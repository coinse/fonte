{"sha": "7f6a0960300792f47ee6c153595e0681ea07cd91", "log": "renamed JsonAdapter annotation to Adapt annotation.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n-import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;\n+import com.google.gson.internal.bind.AdaptAnnotationTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n     // type adapters for composite and user-defined types\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n-    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n+    factories.add(new AdaptAnnotationTypeAdapterFactory(constructorConstructor));\n     factories.add(new ReflectiveTypeAdapterFactory(\n         constructorConstructor, fieldNamingPolicy, excluder));\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/annotations/Adapt.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.google.gson.TypeAdapter;\n+\n+/**\n+ * An annotation that indicates the Gson {@link TypeAdapter} to use with a class or a field.\n+ * Any type adapters registered in {@link com.google.gson.GsonBuilder} supersede the adapter\n+ * specified in this annotation.\n+ *\n+ * <p>Here is an example of how this annotation is used:</p>\n+ * <pre>\n+ * &#64JsonAdapter(UserJsonAdapter.class)\n+ * public class User {\n+ *   public final String firstName, lastName;\n+ *   private User(String firstName, String lastName) {\n+ *     this.firstName = firstName;\n+ *     this.lastName = lastName;\n+ *   }\n+ * }\n+ * public class UserJsonAdapter extends TypeAdapter&lt;User&gt; {\n+ *   &#64Override public void write(JsonWriter out, User user) throws IOException {\n+ *     // implement write: combine firstName and lastName into name\n+ *     out.beginObject();\n+ *     out.name(\"name\");\n+ *     out.value(user.firstName + \" \" + user.lastName);\n+ *     out.endObject();\n+ *     // implement the write method\n+ *   }\n+ *   &#64Override public User read(JsonReader in) throws IOException {\n+ *     // implement read: split name into firstName and lastName\n+ *     in.beginObject();\n+ *     in.nextName();\n+ *     String[] nameParts = in.nextString().split(\" \");\n+ *     in.endObject();\n+ *     return new User(nameParts[0], nameParts[1]);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * Since User class specified UserJsonAdapter.class in &#64JsonAdapter annotation, it\n+ * will automatically be invoked to serialize/deserialize User instances. <br>\n+ *\n+ * If the UserJsonAdapter needs a constructor other than a no-args constructor, you must register\n+ * an {@link com.google.gson.InstanceCreator} for it.\n+ *\n+ * <p> Here is an example of how to apply this annotation to a field.\n+ * <pre>\n+ * private static final class Gadget {\n+ *   &#64JsonAdapter(UserJsonAdapter2.class)\n+ *   final User user;\n+ *   Gadget(User user) {\n+ *     this.user = user;\n+ *   }\n+ * }\n+ * </pre>\n+ * The above annotation will ensure UserJsonAdapter2 supersedes UserJsonAdapter for the user\n+ * field of the Gadget class.\n+ *\n+ * @since 2.3\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @author Jesse Leitch\n+ */\n+// Note that the above example is taken from AdaptAnnotationTest.\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE, ElementType.FIELD})\n+public @interface Adapt {\n+\n+  Class<? extends TypeAdapter<?>> value();\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/AdaptAnnotationTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.annotations.Adapt;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Given a type T, looks for the annotation {@link Adapt} and uses an instance of the\n+ * specified class as the default type adapter.\n+ *\n+ * @since 2.3\n+ */\n+public final class AdaptAnnotationTypeAdapterFactory implements TypeAdapterFactory {\n+\n+  private final ConstructorConstructor constructorConstructor;\n+\n+  public AdaptAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+    this.constructorConstructor = constructorConstructor;\n+  }\n+\n+  @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n+    Class<? super T> clazz = targetType.getRawType();\n+    Adapt annotation = clazz.getAnnotation(Adapt.class);\n+    if (annotation == null) return null;\n+    TypeAdapter adapter = getAnnotationTypeAdapter(gson, constructorConstructor, annotation);\n+    return adapter;\n+  }\n+\n+  static TypeAdapter<?> getAnnotationTypeAdapter(Gson gson,\n+      ConstructorConstructor constructorConstructor, Adapt annotation) {\n+    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n+    ObjectConstructor<? extends TypeAdapter<?>> constructor =\n+        constructorConstructor.get(TypeToken.get(adapterClass));\n+    TypeAdapter<?> adapter = constructor.construct();\n+    Gson.$$Internal.addGeneratedTypeAdapter(gson, adapter);\n+    return adapter;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.annotations.JsonAdapter;\n+import com.google.gson.annotations.Adapt;\n import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n   private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n     TypeAdapter<?> adapter = gson.getAdapter(fieldType);\n     boolean generatedAdapter = Gson.$$Internal.isGeneratedTypeAdapter(gson, adapter);\n-    if (generatedAdapter && field.isAnnotationPresent(JsonAdapter.class)) {\n-      JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n-      return JsonAdapterAnnotationTypeAdapterFactory.getAnnotationTypeAdapter(\n+    if (generatedAdapter && field.isAnnotationPresent(Adapt.class)) {\n+      Adapt annotation = field.getAnnotation(Adapt.class);\n+      return AdaptAnnotationTypeAdapterFactory.getAnnotationTypeAdapter(\n           gson, constructorConstructor, annotation);\n     }\n     return adapter;\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/AdaptAnnotationOnClassesTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.annotations.Adapt;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for the {@link com.google.gson.annotations.Adapt} annotation on classes.\n+ */\n+public final class AdaptAnnotationOnClassesTest extends TestCase {\n+\n+  public void testJsonAdapterInvoked() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new A(\"bar\"));\n+    assertEquals(\"\\\"jsonAdapter\\\"\", json);\n+\n+   // Also invoke the JsonAdapter javadoc sample\n+    json = gson.toJson(new User(\"Inderjeet\", \"Singh\"));\n+    assertEquals(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\", json);\n+    User user = gson.fromJson(\"{'name':'Joel Leitch'}\", User.class);\n+    assertEquals(\"Joel\", user.firstName);\n+    assertEquals(\"Leitch\", user.lastName);\n+  }\n+\n+  public void testRegisteredAdapterOverridesJsonAdapter() {\n+    TypeAdapter<A> typeAdapter = new TypeAdapter<A>() {\n+      @Override public void write(JsonWriter out, A value) throws IOException {\n+        out.value(\"registeredAdapter\");\n+      }\n+      @Override public A read(JsonReader in) throws IOException {\n+        return new A(in.nextString());\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, typeAdapter)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"registeredAdapter\\\"\", json);\n+  }\n+\n+  /**\n+   * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\n+   */\n+  public void testRegisteredSerializerOverridesJsonAdapter() {\n+    JsonSerializer<A> serializer = new JsonSerializer<A>() {\n+      public JsonElement serialize(A src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        return new JsonPrimitive(\"registeredSerializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, serializer)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"registeredSerializer\\\"\", json);\n+    A target = gson.fromJson(\"abcd\", A.class);\n+    assertEquals(\"jsonAdapter\", target.value);\n+  }\n+\n+  /**\n+   * The deserializer overrides Json adapter, but for serializer the jsonAdapter is used.\n+   */\n+  public void testRegisteredDeserializerOverridesJsonAdapter() {\n+    JsonDeserializer<A> deserializer = new JsonDeserializer<A>() {\n+      public A deserialize(JsonElement json, Type typeOfT,\n+          JsonDeserializationContext context) throws JsonParseException {\n+        return new A(\"registeredDeserializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, deserializer)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"jsonAdapter\\\"\", json);\n+    A target = gson.fromJson(\"abcd\", A.class);\n+    assertEquals(\"registeredDeserializer\", target.value);\n+  }\n+\n+  public void testIncorrectTypeAdapterFails() {\n+    try {\n+      String json = new Gson().toJson(new ClassWithIncorrectJsonAdapter(\"bar\"));\n+      fail(json);\n+    } catch (ClassCastException expected) {}\n+  }\n+\n+  public void testSuperclassTypeAdapterNotInvoked() {\n+    String json = new Gson().toJson(new B(\"bar\"));\n+    assertFalse(json.contains(\"jsonAdapter\"));\n+  }\n+\n+  @Adapt(A.JsonAdapter.class)\n+  private static class A {\n+    final String value;\n+    A(String value) {\n+      this.value = value;\n+    }\n+    private static final class JsonAdapter extends TypeAdapter<A> { \n+      @Override public void write(JsonWriter out, A value) throws IOException {\n+        out.value(\"jsonAdapter\");\n+      }\n+      @Override public A read(JsonReader in) throws IOException {\n+        in.nextString();\n+        return new A(\"jsonAdapter\");\n+      }\n+    }\n+  }\n+\n+  private static final class B extends A {\n+    B(String value) {\n+      super(value);\n+    }\n+  }\n+  // Note that the type is NOT TypeAdapter<ClassWithIncorrectJsonAdapter> so this\n+  // should cause error\n+  @Adapt(A.JsonAdapter.class)\n+  private static final class ClassWithIncorrectJsonAdapter {\n+    @SuppressWarnings(\"unused\") final String value;\n+    ClassWithIncorrectJsonAdapter(String value) {\n+      this.value = value;\n+    }\n+  }\n+\n+  // This class is used in JsonAdapter Javadoc as an example\n+  @Adapt(UserJsonAdapter.class)\n+  private static class User {\n+    final String firstName, lastName;\n+    User(String firstName, String lastName) {\n+      this.firstName = firstName;\n+      this.lastName = lastName;\n+    }\n+  }\n+  private static class UserJsonAdapter extends TypeAdapter<User> {\n+    @Override public void write(JsonWriter out, User user) throws IOException {\n+      // implement write: combine firstName and lastName into name\n+      out.beginObject();\n+      out.name(\"name\");\n+      out.value(user.firstName + \" \" + user.lastName);\n+      out.endObject();\n+      // implement the write method\n+    }\n+    @Override public User read(JsonReader in) throws IOException {\n+      // implement read: split name into firstName and lastName\n+      in.beginObject();\n+      in.nextName();\n+      String[] nameParts = in.nextString().split(\" \");\n+      in.endObject();\n+      return new User(nameParts[0], nameParts[1]);\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/AdaptAnnotationOnFieldsTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.annotations.Adapt;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for the {@link com.google.gson.annotations.Adapt} annotation on fields.\n+ */\n+public final class AdaptAnnotationOnFieldsTest extends TestCase {\n+\n+  public void testJsonAdapterInvoked() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\n+    assertEquals(\"{\\\"user\\\":{\\\"firstName\\\":\\\"Inderjeet\\\",\\\"lastName\\\":\\\"Singh\\\"}}\", json);\n+    Computer computer = gson.fromJson(\"{'user':{'firstName':'Jesse','lastName':'Wilson'}}\", Computer.class);\n+    assertEquals(\"Jesse Wilson\", computer.user.name);\n+  }\n+\n+  public void testRegisteredTypeAdapterOverridesFieldAnnotation() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(Part.class, new TypeAdapter<Part>() {\n+        @Override public void write(JsonWriter out, Part part) throws IOException {\n+          out.value(\"registeredAdapter\");\n+        }\n+        @Override public Part read(JsonReader in) throws IOException {\n+          return new Part(in.nextString());\n+        }\n+      }).create();\n+    String json = gson.toJson(new Gadget(new Part(\"screen\")));\n+    assertEquals(\"{\\\"part\\\":\\\"registeredAdapter\\\"}\", json);\n+    Gadget gadget = gson.fromJson(\"{'part':'registeredAdapterValue'}\", Gadget.class);\n+    assertEquals(\"registeredAdapterValue\", gadget.part.name);\n+  }\n+\n+  public void testFieldAnnotationSupersedesClassAnnotation() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer2(new User(\"Inderjeet Singh\")));\n+    assertEquals(\"{\\\"user\\\":\\\"userJsonAdapter2\\\"}\", json);\n+    Computer2 target = gson.fromJson(\"{'user':'userJsonAdapter2Value'}\", Computer2.class);\n+    assertEquals(\"userJsonAdapter2Value\", target.user.name);\n+  }\n+\n+  private static final class Gadget {\n+    @Adapt(PartJsonAdapter.class)\n+    final Part part;\n+    Gadget(Part part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static final class Part {\n+    final String name;\n+    Part(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static class PartJsonAdapter extends TypeAdapter<Part> {\n+    @Override public void write(JsonWriter out, Part part) throws IOException {\n+      out.value(part.name);\n+    }\n+    @Override public Part read(JsonReader in) throws IOException {\n+      in.nextString();\n+      return new Part(\"partJsonAdapter\");\n+    }\n+  }\n+\n+  private static final class Computer {\n+    final User user;\n+    Computer(User user) {\n+      this.user = user;\n+    }\n+  }\n+\n+  @Adapt(UserJsonAdapter.class)\n+  private static class User {\n+    public final String name;\n+    private User(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static class UserJsonAdapter extends TypeAdapter<User> {\n+    @Override public void write(JsonWriter out, User user) throws IOException {\n+      // implement write: combine firstName and lastName into name\n+      out.beginObject();\n+      String[] parts = user.name.split(\" \");\n+      out.name(\"firstName\");\n+      out.value(parts[0]);\n+      out.name(\"lastName\");\n+      out.value(parts[1]);\n+      out.endObject();\n+    }\n+    @Override public User read(JsonReader in) throws IOException {\n+      // implement read: split name into firstName and lastName\n+      in.beginObject();\n+      in.nextName();\n+      String firstName = in.nextString();\n+      in.nextName();\n+      String lastName = in.nextString();\n+      in.endObject();\n+      return new User(firstName + \" \" + lastName);\n+    }\n+  }\n+\n+  private static final class Computer2 {\n+    // overrides the JsonAdapter annotation of User with this\n+    @Adapt(UserJsonAdapter2.class)\n+    final User user;\n+    Computer2(User user) {\n+      this.user = user;\n+    }\n+  }\n+  private static final class UserJsonAdapter2 extends TypeAdapter<User> {\n+    @Override public void write(JsonWriter out, User user) throws IOException {\n+      out.value(\"userJsonAdapter2\");\n+    }\n+    @Override public User read(JsonReader in) throws IOException {\n+      return new User(in.nextString());\n+    }\n+  }\n+}", "timestamp": 1394406534, "metainfo": ""}