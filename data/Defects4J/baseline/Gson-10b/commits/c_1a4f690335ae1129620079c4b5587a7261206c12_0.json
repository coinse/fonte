{"sha": "1a4f690335ae1129620079c4b5587a7261206c12", "log": "Regretfully enable serialization for StringMap and LazilyParsedNumber.  One of our favorite users (my employer!) is stuck in a sad situation where they need to serialize objects returned from Gson; this is a workable escape hatch.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n       return defaultConstructor;\n     }\n \n-    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(rawType);\n+    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\n     if (defaultImplementation != null) {\n       return defaultImplementation;\n     }\n    * subytpes.\n    */\n   @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n-  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(Class<? super T> rawType) {\n+  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n+      Type type, Class<? super T> rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n       if (SortedSet.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n     }\n \n     if (Map.class.isAssignableFrom(rawType)) {\n-      return new ObjectConstructor<T>() {\n-        public T construct() {\n-          // TODO: if the map's key type is a string, should this be StringMap?\n-          return (T) new LinkedHashMap<Object, Object>();\n-        }\n-      };\n+      if (type instanceof ParameterizedType\n+          && ((ParameterizedType) type).getActualTypeArguments()[0] == String.class) {\n+        return new ObjectConstructor<T>() {\n+          public T construct() {\n+            return (T) new StringMap<Object>();\n+          }\n+        };\n+      } else {\n+        return new ObjectConstructor<T>() {\n+          public T construct() {\n+            return (T) new LinkedHashMap<Object, Object>();\n+          }\n+        };\n+      }\n       // TODO: SortedMap ?\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java\n+++ b/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java\n  */\n package com.google.gson.internal;\n \n+import java.io.ObjectStreamException;\n+import java.math.BigDecimal;\n import java.math.BigInteger;\n \n /**\n   public String toString() {\n     return value;\n   }\n+\n+  /**\n+   * If somebody is unlucky enough to have to serialize one of these, serialize\n+   * it as a BigDecimal so that they won't need Gson on the other side to\n+   * deserialize it.\n+   */\n+  private Object writeReplace() throws ObjectStreamException {\n+    return new BigDecimal(value);\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/StringMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/StringMap.java\n \n package com.google.gson.internal;\n \n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n import java.util.AbstractCollection;\n import java.util.AbstractMap;\n import java.util.AbstractSet;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Random;\n  * \n  * <p>This implementation was derived from Android 4.0's LinkedHashMap.\n  */\n-public final class StringMap<V> extends AbstractMap<String, V> {\n+public final class StringMap<V> extends AbstractMap<String, V> implements Serializable {\n   /**\n    * Min capacity (other than zero) for a HashMap. Must be a power of two\n    * greater than 1 (and less than 1 << 30).\n       }\n     }\n     return false; // No entry for key\n+  }\n+\n+  /**\n+   * If somebody is unlucky enough to have to serialize one of these, serialize\n+   * it as a LinkedHashMap so that they won't need Gson on the other side to\n+   * deserialize it. Using serialization defeats our DoS defence, so most apps\n+   * shouldn't use it.\n+   */\n+  private Object writeReplace() throws ObjectStreamException {\n+    return new LinkedHashMap<String, V>(this);\n   }\n \n   private abstract class LinkedHashIterator<T> implements Iterator<T> {\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JavaSerializationTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Check that Gson doesn't return non-serializable data types.\n+ *\n+ * @author Jesse Wilson\n+ */\n+public final class JavaSerializationTest extends TestCase {\n+  private final Gson gson = new Gson();\n+\n+  public void testMapIsSerializable() throws Exception {\n+    Type type = new TypeToken<Map<String, Integer>>() {}.getType();\n+    Map<String, Integer> map = gson.fromJson(\"{\\\"b\\\":1,\\\"c\\\":2,\\\"a\\\":3}\", type);\n+    Map<String, Integer> serialized = serializedCopy(map);\n+    assertEquals(map, serialized);\n+    // Also check that the iteration order is retained.\n+    assertEquals(Arrays.asList(\"b\", \"c\", \"a\"), new ArrayList<String>(serialized.keySet()));\n+  }\n+\n+  public void testListIsSerializable() throws Exception {\n+    Type type = new TypeToken<List<String>>() {}.getType();\n+    List<String> list = gson.fromJson(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", type);\n+    List<String> serialized = serializedCopy(list);\n+    assertEquals(list, serialized);\n+  }\n+\n+  public void testNumberIsSerializable() throws Exception {\n+    Type type = new TypeToken<List<Number>>() {}.getType();\n+    List<Number> list = gson.fromJson(\"[1,3.14,6.673e-11]\", type);\n+    List<Number> serialized = serializedCopy(list);\n+    assertEquals(1.0, serialized.get(0).doubleValue());\n+    assertEquals(3.14, serialized.get(1).doubleValue());\n+    assertEquals(6.673e-11, serialized.get(2).doubleValue());\n+  }\n+\n+  @SuppressWarnings(\"unchecked\") // Serialization promises to return the same type.\n+  private <T> T serializedCopy(T object) throws IOException, ClassNotFoundException {\n+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n+    ObjectOutputStream out = new ObjectOutputStream(bytesOut);\n+    out.writeObject(object);\n+    out.close();\n+    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());\n+    ObjectInputStream in = new ObjectInputStream(bytesIn);\n+    return (T) in.readObject();\n+  }\n+}", "timestamp": 1345042706, "metainfo": ""}