{"sha": "1d2648231f436979b06ccce033946568bdd89f15", "log": "Revised the hashCode of Id to be based just on the value. Also, revised the equals method to return true when the only difference in the type is that one class is Foo and other is Foo<?, ?>. Added a compact toString() in the Id class that prints the type as MyType<Foo,Bar> instead of fully qualified names for each of the types. Added tests regarding object equality for the Id class.", "commit": "\n--- a/wsdef/src/main/java/com/google/gson/webservice/definition/rest/Id.java\n+++ b/wsdef/src/main/java/com/google/gson/webservice/definition/rest/Id.java\n  */\n package com.google.gson.webservice.definition.rest;\n \n+import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n \n /**\n  * An id for a rest resource\n  * @param <R> type variable for the rest resource\n  */\n public final class Id<R> {\n+  private static final long NULL_VALUE = -1;\n   private final long value;\n   private final Type typeOfId;\n \n   private Id(long value, Type typeOfId) {\n+    Preconditions.checkArgument(value != NULL_VALUE);\n     this.value = value;\n     this.typeOfId = typeOfId;\n   }\n     return value;\n   }\n \n+  public static long getValue(Id<?> id) {\n+    return id == null ? NULL_VALUE : id.getValue();\n+  }\n   public Type getTypeOfId() {\n     return typeOfId;\n   }\n \n   @Override\n   public int hashCode() {\n-    final int prime = 31;\n-    int result = 1;\n-    result = prime * result + ((typeOfId == null) ? 0 : typeOfId.hashCode());\n-    result = prime * result + (int)(value ^ (value >>> 32));\n-    return result;\n+    return (int) value;\n   }\n \n   @Override\n     Id<R> other = (Id<R>)obj;\n     if (typeOfId == null) {\n       if (other.typeOfId != null) return false;\n-    } else if (!typeOfId.equals(other.typeOfId)) return false;\n+    } else if (!equivalentTypes(typeOfId, other.typeOfId)) return false;\n     if (value != other.value) return false;\n+    return true;\n+  }\n+\n+  /**\n+   * Returns true for equivalentTypes(Class<?>, Class)\n+   * Visible for testing only \n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  static boolean equivalentTypes(Type type1, Type type2) {\n+    if (type1 instanceof ParameterizedType && type2 instanceof Class) {\n+      return areEquivalentTypes((ParameterizedType)type1, (Class)type2);\n+    } else if (type2 instanceof ParameterizedType && type1 instanceof Class) {\n+      return areEquivalentTypes((ParameterizedType)type2, (Class)type1);\n+    }\n+    return type1.equals(type2);\n+  }\n+\n+  /**\n+   * Visible for testing only\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  static boolean areEquivalentTypes(ParameterizedType type, Class clazz) {\n+    Class rawClass = (Class) type.getRawType();\n+    if (!clazz.equals(rawClass)) {\n+      return false;\n+    }\n+    for (Type typeVariable : type.getActualTypeArguments()) {\n+      if (typeVariable instanceof WildcardType) {\n+        continue;\n+      }\n+      // This is a real parameterized type, not just ?\n+      return false;\n+    }\n     return true;\n   }\n \n \n   @Override\n   public String toString() {\n-    return String.format(\"{value:%s,type:%s}\", value, typeOfId);\n+    String typeAsString = getSimpleTypeName(typeOfId);\n+    return String.format(\"{value:%s,type:%s}\", value, typeAsString);\n+  }\n+\n+  @SuppressWarnings(\"rawtypes\")\n+  private static String getSimpleTypeName(Type type) {\n+    if (type == null) {\n+      return \"null\";\n+    }\n+    if (type instanceof Class) {\n+      return ((Class)type).getSimpleName();\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType pType = (ParameterizedType) type;\n+      StringBuilder sb = new StringBuilder(getSimpleTypeName(pType.getRawType()));\n+      sb.append('<');\n+      boolean first = true;\n+      for (Type argumentType : pType.getActualTypeArguments()) {\n+        if (first) {\n+          first = false;\n+        } else {\n+          sb.append(',');\n+        }\n+        sb.append(getSimpleTypeName(argumentType));\n+      }\n+      sb.append('>');\n+      return sb.toString();\n+    } else if (type instanceof WildcardType) {\n+      return \"?\";\n+    }\n+    return type.toString();\n   }\n }\n--- /dev/null\n+++ b/wsdef/src/test/java/com/google/gson/webservice/definition/rest/IdTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.webservice.definition.rest;\n+\n+import java.lang.reflect.ParameterizedType;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Unit test for {@link Id}\n+ *\n+ * @author inder\n+ */\n+public class IdTest extends TestCase {\n+\n+  public void testRawTypeNotEqualToParameterizedOfConcreteType() {\n+    ParameterizedType type = (ParameterizedType) new TypeToken<Id<Foo>>(){}.getType(); \n+    assertFalse(Id.areEquivalentTypes(type, Id.class));\n+  }\n+\n+  public void testRawTypeEqualToParameterizedOfWildcardType() {\n+    ParameterizedType fooType = (ParameterizedType) new TypeToken<Id<?>>(){}.getType(); \n+    assertTrue(Id.areEquivalentTypes(fooType, Id.class));\n+  }\n+\n+  private static class Foo {\n+  }\n+}", "timestamp": 1287848097, "metainfo": ""}