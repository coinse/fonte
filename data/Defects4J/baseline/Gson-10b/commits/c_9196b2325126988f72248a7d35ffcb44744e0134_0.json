{"sha": "9196b2325126988f72248a7d35ffcb44744e0134", "log": "Refactoring: Separated type handler maps into two types: one for system-specified handlers and one for user-specified. system-specified handlers are the ones that Gson comes with (DefaultTypeAdapters).", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n \n-    map.register(URL.class, URL_TYPE_ADAPTER);\n-    map.register(URI.class, URI_TYPE_ADAPTER);\n-    map.register(UUID.class, UUUID_TYPE_ADAPTER);\n-    map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n-    map.register(Date.class, DATE_TYPE_ADAPTER);\n-    map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\n-    map.register(Timestamp.class, DATE_TYPE_ADAPTER);\n-    map.register(Time.class, TIME_TYPE_ADAPTER);\n-    map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n-    map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n-    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n-    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n-    map.register(BitSet.class, BIT_SET_ADAPTER);\n+    map.register(URL.class, URL_TYPE_ADAPTER, true);\n+    map.register(URI.class, URI_TYPE_ADAPTER, true);\n+    map.register(UUID.class, UUUID_TYPE_ADAPTER, true);\n+    map.register(Locale.class, LOCALE_TYPE_ADAPTER, true);\n+    map.register(Date.class, DATE_TYPE_ADAPTER, true);\n+    map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER, true);\n+    map.register(Timestamp.class, DATE_TYPE_ADAPTER, true);\n+    map.register(Time.class, TIME_TYPE_ADAPTER, true);\n+    map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);\n+    map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);\n+    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER, true);\n+    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER, true);\n+    map.register(BitSet.class, BIT_SET_ADAPTER, true);\n \n     // Add primitive serializers\n-    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n-    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n-    map.register(Byte.class, BYTE_TYPE_ADAPTER);\n-    map.register(byte.class, BYTE_TYPE_ADAPTER);\n-    map.register(Character.class, CHARACTER_TYPE_ADAPTER);\n-    map.register(char.class, CHARACTER_TYPE_ADAPTER);\n-    map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n-    map.register(int.class, INTEGER_TYPE_ADAPTER);\n-    map.register(Number.class, NUMBER_TYPE_ADAPTER);\n-    map.register(Short.class, SHORT_TYPE_ADAPTER);\n-    map.register(short.class, SHORT_TYPE_ADAPTER);\n-    map.register(String.class, STRING_TYPE_ADAPTER);\n-    map.register(StringBuilder.class, STRING_BUILDER_TYPE_ADAPTER);\n-    map.register(StringBuffer.class, STRING_BUFFER_TYPE_ADAPTER);\n+    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER, true);\n+    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER, true);\n+    map.register(Byte.class, BYTE_TYPE_ADAPTER, true);\n+    map.register(byte.class, BYTE_TYPE_ADAPTER, true);\n+    map.register(Character.class, CHARACTER_TYPE_ADAPTER, true);\n+    map.register(char.class, CHARACTER_TYPE_ADAPTER, true);\n+    map.register(Integer.class, INTEGER_TYPE_ADAPTER, true);\n+    map.register(int.class, INTEGER_TYPE_ADAPTER, true);\n+    map.register(Number.class, NUMBER_TYPE_ADAPTER, true);\n+    map.register(Short.class, SHORT_TYPE_ADAPTER, true);\n+    map.register(short.class, SHORT_TYPE_ADAPTER, true);\n+    map.register(String.class, STRING_TYPE_ADAPTER, true);\n+    map.register(StringBuilder.class, STRING_BUILDER_TYPE_ADAPTER, true);\n+    map.register(StringBuffer.class, STRING_BUFFER_TYPE_ADAPTER, true);\n \n     map.makeUnmodifiable();\n     return map;\n   private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultHierarchySerializers() {\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n-    map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\n-    map.registerForTypeHierarchy(InetAddress.class, INET_ADDRESS_ADAPTER);\n-    map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n-    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER, true);\n+    map.registerForTypeHierarchy(InetAddress.class, INET_ADDRESS_ADAPTER, true);\n+    map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER, true);\n+    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER, true);\n     map.makeUnmodifiable();\n     return map;\n   }\n   private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n-    map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\n-    map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\n-    map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\n-    map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\n-    map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n-    map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\n-    map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\n-    map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER));\n-    map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n-    map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n-    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n-    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n-    map.register(BitSet.class, BIT_SET_ADAPTER);\n+    map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER), true);\n+    map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER), true);\n+    map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER), true);\n+    map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER), true);\n+    map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER), true);\n+    map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER), true);\n+    map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER), true);\n+    map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER), true);\n+    map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);\n+    map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);\n+    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER, true);\n+    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER, true);\n+    map.register(BitSet.class, BIT_SET_ADAPTER, true);\n \n     // Add primitive deserializers\n-    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n-    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n-    map.register(Byte.class, BYTE_TYPE_ADAPTER);\n-    map.register(byte.class, BYTE_TYPE_ADAPTER);\n-    map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\n-    map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\n-    map.register(Double.class, DOUBLE_TYPE_ADAPTER);\n-    map.register(double.class, DOUBLE_TYPE_ADAPTER);\n-    map.register(Float.class, FLOAT_TYPE_ADAPTER);\n-    map.register(float.class, FLOAT_TYPE_ADAPTER);\n-    map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n-    map.register(int.class, INTEGER_TYPE_ADAPTER);\n-    map.register(Long.class, LONG_DESERIALIZER);\n-    map.register(long.class, LONG_DESERIALIZER);\n-    map.register(Number.class, NUMBER_TYPE_ADAPTER);\n-    map.register(Short.class, SHORT_TYPE_ADAPTER);\n-    map.register(short.class, SHORT_TYPE_ADAPTER);\n-    map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER));\n-    map.register(StringBuilder.class, wrapDeserializer(STRING_BUILDER_TYPE_ADAPTER));\n-    map.register(StringBuffer.class, wrapDeserializer(STRING_BUFFER_TYPE_ADAPTER));\n+    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER, true);\n+    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER, true);\n+    map.register(Byte.class, BYTE_TYPE_ADAPTER, true);\n+    map.register(byte.class, BYTE_TYPE_ADAPTER, true);\n+    map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER), true);\n+    map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER), true);\n+    map.register(Double.class, DOUBLE_TYPE_ADAPTER, true);\n+    map.register(double.class, DOUBLE_TYPE_ADAPTER, true);\n+    map.register(Float.class, FLOAT_TYPE_ADAPTER, true);\n+    map.register(float.class, FLOAT_TYPE_ADAPTER, true);\n+    map.register(Integer.class, INTEGER_TYPE_ADAPTER, true);\n+    map.register(int.class, INTEGER_TYPE_ADAPTER, true);\n+    map.register(Long.class, LONG_DESERIALIZER, true);\n+    map.register(long.class, LONG_DESERIALIZER, true);\n+    map.register(Number.class, NUMBER_TYPE_ADAPTER, true);\n+    map.register(Short.class, SHORT_TYPE_ADAPTER, true);\n+    map.register(short.class, SHORT_TYPE_ADAPTER, true);\n+    map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER), true);\n+    map.register(StringBuilder.class, wrapDeserializer(STRING_BUILDER_TYPE_ADAPTER), true);\n+    map.register(StringBuffer.class, wrapDeserializer(STRING_BUFFER_TYPE_ADAPTER), true);\n \n     map.makeUnmodifiable();\n     return map;\n   private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultHierarchyDeserializers() {\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n-    map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\n-    map.registerForTypeHierarchy(InetAddress.class, wrapDeserializer(INET_ADDRESS_ADAPTER));\n-    map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n-    map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n+    map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER), true);\n+    map.registerForTypeHierarchy(InetAddress.class, wrapDeserializer(INET_ADDRESS_ADAPTER), true);\n+    map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER), true);\n+    map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER), true);\n     map.makeUnmodifiable();\n     return map;\n   }\n \n     // Map Instance Creators\n     map.registerForTypeHierarchy(Map.class,\n-        new DefaultConstructorCreator<Map>(LinkedHashMap.class, allocator));\n+        new DefaultConstructorCreator<Map>(LinkedHashMap.class, allocator), true);\n \n     // Add Collection type instance creators\n     DefaultConstructorCreator<List> listCreator =\n         new DefaultConstructorCreator<Set>(HashSet.class, allocator);\n     DefaultConstructorCreator<SortedSet> sortedSetCreator =\n         new DefaultConstructorCreator<SortedSet>(TreeSet.class, allocator);\n-    map.registerForTypeHierarchy(Collection.class, listCreator);\n-    map.registerForTypeHierarchy(Queue.class, queueCreator);\n-    map.registerForTypeHierarchy(Set.class, setCreator);\n-    map.registerForTypeHierarchy(SortedSet.class, sortedSetCreator);\n+    map.registerForTypeHierarchy(Collection.class, listCreator, true);\n+    map.registerForTypeHierarchy(Queue.class, queueCreator, true);\n+    map.registerForTypeHierarchy(Set.class, setCreator, true);\n+    map.registerForTypeHierarchy(SortedSet.class, sortedSetCreator, true);\n \n     map.makeUnmodifiable();\n     return map;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n     deserializeExclusionStrategies.add(strategy);\n     return this;\n   }\n+\n   /**\n    * Configures Gson to output Json that fits in a page for pretty printing. This option only\n    * affects Json serialization.\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n+    return registerTypeAdapter(type, typeAdapter, false);\n+  }\n+\n+  private GsonBuilder registerTypeAdapter(Type type, Object typeAdapter, boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n+      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter, isSystem);\n     }\n     if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializer(type, (JsonSerializer<?>) typeAdapter);\n+      registerSerializer(type, (JsonSerializer<?>) typeAdapter, isSystem);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter);\n+      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter, isSystem);\n     }\n     return this;\n   }\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n-      InstanceCreator<? extends T> instanceCreator) {\n-    instanceCreators.register(typeOfT, instanceCreator);\n+      InstanceCreator<? extends T> instanceCreator, boolean isSystem) {\n+    instanceCreators.register(typeOfT, instanceCreator, isSystem);\n     return this;\n   }\n \n    * @param serializer the custom serializer\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n-  private <T> GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer) {\n-    serializers.register(typeOfT, serializer);\n+  private <T> GsonBuilder registerSerializer(Type typeOfT, JsonSerializer<T> serializer,\n+      boolean isSystem) {\n+    serializers.register(typeOfT, serializer, isSystem);\n     return this;\n   }\n \n    * @param deserializer the custom deserializer\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n-  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) {\n-    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer));\n+  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer,\n+      boolean isSystem) {\n+    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer), isSystem);\n     return this;\n   }\n \n    * @since 1.7\n    */\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n+    return registerTypeHierarchyAdapter(baseType, typeAdapter, false);\n+  }\n+\n+  private GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter,\n+      boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n+      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter, isSystem);\n     }\n     if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter);\n+      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter, isSystem);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n+      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter, isSystem);\n     }\n     return this;\n   }\n \n   private <T> GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT,\n-      InstanceCreator<? extends T> instanceCreator) {\n-    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator);\n+      InstanceCreator<? extends T> instanceCreator, boolean isSystem) {\n+    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator, isSystem);\n     return this;\n   }\n \n   private <T> GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT,\n-      final JsonSerializer<T> serializer) {\n-    serializers.registerForTypeHierarchy(classOfT, serializer);\n+      JsonSerializer<T> serializer, boolean isSystem) {\n+    serializers.registerForTypeHierarchy(classOfT, serializer, isSystem);\n     return this;\n   }\n \n   private <T> GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT,\n-      JsonDeserializer<T> deserializer) {\n+      JsonDeserializer<T> deserializer, boolean isSystem) {\n     deserializers.registerForTypeHierarchy(classOfT,\n-        new JsonDeserializerExceptionWrapper<T>(deserializer));\n+        new JsonDeserializerExceptionWrapper<T>(deserializer), isSystem);\n     return this;\n   }\n \n   private static <T> void registerIfAbsent(Class<?> type,\n       ParameterizedTypeHandlerMap<T> adapters, T adapter) {\n     if (!adapters.hasSpecificHandlerFor(type)) {\n-      adapters.register(type, adapter);\n+      adapters.register(type, adapter, false);\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n final class ParameterizedTypeHandlerMap<T> {\n   private static final Logger logger =\n       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n-  private final Map<Type, T> map = new HashMap<Type, T>();\n-  private final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  /**\n+   * Map that is meant for storing default type adapters\n+   */\n+  private final Map<Type, T> systemMap = new HashMap<Type, T>();\n+  private final Map<Type, T> userMap = new HashMap<Type, T>();\n+  /**\n+   * List of default type hierarchy adapters\n+   */\n+  private final List<Pair<Class<?>, T>> systemTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  private final List<Pair<Class<?>, T>> userTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n   private boolean modifiable = true;\n \n-  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n+  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value, boolean isSystem) {\n     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n-    registerForTypeHierarchy(pair);\n-  }\n-\n-  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n-    if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n-    }\n-    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n+    registerForTypeHierarchy(pair, isSystem);\n+  }\n+\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair, boolean isSystem) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    List<Pair<Class<?>, T>> typeHierarchyList = isSystem ? systemTypeHierarchyList : userTypeHierarchyList;\n+    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first, typeHierarchyList);\n     if (index >= 0) {\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n       typeHierarchyList.remove(index);\n     }\n-    index = getIndexOfAnOverriddenHandler(pair.first);\n+    index = getIndexOfAnOverriddenHandler(pair.first, typeHierarchyList);\n     if (index >= 0) {\n       throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n           + \" hides the previously registered type hierarchy handler for \"\n     typeHierarchyList.add(0, pair);\n   }\n \n-  private int getIndexOfAnOverriddenHandler(Class<?> type) {\n+  private static <T> int getIndexOfAnOverriddenHandler(Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n     for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n       Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n       if (type.isAssignableFrom(entry.first)) {\n     return -1;\n   }\n \n-  public synchronized void register(Type typeOfT, T value) {\n+  public synchronized void register(Type typeOfT, T value, boolean isSystem) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n     if (hasSpecificHandlerFor(typeOfT)) {\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n     }\n+    Map<Type, T> map = isSystem ? systemMap : userMap;\n     map.put(typeOfT, value);\n   }\n \n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n-    for (Map.Entry<Type, T> entry : other.map.entrySet()) {\n-      if (!map.containsKey(entry.getKey())) {\n-        register(entry.getKey(), entry.getValue());\n+    for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n+      if (!userMap.containsKey(entry.getKey())) {\n+        register(entry.getKey(), entry.getValue(), false);\n+      }\n+    }\n+    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n+      if (!systemMap.containsKey(entry.getKey())) {\n+        register(entry.getKey(), entry.getValue(), true);\n       }\n     }\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n-    for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n-      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\n+    for (int i = other.userTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n+      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, userTypeHierarchyList);\n       if (index < 0) {\n-        registerForTypeHierarchy(entry);\n+        registerForTypeHierarchy(entry, false);\n+      }\n+    }\n+    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n+      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, systemTypeHierarchyList);\n+      if (index < 0) {\n+        registerForTypeHierarchy(entry, true);\n       }\n     }\n   }\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n-    for (Map.Entry<Type, T> entry : other.map.entrySet()) {\n-      register(entry.getKey(), entry.getValue());\n+    for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n+      register(entry.getKey(), entry.getValue(), false);\n+    }\n+    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n+      register(entry.getKey(), entry.getValue(), true);\n     }\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n-    for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n-      registerForTypeHierarchy(entry);\n+    for (int i = other.userTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n+      registerForTypeHierarchy(entry, false);\n+    }\n+    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n+      registerForTypeHierarchy(entry, true);\n     }\n   }\n \n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n-    if (!map.containsKey(typeOfT)) {\n-      register(typeOfT, value);\n+    if (!userMap.containsKey(typeOfT)) {\n+      register(typeOfT, value, false);\n     }\n   }\n \n   }\n \n   public synchronized T getHandlerFor(Type type) {\n-    T handler = map.get(type);\n-    if (handler == null) {\n-      Class<?> rawClass = $Gson$Types.getRawType(type);\n-      if (rawClass != type) {\n-        handler = getHandlerFor(rawClass);\n-      }\n-      if (handler == null) {\n-        // check if something registered for type hierarchy\n-        handler = getHandlerForTypeHierarchy(rawClass);\n-      }\n-    }\n+    T handler = userMap.get(type);\n+    if (handler != null) {\n+      return handler;\n+    }\n+    handler = systemMap.get(type);\n+    if (handler != null) {\n+      return handler;\n+    }\n+    Class<?> rawClass = $Gson$Types.getRawType(type);\n+    if (rawClass != type) {\n+      handler = getHandlerFor(rawClass);\n+      if (handler != null) {\n+        return handler;\n+      }\n+    }\n+    // check if something registered for type hierarchy\n+    handler = getHandlerForTypeHierarchy(rawClass);\n     return handler;\n   }\n \n   private T getHandlerForTypeHierarchy(Class<?> type) {\n-    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for (Pair<Class<?>, T> entry : userTypeHierarchyList) {\n       if (entry.first.isAssignableFrom(type)) {\n         return entry.second;\n       }\n     }\n+    for (Pair<Class<?>, T> entry : systemTypeHierarchyList) {\n+      if (entry.first.isAssignableFrom(type)) {\n+        return entry.second;\n+      }\n+    }\n     return null;\n   }\n \n   public synchronized boolean hasSpecificHandlerFor(Type type) {\n-    return map.containsKey(type);\n-  }\n-\n-  private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) {\n+    return userMap.containsKey(type) || systemMap.containsKey(type);\n+  }\n+\n+  private static <T> int getIndexOfSpecificHandlerForTypeHierarchy(\n+      Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n     for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n       if (type.equals(typeHierarchyList.get(i).first)) {\n         return i;\n     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>();\n     // Instead of individually registering entries in the map, make an efficient copy\n     // of the list and map\n-    copy.map.putAll(map);\n-    copy.typeHierarchyList.addAll(typeHierarchyList);\n+    \n+    // TODO (inder): Performance optimization. We can probably just share the\n+    // systemMap and systemTypeHierarchyList instead of making copies\n+    copy.systemMap.putAll(systemMap);\n+    copy.userMap.putAll(userMap);\n+    copy.systemTypeHierarchyList.addAll(systemTypeHierarchyList);\n+    copy.userTypeHierarchyList.addAll(userTypeHierarchyList);\n     return copy;\n   }\n \n   @Override\n   public String toString() {\n-    StringBuilder sb = new StringBuilder(\"{mapForTypeHierarchy:{\");\n+    StringBuilder sb = new StringBuilder(\"{userTypeHierarchyList:{\");\n+    appendList(sb, userTypeHierarchyList);\n+    sb.append(\"},systemTypeHierarchyList:{\");\n+    appendList(sb, systemTypeHierarchyList);\n+    sb.append(\"},userMap:{\");\n+    appendMap(sb, userMap);\n+    sb.append(\"},systemMap:{\");\n+    appendMap(sb, systemMap);\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  private void appendList(StringBuilder sb, List<Pair<Class<?>,T>> list) {\n     boolean first = true;\n-    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for (Pair<Class<?>, T> entry : list) {\n       if (first) {\n         first = false;\n       } else {\n       sb.append(typeToString(entry.first)).append(':');\n       sb.append(entry.second);\n     }\n-    sb.append(\"},map:{\");\n-    first = true;\n+  }\n+\n+  private void appendMap(StringBuilder sb, Map<Type, T> map) {\n+    boolean first = true;\n     for (Map.Entry<Type, T> entry : map.entrySet()) {\n       if (first) {\n         first = false;\n       sb.append(typeToString(entry.getKey())).append(':');\n       sb.append(entry.getValue());\n     }\n-    sb.append(\"}\");\n-    return sb.toString();\n   }\n \n   private String typeToString(Type type) {\n--- a/gson/src/test/java/com/google/gson/MappedObjectConstructorTest.java\n+++ b/gson/src/test/java/com/google/gson/MappedObjectConstructorTest.java\n   }\n \n   public void testInstanceCreatorTakesTopPrecedence() throws Exception {\n-    creatorMap.register(ObjectWithDefaultConstructor.class, new MyInstanceCreator());\n+    creatorMap.register(ObjectWithDefaultConstructor.class, new MyInstanceCreator(), false);\n     ObjectWithDefaultConstructor obj =\n         constructor.construct(ObjectWithDefaultConstructor.class);\n     assertEquals(\"instanceCreator\", obj.stringValue);\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n   public void testHasGenericButNotSpecific() throws Exception {\n     Type specificType = new TypeToken<List<String>>() {}.getType();\n     String handler = \"blah\";\n-    paramMap.register(List.class, handler);\n+    paramMap.register(List.class, handler, false);\n \n     assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n     assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n   public void testHasSpecificType() throws Exception {\n     Type specificType = new TypeToken<List<String>>() {}.getType();\n     String handler = \"blah\";\n-    paramMap.register(specificType, handler);\n+    paramMap.register(specificType, handler, false);\n \n     assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n     assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n   public void testTypeOverridding() throws Exception {\n     String handler1 = \"blah1\";\n     String handler2 = \"blah2\";\n-    paramMap.register(String.class, handler1);\n-    paramMap.register(String.class, handler2);\n+    paramMap.register(String.class, handler1, false);\n+    paramMap.register(String.class, handler2, false);\n \n     assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n     assertEquals(handler2, paramMap.getHandlerFor(String.class));\n   public void testMakeUnmodifiable() throws Exception {\n     paramMap.makeUnmodifiable();\n     try {\n-     paramMap.register(String.class, \"blah\");\n+     paramMap.register(String.class, \"blah\", false);\n      fail(\"Can not register handlers when map is unmodifiable\");\n     } catch (IllegalStateException expected) { }\n   }\n \n   public void testTypeHierarchy() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n     String handler = paramMap.getHandlerFor(Sub.class);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testTypeHierarchyMultipleHandlers() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n-    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n     String handler = paramMap.getHandlerFor(SubOfSub.class);\n     assertEquals(\"subHandler\", handler);\n   }\n \n   public void testTypeHierarchyRegisterIfAbsent() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>();\n-    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\");\n+    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\", false);\n     paramMap.registerIfAbsent(otherMap);\n     String handler = paramMap.getHandlerFor(Base.class);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testReplaceExistingTypeHierarchyHandler() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n-    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\", false);\n     String handler = paramMap.getHandlerFor(Base.class);\n     assertEquals(\"base2Handler\", handler);\n   }\n \n   public void testHidingExistingTypeHierarchyHandlerIsDisallowed() {\n-    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n     try {\n-      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n       fail(\"A handler that hides an existing type hierarchy handler is not allowed\");\n     } catch (IllegalArgumentException expected) {\n     }", "timestamp": 1308952379, "metainfo": ""}