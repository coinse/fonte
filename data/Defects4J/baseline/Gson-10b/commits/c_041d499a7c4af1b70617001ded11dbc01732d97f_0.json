{"sha": "041d499a7c4af1b70617001ded11dbc01732d97f", "log": "Fix serialization where one type depends (possibly indireclty) on itself!", "commit": "\n--- a/extras/src/main/java/com/google/gson/mini/MiniGson.java\n+++ b/extras/src/main/java/com/google/gson/mini/MiniGson.java\n package com.google.gson.mini;\n \n import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * A basic binding between JSON and Java objects.\n  */\n public final class MiniGson {\n+  /**\n+   * This thread local guards against reentrant calls to getAdapter(). In\n+   * certain object graphs, creating an adapter for a type may recursively\n+   * require an adapter for the same type! Without intervention, the recursive\n+   * lookup would stack overflow. We cheat by returning a proxy type adapter.\n+   * The proxy is wired up once the initial adapter has been created.\n+   */\n+  private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n+      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>() {\n+    @Override protected Map<TypeToken<?>, FutureTypeAdapter<?>> initialValue() {\n+      return new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n+    }\n+  };\n+\n   private final List<TypeAdapter.Factory> factories;\n \n   private MiniGson(Builder builder) {\n    *     deserialize {@code type}.\n    */\n   public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n-    // TODO: create a cache here\n-    for (TypeAdapter.Factory factory : factories) {\n-      TypeAdapter<T> candidate = factory.create(this, type);\n-      if (candidate != null) {\n-        return candidate;\n+    // TODO: create a cache!\n+\n+    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n+    @SuppressWarnings(\"unchecked\") // the key and value type parameters always agree\n+        FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n+    if (ongoingCall != null) {\n+      return ongoingCall;\n+    }\n+\n+    FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n+    threadCalls.put(type, call);\n+    try {\n+      for (TypeAdapter.Factory factory : factories) {\n+        TypeAdapter<T> candidate = factory.create(this, type);\n+        if (candidate != null) {\n+          call.setDelegate(candidate);\n+          return candidate;\n+        }\n       }\n+      throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    } finally {\n+      threadCalls.remove(type);\n     }\n-    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+  }\n+\n+  static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n+    private TypeAdapter<T> delegate;\n+\n+    public void setDelegate(TypeAdapter<T> typeAdapter) {\n+      if (delegate != null) {\n+        throw new AssertionError();\n+      }\n+      delegate = typeAdapter;\n+    }\n+\n+    @Override public T read(JsonReader reader) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      return delegate.read(reader);\n+    }\n+\n+    @Override public void write(JsonWriter writer, T value) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      delegate.write(writer, value);\n+    }\n   }\n \n   /**\n--- a/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n+++ b/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n     assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));\n   }\n \n+  public void testSerializeRecursive() throws IOException {\n+    TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);\n+    Node root = new Node(\"root\");\n+    root.left = new Node(\"left\");\n+    root.right = new Node(\"right\");\n+    assertEquals(\"{'label':'root',\"\n+        + \"'left':{'label':'left','left':null,'right':null},\"\n+        + \"'right':{'label':'right','left':null,'right':null}}\",\n+        nodeAdapter.toJson(root).replace('\"', '\\''));\n+  }\n+\n   static class Truck {\n     double horsePower;\n     List<Person> passengers = Collections.emptyList();\n       return name.hashCode() ^ age;\n     }\n   }\n+\n+  static class Node {\n+    String label;\n+    Node left;\n+    Node right;\n+    Node(String label) {\n+      this.label = label;\n+    }\n+    public Node() {} // TODO: use Joel's constructor code so we don't need this\n+  }\n }", "timestamp": 1310499567, "metainfo": ""}