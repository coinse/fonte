{"sha": "ce79e16f7a1811e55b140980ebf6f8f68c0370fd", "log": "StringPooling. This makes things up to 20% faster on dalvikvm for some data sets.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n \n   /** The only non-execute prefix this parser permits */\n   private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n+\n+  private final StringPool stringPool = new StringPool();\n \n   /** The input JSON. */\n   private final Reader in;\n           if (skipping) {\n             return \"skipped!\";\n           } else if (builder == null) {\n-            return new String(buffer, start, pos - start - 1);\n+            return stringPool.get(buffer, start, pos - start - 1);\n           } else {\n             builder.append(buffer, start, pos - start - 1);\n             return builder.toString();\n           if (skipping) {\n             return \"skipped!\";\n           } else if (builder == null) {\n-            return new String(buffer, start, pos - start);\n+            return stringPool.get(buffer, start, pos - start);\n           } else {\n             builder.append(buffer, start, pos - start);\n             return builder.toString();\n       if (pos + 4 > limit && !fillBuffer(4)) {\n         throw syntaxError(\"Unterminated escape sequence\");\n       }\n-      String hex = new String(buffer, pos, 4);\n+      String hex = stringPool.get(buffer, pos, 4);\n       pos += 4;\n       return (char) Integer.parseInt(hex, 16);\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/StringPool.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+/**\n+ * A pool of string instances. Unlike the {@link String#intern() VM's\n+ * interned strings}, this pool provides no guarantee of reference equality.\n+ * It is intended only to save allocations. This class is not thread safe.\n+ */\n+final class StringPool {\n+\n+  private final String[] pool = new String[512];\n+\n+  /**\n+   * Returns a string equal to {@code new String(array, start, length)}.\n+   */\n+  public String get(char[] array, int start, int length) {\n+    // Compute an arbitrary hash of the content\n+    int hashCode = 0;\n+    for (int i = start; i < start + length; i++) {\n+      hashCode = (hashCode * 31) + array[i];\n+    }\n+\n+    // Pick a bucket using Doug Lea's supplemental secondaryHash function (from HashMap)\n+    hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);\n+    hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);\n+    int index = hashCode & (pool.length - 1);\n+\n+    String pooled = pool[index];\n+    if (pooled == null || pooled.length() != length) {\n+      String result = new String(array, start, length);\n+      pool[index] = result;\n+      return result;\n+    }\n+\n+    for (int i = 0; i < length; i++) {\n+      if (pooled.charAt(i) != array[start + i]) {\n+        String result = new String(array, start, length);\n+        pool[index] = result;\n+        return result;\n+      }\n+    }\n+\n+    return pooled;\n+  }\n+}", "timestamp": 1304028486, "metainfo": ""}