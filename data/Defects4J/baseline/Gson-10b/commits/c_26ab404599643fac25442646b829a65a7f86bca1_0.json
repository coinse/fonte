{"sha": "26ab404599643fac25442646b829a65a7f86bca1", "log": "Cleanup names for TypeAdapters.", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n     return registerSubtype(type, type.getSimpleName());\n   }\n \n-  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n     if (type.getRawType() != baseType) {\n       return null;\n     }\n     final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n         = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n     for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n-      TypeAdapter<?> delegate = context.getNextAdapter(this, TypeToken.get(entry.getValue()));\n+      TypeAdapter<?> delegate = gson.getNextAdapter(this, TypeToken.get(entry.getValue()));\n       labelToDelegate.put(entry.getKey(), delegate);\n       subtypeToDelegate.put(entry.getValue(), delegate);\n     }\n           throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n               + label + \"; did you forget to register a subtype?\");\n         }\n-        return delegate.fromJsonElement(jsonElement);\n+        return delegate.fromJsonTree(jsonElement);\n       }\n \n       @Override public void write(JsonWriter writer, T value) throws IOException {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \"; did you forget to register a subtype?\");\n         }\n-        JsonObject jsonObject = delegate.toJsonElement(value).getAsJsonObject();\n+        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\n         if (jsonObject.has(typeFieldName)) {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \" because it already defines a field named \" + typeFieldName);\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n     }\n \n     @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n       boolean matches = exactType != null\n           ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()\n           : hierarchyType.isAssignableFrom(type.getRawType());\n       return matches\n           ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,\n-              (JsonDeserializer<T>) deserializer, context, type, this)\n+              (JsonDeserializer<T>) deserializer, gson, type, this)\n           : null;\n     }\n   }\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n \n   public final String toJson(T value) throws IOException {\n     StringWriter stringWriter = new StringWriter();\n-    write(stringWriter, value);\n+    toJson(stringWriter, value);\n     return stringWriter.toString();\n   }\n \n-  public final void write(Writer out, T value) throws IOException {\n+  public final void toJson(Writer out, T value) throws IOException {\n     JsonWriter writer = new JsonWriter(out);\n     write(writer, value);\n   }\n \n   public final T fromJson(String json) throws IOException {\n-    return read(new StringReader(json));\n+    return fromJson(new StringReader(json));\n   }\n \n-  public final T read(Reader in) throws IOException {\n+  public final T fromJson(Reader in) throws IOException {\n     JsonReader reader = new JsonReader(in);\n     reader.setLenient(true);\n     return read(reader);\n   }\n \n-  public JsonElement toJsonElement(T src) {\n+  public JsonElement toJsonTree(T src) {\n     try {\n       JsonElementWriter jsonWriter = new JsonElementWriter();\n       jsonWriter.setLenient(true);\n     }\n   }\n \n-  public T fromJsonElement(JsonElement json) {\n+  public T fromJsonTree(JsonElement json) {\n     try {\n       JsonReader jsonReader = new JsonElementReader(json);\n       jsonReader.setLenient(true);\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n     return result;\n   }\n \n-  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> type) {\n+  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\n     Class<?> rawType = type.getRawType();\n     final boolean skipSerialize = excludeClass(rawType, true);\n     final boolean skipDeserialize = excludeClass(rawType, false);\n         TypeAdapter<T> d = delegate;\n         return d != null\n             ? d\n-            : (delegate = context.getNextAdapter(Excluder.this, type));\n+            : (delegate = gson.getNextAdapter(Excluder.this, type));\n       }\n     };\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n         return null;\n       }\n \n       Type componentType = $Gson$Types.getArrayComponentType(type);\n-      TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));\n+      TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\n       return new ArrayTypeAdapter(\n-          context, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n+              gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n     }\n   };\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n     this.constructorConstructor = constructorConstructor;\n   }\n \n-  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n     Type type = typeToken.getType();\n \n     Class<? super T> rawType = typeToken.getRawType();\n     }\n \n     Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n-    TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));\n+    TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n \n     @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\n-    TypeAdapter<T> result = new Adapter(context, elementType, elementTypeAdapter, constructor);\n+    TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\n     return result;\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n public final class DateTypeAdapter extends TypeAdapter<Date> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n     }\n   };\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n     this.complexMapKeySerialization = complexMapKeySerialization;\n   }\n \n-  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n     Type type = typeToken.getType();\n \n     Class<? super T> rawType = typeToken.getRawType();\n \n     Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n-    TypeAdapter<?> keyAdapter = getKeyAdapter(context, keyAndValueTypes[0]);\n-    TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+    TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\n+    TypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n \n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     // we don't define a type parameter for the key or value types\n-    TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,\n+    TypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\n         keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n   }\n \n       List<V> values = new ArrayList<V>(map.size());\n       for (Map.Entry<K, V> entry : map.entrySet()) {\n-        JsonElement keyElement = keyTypeAdapter.toJsonElement(entry.getKey());\n+        JsonElement keyElement = keyTypeAdapter.toJsonTree(entry.getKey());\n         keys.add(keyElement);\n         values.add(entry.getValue());\n         hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n public final class ObjectTypeAdapter extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\")\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n       if (type.getRawType() == Object.class) {\n-        return (TypeAdapter<T>) new ObjectTypeAdapter(context);\n+        return (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n       }\n       return null;\n     }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n     return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n   }\n \n-  public <T> TypeAdapter<T> create(Gson context, final TypeToken<T> type) {\n+  public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n     Class<? super T> raw = type.getRawType();\n \n     if (!Object.class.isAssignableFrom(raw)) {\n     }\n \n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(type);\n-    return new Adapter<T>(constructor, getBoundFields(context, type, raw));\n+    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n   }\n \n   private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n--- a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == java.sql.Date.class\n           ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n     }\n--- a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n public final class TimeTypeAdapter extends TypeAdapter<Time> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n     }\n   };\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n   public static final TypeAdapter.Factory TIMESTAMP_FACTORY = new TypeAdapter.Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       if (typeToken.getRawType() != Timestamp.class) {\n         return null;\n       }\n \n-      final TypeAdapter<Date> dateTypeAdapter = context.getAdapter(Date.class);\n+      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n       return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n         @Override public Timestamp read(JsonReader reader) throws IOException {\n           Date date = dateTypeAdapter.read(reader);\n   public static <TT> TypeAdapter.Factory newEnumTypeHierarchyFactory(final Class<TT> clazz) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return clazz.isAssignableFrom(rawType)\n           ? (TypeAdapter<T>) new EnumTypeAdapter(rawType) : null;\n       final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n     };\n       final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       @Override public String toString() {\n       final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       final Class<TT> clazz, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\")\n-      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return clazz.isAssignableFrom(typeToken.getRawType()) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       @Override public String toString() {", "timestamp": 1322866650, "metainfo": ""}