{"sha": "6e59e502c2461c11d0e6099f10f65c666acabc45", "log": "Refactored the Async parser interface out of JsonParser into a new class JsonParserAsync. Updated the JsonParser to detect Eof and return a null instead of throwing a ParseException.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root = new JsonParser().parse(json);\n-    JsonDeserializationContext context = new JsonDeserializationContextDefault(\n-        createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n-    T target = (T) context.deserialize(root, typeOfT);\n-    return target;\n+    return fromJson(root, typeOfT);\n   }\n \n   /**\n    */\n   @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonParseException {\n+    if (json == null) {\n+      return null;\n+    }\n     JsonDeserializationContext context = new JsonDeserializationContextDefault(\n         createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n     T target = (T) context.deserialize(json, typeOfT);\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n  */\n package com.google.gson;\n \n+import java.io.EOFException;\n import java.io.Reader;\n import java.io.StringReader;\n \n  */\n public final class JsonParser {\n   \n-  /**\n-   * Interface to provide ability to read multiple {@link JsonElement}s from a stream \n-   * asynchronously.\n-   * \n-   * @since 1.4\n-   */\n-  public interface AsyncReader {\n-\n-    /**\n-     * Parse and return one {@link JsonElement} \n-     * @since 1.4\n-     */\n-    public JsonElement readElement();\n-  }\n-\n   /**\n    * Parses the specified JSON string into a parse tree\n    * \n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (JsonParseException e) {\n+      if (e.getCause() instanceof EOFException) {\n+        return null;\n+      } else {\n+        throw e;\n+      }\n     }\n-  }\n-  \n-  /**\n-   * Returns {@link AsyncReader} to allow reading of multiple {@link JsonElement}s from the \n-   * specified reader asynchronously.\n-   * \n-   * @param json The data stream containing JSON elements concatenated to each other.\n-   * @return {@link AsyncReader} for reading {@link JsonElement}s asynchronously.\n-   * @throws JsonParseException if the incoming stream is malformed JSON.\n-   * @since 1.4\n-   */\n-  public AsyncReader parseAsync(Reader json) throws JsonParseException {\n-    return new AsyncReaderJavacc(json);\n-  }\n-  \n-  private static class AsyncReaderJavacc implements AsyncReader {    \n-    private final JsonParserJavacc parser;\n-    private AsyncReaderJavacc(Reader json) {\n-      parser = new JsonParserJavacc(json);      \n-    }\n-    \n-    public JsonElement readElement() {\n-      try {\n-        JsonElement element = parser.parse();\n-        return element;\n-      } catch (TokenMgrError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n-      } catch (ParseException e) {\n-        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n-      } catch (StackOverflowError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n-      } catch (OutOfMemoryError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n-      }\n-    }    \n-  }\n+  }  \n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserAsync.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import java.io.EOFException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+/**\n+ * A parser that allows reading of multiple {@link JsonElement}s from the specified reader\n+ * asynchronously.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @since 1.4\n+ */\n+public final class JsonParserAsync {\n+\n+  private final JsonParserJavacc parser;\n+\n+  /**\n+   * @param json The string containing JSON elements concatenated to each other.\n+   * @since 1.4\n+   */\n+  public JsonParserAsync(String json) {\n+    this(new StringReader(json));      \n+  }\n+  \n+  /**\n+   * @param reader The data stream containing JSON elements concatenated to each other.\n+   * @since 1.4\n+   */\n+  public JsonParserAsync(Reader reader) {\n+    parser = new JsonParserJavacc(reader);      \n+  }\n+  \n+  /**\n+   * Returns the next available {@link JsonElement} on the reader. Null if none available.\n+   * \n+   * @return the next available {@link JsonElement} on the reader. Null if none available.\n+   * @throws JsonParseException if the incoming stream is malformed JSON.\n+   * @since 1.4\n+   */\n+  public JsonElement nextElement() throws JsonParseException {\n+    try {\n+      JsonElement element = parser.parse();\n+      return element;\n+    } catch (TokenMgrError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (ParseException e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (StackOverflowError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (OutOfMemoryError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (JsonParseException e) {\n+      if (e.getCause() instanceof EOFException) {\n+        return null;\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }    \n+}\n--- a/gson/src/main/java/com/google/gson/JsonParserJavacc.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavacc.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserJavacc.java */\n package com.google.gson;\n+import java.io.EOFException;\n \n @SuppressWarnings(\"all\")\n final class JsonParserJavacc implements JsonParserJavaccConstants {\n   final public JsonElement parse() throws ParseException {\n   JsonElement json = null;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 26:\n-      jj_consume_token(26);\n-      break;\n-    default:\n-      jj_la1[0] = jj_gen;\n-      ;\n-    }\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 27:\n-      json = JsonObject();\n-      break;\n-    case 31:\n-      json = JsonArray();\n+    case 0:\n+      jj_consume_token(0);\n+    {if (true) throw new JsonParseException(new EOFException());}\n       break;\n     case DIGITS:\n+    case NULL:\n     case NAN:\n     case INFINITY:\n     case BOOLEAN:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n+    case 26:\n+    case 27:\n+    case 31:\n     case 33:\n-      json = JsonPrimitive();\n-      break;\n-    case NULL:\n-      json = JsonNull();\n-      break;\n-    default:\n-      jj_la1[1] = jj_gen;\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case 26:\n+        jj_consume_token(26);\n+        break;\n+      default:\n+        jj_la1[0] = jj_gen;\n+        ;\n+      }\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case 27:\n+        json = JsonObject();\n+        break;\n+      case 31:\n+        json = JsonArray();\n+        break;\n+      case DIGITS:\n+      case NAN:\n+      case INFINITY:\n+      case BOOLEAN:\n+      case SINGLE_QUOTE_LITERAL:\n+      case DOUBLE_QUOTE_LITERAL:\n+      case 33:\n+        json = JsonPrimitive();\n+        break;\n+      case NULL:\n+        json = JsonNull();\n+        break;\n+      default:\n+        jj_la1[1] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    {if (true) return json;}\n+      break;\n+    default:\n+      jj_la1[2] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n-    {if (true) return json;}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n       Members(o);\n       break;\n     default:\n-      jj_la1[2] = jj_gen;\n+      jj_la1[3] = jj_gen;\n       ;\n     }\n     jj_consume_token(28);\n       Members(o);\n       break;\n     default:\n-      jj_la1[3] = jj_gen;\n+      jj_la1[4] = jj_gen;\n       ;\n     }\n   }\n                        {if (true) return value;}\n       break;\n     default:\n-      jj_la1[4] = jj_gen;\n+      jj_la1[5] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n       Elements(array);\n       break;\n     default:\n-      jj_la1[5] = jj_gen;\n+      jj_la1[6] = jj_gen;\n       ;\n     }\n     jj_consume_token(32);\n       Elements(array);\n       break;\n     default:\n-      jj_la1[6] = jj_gen;\n+      jj_la1[7] = jj_gen;\n       ;\n     }\n     array.add(element);\n       o = JsonNull();\n       break;\n     default:\n-      jj_la1[7] = jj_gen;\n+      jj_la1[8] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n                            {if (true) return value;}\n       break;\n     default:\n-      jj_la1[8] = jj_gen;\n+      jj_la1[9] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n           fracpart = JsonFrac();\n           break;\n         default:\n-          jj_la1[9] = jj_gen;\n+          jj_la1[10] = jj_gen;\n           ;\n         }\n         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n           exppart = JsonExp();\n           break;\n         default:\n-          jj_la1[10] = jj_gen;\n+          jj_la1[11] = jj_gen;\n           ;\n         }\n     Number n;\n     {if (true) return new JsonPrimitive(n);}\n         break;\n       default:\n-        jj_la1[11] = jj_gen;\n+        jj_la1[12] = jj_gen;\n         jj_consume_token(-1);\n         throw new ParseException();\n       }\n          negative = true;\n         break;\n       default:\n-        jj_la1[12] = jj_gen;\n+        jj_la1[13] = jj_gen;\n         ;\n       }\n       jj_consume_token(INFINITY);\n                                         {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\n       break;\n     default:\n-      jj_la1[13] = jj_gen;\n+      jj_la1[14] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n          negative = true;\n       break;\n     default:\n-      jj_la1[14] = jj_gen;\n+      jj_la1[15] = jj_gen;\n       ;\n     }\n     digits = Digits();\n       t = jj_consume_token(IDENTIFIER_SANS_EXPONENT);\n       break;\n     default:\n-      jj_la1[15] = jj_gen;\n+      jj_la1[16] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n       t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n       break;\n     default:\n-      jj_la1[16] = jj_gen;\n+      jj_la1[17] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n   private Token jj_scanpos, jj_lastpos;\n   private int jj_la;\n   private int jj_gen;\n-  final private int[] jj_la1 = new int[17];\n+  final private int[] jj_la1 = new int[18];\n   static private int[] jj_la1_0;\n   static private int[] jj_la1_1;\n   static {\n       jj_la1_init_1();\n    }\n    private static void jj_la1_init_0() {\n-      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x31800,0x20000000,0x31800,0x880307c0,0x20000000,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n+      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x8c0307c1,0x31800,0x20000000,0x31800,0x880307c0,0x20000000,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n    }\n    private static void jj_la1_init_1() {\n-      jj_la1_1 = new int[] {0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n+      jj_la1_1 = new int[] {0x0,0x2,0x2,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n    }\n   final private JJCalls[] jj_2_rtns = new JJCalls[1];\n   private boolean jj_rescan = false;\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 18; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n       la1tokens[jj_kind] = true;\n       jj_kind = -1;\n     }\n-    for (int i = 0; i < 17; i++) {\n+    for (int i = 0; i < 18; i++) {\n       if (jj_la1[i] == jj_gen) {\n         for (int j = 0; j < 32; j++) {\n           if ((jj_la1_0[i] & (1<<j)) != 0) {\n--- a/gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserJavaccTokenManager.java */\n package com.google.gson;\n+import java.io.EOFException;\n \n /** Token Manager. */\n @SuppressWarnings(\"all\")\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonParserAsyncTest.java\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link JsonParserAsync}\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class JsonParserAsyncTest extends TestCase {\n+  \n+  public void testParseTwoStrings() {\n+    JsonParserAsync parser = new JsonParserAsync(\"'one' 'two'\");\n+    String actualOne = parser.nextElement().getAsString();\n+    assertEquals(\"one\", actualOne);\n+    String actualTwo = parser.nextElement().getAsString();\n+    assertEquals(\"two\", actualTwo);\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n   }\n \n   public void testNullDeserialization() throws Exception {\n-    try {\n-      gson.fromJson(\"\", Object.class);\n-      fail(\"Null strings should not be allowed\");\n-    } catch (JsonParseException expected) {\n-    }\n+    Object object = gson.fromJson(\"\", Object.class);\n+    assertNull(object);\n   }\n \n   public void testNullFieldsSerialization() throws Exception {\n--- a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n-import com.google.gson.JsonParseException;\n-import com.google.gson.JsonParser;\n-import com.google.gson.JsonParser.AsyncReader;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParserAsync;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n \n import junit.framework.TestCase;\n     writer.write(gson.toJson(\"one\").toCharArray());\n     writer.write(gson.toJson(\"two\").toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n-    JsonParser parser = new JsonParser();\n-    AsyncReader asyncReader = parser.parseAsync(reader);\n-    String actualOne = gson.fromJson(asyncReader.readElement(), String.class);\n+    JsonParserAsync parser = new JsonParserAsync(reader);\n+    String actualOne = gson.fromJson(parser.nextElement(), String.class);\n     assertEquals(\"one\", actualOne);\n-    String actualTwo = gson.fromJson(asyncReader.readElement(), String.class);\n+    String actualTwo = gson.fromJson(parser.nextElement(), String.class);\n     assertEquals(\"two\", actualTwo);\n   }\n   \n     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \"two\");\n     writer.write(gson.toJson(expectedTwo).toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n-    JsonParser parser = new JsonParser();\n-    AsyncReader asyncReader = parser.parseAsync(reader);\n-    BagOfPrimitives actualOne = gson.fromJson(asyncReader.readElement(), BagOfPrimitives.class);\n+    JsonParserAsync parser = new JsonParserAsync(reader);\n+    BagOfPrimitives actualOne = gson.fromJson(parser.nextElement(), BagOfPrimitives.class);\n     assertEquals(\"one\", actualOne.stringValue);\n-    BagOfPrimitives actualTwo = gson.fromJson(asyncReader.readElement(), BagOfPrimitives.class);\n+    BagOfPrimitives actualTwo = gson.fromJson(parser.nextElement(), BagOfPrimitives.class);\n     assertEquals(\"two\", actualTwo.stringValue);\n+    JsonElement jsonElement = parser.nextElement();\n   }\n }", "timestamp": 1242332325, "metainfo": ""}