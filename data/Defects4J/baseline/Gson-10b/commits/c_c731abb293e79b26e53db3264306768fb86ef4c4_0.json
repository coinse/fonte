{"sha": "c731abb293e79b26e53db3264306768fb86ef4c4", "log": "Fixed a regression in Gson 2.6 where Gson caused NPE if the TypeAdapterFactory.create() returned null.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n       TypeToken<?> fieldType, JsonAdapter annotation) {\n     Class<?> value = annotation.value();\n-    final TypeAdapter<?> typeAdapter;\n+    TypeAdapter<?> typeAdapter;\n     if (TypeAdapter.class.isAssignableFrom(value)) {\n       Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n       throw new IllegalArgumentException(\n           \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n     }\n-\n-    return typeAdapter.nullSafe();\n+    if (typeAdapter != null) {\n+      typeAdapter = typeAdapter.nullSafe();\n+    }\n+    return typeAdapter;\n   }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java\n+/*\n+ * Copyright (C) 2016 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.regression;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.annotations.JsonAdapter;\n+import com.google.gson.annotations.SerializedName;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+\n+import junit.framework.TestCase;\n+\n+public class JsonAdapterNullSafeTest extends TestCase {\n+  private final Gson gson = new Gson();\n+\n+  /**\n+   * The recursiveCall in {@link ControlData.JsonAdapterFactory} is the source of this bug\n+   * because it returns a null type adapter.\n+   */\n+  public void testTypeAdapterFactoryNullSafeBug() throws IOException {\n+      ControlData control = new ControlData(\"ec57803e\", 2, true, 11211);\n+      Device device = new Device(\"device1\", control);\n+      String json = gson.toJson(device);\n+\n+      json = \"\\\"{\\\\\\\"id\\\\\\\":\\\\\\\"ec57803e2\\\\\\\",\\\\\\\"category\\\\\\\":2,\\\\\\\"alwaysOn\\\\\\\":true,\\\\\\\"codeset_id\\\\\\\":11211}\\\"\";\n+      control = gson.fromJson(json, ControlData.class);\n+      assertEquals(\"ec57803e2\", control.id);\n+      assertTrue(control.alwaysOn);\n+      assertEquals(11211, control.codesetId);\n+      assertEquals(2, control.category);\n+\n+      String deviceJson = \"{'id':'device1','controlData':null}\";\n+      device = gson.fromJson(deviceJson, Device.class);\n+      assertNull(device.controlData);\n+\n+      deviceJson = \"{'id':'device1','controlData':{'id':'ec57803e2','category':2,'alwaysOn':true,'codeset_id':12221}}\";\n+      device = gson.fromJson(deviceJson, Device.class);\n+      assertEquals(12221, device.controlData.codesetId);\n+\n+      deviceJson = \"{'id':'device1','controlData':'\\\\\\\"{}\\\\\\\"'}\";\n+      device = gson.fromJson(deviceJson, Device.class);\n+\n+      try {\n+          deviceJson = \"{'id':'device1','controlData':'a'}\";\n+          device = gson.fromJson(deviceJson, Device.class);\n+          assertNotNull(device.controlData);\n+          fail();\n+      } catch (JsonSyntaxException expected) {}\n+\n+      deviceJson = \"{'id':'device1','controlData':'  '}\";\n+      device = gson.fromJson(deviceJson, Device.class);\n+      assertNull(device.controlData);\n+  }\n+\n+  private static final class Device {\n+    @SuppressWarnings(\"unused\")\n+    String id;\n+    ControlData controlData;\n+\n+    public Device(String id, ControlData controlData) {\n+      this.id = id;\n+      this.controlData = controlData;\n+    }\n+  }\n+\n+  @JsonAdapter(ControlData.JsonAdapterFactory.class)\n+  private static final class ControlData {\n+    String id;\n+    int category;\n+    boolean alwaysOn;\n+    @SerializedName(\"codeset_id\") int codesetId;\n+    ControlData(String id, int category, boolean alwaysOn, int codesetId) {\n+      this.id = id;\n+      this.category = category;\n+      this.alwaysOn = alwaysOn;\n+      this.codesetId = codesetId;\n+    }\n+\n+    /**\n+     * DeviceControlData is received as String in JSON instead of proper JSON.\n+     * So, we need to write a special type adapter.\n+     */\n+    static final class JsonAdapterFactory extends StringifiedJsonAdapterFactory<ControlData> {\n+      private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();\n+      public JsonAdapterFactory() {\n+        super(recursiveCall, ControlData.class, true);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Converts an object to Stringified JSON for saving in a JSON field as a string type.\n+   */\n+  private static class StringifiedJsonAdapterFactory<R> implements TypeAdapterFactory {\n+    private final Class<R> targetType;\n+    private final ThreadLocal<Boolean> recursiveCall;\n+    private final boolean writeAsJson;\n+\n+    /**\n+     * @param recursiveCall provide a static ThreadLocal to workaround a Gson bug where\n+     *   annotation-based type adapter factories can't be skipped over.\n+     * @param targetType The class whose instances needs to be written in stringified form.\n+     * @param writeAsJson Set this to true to write the output as JSON not string.\n+     */\n+    public StringifiedJsonAdapterFactory(ThreadLocal<Boolean> recursiveCall, Class<R> targetType,\n+        boolean writeAsJson) {\n+      this.recursiveCall = recursiveCall;\n+      this.targetType = targetType;\n+      this.writeAsJson = writeAsJson;\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {\n+      if (type.getRawType() != targetType || recursiveCall.get() != null) {\n+        recursiveCall.set(null); // clear for subsequent use\n+        return null;\n+      }\n+      recursiveCall.set(Boolean.TRUE);\n+      final TypeAdapter<R> delegate = (TypeAdapter) gson.getDelegateAdapter(this, type);\n+      return (TypeAdapter) new TypeAdapter<R>() {\n+        @Override public void write(JsonWriter out, R value) throws IOException {\n+          if (writeAsJson) {\n+            delegate.write(out, value);\n+          } else {\n+            // delegate.toJson(value) will write nulls. avoid that by using gson.toJson()\n+            String json = gson.toJson(delegate.toJsonTree(value));\n+            out.value(json);\n+          }\n+        }\n+        @Override public R read(JsonReader in) throws IOException {\n+          JsonToken token = in.peek();\n+          JsonElement root;\n+          if (token == JsonToken.BEGIN_OBJECT) {\n+            return delegate.read(in);\n+          } else { // assume to be string\n+            String json = in.nextString();\n+            JsonParser parser = new JsonParser();\n+            root = parseString(parser, json, null);\n+            return root == null ? null : delegate.fromJsonTree(root);\n+          }\n+        }\n+\n+        private JsonElement parseString(JsonParser parser, String json, String prevJson)\n+            throws IOException {\n+          if (json == null || json.trim().isEmpty()) {\n+            return null;\n+          }\n+          JsonElement root = parser.parse(json);\n+          if (root instanceof JsonPrimitive) {\n+            prevJson = json;\n+            json = root.getAsString();\n+            if (Objects.equals(json, prevJson)) {\n+              throw new JsonSyntaxException(\"Unexpected Json: \" + json);\n+            }\n+            return parseString(parser, json, prevJson);\n+          }\n+          return root;\n+        }\n+      }.nullSafe();\n+    }\n+  }\n+}", "timestamp": 1456437402, "metainfo": ""}