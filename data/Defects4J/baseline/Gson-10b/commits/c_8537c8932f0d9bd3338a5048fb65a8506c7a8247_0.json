{"sha": "8537c8932f0d9bd3338a5048fb65a8506c7a8247", "log": "Optimize list allocation for every reflective field.  The common cases (no @SerializedName and a single-value @SerializedName) now use a specialized one-element collection. Cases with alternate names use a much more space efficient ArrayList which is exactly sized.  This is also a performance win for adapter initialization since an index-based loop was used on the returned type for which LinkedList is not suited for.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n \n   /** first element holds the default name */\n   private List<String> getFieldNames(Field f) {\n-    return getFieldName(fieldNamingPolicy, f);\n-  }\n-\n-  /** first element holds the default name */\n-  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n-    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n-    List<String> fieldNames = new LinkedList<String>();\n-    if (serializedName == null) {\n-      fieldNames.add(fieldNamingPolicy.translateName(f));\n-    } else {\n-      fieldNames.add(serializedName.value());\n-      for (String alternate : serializedName.alternate()) {\n-        fieldNames.add(alternate);\n-      }\n+    SerializedName annotation = f.getAnnotation(SerializedName.class);\n+    if (annotation == null) {\n+      String name = fieldNamingPolicy.translateName(f);\n+      return Collections.singletonList(name);\n+    }\n+\n+    String serializedName = annotation.value();\n+    String[] alternates = annotation.alternate();\n+    if (alternates.length == 0) {\n+      return Collections.singletonList(serializedName);\n+    }\n+\n+    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);\n+    fieldNames.add(serializedName);\n+    for (String alternate : alternates) {\n+      fieldNames.add(alternate);\n     }\n     return fieldNames;\n   }", "timestamp": 1461731331, "metainfo": ""}