{"sha": "0acb1519416832abbd7f83187c9260e99f6d57be", "log": "A test to reproduce Gson concurrency bug. See issue 63.", "commit": "\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * Tests for ensuring Gson thread-safety.\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ConcurrencyTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  /**\n+   * Source-code based on\n+   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n+   */\n+  public void testSingleThread() { \n+    MyObject myObj = new MyObject(\"hello\", \"world\", 42); \n+    for (int i = 0; i < 10; i++) { \n+      gson.toJson(myObj); \n+    } \n+  } \n+\n+  /**\n+   * Source-code based on\n+   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n+   */\n+  public void testMultiThread() throws InterruptedException {\n+    final CountDownLatch startLatch = new CountDownLatch(1);\n+    final CountDownLatch finishedLatch = new CountDownLatch(10);\n+    final AtomicBoolean failed = new AtomicBoolean(false);\n+    ExecutorService executor = Executors.newFixedThreadPool(10);\n+    for (int taskCount = 0; taskCount < 10; taskCount++) {\n+      executor.execute(new Runnable() {\n+        public void run() {\n+          MyObject myObj = new MyObject();\n+          try {\n+            startLatch.await();\n+            for (int i = 0; i < 10; i++) {\n+              String json = gson.toJson(myObj);\n+            }\n+          } catch (Throwable t) {\n+            failed.set(true);\n+          } finally {\n+            finishedLatch.countDown();\n+          }\n+        }\n+      });\n+    }\n+    startLatch.countDown();\n+    finishedLatch.await();\n+    assertFalse(failed.get());\n+  }\n+\n+  private static class MyObject {\n+    private String a;\n+    private String b;\n+    private int i;\n+\n+    MyObject() {\n+      this(\"hello\", \"world\", 42);\n+    }\n+\n+    public MyObject(String a, String b, int i) {\n+      this.a = a;\n+      this.b = b;\n+      this.i = i;\n+    }\n+  }\n+}", "timestamp": 1224532118, "metainfo": ""}