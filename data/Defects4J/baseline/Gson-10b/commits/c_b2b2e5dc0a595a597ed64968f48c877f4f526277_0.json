{"sha": "b2b2e5dc0a595a597ed64968f48c877f4f526277", "log": "Implemented enhancement request from issue 42 by supporting a new GsonBuilder setting generateNonExecutableJson() that prefixes the generated JSON with some special text that makes the output non-executable javascript. Gson now recognizes this special text in the input while parsing the JSON in fromJson and filters it out, if present.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n   private static final String NULL_STRING = \"null\";\n \n+  static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+  \n   // Default instances of plug-ins\n   static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n       new ModifierBasedExclusionStrategy(true, new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n   static final FieldNamingStrategy DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n \n+  private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n<data>\";\n+\n   private final ExclusionStrategy strategy;\n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n \n   private final JsonFormatter formatter;\n   private final boolean serializeNulls;\n+\n+  private final boolean generateNonExecutableJson;\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n     this(strategy, fieldNamingPolicy, \n         new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n         DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n-        DefaultTypeAdapters.getDefaultDeserializers());\n+        DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE);\n   }\n \n   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy, \n       MappedObjectConstructor objectConstructor, JsonFormatter formatter, boolean serializeNulls,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, \n+      boolean generateNonExecutableGson) {\n     this.strategy = strategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.serializeNulls = serializeNulls;\n     this.serializers = serializers;\n     this.deserializers = deserializers;\n+    this.generateNonExecutableJson = generateNonExecutableGson;\n   }\n   \n   private ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n             createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n         JsonElement jsonElement = context.serialize(src, typeOfSrc);\n \n+        if (generateNonExecutableJson) {\n+          writer.append(JSON_NON_EXECUTABLE_PREFIX);\n+        }\n         //TODO(Joel): instead of navigating the \"JsonElement\" inside the formatter, do it here.\n         formatter.format(jsonElement, writer, serializeNulls);\n       } else {\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private boolean serializeSpecialFloatingPointValues;\n   private boolean escapeHtmlChars;\n   private boolean prettyPrinting;\n+  private boolean generateNonExecutableJson;\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n     dateStyle = DateFormat.DEFAULT;\n     timeStyle = DateFormat.DEFAULT;\n     serializeSpecialFloatingPointValues = false;\n+    generateNonExecutableJson = false;\n   }\n \n   /**\n     return this;\n   }\n \n+  /**\n+   * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\n+   * special text. This prevents attacks from third-party sites through script sourcing. See \n+   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a> \n+   * for details. \n+   * \n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.3\n+   */\n+  public GsonBuilder generateNonExecutableJson() {\n+    this.generateNonExecutableJson = true;\n+    return this;\n+  }\n+  \n   /**\n    * Configures Gson to exclude all fields from consideration for serialization or deserialization\n    * that do not have the {@link com.google.gson.annotations.Expose} annotation.\n     JsonFormatter formatter =  prettyPrinting ?\n         new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n     Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor,\n-        formatter, serializeNulls, customSerializers, customDeserializers);\n+        formatter, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson);\n     return gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonParserImpl.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImpl.java\n   JsonElement json = null;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case 26:\n+      jj_consume_token(26);\n+      break;\n+    default:\n+      jj_la1[0] = jj_gen;\n+      ;\n+    }\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 27:\n       json = JsonObject();\n       break;\n-    case 30:\n+    case 31:\n       json = JsonArray();\n       break;\n     case DIGITS:\n     case BOOLEAN:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n-    case 32:\n+    case 33:\n       json = JsonPrimitive();\n       break;\n     case NULL:\n       json = JsonNull();\n       break;\n     default:\n-      jj_la1[0] = jj_gen;\n+      jj_la1[1] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n \n   final private JsonObject JsonObject() throws ParseException {\n   JsonObject o = new JsonObject();\n-    jj_consume_token(26);\n+    jj_consume_token(27);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case IDENTIFIER_SANS_EXPONENT:\n     case IDENTIFIER_STARTS_WITH_EXPONENT:\n       Members(o);\n       break;\n     default:\n-      jj_la1[1] = jj_gen;\n+      jj_la1[2] = jj_gen;\n       ;\n     }\n-    jj_consume_token(27);\n+    jj_consume_token(28);\n     {if (true) return o;}\n     throw new Error(\"Missing return statement in function\");\n   }\n   final private void Members(JsonObject o) throws ParseException {\n     Pair(o);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 28:\n-      jj_consume_token(28);\n+    case 29:\n+      jj_consume_token(29);\n       Members(o);\n       break;\n     default:\n-      jj_la1[2] = jj_gen;\n+      jj_la1[3] = jj_gen;\n       ;\n     }\n   }\n   JsonPrimitive property;\n   JsonElement value;\n     property = JsonMemberName();\n-    jj_consume_token(29);\n+    jj_consume_token(30);\n     value = JsonValue();\n     o.add(property.getAsString(), value);\n   }\n                        {if (true) return value;}\n       break;\n     default:\n-      jj_la1[3] = jj_gen;\n+      jj_la1[4] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n \n   final private JsonArray JsonArray() throws ParseException {\n   JsonArray array = new JsonArray();\n-    jj_consume_token(30);\n+    jj_consume_token(31);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case DIGITS:\n     case NULL:\n     case BOOLEAN:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n-    case 26:\n-    case 30:\n-    case 32:\n+    case 27:\n+    case 31:\n+    case 33:\n       Elements(array);\n       break;\n     default:\n-      jj_la1[4] = jj_gen;\n+      jj_la1[5] = jj_gen;\n       ;\n     }\n-    jj_consume_token(31);\n+    jj_consume_token(32);\n     array.reverse();\n     {if (true) return array;}\n     throw new Error(\"Missing return statement in function\");\n   JsonElement element;\n     element = JsonValue();\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 28:\n-      jj_consume_token(28);\n+    case 29:\n+      jj_consume_token(29);\n       Elements(array);\n       break;\n     default:\n-      jj_la1[5] = jj_gen;\n+      jj_la1[6] = jj_gen;\n       ;\n     }\n     array.add(element);\n     case DIGITS:\n     case NAN:\n     case INFINITY:\n-    case 32:\n+    case 33:\n       o = JsonNumber();\n       break;\n-    case 26:\n+    case 27:\n       o = JsonObject();\n       break;\n-    case 30:\n+    case 31:\n       o = JsonArray();\n       break;\n     case BOOLEAN:\n       o = JsonNull();\n       break;\n     default:\n-      jj_la1[6] = jj_gen;\n+      jj_la1[7] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n     case DIGITS:\n     case NAN:\n     case INFINITY:\n-    case 32:\n+    case 33:\n       value = JsonNumber();\n                           {if (true) return value;}\n       break;\n                            {if (true) return value;}\n       break;\n     default:\n-      jj_la1[7] = jj_gen;\n+      jj_la1[8] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n     } else {\n       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n       case DIGITS:\n-      case 32:\n+      case 33:\n         intpart = JsonInt();\n         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-        case 33:\n+        case 34:\n           fracpart = JsonFrac();\n           break;\n         default:\n-          jj_la1[8] = jj_gen;\n+          jj_la1[9] = jj_gen;\n           ;\n         }\n         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n           exppart = JsonExp();\n           break;\n         default:\n-          jj_la1[9] = jj_gen;\n+          jj_la1[10] = jj_gen;\n           ;\n         }\n     Number n;\n     {if (true) return new JsonPrimitive(n);}\n         break;\n       default:\n-        jj_la1[10] = jj_gen;\n+        jj_la1[11] = jj_gen;\n         jj_consume_token(-1);\n         throw new ParseException();\n       }\n            {if (true) return new JsonPrimitive(Double.NaN);}\n       break;\n     case INFINITY:\n-    case 32:\n+    case 33:\n       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-      case 32:\n-        jj_consume_token(32);\n+      case 33:\n+        jj_consume_token(33);\n          negative = true;\n         break;\n       default:\n-        jj_la1[11] = jj_gen;\n+        jj_la1[12] = jj_gen;\n         ;\n       }\n       jj_consume_token(INFINITY);\n                                         {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\n       break;\n     default:\n-      jj_la1[12] = jj_gen;\n+      jj_la1[13] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n   String digits;\n   boolean negative = false;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 32:\n-      jj_consume_token(32);\n+    case 33:\n+      jj_consume_token(33);\n          negative = true;\n       break;\n     default:\n-      jj_la1[13] = jj_gen;\n+      jj_la1[14] = jj_gen;\n       ;\n     }\n     digits = Digits();\n \n   final private String JsonFrac() throws ParseException {\n   String digits;\n-    jj_consume_token(33);\n+    jj_consume_token(34);\n     digits = Digits();\n     {if (true) return \".\" + digits;}\n     throw new Error(\"Missing return statement in function\");\n       t = jj_consume_token(IDENTIFIER_SANS_EXPONENT);\n       break;\n     default:\n-      jj_la1[14] = jj_gen;\n+      jj_la1[15] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n       t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n       break;\n     default:\n-      jj_la1[15] = jj_gen;\n+      jj_la1[16] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n   }\n \n   private boolean jj_3R_4() {\n-    if (jj_scan_token(32)) return true;\n+    if (jj_scan_token(33)) return true;\n     return false;\n   }\n \n   private Token jj_scanpos, jj_lastpos;\n   private int jj_la;\n   private int jj_gen;\n-  final private int[] jj_la1 = new int[16];\n+  final private int[] jj_la1 = new int[17];\n   static private int[] jj_la1_0;\n   static private int[] jj_la1_1;\n   static {\n       jj_la1_init_1();\n    }\n    private static void jj_la1_init_0() {\n-      jj_la1_0 = new int[] {0x440307c0,0x31800,0x10000000,0x31800,0x440307c0,0x10000000,0x440307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n+      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x31800,0x20000000,0x31800,0x880307c0,0x20000000,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n    }\n    private static void jj_la1_init_1() {\n-      jj_la1_1 = new int[] {0x1,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x2,0x0,0x1,0x1,0x1,0x1,0x0,0x0,};\n+      jj_la1_1 = new int[] {0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n    }\n   final private JJCalls[] jj_2_rtns = new JJCalls[1];\n   private boolean jj_rescan = false;\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n   /** Generate ParseException. */\n   public ParseException generateParseException() {\n     jj_expentries.clear();\n-    boolean[] la1tokens = new boolean[34];\n+    boolean[] la1tokens = new boolean[35];\n     if (jj_kind >= 0) {\n       la1tokens[jj_kind] = true;\n       jj_kind = -1;\n     }\n-    for (int i = 0; i < 16; i++) {\n+    for (int i = 0; i < 17; i++) {\n       if (jj_la1[i] == jj_gen) {\n         for (int j = 0; j < 32; j++) {\n           if ((jj_la1_0[i] & (1<<j)) != 0) {\n         }\n       }\n     }\n-    for (int i = 0; i < 34; i++) {\n+    for (int i = 0; i < 35; i++) {\n       if (la1tokens[i]) {\n         jj_expentry = new int[1];\n         jj_expentry[0] = i;\n--- a/gson/src/main/java/com/google/gson/JsonParserImplConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImplConstants.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserImplConstants.java */\n package com.google.gson;\n-\n \n /**\n  * Token literal values and constants.\n     \"\\\"u\\\"\",\n     \"<HEX>\",\n     \"<HEX_ESC>\",\n+    \"\\\")]}\\\\\\'\\\\n<data>\\\"\",\n     \"\\\"{\\\"\",\n     \"\\\"}\\\"\",\n     \"\\\",\\\"\",\n--- a/gson/src/main/java/com/google/gson/JsonParserImplTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImplTokenManager.java\n             return 10;\n          }\n          return -1;\n+      case 7:\n+         if ((active0 & 0x200L) != 0L)\n+            return 10;\n+         return -1;\n       default :\n          return -1;\n    }\n    {\n       case 34:\n          return jjStartNfaWithStates_0(0, 18, 43);\n+      case 41:\n+         return jjMoveStringLiteralDfa1_0(0x4000000L);\n       case 44:\n-         return jjStopAtPos(0, 28);\n+         return jjStopAtPos(0, 29);\n       case 45:\n-         return jjStopAtPos(0, 32);\n+         return jjStopAtPos(0, 33);\n       case 46:\n-         return jjStopAtPos(0, 33);\n+         return jjStopAtPos(0, 34);\n       case 58:\n-         return jjStopAtPos(0, 29);\n+         return jjStopAtPos(0, 30);\n       case 73:\n          return jjMoveStringLiteralDfa1_0(0x200L);\n       case 78:\n          return jjMoveStringLiteralDfa1_0(0x100L);\n       case 91:\n-         return jjStopAtPos(0, 30);\n+         return jjStopAtPos(0, 31);\n       case 93:\n-         return jjStopAtPos(0, 31);\n+         return jjStopAtPos(0, 32);\n       case 110:\n          return jjMoveStringLiteralDfa1_0(0x80L);\n       case 123:\n-         return jjStopAtPos(0, 26);\n+         return jjStopAtPos(0, 27);\n       case 125:\n-         return jjStopAtPos(0, 27);\n+         return jjStopAtPos(0, 28);\n       default :\n          return jjMoveNfa_0(4, 0);\n    }\n    }\n    switch(curChar)\n    {\n+      case 93:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L);\n       case 97:\n          return jjMoveStringLiteralDfa2_0(active0, 0x100L);\n       case 110:\n          return jjMoveStringLiteralDfa3_0(active0, 0x200L);\n       case 108:\n          return jjMoveStringLiteralDfa3_0(active0, 0x80L);\n+      case 125:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L);\n       default :\n          break;\n    }\n    }\n    switch(curChar)\n    {\n+      case 39:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000L);\n       case 105:\n          return jjMoveStringLiteralDfa4_0(active0, 0x200L);\n       case 108:\n    }\n    switch(curChar)\n    {\n+      case 10:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000L);\n       case 110:\n          return jjMoveStringLiteralDfa5_0(active0, 0x200L);\n       default :\n    }\n    switch(curChar)\n    {\n+      case 60:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000L);\n       case 105:\n          return jjMoveStringLiteralDfa6_0(active0, 0x200L);\n       default :\n    }\n    switch(curChar)\n    {\n+      case 100:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000L);\n       case 116:\n          return jjMoveStringLiteralDfa7_0(active0, 0x200L);\n       default :\n    }\n    switch(curChar)\n    {\n+      case 97:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000L);\n       case 121:\n          if ((active0 & 0x200L) != 0L)\n             return jjStartNfaWithStates_0(7, 9, 10);\n          break;\n    }\n    return jjStartNfa_0(6, active0);\n+}\n+private int jjMoveStringLiteralDfa8_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(6, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(7, active0);\n+      return 8;\n+   }\n+   switch(curChar)\n+   {\n+      case 116:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(7, active0);\n+}\n+private int jjMoveStringLiteralDfa9_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(7, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(8, active0);\n+      return 9;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x4000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(8, active0);\n+}\n+private int jjMoveStringLiteralDfa10_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(8, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(9, active0);\n+      return 10;\n+   }\n+   switch(curChar)\n+   {\n+      case 62:\n+         if ((active0 & 0x4000000L) != 0L)\n+            return jjStopAtPos(10, 26);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(9, active0);\n }\n private int jjStartNfaWithStates_0(int pos, int kind, int state)\n {\n public static final String[] jjstrLiteralImages = {\n \"\", null, null, null, null, null, null, \"\\156\\165\\154\\154\", \"\\116\\141\\116\", \n \"\\111\\156\\146\\151\\156\\151\\164\\171\", null, null, null, null, null, null, null, null, \"\\42\", null, null, null, null, \n-null, null, null, \"\\173\", \"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n+null, null, null, \"\\51\\135\\175\\47\\12\\74\\144\\141\\164\\141\\76\", \"\\173\", \"\\175\", \"\\54\", \n+\"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n \n /** Lexer state names. */\n public static final String[] lexStateNames = {\n /** Lex State array. */\n public static final int[] jjnewLexState = {\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, \n-   1, -1, -1, -1, -1, -1, -1, -1, -1, \n+   1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n };\n static final long[] jjtoToken = {\n-   0x3fe775fe1L, \n+   0x7fe775fe1L, \n };\n static final long[] jjtoSkip = {\n    0x1eL, \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/SecurityTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for security-related aspects of Gson\n+ * \n+ * @author Inderjeet Singh\n+ */\n+public class SecurityTest extends TestCase {\n+  /**\n+   * Keep this in sync with Gson.JSON_NON_EXECUTABLE_PREFIX\n+   */\n+  private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n<data>\";\n+\n+  private GsonBuilder gsonBuilder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gsonBuilder = new GsonBuilder();\n+  }\n+\n+  public void testNonExecutableJsonSerialization() {\n+    Gson gson = gsonBuilder.generateNonExecutableJson().create();\n+    String json = gson.toJson(new BagOfPrimitives());\n+    assertTrue(json.startsWith(JSON_NON_EXECUTABLE_PREFIX));\n+  }\n+  \n+  public void testNonExecutableJsonDeserialization() {\n+    String json = JSON_NON_EXECUTABLE_PREFIX + \"{longValue:1}\";\n+    Gson gson = gsonBuilder.create();\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(1, target.longValue);\n+  }\n+  \n+  public void testJsonWithNonExectuableTokenSerialization() {\n+    Gson gson = gsonBuilder.generateNonExecutableJson().create();\n+    String json = gson.toJson(JSON_NON_EXECUTABLE_PREFIX);\n+    assertTrue(json.contains(\")]}'\\n\\u003cdata\\u003e\"));\n+  }\n+  \n+  /**\n+   *  Gson should be able to deserialize a stream with non-exectuable token even if it is created\n+   *  without {@link GsonBuilder#generateNonExecutableJson()}.\n+   */\n+  public void testJsonWithNonExectuableTokenWithRegularGsonDeserialization() {\n+    Gson gson = gsonBuilder.create();\n+    String json = JSON_NON_EXECUTABLE_PREFIX + \"{stringValue:')]}\\\\u0027\\\\n<data>'}\";\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(\")]}'\\n<data>\", target.stringValue);\n+  }  \n+  \n+  /**\n+   *  Gson should be able to deserialize a stream with non-exectuable token if it is created\n+   *  with {@link GsonBuilder#generateNonExecutableJson()}.\n+   */\n+  public void testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization() {\n+    // Gson should be able to deserialize a stream with non-exectuable token even if it is created \n+    Gson gson = gsonBuilder.generateNonExecutableJson().create();\n+    String json = JSON_NON_EXECUTABLE_PREFIX + \"{intValue:2,stringValue:')]}\\\\u0027\\\\n<data>'}\";\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(\")]}'\\n<data>\", target.stringValue);\n+    assertEquals(2, target.intValue);\n+  }  \n+}", "timestamp": 1237324510, "metainfo": ""}