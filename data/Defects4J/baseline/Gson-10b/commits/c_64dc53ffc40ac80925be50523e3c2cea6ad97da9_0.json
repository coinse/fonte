{"sha": "64dc53ffc40ac80925be50523e3c2cea6ad97da9", "log": "Added support for runtime type determination while serializing collections and its subclasses. This currently doesn't work since Gson register a hierarchy type adapter for Collections that takes precedence over this.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n \n import java.io.IOException;\n import java.lang.reflect.Constructor;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n   public static final Factory FACTORY = new Factory() {\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n-      if (!(type instanceof ParameterizedType)) {\n-        return null;\n-      }\n \n       Class<? super T> rawType = typeToken.getRawType();\n       if (!Collection.class.isAssignableFrom(rawType)) {\n       }\n \n       @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n-      TypeAdapter<T> result = new CollectionTypeAdapter(elementTypeAdapter, constructor);\n+      TypeAdapter<T> result = new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n       return result;\n     }\n   };\n \n+  private final MiniGson context;\n+  private final Type elementType;\n   private final TypeAdapter<E> elementTypeAdapter;\n   private final Constructor<? extends Collection<E>> constructor;\n \n-  public CollectionTypeAdapter(TypeAdapter<E> elementTypeAdapter,\n+  public CollectionTypeAdapter(MiniGson context, Type elementType, TypeAdapter<E> elementTypeAdapter,\n       Constructor<? extends Collection<E>> constructor) {\n+    this.context = context;\n+    this.elementType = elementType;\n     this.elementTypeAdapter = elementTypeAdapter;\n     this.constructor = constructor;\n   }\n \n     writer.beginArray();\n     for (E element : collection) {\n-      elementTypeAdapter.write(writer, element);\n+      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(elementType, collection, element);\n+      TypeAdapter t = runtimeType != elementType ?\n+          context.getAdapter(TypeToken.get(runtimeType)) : elementTypeAdapter;\n+      t.write(writer, element);\n     }\n     writer.endArray();\n   }\n--- a/gson/src/test/java/com/google/gson/common/TestTypes.java\n+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java\n \n package com.google.gson.common;\n \n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonSerializationContext;\n import com.google.gson.JsonSerializer;\n import com.google.gson.annotations.SerializedName;\n-\n-import java.lang.reflect.Type;\n \n /**\n  * Types used for testing JSON serialization and deserialization\n     }\n   }\n \n+  public static class ClassWithBaseCollectionField {\n+    public static final String FIELD_KEY = \"base\";\n+    public final Collection<Base> base;\n+    public ClassWithBaseCollectionField(Collection<Base> base) {\n+      this.base = base;\n+    }\n+  }\n+\n   public static class BaseSerializer implements JsonSerializer<Base> {\n     public static final String NAME = BaseSerializer.class.getSimpleName(); \n     public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n  */\n package com.google.gson.functional;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.TestCase;\n+\n import com.google.gson.Gson;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonElement;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.common.TestTypes.Base;\n import com.google.gson.common.TestTypes.ClassWithBaseArrayField;\n+import com.google.gson.common.TestTypes.ClassWithBaseCollectionField;\n import com.google.gson.common.TestTypes.ClassWithBaseField;\n import com.google.gson.common.TestTypes.Nested;\n import com.google.gson.common.TestTypes.Sub;\n-\n-import junit.framework.TestCase;\n-\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n-import java.util.Set;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n \n /**\n  * Functional tests for Json serialization and deserialization of classes with \n   public void testClassWithBaseArrayFieldSerialization() {\n     Base[] baseClasses = new Base[]{ new Sub(), new Sub()};\n     ClassWithBaseArrayField sub = new ClassWithBaseArrayField(baseClasses);\n+    JsonObject json = gson.toJsonTree(sub).getAsJsonObject();\n+    JsonArray bases = json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\n+    for (JsonElement element : bases) { \n+      assertEquals(Sub.SUB_NAME, element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString());\n+    }\n+  }\n+\n+  public void testClassWithBaseCollectionFieldSerialization() {\n+    Collection<Base> baseClasses = new ArrayList<Base>();\n+    baseClasses.add(new Sub());\n+    baseClasses.add(new Sub());\n+    ClassWithBaseCollectionField sub = new ClassWithBaseCollectionField(baseClasses);\n     JsonObject json = gson.toJsonTree(sub).getAsJsonObject();\n     JsonArray bases = json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\n     for (JsonElement element : bases) { ", "timestamp": 1312502152, "metainfo": ""}