{"sha": "764e4d9aca8139540f3b37ec3977c07e3e705127", "log": "Performance fixes after doing some profiling.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n       return new LinkedList();\n     }    \n   }\n-  \n+\n   private static class PropertiesCreator implements InstanceCreator<Properties> {\n     public Properties createInstance(Type type) {\n       return new Properties();\n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n \n import java.lang.reflect.Field;\n import java.util.Collection;\n-import java.util.LinkedList;\n \n /**\n  * A wrapper class used to collect numerous {@link ExclusionStrategy} objects\n final class DisjunctionExclusionStrategy implements ExclusionStrategy {\n   private final Collection<ExclusionStrategy> strategies;\n \n-  public DisjunctionExclusionStrategy(ExclusionStrategy... strategies) {\n-    Preconditions.checkNotNull(strategies);\n-    Preconditions.checkArgument(strategies.length > 0);\n-\n-    this.strategies = new LinkedList<ExclusionStrategy>();\n-    for (ExclusionStrategy strategy : strategies) {\n-      this.strategies.add(strategy);\n-    }\n-  }\n-\n   public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\n     Preconditions.checkNotNull(strategies);\n-    Preconditions.checkArgument(!strategies.isEmpty());\n-\n-    this.strategies = new LinkedList<ExclusionStrategy>();\n-    this.strategies.addAll(strategies);\n+    this.strategies = strategies;\n   }\n \n   public boolean shouldSkipField(Field f) {\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    */\n   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n     this(strategy, fieldNamingPolicy, \n-        createObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n+        new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n         DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n         DefaultTypeAdapters.getDefaultDeserializers());\n   }\n     this.deserializers = deserializers;\n   }\n   \n-  static MappedObjectConstructor createObjectConstructor(\n-      ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n-    MappedObjectConstructor objectConstructor = new MappedObjectConstructor();\n-    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\n-      objectConstructor.register(entry.getKey(), entry.getValue());\n-    }\n-    return objectConstructor;\n-  }\n-\n   private ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n   }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n  * @author Joel Leitch\n  */\n public final class GsonBuilder {\n-\n+  private static final AnonymousAndLocalClassExclusionStrategy anonAndLocalClassExclusionStrategy =\n+      new AnonymousAndLocalClassExclusionStrategy();\n+  private static final InnerClassExclusionStrategy innerClassExclusionStrategy =\n+      new InnerClassExclusionStrategy();\n+  private static final ExposeAnnotationBasedExclusionStrategy exposeAnnotationExclusionStrategy =\n+      new ExposeAnnotationBasedExclusionStrategy();\n+  \n   private double ignoreVersionsAfter;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n   private boolean serializeInnerClasses;\n-  private final AnonymousAndLocalClassExclusionStrategy anonAndLocalClassExclusionStrategy;\n-  private final InnerClassExclusionStrategy innerClassExclusionStrategy;\n   private boolean excludeFieldsWithoutExposeAnnotation;\n   private LongSerializationPolicy longSerializationPolicy;\n   private FieldNamingStrategy fieldNamingPolicy;\n     serializeInnerClasses = true;\n     prettyPrinting = false;\n     escapeHtmlChars = true;\n-    anonAndLocalClassExclusionStrategy = new AnonymousAndLocalClassExclusionStrategy();\n-    innerClassExclusionStrategy = new InnerClassExclusionStrategy();\n     modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY;\n     excludeFieldsWithoutExposeAnnotation = false;\n     longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n       strategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n     }\n     if (excludeFieldsWithoutExposeAnnotation) {\n-      strategies.add(new ExposeAnnotationBasedExclusionStrategy());\n+      strategies.add(exposeAnnotationExclusionStrategy);\n     }\n     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n \n     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers());\n \n     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n-      instanceCreators.copyOf();\n+        instanceCreators.copyOf();\n     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators());\n-    MappedObjectConstructor objConstructor = Gson.createObjectConstructor(customInstanceCreators);\n+    \n+    customSerializers.makeUnmodifiable();\n+    customDeserializers.makeUnmodifiable();\n+    instanceCreators.makeUnmodifiable();\n+    \n+    MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators);\n \n     JsonFormatter formatter =  prettyPrinting ?\n         new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n   private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n-    // NOTE: if a date pattern exists, then that style takes priority\n-    DefaultDateTypeAdapter dateTypeAdapter = null;\n-    if (datePattern != null && !\"\".equals(datePattern.trim())) {\n-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n-    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n-    }\n-    if (dateTypeAdapter != null\n-        && !serializers.hasSpecificHandlerFor(Date.class)\n+    if (!serializers.hasSpecificHandlerFor(Date.class)\n         && !deserializers.hasSpecificHandlerFor(Date.class)) {\n-      serializers.register(Date.class, dateTypeAdapter);\n-      deserializers.register(Date.class, dateTypeAdapter);\n+      // NOTE: if a date pattern exists, then that style takes priority\n+      DefaultDateTypeAdapter dateTypeAdapter = null;\n+      if (datePattern != null && !\"\".equals(datePattern.trim())) {\n+        dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n+      } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n+        dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n+      }\n+      \n+      if (dateTypeAdapter != null) {\n+        serializers.register(Date.class, dateTypeAdapter);\n+        deserializers.register(Date.class, dateTypeAdapter);\n+      }\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n+++ b/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n     if (child.isJsonNull()) {\n       visitor.visitNullArrayMember(parent, isFirst);\n       navigate(child);\n-\t} else if (child.isJsonArray()) {\n+\t  } else if (child.isJsonArray()) {\n       JsonArray childAsArray = child.getAsJsonArray();\n       visitor.visitArrayMember(parent, childAsArray, isFirst);\n       navigate(childAsArray);\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n final class MappedObjectConstructor implements ObjectConstructor {\n   private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\n \n-  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap =\n-      new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n+  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap;\n+  \n+  public MappedObjectConstructor(\n+      ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n+    instanceCreatorMap = instanceCreators;\n+  }\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T construct(Type typeOfT) {\n--- a/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n   }\n \n   /**\n-   * Creates a new {@link ObjectNavigator} for this {@code srcObject}.\n-   *\n-   * @see #create(Object, Type)\n-   * @param srcObject object to navigate\n-   * @return a new instance of a {@link ObjectNavigator} ready to navigate the\n-   *         {@code srcObject}.\n-   */\n-  public ObjectNavigator create(Object srcObject) {\n-    return create(srcObject, srcObject.getClass());\n-  }\n-\n-  /**\n    * Creates a new {@link ObjectNavigator} for this {@code srcObject},\n    * {@code type} pair.\n    *\n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n \n   public void testBadInstantiation() throws Exception {\n     try {\n-      new DisjunctionExclusionStrategy();\n-    } catch (IllegalArgumentException expected) { }\n-\n-    try {\n-      ExclusionStrategy[] constructorParam = null;\n-      new DisjunctionExclusionStrategy(constructorParam);\n-    } catch (IllegalArgumentException expected) { }\n-\n-    try {\n-      ExclusionStrategy[] constructorParam = new ExclusionStrategy[0];\n-      new DisjunctionExclusionStrategy(constructorParam);\n-    } catch (IllegalArgumentException expected) { }\n-\n-    try {\n       List<ExclusionStrategy> constructorParam = null;\n-      new DisjunctionExclusionStrategy(constructorParam);\n-    } catch (IllegalArgumentException expected) { }\n-\n-    try {\n-      List<ExclusionStrategy> constructorParam = new LinkedList<ExclusionStrategy>();\n       new DisjunctionExclusionStrategy(constructorParam);\n     } catch (IllegalArgumentException expected) { }\n   }\n \n   public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {\n-    DisjunctionExclusionStrategy strategy =\n-        new DisjunctionExclusionStrategy(FALSE_STRATEGY, TRUE_STRATEGY);\n+    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    strategies.add(FALSE_STRATEGY);\n+    strategies.add(TRUE_STRATEGY);\n+    DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies);\n \n     assertTrue(strategy.shouldSkipClass(CLAZZ));\n     assertTrue(strategy.shouldSkipField(FIELD));\n   }\n \n   public void testSkipFieldsWithFalseOnly() throws Exception {\n-    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(FALSE_STRATEGY);\n+    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    strategies.add(FALSE_STRATEGY);\n+    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(strategies);\n \n     assertFalse(strategy.shouldSkipClass(CLAZZ));\n     assertFalse(strategy.shouldSkipField(FIELD));", "timestamp": 1232440701, "metainfo": ""}