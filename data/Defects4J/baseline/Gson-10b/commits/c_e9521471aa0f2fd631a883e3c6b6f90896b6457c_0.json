{"sha": "e9521471aa0f2fd631a883e3c6b6f90896b6457c", "log": "Fix typo: Paramterized was spelled wong.", "commit": "\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.internal.$Gson$Types;\n+\n+import com.google.gson.internal.Primitives;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+\n+/**\n+ * This class contains some test fixtures for Parameterized types. These classes should ideally\n+ * belong either in the common or functional package, but they are placed here because they need\n+ * access to package protected elements of com.google.gson.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ParameterizedTypeFixtures {\n+\n+  public static class MyParameterizedType<T> {\n+    public final T value;\n+    public MyParameterizedType(T value) {\n+      this.value = value;\n+    }\n+    public T getValue() {\n+      return value;\n+    }\n+\n+    public String getExpectedJson() {\n+      String valueAsJson = getExpectedJson(value);\n+      return String.format(\"{\\\"value\\\":%s}\", valueAsJson);\n+    }\n+\n+    private String getExpectedJson(Object obj) {\n+      Class<?> clazz = obj.getClass();\n+      if (Primitives.isWrapperType(Primitives.wrap(clazz))) {\n+        return obj.toString();\n+      } else if (obj.getClass().equals(String.class)) {\n+        return \"\\\"\" + obj.toString() + \"\\\"\";\n+      } else {\n+        // Try invoking a getExpectedJson() method if it exists\n+        try {\n+          Method method = clazz.getMethod(\"getExpectedJson\");\n+          Object results = method.invoke(obj);\n+          return (String) results;\n+        } catch (SecurityException e) {\n+          throw new RuntimeException(e);\n+        } catch (NoSuchMethodException e) {\n+          throw new RuntimeException(e);\n+        } catch (IllegalArgumentException e) {\n+          throw new RuntimeException(e);\n+        } catch (IllegalAccessException e) {\n+          throw new RuntimeException(e);\n+        } catch (InvocationTargetException e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return value == null ? 0 : value.hashCode();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (this == obj) {\n+        return true;\n+      }\n+      if (obj == null) {\n+        return false;\n+      }\n+      if (getClass() != obj.getClass()) {\n+        return false;\n+      }\n+      MyParameterizedType<T> other = (MyParameterizedType<T>) obj;\n+      if (value == null) {\n+        if (other.value != null) {\n+          return false;\n+        }\n+      } else if (!value.equals(other.value)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+  }\n+\n+  public static class MyParameterizedTypeInstanceCreator<T>\n+      implements InstanceCreator<MyParameterizedType<T>>{\n+    private final T instanceOfT;\n+    /**\n+     * Caution the specified instance is reused by the instance creator for each call.\n+     * This means that the fields of the same objects will be overwritten by Gson.\n+     * This is usually fine in tests since there we deserialize just once, but quite\n+     * dangerous in practice.\n+     *\n+     * @param instanceOfT\n+     */\n+    public MyParameterizedTypeInstanceCreator(T instanceOfT) {\n+      this.instanceOfT = instanceOfT;\n+    }\n+    public MyParameterizedType<T> createInstance(Type type) {\n+      return new MyParameterizedType<T>(instanceOfT);\n+    }\n+  }\n+\n+  public static class MyParameterizedTypeAdapter<T>\n+  implements JsonSerializer<MyParameterizedType<T>>, JsonDeserializer<MyParameterizedType<T>> {\n+    @SuppressWarnings(\"unchecked\")\n+    public static<T> String getExpectedJson(MyParameterizedType<T> obj) {\n+      Class<T> clazz = (Class<T>) obj.value.getClass();\n+      boolean addQuotes = !clazz.isArray() && !Primitives.unwrap(clazz).isPrimitive();\n+      StringBuilder sb = new StringBuilder(\"{\\\"\");\n+      sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\n+      if (addQuotes) {\n+        sb.append(\"\\\"\");\n+      }\n+      sb.append(obj.value.toString());\n+      if (addQuotes) {\n+        sb.append(\"\\\"\");\n+      }\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+\n+    public JsonElement serialize(MyParameterizedType<T> src, Type classOfSrc,\n+        JsonSerializationContext context) {\n+      JsonObject json = new JsonObject();\n+      T value = src.getValue();\n+      json.add(value.getClass().getSimpleName(), context.serialize(value));\n+      return json;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n+        JsonDeserializationContext context) throws JsonParseException {\n+      Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n+      Class<?> rawType = $Gson$Types.getRawType(genericClass);\n+      String className = rawType.getSimpleName();\n+      JsonElement jsonElement = json.getAsJsonObject().get(className);\n+\n+      T value;\n+      if (genericClass == Integer.class) {\n+        value = (T) Integer.valueOf(jsonElement.getAsInt());\n+      } else if (genericClass == String.class) {\n+        value = (T) jsonElement.getAsString();\n+      } else {\n+        value = (T) jsonElement;\n+      }\n+\n+      if (Primitives.isPrimitive(genericClass)) {\n+        PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n+        value = (T) typeAdapter.adaptType(value, rawType);\n+      }\n+      return new MyParameterizedType<T>(value);\n+    }\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedType;\n-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeAdapter;\n-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeInstanceCreator;\n+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedType;\n+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeAdapter;\n+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeInstanceCreator;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.reflect.TypeToken;\n ", "timestamp": 1321821070, "metainfo": ""}