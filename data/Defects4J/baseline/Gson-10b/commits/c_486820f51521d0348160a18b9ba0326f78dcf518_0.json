{"sha": "486820f51521d0348160a18b9ba0326f78dcf518", "log": "Fix some test problems.  JsonWriter was using suboptimal escape characters for newlines etc: unicode escapes rather than \\x escapes.  JsonObjectTest was banning empty and whitespace-only keys. These values are permitted as of r585.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n    */\n   private String separator = \":\";\n \n+  private boolean lenient;\n+\n   /**\n    * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n    * For best performance, ensure {@link Writer} is buffered; wrapping in\n   }\n \n   /**\n+   * Configure this writer to relax its syntax rules. By default, this writer\n+   * only emits well-formed JSON as specified by <a\n+   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the writer\n+   * to lenient permits the following:\n+   * <ul>\n+   *   <li>Top-level values of any type. With strict writing, the top-level\n+   *       value must be an object or an array.\n+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n+   *       Double#isInfinite() infinities}.\n+   * </ul>\n+   */\n+  public void setLenient(boolean lenient) {\n+    this.lenient = lenient;\n+  }\n+\n+  /**\n    * Begins encoding a new array. Each call to this method must be paired with\n    * a call to {@link #endArray}.\n    *\n     }\n \n     String string = value.toString();\n-    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\n+    if (!lenient\n+        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue(false);\n        * quotation mark, reverse solidus, and the control characters\n        * (U+0000 through U+001F).\"\n        */\n-      if (c == '\"' || c == '\\\\') {\n+      switch (c) {\n+      case '\"':\n+      case '\\\\':\n         out.write('\\\\');\n         out.write(c);\n-      } else if (c <= 0x1F) {\n-        out.write(String.format(\"\\\\u%04x\", (int) c));\n-      } else {\n-        out.write(c);\n+        break;\n+\n+      case '\\t':\n+        out.write(\"\\\\t\");\n+        break;\n+\n+      case '\\b':\n+        out.write(\"\\\\b\");\n+        break;\n+\n+      case '\\n':\n+        out.write(\"\\\\n\");\n+        break;\n+\n+      case '\\r':\n+        out.write(\"\\\\r\");\n+        break;\n+\n+      case '\\f':\n+        out.write(\"\\\\f\");\n+        break;\n+\n+      default:\n+        if (c <= 0x1F) {\n+          out.write(String.format(\"\\\\u%04x\", (int) c));\n+        } else {\n+          out.write(c);\n+        }\n+        break;\n       }\n     }\n     out.write(\"\\\"\");\n   private void beforeValue(boolean root) throws IOException {\n     switch (peek()) {\n     case EMPTY_DOCUMENT: // first in document\n-      if (!root) {\n+      if (!lenient && !root) {\n         throw new IllegalStateException(\n             \"JSON must start with an array or an object.\");\n       }\n--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java\n       fail(\"Should not allow null property names.\");\n     } catch (IllegalArgumentException expected) { }\n \n-    try {\n-      jsonObj.add(\"\", JsonNull.createJsonNull());\n-      fail(\"Should not allow empty property names.\");\n-    } catch (IllegalArgumentException expected) { }\n-\n-    try {\n-      jsonObj.add(\"   \\t\", JsonNull.createJsonNull());\n-      fail(\"Should not allow whitespace only property names.\");\n-    } catch (IllegalArgumentException expected) { }\n+    jsonObj.add(\"\", JsonNull.createJsonNull());\n+    jsonObj.add(\"   \\t\", JsonNull.createJsonNull());\n   }\n \n   public void testAddingBooleanProperties() throws Exception {", "timestamp": 1282983493, "metainfo": ""}