{"sha": "747e3c3051153779954e49b7dbc475daa678e1f4", "log": "Support mixed streaming and databinding with new APIs.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n package com.google.gson;\n \n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.io.Reader;\n import java.io.StringReader;\n \n   private final JsonFormatter formatter;\n   private final boolean serializeNulls;\n+  private final boolean htmlSafe;\n \n   private final boolean generateNonExecutableJson;\n \n     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n     new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n     DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n-    DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE);\n+    DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true);\n   }\n \n   Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\n       JsonFormatter formatter, boolean serializeNulls,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n-      boolean generateNonExecutableGson) {\n+      boolean generateNonExecutableGson, boolean htmlSafe) {\n     this.serializationStrategy = serializationStrategy;\n     this.deserializationStrategy = deserializationStrategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.serializers = serializers;\n     this.deserializers = deserializers;\n     this.generateNonExecutableJson = generateNonExecutableGson;\n+    this.htmlSafe = htmlSafe;\n   }\n \n   private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\n    */\n   public String toJson(Object src, Type typeOfSrc) {\n     StringWriter writer = new StringWriter();\n-    toJson(src, typeOfSrc, writer);\n+    toJson(toJsonTree(src, typeOfSrc), writer);\n     return writer.toString();\n   }\n \n   }\n \n   /**\n+   * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to\n+   * {@code writer}.\n+   */\n+  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) {\n+    toJson(toJsonTree(src, typeOfSrc), writer);\n+  }\n+\n+  /**\n    * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.\n    *\n    * @param jsonElement root of a tree of {@link JsonElement}s\n       if (generateNonExecutableJson) {\n         writer.append(JSON_NON_EXECUTABLE_PREFIX);\n       }\n-      if (jsonElement == null && serializeNulls) {\n-        writeOutNullString(writer);\n-      }\n-      formatter.format(jsonElement, writer, serializeNulls);\n+      toJson(jsonElement, new JsonWriter(Streams.writerForAppendable(writer)));\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Writes the JSON for {@code jsonElement} to {@code writer}.\n+   */\n+  public void toJson(JsonElement jsonElement, JsonWriter writer) {\n+    boolean oldLenient = writer.isLenient();\n+    writer.setLenient(true);\n+    boolean oldHtmlSafe = writer.isHtmlSafe();\n+    writer.setHtmlSafe(htmlSafe);\n+    try {\n+      Streams.write(jsonElement, serializeNulls, writer);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    } finally {\n+      writer.setLenient(oldLenient);\n+      writer.setHtmlSafe(oldHtmlSafe);\n     }\n   }\n \n    * @since 1.2\n    */\n   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException {\n-    T target = classOfT.cast(fromJson(json, (Type) classOfT));\n+    T target = classOfT.cast(fromJson(new JsonReader(json), classOfT));\n     return target;\n   }\n \n    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n    * @since 1.2\n    */\n-  @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonReader jsonReader = new JsonReader(json);\n-    jsonReader.setLenient(true);\n-    JsonElement root = Streams.parse(jsonReader);\n-    return (T) fromJson(root, typeOfT);\n+    return this.<T>fromJson(new JsonReader(json), typeOfT);\n+  }\n+\n+  /**\n+   * Reads the next JSON value from {@code reader} and convert it to an object\n+   * of type {@code typeOfT}.\n+   */\n+  @SuppressWarnings(\"unchecked\") // this method is unsafe and should be used very carefully\n+  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+    boolean oldLenient = reader.isLenient();\n+    reader.setLenient(true);\n+    try {\n+      JsonElement root = Streams.parse(reader);\n+      return (T) fromJson(root, typeOfT);\n+    } finally {\n+      reader.setLenient(oldLenient);\n+    }\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n         new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy,\n         fieldNamingPolicy, objConstructor, formatter, serializeNulls, customSerializers,\n-        customDeserializers, generateNonExecutableJson);\n+        customDeserializers, generateNonExecutableJson, escapeHtmlChars);\n     return gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n    * @since 1.3\n    */\n   public JsonElement parse(Reader json) throws JsonParseException {\n+    return parse(new JsonReader(json));\n+  }\n+\n+  /**\n+   * Returns the next value from the JSON stream as a parse tree.\n+   *\n+   * @throws JsonParseException if there is an IOException or if the specified\n+   *     text is not valid JSON\n+   */\n+  public JsonElement parse(JsonReader json) throws JsonParseException {\n+    boolean lenient = json.isLenient();\n+    json.setLenient(true);\n     try {\n-      JsonReader jsonReader = new JsonReader(json);\n-      jsonReader.setLenient(true);\n-      return Streams.parse(jsonReader);\n+      return Streams.parse(json);\n     } catch (StackOverflowError e) {\n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n       } else {\n         throw e;\n       }\n+    } finally {\n+      json.setLenient(lenient);\n     }\n-  }  \n+  }\n }\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n \n   private boolean lenient;\n \n+  private boolean htmlSafe;\n+\n   /**\n    * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n    * For best performance, ensure {@link Writer} is buffered; wrapping in\n    */\n   public void setLenient(boolean lenient) {\n     this.lenient = lenient;\n+  }\n+\n+  /**\n+   * Returns true if this writer has relaxed syntax rules.\n+   */\n+  public boolean isLenient() {\n+    return lenient;\n+  }\n+\n+  /**\n+   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n+   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n+   * {@code &} and {@code =} before writing them to the stream. Without this\n+   * setting, your XML/HTML encoder should replace these characters with the\n+   * corresponding escape sequences.\n+   */\n+  public void setHtmlSafe(boolean htmlSafe) {\n+    this.htmlSafe = htmlSafe;\n+  }\n+\n+  /**\n+   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n+   * and XML documents.\n+   */\n+  public boolean isHtmlSafe() {\n+    return htmlSafe;\n   }\n \n   /**\n         out.write(\"\\\\f\");\n         break;\n \n+      case '<':\n+      case '>':\n+      case '&':\n+      case '=':\n+      case '\\'':\n+        if (htmlSafe) {\n+          out.write(String.format(\"\\\\u%04x\", (int) c));\n+        } else {\n+          out.write(c);\n+        }\n+        break;\n+\n       default:\n         if (c <= 0x1F) {\n           out.write(String.format(\"\\\\u%04x\", (int) c));\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,\n         new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n         Gson.DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n-        DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE);\n+        DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE, true);\n     assertEquals(\"{}\", gson.toJson(new ClassWithNoFields() {\n       // empty anonymous class\n     }));\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/MixedStreamTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import junit.framework.TestCase;\n+\n+public final class MixedStreamTest extends TestCase {\n+\n+  private static final Car BLUE_MUSTANG = new Car(\"mustang\", 0x0000FF);\n+  private static final Car BLACK_BMW = new Car(\"bmw\", 0x000000);\n+  private static final Car RED_MIATA = new Car(\"miata\", 0xFF0000);\n+  private static final String CARS_JSON = \"[\\n\"\n+      + \"  {\\n\"\n+      + \"    \\\"name\\\": \\\"mustang\\\",\\n\"\n+      + \"    \\\"color\\\": 255\\n\"\n+      + \"  },\\n\"\n+      + \"  {\\n\"\n+      + \"    \\\"name\\\": \\\"bmw\\\",\\n\"\n+      + \"    \\\"color\\\": 0\\n\"\n+      + \"  },\\n\"\n+      + \"  {\\n\"\n+      + \"    \\\"name\\\": \\\"miata\\\",\\n\"\n+      + \"    \\\"color\\\": 16711680\\n\"\n+      + \"  }\\n\"\n+      + \"]\";\n+\n+  public void testWriteMixedStreamed() throws IOException {\n+    Gson gson = new Gson();\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+\n+    jsonWriter.beginArray();\n+    jsonWriter.setIndent(\"  \");\n+    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\n+    gson.toJson(BLACK_BMW, Car.class, jsonWriter);\n+    gson.toJson(RED_MIATA, Car.class, jsonWriter);\n+    jsonWriter.endArray();\n+\n+    assertEquals(CARS_JSON, stringWriter.toString());\n+  }\n+\n+  public void testReadMixedStreamed() throws IOException {\n+    Gson gson = new Gson();\n+    StringReader stringReader = new StringReader(CARS_JSON);\n+    JsonReader jsonReader = new JsonReader(stringReader);\n+\n+    jsonReader.beginArray();\n+    assertEquals(BLUE_MUSTANG, gson.fromJson(jsonReader, Car.class));\n+    assertEquals(BLACK_BMW, gson.fromJson(jsonReader, Car.class));\n+    assertEquals(RED_MIATA, gson.fromJson(jsonReader, Car.class));\n+    jsonReader.endArray();\n+  }\n+\n+  static final class Car {\n+    String name;\n+    int color;\n+\n+    Car(String name, int color) {\n+      this.name = name;\n+      this.color = color;\n+    }\n+\n+    Car() {} // for Gson\n+\n+    @Override public int hashCode() {\n+      return name.hashCode() ^ color;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Car\n+          && ((Car) o).name.equals(name)\n+          && ((Car) o).color == color;\n+    }\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/EscapingTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/EscapingTest.java\n     strings.add(\"&\");\n     strings.add(\"'\");\n     strings.add(\"\\\"\");\n-    assertEquals(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u003d\\\",\\\"\\\\u0026\\\",\\\"'\\\",\\\"\\\\\\\"\\\"]\",\n+    assertEquals(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u003d\\\",\\\"\\\\u0026\\\",\\\"\\\\u0027\\\",\\\"\\\\\\\"\\\"]\",\n         gson.toJson(strings));\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java\n     gsonBuilder = new GsonBuilder();\n     Gson gson = gsonBuilder.setPrettyPrinting().create();\n     String result = gson.toJson(new ClassWithMembers());\n-    assertEquals(\"{}\\n\", result);\n+    assertEquals(\"{}\", result);\n \n     gson = gsonBuilder.serializeNulls().create();\n     result = gson.toJson(new ClassWithMembers());\n     gsonBuilder = new GsonBuilder();\n     Gson gson = gsonBuilder.setPrettyPrinting().create();\n     String result = gson.toJson(new String[] { \"1\", null, \"3\" });\n-    assertEquals(\"[\\\"1\\\",null,\\\"3\\\"]\\n\", result);\n+    assertEquals(\"[\\\"1\\\",null,\\\"3\\\"]\", result);\n \n     gson = gsonBuilder.serializeNulls().create();\n     result = gson.toJson(new String[] { \"1\", null, \"3\" });\n-    assertEquals(\"[\\\"1\\\",null,\\\"3\\\"]\\n\", result);\n+    assertEquals(\"[\\\"1\\\",null,\\\"3\\\"]\", result);\n   }\n \n   private static class ClassWithNullWrappedPrimitive {\n--- a/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java\n     Type typeOfSrc = new TypeToken<List<BagOfPrimitives>>() {}.getType();\n     String json = gson.toJson(listOfB, typeOfSrc);\n     print(json);\n-    assertPrintMargin(json);\n   }\n \n   public void testPrettyPrintArrayOfObjects() {\n     ArrayOfObjects target = new ArrayOfObjects();\n     String json = gson.toJson(target);\n     print(json);\n-    assertPrintMargin(json);\n   }\n \n   public void testPrettyPrintArrayOfPrimitives() {\n     int[] ints = new int[] { 1, 2, 3, 4, 5 };\n     String json = gson.toJson(ints);\n-    assertEquals(\"[1,2,3,4,5]\\n\", json);\n+    assertEquals(\"[1,2,3,4,5]\", json);\n   }\n \n   public void testPrettyPrintArrayOfPrimitiveArrays() {\n     int[][] ints = new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 },\n         { 9, 0 }, { 10 } };\n     String json = gson.toJson(ints);\n-    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\\n\", json);\n+    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\", json);\n   }\n \n   public void testPrettyPrintListOfPrimitiveArrays() {\n     List<Integer[]> list = Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 },\n         { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } });\n     String json = gson.toJson(list);\n-    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\\n\", json);\n+    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\", json);\n   }\n   \n   public void testMap() {\n     map.put(\"abc\", 1);\n     map.put(\"def\", 5);\n     String json = gson.toJson(map);\n-    assertEquals(\"{\\\"abc\\\":1,\\\"def\\\":5}\\n\", json);\n+    assertEquals(\"{\\\"abc\\\":1,\\\"def\\\":5}\", json);\n   }\n \n   // In response to bug 153\n   public void testMultipleArrays() {\n     int[][][] ints = new int[][][] { { { 1 }, { 2 } } };\n     String json = gson.toJson(ints);\n-    assertEquals(\"[[[1],[2]]]\\n\", json);\n+    assertEquals(\"[[[1],[2]]]\", json);\n   }\n \n   private void print(String msg) {\n       System.out.println(msg);\n     }\n   }\n-\n-  private void assertPrintMargin(String str) {\n-    int position = 0;\n-    char[] chars = str.toCharArray();\n-    for (int i = 0; i < chars.length; ++i, ++position) {\n-      char c = chars[i];\n-      if (c == '\\n') {\n-        position = 0;\n-      }\n-      assertTrue(position <= PRINT_MARGIN - RIGHT_MARGIN + 1);\n-    }\n-  }\n }", "timestamp": 1283386523, "metainfo": ""}