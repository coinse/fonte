{"sha": "ad3489f557d951ebd4574d04adf4b0bb4108d05f", "log": "First steps to StringMap, an alternative to LinkedHashmap.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n-import java.util.LinkedHashMap;\n+import com.google.gson.internal.StringMap;\n import java.util.Map;\n import java.util.Set;\n \n   // the order in which elements are inserted. This is needed to ensure\n   // that the fields of an object are inserted in the order they were\n   // defined in the class.\n-  private final Map<String, JsonElement> members = new LinkedHashMap<String, JsonElement>();\n+  private final StringMap<String, JsonElement> members = new StringMap<String, JsonElement>();\n \n   /**\n    * Creates an empty JsonObject.\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n     if (Map.class.isAssignableFrom(rawType)) {\n       return new ObjectConstructor<T>() {\n         public T construct() {\n+          // TODO: if the map's key type is a string, should this be StringMap?\n           return (T) new LinkedHashMap<Object, Object>();\n         }\n       };\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/StringMap.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements. See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A map of strings to values. Like LinkedHashMap, this map's iteration order is\n+ * well defined: it is the order that elements were inserted into the map.\n+ * \n+ * <p>This implementation was derived from Android 4.0's LinkedHashMap.\n+ */\n+public final class StringMap<K, V> extends AbstractMap<K, V> {\n+  // TODO: defend against predictable hash collisions\n+  \n+  /**\n+   * Min capacity (other than zero) for a HashMap. Must be a power of two\n+   * greater than 1 (and less than 1 << 30).\n+   */\n+  private static final int MINIMUM_CAPACITY = 4;\n+\n+  /**\n+   * Max capacity for a HashMap. Must be a power of two >= MINIMUM_CAPACITY.\n+   */\n+  private static final int MAXIMUM_CAPACITY = 1 << 30;\n+\n+  /**\n+   * A dummy entry in the circular linked list of entries in the map.\n+   * The first real entry is header.nxt, and the last is header.prv.\n+   * If the map is empty, header.nxt == header && header.prv == header.\n+   */\n+  private LinkedEntry<K, V> header;\n+\n+  /**\n+   * An empty table shared by all zero-capacity maps (typically from default\n+   * constructor). It is never written to, and replaced on first put. Its size\n+   * is set to half the minimum, so that the first resize will create a\n+   * minimum-sized table.\n+   */\n+  private static final Entry[] EMPTY_TABLE = new LinkedEntry[MINIMUM_CAPACITY >>> 1];\n+\n+  /**\n+   * The hash table. If this hash map contains a mapping for null, it is\n+   * not represented this hash table.\n+   */\n+  private LinkedEntry<K, V>[] table;\n+\n+  /**\n+   * The number of mappings in this hash map.\n+   */\n+  private int size;\n+\n+  /**\n+   * The table is rehashed when its size exceeds this threshold.\n+   * The value of this field is generally .75 * capacity, except when\n+   * the capacity is zero, as described in the EMPTY_TABLE declaration\n+   * above.\n+   */\n+  private int threshold;\n+\n+  // Views - lazily initialized\n+  private Set<K> keySet;\n+  private Set<Entry<K, V>> entrySet;\n+  private Collection<V> values;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public StringMap() {\n+    table = (LinkedEntry<K, V>[]) EMPTY_TABLE;\n+    threshold = -1; // Forces first put invocation to replace EMPTY_TABLE\n+    header = new LinkedEntry<K, V>();\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object key) {\n+    return get(key) != null;\n+  }\n+\n+  @Override public V get(Object key) {\n+    if (key == null) {\n+      return null;\n+    }\n+\n+    // Doug Lea's supplemental secondaryHash function (inlined)\n+    int hash = key.hashCode();\n+    hash ^= (hash >>> 20) ^ (hash >>> 12);\n+    hash ^= (hash >>> 7) ^ (hash >>> 4);\n+\n+    LinkedEntry<K, V>[] tab = table;\n+    for (LinkedEntry<K, V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n+      K eKey = e.key;\n+      if (eKey == key || (e.hash == hash && key.equals(eKey))) {\n+        return e.value;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    if (key == null || value == null) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    int hash = secondaryHash(key.hashCode());\n+    LinkedEntry<K, V>[] tab = table;\n+    int index = hash & (tab.length - 1);\n+    for (LinkedEntry<K, V> e = tab[index]; e != null; e = e.next) {\n+      if (e.hash == hash && key.equals(e.key)) {\n+        V oldValue = e.value;\n+        e.value = value;\n+        return oldValue;\n+      }\n+    }\n+\n+    // No entry for (non-null) key is present; create one\n+    if (size++ > threshold) {\n+      tab = doubleCapacity();\n+      index = hash & (tab.length - 1);\n+    }\n+    addNewEntry(key, value, hash, index);\n+    return null;\n+  }\n+\n+  private void addNewEntry(K key, V value, int hash, int index) {\n+    LinkedEntry<K, V> header = this.header;\n+\n+    // Create new entry, link it on to list, and put it into table\n+    LinkedEntry<K, V> oldTail = header.prv;\n+    LinkedEntry<K, V> newTail = new LinkedEntry<K, V>(\n+        key, value, hash, table[index], header, oldTail);\n+    table[index] = oldTail.nxt = header.prv = newTail;\n+  }\n+\n+  /**\n+   * Allocate a table of the given capacity and set the threshold accordingly.\n+   * @param newCapacity must be a power of two\n+   */\n+  private LinkedEntry<K, V>[] makeTable(int newCapacity) {\n+    @SuppressWarnings(\"unchecked\")\n+    LinkedEntry<K, V>[] newTable = (LinkedEntry<K, V>[]) new LinkedEntry[newCapacity];\n+    table = newTable;\n+    threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity\n+    return newTable;\n+  }\n+\n+  /**\n+   * Doubles the capacity of the hash table. Existing entries are placed in\n+   * the correct bucket on the enlarged table. If the current capacity is,\n+   * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which\n+   * will be new unless we were already at MAXIMUM_CAPACITY.\n+   */\n+  private LinkedEntry<K, V>[] doubleCapacity() {\n+    LinkedEntry<K, V>[] oldTable = table;\n+    int oldCapacity = oldTable.length;\n+    if (oldCapacity == MAXIMUM_CAPACITY) {\n+      return oldTable;\n+    }\n+    int newCapacity = oldCapacity * 2;\n+    LinkedEntry<K, V>[] newTable = makeTable(newCapacity);\n+    if (size == 0) {\n+      return newTable;\n+    }\n+\n+    for (int j = 0; j < oldCapacity; j++) {\n+      /*\n+       * Rehash the bucket using the minimum number of field writes.\n+       * This is the most subtle and delicate code in the class.\n+       */\n+      LinkedEntry<K, V> e = oldTable[j];\n+      if (e == null) {\n+        continue;\n+      }\n+      int highBit = e.hash & oldCapacity;\n+      LinkedEntry<K, V> broken = null;\n+      newTable[j | highBit] = e;\n+      for (LinkedEntry<K, V> n = e.next; n != null; e = n, n = n.next) {\n+        int nextHighBit = n.hash & oldCapacity;\n+        if (nextHighBit != highBit) {\n+          if (broken == null) {\n+            newTable[j | nextHighBit] = n;\n+          } else {\n+            broken.next = n;\n+          }\n+          broken = e;\n+          highBit = nextHighBit;\n+        }\n+      }\n+      if (broken != null) {\n+        broken.next = null;\n+      }\n+    }\n+    return newTable;\n+  }\n+\n+  @Override public V remove(Object key) {\n+    if (key == null) {\n+      return null;\n+    }\n+    int hash = secondaryHash(key.hashCode());\n+    LinkedEntry<K, V>[] tab = table;\n+    int index = hash & (tab.length - 1);\n+    for (LinkedEntry<K, V> e = tab[index], prev = null;\n+        e != null; prev = e, e = e.next) {\n+      if (e.hash == hash && key.equals(e.key)) {\n+        if (prev == null) {\n+          tab[index] = e.next;\n+        } else {\n+          prev.next = e.next;\n+        }\n+        size--;\n+        unlink(e);\n+        return e.value;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private void unlink(LinkedEntry<K, V> e) {\n+    e.prv.nxt = e.nxt;\n+    e.nxt.prv = e.prv;\n+    e.nxt = e.prv = null; // Help the GC (for performance)\n+  }\n+\n+  @Override public void clear() {\n+    if (size != 0) {\n+      Arrays.fill(table, null);\n+      size = 0;\n+    }\n+\n+    // Clear all links to help GC\n+    LinkedEntry<K, V> header = this.header;\n+    for (LinkedEntry<K, V> e = header.nxt; e != header; ) {\n+      LinkedEntry<K, V> nxt = e.nxt;\n+      e.nxt = e.prv = null;\n+      e = nxt;\n+    }\n+\n+    header.nxt = header.prv = header;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    Set<K> ks = keySet;\n+    return (ks != null) ? ks : (keySet = new KeySet());\n+  }\n+\n+  @Override public Collection<V> values() {\n+    Collection<V> vs = values;\n+    return (vs != null) ? vs : (values = new Values());\n+  }\n+\n+  public Set<Entry<K, V>> entrySet() {\n+    Set<Entry<K, V>> es = entrySet;\n+    return (es != null) ? es : (entrySet = new EntrySet());\n+  }\n+\n+  static class LinkedEntry<K, V> implements Entry<K, V> {\n+    final K key;\n+    V value;\n+    final int hash;\n+    LinkedEntry<K, V> next;\n+    LinkedEntry<K, V> nxt;\n+    LinkedEntry<K, V> prv;\n+\n+    /** Create the header entry */\n+    LinkedEntry() {\n+      this(null, null, 0, null, null, null);\n+      nxt = prv = this;\n+    }\n+\n+    LinkedEntry(K key, V value, int hash, LinkedEntry<K, V> next,\n+        LinkedEntry<K, V> nxt, LinkedEntry<K, V> prv) {\n+      this.key = key;\n+      this.value = value;\n+      this.hash = hash;\n+      this.next = next;\n+      this.nxt = nxt;\n+      this.prv = prv;\n+    }\n+\n+    public final K getKey() {\n+      return key;\n+    }\n+\n+    public final V getValue() {\n+      return value;\n+    }\n+\n+    public final V setValue(V value) {\n+      if (value == null) {\n+        throw new IllegalArgumentException();\n+      }\n+      V oldValue = this.value;\n+      this.value = value;\n+      return oldValue;\n+    }\n+\n+    @Override public final boolean equals(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+      Entry<?, ?> e = (Entry<?, ?>) o;\n+      return key.equals(e.getKey()) && value.equals(e.getValue());\n+    }\n+\n+    @Override public final int hashCode() {\n+      return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());\n+    }\n+\n+    @Override public final String toString() {\n+      return key + \"=\" + value;\n+    }\n+  }\n+\n+  /**\n+   * Removes the mapping from key to value and returns true if this mapping\n+   * exists; otherwise, returns does nothing and returns false.\n+   */\n+  private boolean removeMapping(Object key, Object value) {\n+    if (key == null || value == null) {\n+      return false;\n+    }\n+\n+    int hash = secondaryHash(key.hashCode());\n+    LinkedEntry<K, V>[] tab = table;\n+    int index = hash & (tab.length - 1);\n+    for (LinkedEntry<K, V> e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n+      if (e.hash == hash && key.equals(e.key)) {\n+        if (!value.equals(e.value)) {\n+          return false;  // Map has wrong value for key\n+        }\n+        if (prev == null) {\n+          tab[index] = e.next;\n+        } else {\n+          prev.next = e.next;\n+        }\n+        size--;\n+        unlink(e);\n+        return true;\n+      }\n+    }\n+    return false; // No entry for key\n+  }\n+\n+  private abstract class LinkedHashIterator<T> implements Iterator<T> {\n+    LinkedEntry<K, V> next = header.nxt;\n+    LinkedEntry<K, V> lastReturned = null;\n+\n+    public final boolean hasNext() {\n+      return next != header;\n+    }\n+\n+    final LinkedEntry<K, V> nextEntry() {\n+      LinkedEntry<K, V> e = next;\n+      if (e == header) {\n+        throw new NoSuchElementException();\n+      }\n+      next = e.nxt;\n+      return lastReturned = e;\n+    }\n+\n+    public final void remove() {\n+      if (lastReturned == null) {\n+        throw new IllegalStateException();\n+      }\n+      StringMap.this.remove(lastReturned.key);\n+      lastReturned = null;\n+    }\n+  }\n+\n+  private final class KeySet extends AbstractSet<K> {\n+    public Iterator<K> iterator() {\n+      return new LinkedHashIterator<K>() {\n+        public final K next() {\n+          return nextEntry().key;\n+        }\n+      };\n+    }\n+\n+    public int size() {\n+      return size;\n+    }\n+\n+    public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+\n+    public boolean remove(Object o) {\n+      int oldSize = size;\n+      StringMap.this.remove(o);\n+      return size != oldSize;\n+    }\n+\n+    public void clear() {\n+      StringMap.this.clear();\n+    }\n+  }\n+\n+  private final class Values extends AbstractCollection<V> {\n+    public Iterator<V> iterator() {\n+      return new LinkedHashIterator<V>() {\n+        public final V next() {\n+          return nextEntry().value;\n+        }\n+      };\n+    }\n+\n+    public int size() {\n+      return size;\n+    }\n+\n+    public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+\n+    public void clear() {\n+      StringMap.this.clear();\n+    }\n+  }\n+\n+  private final class EntrySet extends AbstractSet<Entry<K, V>> {\n+    public Iterator<Entry<K, V>> iterator() {\n+      return new LinkedHashIterator<Map.Entry<K, V>>() {\n+        public final Map.Entry<K, V> next() {\n+          return nextEntry();\n+        }\n+      };\n+    }\n+\n+    public boolean contains(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+      Entry<?, ?> e = (Entry<?, ?>) o;\n+      V mappedValue = get(e.getKey());\n+      return mappedValue != null && mappedValue.equals(e.getValue());\n+    }\n+\n+    public boolean remove(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+      Entry<?, ?> e = (Entry<?, ?>) o;\n+      return removeMapping(e.getKey(), e.getValue());\n+    }\n+\n+    public int size() {\n+      return size;\n+    }\n+\n+    public void clear() {\n+      StringMap.this.clear();\n+    }\n+  }\n+\n+  /**\n+   * Applies a supplemental hash function to a given hashCode, which defends\n+   * against poor quality hash functions. This is critical because HashMap\n+   * uses power-of-two length hash tables, that otherwise encounter collisions\n+   * for hashCodes that do not differ in lower or upper bits.\n+   */\n+  private static int secondaryHash(int h) {\n+    // Doug Lea's supplemental hash function\n+    h ^= (h >>> 20) ^ (h >>> 12);\n+    return h ^ (h >>> 7) ^ (h >>> 4);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.StringMap;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n \n       return list;\n \n     case BEGIN_OBJECT:\n-      Map<String, Object> map = new LinkedHashMap<String, Object>();\n+      Map<String, Object> map = new StringMap<String, Object>();\n       in.beginObject();\n       while (in.hasNext()) {\n         map.put(in.nextName(), read(in));\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n    * Consumes the non-execute prefix if it exists.\n    */\n   private void consumeNonExecutePrefix() throws IOException {\n-    // TODO: there's a bug here. We're going to call nextNonWhitespace and we have a character that\n-    //       we can't necessarily push back (because pos could be 0)\n-\n     // fast forward through the leading whitespace\n     nextNonWhitespace(true);\n     pos--;", "timestamp": 1331474081, "metainfo": ""}