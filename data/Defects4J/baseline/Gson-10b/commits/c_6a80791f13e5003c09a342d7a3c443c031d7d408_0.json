{"sha": "6a80791f13e5003c09a342d7a3c443c031d7d408", "log": "Code cleanup and some minor performance fixes.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n         if (value == null) {\n           valueElement = JsonNull.createJsonNull();\n         } else {\n-          Type childType = (childGenericType == null) ? \n-              childType = value.getClass() : childGenericType;\n+          Type childType = (childGenericType == null)\n+              ? value.getClass() : childGenericType;\n           valueElement = context.serialize(value, childType);\n         }\n         map.add(String.valueOf(entry.getKey()), valueElement);\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.logging.Logger;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n   // constructor instead. At the minimum, mark those methods private.\n \n   private static final String NULL_STRING = \"null\";\n+\n   // Default instances of plug-ins\n   static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n       new ModifierBasedExclusionStrategy(true, new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n   static final JsonFormatter DEFAULT_JSON_FORMATTER = new JsonCompactFormatter();\n   static final FieldNamingStrategy DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n-\n-  static final Logger logger = Logger.getLogger(Gson.class.getName());\n \n   private final ExclusionStrategy strategy;\n   private final FieldNamingStrategy fieldNamingPolicy;\n   \n   @Override \n   public String toString() {\n-\tStringBuilder sb = new StringBuilder(\"{\");\n-    sb.append(\"serializeNulls:\").append(serializeNulls);\n-\tsb.append(\",serializers:\").append(serializers);\n-\tsb.append(\",deserializers:\").append(deserializers);\n-\t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are \n-\t// more familiar with the concept of Instance Creators. Moreover, the objectConstructor is\n-\t// just a utility class around instance creators, and its toString() only displays them.\n-    sb.append(\",instanceCreators:\").append(objectConstructor);\n-\tsb.append(\"}\");\n-\treturn sb.toString();\n+  \tStringBuilder sb = new StringBuilder(\"{\")\n+  \t    .append(\"serializeNulls:\").append(serializeNulls)\n+  \t    .append(\",serializers:\").append(serializers)\n+  \t    .append(\",deserializers:\").append(deserializers)\n+  \t\n+      \t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are \n+      \t// more familiar with the concept of Instance Creators. Moreover, the objectConstructor is\n+      \t// just a utility class around instance creators, and its toString() only displays them.\n+        .append(\",instanceCreators:\").append(objectConstructor)\n+        .append(\"}\");\n+  \treturn sb.toString();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n       dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n     }\n     if (dateTypeAdapter != null\n-        && !serializers.hasAnyHandlerFor(Date.class)\n-        && !deserializers.hasAnyHandlerFor(Date.class)) {\n+        && !serializers.hasSpecificHandlerFor(Date.class)\n+        && !deserializers.hasSpecificHandlerFor(Date.class)) {\n       serializers.register(Date.class, dateTypeAdapter);\n       deserializers.register(Date.class, dateTypeAdapter);\n     }\n--- a/gson/src/main/java/com/google/gson/JsonArray.java\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Collections;\n   }\n \n   @Override\n-  protected void toString(StringBuilder sb) {\n+  protected void toString(Appendable sb) throws IOException {\n     sb.append('[');\n     boolean first = true;\n     for (JsonElement element : elements) {\n--- a/gson/src/main/java/com/google/gson/JsonCompactFormatter.java\n+++ b/gson/src/main/java/com/google/gson/JsonCompactFormatter.java\n     }\n \n     public void visitPrimitive(JsonPrimitive primitive) throws IOException {\n-      writer.append(primitive.toString());\n+      primitive.toString(writer);\n     }\n \n     public void visitNull() throws IOException {\n       if (!isFirst) {\n         writer.append(',');\n       }\n-      writer.append(member.toString());\n+      member.toString(writer);\n     }\n \n     public void visitArrayMember(JsonArray parent, JsonArray member, \n       writer.append('\"');\n       writer.append(memberName);\n       writer.append(\"\\\":\");\n-      writer.append(member.toString());\n+      member.toString(writer);\n     }\n \n     public void visitObjectMember(JsonObject parent, String memberName, JsonArray member,\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n package com.google.gson;\n \n import java.lang.reflect.Type;\n-import java.util.logging.Logger;\n \n /**\n  * Abstract data value container for the {@link ObjectNavigator.Visitor}\n  * @author Joel Leitch\n  */\n abstract class JsonDeserializationVisitor<T> implements ObjectNavigator.Visitor {\n-\n-  protected static Logger logger = Logger.getLogger(JsonDeserializationVisitor.class.getName());\n \n   protected final ObjectNavigatorFactory factory;\n   protected final ObjectConstructor objectConstructor;\n--- a/gson/src/main/java/com/google/gson/JsonElement.java\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n    */\n   @Override\n   public String toString() {\n-    StringBuilder sb = new StringBuilder();\n-    toString(sb);\n-    return sb.toString();\n-  }\n-\n-  protected abstract void toString(StringBuilder sb);\n+    try {\n+      StringBuilder sb = new StringBuilder();\n+      toString(sb);\n+      return sb.toString();\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  protected abstract void toString(Appendable sb) throws IOException;\n }\n--- a/gson/src/main/java/com/google/gson/JsonEscapingVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonEscapingVisitor.java\n   private JsonPrimitive escapeJsonPrimitive(JsonPrimitive member) {\n     if (member.isString()) {\n       String memberValue = member.getAsString();\n-      String escapedValue = escaper.escapeJsonString(memberValue);\n-      if (!escapedValue.equals(memberValue)) {\n-        member.setValue(escapedValue);\n-      }\n+      member.setValue(escaper.escapeJsonString(memberValue));\n     }\n     return member;\n   }\n--- a/gson/src/main/java/com/google/gson/JsonNull.java\n+++ b/gson/src/main/java/com/google/gson/JsonNull.java\n  */\n \n package com.google.gson;\n+\n+import java.io.IOException;\n \n /**\n  * A class representing a Json {@code null} value.\n   }\n   \n   @Override\n-  protected void toString(StringBuilder sb) {\n+  protected void toString(Appendable sb) throws IOException {\n     sb.append(\"null\");\n   }\n   \n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n   }\n \n   @Override\n-  protected void toString(StringBuilder sb) {\n+  protected void toString(Appendable sb) throws IOException {\n     sb.append('{');\n     boolean first = true;\n     for (Map.Entry<String, JsonElement> entry : members.entrySet()) {\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n   }\n \n   @Override\n-  protected void toString(StringBuilder sb) {\n-    if (value != null) {\n-      if (value instanceof String) {\n-        sb.append('\"');\n-        sb.append(value);\n-        sb.append('\"');\n-\n-      } else {\n-        sb.append(value);\n-      }\n+  protected void toString(Appendable sb) throws IOException {\n+    if (value instanceof String) {\n+      sb.append('\"');\n+      sb.append((String) value);\n+      sb.append('\"');\n+    } else {\n+      sb.append(value.toString());\n     }\n   }\n   \n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n   private void addAsArrayElement(Type elementType, Object elementValue) {\n     if (elementValue == null) {\n-      addNullAsArrayElement();\n+      root.getAsJsonArray().add(JsonNull.createJsonNull());\n     } else {\n       JsonElement childElement = getJsonElementForChild(elementType, elementValue);\n       root.getAsJsonArray().add(childElement);\n     }\n-  }\n-\n-  private void addNullAsArrayElement() {\n-    root.getAsJsonArray().add(null);\n   }\n \n   private JsonElement getJsonElementForChild(Type fieldType, Object fieldValue) {\n   }\n \n   private void assignToRoot(JsonElement newRoot) {\n-    Preconditions.checkArgument(root == null);\n+    Preconditions.checkNotNull(newRoot);\n     root = newRoot;\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n+++ b/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n   }\n   \n   public void navigate(JsonElement element) throws IOException {\n-    if (element == null || element.isJsonNull()) {\n+    if (element.isJsonNull()) {\n       visitor.visitNull();\n     } else if (element.isJsonArray()) {\n       JsonArray array = element.getAsJsonArray();\n    */\n   private boolean visitChild(JsonObject parent, String childName, JsonElement child, \n       boolean isFirst) throws IOException {\n-    if (child != null) { \n-      if (child.isJsonNull()) {\n-        if (visitNulls) {\n-          visitor.visitNullObjectMember(parent, childName, isFirst);\n-          navigate(child.getAsJsonNull());\n-        } else { // Null value is being skipped.\n-          return false;\n-        }\n-      } else if (child.isJsonArray()) {\n-        JsonArray childAsArray = child.getAsJsonArray();\n-        visitor.visitObjectMember(parent, childName, childAsArray, isFirst);\n-        navigate(childAsArray);\n-      } else if (child.isJsonObject()) {\n-        JsonObject childAsObject = child.getAsJsonObject();\n-        visitor.visitObjectMember(parent, childName, childAsObject, isFirst);\n-        navigate(childAsObject);\n-      } else { // is a JsonPrimitive\n-        visitor.visitObjectMember(parent, childName, child.getAsJsonPrimitive(), isFirst);          \n+    if (child.isJsonNull()) {\n+      if (visitNulls) {\n+        visitor.visitNullObjectMember(parent, childName, isFirst);\n+        navigate(child.getAsJsonNull());\n+      } else { // Null value is being skipped.\n+        return false;\n       }\n+    } else if (child.isJsonArray()) {\n+      JsonArray childAsArray = child.getAsJsonArray();\n+      visitor.visitObjectMember(parent, childName, childAsArray, isFirst);\n+      navigate(childAsArray);\n+    } else if (child.isJsonObject()) {\n+      JsonObject childAsObject = child.getAsJsonObject();\n+      visitor.visitObjectMember(parent, childName, childAsObject, isFirst);\n+      navigate(childAsObject);\n+    } else { // is a JsonPrimitive\n+      visitor.visitObjectMember(parent, childName, child.getAsJsonPrimitive(), isFirst);          \n     }\n     return true;\n   }\n    * Returns true if the child was visited, false if it was skipped.\n    */\n   private void visitChild(JsonArray parent, JsonElement child, boolean isFirst) throws IOException {\n-    if (child == null || child.isJsonNull()) {\n+    if (child.isJsonNull()) {\n       visitor.visitNullArrayMember(parent, isFirst);\n-      navigate(null);\n+      navigate(child);\n \t} else if (child.isJsonArray()) {\n       JsonArray childAsArray = child.getAsJsonArray();\n       visitor.visitArrayMember(parent, childAsArray, isFirst);\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n  * @author Joel Leitch\n  */\n final class MappedObjectConstructor implements ObjectConstructor {\n-  private final Logger log = Logger.getLogger(getClass().getName());\n+  private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\n \n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap =\n-    new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n+      new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T construct(Type typeOfT) {\n-    if (instanceCreatorMap.hasAnyHandlerFor(typeOfT)) {\n-      InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT);\n+    InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT);\n+    if (creator != null) {\n       return creator.createInstance(typeOfT);\n     }\n     return (T) constructWithNoArgConstructor(typeOfT);\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Set;\n import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n /**\n- * A map that provides ability to associate handlers for a specific type or all of its sub-types\n- *\n+ * A map that provides ability to associate handlers for a specific type or all\n+ * of its sub-types\n+ * \n  * @author Inderjeet Singh\n  * @author Joel Leitch\n- *\n- * @param <T> The handler that will be looked up by type\n+ * \n+ * @param <T>\n+ *          The handler that will be looked up by type\n  */\n final class ParameterizedTypeHandlerMap<T> {\n-\n+  private static final Logger logger =\n+      Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n   private final Map<Type, T> map = new HashMap<Type, T>();\n   private boolean modifiable = true;\n \n   public synchronized void register(Type typeOfT, T value) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\n+          \"Attempted to modify an unmodifiable map.\");\n     }\n     if (hasSpecificHandlerFor(typeOfT)) {\n-      Gson.logger.log(Level.WARNING, \"Overriding the existing type handler for \" + typeOfT);\n+      logger.log(Level.WARNING,\n+          \"Overriding the existing type handler for \" + typeOfT);\n     }\n     map.put(typeOfT, value);\n   }\n \n   public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\n+          \"Attempted to modify an unmodifiable map.\");\n     }\n     for (Map.Entry<Type, T> entry : other.entrySet()) {\n       if (!map.containsKey(entry.getKey())) {\n \n   public synchronized void registerIfAbsent(Type typeOfT, T value) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\n+          \"Attempted to modify an unmodifiable map.\");\n     }\n     if (!map.containsKey(typeOfT)) {\n       register(typeOfT, value);\n   }\n \n   public synchronized T getHandlerFor(Type type) {\n-    T handler = getRawHandlerFor(type);\n-    Type rawType = type;\n-    if (handler == null && type instanceof ParameterizedType) {\n-      // a handler for a non-generic version may be registered, so use that\n-      rawType = ((ParameterizedType)type).getRawType();\n-      handler = map.get(rawType);\n-    }\n+    T handler = map.get(type);\n+    if (handler == null) {\n+      Class<?> rawClass = TypeUtils.toRawClass(type);\n+      if (rawClass != type) {\n+        handler = getHandlerFor(rawClass);\n+      }\n \n-    // Check for map or collection \n-    if (handler == null) {\n-      if (rawType instanceof Class) {\n-        Class<?> rawClass = (Class<?>) rawType;\n+      // Check for map or collection\n+      if (handler == null) {\n         if (Map.class.isAssignableFrom(rawClass)) {\n           handler = map.get(Map.class);\n         } else if (Collection.class.isAssignableFrom(rawClass)) {\n       }\n     }\n     return handler;\n-  }\n-  \n-  private synchronized T getRawHandlerFor(Type type) {\n-    if (type instanceof Map) {\n-      return map.get(Map.class);\n-    } else if (type instanceof Collection) {\n-      return map.get(Collection.class);\n-    } else {\n-      T handler = map.get(type);\n-      if (handler == null) {\n-        Class<?> rawClass = TypeUtils.toRawClass(type);\n-        if (rawClass != type) {\n-          handler = getHandlerFor(rawClass);\n-        }\n-      }\n-      return handler;\n-    }\n-  }\n-\n-  public synchronized boolean hasAnyHandlerFor(Type type) {\n-    return getHandlerFor(type) != null;\n   }\n \n   public synchronized boolean hasSpecificHandlerFor(Type type) {\n   public synchronized Set<Map.Entry<Type, T>> entrySet() {\n     return map.entrySet();\n   }\n-  \n+\n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder(\"{\");\n     }\n     return sb.toString();\n   }\n-  \n+\n   private String typeToString(Type type) {\n     return TypeUtils.toRawClass(type).getSimpleName();\n   }\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n \n   public void testNullMap() throws Exception {\n     assertFalse(paramMap.hasSpecificHandlerFor(String.class));\n-    assertFalse(paramMap.hasAnyHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class));\n     assertNull(paramMap.getHandlerFor(String.class));\n   }\n \n \n     assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n     assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n-    assertTrue(paramMap.hasAnyHandlerFor(specificType));\n-    assertTrue(paramMap.hasAnyHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType));\n+    assertNotNull(paramMap.getHandlerFor(List.class));\n     assertEquals(handler, paramMap.getHandlerFor(specificType));\n   }\n \n \n     assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n     assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n-    assertTrue(paramMap.hasAnyHandlerFor(specificType));\n-    assertFalse(paramMap.hasAnyHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType));\n+    assertNull(paramMap.getHandlerFor(List.class));\n     assertEquals(handler, paramMap.getHandlerFor(specificType));\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.google.gson.functional;\n \n import com.google.gson.Gson;\n     for (int i = 0; i < expected.length; ++i) {\n       assertEquals(expected[i], target[i]);\n     }\n+  }\n+  \n+  public void testNullsInArrayWithSerializeNullPropertySetSerialization() {\n+    gson = new GsonBuilder().serializeNulls().create();\n+    String[] array = {\"foo\", null, \"bar\"};\n+    String expected = \"[\\\"foo\\\",null,\\\"bar\\\"]\";\n+    String json = gson.toJson(array);\n+    assertEquals(expected, json);\n   }\n \n   public void testArrayOfStringsSerialization() {", "timestamp": 1232415414, "metainfo": ""}