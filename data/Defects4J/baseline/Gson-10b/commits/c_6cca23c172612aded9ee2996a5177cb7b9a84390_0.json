{"sha": "6cca23c172612aded9ee2996a5177cb7b9a84390", "log": "Get GraphAdapterBuilder working for serialization and deserialization using InstanceCreators to get a sneak peek at a value under construction.", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.graph;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.InstanceCreator;\n+import com.google.gson.JsonElement;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Queue;\n+\n+/**\n+ * Writes a graph of objects as a list of named nodes.\n+ */\n+// TODO: proper documentation\n+public final class GraphAdapterBuilder {\n+  private final ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n+  private final Map<Type, InstanceCreator<?>> instanceCreators\n+      = new HashMap<Type, InstanceCreator<?>>();\n+\n+  public GraphAdapterBuilder addType(Type type) {\n+    final ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));\n+    InstanceCreator<Object> instanceCreator = new InstanceCreator<Object>() {\n+      public Object createInstance(Type type) {\n+        return objectConstructor.construct();\n+      }\n+    };\n+    return addType(type, instanceCreator);\n+  }\n+\n+  public GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator) {\n+    if (type == null || instanceCreator == null) {\n+      throw new NullPointerException();\n+    }\n+    instanceCreators.put(type, instanceCreator);\n+    return this;\n+  }\n+\n+  public void registerOn(GsonBuilder gsonBuilder) {\n+    Factory factory = new Factory(instanceCreators);\n+    gsonBuilder.registerTypeAdapterFactory(factory);\n+    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\n+      gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\n+    }\n+  }\n+\n+  static class Factory implements TypeAdapterFactory, InstanceCreator {\n+    private final Map<Type, InstanceCreator<?>> instanceCreators;\n+    private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<Graph>();\n+\n+    Factory(Map<Type, InstanceCreator<?>> instanceCreators) {\n+      this.instanceCreators = instanceCreators;\n+    }\n+\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+      if (!instanceCreators.containsKey(type.getType())) {\n+        return null;\n+      }\n+\n+      final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n+      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\n+      return new TypeAdapter<T>() {\n+        @Override public void write(JsonWriter out, T value) throws IOException {\n+          if (value == null) {\n+            out.nullValue();\n+            return;\n+          }\n+\n+          Graph graph = graphThreadLocal.get();\n+          boolean writeEntireGraph = false;\n+\n+          /*\n+           * We have one of two cases:\n+           *  1. We've encountered the first known object in this graph. Write\n+           *     out the graph, starting with that object.\n+           *  2. We've encountered another graph object in the course of #1.\n+           *     Just write out this object's name. We'll circle back to writing\n+           *     out the object's value as a part of #1.\n+           */\n+\n+          if (graph == null) {\n+            writeEntireGraph = true;\n+            graph = new Graph(new IdentityHashMap<Object, Element<?>>());\n+          }\n+\n+          @SuppressWarnings(\"unchecked\") // graph.map guarantees consistency between value and T\n+          Element<T> element = (Element<T>) graph.map.get(value);\n+          if (element == null) {\n+            element = new Element<T>(value, graph.nextName(), typeAdapter, null);\n+            graph.map.put(value, element);\n+            graph.queue.add(element);\n+          }\n+\n+          if (writeEntireGraph) {\n+            graphThreadLocal.set(graph);\n+            try {\n+              out.beginObject();\n+              Element<?> current;\n+              while ((current = graph.queue.poll()) != null) {\n+                out.name(current.id);\n+                current.write(out);\n+              }\n+              out.endObject();\n+            } finally {\n+              graphThreadLocal.remove();\n+            }\n+          } else {\n+            out.value(element.id);\n+          }\n+        }\n+\n+        @Override public T read(JsonReader in) throws IOException {\n+          if (in.peek() == JsonToken.NULL) {\n+            in.nextNull();\n+            return null;\n+          }\n+\n+          /*\n+           * Again we have one of two cases:\n+           *  1. We've encountered the first known object in this graph. Read\n+           *     the entire graph in as a map from names to their JsonElements.\n+           *     Then convert the first JsonElement to its Java object.\n+           *  2. We've encountered another graph object in the course of #1.\n+           *     Read in its name, then deserialize its value from the\n+           *     JsonElement in our map. We need to do this lazily because we\n+           *     don't know which TypeAdapter to use until a value is\n+           *     encountered in the wild.\n+           */\n+\n+          String currentName = null;\n+          Graph graph = graphThreadLocal.get();\n+          boolean readEntireGraph = false;\n+\n+          if (graph == null) {\n+            graph = new Graph(new HashMap<Object, Element<?>>());\n+            readEntireGraph = true;\n+\n+            // read the entire tree into memory\n+            in.beginObject();\n+            while (in.hasNext()) {\n+              String name = in.nextName();\n+              if (currentName == null) {\n+                currentName = name;\n+              }\n+              JsonElement element = elementAdapter.read(in);\n+              graph.map.put(name, new Element<T>(null, name, typeAdapter, element));\n+            }\n+            in.endObject();\n+          } else {\n+            currentName = in.nextString();\n+          }\n+\n+          if (readEntireGraph) {\n+            graphThreadLocal.set(graph);\n+          }\n+          try {\n+            @SuppressWarnings(\"unchecked\") // graph.map guarantees consistency between value and T\n+            Element<T> element = (Element<T>) graph.map.get(currentName);\n+            // now that we know the typeAdapter for this name, go from JsonElement to 'T'\n+            if (element.value == null) {\n+              element.typeAdapter = typeAdapter;\n+              element.read(graph);\n+            }\n+            return element.value;\n+          } finally {\n+            if (readEntireGraph) {\n+              graphThreadLocal.remove();\n+            }\n+          }\n+        }\n+      };\n+    }\n+\n+    /**\n+     * Hook for the graph adapter to get a reference to a deserialized value\n+     * before that value is fully populated. This is useful to deserialize\n+     * values that directly or indirectly reference themselves: we can hand\n+     * out an instance before read() returns.\n+     *\n+     * <p>Gson should only ever call this method when we're expecting it to;\n+     * that is only when we've called back into Gson to deserialize a tree.\n+     */\n+    public Object createInstance(Type type) {\n+      Graph graph = graphThreadLocal.get();\n+      if (graph == null || graph.nextCreate == null) {\n+        throw new IllegalStateException(\"Unexpected call to createInstance() for \" + type);\n+      }\n+      InstanceCreator<?> creator = instanceCreators.get(type);\n+      Object result = creator.createInstance(type);\n+      graph.nextCreate.value = result;\n+      graph.nextCreate = null;\n+      return result;\n+    }\n+  }\n+\n+  static class Graph {\n+    /**\n+     * The graph elements. On serialization keys are objects (using an identity\n+     * hash map) and on deserialization keys are the string names (using a\n+     * standard hash map).\n+     */\n+    private final Map<Object, Element<?>> map;\n+\n+    /**\n+     * The queue of elements to write during serialization. Unused during\n+     * deserialization.\n+     */\n+    private final Queue<Element> queue = new LinkedList<Element>();\n+\n+    /**\n+     * The instance currently being deserialized. Used as a backdoor between\n+     * the graph traversal (which needs to know instances) and instance creators\n+     * which create them.\n+     */\n+    private Element nextCreate;\n+\n+    private Graph(Map<Object, Element<?>> map) {\n+      this.map = map;\n+    }\n+\n+    /**\n+     * Returns a unique name for an element to be inserted into the graph.\n+     */\n+    public String nextName() {\n+      return \"0x\" + Integer.toHexString(map.size() + 1);\n+    }\n+  }\n+\n+  /**\n+   * An element of the graph during serialization or deserialization.\n+   */\n+  static class Element<T> {\n+    /**\n+     * This element's name in the top level graph object.\n+     */\n+    private final String id;\n+\n+    /**\n+     * The value if known. During deserialization this is lazily populated.\n+     */\n+    private T value;\n+\n+    /**\n+     * This element's type adapter if known. During deserialization this is\n+     * lazily populated.\n+     */\n+    private TypeAdapter<T> typeAdapter;\n+\n+    /**\n+     * The element to deserialize. Unused in serialization.\n+     */\n+    private final JsonElement element;\n+\n+    Element(T value, String id, TypeAdapter<T> typeAdapter, JsonElement element) {\n+      this.value = value;\n+      this.id = id;\n+      this.typeAdapter = typeAdapter;\n+      this.element = element;\n+    }\n+\n+    void write(JsonWriter out) throws IOException {\n+      typeAdapter.write(out, value);\n+    }\n+\n+    void read(Graph graph) throws IOException {\n+      if (graph.nextCreate != null) {\n+        throw new IllegalStateException(\"Unexpected recursive call to read()\");\n+      }\n+      graph.nextCreate = this;\n+      value = typeAdapter.fromJsonTree(element);\n+      if (value == null) {\n+        throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.graph;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import junit.framework.TestCase;\n+\n+public final class GraphAdapterBuilderTest extends TestCase {\n+  public void testSerialization() {\n+    Roshambo rock = new Roshambo(\"ROCK\");\n+    Roshambo scissors = new Roshambo(\"SCISSORS\");\n+    Roshambo paper = new Roshambo(\"PAPER\");\n+    rock.beats = scissors;\n+    scissors.beats = paper;\n+    paper.beats = rock;\n+\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Roshambo.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    assertEquals(\"{'0x1':{'name':'ROCK','beats':'0x2'},\" +\n+        \"'0x2':{'name':'SCISSORS','beats':'0x3'},\" +\n+        \"'0x3':{'name':'PAPER','beats':'0x1'}}\",\n+        gson.toJson(rock).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserialization() {\n+    String json = \"{'0x1':{'name':'ROCK','beats':'0x2'},\" +\n+        \"'0x2':{'name':'SCISSORS','beats':'0x3'},\" +\n+        \"'0x3':{'name':'PAPER','beats':'0x1'}}\";\n+\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Roshambo.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    Roshambo rock = gson.fromJson(json, Roshambo.class);\n+    assertEquals(\"ROCK\", rock.name);\n+    Roshambo scissors = rock.beats;\n+    assertEquals(\"SCISSORS\", scissors.name);\n+    Roshambo paper = scissors.beats;\n+    assertEquals(\"PAPER\", paper.name);\n+    assertSame(rock, paper.beats);\n+  }\n+\n+  public void testSerializationDirectSelfReference() {\n+    Roshambo suicide = new Roshambo(\"SUICIDE\");\n+    suicide.beats = suicide;\n+\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Roshambo.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    assertEquals(\"{'0x1':{'name':'SUICIDE','beats':'0x1'}}\",\n+        gson.toJson(suicide).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializationDirectSelfReference() {\n+    String json = \"{'0x1':{'name':'SUICIDE','beats':'0x1'}}\";\n+\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Roshambo.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    Roshambo suicide = gson.fromJson(json, Roshambo.class);\n+    assertEquals(\"SUICIDE\", suicide.name);\n+    assertSame(suicide, suicide.beats);\n+  }\n+\n+  static class Roshambo {\n+    String name;\n+    Roshambo beats;\n+    Roshambo(String name) {\n+      this.name = name;\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n     this(Collections.<Type, InstanceCreator<?>>emptyMap());\n   }\n \n-  public <T> ObjectConstructor<T> getConstructor(TypeToken<T> typeToken) {\n+  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\n     final Type type = typeToken.getType();\n     final Class<? super T> rawType = typeToken.getRawType();\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n \n     Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\n-    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n+    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n \n     @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\n     TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n     Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\n     TypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n-    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n+    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n \n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     // we don't define a type parameter for the key or value types\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n       return null; // it's a primitive!\n     }\n \n-    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(type);\n+    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n     return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n   }\n ", "timestamp": 1325425364, "metainfo": ""}