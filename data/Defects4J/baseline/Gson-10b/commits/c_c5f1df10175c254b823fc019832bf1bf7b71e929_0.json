{"sha": "c5f1df10175c254b823fc019832bf1bf7b71e929", "log": "MiniGSON prototype!", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Adapt a homogeneous collection of objects.\n+ */\n+final class CollectionTypeAdapter<E> extends TypeAdapter<Collection<E>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof ParameterizedType)) {\n+        return null;\n+      }\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Collection.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n+      TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));\n+\n+      Class<?> constructorType;\n+\n+      if (rawType == List.class || rawType == Collection.class) {\n+        constructorType = ArrayList.class;\n+      } else if (rawType == Set.class) {\n+        constructorType = LinkedHashSet.class;\n+      } else {\n+        constructorType = rawType;\n+      }\n+\n+      Constructor<?> constructor;\n+      try {\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the element type\n+      TypeAdapter<T> result = new CollectionTypeAdapter(elementTypeAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<E> elementTypeAdapter;\n+  private final Constructor<? extends Collection<E>> constructor;\n+\n+  public CollectionTypeAdapter(TypeAdapter<E> elementTypeAdapter,\n+      Constructor<? extends Collection<E>> constructor) {\n+    this.elementTypeAdapter = elementTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Collection<E> read(JsonReader reader) throws IOException {\n+    Collection<E> collection = MiniGson.newInstance(constructor);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      E instance = elementTypeAdapter.read(reader);\n+      collection.add(instance);\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  public void write(JsonWriter writer, Collection<E> collection) throws IOException {\n+    writer.beginArray();\n+    for (E element : collection) {\n+      elementTypeAdapter.write(writer, element);\n+    }\n+    writer.endArray();\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/MiniGson.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.reflect.TypeToken;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * A basic binding between JSON and Java objects.\n+ */\n+public final class MiniGson {\n+  private final List<TypeAdapter.Factory> factories;\n+\n+  private MiniGson(Builder builder) {\n+    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    factories.addAll(builder.factories);\n+    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n+    factories.add(TypeAdapters.INTEGER_FACTORY);\n+    factories.add(TypeAdapters.DOUBLE_FACTORY);\n+    factories.add(TypeAdapters.LONG_FACTORY);\n+    factories.add(TypeAdapters.STRING_FACTORY);\n+    factories.add(ReflectiveTypeAdapter.FACTORY);\n+    factories.add(CollectionTypeAdapter.FACTORY);\n+    this.factories = Collections.unmodifiableList(factories);\n+  }\n+\n+  // TODO: this should use Joel's unsafe constructor stuff\n+  static <T> T newInstance(Constructor<T> constructor) {\n+    try {\n+      return constructor.newInstance();\n+    } catch (InstantiationException e) {\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e);\n+    } catch (InvocationTargetException e) {\n+      // TODO: don't wrap if cause is unchecked!\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e.getTargetException());\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n+    for (TypeAdapter.Factory factory : factories) {\n+      TypeAdapter<T> candidate = factory.create(this, type);\n+      if (candidate != null) {\n+        return candidate;\n+      }\n+    }\n+    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(Class<T> type) {\n+    return getAdapter(TypeToken.get(type));\n+  }\n+\n+  /**\n+   * Returns the type adapters of this context in order of precedence.\n+   */\n+  public List<TypeAdapter.Factory> getFactories() {\n+    return factories;\n+  }\n+\n+  public static final class Builder {\n+    private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+\n+    public void factory(TypeAdapter.Factory factory) {\n+      factories.add(factory);\n+    }\n+\n+    public <T> void typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+    }\n+\n+    public <T> void typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+    }\n+\n+    public <T> void typeHierarchyAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n+    }\n+\n+    public MiniGson build() {\n+      return new MiniGson(this);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapts the fields of an object to the properties of a JSON object.\n+ */\n+final class ReflectiveTypeAdapter<T> extends TypeAdapter<T>  {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+      Class<? super T> raw = type.getRawType();\n+\n+      if (!Object.class.isAssignableFrom(raw)) {\n+        // TODO: does this catch primitives?\n+        return null;\n+      }\n+\n+      // TODO: use Joel's constructor calling code (with setAccessible)\n+      Constructor<T> constructor;\n+      try {\n+        constructor = (Constructor<T>) raw.getDeclaredConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n+    }\n+\n+    private Map<String, BoundField<?>> getBoundFields(\n+        MiniGson context, TypeToken<?> type, Class<?> raw) {\n+      Map<String, BoundField<?>> result = new LinkedHashMap<String, BoundField<?>>();\n+      while (raw != Object.class) {\n+        for (Field field : raw.getDeclaredFields()) {\n+          Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+          BoundField<?> boundField = BoundField.create(context, field, TypeToken.get(fieldType));\n+          result.put(boundField.name, boundField);\n+        }\n+        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+        raw = type.getRawType();\n+      }\n+      return result;\n+    }\n+  };\n+\n+  private final Constructor<T> constructor;\n+  private final Map<String, BoundField<?>> map;\n+  private final BoundField<?>[] boundFields;\n+\n+  ReflectiveTypeAdapter(Constructor<T> constructor, Map<String, BoundField<?>> map) {\n+    this.constructor = constructor;\n+    this.map = map;\n+    this.boundFields = map.values().toArray(new BoundField<?>[map.size()]);\n+  }\n+\n+  public T read(JsonReader reader) throws IOException {\n+    T instance = MiniGson.newInstance(constructor);\n+\n+    // TODO: null out the other fields?\n+\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String name = reader.nextName();\n+      BoundField<?> field = map.get(name);\n+      if (field == null) {\n+        // TODO: define a better policy\n+        reader.skipValue();\n+      } else {\n+        field.read(reader, instance);\n+      }\n+    }\n+    reader.endObject();\n+    return instance;\n+  }\n+\n+  public void write(JsonWriter writer, T value) throws IOException {\n+    writer.beginObject();\n+    for (BoundField<?> boundField : boundFields) {\n+      writer.name(boundField.name);\n+      boundField.write(writer, value);\n+    }\n+    writer.endObject();\n+  }\n+\n+  static class BoundField<T> {\n+    final String name;\n+    final Field field;\n+    final TypeAdapter<T> typeAdapter;\n+\n+    BoundField(String name, Field field, TypeAdapter<T> typeAdapter) {\n+      this.name = name;\n+      this.field = field;\n+      this.typeAdapter = typeAdapter;\n+    }\n+\n+    static <T> BoundField<T> create(MiniGson context, Field field, TypeToken<T> fieldType) {\n+      return new BoundField<T>(field.getName(), field, context.getAdapter(fieldType));\n+    }\n+\n+    void write(JsonWriter writer, Object value) throws IOException {\n+      try {\n+        @SuppressWarnings(\"unchecked\") // we previously verified that field is of type T\n+        T fieldValue = (T) field.get(value);\n+        typeAdapter.write(writer, fieldValue);\n+      } catch (IllegalAccessException e) {\n+        throw new AssertionError();\n+      }\n+    }\n+\n+    void read(JsonReader reader, Object value) throws IOException {\n+      T fieldValue = typeAdapter.read(reader);\n+      try {\n+        field.set(value, fieldValue);\n+      } catch (IllegalAccessException e) {\n+        throw new AssertionError();\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/TypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+public abstract class TypeAdapter<T> {\n+  public abstract T read(JsonReader reader) throws IOException;\n+  public abstract void write(JsonWriter writer, T value) throws IOException;\n+\n+  public final String toJson(T value) throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    write(stringWriter, value);\n+    return stringWriter.toString();\n+  }\n+\n+  public final void write(Writer out, T value) throws IOException {\n+    JsonWriter writer = new JsonWriter(out);\n+    write(writer, value);\n+  }\n+\n+  public final T fromJson(String json) throws IOException {\n+    return read(new StringReader(json));\n+  }\n+\n+  public final T read(Reader in) throws IOException {\n+    JsonReader reader = new JsonReader(in);\n+    reader.setLenient(true); // TODO: why?\n+    return read(reader);\n+  }\n+\n+  interface Factory {\n+    <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type);\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/TypeAdapters.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+\n+/**\n+ * Type adapters for basic types.\n+ */\n+final class TypeAdapters {\n+  private TypeAdapters() {}\n+\n+  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n+    public Boolean read(JsonReader reader) throws IOException {\n+      return reader.nextBoolean();\n+    }\n+    public void write(JsonWriter writer, Boolean value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory BOOLEAN_FACTORY\n+      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n+\n+  public static final TypeAdapter<Integer> INTEGER = new TypeAdapter<Integer>() {\n+    public Integer read(JsonReader reader) throws IOException {\n+      return reader.nextInt();\n+    }\n+    public void write(JsonWriter writer, Integer value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory INTEGER_FACTORY\n+      = newFactory(int.class, Integer.class, INTEGER);\n+\n+  public static final TypeAdapter<Long> LONG = new TypeAdapter<Long>() {\n+    public Long read(JsonReader reader) throws IOException {\n+      return reader.nextLong();\n+    }\n+    public void write(JsonWriter writer, Long value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory LONG_FACTORY\n+      = newFactory(long.class, Long.class, LONG);\n+\n+  public static final TypeAdapter<Double> DOUBLE = new TypeAdapter<Double>() {\n+    public Double read(JsonReader reader) throws IOException {\n+      return reader.nextDouble();\n+    }\n+    public void write(JsonWriter writer, Double value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory DOUBLE_FACTORY\n+      = newFactory(double.class, Double.class, DOUBLE);\n+\n+  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n+    public String read(JsonReader reader) throws IOException {\n+      return reader.nextString();\n+    }\n+    public void write(JsonWriter writer, String value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory STRING_FACTORY = newFactory(String.class, STRING);\n+\n+  public static <T> TypeAdapter.Factory newFactory(\n+      final TypeToken<T> type, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  public static <T> TypeAdapter.Factory newFactory(\n+      final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  private static <T> TypeAdapter.Factory newFactory(\n+      final Class<T> unboxed, final Class<T> boxed, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        Class<? super T> rawType = typeToken.getRawType();\n+        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  public static <T> TypeAdapter.Factory newTypeHierarchyFactory(\n+      TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        // TODO: use Inder's TypeHierarchyAdapter here\n+        throw new UnsupportedOperationException();\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import junit.framework.TestCase;\n+\n+public final class MiniGsonTest extends TestCase {\n+\n+  public void testSerialize() throws IOException {\n+    Person jesse = new Person(\"Jesse\", 29);\n+    Person jodie = new Person(\"Jodie\", 29);\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(jesse, jodie);\n+    truck.horsePower = 300;\n+\n+    MiniGson miniGson = new MiniGson.Builder().build();\n+    TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n+\n+    String json = truckAdapter.toJson(truck);\n+    assertEquals(\"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\",\n+        json.replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserialize() throws IOException {\n+    String json = \"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\";\n+\n+    MiniGson miniGson = new MiniGson.Builder().build();\n+    TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n+    Truck truck = truckAdapter.fromJson(json);\n+\n+    assertEquals(300.0, truck.horsePower);\n+    Person jesse = truck.passengers.get(0);\n+    assertEquals(\"Jesse\", jesse.name);\n+    assertEquals(29, jesse.age);\n+    Person jodie = truck.passengers.get(1);\n+    assertEquals(\"Jodie\", jodie.name);\n+    assertEquals(29, jodie.age);\n+  }\n+\n+  static class Truck {\n+    double horsePower;\n+    List<Person> passengers;\n+  }\n+\n+  static class Person {\n+    int age;\n+    String name;\n+\n+    Person(String name, int age) {\n+      this.name = name;\n+      this.age = age;\n+    }\n+\n+    public Person() {} // TODO: use Joel's constructor code so we don't need this\n+  }\n+}", "timestamp": 1310402812, "metainfo": ""}