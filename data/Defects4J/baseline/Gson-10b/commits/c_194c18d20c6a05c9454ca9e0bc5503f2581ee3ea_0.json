{"sha": "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea", "log": "Be backwards-compatible for serialization of maps whose keys aren't primitives.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n \n import com.google.gson.JsonElement;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Adapts maps to either JSON objects or JSON arrays.\n \n     Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n-    TypeAdapter<?> keyAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n+    TypeAdapter<?> keyAdapter = getKeyAdapter(context, keyAndValueTypes[0]);\n     TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n \n     TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,\n         keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n+  }\n+\n+  /**\n+   * Returns a type adapter that writes the value as a string.\n+   */\n+  private TypeAdapter<?> getKeyAdapter(MiniGson context, Type keyType) {\n+    return (keyType == boolean.class || keyType == Boolean.class)\n+        ? TypeAdapters.BOOLEAN_AS_STRING\n+        : context.getAdapter(TypeToken.get(keyType));\n   }\n \n   private final class Adapter<K, V> extends TypeAdapter<Map<K, V>> {\n         return;\n       }\n \n+      if (!complexMapKeySerialization) {\n+        writer.beginObject();\n+        for (Map.Entry<K, V> entry : map.entrySet()) {\n+          writer.name(String.valueOf(entry.getKey()));\n+          valueTypeAdapter.write(writer, entry.getValue());\n+        }\n+        writer.endObject();\n+        return;\n+      }\n+\n       boolean hasComplexKeys = false;\n       List<JsonElement> keys = new ArrayList<JsonElement>(map.size());\n \n         hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject();\n       }\n \n-      if (complexMapKeySerialization && hasComplexKeys) {\n+      if (hasComplexKeys) {\n         writer.beginArray();\n         for (int i = 0; i < keys.size(); i++) {\n           writer.beginArray(); // entry array\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n     }\n   };\n \n+  /**\n+   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n+   * otherwise permitted.\n+   */\n+  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n+    @Override public Boolean read(JsonReader reader) throws IOException {\n+      if (reader.peek() == JsonToken.NULL) {\n+        reader.nextNull();\n+        return null;\n+      }\n+      return Boolean.valueOf(reader.nextString());\n+    }\n+\n+    @Override public void write(JsonWriter writer, Boolean value) throws IOException {\n+      writer.value(value == null ? \"null\" : value.toString());\n+    }\n+  };\n+\n   public static final TypeAdapter.Factory BOOLEAN_FACTORY\n       = newFactory(boolean.class, Boolean.class, BOOLEAN);\n \n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n import com.google.gson.InstanceCreator;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSerializationContext;\n import com.google.gson.JsonSerializer;\n import com.google.gson.common.TestTypes;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n-\n-import junit.framework.TestCase;\n-\n import java.lang.reflect.Type;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.TreeMap;\n+import junit.framework.TestCase;\n \n /**\n  * Functional test for Json serialization and deserialization for Maps\n     assertEquals(expected, gson.toJson(map));\n   }\n \n+  public void testComplexKeysSerialization() {\n+    Map<Point, String> map = new LinkedHashMap<Point, String>();\n+    map.put(new Point(2, 3), \"a\");\n+    map.put(new Point(5, 7), \"b\");\n+    String json = \"{\\\"2,3\\\":\\\"a\\\",\\\"5,7\\\":\\\"b\\\"}\";\n+    assertEquals(json, gson.toJson(map, new TypeToken<Map<Point, String>>() {}.getType()));\n+    assertEquals(json, gson.toJson(map, Map.class));\n+  }\n+\n+  public void testComplexKeysDeserialization() {\n+    String json = \"{\\\"2,3\\\":\\\"a\\\",\\\"5,7\\\":\\\"b\\\"}\";\n+    try {\n+      gson.fromJson(json, new TypeToken<Map<Point, String>>() {}.getType());\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testStringKeyDeserialization() {\n+    String json = \"{\\\"2,3\\\":\\\"a\\\",\\\"5,7\\\":\\\"b\\\"}\";\n+    Map<String, String> map = new LinkedHashMap<String, String>();\n+    map.put(\"2,3\", \"a\");\n+    map.put(\"5,7\", \"b\");\n+    assertEquals(map, gson.fromJson(json, new TypeToken<Map<String, String>>() {}.getType()));\n+  }\n+\n+  public void testNumberKeyDeserialization() {\n+    String json = \"{\\\"2.3\\\":\\\"a\\\",\\\"5.7\\\":\\\"b\\\"}\";\n+    Map<Double, String> map = new LinkedHashMap<Double, String>();\n+    map.put(2.3, \"a\");\n+    map.put(5.7, \"b\");\n+    assertEquals(map, gson.fromJson(json, new TypeToken<Map<Double, String>>() {}.getType()));\n+  }\n+\n+  public void testBooleanKeyDeserialization() {\n+    String json = \"{\\\"true\\\":\\\"a\\\",\\\"false\\\":\\\"b\\\"}\";\n+    Map<Boolean, String> map = new LinkedHashMap<Boolean, String>();\n+    map.put(true, \"a\");\n+    map.put(false, \"b\");\n+    assertEquals(map, gson.fromJson(json, new TypeToken<Map<Boolean, String>>() {}.getType()));\n+  }\n+\n+  static class Point {\n+    private final int x;\n+    private final int y;\n+\n+    Point(int x, int y) {\n+      this.x = x;\n+      this.y = y;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Point && x == ((Point) o).x && y == ((Point) o).y;\n+    }\n+\n+    @Override public int hashCode() {\n+      return x * 37 + y;\n+    }\n+\n+    @Override public String toString() {\n+      return x + \",\" + y;\n+    }\n+  }\n+\n   static final class MapClass {\n     private final Map<String, TestTypes.Base> bases = new HashMap<String, TestTypes.Base>();\n     private final Map<String, TestTypes.Sub> subs = new HashMap<String, TestTypes.Sub>();", "timestamp": 1319084667, "metainfo": ""}