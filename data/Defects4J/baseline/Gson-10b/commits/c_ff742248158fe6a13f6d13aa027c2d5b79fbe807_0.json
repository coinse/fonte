{"sha": "ff742248158fe6a13f6d13aa027c2d5b79fbe807", "log": "Revised equals and hashcode of ObjectTypePair to ensure reference equality of object instead of value equality. Improved JavaDocs for various 1.4 API methods.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n    *   <li>aStringField ---> a-string-field</li>\n    *   <li>aURL ---> a-u-r-l</li>\n    * </ul>\n-   * \n+   * Using dashes in JavaScript is not recommended since dash is also used for a minus sign in\n+   * expressions. This requires that a field named with dashes is always accessed as a quoted\n+   * property like {@code myobject['my-field']}. Accessing it as an object field\n+   * {@code myobject.my-field} will result in an unintended javascript expression.\n    * @since 1.4\n    */\n   LOWER_CASE_WITH_DASHES(new LowerCamelCaseSeparatorNamingPolicy(\"-\"));\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n   /**\n    * This method serializes the specified object into its equivalent representation as a tree of \n-   * {JsonElement}s. This method should be used when the specified object is not a generic type. \n-   * This method uses {@link Class#getClass()} to get the type for the specified object, but the\n-   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n+   * {@link JsonElement}s. This method should be used when the specified object is not a generic\n+   * type. This method uses {@link Class#getClass()} to get the type for the specified object, but\n+   * the {@code getClass()} loses the generic type information because of the Type Erasure feature\n    * of Java. Note that this method works fine if the any of the object fields are of generic type,\n    * just the object itself should not be of a generic type. If the object is of generic type, use\n-   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a\n-   * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.\n+   * {@link #toJsonTree(Object, Type)} instead.\n    *\n    * @param src the object for which Json representation is to be created setting for Gson\n    * @return Json representation of {@code src}.\n   /**\n    * This method serializes the specified object, including those of generic types, into its\n    * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the \n-   * specified object is a generic type. For non-generic objects, use {@link #toJson(Object)} \n-   * instead. If you want to write out the object to a {@link Appendable}, \n-   * use {@link #toJson(Object, Type, Appendable)} instead.\n+   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)} \n+   * instead. \n    *\n    * @param src the object for which JSON representation is to be created\n    * @param typeOfSrc The specific genericized type of src. You can obtain\n   /**\n    * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.\n    * \n-   * @param jsonElement root of the tree of {@link JsonElement}s\n+   * @param jsonElement root of a tree of {@link JsonElement}s\n    * @return JSON String representation of the tree\n    * @since 1.4\n    */\n   }\n   \n   /**\n-   * Writes out the equivalent JSON for the tree of {@link JsonElement}s.\n+   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\n    * \n-   * @param jsonElement root of the tree of {@link JsonElement}s\n+   * @param jsonElement root of a tree of {@link JsonElement}s\n    * @param writer Writer to which the Json representation needs to be written\n    * @since 1.4\n    */\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   }\n \n   private void addAsArrayElement(ObjectTypePair elementTypePair) {\n-    if (elementTypePair.getObj() == null) {\n+    if (elementTypePair.getObject() == null) {\n       root.getAsJsonArray().add(JsonNull.createJsonNull());\n     } else {\n       JsonElement childElement = getJsonElementForChild(elementTypePair);\n   @SuppressWarnings(\"unchecked\")\n   public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n     try {\n-      Object obj = objTypePair.getObj();\n+      Object obj = objTypePair.getObject();\n       Type objType = objTypePair.getType();\n       JsonSerializer serializer = serializers.getHandlerFor(objType);\n       if (serializer == null && obj != null) {\n   private JsonElement invokeCustomHandler(ObjectTypePair objTypePair, JsonSerializer serializer) {\n     start(objTypePair);\n     try {\n-      return serializer.serialize(objTypePair.getObj(), objTypePair.getType(), context);\n+      return serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);\n     } finally {\n       end(objTypePair);\n     }\n--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java\n  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader\n  * asynchronously.\n  * \n- * <p>This class is thread-compatible. For some more literature on these definitions, refer to\n- * Effective Java.\n- *\n- * <p>To properly use this class across multiple thread, you will need to add some external\n- * synchronization to your classes/thread to get this to work properly.  For example:\n+ * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To\n+ * properly use this class across multiple threads, you will need to add some external\n+ * synchronization.  For example:\n  * \n  * <pre>\n- * JsonStreamParser parser = new JsonStreamParser(\"blah blah blah\");\n+ * JsonStreamParser parser = new JsonStreamParser(\"['first'] {'second':10} 'third'\");\n  * JsonElement element;\n  * synchronized (someCommonObject) {\n  *   if (parser.hasNext()) {\n     }\n   }\n \n+  /**\n+   * Returns true if a {@link JsonElement} is available on the input for consumption\n+   * @return true if a {@link JsonElement} is available on the input, false otherwise\n+   * @since 1.4\n+   */\n   public boolean hasNext() {\n     synchronized (lock) {\n       try {\n     }\n   }\n \n+  /**\n+   * This optional {@link Iterator} method is not relevant for stream parsing and hence is not\n+   * implemented.\n+   * @since 1.4\n+   */\n   public void remove() {\n     throw new UnsupportedOperationException();\n   }\n--- a/gson/src/main/java/com/google/gson/MemoryRefStack.java\n+++ b/gson/src/main/java/com/google/gson/MemoryRefStack.java\n     }\n \n     for (ObjectTypePair stackObject : stack) {\n-      if (stackObject.getObj() == obj.getObj() && stackObject.getType().equals(obj.getType()) ) {\n+      if (stackObject.getObject() == obj.getObject()\n+          && stackObject.getType().equals(obj.getType()) ) {\n         return true;\n       }\n     }\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n   public void accept(Visitor visitor) {\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n     if (!visitedWithCustomHandler) {\n-      Object obj = objTypePair.getObj();\n+      Object obj = objTypePair.getObject();\n       Object objectToVisit = (obj == null) ? visitor.getTarget() : obj;\n       if (objectToVisit == null) {\n         return;\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.google.gson;\n \n import java.lang.reflect.Type;\n \n- final class ObjectTypePair {\n+/**\n+ * A holder class for an object and its type\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class ObjectTypePair {\n+  private static final int PRIME = 31;\n+\n   private final Object obj;\n   private final Type type;\n+\n   public ObjectTypePair(Object obj, Type type) {\n     this.obj = obj;\n     this.type = type;\n   }\n-  public Object getObj() {\n+\n+  public Object getObject() {\n     return obj;\n   }\n+\n   public Type getType() {\n     return type;\n   }\n+\n   @Override\n   public int hashCode() {\n-    final int prime = 31;\n-    int result = 1;\n-    result = prime * result + ((obj == null) ? 0 : obj.hashCode());\n-    result = prime * result + ((type == null) ? 0 : type.hashCode());\n-    return result;\n+    // Not using type.hashCode() since I am not sure if the subclasses of type reimplement\n+    // hashCode() to be equal for equal types\n+    return ((obj == null) ? PRIME : obj.hashCode());\n   }\n+\n   @Override\n   public boolean equals(Object obj) {\n-    if (this == obj)\n+    if (this == obj) {\n       return true;\n-    if (obj == null)\n+    }\n+    if (obj == null) {\n       return false;\n-    if (getClass() != obj.getClass())\n+    }\n+    if (getClass() != obj.getClass()) {\n       return false;\n+    }\n     ObjectTypePair other = (ObjectTypePair) obj;\n     if (this.obj == null) {\n-      if (other.obj != null)\n+      if (other.obj != null) {\n         return false;\n-    } else if (!this.obj.equals(other.obj))\n+      }\n+    } else if (this.obj != other.obj) { // Checking for reference equality\n       return false;\n+    }\n     if (type == null) {\n-      if (other.type != null)\n+      if (other.type != null) {\n         return false;\n-    } else if (!type.equals(other.type))\n+      }\n+    } else if (!type.equals(other.type)) {\n       return false;\n+    }\n     return true;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/annotations/Expose.java\n+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java\n public @interface Expose {\n   \n   /**\n-   * If true, the field marked with this annotation is written out in the JSON while serializing.\n-   * If false, the field marked with this annotation is skipped from the serialized output. \n-   * Defaults to true.\n+   * If {@code true}, the field marked with this annotation is written out in the JSON while\n+   * serializing. If {@code false}, the field marked with this annotation is skipped from the\n+   * serialized output. Defaults to {@code true}.\n    * @since 1.4\n    */\n   public boolean serialize() default true;\n \n   /**\n-   * If true, the field marked with this annotation is deserialized from the JSON.\n-   * If false, the field marked with this annotation is skipped during deserialization. \n-   * Defaults to true.\n+   * If {@code true}, the field marked with this annotation is deserialized from the JSON.\n+   * If {@code false}, the field marked with this annotation is skipped during deserialization. \n+   * Defaults to {@code true}.\n    * @since 1.4\n    */\n   public boolean deserialize() default true;\n--- a/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n+++ b/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n   }\n \n   public void testContains() throws Exception {\n-    ObjectTypePair objA = new ObjectTypePair(new MockObject(), MockObject.class);\n-    ObjectTypePair objB = new ObjectTypePair(new MockObject(), MockObject.class);\n+    MockObject objA = new MockObject();\n+    MockObject objB = new MockObject();\n     assertEquals(objA, objB);\n-\n-    stack.push(objA);\n-    assertFalse(stack.contains(objB));\n-    assertTrue(stack.contains(objA));\n+    stack.push(new ObjectTypePair(objA, MockObject.class));\n+    assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class)));\n+    assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class)));\n   }\n \n   private static class MockObject {", "timestamp": 1254766672, "metainfo": ""}