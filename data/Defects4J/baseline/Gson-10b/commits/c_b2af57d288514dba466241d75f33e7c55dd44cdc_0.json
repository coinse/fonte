{"sha": "b2af57d288514dba466241d75f33e7c55dd44cdc", "log": "Added checks to ensure that typeHierarchyAdapter being registered doesn't hide a previously existing one. Fixed a bug where registerIfAbsent was adding type adapters in the reverse order of priority. Added toString() to Pair.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n     map.register(UUID.class, UUUID_TYPE_ADAPTER);\n     map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n-    map.registerForTypeHierarchy(Set.class, COLLECTION_TYPE_ADAPTER);\n     map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n     map.register(Date.class, DATE_TYPE_ADAPTER);\n     map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\n     map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\n     map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\n     map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n-    map.registerForTypeHierarchy(Set.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n     map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n     map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\n   private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\n     ParameterizedTypeHandlerMap<InstanceCreator<?>> map =\n         new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n-    map.register(Map.class, MAP_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n \n     // Add Collection type instance creators\n     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n \n-    map.register(Set.class, HASH_SET_CREATOR);\n-    map.register(SortedSet.class, TREE_SET_CREATOR);\n-    map.register(TreeSet.class, TREE_SET_CREATOR);\n+    map.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR);\n+    map.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR);\n     map.register(Properties.class, PROPERTIES_CREATOR);\n     map.makeUnmodifiable();\n     return map;\n--- a/gson/src/main/java/com/google/gson/Pair.java\n+++ b/gson/src/main/java/com/google/gson/Pair.java\n   private static boolean equal(Object a, Object b) {\n     return a == b || (a != null && a.equals(b));\n   }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n       typeHierarchyList.remove(index);\n     }\n+    index = getIndexOfAnOverriddenHandler(pair.first);\n+    if (index >= 0) {\n+      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n+          + \" hides the previously registered type hierarchy handler for \"\n+          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n+    }\n     // We want stack behavior for adding to this list. A type adapter added subsequently should\n     // override a previously registered one.\n     typeHierarchyList.add(0, pair);\n   }\n \n+  private int getIndexOfAnOverriddenHandler(Class<?> type) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n+      if (type.isAssignableFrom(entry.first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n   public synchronized void register(Type typeOfT, T value) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n         register(entry.getKey(), entry.getValue());\n       }\n     }\n-    for (Pair<Class<?>, T> entry : other.typeHierarchyList) {\n+    // Quite important to traverse the typeHierarchyList from stack bottom first since\n+    // we want to register the handlers in the same order to preserve priority order\n+    for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n       int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\n       if (index < 0) {\n         registerForTypeHierarchy(entry);\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n     assertEquals(\"baseHandler\", handler);\n   }\n \n+  public void testReplaceExistingTypeHierarchyHandler() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\");\n+    String handler = paramMap.getHandlerFor(Base.class);\n+    assertEquals(\"base2Handler\", handler);\n+  }\n+\n+  public void testHidingExistingTypeHierarchyHandlerIsDisallowed() {\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    try {\n+      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+      fail(\"A handler that hides an existing type hierarchy handler is not allowed\");\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n   private static class SubOfSub extends Sub {\n   }\n }", "timestamp": 1277416278, "metainfo": ""}