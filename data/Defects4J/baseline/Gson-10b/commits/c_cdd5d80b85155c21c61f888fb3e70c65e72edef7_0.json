{"sha": "cdd5d80b85155c21c61f888fb3e70c65e72edef7", "log": "Support writing maps with non-string keys", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/GsonCompatibleMapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/GsonCompatibleMapTypeAdapter.java\n /**\n  * Adapt a map whose keys are any type.\n  */\n-public final class GsonCompatibleMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+public final class GsonCompatibleMapTypeAdapter<V> extends TypeAdapter<Map<?, V>> {\n   public static final Factory FACTORY = new Factory() {\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n     this.constructor = constructor;\n   }\n \n-  public Map<String, V> read(JsonReader reader) throws IOException {\n+  public Map<?, V> read(JsonReader reader) throws IOException {\n     if (reader.peek() == JsonToken.NULL) {\n       reader.nextNull(); // TODO: does this belong here?\n       return null;\n     while (reader.hasNext()) {\n       String key = reader.nextName();\n       V value = valueTypeAdapter.read(reader);\n-      map.put(key, value);\n+      map.put(key, value); // TODO: convert to the map's key type?\n     }\n     reader.endObject();\n     return map;\n   }\n \n-  public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+  public void write(JsonWriter writer, Map<?, V> map) throws IOException {\n     if (map == null) {\n       writer.nullValue(); // TODO: better policy here?\n       return;\n     }\n \n     writer.beginObject();\n-    for (Map.Entry<String, V> entry : map.entrySet()) {\n-      String key = entry.getKey();\n-      if (key == null) {\n-        key = \"null\";\n-      }\n+    for (Map.Entry<?, V> entry : map.entrySet()) {\n+      String key = String.valueOf(entry.getKey());\n       writer.name(key);\n       valueTypeAdapter.write(writer, entry.getValue());\n     }\n--- a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java\n     try {\n       gson.toJson(a);\n       fail(\"Circular types should not get printed!\");\n-    } catch (IllegalStateException expected) { \n-      assertTrue(expected.getMessage().contains(\"children\"));      \n+    } catch (IllegalStateException expected) {\n+      assertTrue(expected.getMessage().contains(\"children\"));\n     }\n   }\n \n     try {\n       gson.toJson(objA);\n       fail(\"Circular reference to self can not be serialized!\");\n-    } catch (IllegalStateException expected) { \n+    } catch (IllegalStateException expected) {\n       assertTrue(expected.getMessage().contains(\"children\"));\n     }\n   }\n         obj.addProperty(\"property\", \"value\");\n         obj.add(\"child\", context.serialize(src.child));\n         return obj;\n-      }      \n+      }\n     }).create();\n     try {\n       gson.toJson(obj);\n       fail(\"Circular reference to self can not be serialized!\");\n-    } catch (IllegalStateException expected) { \n+    } catch (IllegalStateException expected) {\n       assertTrue(expected.getMessage().contains(\"Offending\"));\n     }\n   }\n   private static class ContainsReferenceToSelfType {\n     Collection<ContainsReferenceToSelfType> children = new ArrayList<ContainsReferenceToSelfType>();\n   }\n-  \n+\n   private static class ClassWithSelfReference {\n     ClassWithSelfReference child;\n   }", "timestamp": 1315556240, "metainfo": ""}