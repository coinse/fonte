{"sha": "861e047a6222d581ecf1f617599629bbf8654d34", "log": "Create an \"internals\" package for classes that we do not want to share, but is needed across multiple pacakges.  As well, move non-Gson specific classes, such as Preconditions, to this new \"internals\" package.", "commit": "\n--- a/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n+++ b/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.io.IOException;\n \n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.util.Collection;\n \n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Cache;\n+import com.google.gson.internal.LruCache;\n+import com.google.gson.internal.Pair;\n+import com.google.gson.internal.Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n /**\n  * Adapts the old \"deprecated\" FieldNamingStrategy to the new {@link FieldNamingStrategy2}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Primitives;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n import java.util.Set;\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+import com.google.gson.internal.Preconditions;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Pair;\n+import com.google.gson.internal.Preconditions;\n \n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n+++ b/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.io.IOException;\n import java.util.LinkedHashMap;\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Pair;\n+import com.google.gson.internal.Primitives;\n \n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Preconditions;\n+\n import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n  */\n \n package com.google.gson;\n+\n \n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Pair;\n+import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n   /**\n    * objTypePair.getObject() must not be null\n    */\n-  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  @SuppressWarnings(\"unchecked\")\n   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\n     Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n     if (pair == null) {\n--- a/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Types;\n+import com.google.gson.internal.UnsafeAllocator;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Constructor;\n--- a/gson/src/main/java/com/google/gson/MemoryRefStack.java\n+++ b/gson/src/main/java/com/google/gson/MemoryRefStack.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.util.Stack;\n \n--- a/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n--- a/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Preconditions;\n \n /**\n  * A factory class used to simplify {@link ObjectNavigator} creation.\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n  * limitations under the License.\n  */\n package com.google.gson;\n+\n+import com.google.gson.internal.Pair;\n \n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Pair;\n+import com.google.gson.internal.Types;\n+\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.HashMap;\n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n \n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n+import com.google.gson.internal.Preconditions;\n \n /**\n  * This strategy will exclude any files and/or class that are passed the\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Cache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * Defines generic cache interface.\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public interface Cache<K, V> {\n+\n+  /**\n+   * Adds the new value object into the cache for the given key.  If the key already\n+   * exists, then this method will override the value for the key.\n+   *\n+   * @param key the key identifier for the {@code value} object\n+   * @param value the value object to store in the cache\n+   */\n+  void addElement(K key, V value);\n+\n+  /**\n+   * Retrieve the cached value for the given {@code key}.\n+   *\n+   * @param key the key identifying the value\n+   * @return the cached value for the given {@code key}\n+   */\n+  V getElement(K key);\n+  \n+  /**\n+   * Removes the value from the cache for the given key.\n+   * \n+   * @param key the key identifying the value to remove\n+   * @return the value for the given {@code key}\n+   */\n+  V removeElement(K key);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/LruCache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of the {@link Cache} interface that evict objects from the cache using an\n+ * LRU (least recently used) algorithm.  Object start getting evicted from the cache once the\n+ * {@code maxCapacity} is reached.\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {\n+  private static final long serialVersionUID = 1L;\n+\n+  private final int maxCapacity;\n+\n+  public LruCache(int maxCapacity) {\n+    super(maxCapacity, 0.7F, true);\n+    this.maxCapacity = maxCapacity;\n+  }\n+\n+  public synchronized void addElement(K key, V value) {\n+    put(key, value);\n+  }\n+\n+  public synchronized V getElement(K key) {\n+    return get(key);\n+  }\n+\n+  public synchronized V removeElement(K key) {\n+    return remove(key);\n+  }\n+\n+  @Override\n+  protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n+    return size() > maxCapacity;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Pair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n+public final class Pair<FIRST, SECOND> {\n+  public final FIRST first;\n+  public final SECOND second;\n+\n+  public Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    Pair<?, ?> that = (Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Preconditions.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple utility class used to check method Preconditions.\n+ *\n+ * <pre>\n+ * public long divideBy(long value) {\n+ *   Preconditions.checkArgument(value != 0);\n+ *   return this.value / value;\n+ * }\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class Preconditions {\n+  public static <T> T checkNotNull(T obj) {\n+    if (obj == null) {\n+      throw new NullPointerException();\n+    }\n+    return obj;\n+  }\n+\n+  public static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+  \n+  public static void checkState(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Primitives.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+\n+import java.lang.reflect.Type;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains static utility methods pertaining to primitive types and their\n+ * corresponding wrapper types.\n+ *\n+ * @author Kevin Bourrillion\n+ */\n+public final class Primitives {\n+  private Primitives() {}\n+\n+  /** A map from primitive types to their corresponding wrapper types. */\n+  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n+\n+  /** A map from wrapper types to their corresponding primitive types. */\n+  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n+\n+  // Sad that we can't use a BiMap. :(\n+  \n+  static {\n+    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\n+    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n+\n+    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);\n+    add(primToWrap, wrapToPrim, byte.class, Byte.class);\n+    add(primToWrap, wrapToPrim, char.class, Character.class);\n+    add(primToWrap, wrapToPrim, double.class, Double.class);\n+    add(primToWrap, wrapToPrim, float.class, Float.class);\n+    add(primToWrap, wrapToPrim, int.class, Integer.class);\n+    add(primToWrap, wrapToPrim, long.class, Long.class);\n+    add(primToWrap, wrapToPrim, short.class, Short.class);\n+    add(primToWrap, wrapToPrim, void.class, Void.class);\n+\n+    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\n+    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n+  }\n+\n+  private static void add(Map<Class<?>, Class<?>> forward,\n+      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n+    forward.put(key, value);\n+    backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public static boolean isPrimitive(Type type) {\n+    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n+  }\n+\n+  /**\n+   * Returns {@code true} if {@code type} is one of the nine\n+   * primitive-wrapper types, such as {@link Integer}.\n+   *\n+   * @see Class#isPrimitive\n+   */\n+  public static boolean isWrapperType(Class<?> type) {\n+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n+        Preconditions.checkNotNull(type));\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> wrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n+        Preconditions.checkNotNull(type));\n+    return (wrapped == null) ? type : wrapped;\n+  }\n+\n+  /**\n+   * Returns the corresponding primitive type of {@code type} if it is a\n+   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     unwrap(Integer.class) == int.class\n+   *     unwrap(int.class) == int.class\n+   *     unwrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> unwrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n+        Preconditions.checkNotNull(type));\n+    return (unwrapped == null) ? type : unwrapped;\n+  }  \n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Types.java\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+\n+/**\n+ * Static methods for working with types.\n+ *\n+ * @author Bob Lee\n+ * @author Jesse Wilson\n+ */\n+public final class Types {\n+  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private Types() {}\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType} and enclosed by {@code ownerType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedTypeWithOwner(\n+      Type ownerType, Type rawType, Type... typeArguments) {\n+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns an array type whose elements are all instances of\n+   * {@code componentType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} generic array type.\n+   */\n+  public static GenericArrayType arrayOf(Type componentType) {\n+    return new GenericArrayTypeImpl(componentType);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}.\n+   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n+   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n+   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For\n+   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n+   * super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+  }\n+\n+  /**\n+   * Returns a type that is functionally equal but not necessarily equal\n+   * according to {@link Object#equals(Object) Object.equals()}. The returned\n+   * type is {@link java.io.Serializable}.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type canonicalize(Type type) {\n+    if (type instanceof Class) {\n+      Class<?> c = (Class<?>) type;\n+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType p = (ParameterizedType) type;\n+      return new ParameterizedTypeImpl(p.getOwnerType(),\n+          p.getRawType(), p.getActualTypeArguments());\n+\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType g = (GenericArrayType) type;\n+      return new GenericArrayTypeImpl(g.getGenericComponentType());\n+\n+    } else if (type instanceof WildcardType) {\n+      WildcardType w = (WildcardType) type;\n+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+\n+    } else {\n+      // type is either serializable as-is or unsupported\n+      return type;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      checkArgument(rawType instanceof Class);\n+      return (Class<?>) rawType;\n+\n+    } else if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n+      return Array.newInstance(getRawType(componentType), 0).getClass();\n+\n+    } else if (type instanceof TypeVariable) {\n+      // we could use the variable's bounds, but that won't work if there are multiple.\n+      // having a raw type that's more general than necessary is okay\n+      return Object.class;\n+\n+    } else if (type instanceof WildcardType) {\n+      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n+\n+    } else {\n+      String className = type == null ? \"null\" : type.getClass().getName();\n+      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n+    }\n+  }\n+\n+  static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Returns true if {@code a} and {@code b} are equal.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean equals(Type a, Type b) {\n+    if (a == b) {\n+      // also handles (a == null && b == null)\n+      return true;\n+\n+    } else if (a instanceof Class) {\n+      // Class already specifies equals().\n+      return a.equals(b);\n+\n+    } else if (a instanceof ParameterizedType) {\n+      if (!(b instanceof ParameterizedType)) {\n+        return false;\n+      }\n+\n+      // TODO: save a .clone() call\n+      ParameterizedType pa = (ParameterizedType) a;\n+      ParameterizedType pb = (ParameterizedType) b;\n+      return equal(pa.getOwnerType(), pb.getOwnerType())\n+          && pa.getRawType().equals(pb.getRawType())\n+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n+\n+    } else if (a instanceof GenericArrayType) {\n+      if (!(b instanceof GenericArrayType)) {\n+        return false;\n+      }\n+\n+      GenericArrayType ga = (GenericArrayType) a;\n+      GenericArrayType gb = (GenericArrayType) b;\n+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n+\n+    } else if (a instanceof WildcardType) {\n+      if (!(b instanceof WildcardType)) {\n+        return false;\n+      }\n+\n+      WildcardType wa = (WildcardType) a;\n+      WildcardType wb = (WildcardType) b;\n+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n+\n+    } else if (a instanceof TypeVariable) {\n+      if (!(b instanceof TypeVariable)) {\n+        return false;\n+      }\n+      TypeVariable<?> va = (TypeVariable<?>) a;\n+      TypeVariable<?> vb = (TypeVariable<?>) b;\n+      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n+          && va.getName().equals(vb.getName());\n+\n+    } else {\n+      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n+      return false;\n+    }\n+  }\n+\n+  private static int hashCodeOrZero(Object o) {\n+    return o != null ? o.hashCode() : 0;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static String typeToString(Type type) {\n+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n+  }\n+\n+  /**\n+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n+   */\n+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n+    if (toResolve == rawType) {\n+      return context;\n+    }\n+\n+    // we skip searching through interfaces if unknown is an interface\n+    if (toResolve.isInterface()) {\n+      Class<?>[] interfaces = rawType.getInterfaces();\n+      for (int i = 0, length = interfaces.length; i < length; i++) {\n+        if (interfaces[i] == toResolve) {\n+          return rawType.getGenericInterfaces()[i];\n+        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+        }\n+      }\n+    }\n+\n+    // check our supertypes\n+    if (!rawType.isInterface()) {\n+      while (rawType != Object.class) {\n+        Class<?> rawSupertype = rawType.getSuperclass();\n+        if (rawSupertype == toResolve) {\n+          return rawType.getGenericSuperclass();\n+        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+        }\n+        rawType = rawSupertype;\n+      }\n+    }\n+\n+    // we can't resolve this further\n+    return toResolve;\n+  }\n+\n+  /**\n+   * Returns the generic form of {@code supertype}. For example, if this is {@code\n+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n+   * Iterable.class}.\n+   *\n+   * @param supertype a superclass of, or interface implemented by, this.\n+   */\n+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n+    checkArgument(supertype.isAssignableFrom(contextRawType));\n+    return resolve(context, contextRawType,\n+        Types.getGenericSupertype(context, contextRawType, supertype));\n+  }\n+\n+  /**\n+   * Returns true if this type is an array.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean isArray(Type type) {\n+    return type instanceof GenericArrayType\n+        || (type instanceof Class && ((Class<?>) type).isArray());\n+  }\n+\n+  /**\n+   * Returns the component type of this array type.\n+   * @throws ClassCastException if this type is not an array.\n+   */\n+  public static Type getArrayComponentType(Type array) {\n+    return array instanceof GenericArrayType\n+        ? ((GenericArrayType) array).getGenericComponentType()\n+        : ((Class<?>) array).getComponentType();\n+  }\n+\n+  /**\n+   * Returns the element type of this collection type.\n+   * @throws IllegalArgumentException if this type is not a collection.\n+   */\n+  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n+    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n+    return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Returns a two element array containing this map's key and value types in\n+   * positions 0 and 1 respectively.\n+   */\n+  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n+    /*\n+     * Work around a problem with the declaration of java.util.Properties. That\n+     * class should extend Hashtable<String, String>, but it's declared to\n+     * extend Hashtable<Object, Object>.\n+     */\n+    if (context == Properties.class) {\n+      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n+    }\n+\n+    Type mapType = getSupertype(context, contextRawType, Map.class);\n+    ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n+    return mapParameterizedType.getActualTypeArguments();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n+    // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    while (true) {\n+      if (toResolve instanceof TypeVariable) {\n+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n+        if (toResolve == typeVariable) {\n+          return toResolve;\n+        }\n+\n+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n+        Class<?> original = (Class<?>) toResolve;\n+        Type componentType = original.getComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof GenericArrayType) {\n+        GenericArrayType original = (GenericArrayType) toResolve;\n+        Type componentType = original.getGenericComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof ParameterizedType) {\n+        ParameterizedType original = (ParameterizedType) toResolve;\n+        Type ownerType = original.getOwnerType();\n+        Type newOwnerType = resolve(context, contextRawType, ownerType);\n+        boolean changed = newOwnerType != ownerType;\n+\n+        Type[] args = original.getActualTypeArguments();\n+        for (int t = 0, length = args.length; t < length; t++) {\n+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n+          if (resolvedTypeArgument != args[t]) {\n+            if (!changed) {\n+              args = args.clone();\n+              changed = true;\n+            }\n+            args[t] = resolvedTypeArgument;\n+          }\n+        }\n+\n+        return changed\n+            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n+            : original;\n+\n+      } else if (toResolve instanceof WildcardType) {\n+        WildcardType original = (WildcardType) toResolve;\n+        Type[] originalLowerBound = original.getLowerBounds();\n+        Type[] originalUpperBound = original.getUpperBounds();\n+\n+        if (originalLowerBound.length == 1) {\n+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n+          if (lowerBound != originalLowerBound[0]) {\n+            return supertypeOf(lowerBound);\n+          }\n+        } else if (originalUpperBound.length == 1) {\n+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n+          if (upperBound != originalUpperBound[0]) {\n+            return subtypeOf(upperBound);\n+          }\n+        }\n+        return original;\n+\n+      } else {\n+        return toResolve;\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n+    Class<?> declaredByRaw = declaringClassOf(unknown);\n+\n+    // we can't reduce this further\n+    if (declaredByRaw == null) {\n+      return unknown;\n+    }\n+\n+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n+    if (declaredBy instanceof ParameterizedType) {\n+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n+    }\n+\n+    return unknown;\n+  }\n+\n+  private static int indexOf(Object[] array, Object toFind) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (toFind.equals(array[i])) {\n+        return i;\n+      }\n+    }\n+    throw new NoSuchElementException();\n+  }\n+\n+  /**\n+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n+   * a class.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n+    return genericDeclaration instanceof Class\n+        ? (Class<?>) genericDeclaration\n+        : null;\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+  }\n+\n+  private static class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n+    private final Type ownerType;\n+    private final Type rawType;\n+    private final Type[] typeArguments;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n+      // require an owner type if the raw type needs it\n+      if (rawType instanceof Class<?>) {\n+        Class rawTypeAsClass = (Class) rawType;\n+        checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n+        checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n+      }\n+\n+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n+      this.rawType = canonicalize(rawType);\n+      this.typeArguments = typeArguments.clone();\n+      for (int t = 0; t < this.typeArguments.length; t++) {\n+        checkNotNull(this.typeArguments[t]);\n+        checkNotPrimitive(this.typeArguments[t]);\n+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n+      }\n+    }\n+\n+    public Type[] getActualTypeArguments() {\n+      return typeArguments.clone();\n+    }\n+\n+    public Type getRawType() {\n+      return rawType;\n+    }\n+\n+    public Type getOwnerType() {\n+      return ownerType;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof ParameterizedType\n+          && Types.equals(this, (ParameterizedType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      return Arrays.hashCode(typeArguments)\n+          ^ rawType.hashCode()\n+          ^ hashCodeOrZero(ownerType);\n+    }\n+\n+    @Override public String toString() {\n+      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));\n+      stringBuilder.append(typeToString(rawType));\n+\n+      if (typeArguments.length == 0) {\n+        return stringBuilder.toString();\n+      }\n+\n+      stringBuilder.append(\"<\").append(typeToString(typeArguments[0]));\n+      for (int i = 1; i < typeArguments.length; i++) {\n+        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n+      }\n+      return stringBuilder.append(\">\").toString();\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n+    private final Type componentType;\n+\n+    public GenericArrayTypeImpl(Type componentType) {\n+      this.componentType = canonicalize(componentType);\n+    }\n+\n+    public Type getGenericComponentType() {\n+      return componentType;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof GenericArrayType\n+          && Types.equals(this, (GenericArrayType) o);\n+    }\n+\n+    @Override public int hashCode() {\n+      return componentType.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return typeToString(componentType) + \"[]\";\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  /**\n+   * The WildcardType interface supports multiple upper bounds and multiple\n+   * lower bounds. We only support what the Java 6 language needs - at most one\n+   * bound. If a lower bound is set, the upper bound must be Object.class.\n+   */\n+  private static class WildcardTypeImpl implements WildcardType, Serializable {\n+    private final Type upperBound;\n+    private final Type lowerBound;\n+\n+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+      checkArgument(lowerBounds.length <= 1);\n+      checkArgument(upperBounds.length == 1);\n+\n+      if (lowerBounds.length == 1) {\n+        checkNotNull(lowerBounds[0]);\n+        checkNotPrimitive(lowerBounds[0]);\n+        checkArgument(upperBounds[0] == Object.class);\n+        this.lowerBound = canonicalize(lowerBounds[0]);\n+        this.upperBound = Object.class;\n+\n+      } else {\n+        checkNotNull(upperBounds[0]);\n+        checkNotPrimitive(upperBounds[0]);\n+        this.lowerBound = null;\n+        this.upperBound = canonicalize(upperBounds[0]);\n+      }\n+    }\n+\n+    public Type[] getUpperBounds() {\n+      return new Type[] { upperBound };\n+    }\n+\n+    public Type[] getLowerBounds() {\n+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof WildcardType\n+          && Types.equals(this, (WildcardType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n+          ^ (31 + upperBound.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      if (lowerBound != null) {\n+        return \"? super \" + typeToString(lowerBound);\n+      } else if (upperBound == Object.class) {\n+        return \"?\";\n+      } else {\n+        return \"? extends \" + typeToString(upperBound);\n+      }\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static void checkNotNull(Object obj) {\n+    checkArgument(obj != null);\n+  }\n+\n+  private static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException(\"condition failed: \" + condition);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Do sneaky things to allocate objects without invoking their constructors.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+public abstract class UnsafeAllocator {\n+  public abstract <T> T newInstance(Class<T> c) throws Exception;\n+\n+  public static UnsafeAllocator create() {\n+    // try JVM\n+    // public class Unsafe {\n+    //   public Object allocateInstance(Class<?> type);\n+    // }\n+    try {\n+      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n+      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      final Object unsafe = f.get(null);\n+      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) allocateInstance.invoke(unsafe, c);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, pre-gingerbread\n+    // public class ObjectInputStream {\n+    //   private static native Object newInstance(\n+    //     Class<?> instantiationClass, Class<?> constructorClass);\n+    // }\n+    try {\n+      final Method newInstance = ObjectInputStream.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, Object.class);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvivkm, post-gingerbread\n+    // public class ObjectStreamClass {\n+    //   private static native int getConstructorId(Class<?> c);\n+    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n+    // }\n+    try {\n+      Method getConstructorId = ObjectStreamClass.class\n+          .getDeclaredMethod(\"getConstructorId\", Class.class);\n+      getConstructorId.setAccessible(true);\n+      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n+      final Method newInstance = ObjectStreamClass.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, constructorId);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // give up\n+    return new UnsafeAllocator() {\n+      public <T> T newInstance(Class<T> c) throws InstantiationException {\n+        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n package com.google.gson.reflect;\n \n-import com.google.gson.Types;\n+import com.google.gson.internal.Types;\n+\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n  * create an empty anonymous inner class:\n  *\n  * <p>\n- * {@code TypeLiteral<List<String>> list = new TypeToken<List<String>>() {};}\n+ * {@code TypeToken<List<String>> list = new TypeToken<List<String>>() {};}\n  *\n  * <p>This syntax cannot be used to create type literals that have wildcard\n  * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n- * Such type literals must be constructed programatically, either by {@link\n+ * Such type tokens must be constructed programatically, either by {@link\n  * Method#getGenericReturnType extracting types from members} or by using the\n  * {@link Types} factory class.\n  *\n--- a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n--- a/gson/src/test/java/com/google/gson/LruCacheTest.java\n+++ b/gson/src/test/java/com/google/gson/LruCacheTest.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Cache;\n+import com.google.gson.internal.LruCache;\n \n import junit.framework.TestCase;\n \n--- a/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n+++ b/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n \n package com.google.gson;\n \n-import com.google.gson.MemoryRefStack;\n \n import junit.framework.TestCase;\n \n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n  */\n \n package com.google.gson;\n+\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.Types;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n--- a/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n+++ b/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n import java.lang.reflect.Method;\n \n import com.google.gson.JsonParseException;\n-import com.google.gson.Primitives;\n+import com.google.gson.internal.Primitives;\n \n /**\n  * Handles type conversion from some object to some primitive (or primitive\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.InstanceCreator;\n-import com.google.gson.JsonElement;\n-import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n--- a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java\n \n   public void testRegisterSubTypeFirstNotAllowed() {\n     try {\n-      Gson gson = new GsonBuilder()\n-        .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())\n-        .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())\n-        .create();\n+      new GsonBuilder()\n+          .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())\n+          .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())\n+          .create();\n       fail();\n     } catch (IllegalArgumentException expected) {\n     }", "timestamp": 1300746635, "metainfo": ""}