{"sha": "7abeb1608064abd19129ef7bcaf781dbd3ed26e9", "log": "Thread safe method cache", "commit": "\n--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n \n import com.google.common.base.CaseFormat;\n import com.google.common.base.Converter;\n+import com.google.common.collect.MapMaker;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n \n /**\n  * GSON type adapter for protocol buffers that knows how to serialize enums either by using their\n \n   private static final com.google.protobuf.Descriptors.FieldDescriptor.Type ENUM_TYPE =\n       com.google.protobuf.Descriptors.FieldDescriptor.Type.ENUM;\n+\n+  private static final ConcurrentMap<String, Map<Class<?>, Method>> mapOfMapOfMethods =\n+      new MapMaker().makeMap();\n \n   private final EnumSerialization enumSerialization;\n   private final Converter<String, String> fieldNameSerializationFormat;\n     }\n   }\n \n-  private static Method getCachedMethod(Class<?> clazz, String methodName)\n-      throws NoSuchMethodException {\n-    if (!mapOfMapOfMethods.containsKey(methodName)) {\n-      mapOfMapOfMethods.put(methodName, new HashMap<Class<?>, Method>());\n-    }\n+  private static Method getCachedMethod(Class<?> clazz, String methodName,\n+      Class<?>... methodParamTypes) throws NoSuchMethodException {\n     Map<Class<?>, Method> mapOfMethods = mapOfMapOfMethods.get(methodName);\n-    if (!mapOfMethods.containsKey(clazz)) {\n-      mapOfMethods.put(clazz, clazz.getMethod(methodName));\n-    }\n-    return mapOfMethods.get(clazz);\n-  }\n-\n-  private static Map<String, Map<Class<?>, Method>> mapOfMapOfMethods =\n-      new HashMap<String, Map<Class<?>, Method>>();\n+    if (mapOfMethods == null) {\n+      mapOfMethods = new MapMaker().makeMap();\n+      Map<Class<?>, Method> previous =\n+          mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);\n+      mapOfMethods = previous == null ? mapOfMethods : previous;\n+    }\n+\n+    Method method = mapOfMethods.get(clazz);\n+    if (method == null) {\n+      method = clazz.getMethod(methodName, methodParamTypes);\n+      mapOfMethods.putIfAbsent(clazz, method);\n+      // NB: it doesn't matter which method we return in the event of a race.\n+    }\n+    return method;\n+  }\n+\n }", "timestamp": 1446068516, "metainfo": ""}