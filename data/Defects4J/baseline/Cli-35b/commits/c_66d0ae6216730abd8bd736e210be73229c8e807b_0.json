{"sha": "66d0ae6216730abd8bd736e210be73229c8e807b", "log": "implemented the parser factory, added new unit tests for the GnuParser, a good deal of refactoring for both parsers   ", "commit": "\n--- a/src/java/org/apache/commons/cli/CommandLineParser.java\n+++ b/src/java/org/apache/commons/cli/CommandLineParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/CommandLineParser.java,v 1.1 2002/06/16 23:00:57 jkeyes Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/06/16 23:00:57 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/CommandLineParser.java,v 1.2 2002/07/04 22:32:12 jkeyes Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/07/04 22:32:12 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.cli;\n \n-import java.util.List;\n-\n /**\n  * @author John Keyes (jbjk at mac.com)\n  */\n     \n     /**\n      * Parse the arguments according to the specified options.\n+     *\n      * @param options the specified Options\n      * @param arguments the command line arguments\n      * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n      */\n-    public List parse( Options options, List arguments );\n-    \n+    public CommandLine parse( Options options, String[] arguments )\n+    throws ParseException;\n+\n     /**\n      * Parse the arguments according to the specified options.\n+     *\n      * @param options the specified Options\n      * @param arguments the command line arguments\n      * @param stopAtNonOption specifies whether to continue parsing the\n      * arguments if a non option is encountered.\n      * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n      */\n-    public List parse( Options options, List arguments, boolean stopAtNonOption );\n+    public CommandLine parse( Options options, String[] arguments, boolean stopAtNonOption )\n+    throws ParseException;\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/CommandLineParserFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Attic/CommandLineParserFactory.java,v 1.1 2002/07/04 22:32:12 jkeyes Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/07/04 22:32:12 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.cli;\n+\n+/**\n+ * Constructs CommandLineParser instances.  The implementation class\n+ * is specified by the <code>org.apache.commons.cli.parser</code>\n+ * system property.\n+ *\n+ * @author John Keyes (jbjk at mac.com)\n+ */\n+public class CommandLineParserFactory {\n+\n+    /** The PosixParser is the default parser implementation */\n+    private static String DEFAULT_PARSER = \"org.apache.commons.cli.PosixParser\";\n+\n+    /**\n+     * @return the CommandLineParser\n+     */\n+    public static CommandLineParser newParser() {\n+        String parserImpl = System.getProperty( \"org.apache.commons.cli.parser\" );\n+        try {\n+            return (CommandLineParser)Class.forName( parserImpl ).newInstance();\n+        }\n+        catch( Exception exp ) {\n+            // could not create according to parserImpl so default to\n+            // PosixParser\n+            try {\n+                return (CommandLineParser)Class.forName( DEFAULT_PARSER ).newInstance();\n+            }\n+            catch( Exception exp2 ) {\n+                // this will not happen ?\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.1 2002/06/19 21:25:40 jkeyes Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/06/19 21:25:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.2 2002/07/04 22:32:12 jkeyes Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/07/04 22:32:12 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.cli;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.ListIterator;\n \n /**\n  * GnuParser parses the command line arguments using the GNU style.\n  */\n public class GnuParser implements CommandLineParser {\n \n+    /** current options instance */\n+    private Options options;\n+\n+    /** convience member for the command line */\n+    private CommandLine cmd;\n+\n+    /** required options subset of options */\n+    private Collection requiredOptions;\n+\n     /**\n      * Parse the arguments according to the specified options.\n+     *\n      * @param options the specified Options\n      * @param arguments the command line arguments\n      * @return the list of atomic option and value tokens\n-     */\n-    public List parse( Options options, List arguments ) {\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse( Options options, String[] arguments ) \n+    throws ParseException\n+    {\n         return parse( options, arguments, false );\n     }\n \n     /**\n      * Parse the arguments according to the specified options.\n-     * @param options the specified Options\n+     *\n+     * @param opts the specified Options\n      * @param arguments the command line arguments\n      * @param stopAtNonOption specifies whether to continue parsing the\n      * arguments if a non option is encountered.\n-     * @return the list of atomic option and value tokens\n-     */\n-    public List parse( Options options, List arguments, boolean stopAtNonOption ) {\n-        List args = new LinkedList();\n-\n-        Iterator argIter = arguments.iterator();\n-        String   eachArg = null;\n-        \n+     * @return the CommandLine\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse( Options opts, String[] arguments, boolean stopAtNonOption ) \n+    throws ParseException\n+    {\n+        // set the member instances\n+        options = opts;\n+        cmd = new CommandLine();\n+        requiredOptions = options.getRequiredOptions();\n+\n+        ListIterator iter = Arrays.asList( arguments ).listIterator();\n+        String token = null;\n+\n+        // flag to indicate whether the remainder of the tokens should\n+        // be added to the other arguments list\n         boolean eatTheRest = false;\n-        \n-        while ( argIter.hasNext() ) {\n-            eachArg = (String) argIter.next();\n-            \n-            if ( eachArg.equals(\"--\") ) {\n-                // Look for -- to indicate end-of-options, and\n-                // just stuff it, along with everything past it\n-                // into the returned list.\n-                \n-                args.add( eachArg );\n+\n+        while ( iter.hasNext() ) {\n+            token = (String) iter.next();\n+\n+            if ( token.equals(\"--\") ) {\n                 eatTheRest = true;\n             }\n-            else if ( eachArg.startsWith(\"--\") ) {\n-                // It's a long-option, so doesn't need any\n-                // bursting applied to it.\n-                \n-                args.add( eachArg );\n-            }\n-            else if ( eachArg.startsWith(\"-\") ) {\n-                \n-                if ( eachArg.length() == 1) {\n+            else if ( token.startsWith(\"--\") ) {\n+                //process the long-option\n+                processOption( token, iter );\n+            }\n+            else if ( token.startsWith(\"-\") ) {\n+                if ( token.length() == 1) {\n                     // It's not really an option, so\n                     // just drop it on the list\n-                    \n                     if ( stopAtNonOption ) {\n                         eatTheRest = true;\n                     }\n                     else {\n-                        args.add( eachArg );\n+                        cmd.addArg( token );\n                     }\n                 }\n-                else if ( eachArg.length() == 2 ) {\n-                    args.add( eachArg );\n-                }\n                 else {\n-                    String charOpt = eachArg.substring( 1, 2 );\n-\n-                    if( options.getOption( charOpt ) != null\n-                        && options.getOption( eachArg ) == null )\n-                    {\n-                        args.add( \"-\" + charOpt );\n-                        args.add( eachArg.substring( 2, eachArg.length() ) );\n-                    }\n-                    else {\n-                        args.add( eachArg );\n-                    }\n+                    processOption( token, iter );\n                 }\n             }\n             else {\n                 // It's just a normal non-option arg,\n                 // so dump it into the list of returned\n                 // values.\n-                \n-                args.add( eachArg );\n-                \n+\n+                cmd.addArg( token );\n+\n                 if ( stopAtNonOption ) {\n                     eatTheRest = true;\n                 }\n             }\n-            \n+\n             if ( eatTheRest ) {\n-                while ( argIter.hasNext() ) {\n-                    args.add( argIter.next() );\n-                }\n-            }\n-        }\n-        \n-        return args;\n-    }\n+                while ( iter.hasNext() ) {\n+                    cmd.addArg( (String)iter.next() );\n+                }\n+            }\n+        }\n+\n+        // see if all required options have been processed\n+        checkRequiredOptions( );\n+\n+        return cmd;\n+    }\n+\n+    /**\n+     * It the option can accept multiple argument values then\n+     * keep adding values until the next option token is encountered.\n+     *\n+     * @param opt the specified option\n+     * @param iter the iterator over the command line tokens\n+     */\n+    public void processMultipleArgs( Option opt, ListIterator iter ) {\n+        // loop until an option is found\n+        while( iter.hasNext() ) {\n+            String var = (String)iter.next();\n+\n+            // its an option\n+            if( var.startsWith( \"-\" ) ) {\n+                // set the iterator pointer back a position\n+                iter.previous();\n+                break;\n+            }\n+            // its a value\n+            else {\n+                opt.addValue( var );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process the option represented by <code>arg</code>.\n+     * \n+     * @param arg the string representation of an option\n+     * @param iter the command line token iterator\n+     */\n+    private void processOption( String arg, ListIterator iter ) \n+    throws ParseException\n+    {\n+        String value = null;\n+\n+        // see if it is a single character special option\n+        Option opt = (Option) options.getOption( arg );\n+        Option specialOption = (Option) options.getOption( arg.substring(0,2 ) );\n+        if( specialOption != null && opt == null) {\n+            opt = specialOption;\n+            value = arg.substring( 2 );\n+        }\n+\n+        // if there is no option throw an UnrecognisedOptionException\n+        if( opt == null ) {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n+        }\n+\n+        // if the option is a required option remove the option from\n+        // the requiredOptions list\n+        if ( opt.isRequired() ) {\n+            requiredOptions.remove( opt );\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected\n+        // option of the group\n+        if ( options.getOptionGroup( opt ) != null ) {\n+            ( (OptionGroup)( options.getOptionGroup( opt ) ) ).setSelected( opt );\n+        }\n+\n+        // if the option takes an argument value\n+        if ( opt.hasArg() ) {\n+            try {\n+                value = (value != null) ? value : (String)iter.next(); \n+            }\n+            catch( java.util.NoSuchElementException exp ) {\n+                throw new MissingArgumentException( \"no argument for:\" + arg );\n+            }\n+            opt.addValue( value );\n+            if  (opt.hasMultipleArgs() ) {\n+                processMultipleArgs( opt, iter );\n+            }\n+        }\n+\n+        // set the option on the command line\n+        cmd.setOpt( opt );\n+    }\n+\n+    /**\n+     * Ensures that all required options are present.\n+     *\n+     * @throws ParseException if all of the required options\n+     * are not present.\n+     */\n+    private void checkRequiredOptions( ) \n+    throws ParseException {\n+\n+        // if there are required options that have not been\n+        // processsed\n+        if( requiredOptions.size() > 0 ) {\n+            Iterator iter = requiredOptions.iterator();\n+            StringBuffer buff = new StringBuffer();\n+\n+            // loop through the required options\n+            while( iter.hasNext() ) {\n+                Option missing = (Option)iter.next();\n+                buff.append( \"-\" );\n+                buff.append( missing.getOpt() );\n+                buff.append( \" \" );\n+                buff.append( missing.getDescription() );\n+            }\n+\n+            // throw the MissingOptionException\n+            throw new MissingOptionException( buff.toString() );\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n \n package org.apache.commons.cli;\n \n+import java.util.Collection;\n import java.util.Map;\n-import java.util.Set;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.Collections;\n  */\n public class Options {\n \n-    private String defaultParserImpl = \"org.apache.commons.cli.PosixParser\";\n-    private String parserImpl = defaultParserImpl;\n-\n-    private CommandLineParser parser;\n-\n     /** the list of options */\n     private List options      = new ArrayList();\n \n     /** <p>Construct a new Options descriptor</p>\n      */\n     public Options() {        \n-        parserImpl = System.getProperty( \"org.apache.commons.cli.parser\" );\n-        try {\n-            parser = (CommandLineParser)Class.forName( parserImpl ).newInstance();\n-        }\n-        catch( Exception exp ) {\n-            // could not create according to parserImpl so default to\n-            // PosixParser\n-            try {\n-                parser = (CommandLineParser)Class.forName( defaultParserImpl ).newInstance();\n-            }\n-            catch( Exception exp2 ) {\n-                // this will not happen ?\n-            }\n-        }\n     }\n \n     /**\n         return this;\n     }\n \n-    /** <p>Parse the given list of arguments against this descriptor<p>\n-     *\n-     * @param args Args to parse\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(String[] args) \n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        return parse( args, 0, args.length, false);\n-    }\n-    \n-    /** <p>Parse the given list of arguments against this descriptor</p>\n-     *\n-     * <p>This method will cease parsing upon the first non-option token,\n-     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n-     *\n-     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n-     *\n-     * <p><code>\n-     * <pre>\n-     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n-     * </pre>\n-     * </code></p>\n-     *\n-     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n-     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n-     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n-     * another different <code>Options</code> instance.<p>\n-     *\n-     * @param args Args to parse\n-     * @param stopAtNonOption stop parsing at the first non-option token\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(String[] args, boolean stopAtNonOption) \n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        return parse( args, 0, args.length, stopAtNonOption);\n-    }\n-    \n-    /** <p>Parse the given list of arguments against this descriptor</p>\n-     *\n-     * <p>This method allows parsing from <code>formIndex</code> inclusive\n-     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n-     * to allow parsing a specific portion of a command-line.<p>\n-     *\n-     * @param args Args to parse\n-     * @param fromIndex index of args to start parsing\n-     * @param toIndex index of args to stop parsing\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(String[] args, int fromIndex, int toIndex) \n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        return parse( args, fromIndex, toIndex, false );\n-    }\n-    \n-    /** <p>Parse the given list of arguments against this descriptor</p>\n-     *\n-     * <p>This method will cease parsing upon the first non-option token,\n-     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n-     *\n-     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n-     *\n-     * <p><code>\n-     * <pre>\n-     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n-     * </pre>\n-     * </code></p>\n-     *\n-     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n-     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n-     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n-     * another different <code>Options</code> instance.<p>\n-     *\n-     * <p>This method also allows parsing from <code>formIndex</code> inclusive\n-     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n-     * to allow parsing a specific portion of a command-line.<p>\n-     *\n-     * @param args Args to parse\n-     * @param fromIndex index of args to start parsing\n-     * @param toIndex index of args to stop parsing\n-     * @param stopAtNonOption stop parsing at the first non-option token\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(String[] args, int fromIndex, int toIndex, boolean stopAtNonOption)\n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        List argList = java.util.Arrays.asList( args );\n-        \n-        return parse( argList, stopAtNonOption);\n-    }\n-    \n-    /** <p>Parse the given list of arguments against this descriptor</p>\n-     *\n-     * @param args Args to parse\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(List args)\n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        return parse( args, false );\n-    }\n-    \n-    /** <p>Parse the given list of arguments against this descriptor</p>\n-     *\n-     * <p>This method will cease parsing upon the first non-option token,\n-     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n-     *\n-     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n-     *\n-     * <p><code>\n-     * <pre>\n-     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n-     * </pre>\n-     * </code></p>\n-     *\n-     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n-     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n-     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n-     * another different <code>Options</code> instance.<p>\n-     *\n-     * <p>This method also allows parsing from <code>formIndex</code> inclusive\n-     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n-     * to allow parsing a specific portion of a command-line.<p>\n-     *\n-     * @param inArgs Arguments to parse\n-     * @param stopAtNonOption stop parsing at the first non-option token\n-     *\n-     * @return {@link CommandLine} containing information related to parse state\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws MissingOptionException if a required option is not present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    public CommandLine parse(List inArgs, boolean stopAtNonOption) \n-    throws MissingArgumentException, UnrecognizedOptionException, \n-        MissingOptionException, AlreadySelectedException {\n-        CommandLine cl = new CommandLine();\n-        \n-        List args = parser.parse( this, inArgs, stopAtNonOption );\n-\n-        ListIterator argIter = args.listIterator();\n-        String   eachArg = null;\n-        Option   eachOpt = null;\n-        boolean  eatTheRest = false;\n-\n-        while ( argIter.hasNext() ) {\n-\n-            eachArg = (String) argIter.next();\n-\n-            if ( eachArg.equals(\"--\") ) {\n-                // signalled end-of-opts.  Eat the rest\n-                \n-                eatTheRest = true;\n-            }\n-            else if ( eachArg.startsWith(\"--\") ) {\n-                eachOpt = (Option) longOpts.get( eachArg );\n-                processOption( eachArg, eachOpt, argIter, cl );\n-            }\n-            else if ( eachArg.equals(\"-\") ) {\n-                // Just-another-argument\n-                \n-                if ( stopAtNonOption ) {\n-                    eatTheRest = true;\n-                }\n-                else {\n-                    cl.addArg( eachArg );\n-                }\n-            }\n-            else if ( eachArg.startsWith(\"-\") ) {\n-                eachOpt = (Option) shortOpts.get( eachArg );\n-                processOption( eachArg, eachOpt, argIter, cl );\n-            }                \n-            else {\n-                cl.addArg( eachArg );\n-                if ( stopAtNonOption ) {\n-                    eatTheRest = true;\n-                }\n-            }\n-            \n-            if ( eatTheRest ) {\n-                while ( argIter.hasNext() ) {\n-                    eachArg = (String) argIter.next();\n-                    cl.addArg( eachArg );\n-                }\n-            }\n-        }\n-\n-        // this will throw a MissingOptionException\n-        checkRequiredOptions();\n-\n-        return cl;\n-    }\n-\n-    /**\n-     * @throws MissingOptionException if all of the required options are\n-     * not present.\n-     */\n-    private void checkRequiredOptions() throws MissingOptionException {\n-        if( requiredOpts.size() > 0 ) {\n-            Set optKeys = requiredOpts.keySet();\n-\n-            Iterator iter = optKeys.iterator();\n-\n-            StringBuffer buff = new StringBuffer();\n-\n-            while( iter.hasNext() ) {\n-                Option missing = (Option)requiredOpts.get( iter.next() );\n-                buff.append( \"-\" );\n-                buff.append( missing.getOpt() );\n-                buff.append( \" \" );\n-                buff.append( missing.getDescription() );\n-            }\n-\n-            throw new MissingOptionException( buff.toString() );\n-        }\n-    }\n-\n-    /**\n-     * <p>processOption rakes the current option and checks if it is\n-     * an unrecognised option, whether the argument value is missing or\n-     * whether the option has already been selected.</p>\n-     *\n-     * @param eachArg the current option read from command line\n-     * @param option the current option corresponding to eachArg\n-     * @param argIter the argument iterator\n-     * @param cl the current command line\n-     *\n-     * @throws MissingArgumentException if an argument value for an option is not present\n-     * @throws UnrecognizedOptionException if an unrecognised option is present\n-     * @throws AlreadySelectedException if the same option appears more than once\n-     */\n-    private void processOption( String eachArg, Option option, ListIterator argIter, \n-                                CommandLine cl)\n-    throws UnrecognizedOptionException, AlreadySelectedException, \n-        MissingArgumentException {\n-\n-        if ( option == null ) {\n-            throw new UnrecognizedOptionException(\"Unrecognized option: \" + eachArg);\n-        }\n-        else {\n-\n-            if ( optionGroups.get( option ) != null ) {\n-                ( (OptionGroup)( optionGroups.get( option ) ) ).setSelected( option );\n-            }\n-\n-            // if required remove from list\n-            if ( option.isRequired() ) {\n-                requiredOpts.remove( \"-\" + option.getOpt() );\n-            }\n-\n-            if ( option.hasArg() ) {\n-                if ( argIter.hasNext() ) {\n-                    eachArg = (String) argIter.next();\n-                    option.addValue( eachArg );\n-                    \n-                    if( option.hasMultipleArgs() ) {\n-                        while( argIter.hasNext() ) {\n-                            eachArg = (String)argIter.next();\n-                            if( eachArg.startsWith(\"-\") ) {\n-                                argIter.previous();\n-                                cl.setOpt( option );\n-                                break;\n-                            }\n-                            else {\n-                                option.addValue( eachArg );\n-                            }\n-                        }\n-                    }\n-                    else {\n-                        cl.setOpt( option );\n-                        return;\n-                    }\n-                    if( !argIter.hasNext() ) {\n-                        cl.setOpt( option );\n-                    }\n-                }\n-                else {\n-                    throw new MissingArgumentException( eachArg + \" requires an argument.\");\n-                }\n-\n-            }\n-            else {\n-                cl.setOpt( option );\n-            }\n-        }\n-    }\n-\n     /**\n      * <p>Adds the option to the necessary member lists</p>\n      *\n      */\n     public List getOptions() {\n         return Collections.unmodifiableList(options);\n+    }\n+\n+    /** <p>Returns the required options as a \n+     * <code>java.util.Collection</code>.</p>\n+     *\n+     * @return Collection of required options\n+     */\n+    public Collection getRequiredOptions() {\n+        return requiredOpts.values();\n     }\n     \n     /** <p>Retrieve the named {@link Option}</p>\n         else {\n             return (Option) shortOpts.get( opt );\n         }\n+    }\n+\n+    /** <p>Returns the OptionGroup the <code>opt</code>\n+     * belongs to.</p>\n+     * @param opt the option whose OptionGroup is being queried.\n+     *\n+     * @return the OptionGroup if <code>opt</code> is part\n+     * of an OptionGroup, otherwise return null\n+     */\n+    public OptionGroup getOptionGroup( Option opt ) {\n+        return (OptionGroup)optionGroups.get( opt );\n     }\n     \n     /** <p>Dump state, suitable for debugging.</p>\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.2 2002/06/19 21:31:16 jkeyes Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/19 21:31:16 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.3 2002/07/04 22:32:12 jkeyes Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/07/04 22:32:12 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.cli;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.ListIterator;\n import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n \n /**\n  * PosixParser parses the command line arguments using the Posix style.\n  */\n public class PosixParser implements CommandLineParser {\n \n+    /** current options instance */\n+    private Options options;\n+\n+    /** convience member for the command line */\n+    private CommandLine cmd;\n+\n+    /** required options subset of options */\n+    private Collection requiredOptions;\n+\n     /**\n      * Parse the arguments according to the specified options.\n+     *\n      * @param options the specified Options\n      * @param arguments the command line arguments\n      * @return the list of atomic option and value tokens\n-     */\n-    public List parse( Options options, List arguments ) {\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse( Options options, String[] arguments ) \n+    throws ParseException\n+    {\n         return parse( options, arguments, false );\n     }\n \n     /**\n      * Parse the arguments according to the specified options.\n-     * @param options the specified Options\n+     *\n+     * @param opts the specified Options\n      * @param arguments the command line arguments\n      * @param stopAtNonOption specifies whether to continue parsing the\n      * arguments if a non option is encountered.\n-     * @return the list of atomic option and value tokens\n-     */\n-    public List parse( Options options, List arguments, boolean stopAtNonOption ) {\n-        List args = new LinkedList();\n+     * @return the CommandLine\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse( Options opts, String[] arguments, boolean stopAtNonOption ) \n+    throws ParseException\n+    {\n+        // set the member instances\n+        options = opts;\n+        cmd = new CommandLine();\n+        requiredOptions = options.getRequiredOptions();\n+\n+        // an iterator for the command line tokens\n+        ListIterator iter = Arrays.asList( arguments ).listIterator();\n+        String token = null;\n         \n-        Iterator argIter = arguments.iterator();\n-        String   eachArg = null;\n-        \n+        // flag to indicate whether the remainder of the tokens should\n+        // be added to the other arguments list\n         boolean eatTheRest = false;\n         \n-        while ( argIter.hasNext() ) {\n-            eachArg = (String) argIter.next();\n+        // process each command line token\n+        while ( iter.hasNext() ) {\n+            // get the next command line token\n+            token = (String) iter.next();\n             \n-            if ( eachArg.equals(\"--\") ) {\n-                // Look for -- to indicate end-of-options, and\n-                // just stuff it, along with everything past it\n-                // into the returned list.\n-                \n-                args.add( eachArg );\n+            // Look for -- to indicate end-of-options, and\n+            // just stuff it, along with everything past it\n+            // into the returned list.\n+            if ( token.equals(\"--\") ) {\n                 eatTheRest = true;\n             }\n-            else if ( eachArg.startsWith(\"--\") ) {\n-                // It's a long-option, so doesn't need any\n-                // bursting applied to it.\n-                \n-                args.add( eachArg );\n-            }\n-            else if ( eachArg.startsWith(\"-\") ) {\n-                // It might be a short arg needing\n-                // some bursting\n-                \n-                if ( eachArg.length() == 1) {\n-                    // It's not really an option, so\n-                    // just drop it on the list\n-                    \n+            else if ( token.startsWith(\"--\") ) {\n+                // process the long-option\n+                processOption( token, iter );\n+            }\n+            else if ( token.startsWith(\"-\") ) {\n+                // it might be a short arg needing some bursting\n+                if ( token.length() == 1) {\n+                    // not an option, so just drop it on the argument list\n                     if ( stopAtNonOption ) {\n                         eatTheRest = true;\n                     }\n                     else {\n-                        args.add( eachArg );\n+                        cmd.addArg( token );\n                     }\n                 }\n-                else if ( eachArg.length() == 2 ) {\n-                    // No bursting required\n+                else if ( token.length() == 2 ) {\n+                    processOption( token, iter );\n+                }\n+                else {\n+                    // Needs bursting.  Figure out if we have multiple \n+                    // options, or maybe an option plus an arg, or some \n+                    // combination thereof.\n                     \n-                    args.add( eachArg );\n-                }\n-                else {\n-                    // Needs bursting.  Figure out\n-                    // if we have multiple options,\n-                    // or maybe an option plus an arg,\n-                    // or some combination thereof.\n-                    \n-                    for ( int i = 1 ; i < eachArg.length() ; ++i ) {\n-                        String optStr = \"-\" + eachArg.charAt(i);\n-                        Option opt    = (Option) options.getOption( String.valueOf( eachArg.charAt(i) ) );\n+                    // iterate over each character in the token\n+                    for ( int i = 1 ; i < token.length() ; ++i ) {\n+\n+                        // retrieve the associated option\n+                        Option opt = (Option) options.getOption( \n+                            String.valueOf( token.charAt(i) ) );\n                         \n-                        if ( (opt != null) && (opt.hasArg()) ) {\n-                            // If the current option has an argument,\n-                            // then consider the rest of the eachArg\n-                            // to be that argument.\n-                            \n-                            args.add( optStr );\n-                            \n-                            if ( (i+1) < eachArg.length() ) {\n-                                String optArg = eachArg.substring(i+1);\n-                                args.add( optArg );\n-                            }                            \n-                            break;\n+                        // if there is an associated option\n+                        if ( opt != null ) {\n+\n+                            // if the option requires an argument value\n+                            if ( opt.hasArg() ) {\n+                                // consider the rest of the token\n+                                // to be the argument value\n+\n+                                // if there is no argument value\n+                                if( token.substring(i+1).length() == 0 ) {\n+                                    throw new MissingArgumentException( \"Missing argument value for \" + opt.getOpt() );\n+                                }\n+\n+                                // add the argument value\n+                                opt.addValue( token.substring(i+1) );\n+\n+                                // if the option takes multiple values\n+                                if  (opt.hasMultipleArgs() ) {\n+                                    processMultipleArgs( opt, iter );\n+                                }\n+                                // set the option \n+                                cmd.setOpt( opt );\n+\n+                                // don't process any more characters\n+                                break;\n+                            }\n+\n+                            // if the option does not require an argument\n+                            cmd.setOpt( opt );\n                         }\n+                        // this is an unrecognized option\n                         else {\n-                            // No argument, so prepend the single dash,\n-                            // and then drop it into the arglist.\n-                            \n-                            args.add( optStr );\n+                            throw new UnrecognizedOptionException( String.valueOf( token.charAt(i) ) );\n                         }\n                     }\n                 }\n             }\n             else {\n-                // It's just a normal non-option arg,\n-                // so dump it into the list of returned\n-                // values.\n-                \n-                args.add( eachArg );\n+                // It's just a normal non-option arg, so dump it into the \n+                // list of returned values.\n+                cmd.addArg( token );\n                 \n                 if ( stopAtNonOption ) {\n                     eatTheRest = true;\n                 }\n             }\n             \n+            // add all unprocessed tokens to the arg list\n             if ( eatTheRest ) {\n-                while ( argIter.hasNext() ) {\n-                    args.add( argIter.next() );\n+                while ( iter.hasNext() ) {\n+                    cmd.addArg( (String)iter.next() );\n                 }\n             }\n         }\n         \n-        return args;\n+        // see if all required options have been processed\n+        checkRequiredOptions( );\n+\n+        // return the CommandLine instance\n+        return cmd;\n+    }\n+\n+    /**\n+     * Process the option represented by <code>arg</code>.\n+     * \n+     * @param arg the string representation of an option\n+     * @param iter the command line token iterator\n+     */\n+    private void processOption( String arg, ListIterator iter ) \n+    throws ParseException\n+    {\n+        // get the option represented by arg\n+        Option opt = (Option) options.getOption( arg );\n+\n+        // if there is no option throw an UnrecognisedOptionException\n+        if( opt == null ) {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n+        }\n+\n+        // if the option is a required option remove the option from\n+        // the requiredOptions list\n+        if ( opt.isRequired() ) {\n+            requiredOptions.remove( opt );\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected\n+        // option of the group\n+        if ( options.getOptionGroup( opt ) != null ) {\n+            ( (OptionGroup)( options.getOptionGroup( opt ) ) ).setSelected( opt );\n+        }\n+\n+        // if the option takes an argument value\n+        if ( opt.hasArg() ) {\n+            if  (opt.hasMultipleArgs() ) {\n+                processMultipleArgs( opt, iter );\n+            }\n+            else {\n+                opt.addValue( (String)iter.next() );\n+            }\n+        }\n+\n+        // set the option on the command line\n+        cmd.setOpt( opt );\n+    }\n+\n+    /**\n+     * It the option can accept multiple argument values then\n+     * keep adding values until the next option token is encountered.\n+     *\n+     * @param opt the specified option\n+     * @param iter the iterator over the command line tokens\n+     */\n+    public void processMultipleArgs( Option opt, ListIterator iter ) {\n+        // loop until an option is found\n+        while( iter.hasNext() ) {\n+            String var = (String)iter.next();\n+\n+            // its an option\n+            if( var.startsWith( \"-\" ) ) {\n+                // set the iterator pointer back a position\n+                iter.previous();\n+                break;\n+            }\n+            // its a value\n+            else {\n+                opt.addValue( var );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Ensures that all required options are present.\n+     *\n+     * @throws ParseException if all of the required options\n+     * are not present.\n+     */\n+    private void checkRequiredOptions( ) \n+    throws ParseException {\n+\n+        // if there are required options that have not been\n+        // processsed\n+        if( requiredOptions.size() > 0 ) {\n+            Iterator iter = requiredOptions.iterator();\n+            StringBuffer buff = new StringBuffer();\n+\n+            // loop through the required options\n+            while( iter.hasNext() ) {\n+                Option missing = (Option)iter.next();\n+                buff.append( \"-\" );\n+                buff.append( missing.getOpt() );\n+                buff.append( \" \" );\n+                buff.append( missing.getDescription() );\n+            }\n+\n+            // throw the MissingOptionException\n+            throw new MissingOptionException( buff.toString() );\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/cli/ApplicationTest.java\n+++ b/src/test/org/apache/commons/cli/ApplicationTest.java\n         System.setProperty( \"org.apache.commons.cli.parser\",\n                             \"org.apache.commons.cli.GnuParser\");\n \n+        CommandLineParser parser = CommandLineParserFactory.newParser();\n         Options options = new Options();\n         options.addOption( \"help\", false, \"print this message\" );\n         options.addOption( \"projecthelp\", false, \"print project help information\" );\n             \"-projecthelp\" };\n \n         try {\n-            CommandLine line = options.parse( args );\n+            CommandLine line = parser.parse( options, args );\n \n             // check multiple values\n             String[] opts = line.getOptionValues( \"D\" );\n--- a/src/test/org/apache/commons/cli/BuildTest.java\n+++ b/src/test/org/apache/commons/cli/BuildTest.java\n         opts.addOption(\"b\",\n                        true,\n                        \"toggle -b\");\n-/*\n-        try\n-        {\n-            opts.addOption('a',\n-                           false,\n-                           \"toggle -a\");\n-            \n-            opts.addOption('b',\n-                           true,\n-                           \"toggle -b\");\n-        }\n-        catch (DuplicateOptionException e)\n-        {\n-            fail(e.toString());\n-        }\n-*/\n     }\n \n     public void testDuplicateSimple()\n                        \"toggle -a*\");\n         \n         assertEquals( \"last one in wins\", \"toggle -a*\", opts.getOption(\"a\").getDescription() );\n-/*\n-        try\n-        {\n-            opts.addOption('a',\n-                           false,\n-                           \"toggle -a\");\n-            \n-            opts.addOption('a',\n-                           true,\n-                           \"toggle -a\");\n-\n-            fail(\"Should've thrown DuplicateOptionException\");\n-        }\n-        catch (DuplicateOptionException e)\n-        {\n-        }\n- */\n     }\n \n     public void testLong()\n                        true,\n                        \"set -b\");\n \n-/*        \n-        try\n-        {\n-            opts.addOption('a',\n-                           \"--a\",\n-                           false,\n-                           \"toggle -a\");\n-\n-            opts.addOption('b',\n-                           \"--b\",\n-                           true,\n-                           \"set -b\");\n-        }\n-        catch (DuplicateOptionException e)\n-        {\n-            fail(e.toString());\n-        }\n-*/\n     }\n \n     public void testDuplicateLong()\n                        false,\n                        \"toggle -a*\");\n         assertEquals( \"last one in wins\", \"toggle -a*\", opts.getOption(\"a\").getDescription() );\n-/*\n-        try\n-        {\n-            opts.addOption('a',\n-                           \"--a\",\n-                           false,\n-                           \"toggle -a\");\n-\n-            opts.addOption('a',\n-                           \"--a\",\n-                           false,\n-                           \"toggle -a\");\n-\n-            fail(\"Should've thrown DuplicateOptionException\");\n-        }\n-        catch (DuplicateOptionException e)\n-        {\n-        }\n-*/\n     }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/GnuParseTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: GnuParseTest.java,v 1.1 2002/07/04 22:32:12 jkeyes Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class GnuParseTest extends TestCase\n+{\n+    private Options _options = null;\n+    private CommandLineParser _parser = null;\n+\n+    public static Test suite() { \n+        return new TestSuite( GnuParseTest.class ); \n+    }\n+\n+    public GnuParseTest( String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void setUp()\n+    {\n+        System.setProperty( \"org.apache.commons.cli.parser\",\n+                            \"org.apache.commons.cli.GnuParser\");\n+\n+        _options = new Options()\n+            .addOption(\"a\",\n+                       \"enable-a\",\n+                       false,\n+                       \"turn [a] on or off\")\n+            .addOption(\"b\",\n+                       \"bfile\",\n+                       true,\n+                       \"set the value of [b]\")\n+            .addOption(\"c\",\n+                       \"copt\",\n+                       false,\n+                       \"turn [c] on or off\");\n+\n+        _parser = CommandLineParserFactory.newParser();\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testSimpleShort()\n+    {\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSimpleLong()\n+    {\n+        String[] args = new String[] { \"--enable-a\",\n+                                       \"--bfile\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+        } \n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testExtraOption()\n+    {\n+        String[] args = new String[] { \"-a\", \"-d\", \"-b\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 3);\n+        }\n+        catch (UnrecognizedOptionException e)\n+        {\n+            caught = true;\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+        assertTrue( \"Confirm UnrecognizedOptionException caught\", caught );\n+    }\n+\n+    public void testMissingArg()\n+    {\n+\n+        String[] args = new String[] { \"-b\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+        }\n+        catch (MissingArgumentException e)\n+        {\n+            caught = true;\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+\n+        assertTrue( \"Confirm MissingArgumentException caught\", caught );\n+    }\n+\n+    public void testStop()\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foober\",\n+                                       \"-b\",\n+                                       \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args, true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testMultiple()\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foobar\",\n+                                       \"-b\",\n+                                       \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args, true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+\n+            cl = _parser.parse(_options, cl.getArgs() );\n+\n+            assertTrue( \"Confirm -c is not set\", ! cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+            assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testMultipleWithLong()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"foobar\",\n+                                       \"--bfile\", \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options,args,\n+                                            true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+\n+            cl = _parser.parse(_options, cl.getArgs() );\n+\n+            assertTrue( \"Confirm -c is not set\", ! cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+            assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testDoubleDash()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"--\",\n+                                       \"-b\", \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+\n+            assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n+            assertTrue( \"Confirm -b is not set\", ! cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm 2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSingleDash()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"-b\", \"-\",\n+                                       \"-a\",\n+                                       \"-\" };\n+\n+        try\n+        {\n+            CommandLine cl = _parser.parse(_options, args);\n+\n+            assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"-\") );\n+            assertTrue( \"Confirm 1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"-\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+        \n+    }\n+}\n--- a/src/test/org/apache/commons/cli/OptionGroupTest.java\n+++ b/src/test/org/apache/commons/cli/OptionGroupTest.java\n {\n \n     private Options _options = null;\n+    private CommandLineParser parser = CommandLineParserFactory.newParser();\n+\n \n     public static Test suite() \n     { \n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is NOT set\", !cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n \n             assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is NOT set\", !cl.hasOption(\"f\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n             fail( \"two arguments from group not allowed\" );\n         }\n         catch (ParseException e)\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n             fail( \"two arguments from group not allowed\" );\n         }\n         catch (ParseException e)\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse( _options, args);\n             assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n             assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n             assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n--- a/src/test/org/apache/commons/cli/ParseRequiredTest.java\n+++ b/src/test/org/apache/commons/cli/ParseRequiredTest.java\n {\n \n     private Options _options = null;\n+    private CommandLineParser parser = CommandLineParserFactory.newParser();\n \n     public static Test suite() { \n         return new TestSuite(ParseRequiredTest.class); \n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse(_options,args);\n             \n             assertTrue( \"Confirm -a is NOT set\", !cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse(_options,args);\n \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = parser.parse(_options,args);\n             fail( \"exception should have been thrown\" );\n         }\n         catch (ParseException e)\n--- a/src/test/org/apache/commons/cli/ParseTest.java\n+++ b/src/test/org/apache/commons/cli/ParseTest.java\n {\n \n     private Options _options = null;\n+    private CommandLineParser _parser = null;\n \n     public static Test suite() { \n         return new TestSuite(ParseTest.class); \n \n     public void setUp()\n     {\n+        System.setProperty( \"org.apache.commons.cli.parser\",\n+                            \"org.apache.commons.cli.PosixParser\");\n+\n         _options = new Options()\n             .addOption(\"a\",\n                        \"enable-a\",\n                        \"copt\",\n                        false,\n                        \"turn [c] on or off\");\n-/*        \n-        try\n-        {\n-            _options\n-                .addOption('a',\n-                           \"enable-a\",\n-                           false,\n-                           \"turn [a] on or off\")\n-                .addOption('b',\n-                           \"bfile\",\n-                           true,\n-                           \"set the value of [b]\")\n-                .addOption('c',\n-                           \"copt\",\n-                           false,\n-                           \"turn [c] on or off\");\n-            \n-        }\n-        catch (CLIException e)\n-        {\n-            e.printStackTrace();\n-        }\n-*/\n+\n+        _parser = CommandLineParserFactory.newParser();\n     }\n \n     public void tearDown()\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n             \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n             \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n             \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n             \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n         }\n         catch (MissingArgumentException e)\n         {\n \n         try\n         {\n-            CommandLine cl = _options.parse(args,\n-                                            true);\n+            CommandLine cl = _parser.parse(_options, args, true);\n             assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n             assertTrue( \"Confirm  2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n         }\n \n         try\n         {\n-            CommandLine cl = _options.parse(args,\n-                                            true);\n+            CommandLine cl = _parser.parse(_options, args, true);\n             assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n             assertTrue( \"Confirm  2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n \n-            cl = _options.parse( cl.getArgList() );\n+            cl = _parser.parse(_options, cl.getArgs() );\n \n             assertTrue( \"Confirm -c is not set\", ! cl.hasOption(\"c\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args,\n+            CommandLine cl = _parser.parse(_options,args,\n                                             true);\n             assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n             assertTrue( \"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n \n-            cl = _options.parse( cl.getArgList() );\n+            cl = _parser.parse(_options, cl.getArgs() );\n \n             assertTrue( \"Confirm -c is not set\", ! cl.hasOption(\"c\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n \n             assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n             assertTrue( \"Confirm -b is not set\", ! cl.hasOption(\"b\") );\n \n         try\n         {\n-            CommandLine cl = _options.parse(args);\n+            CommandLine cl = _parser.parse(_options, args);\n \n             assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n             assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n         }\n         \n     }\n-\n }\n--- a/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n+++ b/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n       Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\n       String[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\n       \n-      CommandLine line = options.parse(args);\n+      CommandLineParser parser = CommandLineParserFactory.newParser();\n+      CommandLine line = parser.parse(options,args);\n       assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n       assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n       assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject(\"b\"));\n--- a/src/test/org/apache/commons/cli/ValueTest.java\n+++ b/src/test/org/apache/commons/cli/ValueTest.java\n                        true,\n                        \"set -d\");\n \n-/*            \n-        try\n-        {\n-            opts.addOption('a',\n-                           false,\n-                           \"toggle -a\");\n-            \n-            opts.addOption('b',\n-                           true,\n-                           \"set -b\");\n-            \n-            opts.addOption('c',\n-                           \"c\",\n-                           false,\n-                           \"toggle -c\");\n-            \n-            opts.addOption('d',\n-                           \"d\",\n-                           true,\n-                           \"set -d\");\n-        }\n-        catch (DuplicateOptionException e)\n-        {\n-            fail(\"Cannot setUp() Options: \" + e.toString());\n-        }\n-*/\n-\n         String[] args = new String[] { \"-a\",\n                                        \"-b\", \"foo\",\n                                        \"--c\",\n \n         try\n         {\n-            _cl = opts.parse(args);\n+            CommandLineParser parser = CommandLineParserFactory.newParser();\n+            _cl = parser.parse(opts,args);\n         }\n         catch (ParseException e)\n         {\n--- a/src/test/org/apache/commons/cli/ValuesTest.java\n+++ b/src/test/org/apache/commons/cli/ValuesTest.java\n                                        \"-f\",\n                                        \"arg1\", \"arg2\" };\n \n+        CommandLineParser parser = CommandLineParserFactory.newParser();\n+\n         try\n         {\n-            _cl = opts.parse(args);\n+            _cl = parser.parse(opts,args);\n         }\n         catch (ParseException e)\n         {", "timestamp": 1025821933, "metainfo": ""}