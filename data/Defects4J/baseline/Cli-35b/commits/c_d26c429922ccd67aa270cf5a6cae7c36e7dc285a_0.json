{"sha": "d26c429922ccd67aa270cf5a6cae7c36e7dc285a", "log": "Moving the 1.x branch in as the trunk for Commons CLI  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/AlreadySelectedException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Thrown when more than one option in an option group\n+ * has been provided.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class AlreadySelectedException extends ParseException\n+{\n+    /** The option group selected. */\n+    private OptionGroup group;\n+\n+    /** The option that triggered the exception. */\n+    private Option option;\n+\n+    /**\n+     * Construct a new <code>AlreadySelectedException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public AlreadySelectedException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>AlreadySelectedException</code>\n+     * for the specified option group.\n+     *\n+     * @param group  the option group already selected\n+     * @param option the option that triggered the exception\n+     * @since 1.2\n+     */\n+    public AlreadySelectedException(OptionGroup group, Option option)\n+    {\n+        this(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+                + \"has already been selected: '\" + group.getSelected() + \"'\");\n+        this.group = group;\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Returns the option group where another option has been selected.\n+     *\n+     * @return the related option group\n+     * @since 1.2\n+     */\n+    public OptionGroup getOptionGroup()\n+    {\n+        return group;\n+    }\n+\n+    /**\n+     * Returns the option that was added to the group and triggered the exception.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public Option getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/BasicParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * The class BasicParser provides a very simple implementation of\n+ * the {@link Parser#flatten(Options,String[],boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class BasicParser extends Parser\n+{\n+    /**\n+     * <p>A simple implementation of {@link Parser}'s abstract\n+     * {@link Parser#flatten(Options, String[], boolean) flatten} method.</p>\n+     *\n+     * <p><b>Note:</b> <code>options</code> and <code>stopAtNonOption</code>\n+     * are not used in this <code>flatten</code> method.</p>\n+     *\n+     * @param options The command line {@link Options}\n+     * @param arguments The command line arguments to be parsed\n+     * @param stopAtNonOption Specifies whether to stop flattening\n+     * when an non option is found.\n+     * @return The <code>arguments</code> String array.\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n+    {\n+        // just echo the arguments\n+        return arguments;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Properties;\n+\n+/**\n+ * Represents list of arguments parsed against a {@link Options} descriptor.\n+ *\n+ * <p>It allows querying of a boolean {@link #hasOption(String opt)},\n+ * in addition to retrieving the {@link #getOptionValue(String opt)}\n+ * for options requiring arguments.</p>\n+ *\n+ * <p>Additionally, any left-over or unrecognized arguments,\n+ * are available for further processing.</p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class CommandLine implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** the unrecognised options/arguments */\n+    private List args = new LinkedList();\n+\n+    /** the processed options */\n+    private List options = new ArrayList();\n+\n+    /**\n+     * Creates a command line.\n+     */\n+    CommandLine()\n+    {\n+        // nothing to do\n+    }\n+\n+    /** \n+     * Query to see if an option has been set.\n+     *\n+     * @param opt Short name of the option\n+     * @return true if set, false if not\n+     */\n+    public boolean hasOption(String opt)\n+    {\n+        return options.contains(resolveOption(opt));\n+    }\n+\n+    /** \n+     * Query to see if an option has been set.\n+     *\n+     * @param opt character name of the option\n+     * @return true if set, false if not\n+     */\n+    public boolean hasOption(char opt)\n+    {\n+        return hasOption(String.valueOf(opt));\n+    }\n+\n+    /**\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n+     *\n+     * @param opt the name of the option\n+     * @return the type of this <code>Option</code>\n+     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n+     */\n+    public Object getOptionObject(String opt)\n+    {\n+        try {\n+            return getParsedOptionValue(opt);\n+        } catch(ParseException pe) {\n+            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + \n+                pe.getMessage() );\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Return a version of this <code>Option</code> converted to a particular type. \n+     *\n+     * @param opt the name of the option\n+     * @return the value parsed into a particluar object\n+     * @throws ParseException if there are problems turning the option value into the desired type\n+     * @see PatternOptionBuilder\n+     */\n+    public Object getParsedOptionValue(String opt)\n+    throws ParseException\n+    {\n+        String res = getOptionValue(opt);\n+\n+        Option option = resolveOption(opt);\n+        if (option == null)\n+        {\n+            return null;\n+        }\n+\n+        Object type = option.getType();\n+\n+        return (res == null)        ? null : TypeHandler.createValue(res, type);\n+    }\n+\n+    /**\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n+     *\n+     * @param opt the name of the option\n+     * @return the type of opt\n+     */\n+    public Object getOptionObject(char opt)\n+    {\n+        return getOptionObject(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of this option.\n+     *\n+     * @param opt the name of the option\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String getOptionValue(String opt)\n+    {\n+        String[] values = getOptionValues(opt);\n+\n+        return (values == null) ? null : values[0];\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of this option.\n+     *\n+     * @param opt the character name of the option\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String getOptionValue(char opt)\n+    {\n+        return getOptionValue(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieves the array of values, if any, of an option.\n+     *\n+     * @param opt string name of the option\n+     * @return Values of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String[] getOptionValues(String opt)\n+    {\n+        List values = new ArrayList();\n+\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n+            {\n+                values.addAll(option.getValuesList());\n+            }\n+        }\n+\n+        return values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n+    }\n+\n+    /**\n+     * Retrieves the option object given the long or short option as a String\n+     * \n+     * @param opt short or long name of the option\n+     * @return Canonicalized option\n+     */\n+    private Option resolveOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+            if (opt.equals(option.getOpt()))\n+            {\n+                return option;\n+            }\n+\n+            if (opt.equals(option.getLongOpt()))\n+            {\n+                return option;\n+            }\n+\n+        }\n+        return null;\n+    }\n+\n+    /** \n+     * Retrieves the array of values, if any, of an option.\n+     *\n+     * @param opt character name of the option\n+     * @return Values of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String[] getOptionValues(char opt)\n+    {\n+        return getOptionValues(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of an option.\n+     *\n+     * @param opt name of the option\n+     * @param defaultValue is the default value to be returned if the option\n+     * is not specified\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise <code>defaultValue</code>.\n+     */\n+    public String getOptionValue(String opt, String defaultValue)\n+    {\n+        String answer = getOptionValue(opt);\n+\n+        return (answer != null) ? answer : defaultValue;\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of an option.\n+     *\n+     * @param opt character name of the option\n+     * @param defaultValue is the default value to be returned if the option\n+     * is not specified\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise <code>defaultValue</code>.\n+     */\n+    public String getOptionValue(char opt, String defaultValue)\n+    {\n+        return getOptionValue(String.valueOf(opt), defaultValue);\n+    }\n+\n+    /**\n+     * Retrieve the map of values associated to the option. This is convenient\n+     * for options specifying Java properties like <tt>-Dparam1=value1\n+     * -Dparam2=value2</tt>. The first argument of the option is the key, and\n+     * the 2nd argument is the value. If the option has only one argument\n+     * (<tt>-Dfoo</tt>) it is considered as a boolean flag and the value is\n+     * <tt>\"true\"</tt>.\n+     *\n+     * @param opt name of the option\n+     * @return The Properties mapped by the option, never <tt>null</tt>\n+     *         even if the option doesn't exists\n+     * @since 1.2\n+     */\n+    public Properties getOptionProperties(String opt)\n+    {\n+        Properties props = new Properties();\n+\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+\n+            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n+            {\n+                List values = option.getValuesList();\n+                if (values.size() >= 2)\n+                {\n+                    // use the first 2 arguments as the key/value pair\n+                    props.put(values.get(0), values.get(1));\n+                }\n+                else if (values.size() == 1)\n+                {\n+                    // no explicit value, handle it as a boolean\n+                    props.put(values.get(0), \"true\");\n+                }\n+            }\n+        }\n+\n+        return props;\n+    }\n+\n+    /** \n+     * Retrieve any left-over non-recognized options and arguments\n+     *\n+     * @return remaining items passed in but not parsed as an array\n+     */\n+    public String[] getArgs()\n+    {\n+        String[] answer = new String[args.size()];\n+\n+        args.toArray(answer);\n+\n+        return answer;\n+    }\n+\n+    /** \n+     * Retrieve any left-over non-recognized options and arguments\n+     *\n+     * @return remaining items passed in but not parsed as a <code>List</code>.\n+     */\n+    public List getArgList()\n+    {\n+        return args;\n+    }\n+\n+    /** \n+     * jkeyes\n+     * - commented out until it is implemented properly\n+     * <p>Dump state, suitable for debugging.</p>\n+     *\n+     * @return Stringified form of this object\n+     */\n+\n+    /*\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+            \n+        buf.append(\"[ CommandLine: [ options: \");\n+        buf.append(options.toString());\n+        buf.append(\" ] [ args: \");\n+        buf.append(args.toString());\n+        buf.append(\" ] ]\");\n+            \n+        return buf.toString();\n+    }\n+    */\n+\n+    /**\n+     * Add left-over unrecognized option/argument.\n+     *\n+     * @param arg the unrecognised option/argument.\n+     */\n+    void addArg(String arg)\n+    {\n+        args.add(arg);\n+    }\n+\n+    /**\n+     * Add an option to the command line.  The values of the option are stored.\n+     *\n+     * @param opt the processed option\n+     */\n+    void addOption(Option opt)\n+    {\n+        options.add(opt);\n+    }\n+\n+    /**\n+     * Returns an iterator over the Option members of CommandLine.\n+     *\n+     * @return an <code>Iterator</code> over the processed {@link Option}\n+     * members of this {@link CommandLine}\n+     */\n+    public Iterator iterator()\n+    {\n+        return options.iterator();\n+    }\n+\n+    /**\n+     * Returns an array of the processed {@link Option}s.\n+     *\n+     * @return an array of the processed {@link Option}s.\n+     */\n+    public Option[] getOptions()\n+    {\n+        Collection processed = options;\n+\n+        // reinitialise array\n+        Option[] optionsArray = new Option[processed.size()];\n+\n+        // return the array\n+        return (Option[]) processed.toArray(optionsArray);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/CommandLineParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * A class that implements the <code>CommandLineParser</code> interface\n+ * can parse a String array according to the {@link Options} specified\n+ * and return a {@link CommandLine}.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public interface CommandLineParser\n+{\n+    /**\n+     * Parse the arguments according to the specified options.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    CommandLine parse(Options options, String[] arguments) throws ParseException;\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties)\n+               throws ParseException;\n+     */\n+\n+    /**\n+     * Parse the arguments according to the specified options.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param stopAtNonOption specifies whether to continue parsing the\n+     * arguments if a non option is encountered.\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @param stopAtNonOption specifies whether to continue parsing the\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException;\n+     */\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The class GnuParser provides an implementation of the\n+ * {@link Parser#flatten(Options, String[], boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class GnuParser extends Parser\n+{\n+    /**\n+     * This flatten method does so using the following rules:\n+     * <ol>\n+     *   <li>If an {@link Option} exists for the first character of\n+     *   the <code>arguments</code> entry <b>AND</b> an {@link Option}\n+     *   does not exist for the whole <code>argument</code> then\n+     *   add the first character as an option to the processed tokens\n+     *   list e.g. \"-D\" and add the rest of the entry to the also.</li>\n+     *   <li>Otherwise just add the token to the processed tokens list.</li>\n+     * </ol>\n+     *\n+     * @param options         The Options to parse the arguments by.\n+     * @param arguments       The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop flattening when\n+     *                        a non option has been encountered\n+     * @return a String array of the flattened arguments\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n+    {\n+        List tokens = new ArrayList();\n+\n+        boolean eatTheRest = false;\n+\n+        for (int i = 0; i < arguments.length; i++)\n+        {\n+            String arg = arguments[i];\n+\n+            if (\"--\".equals(arg))\n+            {\n+                eatTheRest = true;\n+                tokens.add(\"--\");\n+            }\n+            else if (\"-\".equals(arg))\n+            {\n+                tokens.add(\"-\");\n+            }\n+            else if (arg.startsWith(\"-\"))\n+            {\n+                String opt = Util.stripLeadingHyphens(arg);\n+\n+                if (options.hasOption(opt))\n+                {\n+                    tokens.add(arg);\n+                }\n+                else\n+                {\n+                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n+                    {\n+                        // the format is --foo=value or -foo=value\n+                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n+                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n+                    }\n+                    else if (options.hasOption(arg.substring(0, 2)))\n+                    {\n+                        // the format is a special properties option (-Dproperty=value)\n+                        tokens.add(arg.substring(0, 2)); // -D\n+                        tokens.add(arg.substring(2)); // property=value\n+                    }\n+                    else\n+                    {\n+                        eatTheRest = stopAtNonOption;\n+                        tokens.add(arg);\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                tokens.add(arg);\n+            }\n+\n+            if (eatTheRest)\n+            {\n+                for (i++; i < arguments.length; i++)\n+                {\n+                    tokens.add(arguments[i]);\n+                }\n+            }\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/** \n+ * A formatter of help messages for the current command line options\n+ *\n+ * @author Slawek Zachcial\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class HelpFormatter\n+{\n+    // --------------------------------------------------------------- Constants\n+\n+    /** default number of characters per line */\n+    public static final int DEFAULT_WIDTH = 74;\n+\n+    /** default padding to the left of each line */\n+    public static final int DEFAULT_LEFT_PAD = 1;\n+\n+    /**\n+     * the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public static final int DEFAULT_DESC_PAD = 3;\n+\n+    /** the string to display at the beginning of the usage statement */\n+    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n+\n+    /** default prefix for shortOpts */\n+    public static final String DEFAULT_OPT_PREFIX = \"-\";\n+\n+    /** default prefix for long Option */\n+    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n+\n+    /** default name for an argument */\n+    public static final String DEFAULT_ARG_NAME = \"arg\";\n+\n+    // -------------------------------------------------------------- Attributes\n+\n+    /**\n+     * number of characters per line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setWidth methods instead.\n+     */\n+    public int defaultWidth = DEFAULT_WIDTH;\n+\n+    /**\n+     * amount of padding to the left of each line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setLeftPadding methods instead.\n+     */\n+    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n+\n+    /**\n+     * the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setDescPadding methods instead.\n+     */\n+    public int defaultDescPad = DEFAULT_DESC_PAD;\n+\n+    /**\n+     * the string to display at the begining of the usage statement\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setSyntaxPrefix methods instead.\n+     */\n+    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n+\n+    /**\n+     * the new line string\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setNewLine methods instead.\n+     */\n+    public String defaultNewLine = System.getProperty(\"line.separator\");\n+\n+    /**\n+     * the shortOpt prefix\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setOptPrefix methods instead.\n+     */\n+    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n+\n+    /**\n+     * the long Opt prefix\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setLongOptPrefix methods instead.\n+     */\n+    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n+\n+    /**\n+     * the name of the argument\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setArgName methods instead.\n+     */\n+    public String defaultArgName = DEFAULT_ARG_NAME;\n+\n+    /**\n+     * Comparator used to sort the options when they output in help text\n+     * \n+     * Defaults to case-insensitive alphabetical sorting by option key\n+     */\n+    protected Comparator optionComparator = new OptionComparator();\n+\n+    /**\n+     * Sets the 'width'.\n+     *\n+     * @param width the new value of 'width'\n+     */\n+    public void setWidth(int width)\n+    {\n+        this.defaultWidth = width;\n+    }\n+\n+    /**\n+     * Returns the 'width'.\n+     *\n+     * @return the 'width'\n+     */\n+    public int getWidth()\n+    {\n+        return defaultWidth;\n+    }\n+\n+    /**\n+     * Sets the 'leftPadding'.\n+     *\n+     * @param padding the new value of 'leftPadding'\n+     */\n+    public void setLeftPadding(int padding)\n+    {\n+        this.defaultLeftPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'leftPadding'.\n+     *\n+     * @return the 'leftPadding'\n+     */\n+    public int getLeftPadding()\n+    {\n+        return defaultLeftPad;\n+    }\n+\n+    /**\n+     * Sets the 'descPadding'.\n+     *\n+     * @param padding the new value of 'descPadding'\n+     */\n+    public void setDescPadding(int padding)\n+    {\n+        this.defaultDescPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'descPadding'.\n+     *\n+     * @return the 'descPadding'\n+     */\n+    public int getDescPadding()\n+    {\n+        return defaultDescPad;\n+    }\n+\n+    /**\n+     * Sets the 'syntaxPrefix'.\n+     *\n+     * @param prefix the new value of 'syntaxPrefix'\n+     */\n+    public void setSyntaxPrefix(String prefix)\n+    {\n+        this.defaultSyntaxPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'syntaxPrefix'.\n+     *\n+     * @return the 'syntaxPrefix'\n+     */\n+    public String getSyntaxPrefix()\n+    {\n+        return defaultSyntaxPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'newLine'.\n+     *\n+     * @param newline the new value of 'newLine'\n+     */\n+    public void setNewLine(String newline)\n+    {\n+        this.defaultNewLine = newline;\n+    }\n+\n+    /**\n+     * Returns the 'newLine'.\n+     *\n+     * @return the 'newLine'\n+     */\n+    public String getNewLine()\n+    {\n+        return defaultNewLine;\n+    }\n+\n+    /**\n+     * Sets the 'optPrefix'.\n+     *\n+     * @param prefix the new value of 'optPrefix'\n+     */\n+    public void setOptPrefix(String prefix)\n+    {\n+        this.defaultOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'optPrefix'.\n+     *\n+     * @return the 'optPrefix'\n+     */\n+    public String getOptPrefix()\n+    {\n+        return defaultOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'longOptPrefix'.\n+     *\n+     * @param prefix the new value of 'longOptPrefix'\n+     */\n+    public void setLongOptPrefix(String prefix)\n+    {\n+        this.defaultLongOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'longOptPrefix'.\n+     *\n+     * @return the 'longOptPrefix'\n+     */\n+    public String getLongOptPrefix()\n+    {\n+        return defaultLongOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'argName'.\n+     *\n+     * @param name the new value of 'argName'\n+     */\n+    public void setArgName(String name)\n+    {\n+        this.defaultArgName = name;\n+    }\n+\n+    /**\n+     * Returns the 'argName'.\n+     *\n+     * @return the 'argName'\n+     */\n+    public String getArgName()\n+    {\n+        return defaultArgName;\n+    }\n+\n+    /**\n+     * Comparator used to sort the options when they output in help text\n+     * \n+     * Defaults to case-insensitive alphabetical sorting by option key\n+     */\n+    public Comparator getOptionComparator()\n+    {\n+        return optionComparator;\n+    }\n+\n+    /**\n+     * Set the comparator used to sort the options when they output in help text\n+     * \n+     * Passing in a null parameter will set the ordering to the default mode\n+     */\n+    public void setOptionComparator(Comparator comparator)\n+    {\n+        if (comparator == null)\n+        {\n+            this.optionComparator = new OptionComparator();\n+        }\n+        else\n+        {\n+            this.optionComparator = comparator;\n+        }\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to \n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n+    {\n+        printHelp(cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to \n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the beginning of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n+    {\n+        printHelp(width, cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header,\n+                          Options options, String footer, boolean autoUsage)\n+    {\n+        PrintWriter pw = new PrintWriter(System.out);\n+\n+        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n+        pw.flush();\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     *\n+     * @throws IllegalStateException if there is no room to print a line\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer)\n+    {\n+        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n+    }\n+\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     *\n+     * @throws IllegalStateException if there is no room to print a line\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n+                          String header, Options options, int leftPad,\n+                          int descPad, String footer, boolean autoUsage)\n+    {\n+        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n+        {\n+            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n+        }\n+\n+        if (autoUsage)\n+        {\n+            printUsage(pw, width, cmdLineSyntax, options);\n+        }\n+        else\n+        {\n+            printUsage(pw, width, cmdLineSyntax);\n+        }\n+\n+        if ((header != null) && (header.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, header);\n+        }\n+\n+        printOptions(pw, width, options, leftPad, descPad);\n+\n+        if ((footer != null) && (footer.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, footer);\n+        }\n+    }\n+\n+    /**\n+     * <p>Prints the usage statement for the specified application.</p>\n+     *\n+     * @param pw The PrintWriter to print the usage statement \n+     * @param width The number of characters to display per line\n+     * @param app The application name\n+     * @param options The command line Options\n+     *\n+     */\n+    public void printUsage(PrintWriter pw, int width, String app, Options options)\n+    {\n+        // initialise the string buffer\n+        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n+\n+        // create a list for processed option groups\n+        final Collection processedGroups = new ArrayList();\n+\n+        // temp variable\n+        Option option;\n+\n+        List optList = new ArrayList(options.getOptions());\n+        Collections.sort(optList, getOptionComparator());\n+        // iterate over the options\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            // get the next Option\n+            option = (Option) i.next();\n+\n+            // check if the option is part of an OptionGroup\n+            OptionGroup group = options.getOptionGroup(option);\n+\n+            // if the option is part of a group \n+            if (group != null)\n+            {\n+                // and if the group has not already been processed\n+                if (!processedGroups.contains(group))\n+                {\n+                    // add the group to the processed list\n+                    processedGroups.add(group);\n+\n+\n+                    // add the usage clause\n+                    appendOptionGroup(buff, group);\n+                }\n+\n+                // otherwise the option was displayed in the group\n+                // previously so ignore it.\n+            }\n+\n+            // if the Option is not part of an OptionGroup\n+            else\n+            {\n+                appendOption(buff, option, option.isRequired());\n+            }\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" \");\n+            }\n+        }\n+\n+\n+        // call printWrapped\n+        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n+    }\n+\n+    /**\n+     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n+     * The clause is wrapped in square brackets if the group is required.\n+     * The display of the options is handled by appendOption\n+     * @param buff the StringBuffer to append to\n+     * @param group the group to append\n+     * @see #appendOption(StringBuffer,Option,boolean)\n+     */\n+    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n+    {\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        List optList = new ArrayList(group.getOptions());\n+        Collections.sort(optList, getOptionComparator());\n+        // for each option in the OptionGroup\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            // whether the option is required or not is handled at group level\n+            appendOption(buff, (Option) i.next(), true);\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" | \");\n+            }\n+        }\n+\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * Appends the usage clause for an Option to a StringBuffer.  \n+     *\n+     * @param buff the StringBuffer to append to\n+     * @param option the Option to append\n+     * @param required whether the Option is required or not\n+     */\n+    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n+    {\n+        if (!required)\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        if (option.getOpt() != null)\n+        {\n+            buff.append(\"-\").append(option.getOpt());\n+        }\n+        else\n+        {\n+            buff.append(\"--\").append(option.getLongOpt());\n+        }\n+\n+        // if the Option has a value\n+        if (option.hasArg() && option.hasArgName())\n+        {\n+            buff.append(\" <\").append(option.getArgName()).append(\">\");\n+        }\n+\n+        // if the Option is not a required option\n+        if (!required)\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * Print the cmdLineSyntax to the specified writer, using the\n+     * specified width.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters per line for the usage statement.\n+     * @param cmdLineSyntax The usage statement.\n+     */\n+    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n+    {\n+        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n+\n+        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n+    }\n+\n+    /**\n+     * <p>Print the help for the specified Options to the specified writer, \n+     * using the specified width, left padding and description padding.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public void printOptions(PrintWriter pw, int width, Options options, \n+                             int leftPad, int descPad)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+\n+        renderOptions(sb, width, options, leftPad, descPad);\n+        pw.println(sb.toString());\n+    }\n+\n+    /**\n+     * Print the specified text to the specified PrintWriter.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, String text)\n+    {\n+        printWrapped(pw, width, 0, text);\n+    }\n+\n+    /**\n+     * Print the specified text to the specified PrintWriter.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n+    {\n+        StringBuffer sb = new StringBuffer(text.length());\n+\n+        renderWrappedText(sb, width, nextLineTabStop, text);\n+        pw.println(sb.toString());\n+    }\n+\n+    // --------------------------------------------------------------- Protected\n+\n+    /**\n+     * Render the specified Options and return the rendered Options\n+     * in a StringBuffer.\n+     *\n+     * @param sb The StringBuffer to place the rendered Options into.\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n+    {\n+        final String lpad = createPadding(leftPad);\n+        final String dpad = createPadding(descPad);\n+\n+        // first create list containing only <lpad>-a,--aaa where \n+        // -a is opt and --aaa is long opt; in parallel look for \n+        // the longest opt string this list will be then used to \n+        // sort options ascending\n+        int max = 0;\n+        StringBuffer optBuf;\n+        List prefixList = new ArrayList();\n+\n+        List optList = options.helpOptions();\n+\n+        Collections.sort(optList, getOptionComparator());\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            Option option = (Option) i.next();\n+            optBuf = new StringBuffer(8);\n+\n+            if (option.getOpt() == null)\n+            {\n+                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n+            }\n+            else\n+            {\n+                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n+\n+                if (option.hasLongOpt())\n+                {\n+                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n+                }\n+            }\n+\n+            if (option.hasArg())\n+            {\n+                if (option.hasArgName())\n+                {\n+                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n+                }\n+                else\n+                {\n+                    optBuf.append(' ');\n+                }\n+            }\n+\n+            prefixList.add(optBuf);\n+            max = (optBuf.length() > max) ? optBuf.length() : max;\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            Option option = (Option) i.next();\n+            optBuf = new StringBuffer(prefixList.get(x++).toString());\n+\n+            if (optBuf.length() < max)\n+            {\n+                optBuf.append(createPadding(max - optBuf.length()));\n+            }\n+\n+            optBuf.append(dpad);\n+\n+            int nextLineTabStop = max + descPad;\n+\n+            if (option.getDescription() != null)\n+            {\n+                optBuf.append(option.getDescription());\n+            }\n+\n+            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n+\n+            if (i.hasNext())\n+            {\n+                sb.append(defaultNewLine);\n+            }\n+        }\n+\n+        return sb;\n+    }\n+\n+    /**\n+     * Render the specified text and return the rendered Options\n+     * in a StringBuffer.\n+     *\n+     * @param sb The StringBuffer to place the rendered text into.\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be rendered.\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n+                                             int nextLineTabStop, String text)\n+    {\n+        int pos = findWrapPos(text, width, 0);\n+\n+        if (pos == -1)\n+        {\n+            sb.append(rtrim(text));\n+\n+            return sb;\n+        }\n+        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+\n+        if (nextLineTabStop >= width)\n+        {\n+            // stops infinite loop happening\n+            nextLineTabStop = 1;\n+        }\n+\n+        // all following lines must be padded with nextLineTabStop space \n+        // characters\n+        final String padding = createPadding(nextLineTabStop);\n+\n+        while (true)\n+        {\n+            text = padding + text.substring(pos).trim();\n+            pos = findWrapPos(text, width, 0);\n+\n+            if (pos == -1)\n+            {\n+                sb.append(text);\n+\n+                return sb;\n+            }\n+            \n+            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n+            {\n+                pos = width;\n+            }\n+\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next text wrap position after <code>startPos</code> for the\n+     * text in <code>text</code> with the column width <code>width</code>.\n+     * The wrap point is the last postion before startPos+width having a \n+     * whitespace character (space, \\n, \\r).\n+     *\n+     * @param text The text being searched for the wrap position\n+     * @param width width of the wrapped text\n+     * @param startPos position from which to start the lookup whitespace\n+     * character\n+     * @return postion on which the text must be wrapped or -1 if the wrap\n+     * position is at the end of the text\n+     */\n+    protected int findWrapPos(String text, int width, int startPos)\n+    {\n+        int pos = -1;\n+\n+        // the line ends before the max wrap pos or a new line char found\n+        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n+                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n+        {\n+            return pos + 1;\n+        }\n+        else if (startPos + width >= text.length())\n+        {\n+            return -1;\n+        }\n+\n+\n+        // look for the last whitespace character before startPos+width\n+        pos = startPos + width;\n+\n+        char c;\n+\n+        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n+                && (c != '\\n') && (c != '\\r'))\n+        {\n+            --pos;\n+        }\n+\n+        // if we found it - just return\n+        if (pos > startPos)\n+        {\n+            return pos;\n+        }\n+        \n+        // must look for the first whitespace chearacter after startPos \n+        // + width\n+        pos = startPos + width;\n+\n+        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n+               && (c != '\\n') && (c != '\\r'))\n+        {\n+            ++pos;\n+        }\n+\n+        return (pos == text.length()) ? (-1) : pos;\n+    }\n+\n+    /**\n+     * Return a String of padding of length <code>len</code>.\n+     *\n+     * @param len The length of the String of padding to create.\n+     *\n+     * @return The String of padding\n+     */\n+    protected String createPadding(int len)\n+    {\n+        StringBuffer sb = new StringBuffer(len);\n+\n+        for (int i = 0; i < len; ++i)\n+        {\n+            sb.append(' ');\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Remove the trailing whitespace from the specified String.\n+     *\n+     * @param s The String to remove the trailing padding from.\n+     *\n+     * @return The String of without the trailing padding\n+     */\n+    protected String rtrim(String s)\n+    {\n+        if ((s == null) || (s.length() == 0))\n+        {\n+            return s;\n+        }\n+\n+        int pos = s.length();\n+\n+        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n+        {\n+            --pos;\n+        }\n+\n+        return s.substring(0, pos);\n+    }\n+\n+    // ------------------------------------------------------ Package protected\n+    // ---------------------------------------------------------------- Private\n+    // ---------------------------------------------------------- Inner classes\n+    /**\n+     * This class implements the <code>Comparator</code> interface\n+     * for comparing Options.\n+     */\n+    private static class OptionComparator implements Comparator\n+    {\n+\n+        /**\n+         * Compares its two arguments for order. Returns a negative\n+         * integer, zero, or a positive integer as the first argument\n+         * is less than, equal to, or greater than the second.\n+         *\n+         * @param o1 The first Option to be compared.\n+         * @param o2 The second Option to be compared.\n+         * @return a negative integer, zero, or a positive integer as\n+         *         the first argument is less than, equal to, or greater than the\n+         *         second.\n+         */\n+        public int compare(Object o1, Object o2)\n+        {\n+            Option opt1 = (Option) o1;\n+            Option opt2 = (Option) o2;\n+\n+            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/MissingArgumentException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Thrown when an option requiring an argument\n+ * is not provided with an argument.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class MissingArgumentException extends ParseException\n+{\n+    /** The option requiring additional arguments */\n+    private Option option;\n+\n+    /**\n+     * Construct a new <code>MissingArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public MissingArgumentException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>MissingArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param option the option requiring an argument\n+     * @since 1.2\n+     */\n+    public MissingArgumentException(Option option)\n+    {\n+        this(\"Missing argument for option: \" + option.getKey());\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Return the option requiring an argument that wasn't provided\n+     * on the command line.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public Option getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/MissingOptionException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.List;\n+import java.util.Iterator;\n+\n+/**\n+ * Thrown when a required option has not been provided.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class MissingOptionException extends ParseException\n+{\n+    /** The list of missing options */\n+    private List missingOptions;\n+\n+    /**\n+     * Construct a new <code>MissingSelectedException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public MissingOptionException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MissingSelectedException</code> with the\n+     * specified list of missing options.\n+     *\n+     * @param missingOptions the list of missing options\n+     * @since 1.2\n+     */\n+    public MissingOptionException(List missingOptions)\n+    {\n+        this(createMessage(missingOptions));\n+        this.missingOptions = missingOptions;\n+    }\n+\n+    /**\n+     * Return the list of options (as strings) missing in the command line parsed.\n+     *\n+     * @return the missing options\n+     * @since 1.2\n+     */\n+    public List getMissingOptions()\n+    {\n+        return missingOptions;\n+    }\n+\n+    /**\n+     * Build the exception message from the specified list of options.\n+     *\n+     * @param missingOptions\n+     * @since 1.2\n+     */\n+    private static String createMessage(List missingOptions)\n+    {\n+        StringBuffer buff = new StringBuffer(\"Missing required option\");\n+        buff.append(missingOptions.size() == 1 ? \"\" : \"s\");\n+        buff.append(\": \");\n+\n+        Iterator it = missingOptions.iterator();\n+        while (it.hasNext())\n+        {\n+            buff.append(it.next());\n+            if (it.hasNext())\n+            {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Option.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** <p>Describes a single command-line option.  It maintains\n+ * information regarding the short-name of the option, the long-name,\n+ * if any exists, a flag indicating if an argument is required for\n+ * this option, and a self-documenting description of the option.</p>\n+ *\n+ * <p>An Option is not created independantly, but is create through\n+ * an instance of {@link Options}.<p>\n+ *\n+ * @see org.apache.commons.cli.Options\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision$, $Date$\n+ */\n+public class Option implements Cloneable, Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** constant that specifies the number of argument values has not been specified */\n+    public static final int UNINITIALIZED = -1;\n+\n+    /** constant that specifies the number of argument values is infinite */\n+    public static final int UNLIMITED_VALUES = -2;\n+\n+    /** the name of the option */\n+    private String opt;\n+\n+    /** the long representation of the option */\n+    private String longOpt;\n+\n+    /** the name of the argument for this option */\n+    private String argName = \"arg\";\n+\n+    /** description of the option */\n+    private String description;\n+\n+    /** specifies whether this option is required to be present */\n+    private boolean required;\n+\n+    /** specifies whether the argument value of this Option is optional */\n+    private boolean optionalArg;\n+\n+    /** the number of argument values this option can have */\n+    private int numberOfArgs = UNINITIALIZED;\n+\n+    /** the type of this Option */\n+    private Object type;\n+\n+    /** the list of argument values **/\n+    private List values = new ArrayList();\n+\n+    /** the character that is the value separator */\n+    private char valuesep;\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String description) throws IllegalArgumentException\n+    {\n+        this(opt, null, false, description);\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n+    {\n+        this(opt, null, hasArg, description);\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param longOpt the long representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String longOpt, boolean hasArg, String description)\n+           throws IllegalArgumentException\n+    {\n+        // ensure that the option is valid\n+        OptionValidator.validateOption(opt);\n+\n+        this.opt = opt;\n+        this.longOpt = longOpt;\n+\n+        // if hasArg is set then the number of arguments is 1\n+        if (hasArg)\n+        {\n+            this.numberOfArgs = 1;\n+        }\n+\n+        this.description = description;\n+    }\n+\n+    /**\n+     * Returns the id of this Option.  This is only set when the\n+     * Option shortOpt is a single character.  This is used for switch\n+     * statements.\n+     *\n+     * @return the id of this Option\n+     */\n+    public int getId()\n+    {\n+        return getKey().charAt(0);\n+    }\n+\n+    /**\n+     * Returns the 'unique' Option identifier.\n+     * \n+     * @return the 'unique' Option identifier\n+     */\n+    String getKey()\n+    {\n+        // if 'opt' is null, then it is a 'long' option\n+        if (opt == null)\n+        {\n+            return longOpt;\n+        }\n+\n+        return opt;\n+    }\n+\n+    /** \n+     * Retrieve the name of this Option.\n+     *\n+     * It is this String which can be used with\n+     * {@link CommandLine#hasOption(String opt)} and\n+     * {@link CommandLine#getOptionValue(String opt)} to check\n+     * for existence and argument.\n+     *\n+     * @return The name of this option\n+     */\n+    public String getOpt()\n+    {\n+        return opt;\n+    }\n+\n+    /**\n+     * Retrieve the type of this Option.\n+     * \n+     * @return The type of this option\n+     */\n+    public Object getType()\n+    {\n+        return type;\n+    }\n+\n+    /**\n+     * Sets the type of this Option.\n+     *\n+     * @param type the type of this Option\n+     */\n+    public void setType(Object type)\n+    {\n+        this.type = type;\n+    }\n+\n+    /** \n+     * Retrieve the long name of this Option.\n+     *\n+     * @return Long name of this option, or null, if there is no long name\n+     */\n+    public String getLongOpt()\n+    {\n+        return longOpt;\n+    }\n+\n+    /**\n+     * Sets the long name of this Option.\n+     *\n+     * @param longOpt the long name of this Option\n+     */\n+    public void setLongOpt(String longOpt)\n+    {\n+        this.longOpt = longOpt;\n+    }\n+\n+    /**\n+     * Sets whether this Option can have an optional argument.\n+     *\n+     * @param optionalArg specifies whether the Option can have\n+     * an optional argument.\n+     */\n+    public void setOptionalArg(boolean optionalArg)\n+    {\n+        this.optionalArg = optionalArg;\n+    }\n+\n+    /**\n+     * @return whether this Option can have an optional argument\n+     */\n+    public boolean hasOptionalArg()\n+    {\n+        return optionalArg;\n+    }\n+\n+    /** \n+     * Query to see if this Option has a long name\n+     *\n+     * @return boolean flag indicating existence of a long name\n+     */\n+    public boolean hasLongOpt()\n+    {\n+        return longOpt != null;\n+    }\n+\n+    /** \n+     * Query to see if this Option requires an argument\n+     *\n+     * @return boolean flag indicating if an argument is required\n+     */\n+    public boolean hasArg()\n+    {\n+        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n+    }\n+\n+    /** \n+     * Retrieve the self-documenting description of this Option\n+     *\n+     * @return The string description of this option\n+     */\n+    public String getDescription()\n+    {\n+        return description;\n+    }\n+\n+    /**\n+     * Sets the self-documenting description of this Option\n+     *\n+     * @param description The description of this option\n+     * @since 1.1\n+     */\n+    public void setDescription(String description)\n+    {\n+        this.description = description;\n+    }\n+\n+    /** \n+     * Query to see if this Option requires an argument\n+     *\n+     * @return boolean flag indicating if an argument is required\n+     */\n+    public boolean isRequired()\n+    {\n+        return required;\n+    }\n+\n+    /**\n+     * Sets whether this Option is mandatory.\n+     *\n+     * @param required specifies whether this Option is mandatory\n+     */\n+    public void setRequired(boolean required)\n+    {\n+        this.required = required;\n+    }\n+\n+    /**\n+     * Sets the display name for the argument value.\n+     *\n+     * @param argName the display name for the argument value.\n+     */\n+    public void setArgName(String argName)\n+    {\n+        this.argName = argName;\n+    }\n+\n+    /**\n+     * Gets the display name for the argument value.\n+     *\n+     * @return the display name for the argument value.\n+     */\n+    public String getArgName()\n+    {\n+        return argName;\n+    }\n+\n+    /**\n+     * Returns whether the display name for the argument value\n+     * has been set.\n+     *\n+     * @return if the display name for the argument value has been\n+     * set.\n+     */\n+    public boolean hasArgName()\n+    {\n+        return argName != null && argName.length() > 0;\n+    }\n+\n+    /** \n+     * Query to see if this Option can take many values.\n+     *\n+     * @return boolean flag indicating if multiple values are allowed\n+     */\n+    public boolean hasArgs()\n+    {\n+        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n+    }\n+\n+    /** \n+     * Sets the number of argument values this Option can take.\n+     *\n+     * @param num the number of argument values\n+     */\n+    public void setArgs(int num)\n+    {\n+        this.numberOfArgs = num;\n+    }\n+\n+    /**\n+     * Sets the value separator.  For example if the argument value\n+     * was a Java property, the value separator would be '='.\n+     *\n+     * @param sep The value separator.\n+     */\n+    public void setValueSeparator(char sep)\n+    {\n+        this.valuesep = sep;\n+    }\n+\n+    /**\n+     * Returns the value separator character.\n+     *\n+     * @return the value separator character.\n+     */\n+    public char getValueSeparator()\n+    {\n+        return valuesep;\n+    }\n+\n+    /**\n+     * Return whether this Option has specified a value separator.\n+     * \n+     * @return whether this Option has specified a value separator.\n+     * @since 1.1\n+     */\n+    public boolean hasValueSeparator()\n+    {\n+        return valuesep > 0;\n+    }\n+\n+    /** \n+     * Returns the number of argument values this Option can take.\n+     *\n+     * @return num the number of argument values\n+     */\n+    public int getArgs()\n+    {\n+        return numberOfArgs;\n+    }\n+\n+    /**\n+     * Adds the specified value to this Option.\n+     * \n+     * @param value is a/the value of this Option\n+     */\n+    void addValueForProcessing(String value)\n+    {\n+        switch (numberOfArgs)\n+        {\n+            case UNINITIALIZED:\n+                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n+\n+            default:\n+                processValue(value);\n+        }\n+    }\n+\n+    /**\n+     * Processes the value.  If this Option has a value separator\n+     * the value will have to be parsed into individual tokens.  When\n+     * n-1 tokens have been processed and there are more value separators\n+     * in the value, parsing is ceased and the remaining characters are\n+     * added as a single token.\n+     *\n+     * @param value The String to be processed.\n+     *\n+     * @since 1.0.1\n+     */\n+    private void processValue(String value)\n+    {\n+        // this Option has a separator character\n+        if (hasValueSeparator())\n+        {\n+            // get the separator character\n+            char sep = getValueSeparator();\n+\n+            // store the index for the value separator\n+            int index = value.indexOf(sep);\n+\n+            // while there are more value separators\n+            while (index != -1)\n+            {\n+                // next value to be added \n+                if (values.size() == (numberOfArgs - 1))\n+                {\n+                    break;\n+                }\n+\n+                // store\n+                add(value.substring(0, index));\n+\n+                // parse\n+                value = value.substring(index + 1);\n+\n+                // get new index\n+                index = value.indexOf(sep);\n+            }\n+        }\n+\n+        // store the actual value or the last value that has been parsed\n+        add(value);\n+    }\n+\n+    /**\n+     * Add the value to this Option.  If the number of arguments\n+     * is greater than zero and there is enough space in the list then\n+     * add the value.  Otherwise, throw a runtime exception.\n+     *\n+     * @param value The value to be added to this Option\n+     *\n+     * @since 1.0.1\n+     */\n+    private void add(String value)\n+    {\n+        if ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n+        {\n+            throw new RuntimeException(\"Cannot add value, list full.\");\n+        }\n+\n+        // store value\n+        values.add(value);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @return the value/first value of this Option or \n+     * <code>null</code> if there is no value.\n+     */\n+    public String getValue()\n+    {\n+        return hasNoValues() ? null : (String) values.get(0);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @param index The index of the value to be returned.\n+     *\n+     * @return the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @throws IndexOutOfBoundsException if index is less than 1\n+     * or greater than the number of the values for this Option.\n+     */\n+    public String getValue(int index) throws IndexOutOfBoundsException\n+    {\n+        return hasNoValues() ? null : (String) values.get(index);\n+    }\n+\n+    /**\n+     * Returns the value/first value of this Option or the \n+     * <code>defaultValue</code> if there is no value.\n+     *\n+     * @param defaultValue The value to be returned if ther\n+     * is no value.\n+     *\n+     * @return the value/first value of this Option or the \n+     * <code>defaultValue</code> if there are no values.\n+     */\n+    public String getValue(String defaultValue)\n+    {\n+        String value = getValue();\n+\n+        return (value != null) ? value : defaultValue;\n+    }\n+\n+    /**\n+     * Return the values of this Option as a String array \n+     * or null if there are no values\n+     *\n+     * @return the values of this Option as a String array \n+     * or null if there are no values\n+     */\n+    public String[] getValues()\n+    {\n+        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n+    }\n+\n+    /**\n+     * @return the values of this Option as a List\n+     * or null if there are no values\n+     */\n+    public List getValuesList()\n+    {\n+        return values;\n+    }\n+\n+    /** \n+     * Dump state, suitable for debugging.\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n+\n+        buf.append(opt);\n+\n+        if (longOpt != null)\n+        {\n+            buf.append(\" \").append(longOpt);\n+        }\n+\n+        buf.append(\" \");\n+\n+        if (hasArgs())\n+        {\n+            buf.append(\"[ARG...]\");\n+        }\n+        else if (hasArg())\n+        {\n+            buf.append(\" [ARG]\");\n+        }\n+\n+        buf.append(\" :: \").append(description);\n+\n+        if (type != null)\n+        {\n+            buf.append(\" :: \").append(type);\n+        }\n+\n+        buf.append(\" ]\");\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns whether this Option has any values.\n+     *\n+     * @return whether this Option has any values.\n+     */\n+    private boolean hasNoValues()\n+    {\n+        return values.isEmpty();\n+    }\n+\n+    public boolean equals(Object o)\n+    {\n+        if (this == o)\n+        {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass())\n+        {\n+            return false;\n+        }\n+\n+        Option option = (Option) o;\n+\n+\n+        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n+        {\n+            return false;\n+        }\n+        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public int hashCode()\n+    {\n+        int result;\n+        result = (opt != null ? opt.hashCode() : 0);\n+        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n+        return result;\n+    }\n+\n+    /**\n+     * A rather odd clone method - due to incorrect code in 1.0 it is public \n+     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n+     * a RuntimeException so as to maintain backwards compat at the API level. \n+     *\n+     * After calling this method, it is very likely you will want to call \n+     * clearValues(). \n+     *\n+     * @throws RuntimeException\n+     */\n+    public Object clone()\n+    {\n+        try\n+        {\n+            Option option = (Option) super.clone();\n+            option.values = new ArrayList(values);\n+            return option;\n+        }\n+        catch (CloneNotSupportedException cnse)\n+        {\n+            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Clear the Option values. After a parse is complete, these are left with\n+     * data in them and they need clearing if another parse is done.\n+     *\n+     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n+     */\n+    void clearValues()\n+    {\n+        values.clear();\n+    }\n+\n+    /**\n+     * This method is not intended to be used. It was a piece of internal \n+     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n+     * @deprecated\n+     * @throws UnsupportedOperationException\n+     */\n+    public boolean addValue(String value)\n+    {\n+        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n+                + \"Subclasses should use the addValueForProcessing method instead. \");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/OptionBuilder.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * OptionBuilder allows the user to create Options using descriptive methods.\n+ *\n+ * <p>Details on the Builder pattern can be found at\n+ * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n+ * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @since 1.0\n+ */\n+public final class OptionBuilder\n+{\n+    /** long option */\n+    private static String longopt;\n+\n+    /** option description */\n+    private static String description;\n+\n+    /** argument name */\n+    private static String argName;\n+\n+    /** is required? */\n+    private static boolean required;\n+\n+    /** the number of arguments */\n+    private static int numberOfArgs = Option.UNINITIALIZED;\n+\n+    /** option type */\n+    private static Object type;\n+\n+    /** option can have an optional argument value */\n+    private static boolean optionalArg;\n+\n+    /** value separator for argument value */\n+    private static char valuesep;\n+\n+    /** option builder instance */\n+    private static OptionBuilder instance = new OptionBuilder();\n+\n+    /**\n+     * private constructor to prevent instances being created\n+     */\n+    private OptionBuilder()\n+    {\n+        // hide the constructor\n+    }\n+\n+    /**\n+     * Resets the member variables to their default values.\n+     */\n+    private static void reset()\n+    {\n+        description = null;\n+        argName = \"arg\";\n+        longopt = null;\n+        type = null;\n+        required = false;\n+        numberOfArgs = Option.UNINITIALIZED;\n+\n+\n+        // PMM 9/6/02 - these were missing\n+        optionalArg = false;\n+        valuesep = (char) 0;\n+    }\n+\n+    /**\n+     * The next Option created will have the following long option value.\n+     *\n+     * @param newLongopt the long option value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withLongOpt(String newLongopt)\n+    {\n+        OptionBuilder.longopt = newLongopt;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will require an argument value.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArg()\n+    {\n+        OptionBuilder.numberOfArgs = 1;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will require an argument value if\n+     * <code>hasArg</code> is true.\n+     *\n+     * @param hasArg if true then the Option has an argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArg(boolean hasArg)\n+    {\n+        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have the specified argument value name.\n+     *\n+     * @param name the name for the argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withArgName(String name)\n+    {\n+        OptionBuilder.argName = name;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will be required.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder isRequired()\n+    {\n+        OptionBuilder.required = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created uses <code>sep</code> as a means to\n+     * separate argument values.\n+     *\n+     * <b>Example:</b>\n+     * <pre>\n+     * Option opt = OptionBuilder.withValueSeparator(':')\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n+     * </pre>\n+     *\n+     * @param sep The value separator to be used for the argument values.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withValueSeparator(char sep)\n+    {\n+        OptionBuilder.valuesep = sep;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created uses '<code>=</code>' as a means to\n+     * separate argument values.\n+     *\n+     * <b>Example:</b>\n+     * <pre>\n+     * Option opt = OptionBuilder.withValueSeparator()\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n+     * </pre>\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withValueSeparator()\n+    {\n+        OptionBuilder.valuesep = '=';\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will be required if <code>required</code>\n+     * is true.\n+     *\n+     * @param newRequired if true then the Option is required\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder isRequired(boolean newRequired)\n+    {\n+        OptionBuilder.required = newRequired;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created can have unlimited argument values.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArgs()\n+    {\n+        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created can have <code>num</code> argument values.\n+     *\n+     * @param num the number of args that the option can have\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArgs(int num)\n+    {\n+        OptionBuilder.numberOfArgs = num;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have an optional argument.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArg()\n+    {\n+        OptionBuilder.numberOfArgs = 1;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have an unlimited number of optional arguments.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArgs()\n+    {\n+        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have the specified number of optional arguments.\n+     *\n+     * @param numArgs - the maximum number of optional arguments\n+     * the next Option created can have.\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArgs(int numArgs)\n+    {\n+        OptionBuilder.numberOfArgs = numArgs;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have a value that will be an instance\n+     * of <code>type</code>.\n+     *\n+     * @param newType the type of the Options argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withType(Object newType)\n+    {\n+        OptionBuilder.type = newType;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have the specified description\n+     *\n+     * @param newDescription a description of the Option's purpose\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withDescription(String newDescription)\n+    {\n+        OptionBuilder.description = newDescription;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * Create an Option using the current settings and with\n+     * the specified Option <code>char</code>.\n+     *\n+     * @param opt the character representation of the Option\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>opt</code> is not\n+     * a valid character.  See Option.\n+     */\n+    public static Option create(char opt) throws IllegalArgumentException\n+    {\n+        return create(String.valueOf(opt));\n+    }\n+\n+    /**\n+     * Create an Option using the current settings\n+     *\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n+     */\n+    public static Option create() throws IllegalArgumentException\n+    {\n+        if (longopt == null)\n+        {\n+            OptionBuilder.reset();\n+            throw new IllegalArgumentException(\"must specify longopt\");\n+        }\n+\n+        return create(null);\n+    }\n+\n+    /**\n+     * Create an Option using the current settings and with\n+     * the specified Option <code>char</code>.\n+     *\n+     * @param opt the <code>java.lang.String</code> representation\n+     * of the Option\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>opt</code> is not\n+     * a valid character.  See Option.\n+     */\n+    public static Option create(String opt) throws IllegalArgumentException\n+    {\n+        Option option = null;\n+        try {\n+            // create the option\n+            option = new Option(opt, description);\n+\n+            // set the option properties\n+            option.setLongOpt(longopt);\n+            option.setRequired(required);\n+            option.setOptionalArg(optionalArg);\n+            option.setArgs(numberOfArgs);\n+            option.setType(type);\n+            option.setValueSeparator(valuesep);\n+            option.setArgName(argName);\n+        } finally {\n+            // reset the OptionBuilder properties\n+            OptionBuilder.reset();\n+        }\n+\n+        // return the Option instance\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * A group of mutually exclusive options.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class OptionGroup implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+    \n+    /** hold the options */\n+    private Map optionMap = new HashMap();\n+\n+    /** the name of the selected option */\n+    private String selected;\n+\n+    /** specified whether this group is required */\n+    private boolean required;\n+\n+    /**\n+     * Add the specified <code>Option</code> to this group.\n+     *\n+     * @param option the option to add to this group\n+     * @return this option group with the option added\n+     */\n+    public OptionGroup addOption(Option option)\n+    {\n+        // key   - option name\n+        // value - the option\n+        optionMap.put(option.getKey(), option);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * @return the names of the options in this group as a \n+     * <code>Collection</code>\n+     */\n+    public Collection getNames()\n+    {\n+        // the key set is the collection of names\n+        return optionMap.keySet();\n+    }\n+\n+    /**\n+     * @return the options in this group as a <code>Collection</code>\n+     */\n+    public Collection getOptions()\n+    {\n+        // the values are the collection of options\n+        return optionMap.values();\n+    }\n+\n+    /**\n+     * Set the selected option of this group to <code>name</code>.\n+     *\n+     * @param option the option that is selected\n+     * @throws AlreadySelectedException if an option from this group has \n+     * already been selected.\n+     */\n+    public void setSelected(Option option) throws AlreadySelectedException\n+    {\n+        // if no option has already been selected or the \n+        // same option is being reselected then set the\n+        // selected member variable\n+        if (selected == null || selected.equals(option.getOpt()))\n+        {\n+            selected = option.getOpt();\n+        }\n+        else\n+        {\n+            throw new AlreadySelectedException(this, option);\n+        }\n+    }\n+\n+    /**\n+     * @return the selected option name\n+     */\n+    public String getSelected()\n+    {\n+        return selected;\n+    }\n+\n+    /**\n+     * @param required specifies if this group is required\n+     */\n+    public void setRequired(boolean required)\n+    {\n+        this.required = required;\n+    }\n+\n+    /**\n+     * Returns whether this option group is required.\n+     *\n+     * @return whether this option group is required\n+     */\n+    public boolean isRequired()\n+    {\n+        return required;\n+    }\n+\n+    /**\n+     * Returns the stringified version of this OptionGroup.\n+     * \n+     * @return the stringified representation of this group\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buff = new StringBuffer();\n+\n+        Iterator iter = getOptions().iterator();\n+\n+        buff.append(\"[\");\n+\n+        while (iter.hasNext())\n+        {\n+            Option option = (Option) iter.next();\n+\n+            if (option.getOpt() != null)\n+            {\n+                buff.append(\"-\");\n+                buff.append(option.getOpt());\n+            }\n+            else\n+            {\n+                buff.append(\"--\");\n+                buff.append(option.getLongOpt());\n+            }\n+\n+            buff.append(\" \");\n+            buff.append(option.getDescription());\n+\n+            if (iter.hasNext())\n+            {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        buff.append(\"]\");\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/OptionValidator.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Validates an Option string.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ * @since 1.1\n+ */\n+class OptionValidator\n+{\n+    /**\n+     * Validates whether <code>opt</code> is a permissable Option\n+     * shortOpt.  The rules that specify if the <code>opt</code>\n+     * is valid are:\n+     *\n+     * <ul>\n+     *  <li><code>opt</code> is not NULL</li>\n+     *  <li>a single character <code>opt</code> that is either\n+     *  ' '(special case), '?', '@' or a letter</li>\n+     *  <li>a multi character <code>opt</code> that only contains\n+     *  letters.</li>\n+     * </ul>\n+     *\n+     * @param opt The option string to validate\n+     * @throws IllegalArgumentException if the Option is not valid.\n+     */\n+    static void validateOption(String opt) throws IllegalArgumentException\n+    {\n+        // check that opt is not NULL\n+        if (opt == null)\n+        {\n+            return;\n+        }\n+\n+        // handle the single character opt\n+        else if (opt.length() == 1)\n+        {\n+            char ch = opt.charAt(0);\n+\n+            if (!isValidOpt(ch))\n+            {\n+                throw new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n+            }\n+        }\n+\n+        // handle the multi character opt\n+        else\n+        {\n+            char[] chars = opt.toCharArray();\n+\n+            for (int i = 0; i < chars.length; i++)\n+            {\n+                if (!isValidChar(chars[i]))\n+                {\n+                    throw new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the specified character is a valid Option.\n+     *\n+     * @param c the option to validate\n+     * @return true if <code>c</code> is a letter, ' ', '?' or '@',\n+     *         otherwise false.\n+     */\n+    private static boolean isValidOpt(char c)\n+    {\n+        return isValidChar(c) || c == ' ' || c == '?' || c == '@';\n+    }\n+\n+    /**\n+     * Returns whether the specified character is a valid character.\n+     *\n+     * @param c the character to validate\n+     * @return true if <code>c</code> is a letter.\n+     */\n+    private static boolean isValidChar(char c)\n+    {\n+        return Character.isJavaIdentifierPart(c);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Options.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Main entry-point into the library.</p>\n+ *\n+ * <p>Options represents a collection of {@link Option} objects, which\n+ * describe the possible options for a command-line.<p>\n+ *\n+ * <p>It may flexibly parse long and short options, with or without\n+ * values.  Additionally, it may parse only a portion of a commandline,\n+ * allowing for flexible multi-stage parsing.<p>\n+ *\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision$, $Date$\n+ */\n+public class Options implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** a map of the options with the character key */\n+    private Map shortOpts = new HashMap();\n+\n+    /** a map of the options with the long key */\n+    private Map longOpts = new HashMap();\n+\n+    /** a map of the required options */\n+    private List requiredOpts = new ArrayList();\n+\n+    /** a map of the option groups */\n+    private Map optionGroups = new HashMap();\n+\n+    /**\n+     * Add the specified option group.\n+     *\n+     * @param group the OptionGroup that is to be added\n+     * @return the resulting Options instance\n+     */\n+    public Options addOptionGroup(OptionGroup group)\n+    {\n+        Iterator options = group.getOptions().iterator();\n+\n+        if (group.isRequired())\n+        {\n+            requiredOpts.add(group);\n+        }\n+\n+        while (options.hasNext())\n+        {\n+            Option option = (Option) options.next();\n+\n+            // an Option cannot be required if it is in an\n+            // OptionGroup, either the group is required or\n+            // nothing is required\n+            option.setRequired(false);\n+            addOption(option);\n+\n+            optionGroups.put(option.getKey(), group);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Lists the OptionGroups that are members of this Options instance.\n+     *\n+     * @return a Collection of OptionGroup instances.\n+     */\n+    Collection getOptionGroups()\n+    {\n+        return new HashSet(optionGroups.values());\n+    }\n+\n+    /**\n+     * Add an option that only contains a short-name.\n+     * It may be specified as requiring an argument.\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(String opt, boolean hasArg, String description)\n+    {\n+        addOption(opt, null, hasArg, description);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Add an option that contains a short-name and a long-name.\n+     * It may be specified as requiring an argument.\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param longOpt Long multi-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n+    {\n+        addOption(new Option(opt, longOpt, hasArg, description));\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an option instance\n+     *\n+     * @param opt the option that is to be added\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(Option opt)\n+    {\n+        String key = opt.getKey();\n+\n+        // add it to the long option list\n+        if (opt.hasLongOpt())\n+        {\n+            longOpts.put(opt.getLongOpt(), opt);\n+        }\n+\n+        // if the option is required add it to the required list\n+        if (opt.isRequired())\n+        {\n+            if (requiredOpts.contains(key))\n+            {\n+                requiredOpts.remove(requiredOpts.indexOf(key));\n+            }\n+            requiredOpts.add(key);\n+        }\n+\n+        shortOpts.put(key, opt);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieve a read-only list of options in this set\n+     *\n+     * @return read-only Collection of {@link Option} objects in this descriptor\n+     */\n+    public Collection getOptions()\n+    {\n+        return Collections.unmodifiableCollection(helpOptions());\n+    }\n+\n+    /**\n+     * Returns the Options for use by the HelpFormatter.\n+     *\n+     * @return the List of Options\n+     */\n+    List helpOptions()\n+    {\n+        return new ArrayList(shortOpts.values());\n+    }\n+\n+    /**\n+     * Returns the required options.\n+     *\n+     * @return List of required options\n+     */\n+    public List getRequiredOptions()\n+    {\n+        return requiredOpts;\n+    }\n+\n+    /**\n+     * Retrieve the {@link Option} matching the long or short name specified.\n+     * The leading hyphens in the name are ignored (up to 2).\n+     *\n+     * @param opt short or long name of the {@link Option}\n+     * @return the option represented by opt\n+     */\n+    public Option getOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        if (shortOpts.containsKey(opt))\n+        {\n+            return (Option) shortOpts.get(opt);\n+        }\n+\n+        return (Option) longOpts.get(opt);\n+    }\n+\n+    /**\n+     * Returns whether the named {@link Option} is a member of this {@link Options}.\n+     *\n+     * @param opt short or long name of the {@link Option}\n+     * @return true if the named {@link Option} is a member\n+     * of this {@link Options}\n+     */\n+    public boolean hasOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n+    }\n+\n+    /**\n+     * Returns the OptionGroup the <code>opt</code> belongs to.\n+     * @param opt the option whose OptionGroup is being queried.\n+     *\n+     * @return the OptionGroup if <code>opt</code> is part\n+     * of an OptionGroup, otherwise return null\n+     */\n+    public OptionGroup getOptionGroup(Option opt)\n+    {\n+        return (OptionGroup) optionGroups.get(opt.getKey());\n+    }\n+\n+    /**\n+     * Dump state, suitable for debugging.\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buf = new StringBuffer();\n+\n+        buf.append(\"[ Options: [ short \");\n+        buf.append(shortOpts.toString());\n+        buf.append(\" ] [ long \");\n+        buf.append(longOpts);\n+        buf.append(\" ]\");\n+\n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/ParseException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Base for Exceptions thrown during parsing of a command-line.\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class ParseException extends Exception\n+{\n+    /**\n+     * Construct a new <code>ParseException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public ParseException(String message)\n+    {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Parser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Properties;\n+\n+/**\n+ * <code>Parser</code> creates {@link CommandLine}s.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public abstract class Parser implements CommandLineParser\n+{\n+    /** commandline instance */\n+    protected CommandLine cmd;\n+\n+    /** current Options */\n+    private Options options;\n+\n+    /** list of required options strings */\n+    private List requiredOptions;\n+\n+    protected void setOptions(final Options options)\n+    {\n+        this.options = options;\n+        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n+    }\n+\n+    protected Options getOptions()\n+    {\n+        return options;\n+    }\n+\n+    protected List getRequiredOptions()\n+    {\n+        return requiredOptions;\n+    }\n+\n+    /**\n+     * Subclasses must implement this method to reduce\n+     * the <code>arguments</code> that have been passed to the parse method.\n+     *\n+     * @param opts The Options to parse the arguments by.\n+     * @param arguments The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop\n+     * flattening when a non option has been encountered\n+     * @return a String array of the flattened arguments\n+     */\n+    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption);\n+\n+    /**\n+     * Parses the specified <code>arguments</code> based\n+     * on the specifed {@link Options}.\n+     *\n+     * @param options the <code>Options</code>\n+     * @param arguments the <code>arguments</code>\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the\n+     * arguments.\n+     */\n+    public CommandLine parse(Options options, String[] arguments) throws ParseException\n+    {\n+        return parse(options, arguments, null, false);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param options    the specified Options\n+     * @param arguments  the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     *                        while parsing the command line tokens.\n+     *\n+     * @since 1.1\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n+    {\n+        return parse(options, arguments, properties, false);\n+    }\n+\n+    /**\n+     * Parses the specified <code>arguments</code>\n+     * based on the specifed {@link Options}.\n+     *\n+     * @param options         the <code>Options</code>\n+     * @param arguments       the <code>arguments</code>\n+     * @param stopAtNonOption specifies whether to stop interpreting the\n+     *                        arguments when a non option has been encountered\n+     *                        and to add them to the CommandLines args list.\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the arguments.\n+     */\n+    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n+    {\n+        return parse(options, arguments, null, stopAtNonOption);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @param stopAtNonOption stop parsing the arguments when the first\n+     * non option is encountered.\n+     *\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     *\n+     * @since 1.1\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException\n+    {\n+        // clear out the data in options in case it's been used before (CLI-71)\n+        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n+        {\n+            Option opt = (Option) it.next();\n+            opt.clearValues();\n+        }\n+\n+        // initialise members\n+        setOptions(options);\n+\n+        cmd = new CommandLine();\n+\n+        boolean eatTheRest = false;\n+\n+        if (arguments == null)\n+        {\n+            arguments = new String[0];\n+        }\n+\n+        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n+\n+        ListIterator iterator = tokenList.listIterator();\n+\n+        // process each flattened token\n+        while (iterator.hasNext())\n+        {\n+            String t = (String) iterator.next();\n+\n+            // the value is the double-dash\n+            if (\"--\".equals(t))\n+            {\n+                eatTheRest = true;\n+            }\n+\n+            // the value is a single dash\n+            else if (\"-\".equals(t))\n+            {\n+                if (stopAtNonOption)\n+                {\n+                    eatTheRest = true;\n+                }\n+                else\n+                {\n+                    cmd.addArg(t);\n+                }\n+            }\n+\n+            // the value is an option\n+            else if (t.startsWith(\"-\"))\n+            {\n+                if (stopAtNonOption && !getOptions().hasOption(t))\n+                {\n+                    eatTheRest = true;\n+                    cmd.addArg(t);\n+                }\n+                else\n+                {\n+                    processOption(t, iterator);\n+                }\n+            }\n+\n+            // the value is an argument\n+            else\n+            {\n+                cmd.addArg(t);\n+\n+                if (stopAtNonOption)\n+                {\n+                    eatTheRest = true;\n+                }\n+            }\n+\n+            // eat the remaining tokens\n+            if (eatTheRest)\n+            {\n+                while (iterator.hasNext())\n+                {\n+                    String str = (String) iterator.next();\n+\n+                    // ensure only one double-dash is added\n+                    if (!\"--\".equals(str))\n+                    {\n+                        cmd.addArg(str);\n+                    }\n+                }\n+            }\n+        }\n+\n+        processProperties(properties);\n+        checkRequiredOptions();\n+\n+        return cmd;\n+    }\n+\n+    /**\n+     * Sets the values of Options using the values in <code>properties</code>.\n+     *\n+     * @param properties The value properties to be processed.\n+     */\n+    protected void processProperties(Properties properties)\n+    {\n+        if (properties == null)\n+        {\n+            return;\n+        }\n+\n+        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n+        {\n+            String option = e.nextElement().toString();\n+\n+            if (!cmd.hasOption(option))\n+            {\n+                Option opt = getOptions().getOption(option);\n+\n+                // get the value from the properties instance\n+                String value = properties.getProperty(option);\n+\n+                if (opt.hasArg())\n+                {\n+                    if (opt.getValues() == null || opt.getValues().length == 0)\n+                    {\n+                        try\n+                        {\n+                            opt.addValueForProcessing(value);\n+                        }\n+                        catch (RuntimeException exp)\n+                        {\n+                            // if we cannot add the value don't worry about it\n+                        }\n+                    }\n+                }\n+                else if (!(\"yes\".equalsIgnoreCase(value)\n+                        || \"true\".equalsIgnoreCase(value)\n+                        || \"1\".equalsIgnoreCase(value)))\n+                {\n+                    // if the value is not yes, true or 1 then don't add the\n+                    // option to the CommandLine\n+                    break;\n+                }\n+\n+                cmd.addOption(opt);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throws a {@link MissingOptionException} if all of the required options\n+     * are not present.\n+     *\n+     * @throws MissingOptionException if any of the required Options\n+     * are not present.\n+     */\n+    protected void checkRequiredOptions() throws MissingOptionException\n+    {\n+        // if there are required options that have not been processsed\n+        if (!getRequiredOptions().isEmpty())\n+        {\n+            throw new MissingOptionException(getRequiredOptions());\n+        }\n+    }\n+\n+    /**\n+     * <p>Process the argument values for the specified Option\n+     * <code>opt</code> using the values retrieved from the\n+     * specified iterator <code>iter</code>.\n+     *\n+     * @param opt The current Option\n+     * @param iter The iterator over the flattened command line\n+     * Options.\n+     *\n+     * @throws ParseException if an argument value is required\n+     * and it is has not been found.\n+     */\n+    public void processArgs(Option opt, ListIterator iter) throws ParseException\n+    {\n+        // loop until an option is found\n+        while (iter.hasNext())\n+        {\n+            String str = (String) iter.next();\n+\n+            // found an Option, not an argument\n+            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n+            {\n+                iter.previous();\n+                break;\n+            }\n+\n+            // found a value\n+            try\n+            {\n+                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n+            }\n+            catch (RuntimeException exp)\n+            {\n+                iter.previous();\n+                break;\n+            }\n+        }\n+\n+        if (opt.getValues() == null && !opt.hasOptionalArg())\n+        {\n+            throw new MissingArgumentException(opt);\n+        }\n+    }\n+\n+    /**\n+     * Process the Option specified by <code>arg</code> using the values\n+     * retrieved from the specfied iterator <code>iter</code>.\n+     *\n+     * @param arg The String value representing an Option\n+     * @param iter The iterator over the flattened command line arguments.\n+     *\n+     * @throws ParseException if <code>arg</code> does not represent an Option\n+     */\n+    protected void processOption(String arg, ListIterator iter) throws ParseException\n+    {\n+        boolean hasOption = getOptions().hasOption(arg);\n+\n+        // if there is no option throw an UnrecognisedOptionException\n+        if (!hasOption)\n+        {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n+        }\n+\n+        // get the option represented by arg\n+        Option opt = (Option) getOptions().getOption(arg).clone();\n+\n+        // if the option is a required option remove the option from\n+        // the requiredOptions list\n+        if (opt.isRequired())\n+        {\n+            getRequiredOptions().remove(opt.getKey());\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected\n+        // option of the group\n+        if (getOptions().getOptionGroup(opt) != null)\n+        {\n+            OptionGroup group = getOptions().getOptionGroup(opt);\n+\n+            if (group.isRequired())\n+            {\n+                getRequiredOptions().remove(group);\n+            }\n+\n+            group.setSelected(opt);\n+        }\n+\n+        // if the option takes an argument value\n+        if (opt.hasArg())\n+        {\n+            processArgs(opt, iter);\n+        }\n+\n+        // set the option on the command line\n+        cmd.addOption(opt);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.net.URL;\n+import java.util.Date;\n+\n+/**\n+ * <p>\n+ * Allows Options to be created from a single String.\n+ * The pattern contains various single character flags and via\n+ * an optional punctuation character, their expected type.\n+ * </p>\n+ *\n+ * <table border=\"1\">\n+ * <tr><td>a</td><td>-a flag</td></tr>\n+ * <tr><td>b@</td><td>-b [classname]</td></tr>\n+ * <tr><td>c&gt;</td><td>-c [filename]</td></tr>\n+ * <tr><td>d+</td><td>-d [classname] (creates object via empty contructor)</td></tr>\n+ * <tr><td>e%</td><td>-e [number] (creates Double/Long instance depeding on existing of a '.')</td></tr>\n+ * <tr><td>f/</td><td>-f [url]</td></tr>\n+ * <tr><td>g:</td><td>-g [string]</td></tr>\n+ * </table>\n+ *\n+ * <p>\n+ * For example, the following allows command line flags of '-v -p string-value -f /dir/file'.\n+ * The exclamation mark precede a mandatory option.\n+ * </p>\n+ * <code>Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");</code>\n+ *\n+ * <p>\n+ * TODO These need to break out to OptionType and also\n+ * to be pluggable.\n+ * </p>\n+ *\n+ * @version $Revision$, $Date$\n+ */\n+public class PatternOptionBuilder\n+{\n+    /** String class */\n+    public static final Class STRING_VALUE = String.class;\n+\n+    /** Object class */\n+    public static final Class OBJECT_VALUE = Object.class;\n+\n+    /** Number class */\n+    public static final Class NUMBER_VALUE = Number.class;\n+\n+    /** Date class */\n+    public static final Class DATE_VALUE = Date.class;\n+\n+    /** Class class */\n+    public static final Class CLASS_VALUE = Class.class;\n+\n+    /// can we do this one??\n+    // is meant to check that the file exists, else it errors.\n+    // ie) it's for reading not writing.\n+\n+    /** FileInputStream class */\n+    public static final Class EXISTING_FILE_VALUE = FileInputStream.class;\n+\n+    /** File class */\n+    public static final Class FILE_VALUE = File.class;\n+\n+    /** File array class */\n+    public static final Class FILES_VALUE = File[].class;\n+\n+    /** URL class */\n+    public static final Class URL_VALUE = URL.class;\n+\n+    /**\n+     * Retrieve the class that <code>ch</code> represents.\n+     *\n+     * @param ch the specified character\n+     * @return The class that <code>ch</code> represents\n+     */\n+    public static Object getValueClass(char ch)\n+    {\n+        switch (ch)\n+        {\n+            case '@':\n+                return PatternOptionBuilder.OBJECT_VALUE;\n+            case ':':\n+                return PatternOptionBuilder.STRING_VALUE;\n+            case '%':\n+                return PatternOptionBuilder.NUMBER_VALUE;\n+            case '+':\n+                return PatternOptionBuilder.CLASS_VALUE;\n+            case '#':\n+                return PatternOptionBuilder.DATE_VALUE;\n+            case '<':\n+                return PatternOptionBuilder.EXISTING_FILE_VALUE;\n+            case '>':\n+                return PatternOptionBuilder.FILE_VALUE;\n+            case '*':\n+                return PatternOptionBuilder.FILES_VALUE;\n+            case '/':\n+                return PatternOptionBuilder.URL_VALUE;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Returns whether <code>ch</code> is a value code, i.e.\n+     * whether it represents a class in a pattern.\n+     *\n+     * @param ch the specified character\n+     * @return true if <code>ch</code> is a value code, otherwise false.\n+     */\n+    public static boolean isValueCode(char ch)\n+    {\n+        return ch == '@'\n+                || ch == ':'\n+                || ch == '%'\n+                || ch == '+'\n+                || ch == '#'\n+                || ch == '<'\n+                || ch == '>'\n+                || ch == '*'\n+                || ch == '/'\n+                || ch == '!';\n+    }\n+\n+    /**\n+     * Returns the {@link Options} instance represented by <code>pattern</code>.\n+     *\n+     * @param pattern the pattern string\n+     * @return The {@link Options} instance\n+     */\n+    public static Options parsePattern(String pattern)\n+    {\n+        char opt = ' ';\n+        boolean required = false;\n+        Object type = null;\n+\n+        Options options = new Options();\n+\n+        for (int i = 0; i < pattern.length(); i++)\n+        {\n+            char ch = pattern.charAt(i);\n+\n+            // a value code comes after an option and specifies\n+            // details about it\n+            if (!isValueCode(ch))\n+            {\n+                if (opt != ' ')\n+                {\n+                    OptionBuilder.hasArg(type != null);\n+                    OptionBuilder.isRequired(required);\n+                    OptionBuilder.withType(type);\n+\n+                    // we have a previous one to deal with\n+                    options.addOption(OptionBuilder.create(opt));\n+                    required = false;\n+                    type = null;\n+                    opt = ' ';\n+                }\n+\n+                opt = ch;\n+            }\n+            else if (ch == '!')\n+            {\n+                required = true;\n+            }\n+            else\n+            {\n+                type = getValueClass(ch);\n+            }\n+        }\n+\n+        if (opt != ' ')\n+        {\n+            OptionBuilder.hasArg(type != null);\n+            OptionBuilder.isRequired(required);\n+            OptionBuilder.withType(type);\n+\n+            // we have a final one to deal with\n+            options.addOption(OptionBuilder.create(opt));\n+        }\n+\n+        return options;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * The class PosixParser provides an implementation of the\n+ * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class PosixParser extends Parser\n+{\n+    /** holder for flattened tokens */\n+    private List tokens = new ArrayList();\n+\n+    /** specifies if bursting should continue */\n+    private boolean eatTheRest;\n+\n+    /** holder for the current option */\n+    private Option currentOption;\n+\n+    /** the command line Options */\n+    private Options options;\n+\n+    /**\n+     * Resets the members to their original state i.e. remove\n+     * all of <code>tokens</code> entries and set <code>eatTheRest</code>\n+     * to false.\n+     */\n+    private void init()\n+    {\n+        eatTheRest = false;\n+        tokens.clear();\n+    }\n+\n+    /**\n+     * <p>An implementation of {@link Parser}'s abstract\n+     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n+     *\n+     * <p>The following are the rules used by this flatten method.\n+     * <ol>\n+     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n+     *  burst anymore of <code>arguments</code> entries, just add each\n+     *  successive entry without further processing.  Otherwise, ignore\n+     *  <code>stopAtNonOption</code>.</li>\n+     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n+     *  just add the entry to the list of processed tokens</li>\n+     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n+     *  just add the entry to the list of processed tokens</li>\n+     *  <li>if the current <code>arguments</code> entry is two characters\n+     *  in length and the first character is \"<b>-</b>\" then check if this\n+     *  is a valid {@link Option} id.  If it is a valid id, then add the\n+     *  entry to the list of processed tokens and set the current {@link Option}\n+     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n+     *  is true, then the remaining entries are copied to the list of\n+     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n+     *  <li>if the current <code>arguments</code> entry is more than two\n+     *  characters in length and the first character is \"<b>-</b>\" then\n+     *  we need to burst the entry to determine its constituents.  For more\n+     *  information on the bursting algorithm see\n+     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n+     *  <li>if the current <code>arguments</code> entry is not handled\n+     *  by any of the previous rules, then the entry is added to the list\n+     *  of processed tokens.</li>\n+     * </ol>\n+     * </p>\n+     *\n+     * @param options The command line {@link Options}\n+     * @param arguments The command line arguments to be parsed\n+     * @param stopAtNonOption Specifies whether to stop flattening\n+     * when an non option is found.\n+     * @return The flattened <code>arguments</code> String array.\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n+    {\n+        init();\n+        this.options = options;\n+\n+        // an iterator for the command line tokens\n+        Iterator iter = Arrays.asList(arguments).iterator();\n+\n+        // process each command line token\n+        while (iter.hasNext())\n+        {\n+            // get the next command line token\n+            String token = (String) iter.next();\n+\n+            // handle long option --foo or --foo=bar\n+            if (token.startsWith(\"--\"))\n+            {\n+                int pos = token.indexOf('=');\n+                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n+\n+                if (!options.hasOption(opt))\n+                {\n+                    processNonOptionToken(token, stopAtNonOption);\n+                }\n+                else\n+                {\n+                    currentOption = options.getOption(opt);\n+                    \n+                    tokens.add(opt);\n+                    if (pos != -1)\n+                    {\n+                        tokens.add(token.substring(pos + 1));\n+                    }\n+                }\n+            }\n+\n+            // single hyphen\n+            else if (\"-\".equals(token))\n+            {\n+                tokens.add(token);\n+            }\n+            else if (token.startsWith(\"-\"))\n+            {\n+                if (token.length() == 2 || options.hasOption(token))\n+                {\n+                    processOptionToken(token, stopAtNonOption);\n+                }\n+                // requires bursting\n+                else\n+                {\n+                    burstToken(token, stopAtNonOption);\n+                }\n+            }\n+            else\n+            {\n+                processNonOptionToken(token, stopAtNonOption);\n+            }\n+\n+            gobble(iter);\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+\n+    /**\n+     * Adds the remaining tokens to the processed tokens list.\n+     *\n+     * @param iter An iterator over the remaining tokens\n+     */\n+    private void gobble(Iterator iter)\n+    {\n+        if (eatTheRest)\n+        {\n+            while (iter.hasNext())\n+            {\n+                tokens.add(iter.next());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add the special token \"<b>--</b>\" and the current <code>value</code>\n+     * to the processed tokens list. Then add all the remaining\n+     * <code>argument</code> values to the processed tokens list.\n+     *\n+     * @param value The current token\n+     */\n+    private void processNonOptionToken(String value, boolean stopAtNonOption)\n+    {\n+        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n+        {\n+            eatTheRest = true;\n+            tokens.add(\"--\");\n+        }\n+\n+        tokens.add(value);\n+    }\n+\n+    /**\n+     * <p>If an {@link Option} exists for <code>token</code> then\n+     * add the token to the processed list.</p>\n+     *\n+     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n+     * is set then add the remaining tokens to the processed tokens list\n+     * directly.</p>\n+     *\n+     * @param token The current option token\n+     * @param stopAtNonOption Specifies whether flattening should halt\n+     * at the first non option.\n+     */\n+    private void processOptionToken(String token, boolean stopAtNonOption)\n+    {\n+        if (stopAtNonOption && !options.hasOption(token))\n+        {\n+            eatTheRest = true;\n+        }\n+\n+        if (options.hasOption(token))\n+        {\n+            currentOption = options.getOption(token);\n+        }\n+\n+        tokens.add(token);\n+    }\n+\n+    /**\n+     * Breaks <code>token</code> into its constituent parts\n+     * using the following algorithm.\n+     *\n+     * <ul>\n+     *  <li>ignore the first character (\"<b>-</b>\")</li>\n+     *  <li>foreach remaining character check if an {@link Option}\n+     *  exists with that id.</li>\n+     *  <li>if an {@link Option} does exist then add that character\n+     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n+     *  <li>if the {@link Option} can have an argument value and there\n+     *  are remaining characters in the token then add the remaining\n+     *  characters as a token to the list of processed tokens.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n+     *  \"<b>--</b>\" followed by the remaining characters and also\n+     *  the remaining tokens directly to the processed tokens list.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n+     *  character prepended with \"<b>-</b>\".</li>\n+     * </ul>\n+     *\n+     * @param token The current token to be <b>burst</b>\n+     * @param stopAtNonOption Specifies whether to stop processing\n+     * at the first non-Option encountered.\n+     */\n+    protected void burstToken(String token, boolean stopAtNonOption)\n+    {\n+        for (int i = 1; i < token.length(); i++)\n+        {\n+            String ch = String.valueOf(token.charAt(i));\n+\n+            if (options.hasOption(ch))\n+            {\n+                tokens.add(\"-\" + ch);\n+                currentOption = options.getOption(ch);\n+\n+                if (currentOption.hasArg() && (token.length() != (i + 1)))\n+                {\n+                    tokens.add(token.substring(i + 1));\n+\n+                    break;\n+                }\n+            }\n+            else if (stopAtNonOption)\n+            {\n+                processNonOptionToken(token.substring(i), true);\n+                break;\n+            }\n+            else\n+            {\n+                tokens.add(token);\n+                break;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import java.util.Date;\n+\n+/**\n+  * This is a temporary implementation. TypeHandler will handle the\n+  * pluggableness of OptionTypes and it will direct all of these types\n+  * of conversion functionalities to ConvertUtils component in Commons\n+  * already. BeanUtils I think.\n+  *\n+  * @version $Revision$, $Date$\n+  */\n+public class TypeHandler\n+{\n+    /**\n+     * Returns the <code>Object</code> of type <code>obj</code>\n+     * with the value of <code>str</code>.\n+     *\n+     * @param str the command line value\n+     * @param obj the type of argument\n+     * @return The instance of <code>obj</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Object obj)\n+    throws ParseException\n+    {\n+        return createValue(str, (Class) obj);\n+    }\n+\n+    /**\n+     * Returns the <code>Object</code> of type <code>clazz</code>\n+     * with the value of <code>str</code>.\n+     *\n+     * @param str the command line value\n+     * @param clazz the type of argument\n+     * @return The instance of <code>clazz</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Class clazz)\n+    throws ParseException\n+    {\n+        if (PatternOptionBuilder.STRING_VALUE == clazz)\n+        {\n+            return str;\n+        }\n+        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n+        {\n+            return createObject(str);\n+        }\n+        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n+        {\n+            return createNumber(str);\n+        }\n+        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n+        {\n+            return createDate(str);\n+        }\n+        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n+        {\n+            return createClass(str);\n+        }\n+        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n+        {\n+            return createFile(str);\n+        }\n+        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n+        {\n+            return createFile(str);\n+        }\n+        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n+        {\n+            return createFiles(str);\n+        }\n+        else if (PatternOptionBuilder.URL_VALUE == clazz)\n+        {\n+            return createURL(str);\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+      * Create an Object from the classname and empty constructor.\n+      *\n+      * @param classname the argument value\n+      * @return the initialised object, or null if it couldn't create\n+      * the Object.\n+      */\n+    public static Object createObject(String classname)\n+    throws ParseException\n+    {\n+        Class cl = null;\n+\n+        try\n+        {\n+            cl = Class.forName(classname);\n+        }\n+        catch (ClassNotFoundException cnfe)\n+        {\n+            throw new ParseException(\"Unable to find the class: \" + classname);\n+        }\n+\n+        Object instance = null;\n+\n+        try\n+        {\n+            instance = cl.newInstance();\n+        }\n+        catch (Exception e)\n+        {\n+            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n+        }\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * Create a number from a String. If a . is present, it creates a\n+     * Double, otherwise a Long.\n+     *\n+     * @param str the value\n+     * @return the number represented by <code>str</code>, if <code>str</code>\n+     * is not a number, null is returned.\n+     */\n+    public static Number createNumber(String str)\n+    throws ParseException\n+    {\n+        try\n+        {\n+            if (str.indexOf('.') != -1)\n+            {\n+                return Double.valueOf(str);\n+            }\n+            else\n+            {\n+                return Long.valueOf(str);\n+            }\n+        }\n+        catch (NumberFormatException e)\n+        {\n+            throw new ParseException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Returns the class whose name is <code>classname</code>.\n+     *\n+     * @param classname the class name\n+     * @return The class if it is found, otherwise return null\n+     */\n+    public static Class createClass(String classname)\n+    throws ParseException\n+    {\n+        try\n+        {\n+            return Class.forName(classname);\n+        }\n+        catch (ClassNotFoundException e)\n+        {\n+            throw new ParseException(\"Unable to find the class: \" + classname);\n+        }\n+    }\n+\n+    /**\n+     * Returns the date represented by <code>str</code>.\n+     *\n+     * @param str the date string\n+     * @return The date if <code>str</code> is a valid date string,\n+     * otherwise return null.\n+     */\n+    public static Date createDate(String str)\n+    throws ParseException\n+    {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n+    }\n+\n+    /**\n+     * Returns the URL represented by <code>str</code>.\n+     *\n+     * @param str the URL string\n+     * @return The URL is <code>str</code> is well-formed, otherwise\n+     * return null.\n+     */\n+    public static URL createURL(String str)\n+    throws ParseException\n+    {\n+        try\n+        {\n+            return new URL(str);\n+        }\n+        catch (MalformedURLException e)\n+        {\n+            throw new ParseException(\"Unable to parse the URL: \" + str);\n+        }\n+    }\n+\n+    /**\n+     * Returns the File represented by <code>str</code>.\n+     *\n+     * @param str the File location\n+     * @return The file represented by <code>str</code>.\n+     */\n+    public static File createFile(String str)\n+    throws ParseException\n+    {\n+        return new File(str);\n+    }\n+\n+    /**\n+     * Returns the File[] represented by <code>str</code>.\n+     *\n+     * @param str the paths to the files\n+     * @return The File[] represented by <code>str</code>.\n+     */\n+    public static File[] createFiles(String str)\n+    throws ParseException\n+    {\n+        // to implement/port:\n+        //        return FileW.findFiles(str);\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Exception thrown during parsing signalling an unrecognized\n+ * option was seen.\n+ *\n+ * @author bob mcwhiter (bob @ werken.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class UnrecognizedOptionException extends ParseException\n+{\n+    /** The  unrecognized option */\n+    private String option;\n+\n+    /**\n+     * Construct a new <code>UnrecognizedArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public UnrecognizedOptionException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>UnrecognizedArgumentException</code>\n+     * with the specified option and detail message.\n+     *\n+     * @param message the detail message\n+     * @param option  the unrecognized option\n+     * @since 1.2\n+     */\n+    public UnrecognizedOptionException(String message, String option)\n+    {\n+        this(message);\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Returns the unrecognized option.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public String getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Util.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Contains useful helper methods for classes within this package.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+class Util\n+{\n+    /**\n+     * Remove the hyphens from the begining of <code>str</code> and\n+     * return the new String.\n+     *\n+     * @param str The string from which the hyphens should be removed.\n+     *\n+     * @return the new String.\n+     */\n+    static String stripLeadingHyphens(String str)\n+    {\n+        if (str == null)\n+        {\n+            return null;\n+        }\n+        if (str.startsWith(\"--\"))\n+        {\n+            return str.substring(2, str.length());\n+        }\n+        else if (str.startsWith(\"-\"))\n+        {\n+            return str.substring(1, str.length());\n+        }\n+\n+        return str;\n+    }\n+\n+    /**\n+     * Remove the leading and trailing quotes from <code>str</code>.\n+     * E.g. if str is '\"one two\"', then 'one two' is returned.\n+     *\n+     * @param str The string from which the leading and trailing quotes\n+     * should be removed.\n+     *\n+     * @return The string without the leading and trailing quotes.\n+     */\n+    static String stripLeadingAndTrailingQuotes(String str)\n+    {\n+        if (str.startsWith(\"\\\"\"))\n+        {\n+            str = str.substring(1, str.length());\n+        }\n+        if (str.endsWith(\"\\\"\"))\n+        {\n+            str = str.substring(0, str.length() - 1);\n+        }\n+        return str;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ApplicationTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * This is a collection of tests that test real world applications command lines.\n+ *\n+ * <p>\n+ * The following applications are tested:\n+ * <ul>\n+ *   <li>ls</li>\n+ *   <li>Ant</li>\n+ *   <li>Groovy</li>\n+ *   <li>man</li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ */\n+public class ApplicationTest extends TestCase {\n+\n+    public void testLs() throws Exception {\n+        // create the command line parser\n+        CommandLineParser parser = new PosixParser();\n+        Options options = new Options();\n+        options.addOption( \"a\", \"all\", false, \"do not hide entries starting with .\" );\n+        options.addOption( \"A\", \"almost-all\", false, \"do not list implied . and ..\" );\n+        options.addOption( \"b\", \"escape\", false, \"print octal escapes for nongraphic characters\" );\n+        options.addOption( OptionBuilder.withLongOpt( \"block-size\" )\n+                                        .withDescription( \"use SIZE-byte blocks\" )\n+                                        .hasArg()\n+                                        .withArgName(\"SIZE\")\n+                                        .create() );\n+        options.addOption( \"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n+        options.addOption( \"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with -l:show ctime and sort by name otherwise: sort by ctime\" );\n+        options.addOption( \"C\", false, \"list entries by columns\" );\n+\n+        String[] args = new String[]{ \"--block-size=10\" };\n+\n+        CommandLine line = parser.parse( options, args );\n+        assertTrue( line.hasOption( \"block-size\" ) );\n+        assertEquals( line.getOptionValue( \"block-size\" ), \"10\" );\n+    }\n+\n+    /**\n+     * Ant test\n+     */\n+    public void testAnt() throws Exception {\n+        // use the GNU parser\n+        CommandLineParser parser = new GnuParser( );\n+        Options options = new Options();\n+        options.addOption( \"help\", false, \"print this message\" );\n+        options.addOption( \"projecthelp\", false, \"print project help information\" );\n+        options.addOption( \"version\", false, \"print the version information and exit\" );\n+        options.addOption( \"quiet\", false, \"be extra quiet\" );\n+        options.addOption( \"verbose\", false, \"be extra verbose\" );\n+        options.addOption( \"debug\", false, \"print debug information\" );\n+        options.addOption( \"logfile\", true, \"use given file for log\" );\n+        options.addOption( \"logger\", true, \"the class which is to perform the logging\" );\n+        options.addOption( \"listener\", true, \"add an instance of a class as a project listener\" );\n+        options.addOption( \"buildfile\", true, \"use given buildfile\" );\n+        options.addOption( OptionBuilder.withDescription( \"use value for given property\" )\n+                                        .hasArgs()\n+                                        .withValueSeparator()\n+                                        .create( 'D' ) );\n+                           //, null, true, , false, true );\n+        options.addOption( \"find\", true, \"search for buildfile towards the root of the filesystem and use it\" );\n+\n+        String[] args = new String[]{ \"-buildfile\", \"mybuild.xml\",\n+            \"-Dproperty=value\", \"-Dproperty1=value1\",\n+            \"-projecthelp\" };\n+\n+        CommandLine line = parser.parse( options, args );\n+\n+        // check multiple values\n+        String[] opts = line.getOptionValues( \"D\" );\n+        assertEquals( \"property\", opts[0] );\n+        assertEquals( \"value\", opts[1] );\n+        assertEquals( \"property1\", opts[2] );\n+        assertEquals( \"value1\", opts[3] );\n+\n+        // check single value\n+        assertEquals( line.getOptionValue( \"buildfile\"), \"mybuild.xml\" );\n+\n+        // check option\n+        assertTrue( line.hasOption( \"projecthelp\") );\n+    }\n+\n+    public void testGroovy() throws Exception {\n+        Options options = new Options();\n+\n+        options.addOption(\n+            OptionBuilder.withLongOpt(\"define\").\n+                withDescription(\"define a system property\").\n+                hasArg(true).\n+                withArgName(\"name=value\").\n+                create('D'));\n+        options.addOption(\n+            OptionBuilder.hasArg(false)\n+            .withDescription(\"usage information\")\n+            .withLongOpt(\"help\")\n+            .create('h'));\n+        options.addOption(\n+            OptionBuilder.hasArg(false)\n+            .withDescription(\"debug mode will print out full stack traces\")\n+            .withLongOpt(\"debug\")\n+            .create('d'));\n+        options.addOption(\n+            OptionBuilder.hasArg(false)\n+            .withDescription(\"display the Groovy and JVM versions\")\n+            .withLongOpt(\"version\")\n+            .create('v'));\n+        options.addOption(\n+            OptionBuilder.withArgName(\"charset\")\n+            .hasArg()\n+            .withDescription(\"specify the encoding of the files\")\n+            .withLongOpt(\"encoding\")\n+            .create('c'));\n+        options.addOption(\n+            OptionBuilder.withArgName(\"script\")\n+            .hasArg()\n+            .withDescription(\"specify a command line script\")\n+            .create('e'));\n+        options.addOption(\n+            OptionBuilder.withArgName(\"extension\")\n+            .hasOptionalArg()\n+            .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n+            .create('i'));\n+        options.addOption(\n+            OptionBuilder.hasArg(false)\n+            .withDescription(\"process files line by line using implicit 'line' variable\")\n+            .create('n'));\n+        options.addOption(\n+            OptionBuilder.hasArg(false)\n+            .withDescription(\"process files line by line and print result (see also -n)\")\n+            .create('p'));\n+        options.addOption(\n+            OptionBuilder.withArgName(\"port\")\n+            .hasOptionalArg()\n+            .withDescription(\"listen on a port and process inbound lines\")\n+            .create('l'));\n+        options.addOption(\n+            OptionBuilder.withArgName(\"splitPattern\")\n+            .hasOptionalArg()\n+            .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n+            .withLongOpt(\"autosplit\")\n+            .create('a'));\n+\n+        Parser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-e\", \"println 'hello'\" }, true);\n+\n+        assertTrue(line.hasOption('e'));\n+        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n+    }\n+\n+    /**\n+     * author Slawek Zachcial\n+     */\n+    public void testMan()\n+    {\n+        String cmdLine =\n+                \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] \" +\n+                        \"[-msystem] [-pstring] [-Llocale] [-eextension] [section] page ...\";\n+        Options options = new Options().\n+                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n+                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n+                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n+                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n+                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n+                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n+                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local filename(s)\").\n+                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n+                //FIXME - should generate -r,--prompt string\n+                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n+                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n+                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n+                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n+                //FIXME - should generate -T,--troff-device device\n+                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n+                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n+                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n+                //FIXME - should generate -M,--manpath path\n+                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n+                //FIXME - should generate -P,--pager pager\n+                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n+                //FIXME - should generate -S,--sections list\n+                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n+                //FIXME - should generate -m,--systems system\n+                addOption(\"m\", \"systems\", true, \"search for man pages from other unix system(s).\").\n+                //FIXME - should generate -L,--locale locale\n+                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n+                //FIXME - should generate -p,--preprocessor string\n+                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n+                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n+                         \" g - grap    r - refer   v - vgrind\").\n+                addOption(\"V\", \"version\", false, \"show version.\").\n+                addOption(\"h\", \"help\", false, \"show this usage message.\");\n+\n+        HelpFormatter hf = new HelpFormatter();\n+        //hf.printHelp(cmdLine, opts);\n+        hf.printHelp(60, cmdLine, null, options, null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ArgumentIsOptionTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+public class ArgumentIsOptionTest extends TestCase\n+{\n+    private Options options = null;\n+    private CommandLineParser parser = null;\n+\n+    public void setUp()\n+    {\n+        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n+\n+        parser = new PosixParser();\n+    }\n+\n+    public void testOptionAndOptionWithArgument() throws Exception\n+    {\n+        String[] args = new String[]{\n+                \"-p\",\n+                \"-attr\",\n+                \"p\"\n+        };\n+\n+        CommandLine cl = parser.parse(options, args);\n+        assertTrue(\"Confirm -p is set\", cl.hasOption(\"p\"));\n+        assertTrue(\"Confirm -attr is set\", cl.hasOption(\"attr\"));\n+        assertTrue(\"Confirm arg of -attr\", cl.getOptionValue(\"attr\").equals(\"p\"));\n+        assertTrue(\"Confirm all arguments recognized\", cl.getArgs().length == 0);\n+    }\n+\n+    public void testOptionWithArgument() throws Exception\n+    {\n+        String[] args = new String[]{\n+                \"-attr\",\n+                \"p\"\n+        };\n+\n+        CommandLine cl = parser.parse(options, args);\n+        assertFalse(\"Confirm -p is set\", cl.hasOption(\"p\"));\n+        assertTrue(\"Confirm -attr is set\", cl.hasOption(\"attr\"));\n+        assertTrue(\"Confirm arg of -attr\",\n+                cl.getOptionValue(\"attr\").equals(\"p\"));\n+        assertTrue(\"Confirm all arguments recognized\", cl.getArgs().length == 0);\n+    }\n+\n+    public void testOption() throws Exception\n+    {\n+        String[] args = new String[]{\n+                \"-p\"\n+        };\n+\n+        CommandLine cl = parser.parse(options, args);\n+        assertTrue(\"Confirm -p is set\", cl.hasOption(\"p\"));\n+        assertFalse(\"Confirm -attr is not set\", cl.hasOption(\"attr\"));\n+        assertTrue(\"Confirm all arguments recognized\", cl.getArgs().length == 0);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/BasicParserTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ */\n+public class BasicParserTest extends ParserTestCase\n+{\n+    public void setUp()\n+    {\n+        super.setUp();\n+        parser = new BasicParser();\n+    }\n+\n+    public void testPropertiesOption() throws Exception\n+    {\n+        // not supported by the BasicParser\n+    }\n+\n+    public void testShortWithEqual() throws Exception\n+    {\n+        // not supported by the BasicParser\n+    }\n+\n+    public void testShortWithoutEqual() throws Exception\n+    {\n+        // not supported by the BasicParser\n+    }\n+\n+    public void testLongWithEqual() throws Exception\n+    {\n+        // not supported by the BasicParser\n+    }\n+\n+    public void testLongWithEqualSingleDash() throws Exception\n+    {\n+        // not supported by the BasicParser\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/BugsTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Iterator;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+\n+public class BugsTest extends TestCase\n+{\n+    public void test11457() throws Exception\n+    {\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n+        String[] args = new String[]{\"--verbose\"};\n+\n+        CommandLineParser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse(options, args);\n+        assertTrue(cmd.hasOption(\"verbose\"));\n+    }\n+\n+    public void test11458() throws Exception\n+    {\n+        Options options = new Options();\n+        options.addOption( OptionBuilder.withValueSeparator( '=' ).hasArgs().create( 'D' ) );\n+        options.addOption( OptionBuilder.withValueSeparator( ':' ).hasArgs().create( 'p' ) );\n+        String[] args = new String[] { \"-DJAVA_HOME=/opt/java\" , \"-pfile1:file2:file3\" };\n+\n+        CommandLineParser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        String[] values = cmd.getOptionValues('D');\n+\n+        assertEquals(values[0], \"JAVA_HOME\");\n+        assertEquals(values[1], \"/opt/java\");\n+\n+        values = cmd.getOptionValues('p');\n+\n+        assertEquals(values[0], \"file1\");\n+        assertEquals(values[1], \"file2\");\n+        assertEquals(values[2], \"file3\");\n+\n+        Iterator iter = cmd.iterator();\n+        while (iter.hasNext())\n+        {\n+            Option opt = (Option) iter.next();\n+            switch (opt.getId())\n+            {\n+                case 'D':\n+                    assertEquals(opt.getValue(0), \"JAVA_HOME\");\n+                    assertEquals(opt.getValue(1), \"/opt/java\");\n+                    break;\n+                case 'p':\n+                    assertEquals(opt.getValue(0), \"file1\");\n+                    assertEquals(opt.getValue(1), \"file2\");\n+                    assertEquals(opt.getValue(2), \"file3\");\n+                    break;\n+                default:\n+                    fail(\"-D option not found\");\n+            }\n+        }\n+    }\n+\n+    public void test11680() throws Exception\n+    {\n+        Options options = new Options();\n+        options.addOption(\"f\", true, \"foobar\");\n+        options.addOption(\"m\", true, \"missing\");\n+        String[] args = new String[]{\"-f\", \"foo\"};\n+\n+        CommandLineParser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        cmd.getOptionValue(\"f\", \"default f\");\n+        cmd.getOptionValue(\"m\", \"default m\");\n+    }\n+\n+    public void test11456() throws Exception\n+    {\n+        // Posix \n+        Options options = new Options();\n+        options.addOption( OptionBuilder.hasOptionalArg().create( 'a' ) );\n+        options.addOption( OptionBuilder.hasArg().create( 'b' ) );\n+        String[] args = new String[] { \"-a\", \"-bvalue\" };\n+\n+        CommandLineParser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse( options, args );\n+        assertEquals( cmd.getOptionValue( 'b' ), \"value\" );\n+\n+        // GNU\n+        options = new Options();\n+        options.addOption( OptionBuilder.hasOptionalArg().create( 'a' ) );\n+        options.addOption( OptionBuilder.hasArg().create( 'b' ) );\n+        args = new String[] { \"-a\", \"-b\", \"value\" };\n+\n+        parser = new GnuParser();\n+\n+        cmd = parser.parse( options, args );\n+        assertEquals( cmd.getOptionValue( 'b' ), \"value\" );\n+    }\n+\n+    public void test12210() throws Exception\n+    {\n+        // create the main options object which will handle the first parameter\n+        Options mainOptions = new Options();\n+        // There can be 2 main exclusive options:  -exec|-rep\n+\n+        // Therefore, place them in an option group\n+\n+        String[] argv = new String[] { \"-exec\", \"-exec_opt1\", \"-exec_opt2\" };\n+        OptionGroup grp = new OptionGroup();\n+\n+        grp.addOption(new Option(\"exec\",false,\"description for this option\"));\n+\n+        grp.addOption(new Option(\"rep\",false,\"description for this option\"));\n+\n+        mainOptions.addOptionGroup(grp);\n+\n+        // for the exec option, there are 2 options...\n+        Options execOptions = new Options();\n+        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n+        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n+\n+        // similarly, for rep there are 2 options...\n+        Options repOptions = new Options();\n+        repOptions.addOption(\"repopto\", false, \"desc\");\n+        repOptions.addOption(\"repoptt\", false, \"desc\");\n+\n+        // create the parser\n+        GnuParser parser = new GnuParser();\n+\n+        // finally, parse the arguments:\n+\n+        // first parse the main options to see what the user has specified\n+        // We set stopAtNonOption to true so it does not touch the remaining\n+        // options\n+        CommandLine cmd = parser.parse(mainOptions,argv,true);\n+        // get the remaining options...\n+        argv = cmd.getArgs();\n+\n+        if(cmd.hasOption(\"exec\"))\n+        {\n+            cmd = parser.parse(execOptions,argv,false);\n+            // process the exec_op1 and exec_opt2...\n+            assertTrue( cmd.hasOption(\"exec_opt1\") );\n+            assertTrue( cmd.hasOption(\"exec_opt2\") );\n+        }\n+        else if(cmd.hasOption(\"rep\"))\n+        {\n+            cmd = parser.parse(repOptions,argv,false);\n+            // process the rep_op1 and rep_opt2...\n+        }\n+        else {\n+            fail( \"exec option not found\" );\n+        }\n+    }\n+\n+    public void test13425() throws Exception\n+    {\n+        Options options = new Options();\n+        Option oldpass = OptionBuilder.withLongOpt( \"old-password\" )\n+            .withDescription( \"Use this option to specify the old password\" )\n+            .hasArg()\n+            .create( 'o' );\n+        Option newpass = OptionBuilder.withLongOpt( \"new-password\" )\n+            .withDescription( \"Use this option to specify the new password\" )\n+            .hasArg()\n+            .create( 'n' );\n+\n+        String[] args = { \n+            \"-o\", \n+            \"-n\", \n+            \"newpassword\" \n+        };\n+\n+        options.addOption( oldpass );\n+        options.addOption( newpass );\n+\n+        Parser parser = new PosixParser();\n+\n+        try\n+        {\n+            parser.parse( options, args );\n+        }\n+        // catch the exception and leave the method\n+        catch( Exception exp )\n+        {\n+            assertTrue( exp != null );\n+            return;\n+        }\n+        fail( \"MissingArgumentException not caught.\" );\n+    }\n+\n+    public void test13666() throws Exception\n+    {\n+        Options options = new Options();\n+        Option dir = OptionBuilder.withDescription( \"dir\" ).hasArg().create( 'd' );\n+        options.addOption( dir );\n+        \n+        final PrintStream oldSystemOut = System.out;\n+        try\n+        {\n+            final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            final PrintStream print = new PrintStream(bytes);\n+            \n+            // capture this platform's eol symbol\n+            print.println();\n+            final String eol = bytes.toString();\n+            bytes.reset();\n+            \n+            System.setOut(new PrintStream(bytes));\n+\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp( \"dir\", options );\n+\n+            assertEquals(\"usage: dir\"+eol+\" -d <arg>   dir\"+eol,bytes.toString());\n+        }\n+        finally\n+        {\n+            System.setOut(oldSystemOut);\n+        }\n+    }\n+\n+    public void test13935() throws Exception\n+    {\n+        OptionGroup directions = new OptionGroup();\n+\n+        Option left = new Option( \"l\", \"left\", false, \"go left\" );\n+        Option right = new Option( \"r\", \"right\", false, \"go right\" );\n+        Option straight = new Option( \"s\", \"straight\", false, \"go straight\" );\n+        Option forward = new Option( \"f\", \"forward\", false, \"go forward\" );\n+        forward.setRequired( true );\n+\n+        directions.addOption( left );\n+        directions.addOption( right );\n+        directions.setRequired( true );\n+\n+        Options opts = new Options();\n+        opts.addOptionGroup( directions );\n+        opts.addOption( straight );\n+\n+        CommandLineParser parser = new PosixParser();\n+        boolean exception = false;\n+\n+        String[] args = new String[] {  };\n+        try\n+        {\n+            CommandLine line = parser.parse(opts, args);\n+        }\n+        catch (ParseException exp)\n+        {\n+            exception = true;\n+        }\n+\n+        if (!exception)\n+        {\n+            fail(\"Expected exception not caught.\");\n+        }\n+\n+        exception = false;\n+\n+        args = new String[] { \"-s\" };\n+        try\n+        {\n+            CommandLine line = parser.parse(opts, args);\n+        }\n+        catch (ParseException exp)\n+        {\n+            exception = true;\n+        }\n+\n+        if (!exception)\n+        {\n+            fail(\"Expected exception not caught.\");\n+        }\n+\n+        exception = false;\n+\n+        args = new String[] { \"-s\", \"-l\" };\n+        try\n+        {\n+            parser.parse(opts, args);\n+        }\n+        catch (ParseException exp)\n+        {\n+            fail(\"Unexpected exception: \" + exp.getClass().getName() + \":\" + exp.getMessage());\n+        }\n+\n+        opts.addOption( forward );\n+        args = new String[] { \"-s\", \"-l\", \"-f\" };\n+        try\n+        {\n+            parser.parse(opts, args);\n+        }\n+        catch (ParseException exp)\n+        {\n+            fail(\"Unexpected exception: \" + exp.getClass().getName() + \":\" + exp.getMessage());\n+        }\n+    }\n+\n+    public void test14786() throws Exception\n+    {\n+        Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n+        Options opts = new Options();\n+        opts.addOption(o);\n+        opts.addOption(o);\n+\n+        CommandLineParser parser = new GnuParser();\n+\n+        String[] args = new String[] { \"-test\" };\n+\n+        CommandLine line = parser.parse( opts, args );\n+        assertTrue( line.hasOption( \"test\" ) );\n+    }\n+\n+    public void test15046() throws Exception\n+    {\n+        CommandLineParser parser = new PosixParser();\n+        String[] CLI_ARGS = new String[] {\"-z\", \"c\"};\n+\n+        Options options = new Options();\n+        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n+\n+        parser.parse(options, CLI_ARGS);\n+        \n+        //now add conflicting option\n+        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n+        CommandLine line = parser.parse(options, CLI_ARGS);\n+        assertEquals( line.getOptionValue('z'), \"c\" );\n+        assertTrue( !line.hasOption(\"c\") );\n+    }\n+\n+    public void test15648() throws Exception\n+    {\n+        CommandLineParser parser = new PosixParser();\n+        final String[] args = new String[] { \"-m\", \"\\\"Two Words\\\"\" };\n+        Option m = OptionBuilder.hasArgs().create(\"m\");\n+        Options options = new Options();\n+        options.addOption( m );\n+        CommandLine line = parser.parse( options, args );\n+        assertEquals( \"Two Words\", line.getOptionValue( \"m\" ) );\n+    }\n+    \n+    public void test31148() throws ParseException\n+    {\n+        Option multiArgOption = new Option(\"o\",\"option with multiple args\");\n+        multiArgOption.setArgs(1);\n+        \n+        Options options = new Options();\n+        options.addOption(multiArgOption);\n+        \n+        Parser parser = new PosixParser();\n+        String[] args = new String[]{};\n+        Properties props = new Properties();\n+        props.setProperty(\"o\",\"ovalue\");\n+        CommandLine cl = parser.parse(options,args,props);\n+        \n+        assertTrue(cl.hasOption('o'));\n+        assertEquals(\"ovalue\",cl.getOptionValue('o'));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/CommandLineTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ */\n+public class CommandLineTest extends TestCase\n+{\n+    public void testGetOptionProperties() throws Exception\n+    {\n+        String[] args = new String[] { \"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n+        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).withLongOpt(\"property\").create());\n+\n+        Parser parser = new GnuParser();\n+        CommandLine cl = parser.parse(options, args);\n+\n+        Properties props = cl.getOptionProperties(\"D\");\n+        assertNotNull(\"null properties\", props);\n+        assertEquals(\"number of properties in \" + props, 4, props.size());\n+        assertEquals(\"property 1\", \"value1\", props.getProperty(\"param1\"));\n+        assertEquals(\"property 2\", \"value2\", props.getProperty(\"param2\"));\n+        assertEquals(\"property 3\", \"true\", props.getProperty(\"param3\"));\n+        assertEquals(\"property 4\", \"value4\", props.getProperty(\"param4\"));\n+\n+        assertEquals(\"property with long format\", \"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/GnuParserTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+public class GnuParserTest extends ParserTestCase\n+{\n+    public void setUp()\n+    {\n+        super.setUp();\n+        parser = new GnuParser();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/HelpFormatterTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Comparator;\n+\n+import junit.framework.TestCase;\n+\n+/** \n+ * Test case for the HelpFormatter class \n+ *\n+ * @author Slawek Zachcial\n+ * @author John Keyes ( john at integralsource.com )\n+ * @author brianegge\n+ */\n+public class HelpFormatterTest extends TestCase\n+{\n+    private static final String EOL = System.getProperty(\"line.separator\");\n+\n+    public void testFindWrapPos() throws Exception\n+    {\n+        HelpFormatter hf = new HelpFormatter();\n+\n+        String text = \"This is a test.\";\n+        //text width should be max 8; the wrap position is 7\n+        assertEquals(\"wrap position\", 7, hf.findWrapPos(text, 8, 0));\n+        //starting from 8 must give -1 - the wrap pos is after end\n+        assertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n+        //if there is no a good position before width to make a wrapping look for the next one\n+        text = \"aaaa aa\";\n+        assertEquals(\"wrap position 3\", 4, hf.findWrapPos(text, 3, 0));\n+    }\n+\n+    public void testPrintWrapped() throws Exception\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        HelpFormatter hf = new HelpFormatter();\n+\n+        String text = \"This is a test.\";\n+\n+        String expected = \"This is a\" + hf.getNewLine() + \"test.\";\n+        hf.renderWrappedText(sb, 12, 0, text);\n+        assertEquals(\"single line text\", expected, sb.toString());\n+\n+        sb.setLength(0);\n+        expected = \"This is a\" + hf.getNewLine() + \"    test.\";\n+        hf.renderWrappedText(sb, 12, 4, text);\n+        assertEquals(\"single line padded text\", expected, sb.toString());\n+\n+        text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n+               \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n+\n+        sb.setLength(0);\n+        expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" +\n+                hf.getNewLine() +\n+                \"                        form DATE[-DATE] where DATE\" +\n+                hf.getNewLine() +\n+                \"                        has form YYYY[MM[DD]]\";\n+        hf.renderWrappedText(sb, 53, 24, text);\n+        assertEquals(\"single line padded text 2\", expected, sb.toString());\n+\n+        text = \"aaaa aaaa aaaa\" + hf.getNewLine() +\n+               \"aaaaaa\" + hf.getNewLine() +\n+               \"aaaaa\";\n+\n+        expected = text;\n+        sb.setLength(0);\n+        hf.renderWrappedText(sb, 16, 0, text);\n+        assertEquals(\"multi line text\", expected, sb.toString());\n+\n+        expected = \"aaaa aaaa aaaa\" + hf.getNewLine() +\n+                   \"    aaaaaa\" + hf.getNewLine() +\n+                   \"    aaaaa\";\n+        sb.setLength(0);\n+        hf.renderWrappedText(sb, 16, 4, text);\n+        assertEquals(\"multi-line padded text\", expected, sb.toString());\n+    }\n+\n+    public void testPrintOptions() throws Exception\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        HelpFormatter hf = new HelpFormatter();\n+        final int leftPad = 1;\n+        final int descPad = 3;\n+        final String lpad = hf.createPadding(leftPad);\n+        final String dpad = hf.createPadding(descPad);\n+        Options options = null;\n+        String expected = null;\n+\n+        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n+        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n+        hf.renderOptions(sb, 60, options, leftPad, descPad);\n+        assertEquals(\"simple non-wrapped option\", expected, sb.toString());\n+\n+        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n+        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + hf.getNewLine() +\n+                   hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n+        sb.setLength(0);\n+        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n+        assertEquals(\"simple wrapped option\", expected, sb.toString());\n+\n+\n+        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n+        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n+        sb.setLength(0);\n+        hf.renderOptions(sb, 60, options, leftPad, descPad);\n+        assertEquals(\"long non-wrapped option\", expected, sb.toString());\n+\n+        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n+        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.getNewLine() +\n+                   hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n+        sb.setLength(0);\n+        hf.renderOptions(sb, 25, options, leftPad, descPad);\n+        assertEquals(\"long wrapped option\", expected, sb.toString());\n+\n+        options = new Options().\n+                addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").\n+                addOption(\"b\", false, \"feeee eeee eeee eeee\");\n+        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.getNewLine() +\n+                   hf.createPadding(nextLineTabStop) + \"dddd dddd\" + hf.getNewLine() +\n+                   lpad + \"-b      \" + dpad + \"feeee eeee\" + hf.getNewLine() +\n+                   hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n+        sb.setLength(0);\n+        hf.renderOptions(sb, 25, options, leftPad, descPad);\n+        assertEquals(\"multiple wrapped options\", expected, sb.toString());\n+    }\n+\n+    public void testPrintHelpWithEmptySyntax()\n+    {\n+        HelpFormatter formatter = new HelpFormatter();\n+        try\n+        {\n+            formatter.printHelp(null, new Options());\n+            fail(\"null command line syntax should be rejected\");\n+        }\n+        catch (IllegalArgumentException e)\n+        {\n+            // expected\n+        }\n+\n+        try\n+        {\n+            formatter.printHelp(\"\", new Options());\n+            fail(\"empty command line syntax should be rejected\");\n+        }\n+        catch (IllegalArgumentException e)\n+        {\n+            // expected\n+        }\n+    }\n+\n+    public void testAutomaticUsage() throws Exception\n+    {\n+        HelpFormatter hf = new HelpFormatter();\n+        Options options = null;\n+        String expected = \"usage: app [-a]\";\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        PrintWriter pw = new PrintWriter(out);\n+\n+        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n+        hf.printUsage(pw, 60, \"app\", options);\n+        pw.flush();\n+        assertEquals(\"simple auto usage\", expected, out.toString().trim());\n+        out.reset();\n+\n+        expected = \"usage: app [-a] [-b]\";\n+        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\")\n+                .addOption(\"b\", false, \"bbb\");\n+        hf.printUsage(pw, 60, \"app\", options);\n+        pw.flush();\n+        assertEquals(\"simple auto usage\", expected, out.toString().trim());\n+        out.reset();\n+    }\n+\n+    // This test ensures the options are properly sorted\n+    // See https://issues.apache.org/jira/browse/CLI-131\n+    public void testPrintUsage()\n+    {\n+        Option optionA = new Option(\"a\", \"first\");\n+        Option optionB = new Option(\"b\", \"second\");\n+        Option optionC = new Option(\"c\", \"third\");\n+        Options opts = new Options();\n+        opts.addOption(optionA);\n+        opts.addOption(optionB);\n+        opts.addOption(optionC);\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n+        PrintWriter printWriter = new PrintWriter(bytesOut);\n+        helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n+        printWriter.close();\n+        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n+    }\n+\n+    // uses the test for CLI-131 to implement CLI-155\n+    public void testPrintSortedUsage()\n+    {\n+        Options opts = new Options();\n+        opts.addOption(new Option(\"a\", \"first\"));\n+        opts.addOption(new Option(\"b\", \"second\"));\n+        opts.addOption(new Option(\"c\", \"third\"));\n+\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        helpFormatter.setOptionComparator(new Comparator()\n+        {\n+            public int compare(Object o1, Object o2)\n+            {\n+                // reverses the fuctionality of the default comparator\n+                Option opt1 = (Option) o1;\n+                Option opt2 = (Option) o2;\n+                return opt2.getKey().compareToIgnoreCase(opt1.getKey());\n+            }\n+        });\n+\n+        StringWriter out = new StringWriter();\n+        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n+\n+        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n+    }\n+\n+    public void testPrintSortedUsageWithNullComparator()\n+    {\n+        Options opts = new Options();\n+        opts.addOption(new Option(\"a\", \"first\"));\n+        opts.addOption(new Option(\"b\", \"second\"));\n+        opts.addOption(new Option(\"c\", \"third\"));\n+\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        helpFormatter.setOptionComparator(null);\n+\n+        StringWriter out = new StringWriter();\n+        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n+\n+        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, out.toString());\n+    }\n+\n+    public void testPrintOptionGroupUsage()\n+    {\n+        OptionGroup group = new OptionGroup();\n+        group.addOption(OptionBuilder.create(\"a\"));\n+        group.addOption(OptionBuilder.create(\"b\"));\n+        group.addOption(OptionBuilder.create(\"c\"));\n+\n+        Options options = new Options();\n+        options.addOptionGroup(group);\n+\n+        StringWriter out = new StringWriter();\n+\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n+\n+        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n+    }\n+\n+    public void testPrintRequiredOptionGroupUsage()\n+    {\n+        OptionGroup group = new OptionGroup();\n+        group.addOption(OptionBuilder.create(\"a\"));\n+        group.addOption(OptionBuilder.create(\"b\"));\n+        group.addOption(OptionBuilder.create(\"c\"));\n+        group.setRequired(true);\n+\n+        Options options = new Options();\n+        options.addOptionGroup(group);\n+\n+        StringWriter out = new StringWriter();\n+\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n+\n+        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n+    }\n+\n+    public void testPrintOptionWithEmptyArgNameUsage()\n+    {\n+        Option option = new Option(\"f\", true, null);\n+        option.setArgName(\"\");\n+        option.setRequired(true);\n+\n+        Options options = new Options();\n+        options.addOption(option);\n+\n+        StringWriter out = new StringWriter();\n+\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n+\n+        assertEquals(\"usage: app -f\" + EOL, out.toString());\n+    }\n+\n+    public void testRtrim()\n+    {\n+        HelpFormatter formatter = new HelpFormatter();\n+\n+        assertEquals(null, formatter.rtrim(null));\n+        assertEquals(\"\", formatter.rtrim(\"\"));\n+        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n+    }\n+\n+    public void testAccessors()\n+    {\n+        HelpFormatter formatter = new HelpFormatter();\n+\n+        formatter.setArgName(\"argname\");\n+        assertEquals(\"arg name\", \"argname\", formatter.getArgName());\n+\n+        formatter.setDescPadding(3);\n+        assertEquals(\"desc padding\", 3, formatter.getDescPadding());\n+\n+        formatter.setLeftPadding(7);\n+        assertEquals(\"left padding\", 7, formatter.getLeftPadding());\n+\n+        formatter.setLongOptPrefix(\"~~\");\n+        assertEquals(\"long opt prefix\", \"~~\", formatter.getLongOptPrefix());\n+\n+        formatter.setNewLine(\"\\n\");\n+        assertEquals(\"new line\", \"\\n\", formatter.getNewLine());\n+\n+        formatter.setOptPrefix(\"~\");\n+        assertEquals(\"opt prefix\", \"~\", formatter.getOptPrefix());\n+\n+        formatter.setSyntaxPrefix(\"-> \");\n+        assertEquals(\"syntax prefix\", \"-> \", formatter.getSyntaxPrefix());\n+\n+        formatter.setWidth(80);\n+        assertEquals(\"width\", 80, formatter.getWidth());\n+    }\n+    \n+    public void testHeaderStartingWithLineSeparator()\n+    {\n+        // related to Bugzilla #21215\n+        Options options = new Options();\n+        HelpFormatter formatter = new HelpFormatter();\n+        String header = EOL + \"Header\";\n+        String footer = \"Footer\";\n+        StringWriter out = new StringWriter();\n+        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n+        assertEquals(\n+                \"usage: foobar\" + EOL +\n+                \"\" + EOL +\n+                \"Header\" + EOL +\n+                \"\" + EOL +\n+                \"Footer\" + EOL\n+                , out.toString());\n+    }\n+\n+    public void testOptionWithoutShortFormat()\n+    {\n+        // related to Bugzilla #19383 (CLI-67)\n+        Options options = new Options();\n+        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n+        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n+        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n+\n+        HelpFormatter formatter = new HelpFormatter();\n+        StringWriter out = new StringWriter();\n+        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n+        assertEquals(\n+                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n+                \"  -a,--aaa  aaaaaaa\" + EOL +\n+                \"     --bbb  bbbbbbb\" + EOL +\n+                \"  -c        ccccccc\" + EOL\n+                , out.toString());\n+    }\n+    \n+\n+    public void testOptionWithoutShortFormat2()\n+    {\n+        // related to Bugzilla #27635 (CLI-26)\n+        Option help = new Option(\"h\", \"help\", false, \"print this message\");\n+        Option version = new Option(\"v\", \"version\", false, \"print version information\");\n+        Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n+        Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n+        \n+        Option timeLimit = OptionBuilder.withLongOpt(\"limit\")\n+                                        .hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"Set time limit for execution, in mintues\")\n+                                        .create(\"l\");\n+        \n+        Option age = OptionBuilder.withLongOpt(\"age\")\n+                                        .hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"Age (in days) of cache item before being recomputed\")\n+                                        .create(\"a\");\n+        \n+        Option server = OptionBuilder.withLongOpt(\"server\")\n+                                        .hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"The NLT server address\")\n+                                        .create(\"s\");\n+        \n+        Option numResults = OptionBuilder.withLongOpt(\"results\")\n+                                        .hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"Number of results per item\")\n+                                        .create(\"r\");\n+        \n+        Option configFile = OptionBuilder.withLongOpt(\"config\")\n+                                        .hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"Use the specified configuration file\")\n+                                        .create();\n+        \n+        Options mOptions = new Options();\n+        mOptions.addOption(help);\n+        mOptions.addOption(version);\n+        mOptions.addOption(newRun);\n+        mOptions.addOption(trackerRun);\n+        mOptions.addOption(timeLimit);\n+        mOptions.addOption(age);\n+        mOptions.addOption(server);\n+        mOptions.addOption(numResults);\n+        mOptions.addOption(configFile);\n+        \n+        HelpFormatter formatter = new HelpFormatter();\n+        final String EOL = System.getProperty(\"line.separator\");\n+        StringWriter out = new StringWriter();\n+        formatter.printHelp(new PrintWriter(out),80,\"commandline\",\"header\",mOptions,2,2,\"footer\",true);\n+        assertEquals(\n+                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + EOL +\n+                \"       [-s <arg>] [-t] [-v]\" + EOL +\n+                \"header\"+EOL+\n+                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\"+EOL+\n+                \"     --config <arg>   Use the specified configuration file\"+EOL+\n+                \"  -h,--help           print this message\"+EOL+\n+                \"  -l,--limit <arg>    Set time limit for execution, in mintues\"+EOL+\n+                \"  -n,--new            Create NLT cache entries only for new items\"+EOL+\n+                \"  -r,--results <arg>  Number of results per item\"+EOL+\n+                \"  -s,--server <arg>   The NLT server address\"+EOL+\n+                \"  -t,--tracker        Create NLT cache entries only for tracker items\"+EOL+\n+                \"  -v,--version        print version information\"+EOL+\n+                \"footer\"+EOL\n+                ,out.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/OptionBuilderTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+public class OptionBuilderTest extends TestCase {\n+\n+    public void testCompleteOption( ) {\n+        Option simple = OptionBuilder.withLongOpt( \"simple option\")\n+                                     .hasArg( )\n+                                     .isRequired( )\n+                                     .hasArgs( )\n+                                     .withType( new Float( 10 ) )\n+                                     .withDescription( \"this is a simple option\" )\n+                                     .create( 's' );\n+\n+        assertEquals( \"s\", simple.getOpt() );\n+        assertEquals( \"simple option\", simple.getLongOpt() );\n+        assertEquals( \"this is a simple option\", simple.getDescription() );\n+        assertEquals( simple.getType().getClass(), Float.class );\n+        assertTrue( simple.hasArg() );\n+        assertTrue( simple.isRequired() );\n+        assertTrue( simple.hasArgs() );\n+    }\n+\n+    public void testTwoCompleteOptions( ) {\n+        Option simple = OptionBuilder.withLongOpt( \"simple option\")\n+                                     .hasArg( )\n+                                     .isRequired( )\n+                                     .hasArgs( )\n+                                     .withType( new Float( 10 ) )\n+                                     .withDescription( \"this is a simple option\" )\n+                                     .create( 's' );\n+\n+        assertEquals( \"s\", simple.getOpt() );\n+        assertEquals( \"simple option\", simple.getLongOpt() );\n+        assertEquals( \"this is a simple option\", simple.getDescription() );\n+        assertEquals( simple.getType().getClass(), Float.class );\n+        assertTrue( simple.hasArg() );\n+        assertTrue( simple.isRequired() );\n+        assertTrue( simple.hasArgs() );\n+\n+        simple = OptionBuilder.withLongOpt( \"dimple option\")\n+                              .hasArg( )\n+                              .withDescription( \"this is a dimple option\" )\n+                              .create( 'd' );\n+\n+        assertEquals( \"d\", simple.getOpt() );\n+        assertEquals( \"dimple option\", simple.getLongOpt() );\n+        assertEquals( \"this is a dimple option\", simple.getDescription() );\n+        assertNull( simple.getType() );\n+        assertTrue( simple.hasArg() );\n+        assertTrue( !simple.isRequired() );\n+        assertTrue( !simple.hasArgs() );\n+    }\n+\n+    public void testBaseOptionCharOpt() {\n+        Option base = OptionBuilder.withDescription( \"option description\")\n+                                   .create( 'o' );\n+\n+        assertEquals( \"o\", base.getOpt() );\n+        assertEquals( \"option description\", base.getDescription() );\n+        assertTrue( !base.hasArg() );\n+    }\n+\n+    public void testBaseOptionStringOpt() {\n+        Option base = OptionBuilder.withDescription( \"option description\")\n+                                   .create( \"o\" );\n+\n+        assertEquals( \"o\", base.getOpt() );\n+        assertEquals( \"option description\", base.getDescription() );\n+        assertTrue( !base.hasArg() );\n+    }\n+\n+    public void testSpecialOptChars() throws Exception\n+    {\n+        // '?'\n+        Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n+        assertEquals(\"?\", opt1.getOpt());\n+\n+        // '@'\n+        Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n+        assertEquals(\"@\", opt2.getOpt());\n+    }\n+\n+    public void testOptionArgNumbers()\n+    {\n+        Option opt = OptionBuilder.withDescription( \"option description\" )\n+                                  .hasArgs( 2 )\n+                                  .create( 'o' );\n+        assertEquals( 2, opt.getArgs() );\n+    }\n+\n+    public void testIllegalOptions() {\n+        // bad single character option\n+        try {\n+            OptionBuilder.withDescription( \"option description\" ).create( '\"' );\n+            fail( \"IllegalArgumentException not caught\" );\n+        }\n+        catch( IllegalArgumentException exp ) {\n+            // success\n+        }\n+\n+        // bad character in option string\n+        try {\n+            Option opt = OptionBuilder.create( \"opt`\" );\n+            fail( \"IllegalArgumentException not caught\" );\n+        }\n+        catch( IllegalArgumentException exp ) {\n+            // success\n+        }\n+\n+        // valid option \n+        try {\n+            Option opt = OptionBuilder.create( \"opt\" );\n+            // success\n+        }\n+        catch( IllegalArgumentException exp ) {\n+            fail( \"IllegalArgumentException caught\" );\n+        }\n+    }\n+\n+    public void testCreateIncompleteOption() {\n+        try\n+        {\n+            OptionBuilder.hasArg().create();\n+            fail(\"Incomplete option should be rejected\");\n+        }\n+        catch (IllegalArgumentException e)\n+        {\n+            // expected\n+            \n+            // implicitly reset the builder\n+            OptionBuilder.create( \"opt\" );\n+        }\n+    }\n+\n+    public void testBuilderIsResettedAlways() {\n+        try\n+        {\n+            OptionBuilder.withDescription(\"JUnit\").create('\"');\n+            fail(\"IllegalArgumentException expected\");\n+        }\n+        catch (IllegalArgumentException e)\n+        {\n+            // expected\n+        }\n+        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n+\n+        try\n+        {\n+            OptionBuilder.withDescription(\"JUnit\").create();\n+            fail(\"IllegalArgumentException expected\");\n+        }\n+        catch (IllegalArgumentException e)\n+        {\n+            // expected\n+        }\n+        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/OptionGroupTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$\n+ */\n+public class OptionGroupTest extends TestCase\n+{\n+    private Options _options = null;\n+    private CommandLineParser parser = new PosixParser();\n+\n+    public void setUp()\n+    {\n+        Option file = new Option( \"f\", \"file\", false, \"file to process\" );\n+        Option dir = new Option( \"d\", \"directory\", false, \"directory to process\" );\n+        OptionGroup group = new OptionGroup();\n+        group.addOption( file );\n+        group.addOption( dir );\n+        _options = new Options().addOptionGroup( group );\n+\n+        Option section = new Option( \"s\", \"section\", false, \"section to process\" );\n+        Option chapter = new Option( \"c\", \"chapter\", false, \"chapter to process\" );\n+        OptionGroup group2 = new OptionGroup();\n+        group2.addOption( section );\n+        group2.addOption( chapter );\n+\n+        _options.addOptionGroup( group2 );\n+\n+        Option importOpt = new Option( null, \"import\", false, \"section to process\" );\n+        Option exportOpt = new Option( null, \"export\", false, \"chapter to process\" );\n+        OptionGroup group3 = new OptionGroup();\n+        group3.addOption( importOpt );\n+        group3.addOption( exportOpt );\n+        _options.addOptionGroup( group3 );\n+\n+        _options.addOption( \"r\", \"revision\", false, \"revision number\" );\n+    }\n+\n+    public void testSingleOptionFromGroup() throws Exception\n+    {\n+        String[] args = new String[] { \"-f\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testSingleOption() throws Exception\n+    {\n+        String[] args = new String[] { \"-r\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is NOT set\", !cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testTwoValidOptions() throws Exception\n+    {\n+        String[] args = new String[] { \"-r\", \"-f\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testSingleLongOption() throws Exception\n+    {\n+        String[] args = new String[] { \"--file\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testTwoValidLongOptions() throws Exception\n+    {\n+        String[] args = new String[] { \"--revision\", \"--file\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is set\", cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testNoOptionsExtraArgs() throws Exception\n+    {\n+        String[] args = new String[] { \"arg1\", \"arg2\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+\n+        assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is NOT set\", !cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is NOT set\", !cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm TWO extra args\", cl.getArgList().size() == 2);\n+    }\n+\n+    public void testTwoOptionsFromGroup() throws Exception\n+    {\n+        String[] args = new String[] { \"-f\", \"-d\" };\n+\n+        try\n+        {\n+            parser.parse( _options, args);\n+            fail( \"two arguments from group not allowed\" );\n+        }\n+        catch (AlreadySelectedException e)\n+        {\n+            assertNotNull(\"null option group\", e.getOptionGroup());\n+            assertEquals(\"selected option\", \"f\", e.getOptionGroup().getSelected());\n+            assertEquals(\"option\", \"d\", e.getOption().getOpt());\n+        }\n+    }\n+\n+    public void testTwoLongOptionsFromGroup() throws Exception\n+    {\n+        String[] args = new String[] { \"--file\", \"--directory\" };\n+\n+        try\n+        {\n+            parser.parse(_options, args);\n+            fail( \"two arguments from group not allowed\" );\n+        }\n+        catch (AlreadySelectedException e)\n+        {\n+            assertNotNull(\"null option group\", e.getOptionGroup());\n+            assertEquals(\"selected option\", \"f\", e.getOptionGroup().getSelected());\n+            assertEquals(\"option\", \"d\", e.getOption().getOpt());\n+        }\n+    }\n+\n+    public void testTwoOptionsFromDifferentGroup() throws Exception\n+    {\n+        String[] args = new String[] { \"-f\", \"-s\" };\n+\n+        CommandLine cl = parser.parse( _options, args);\n+        assertTrue( \"Confirm -r is NOT set\", !cl.hasOption(\"r\") );\n+        assertTrue( \"Confirm -f is set\", cl.hasOption(\"f\") );\n+        assertTrue( \"Confirm -d is NOT set\", !cl.hasOption(\"d\") );\n+        assertTrue( \"Confirm -s is set\", cl.hasOption(\"s\") );\n+        assertTrue( \"Confirm -c is NOT set\", !cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm NO extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testValidLongOnlyOptions() throws Exception\n+    {\n+        CommandLine cl1 = parser.parse(_options, new String[]{\"--export\"});\n+        assertTrue(\"Confirm --export is set\", cl1.hasOption(\"export\"));\n+\n+        CommandLine cl2 = parser.parse(_options, new String[]{\"--import\"});\n+        assertTrue(\"Confirm --import is set\", cl2.hasOption(\"import\"));\n+    }\n+\n+    public void testToString()\n+    {\n+        OptionGroup group1 = new OptionGroup();\n+        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n+        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n+\n+        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n+            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n+        }\n+\n+        OptionGroup group2 = new OptionGroup();\n+        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n+        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n+\n+        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n+            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n+        }\n+    }\n+\n+    public void testGetNames()\n+    {\n+        OptionGroup group = new OptionGroup();\n+        group.addOption(OptionBuilder.create('a'));\n+        group.addOption(OptionBuilder.create('b'));\n+\n+        assertNotNull(\"null names\", group.getNames());\n+        assertEquals(2, group.getNames().size());\n+        assertTrue(group.getNames().contains(\"a\"));\n+        assertTrue(group.getNames().contains(\"b\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/OptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class OptionTest extends TestCase\n+{\n+    private static class TestOption extends Option\n+    {\n+        public TestOption(String opt, boolean hasArg, String description) throws IllegalArgumentException\n+        {\n+            super(opt, hasArg, description);\n+        }\n+\n+        public boolean addValue(String value)\n+        {\n+            addValueForProcessing(value);\n+            return true;\n+        }\n+    }\n+\n+    public void testClear()\n+    {\n+        TestOption option = new TestOption(\"x\", true, \"\");\n+        assertEquals(0, option.getValuesList().size());\n+        option.addValue(\"a\");\n+        assertEquals(1, option.getValuesList().size());\n+        option.clearValues();\n+        assertEquals(0, option.getValuesList().size());\n+    }\n+\n+    // See http://issues.apache.org/jira/browse/CLI-21\n+    public void testClone() throws CloneNotSupportedException\n+    {\n+        TestOption a = new TestOption(\"a\", true, \"\");\n+        TestOption b = (TestOption) a.clone();\n+        assertEquals(a, b);\n+        assertNotSame(a, b);\n+        a.setDescription(\"a\");\n+        assertEquals(\"\", b.getDescription());\n+        b.setArgs(2);\n+        b.addValue(\"b1\");\n+        b.addValue(\"b2\");\n+        assertEquals(1, a.getArgs());\n+        assertEquals(0, a.getValuesList().size());\n+        assertEquals(2, b.getValues().length);\n+    }\n+\n+    private static class DefaultOption extends Option\n+    {\n+        private final String defaultValue;\n+\n+        public DefaultOption(String opt, String description, String defaultValue) throws IllegalArgumentException\n+        {\n+            super(opt, true, description);\n+            this.defaultValue = defaultValue;\n+        }\n+\n+        public String getValue()\n+        {\n+            return super.getValue() != null ? super.getValue() : defaultValue;\n+        }\n+    }\n+\n+    public void testSubclass() throws CloneNotSupportedException\n+    {\n+        Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n+        Option clone = (Option) option.clone();\n+        assertEquals(\"myfile.txt\", clone.getValue());\n+        assertEquals(DefaultOption.class, clone.getClass());\n+    }\n+\n+    public void testHasArgName()\n+    {\n+        Option option = new Option(\"f\", null);\n+\n+        option.setArgName(null);\n+        assertFalse(option.hasArgName());\n+\n+        option.setArgName(\"\");\n+        assertFalse(option.hasArgName());\n+\n+        option.setArgName(\"file\");\n+        assertTrue(option.hasArgName());\n+    }\n+\n+    public void testHasArgs()\n+    {\n+        Option option = new Option(\"f\", null);\n+\n+        option.setArgs(0);\n+        assertFalse(option.hasArgs());\n+\n+        option.setArgs(1);\n+        assertFalse(option.hasArgs());\n+\n+        option.setArgs(10);\n+        assertTrue(option.hasArgs());\n+\n+        option.setArgs(Option.UNLIMITED_VALUES);\n+        assertTrue(option.hasArgs());\n+\n+        option.setArgs(Option.UNINITIALIZED);\n+        assertFalse(option.hasArgs());\n+    }\n+\n+    public void testGetValue()\n+    {\n+        Option option = new Option(\"f\", null);\n+        option.setArgs(Option.UNLIMITED_VALUES);\n+\n+        assertEquals(\"default\", option.getValue(\"default\"));\n+        assertEquals(null, option.getValue(0));\n+\n+        option.addValueForProcessing(\"foo\");\n+        \n+        assertEquals(\"foo\", option.getValue());\n+        assertEquals(\"foo\", option.getValue(0));\n+        assertEquals(\"foo\", option.getValue(\"default\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/OptionsTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Rob Oxspring roxspring@apache.org\n+ * @version $Revision$\n+ */\n+public class OptionsTest extends TestCase\n+{\n+    public void testSimple()\n+    {\n+        Options opts = new Options();\n+\n+        opts.addOption(\"a\", false, \"toggle -a\");\n+        opts.addOption(\"b\", true, \"toggle -b\");\n+\n+        assertTrue(opts.hasOption(\"a\"));\n+        assertTrue(opts.hasOption(\"b\"));\n+    }\n+\n+    public void testDuplicateSimple()\n+    {\n+        Options opts = new Options();\n+        opts.addOption(\"a\", false, \"toggle -a\");\n+        opts.addOption(\"a\", true, \"toggle -a*\");\n+\n+        assertEquals(\"last one in wins\", \"toggle -a*\", opts.getOption(\"a\").getDescription());\n+    }\n+\n+    public void testLong()\n+    {\n+        Options opts = new Options();\n+\n+        opts.addOption(\"a\", \"--a\", false, \"toggle -a\");\n+        opts.addOption(\"b\", \"--b\", true, \"set -b\");\n+\n+        assertTrue(opts.hasOption(\"a\"));\n+        assertTrue(opts.hasOption(\"b\"));\n+    }\n+\n+    public void testDuplicateLong()\n+    {\n+        Options opts = new Options();\n+        opts.addOption(\"a\", \"--a\", false, \"toggle -a\");\n+        opts.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n+        assertEquals(\"last one in wins\", \"toggle -a*\", opts.getOption(\"a\").getDescription());\n+    }\n+\n+    public void testHelpOptions()\n+    {\n+        Option longOnly1 = OptionBuilder.withLongOpt(\"long-only1\").create();\n+        Option longOnly2 = OptionBuilder.withLongOpt(\"long-only2\").create();\n+        Option shortOnly1 = OptionBuilder.create(\"1\");\n+        Option shortOnly2 = OptionBuilder.create(\"2\");\n+        Option bothA = OptionBuilder.withLongOpt(\"bothA\").create(\"a\");\n+        Option bothB = OptionBuilder.withLongOpt(\"bothB\").create(\"b\");\n+        \n+        Options options = new Options();\n+        options.addOption(longOnly1);\n+        options.addOption(longOnly2);\n+        options.addOption(shortOnly1);\n+        options.addOption(shortOnly2);\n+        options.addOption(bothA);\n+        options.addOption(bothB);\n+        \n+        Collection allOptions = new ArrayList();\n+        allOptions.add(longOnly1);\n+        allOptions.add(longOnly2);\n+        allOptions.add(shortOnly1);\n+        allOptions.add(shortOnly2);\n+        allOptions.add(bothA);\n+        allOptions.add(bothB);\n+        \n+        Collection helpOptions = options.helpOptions();\n+        \n+        assertTrue(\"Everything in all should be in help\", helpOptions.containsAll(allOptions));\n+        assertTrue(\"Everything in help should be in all\", allOptions.containsAll(helpOptions));        \n+    }\n+\n+    public void testMissingOptionException() throws ParseException\n+    {\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n+        try\n+        {\n+            new PosixParser().parse(options, new String[0]);\n+            fail(\"Expected MissingOptionException to be thrown\");\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            assertEquals(\"Missing required option: f\", e.getMessage());\n+        }\n+    }\n+\n+    public void testMissingOptionsException() throws ParseException\n+    {\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n+        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n+        try\n+        {\n+            new PosixParser().parse(options, new String[0]);\n+            fail(\"Expected MissingOptionException to be thrown\");\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            assertEquals(\"Missing required options: f, x\", e.getMessage());\n+        }\n+    }\n+\n+    public void testToString()\n+    {\n+        Options options = new Options();\n+        options.addOption(\"f\", \"foo\", true, \"Foo\");\n+        options.addOption(\"b\", \"bar\", false, \"Bar\");\n+\n+        String s = options.toString();\n+        assertNotNull(\"null string returned\", s);\n+        assertTrue(\"foo option missing\", s.toLowerCase().indexOf(\"foo\") != -1);\n+        assertTrue(\"bar option missing\", s.toLowerCase().indexOf(\"bar\") != -1);\n+    }\n+\n+    public void testGetOptionsGroups()\n+    {\n+        Options options = new Options();\n+\n+        OptionGroup group1 = new OptionGroup();\n+        group1.addOption(OptionBuilder.create('a'));\n+        group1.addOption(OptionBuilder.create('b'));\n+\n+        OptionGroup group2 = new OptionGroup();\n+        group2.addOption(OptionBuilder.create('x'));\n+        group2.addOption(OptionBuilder.create('y'));\n+\n+        options.addOptionGroup(group1);\n+        options.addOptionGroup(group2);\n+\n+        assertNotNull(options.getOptionGroups());\n+        assertEquals(2, options.getOptionGroups().size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ParseRequiredTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$\n+ */\n+public class ParseRequiredTest extends TestCase\n+{\n+    private Options _options = null;\n+    private CommandLineParser parser = new PosixParser();\n+\n+    public void setUp()\n+    {\n+        _options = new Options()\n+            .addOption(\"a\",\n+                       \"enable-a\",\n+                       false,\n+                       \"turn [a] on or off\")\n+            .addOption( OptionBuilder.withLongOpt( \"bfile\" )\n+                                     .hasArg()\n+                                     .isRequired()\n+                                     .withDescription( \"set the value of [b]\" )\n+                                     .create( 'b' ) );\n+    }\n+\n+    public void testWithRequiredOption() throws Exception\n+    {\n+        String[] args = new String[] {  \"-b\", \"file\" };\n+\n+        CommandLine cl = parser.parse(_options,args);\n+\n+        assertTrue( \"Confirm -a is NOT set\", !cl.hasOption(\"a\") );\n+        assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+        assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"file\") );\n+        assertTrue( \"Confirm NO of extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testOptionAndRequiredOption() throws Exception\n+    {\n+        String[] args = new String[] {  \"-a\", \"-b\", \"file\" };\n+\n+        CommandLine cl = parser.parse(_options,args);\n+\n+        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+        assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+        assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"file\") );\n+        assertTrue( \"Confirm NO of extra args\", cl.getArgList().size() == 0);\n+    }\n+\n+    public void testMissingRequiredOption()\n+    {\n+        String[] args = new String[] { \"-a\" };\n+\n+        try\n+        {\n+            CommandLine cl = parser.parse(_options,args);\n+            fail( \"exception should have been thrown\" );\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            assertEquals( \"Incorrect exception message\", \"Missing required option: b\", e.getMessage() );\n+            assertTrue(e.getMissingOptions().contains(\"b\"));\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( \"expected to catch MissingOptionException\" );\n+        }\n+    }\n+\n+    public void testMissingRequiredOptions()\n+    {\n+        String[] args = new String[] { \"-a\" };\n+\n+        _options.addOption( OptionBuilder.withLongOpt( \"cfile\" )\n+                                     .hasArg()\n+                                     .isRequired()\n+                                     .withDescription( \"set the value of [c]\" )\n+                                     .create( 'c' ) );\n+\n+        try\n+        {\n+            CommandLine cl = parser.parse(_options,args);\n+            fail( \"exception should have been thrown\" );\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            assertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );\n+            assertTrue(e.getMissingOptions().contains(\"b\"));\n+            assertTrue(e.getMissingOptions().contains(\"c\"));\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( \"expected to catch MissingOptionException\" );\n+        }\n+    }\n+\n+    public void testReuseOptionsTwice() throws Exception\n+    {\n+        Options opts = new Options();\n+\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n+\n+\t\tGnuParser parser = new GnuParser();\n+\n+        // first parsing\n+        parser.parse(opts, new String[] { \"-v\" });\n+\n+        try\n+        {\n+            // second parsing, with the same Options instance and an invalid command line\n+            parser.parse(opts, new String[0]);\n+            fail(\"MissingOptionException not thrown\");\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ParserTestCase.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract test case testing common parser features.\n+ *\n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ */\n+public abstract class ParserTestCase extends TestCase\n+{\n+    protected Parser parser;\n+\n+    protected Options options;\n+\n+    public void setUp()\n+    {\n+        options = new Options()\n+            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n+            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n+            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n+    }\n+\n+    public void testSimpleShort() throws Exception\n+    {\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertTrue(\"Confirm -a is set\", cl.hasOption(\"a\"));\n+        assertTrue(\"Confirm -b is set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\"));\n+        assertTrue(\"Confirm size of extra args\", cl.getArgList().size() == 2);\n+    }\n+\n+    public void testSimpleLong() throws Exception\n+    {\n+        String[] args = new String[] { \"--enable-a\",\n+                                       \"--bfile\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+        assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+        assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+        assertTrue( \"Confirm arg of --bfile\", cl.getOptionValue( \"bfile\" ).equals( \"toast\" ) );\n+        assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+    }\n+\n+    public void testMultiple() throws Exception\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foobar\",\n+                                       \"-b\", \"toast\" };\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertTrue(\"Confirm -c is set\", cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+\n+        cl = parser.parse(options, cl.getArgs());\n+\n+        assertTrue(\"Confirm -c is not set\", !cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm -b is set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\"));\n+        assertTrue(\"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+        assertTrue(\"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\"));\n+    }\n+\n+    public void testMultipleWithLong() throws Exception\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"foobar\",\n+                                       \"--bfile\", \"toast\" };\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertTrue(\"Confirm -c is set\", cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+\n+        cl = parser.parse(options, cl.getArgs());\n+\n+        assertTrue(\"Confirm -c is not set\", !cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm -b is set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\"));\n+        assertTrue(\"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+        assertTrue(\"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\"));\n+    }\n+\n+    public void testUnrecognizedOption() throws Exception\n+    {\n+        String[] args = new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            parser.parse(options, args);\n+            fail(\"UnrecognizedOptionException wasn't thrown\");\n+        }\n+        catch (UnrecognizedOptionException e)\n+        {\n+            assertEquals(\"-d\", e.getOption());\n+        }\n+    }    \n+\n+    public void testMissingArg() throws Exception\n+    {\n+        String[] args = new String[] { \"-b\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            parser.parse(options, args);\n+        }\n+        catch (MissingArgumentException e)\n+        {\n+            caught = true;\n+            assertEquals(\"option missing an argument\", \"b\", e.getOption().getOpt());\n+        }\n+\n+        assertTrue( \"Confirm MissingArgumentException caught\", caught );\n+    }\n+\n+    public void testDoubleDash() throws Exception\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"--\",\n+                                       \"-b\", \"toast\" };\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertTrue(\"Confirm -c is set\", cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm -b is not set\", !cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm 2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+    }\n+\n+    public void testSingleDash() throws Exception\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"-b\", \"-\",\n+                                       \"-a\",\n+                                       \"-\" };\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertTrue(\"Confirm -a is set\", cl.hasOption(\"a\"));\n+        assertTrue(\"Confirm -b is set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"-\"));\n+        assertTrue(\"Confirm 1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+        assertTrue(\"Confirm value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"-\"));\n+    }\n+\n+    public void testStopAtUnexpectedArg() throws Exception\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foober\",\n+                                       \"-b\",\n+                                       \"toast\" };\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertTrue(\"Confirm -c is set\", cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+    }\n+\n+   public void testStopAtExpectedArg() throws Exception\n+    {\n+        String[] args = new String[]{\"-b\", \"foo\"};\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+\n+        assertTrue(\"Confirm -b is set\", cl.hasOption('b'));\n+        assertEquals(\"Confirm -b is set\", \"foo\", cl.getOptionValue('b'));\n+        assertTrue(\"Confirm no extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 0);\n+    }\n+\n+    public void testStopAtNonOptionShort() throws Exception\n+    {\n+        String[] args = new String[]{\"-z\",\n+                                     \"-a\",\n+                                     \"-btoast\"};\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\n+        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+    }\n+\n+    public void testStopAtNonOptionLong() throws Exception\n+    {\n+        String[] args = new String[]{\"--zop==1\",\n+                                     \"-abtoast\",\n+                                     \"--b=bar\"};\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+\n+        assertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\n+        assertFalse(\"Confirm -b is not set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+    }\n+\n+    public void testNegativeArgument() throws Exception\n+    {\n+        String[] args = new String[] { \"-b\", \"-1\"} ;\n+\n+        CommandLine cl = parser.parse(options, args);\n+        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n+    }\n+\n+    public void testArgumentStartingWithHyphen() throws Exception\n+    {\n+        String[] args = new String[]{\"-b\", \"-foo\"};\n+\n+        CommandLine cl = parser.parse(options, args);\n+        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n+    }\n+\n+    public void testShortWithEqual() throws Exception\n+    {\n+        String[] args = new String[] { \"-f=bar\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n+    }\n+\n+    public void testShortWithoutEqual() throws Exception\n+    {\n+        String[] args = new String[] { \"-fbar\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n+    }\n+\n+    public void testLongWithEqual() throws Exception\n+    {\n+        String[] args = new String[] { \"--foo=bar\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n+    }\n+\n+    public void testLongWithEqualSingleDash() throws Exception\n+    {\n+        String[] args = new String[] { \"-foo=bar\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n+    }\n+\n+    public void testPropertiesOption() throws Exception\n+    {\n+        String[] args = new String[] { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n+\n+        Options options = new Options();\n+        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        List values = Arrays.asList(cl.getOptionValues(\"J\"));\n+        assertNotNull(\"null values\", values);\n+        assertEquals(\"number of values\", 4, values.size());\n+        assertEquals(\"value 1\", \"source\", values.get(0));\n+        assertEquals(\"value 2\", \"1.5\", values.get(1));\n+        assertEquals(\"value 3\", \"target\", values.get(2));\n+        assertEquals(\"value 4\", \"1.5\", values.get(3));\n+        List argsleft = cl.getArgList();\n+        assertEquals(\"Should be 1 arg left\",1,argsleft.size());\n+        assertEquals(\"Expecting foo\",\"foo\",argsleft.get(0));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Vector;\n+\n+import junit.framework.TestCase;\n+\n+/** \n+ * Test case for the PatternOptionBuilder class \n+ *\n+ * @version $Revision$, $Date$\n+ */\n+public class PatternOptionBuilderTest extends TestCase\n+{\n+    public void testSimplePattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n+        String[] args = new String[] {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://commons.apache.org\", \"-z\", \"Thu Jun 06 17:48:57 EDT 2002\", \"-m\", \"test*\"};\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, args);\n+\n+        assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n+        assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n+        assertEquals(\"object flag b\", new Vector(), line.getOptionObject(\"b\"));\n+        assertTrue(\"boolean true flag c\", line.hasOption(\"c\"));\n+        assertFalse(\"boolean false flag d\", line.hasOption(\"d\"));\n+        assertEquals(\"file flag e\", new File(\"build.xml\"), line.getOptionObject(\"e\"));\n+        assertEquals(\"class flag f\", Calendar.class, line.getOptionObject(\"f\"));\n+        assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\n+        assertEquals(\"url flag t\", new URL(\"http://commons.apache.org\"), line.getOptionObject(\"t\"));\n+\n+        // tests the char methods of CommandLine that delegate to the String methods\n+        assertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\n+        assertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\n+        assertEquals(\"object flag b\", new Vector(), line.getOptionObject('b'));\n+        assertTrue(\"boolean true flag c\", line.hasOption('c'));\n+        assertFalse(\"boolean false flag d\", line.hasOption('d'));\n+        assertEquals(\"file flag e\", new File(\"build.xml\"), line.getOptionObject('e'));\n+        assertEquals(\"class flag f\", Calendar.class, line.getOptionObject('f'));\n+        assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n'));\n+        assertEquals(\"url flag t\", new URL(\"http://commons.apache.org\"), line.getOptionObject('t'));\n+\n+        // FILES NOT SUPPORTED YET\n+        try {\n+            assertEquals(\"files flag m\", new File[0], line.getOptionObject('m'));\n+            fail(\"Multiple files are not supported yet, should have failed\");\n+        } catch(UnsupportedOperationException uoe) {\n+            // expected\n+        }\n+\n+        // DATES NOT SUPPORTED YET\n+        try {\n+            assertEquals(\"date flag z\", new Date(1023400137276L), line.getOptionObject('z'));\n+            fail(\"Date is not supported yet, should have failed\");\n+        } catch(UnsupportedOperationException uoe) {\n+            // expected\n+        }\n+    }\n+\n+    public void testEmptyPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"\");\n+        assertTrue(options.getOptions().isEmpty());\n+    }\n+\n+    public void testUntypedPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"abc\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-abc\" });\n+\n+        assertTrue(line.hasOption('a'));\n+        assertNull(\"value a\", line.getOptionObject('a'));\n+        assertTrue(line.hasOption('b'));\n+        assertNull(\"value b\", line.getOptionObject('b'));\n+        assertTrue(line.hasOption('c'));\n+        assertNull(\"value c\", line.getOptionObject('c'));\n+    }\n+\n+    public void testNumberPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\" });\n+\n+        assertEquals(\"n object class\", Long.class, line.getOptionObject(\"n\").getClass());\n+        assertEquals(\"n value\", new Long(1), line.getOptionObject(\"n\"));\n+\n+        assertEquals(\"d object class\", Double.class, line.getOptionObject(\"d\").getClass());\n+        assertEquals(\"d value\", new Double(2.1), line.getOptionObject(\"d\"));\n+\n+        assertNull(\"x object\", line.getOptionObject(\"x\"));\n+    }\n+\n+    public void testClassPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\" });\n+\n+        assertEquals(\"c value\", Calendar.class, line.getOptionObject(\"c\"));\n+        assertNull(\"d value\", line.getOptionObject(\"d\"));\n+    }\n+\n+    public void testObjectPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\" });\n+\n+        assertEquals(\"o value\", \"\", line.getOptionObject(\"o\"));\n+        assertNull(\"i value\", line.getOptionObject(\"i\"));\n+        assertNull(\"n value\", line.getOptionObject(\"n\"));\n+    }\n+\n+    public void testURLPattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-u\", \"http://commons.apache.org\", \"-v\", \"foo://commons.apache.org\" });\n+\n+        assertEquals(\"u value\", new URL(\"http://commons.apache.org\"), line.getOptionObject(\"u\"));\n+        assertNull(\"v value\", line.getOptionObject(\"v\"));\n+    }\n+\n+    public void testExistingFilePattern() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"f<\");\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine line = parser.parse(options, new String[] { \"-f\", \"test.properties\" });\n+\n+        assertEquals(\"f value\", new File(\"test.properties\"), line.getOptionObject(\"f\"));\n+\n+        // todo test if an error is returned if the file doesn't exists (when it's implemented)\n+    }\n+\n+    public void testRequiredOption() throws Exception\n+    {\n+        Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n+        CommandLineParser parser = new PosixParser();\n+\n+        try\n+        {\n+            parser.parse(options, new String[]{\"\"});\n+            fail(\"MissingOptionException wasn't thrown\");\n+        }\n+        catch (MissingOptionException e)\n+        {\n+            assertEquals(1, e.getMissingOptions().size());\n+            assertTrue(e.getMissingOptions().contains(\"n\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/PosixParserTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Test case for the PosixParser.\n+ *\n+ * @version $Revision$, $Date$\n+ */\n+public class PosixParserTest extends ParserTestCase\n+{\n+    public void setUp()\n+    {\n+        super.setUp();\n+        parser = new PosixParser();\n+    }\n+\n+    public void testBursting() throws Exception\n+    {\n+        String[] args = new String[] { \"-acbtoast\",\n+                                       \"foo\", \"bar\" };\n+\n+        CommandLine cl = parser.parse(options, args);\n+\n+        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+        assertTrue( \"Confirm -b is set\", cl.hasOption(\"b\") );\n+        assertTrue( \"Confirm -c is set\", cl.hasOption(\"c\") );\n+        assertTrue( \"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\") );\n+        assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+    }\n+\n+    public void testUnrecognizedOptionWithBursting() throws Exception\n+    {\n+        String[] args = new String[] { \"-adbtoast\", \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            parser.parse(options, args);\n+            fail(\"UnrecognizedOptionException wasn't thrown\");\n+        }\n+        catch (UnrecognizedOptionException e)\n+        {\n+            assertEquals(\"-adbtoast\", e.getOption());\n+        }\n+    }\n+\n+    public void testMissingArgWithBursting() throws Exception\n+    {\n+        String[] args = new String[] { \"-acb\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            parser.parse(options, args);\n+        }\n+        catch (MissingArgumentException e)\n+        {\n+            caught = true;\n+            assertEquals(\"option missing an argument\", \"b\", e.getOption().getOpt());\n+        }\n+\n+        assertTrue( \"Confirm MissingArgumentException caught\", caught );\n+    }\n+\n+    public void testStopBursting() throws Exception\n+    {\n+        String[] args = new String[] { \"-azc\" };\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n+        assertFalse( \"Confirm -c is not set\", cl.hasOption(\"c\") );\n+\n+        assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+        assertTrue(cl.getArgList().contains(\"zc\"));\n+    }\n+\n+    public void testStopBursting2() throws Exception\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foobar\",\n+                                       \"-btoast\" };\n+\n+        CommandLine cl = parser.parse(options, args, true);\n+        assertTrue(\"Confirm -c is set\", cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm  2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+\n+        cl = parser.parse(options, cl.getArgs());\n+\n+        assertTrue(\"Confirm -c is not set\", !cl.hasOption(\"c\"));\n+        assertTrue(\"Confirm -b is set\", cl.hasOption(\"b\"));\n+        assertTrue(\"Confirm arg of -b\", cl.getOptionValue(\"b\").equals(\"toast\"));\n+        assertTrue(\"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+        assertTrue(\"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\"));\n+    }\n+\n+    /**\n+     * Real world test with long and short options.\n+     */\n+    public void testLongOptionWithShort() throws Exception {\n+        Option help = new Option(\"h\", \"help\", false, \"print this message\");\n+        Option version = new Option(\"v\", \"version\", false, \"print version information\");\n+        Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n+        Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n+\n+        Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n+                                        .withValueSeparator()\n+                                        .withDescription(\"Set time limit for execution, in minutes\")\n+                                        .create(\"l\");\n+\n+        Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n+                                  .withValueSeparator()\n+                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n+                                  .create(\"a\");\n+\n+        Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n+                                     .withValueSeparator()\n+                                     .withDescription(\"The NLT server address\")\n+                                     .create(\"s\");\n+\n+        Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n+                                         .withValueSeparator()\n+                                         .withDescription(\"Number of results per item\")\n+                                         .create(\"r\");\n+\n+        Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n+                                         .withValueSeparator()\n+                                         .withDescription(\"Use the specified configuration file\")\n+                                         .create();\n+\n+        Options options = new Options();\n+        options.addOption(help);\n+        options.addOption(version);\n+        options.addOption(newRun);\n+        options.addOption(trackerRun);\n+        options.addOption(timeLimit);\n+        options.addOption(age);\n+        options.addOption(server);\n+        options.addOption(numResults);\n+        options.addOption(configFile);\n+\n+        // create the command line parser\n+        CommandLineParser parser = new PosixParser();\n+\n+        String[] args = new String[] {\n+                \"-v\",\n+                \"-l\",\n+                \"10\",\n+                \"-age\",\n+                \"5\",\n+                \"-file\",\n+                \"filename\"\n+            };\n+\n+        CommandLine line = parser.parse(options, args);\n+        assertTrue(line.hasOption(\"v\"));\n+        assertEquals(line.getOptionValue(\"l\"), \"10\");\n+        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n+        assertEquals(line.getOptionValue(\"a\"), \"5\");\n+        assertEquals(line.getOptionValue(\"age\"), \"5\");\n+        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n+    }\n+\n+    public void testLongWithEqualSingleDash() throws Exception\n+    {\n+        // not supported by the PosixParser\n+    }\n+\n+    public void testShortWithEqual() throws Exception\n+    {\n+        // not supported by the PosixParser\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/UtilTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class UtilTest extends TestCase\n+{\n+    public void testStripLeadingHyphens()\n+    {\n+        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n+        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n+        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n+        assertNull(Util.stripLeadingHyphens(null));\n+    }\n+\n+    public void testStripLeadingAndTrailingQuotes()\n+    {\n+        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ValueTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Arrays;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+\n+public class ValueTest extends TestCase\n+{\n+    private CommandLine _cl = null;\n+    private Options opts = new Options();\n+\n+    public void setUp() throws Exception\n+    {\n+        opts.addOption(\"a\", false, \"toggle -a\");\n+        opts.addOption(\"b\", true, \"set -b\");\n+        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n+        opts.addOption(\"d\", \"d\", true, \"set -d\");\n+\n+        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n+        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n+        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n+        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n+        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n+        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n+        opts.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n+\n+        String[] args = new String[] { \"-a\",\n+            \"-b\", \"foo\",\n+            \"--c\",\n+            \"--d\", \"bar\" \n+        };\n+\n+        Parser parser = new PosixParser();\n+        _cl = parser.parse(opts,args);\n+    }\n+\n+    public void testShortNoArg()\n+    {\n+        assertTrue( _cl.hasOption(\"a\") );\n+        assertNull( _cl.getOptionValue(\"a\") );\n+    }\n+\n+    public void testShortWithArg()\n+    {\n+        assertTrue( _cl.hasOption(\"b\") );\n+        assertNotNull( _cl.getOptionValue(\"b\") );\n+        assertEquals( _cl.getOptionValue(\"b\"), \"foo\");\n+    }\n+\n+    public void testLongNoArg()\n+    {\n+        assertTrue( _cl.hasOption(\"c\") );\n+        assertNull( _cl.getOptionValue(\"c\") );\n+    }\n+\n+    public void testLongWithArg()\n+    {\n+        assertTrue( _cl.hasOption(\"d\") );\n+        assertNotNull( _cl.getOptionValue(\"d\") );\n+        assertEquals( _cl.getOptionValue(\"d\"), \"bar\");\n+    }\n+\n+    public void testShortOptionalArgNoValue() throws Exception\n+    {\n+        String[] args = new String[] { \"-e\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"e\") );\n+        assertNull( cmd.getOptionValue(\"e\") );\n+    }\n+\n+    public void testShortOptionalArgValue() throws Exception\n+    {\n+        String[] args = new String[] { \"-e\", \"everything\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"e\") );\n+        assertEquals( \"everything\", cmd.getOptionValue(\"e\") );\n+    }\n+\n+    public void testLongOptionalNoValue() throws Exception\n+    {\n+        String[] args = new String[] { \"--fish\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"fish\") );\n+        assertNull( cmd.getOptionValue(\"fish\") );\n+    }\n+\n+    public void testLongOptionalArgValue() throws Exception\n+    {\n+        String[] args = new String[] { \"--fish\", \"face\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"fish\") );\n+        assertEquals( \"face\", cmd.getOptionValue(\"fish\") );\n+    }\n+\n+    public void testShortOptionalArgValues() throws Exception\n+    {\n+        String[] args = new String[] { \"-j\", \"ink\", \"idea\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"j\") );\n+        assertEquals( \"ink\", cmd.getOptionValue(\"j\") );\n+        assertEquals( \"ink\", cmd.getOptionValues(\"j\")[0] );\n+        assertEquals( \"idea\", cmd.getOptionValues(\"j\")[1] );\n+        assertEquals( cmd.getArgs().length, 0 );\n+    }\n+\n+    public void testLongOptionalArgValues() throws Exception\n+    {\n+        String[] args = new String[] { \"--gravy\", \"gold\", \"garden\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"gravy\") );\n+        assertEquals( \"gold\", cmd.getOptionValue(\"gravy\") );\n+        assertEquals( \"gold\", cmd.getOptionValues(\"gravy\")[0] );\n+        assertEquals( \"garden\", cmd.getOptionValues(\"gravy\")[1] );\n+        assertEquals( cmd.getArgs().length, 0 );\n+    }\n+\n+    public void testShortOptionalNArgValues() throws Exception\n+    {\n+        String[] args = new String[] { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"i\") );\n+        assertEquals( \"ink\", cmd.getOptionValue(\"i\") );\n+        assertEquals( \"ink\", cmd.getOptionValues(\"i\")[0] );\n+        assertEquals( \"idea\", cmd.getOptionValues(\"i\")[1] );\n+        assertEquals( cmd.getArgs().length, 2 );\n+        assertEquals( \"isotope\", cmd.getArgs()[0] );\n+        assertEquals( \"ice\", cmd.getArgs()[1] );\n+    }\n+\n+    public void testLongOptionalNArgValues() throws Exception\n+    {\n+        String[] args = new String[] { \n+            \"--hide\", \"house\", \"hair\", \"head\"\n+        };\n+\n+        Parser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse(opts,args);\n+        assertTrue( cmd.hasOption(\"hide\") );\n+        assertEquals( \"house\", cmd.getOptionValue(\"hide\") );\n+        assertEquals( \"house\", cmd.getOptionValues(\"hide\")[0] );\n+        assertEquals( \"hair\", cmd.getOptionValues(\"hide\")[1] );\n+        assertEquals( cmd.getArgs().length, 1 );\n+        assertEquals( \"head\", cmd.getArgs()[0] );\n+    }\n+\n+    public void testPropertyOptionSingularValue() throws Exception\n+    {\n+        Properties properties = new Properties();\n+        properties.setProperty( \"hide\", \"seek\" );\n+\n+        Parser parser = new PosixParser();\n+        \n+        CommandLine cmd = parser.parse(opts, null, properties);\n+        assertTrue( cmd.hasOption(\"hide\") );\n+        assertEquals( \"seek\", cmd.getOptionValue(\"hide\") );\n+        assertTrue( !cmd.hasOption(\"fake\") );\n+    }\n+\n+    public void testPropertyOptionFlags() throws Exception\n+    {\n+        Properties properties = new Properties();\n+        properties.setProperty( \"a\", \"true\" );\n+        properties.setProperty( \"c\", \"yes\" );\n+        properties.setProperty( \"e\", \"1\" );\n+\n+        Parser parser = new PosixParser();\n+\n+        CommandLine cmd = parser.parse(opts, null, properties);\n+        assertTrue( cmd.hasOption(\"a\") );\n+        assertTrue( cmd.hasOption(\"c\") );\n+        assertTrue( cmd.hasOption(\"e\") );\n+\n+\n+        properties = new Properties();\n+        properties.setProperty( \"a\", \"false\" );\n+        properties.setProperty( \"c\", \"no\" );\n+        properties.setProperty( \"e\", \"0\" );\n+\n+        cmd = parser.parse(opts, null, properties);\n+        assertTrue( !cmd.hasOption(\"a\") );\n+        assertTrue( !cmd.hasOption(\"c\") );\n+        assertTrue( !cmd.hasOption(\"e\") );\n+\n+\n+        properties = new Properties();\n+        properties.setProperty( \"a\", \"TRUE\" );\n+        properties.setProperty( \"c\", \"nO\" );\n+        properties.setProperty( \"e\", \"TrUe\" );\n+\n+        cmd = parser.parse(opts, null, properties);\n+        assertTrue( cmd.hasOption(\"a\") );\n+        assertTrue( !cmd.hasOption(\"c\") );\n+        assertTrue( cmd.hasOption(\"e\") );\n+\n+        \n+        properties = new Properties();\n+        properties.setProperty( \"a\", \"just a string\" );\n+        properties.setProperty( \"e\", \"\" );\n+\n+        cmd = parser.parse(opts, null, properties);\n+        assertTrue( !cmd.hasOption(\"a\") );\n+        assertTrue( !cmd.hasOption(\"c\") );\n+        assertTrue( !cmd.hasOption(\"e\") );\n+    } \n+\n+    public void testPropertyOptionMultipleValues() throws Exception\n+    {\n+        Properties properties = new Properties();\n+        properties.setProperty( \"k\", \"one,two\" );\n+\n+        Parser parser = new PosixParser();\n+        \n+        String[] values = new String[] {\n+            \"one\", \"two\"\n+        };\n+\n+        CommandLine cmd = parser.parse(opts, null, properties);\n+        assertTrue( cmd.hasOption(\"k\") );\n+        assertTrue( Arrays.equals( values, cmd.getOptionValues('k') ) );\n+    }\n+\n+    public void testPropertyOverrideValues() throws Exception\n+    {\n+        String[] args = new String[] { \n+            \"-j\",\n+            \"found\",\n+            \"-i\",\n+            \"ink\"\n+        };\n+\n+        Properties properties = new Properties();\n+        properties.setProperty( \"j\", \"seek\" );\n+\n+        Parser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(opts, args, properties);\n+        assertTrue( cmd.hasOption(\"j\") );\n+        assertEquals( \"found\", cmd.getOptionValue(\"j\") );\n+        assertTrue( cmd.hasOption(\"i\") );\n+        assertEquals( \"ink\", cmd.getOptionValue(\"i\") );\n+        assertTrue( !cmd.hasOption(\"fake\") );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ValuesTest.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+public class ValuesTest extends TestCase\n+{\n+    /** CommandLine instance */\n+    private CommandLine _cmdline = null;\n+\n+    public void setUp() throws Exception\n+    {\n+        Options options = new Options();\n+\n+        options.addOption(\"a\", false, \"toggle -a\");\n+        options.addOption(\"b\", true, \"set -b\");\n+        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n+        options.addOption(\"d\", \"d\", true, \"set -d\");\n+\n+        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n+        options.addOption(\"f\", \"f\", false, \"jk\");\n+        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n+        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArgs(2).withDescription(\"set -h\").create('h'));\n+        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n+        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n+        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n+        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n+\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"foo\",\n+                                       \"--c\",\n+                                       \"--d\", \"bar\",\n+                                       \"-e\", \"one\", \"two\",\n+                                       \"-f\",\n+                                       \"arg1\", \"arg2\",\n+                                       \"-g\", \"val1\", \"val2\" , \"arg3\",\n+                                       \"-h\", \"val1\", \"-i\",\n+                                       \"-h\", \"val2\",\n+                                       \"-jkey=value\",\n+                                       \"-j\", \"key=value\",\n+                                       \"-kkey1=value1\", \n+                                       \"-kkey2=value2\",\n+                                       \"-mkey=value\"};\n+\n+        CommandLineParser parser = new PosixParser();\n+\n+        _cmdline = parser.parse(options,args);\n+    }\n+\n+    public void testShortArgs()\n+    {\n+        assertTrue( _cmdline.hasOption(\"a\") );\n+        assertTrue( _cmdline.hasOption(\"c\") );\n+\n+        assertNull( _cmdline.getOptionValues(\"a\") );\n+        assertNull( _cmdline.getOptionValues(\"c\") );\n+    }\n+\n+    public void testShortArgsWithValue()\n+    {\n+        assertTrue( _cmdline.hasOption(\"b\") );\n+        assertTrue( _cmdline.getOptionValue(\"b\").equals(\"foo\"));\n+        assertEquals(1, _cmdline.getOptionValues(\"b\").length);\n+\n+        assertTrue( _cmdline.hasOption(\"d\") );\n+        assertTrue( _cmdline.getOptionValue(\"d\").equals(\"bar\"));\n+        assertEquals(1, _cmdline.getOptionValues(\"d\").length);\n+    }\n+\n+    public void testMultipleArgValues()\n+    {\n+        String[] result = _cmdline.getOptionValues(\"e\");\n+        String[] values = new String[] { \"one\", \"two\" };\n+        assertTrue( _cmdline.hasOption(\"e\") );\n+        assertEquals(2, _cmdline.getOptionValues(\"e\").length);\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues(\"e\") ) );\n+    }\n+\n+    public void testTwoArgValues()\n+    {\n+        String[] result = _cmdline.getOptionValues(\"g\");\n+        String[] values = new String[] { \"val1\", \"val2\" };\n+        assertTrue( _cmdline.hasOption(\"g\") );\n+        assertEquals(2, _cmdline.getOptionValues(\"g\").length);\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues(\"g\") ) );\n+    }\n+\n+    public void testComplexValues()\n+    {\n+        String[] result = _cmdline.getOptionValues(\"h\");\n+        String[] values = new String[] { \"val1\", \"val2\" };\n+        assertTrue( _cmdline.hasOption(\"i\") );\n+        assertTrue( _cmdline.hasOption(\"h\") );\n+        assertEquals(2, _cmdline.getOptionValues(\"h\").length);\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues(\"h\") ) );\n+    }\n+\n+    public void testExtraArgs()\n+    {\n+        String[] args = new String[] { \"arg1\", \"arg2\", \"arg3\" };\n+        assertEquals(3, _cmdline.getArgs().length);\n+        assertTrue( Arrays.equals( args, _cmdline.getArgs() ) );\n+    }\n+\n+    public void testCharSeparator()\n+    {\n+        // tests the char methods of CommandLine that delegate to\n+        // the String methods\n+        String[] values = new String[] { \"key\", \"value\", \"key\", \"value\" };\n+        assertTrue( _cmdline.hasOption( \"j\" ) );\n+        assertTrue( _cmdline.hasOption( 'j' ) );\n+        assertEquals( 4, _cmdline.getOptionValues( \"j\" ).length );\n+        assertEquals( 4, _cmdline.getOptionValues( 'j' ).length );\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( \"j\" ) ) );\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( 'j' ) ) );\n+\n+        values = new String[] { \"key1\", \"value1\", \"key2\", \"value2\" };\n+        assertTrue( _cmdline.hasOption( \"k\" ) );\n+        assertTrue( _cmdline.hasOption( 'k' ) );\n+        assertEquals(4, _cmdline.getOptionValues( \"k\" ).length);\n+        assertEquals(4, _cmdline.getOptionValues( 'k' ).length);\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( \"k\" ) ) );\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( 'k' ) ) );\n+\n+        values = new String[] { \"key\", \"value\" };\n+        assertTrue( _cmdline.hasOption( \"m\" ) );\n+        assertTrue( _cmdline.hasOption( 'm' ) );\n+        assertEquals(2, _cmdline.getOptionValues( \"m\" ).length);\n+        assertEquals(2, _cmdline.getOptionValues( 'm' ).length);\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( \"m\" ) ) );\n+        assertTrue( Arrays.equals( values, _cmdline.getOptionValues( 'm' ) ) );\n+    }\n+\n+    /**\n+     * jkeyes - commented out this test as the new architecture\n+     * breaks this type of functionality.  I have left the test \n+     * here in case I get a brainwave on how to resolve this.\n+     */\n+    /*\n+    public void testGetValue()\n+    {\n+        // the 'm' option\n+        assertTrue( _option.getValues().length == 2 );\n+        assertEquals( _option.getValue(), \"key\" );\n+        assertEquals( _option.getValue( 0 ), \"key\" );\n+        assertEquals( _option.getValue( 1 ), \"value\" );\n+\n+        try {\n+            assertEquals( _option.getValue( 2 ), \"key\" );\n+            fail( \"IndexOutOfBounds not caught\" );\n+        }\n+        catch( IndexOutOfBoundsException exp ) {\n+            \n+        }\n+\n+        try {\n+            assertEquals( _option.getValue( -1 ), \"key\" );\n+            fail( \"IndexOutOfBounds not caught\" );\n+        }\n+        catch( IndexOutOfBoundsException exp ) {\n+\n+        }\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI133Test.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli.bug;\n+\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.cli.PosixParser;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class BugCLI133Test extends TestCase {\n+    public void testOrder() throws ParseException {\n+        Option optionA = new Option(\"a\", \"first\");\n+        Options opts = new Options();\n+        opts.addOption(optionA);\n+        PosixParser posixParser = new PosixParser();\n+        CommandLine line = posixParser.parse(opts, null);\n+        assertFalse(line.hasOption(null));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI13Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli.bug;\n+\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.cli.PosixParser;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class BugCLI13Test extends TestCase\n+{\n+    public void testCLI13() throws ParseException\n+    {\n+        final String debugOpt = \"debug\";\n+        Option debug = OptionBuilder\n+            .withArgName( debugOpt )\n+            .withDescription( \"turn on debugging\" )\n+            .withLongOpt( debugOpt )\n+            .hasArg()\n+            .create( 'd' );\n+        Options options = new Options();\n+        options.addOption( debug );\n+        CommandLine commandLine = new PosixParser().parse( options, new String[]{\"-d\", \"true\"} );\n+\n+        assertEquals(\"true\", commandLine.getOptionValue( debugOpt ));\n+        assertEquals(\"true\", commandLine.getOptionValue( 'd' ));\n+        assertTrue(commandLine.hasOption( 'd'));\n+        assertTrue(commandLine.hasOption( debugOpt));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI148Test.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli.bug;\n+\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.PosixParser;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * http://issues.apache.org/jira/browse/CLI-148\n+ *\n+ * @author brianegge\n+ */\n+public class BugCLI148Test  extends TestCase {\n+\n+    public void testWorkaround1() throws Exception\n+    {\n+        Options options = buildCommandLineOptions();\n+        CommandLineParser parser = new PosixParser();\n+        String[] args = new String[] {\"-t-something\" };\n+        CommandLine commandLine;\n+        commandLine = parser.parse( options, args );\n+        assertEquals(\"-something\", commandLine.getOptionValue( 't'));\n+    }\n+\n+    public void testWorkaround2() throws Exception\n+    {\n+        Options options = buildCommandLineOptions();\n+        CommandLineParser parser = new PosixParser();\n+        String[] args = new String[] {\"-t\", \"\\\"-something\\\"\" };\n+        CommandLine commandLine;\n+        commandLine = parser.parse( options, args );\n+        assertEquals(\"-something\", commandLine.getOptionValue( 't'));\n+    }\n+\n+    private Options buildCommandLineOptions()\n+    {\n+        Option t = OptionBuilder.withArgName( \"t\").hasArg().create('t');\n+        Option s = OptionBuilder.withArgName( \"s\").hasArg().create('s');\n+        Options options = new Options();\n+        options.addOption( t);\n+        options.addOption( s);\n+        return options;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI162Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package org.apache.commons.cli.bug;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.sql.ParameterMetaData;\n+import java.sql.Types;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.OptionGroup;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+\n+public class BugCLI162Test extends TestCase {\n+    /** Constant for the line separator.*/\n+    private static final String CR = System.getProperty(\"line.separator\");\n+\n+    public void testInfiniteLoop() {\n+        Options options = new Options();\n+        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.setWidth(20);\n+        formatter.printHelp(\"app\", options); // used to hang & crash\n+    }\n+\n+    public void testPrintHelpLongLines() throws ParseException, IOException {\n+        // Constants used for options\n+        final String OPT = \"-\";\n+\n+        final String OPT_COLUMN_NAMES = \"l\";\n+\n+        final String OPT_CONNECTION = \"c\";\n+\n+        final String OPT_DESCRIPTION = \"e\";\n+\n+        final String OPT_DRIVER = \"d\";\n+\n+        final String OPT_DRIVER_INFO = \"n\";\n+\n+        final String OPT_FILE_BINDING = \"b\";\n+\n+        final String OPT_FILE_JDBC = \"j\";\n+\n+        final String OPT_FILE_SFMD = \"f\";\n+\n+        final String OPT_HELP = \"h\";\n+\n+        final String OPT_HELP_ = \"help\";\n+\n+        final String OPT_INTERACTIVE = \"i\";\n+\n+        final String OPT_JDBC_TO_SFMD = \"2\";\n+\n+        final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n+\n+        final String OPT_METADATA = \"m\";\n+\n+        final String OPT_PARAM_MODES_INT = \"o\";\n+\n+        final String OPT_PARAM_MODES_NAME = \"O\";\n+\n+        final String OPT_PARAM_NAMES = \"a\";\n+\n+        final String OPT_PARAM_TYPES_INT = \"y\";\n+\n+        final String OPT_PARAM_TYPES_NAME = \"Y\";\n+\n+        final String OPT_PASSWORD = \"p\";\n+\n+        final String OPT_PASSWORD_L = \"password\";\n+\n+        final String OPT_SQL = \"s\";\n+\n+        final String OPT_SQL_L = \"sql\";\n+\n+        final String OPT_SQL_SPLIT_DEFAULT = \"###\";\n+\n+        final String OPT_SQL_SPLIT_L = \"splitSql\";\n+\n+        final String OPT_STACK_TRACE = \"t\";\n+\n+        final String OPT_TIMING = \"g\";\n+\n+        final String OPT_TRIM_L = \"trim\";\n+\n+        final String OPT_USER = \"u\";\n+\n+        final String OPT_WRITE_TO_FILE = \"w\";\n+\n+        final String _PMODE_IN = \"IN\";\n+\n+        final String _PMODE_INOUT = \"INOUT\";\n+\n+        final String _PMODE_OUT = \"OUT\";\n+\n+        final String _PMODE_UNK = \"Unknown\";\n+\n+        final String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n+\n+        // Options build\n+        Options commandLineOptions;\n+        commandLineOptions = new Options();\n+        commandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\n+        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n+        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n+            + OPT\n+            + OPT_CONNECTION\n+            + \" is not specified, all drivers on the classpath are displayed.\");\n+        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n+        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n+        commandLineOptions\n+                .addOption(\n+                        OPT_PASSWORD,\n+                        OPT_PASSWORD_L,\n+                        true,\n+                        \"The database password for the user specified with the \"\n+                            + OPT\n+                            + OPT_USER\n+                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n+        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n+        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n+        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n+        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n+        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n+        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n+                \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n+        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n+                \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n+        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n+        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n+        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n+        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n+            + OPT\n+            + OPT_COLUMN_NAMES\n+            + \" \\\"cname1 cname2\\\"\");\n+        commandLineOptions.addOption(option);\n+        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n+            + OPT\n+            + OPT_PARAM_NAMES\n+            + \" \\\"pname1 pname2\\\"\");\n+        commandLineOptions.addOption(option);\n+        //\n+        OptionGroup pOutTypesOptionGroup = new OptionGroup();\n+        String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n+        final String typesClassName = Types.class.getName();\n+        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n+            + typesClassName\n+            + \". \"\n+            + pOutTypesOptionGroupDoc\n+            + \" Example: \"\n+            + OPT\n+            + OPT_PARAM_TYPES_INT\n+            + \" \\\"-10 12\\\"\");\n+        commandLineOptions.addOption(option);\n+        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n+            + typesClassName\n+            + \" names. \"\n+            + pOutTypesOptionGroupDoc\n+            + \" Example: \"\n+            + OPT\n+            + OPT_PARAM_TYPES_NAME\n+            + \" \\\"CURSOR VARCHAR\\\"\");\n+        commandLineOptions.addOption(option);\n+        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n+        //\n+        OptionGroup modesOptionGroup = new OptionGroup();\n+        String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n+        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n+            + ParameterMetaData.parameterModeIn\n+            + \"=IN, \"\n+            + ParameterMetaData.parameterModeInOut\n+            + \"=INOUT, \"\n+            + ParameterMetaData.parameterModeOut\n+            + \"=OUT, \"\n+            + ParameterMetaData.parameterModeUnknown\n+            + \"=Unknown\"\n+            + \"). \"\n+            + modesOptionGroupDoc\n+            + \" Example for 2 parameters, OUT and IN: \"\n+            + OPT\n+            + OPT_PARAM_MODES_INT\n+            + \" \\\"\"\n+            + ParameterMetaData.parameterModeOut\n+            + \" \"\n+            + ParameterMetaData.parameterModeIn\n+            + \"\\\"\");\n+        modesOptionGroup.addOption(option);\n+        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n+            + PMODES\n+            + \"). \"\n+            + modesOptionGroupDoc\n+            + \" Example for 2 parameters, OUT and IN: \"\n+            + OPT\n+            + OPT_PARAM_MODES_NAME\n+            + \" \\\"\"\n+            + _PMODE_OUT\n+            + \" \"\n+            + _PMODE_IN\n+            + \"\\\"\");\n+        modesOptionGroup.addOption(option);\n+        commandLineOptions.addOptionGroup(modesOptionGroup);\n+        option = new Option(null, OPT_TRIM_L, true,\n+                \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n+        option.setOptionalArg(true);\n+        commandLineOptions.addOption(option);\n+        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n+                \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n+        option.setArgs(2);\n+        commandLineOptions.addOption(option);\n+        new HelpFormatter().printHelp(this.getClass().getName(), commandLineOptions);\n+    }\n+\n+    public void testLongLineChunking() throws ParseException, IOException {\n+        Options options = new Options();\n+        options.addOption(\"x\", \"extralongarg\", false,\n+                                     \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n+                                     \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n+                                     \"yes. \");\n+        HelpFormatter formatter = new HelpFormatter();\n+        StringWriter sw = new StringWriter();\n+        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n+        String expected = \"usage:\" + CR +\n+                          \"       org.apache.commons.cli.bug.B\" + CR +\n+                          \"       ugCLI162Test\" + CR +\n+                          \"Header\" + CR +\n+                          \"-x,--extralongarg     This\" + CR +\n+                          \"                      description\" + CR +\n+                          \"                      has\" + CR +\n+                          \"                      ReallyLongVal\" + CR +\n+                          \"                      uesThatAreLon\" + CR +\n+                          \"                      gerThanTheWid\" + CR +\n+                          \"                      thOfTheColumn\" + CR +\n+                          \"                      s and also\" + CR +\n+                          \"                      other\" + CR +\n+                          \"                      ReallyLongVal\" + CR +\n+                          \"                      uesThatAreHug\" + CR +\n+                          \"                      erAndBiggerTh\" + CR +\n+                          \"                      anTheWidthOfT\" + CR +\n+                          \"                      heColumnsBob,\" + CR +\n+                          \"                      yes.\" + CR +\n+                          \"Footer\" + CR;\n+        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n+    }\n+\n+    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n+        Options options = new Options();\n+        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n+        HelpFormatter formatter = new HelpFormatter();\n+        StringWriter sw = new StringWriter();\n+        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n+        System.err.println(sw.toString());\n+        String expected = \"usage:\" + CR +\n+                          \"       org.apache.comm\" + CR +\n+                          \"       ons.cli.bug.Bug\" + CR +\n+                          \"       CLI162Test\" + CR +\n+                          \"Header\" + CR +\n+                          \"-x,--extralongarg\" + CR +\n+                          \" This description is\" + CR +\n+                          \" Long.\" + CR +\n+                          \"Footer\" + CR;\n+        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI18Test.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli.bug;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * http://issues.apache.org/jira/browse/CLI-18\n+ */\n+public class BugCLI18Test extends TestCase\n+{\n+    public void testCLI18()\n+    {\n+        Options options = new Options();\n+        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n+        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n+        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n+\n+        HelpFormatter formatter = new HelpFormatter();\n+        StringWriter out = new StringWriter();\n+\n+        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2, \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI71Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package org.apache.commons.cli.bug;\n+\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.MissingArgumentException;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.PosixParser;\n+\n+import junit.framework.TestCase;\n+\n+public class BugCLI71Test extends TestCase {\n+\n+    private Options options;\n+    private CommandLineParser parser;\n+\n+    public void setUp() {\n+        options = new Options();\n+\n+        Option algorithm = new Option(\"a\" , \"algo\", true, \"the algorithm which it to perform executing\");\n+        algorithm.setArgName(\"algorithm name\");\n+        options.addOption(algorithm);\n+\n+        Option key = new Option(\"k\" , \"key\", true, \"the key the setted algorithm uses to process\");\n+        algorithm.setArgName(\"value\");\n+        options.addOption(key);\n+\n+        parser = new PosixParser();\n+    }\n+\n+    public void testBasic() throws Exception {\n+        String[] args = new String[] { \"-a\", \"Caesar\", \"-k\", \"A\" };\n+        CommandLine line = parser.parse( options, args);\n+        assertEquals( \"Caesar\", line.getOptionValue(\"a\") );\n+        assertEquals( \"A\", line.getOptionValue(\"k\") );\n+    }\n+\n+    public void testMistakenArgument() throws Exception {\n+        String[] args = new String[] { \"-a\", \"Caesar\", \"-k\", \"A\" };\n+        CommandLine line = parser.parse( options, args);\n+        args = new String[] { \"-a\", \"Caesar\", \"-k\", \"a\" };\n+        line = parser.parse( options, args);\n+        assertEquals( \"Caesar\", line.getOptionValue(\"a\") );\n+        assertEquals( \"a\", line.getOptionValue(\"k\") );\n+    }\n+\n+    public void testLackOfError() throws Exception {\n+        String[] args = new String[] { \"-k\", \"-a\",  \"Caesar\" };\n+        try {\n+            CommandLine line = parser.parse( options, args);\n+            fail(\"MissingArgumentException expected\");\n+        } catch(MissingArgumentException e) {\n+            assertEquals(\"option missing an argument\", \"k\", e.getOption().getOpt());\n+        }\n+    }\n+\n+    public void testGetsDefaultIfOptional() throws Exception {\n+        String[] args = new String[] { \"-k\", \"-a\", \"Caesar\" };\n+        options.getOption(\"k\").setOptionalArg(true);\n+        CommandLine line = parser.parse( options, args);\n+        \n+        assertEquals( \"Caesar\", line.getOptionValue(\"a\") );\n+        assertEquals( \"a\", line.getOptionValue(\"k\", \"a\") );\n+    }\n+\n+}", "timestamp": 1237675755, "metainfo": ""}