{"sha": "8f95e4a724350f9f80429c2af1c3ac9bb2b2c2db", "log": "Merged RESEARCH_CLI_2_ROXSPRING branch back to HEAD   ", "commit": "\n--- a/src/java/org/apache/commons/cli/AlreadySelectedException.java\n+++ b/src/java/org/apache/commons/cli/AlreadySelectedException.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/BasicParser.java\n+++ b/src/java/org/apache/commons/cli/BasicParser.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/CLI2Converter.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.validation.InvalidArgumentException;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * A utility class for converting data structures version 1 to \n+ * version 2 Option instances.\n+ */\n+public class CLI2Converter {\n+\t\n+\tprivate CLI2Converter(){\n+\t\t// prevent creation of static utility class \n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Option instance from a version 1 Option instance.\n+\t * \n+\t * @param option1 the version 1 Option to convert\n+\t * @return a version 2 Option  \n+\t */\n+\tpublic static Option option(final org.apache.commons.cli.Option option1){\n+\t\t\n+\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+\t\tobuilder.withRequired(option1.isRequired());\n+\t\t\n+\t\tfinal String shortName = option1.getOpt();\n+\t\tif(shortName!=null && !\" \".equals(shortName)){\n+\t\t\tobuilder.withShortName(shortName);\n+\t\t}\n+\t\t\n+\t\tfinal String longName = option1.getLongOpt();\n+\t\tif(longName!=null){\n+\t\t\tobuilder.withLongName(longName);\n+\t\t}\n+\t\tobuilder.withId(option1.getId());\n+\t\t\n+\t\tfinal String description = option1.getDescription();\n+\t\tif(description!=null){\n+\t\t\tobuilder.withDescription(description);\n+\t\t}\n+\t\t\n+\t\tif(option1.hasArg()){\n+\t\t\tfinal ArgumentBuilder abuilder = new ArgumentBuilder();\n+\t\t\tfinal String argName = option1.getArgName();\n+\t\t\tabuilder.withName(argName);\n+\t\t\tabuilder.withMaximum(option1.getArgs());\n+\t\t\tif(option1.hasValueSeparator()){\n+\t\t\t\tabuilder.withSubsequentSeparator(option1.getValueSeparator());\n+\t\t\t}\n+\t\t\tif(option1.hasOptionalArg()){\n+\t\t\t\tabuilder.withMinimum(0);\n+\t\t\t}\n+\t\t\telse{\n+\t\t\t\t//TODO check what non-optional arg means\n+\t\t\t\tabuilder.withMinimum(option1.getArgs());\n+\t\t\t}\n+\t\t\t\n+\t\t\tfinal Object type = option1.getType();\n+\t\t\tif(type!=null){\n+\t\t\t\tabuilder.withValidator(new TypeHandlerValidator(type));\n+\t\t\t}\n+\t\t\t\n+\t\t\tobuilder.withArgument(abuilder.create());\n+\t\t}\n+\t\t\n+\t\treturn obuilder.create();\n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Group instance from a version 1 OptionGroup instance.\n+\t * \n+\t * @param optionGroup1 the version 1 OptionGroup to convert\n+\t * @return a version 2 Group\n+\t */\n+\tpublic static Group group(final OptionGroup optionGroup1){\n+\t\t\n+\t\tfinal GroupBuilder gbuilder = new GroupBuilder();\n+\t\t\n+\t\tfor(final Iterator i = optionGroup1.getOptions().iterator();i.hasNext();){\n+\t\t\tfinal org.apache.commons.cli.Option option1 = (org.apache.commons.cli.Option)i.next();\n+\t\t\tfinal Option option2 = option(option1);\n+\t\t\tgbuilder.withOption(option2);\n+\t\t}\n+\t\t\n+\t\tgbuilder.withMaximum(1);\n+\t\t\n+\t\tif(optionGroup1.isRequired()){\n+\t\t\tgbuilder.withMinimum(1);\n+\t\t}\n+\t\t\n+\t\treturn gbuilder.create();\n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Group instance from a version 1 Options instance.\n+\t * \n+\t * @param options1 the version 1 Options to convert\n+\t * @return a version 2 Group\n+\t */\n+\tpublic static Group group(final Options options1){\n+\t\t\n+\t\tfinal GroupBuilder gbuilder = new GroupBuilder();\n+\t\t\n+\t\tfinal Set optionGroups = new HashSet();\n+\t\t\n+\t\tfor(final Iterator i = options1.getOptionGroups().iterator();i.hasNext();){\n+\t\t\tfinal OptionGroup optionGroup1 = (OptionGroup)i.next();\n+\t\t\tGroup group = group(optionGroup1);\n+\t\t\tgbuilder.withOption(group);\n+\t\t\toptionGroups.add(optionGroup1);\n+\t\t}\n+\t\t\n+\t\tfor(final Iterator i = options1.getOptions().iterator();i.hasNext();){\n+\t\t\tfinal org.apache.commons.cli.Option option1 = (org.apache.commons.cli.Option)i.next();\n+\t\t\tif(!optionInAGroup(option1,optionGroups)){\n+\t\t\t\tfinal Option option2 = option(option1);\n+\t\t\t\tgbuilder.withOption(option2);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn gbuilder.create();\n+\t}\n+\n+\tprivate static boolean optionInAGroup(final org.apache.commons.cli.Option option1, final Set optionGroups) {\n+\t\tfor (Iterator i = optionGroups.iterator(); i.hasNext();) {\n+\t\t\tOptionGroup group = (OptionGroup) i.next();\n+\t\t\tif(group.getOptions().contains(option1)){\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+}\n+\n+class TypeHandlerValidator implements Validator{\n+\t\n+\tprivate final Object type;\n+\t\n+\t/**\n+     * Creates a new Validator using the TypeHandler class.\n+     * \n+     * @see TypeHandler\n+\t * @param type The required type for valid elements\n+\t */\n+\tpublic TypeHandlerValidator(final Object type){\n+\t\tthis.type = type;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+\t */\n+\tpublic void validate(final List values) throws InvalidArgumentException {\n+\t\tfinal ListIterator i = values.listIterator();\n+\t\twhile(i.hasNext()){\n+\t\t\tfinal String value = (String)i.next();\n+\t\t\tfinal Object converted = TypeHandler.createValue(value,type);\n+\t\t\tif(converted==null){\n+\t\t\t\tthrow new InvalidArgumentException(\"Unable to understand value: \" + value);\n+\t\t\t}\n+\t\t\ti.set(converted);\n+\t\t}\n+\t}\n+}\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     private Option[] optionsArray;\n \n     /**\n-     * <p>Creates a command line.</p>\n+     * Creates a command line.\n      */\n     CommandLine()\n     {\n     }\n \n     /** \n-     * <p>Query to see if an option has been set.</p>\n+     * Query to see if an option has been set.\n      *\n      * @param opt Short name of the option\n      * @return true if set, false if not\n     }\n \n     /** \n-     * <p>Query to see if an option has been set.</p>\n+     * Query to see if an option has been set.\n      *\n      * @param opt character name of the option\n      * @return true if set, false if not\n     }\n \n     /**\n-     * <p>Return the <code>Object</code> type of this <code>Option</code>.</p>\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n      *\n      * @param opt the name of the option\n      * @return the type of this <code>Option</code>\n     }\n \n     /**\n-     * <p>Return the <code>Object</code> type of this <code>Option</code>.</p>\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n      *\n      * @param opt the name of the option\n      * @return the type of opt\n     }\n \n     /** \n-     * <p>Retrieve the argument, if any, of this option.</p>\n+     * Retrieve the argument, if any, of this option.\n      *\n      * @param opt the name of the option\n      * @return Value of the argument if option is set, and has an argument,\n     }\n \n     /** \n-     * <p>Retrieve the argument, if any, of this option.</p>\n+     * Retrieve the argument, if any, of this option.\n      *\n      * @param opt the character name of the option\n      * @return Value of the argument if option is set, and has an argument,\n     }\n \n     /** \n-     * <p>Retrieves the array of values, if any, of an option.</p>\n+     * Retrieves the array of values, if any, of an option.\n      *\n      * @param opt string name of the option\n      * @return Values of the argument if option is set, and has an argument,\n     }\n \n     /** \n-     * <p>Retrieves the array of values, if any, of an option.</p>\n+     * Retrieves the array of values, if any, of an option.\n      *\n      * @param opt character name of the option\n      * @return Values of the argument if option is set, and has an argument,\n     }\n \n     /** \n-     * <p>Retrieve the argument, if any, of an option.</p>\n+     * Retrieve the argument, if any, of an option.\n      *\n      * @param opt name of the option\n      * @param defaultValue is the default value to be returned if the option \n     }\n \n     /** \n-     * <p>Retrieve the argument, if any, of an option.</p>\n+     * Retrieve the argument, if any, of an option.\n      *\n      * @param opt character name of the option\n      * @param defaultValue is the default value to be returned if the option \n     }\n \n     /** \n-     * <p>Retrieve any left-over non-recognized options and arguments</p>\n+     * Retrieve any left-over non-recognized options and arguments\n      *\n      * @return remaining items passed in but not parsed as an array\n      */\n     }\n \n     /** \n-     * <p>Retrieve any left-over non-recognized options and arguments</p>\n+     * Retrieve any left-over non-recognized options and arguments\n      *\n      * @return remaining items passed in but not parsed as a <code>List</code>.\n      */\n     */\n \n     /**\n-     * <p>Add left-over unrecognized option/argument.</p>\n+     * Add left-over unrecognized option/argument.\n      *\n      * @param arg the unrecognised option/argument.\n      */\n     }\n \n     /**\n-     * <p>Add an option to the command line.  The values of \n-     * the option are stored.</p>\n+     * Add an option to the command line.  The values of \n+     * the option are stored.\n      *\n      * @param opt the processed option\n      */\n     }\n \n     /**\n-     * <p>Returns an iterator over the Option members of CommandLine.</p>\n+     * Returns an iterator over the Option members of CommandLine.\n      *\n      * @return an <code>Iterator</code> over the processed {@link Option} \n      * members of this {@link CommandLine}\n     }\n \n     /**\n-     * <p>Returns an array of the processed {@link Option}s.</p>\n+     * Returns an array of the processed {@link Option}s.\n      *\n      * @return an array of the processed {@link Option}s.\n      */\n--- a/src/java/org/apache/commons/cli/CommandLineParser.java\n+++ b/src/java/org/apache/commons/cli/CommandLineParser.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.13 $\n+ * @version $Revision: 1.14 $\n  */\n public class GnuParser extends Parser {\n \n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         Option option;\n         List optList = options.helpOptions();\n \n-        Collections.sort(optList, new StringBufferComparator());\n+        Collections.sort(optList, new OptionComparator());\n \n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n     // ---------------------------------------------------------- Inner classes\n     /**\n      * <p>This class implements the <code>Comparator</code> interface\n-     * for comparing StringBuffers.</p>\n-     */\n-    private static class StringBufferComparator\n+     * for comparing Options.</p>\n+     */\n+    private static class OptionComparator\n         implements Comparator {\n \n         /**\n          * integer, zero, or a positive integer as the first argument \n          * is less than, equal to, or greater than the second.</p>\n          *\n-         * @param o1 The first StringBuffer to be compared.\n-         * @param o2 The second StringBuffer to be compared.\n+         * @param o1 The first Option to be compared.\n+         * @param o2 The second Option to be compared.\n          *\n          * @return a negative integer, zero, or a positive integer as \n          * the first argument is less than, equal to, or greater than the \n          */\n         public int compare(Object o1, Object o2)\n         {\n-            String str1 = stripPrefix(o1.toString());\n-            String str2 = stripPrefix(o2.toString());\n-\n-            return (str1.compareTo(str2));\n-        }\n-\n-        /**\n-         * <p>Removes any leading hyphens from <code>strOption</code>.</p>\n-         *         \n-         * @param strOption The String from which to strip the leading\n-         * hyphens.\n-         *\n-         * @return The String without any leading hyphens.\n-         */\n-        private String stripPrefix(String strOption)\n-        {\n-            // Strip any leading '-' characters\n-            int iStartIndex = strOption.lastIndexOf('-');\n-\n-            if (iStartIndex == -1)\n-            {\n-                iStartIndex = 0;\n-            }\n-\n-            return strOption.substring(iStartIndex);\n+            Option opt1 = (Option)o1;\n+            Option opt2 = (Option)o2;\n+\n+            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n         }\n     }\n }\n--- a/src/java/org/apache/commons/cli/MissingArgumentException.java\n+++ b/src/java/org/apache/commons/cli/MissingArgumentException.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/MissingOptionException.java\n+++ b/src/java/org/apache/commons/cli/MissingOptionException.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     }\n \n     /**\n-     * <p>Creates an Option using the specified parameters.</p>\n+     * Creates an Option using the specified parameters.\n      *\n      * @param opt short representation of the option\n      * @param longOpt the long representation of the option\n     }\n \n     /**\n-     * <p>Returns the id of this Option.  This is only set when the\n+     * Returns the id of this Option.  This is only set when the\n      * Option shortOpt is a single character.  This is used for switch\n-     * statements.</p>\n+     * statements.\n      *\n      * @return the id of this Option\n      */\n     }\n \n     /**\n-     * <p>Returns the 'unique' Option identifier.</p>\n+     * Returns the 'unique' Option identifier.\n      * \n      * @return the 'unique' Option identifier\n      */\n         return this.opt;\n     }\n \n-    /** <p>Retrieve the name of this Option.</p>\n-     *\n-     * <p>It is this String which can be used with\n+    /** \n+     * Retrieve the name of this Option.\n+     *\n+     * It is this String which can be used with\n      * {@link CommandLine#hasOption(String opt)} and\n      * {@link CommandLine#getOptionValue(String opt)} to check\n-     * for existence and argument.<p>\n+     * for existence and argument.\n      *\n      * @return The name of this option\n      */\n     }\n \n     /**\n-     * <p>Retrieve the type of this Option.</p>\n+     * Retrieve the type of this Option.\n      * \n      * @return The type of this option\n      */\n     }\n \n     /**\n-     * <p>Sets the type of this Option.</p>\n+     * Sets the type of this Option.\n      *\n      * @param type the type of this Option\n      */\n     }\n \n     /** \n-     * <p>Retrieve the long name of this Option.</p>\n+     * Retrieve the long name of this Option.\n      *\n      * @return Long name of this option, or null, if there is no long name\n      */\n     }\n \n     /**\n-     * <p>Sets the long name of this Option.</p>\n+     * Sets the long name of this Option.\n      *\n      * @param longOpt the long name of this Option\n      */\n     }\n \n     /**\n-     * <p>Sets whether this Option can have an optional argument.</p>\n+     * Sets whether this Option can have an optional argument.\n      *\n      * @param optionalArg specifies whether the Option can have\n      * an optional argument.\n         return this.optionalArg;\n     }\n \n-    /** <p>Query to see if this Option has a long name</p>\n+    /** \n+     * Query to see if this Option has a long name\n      *\n      * @return boolean flag indicating existence of a long name\n      */\n         return (this.longOpt != null);\n     }\n \n-    /** <p>Query to see if this Option requires an argument</p>\n+    /** \n+     * Query to see if this Option requires an argument\n      *\n      * @return boolean flag indicating if an argument is required\n      */\n         return (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n     }\n \n-    /** <p>Retrieve the self-documenting description of this Option</p>\n+    /** \n+     * Retrieve the self-documenting description of this Option\n      *\n      * @return The string description of this option\n      */\n     }\n \n     /** \n-     * <p>Query to see if this Option requires an argument</p>\n+     * Query to see if this Option requires an argument\n      *\n      * @return boolean flag indicating if an argument is required\n      */\n     }\n \n     /**\n-     * <p>Sets whether this Option is mandatory.</p>\n+     * Sets whether this Option is mandatory.\n      *\n      * @param required specifies whether this Option is mandatory\n      */\n     }\n \n     /**\n-     * <p>Sets the display name for the argument value.</p>\n+     * Sets the display name for the argument value.\n      *\n      * @param argName the display name for the argument value.\n      */\n     }\n \n     /**\n-     * <p>Gets the display name for the argument value.</p>\n+     * Gets the display name for the argument value.\n      *\n      * @return the display name for the argument value.\n      */\n     }\n \n     /**\n-     * <p>Returns whether the display name for the argument value\n-     * has been set.</p>\n+     * Returns whether the display name for the argument value\n+     * has been set.\n      *\n      * @return if the display name for the argument value has been\n      * set.\n     }\n \n     /** \n-     * <p>Query to see if this Option can take many values</p>\n+     * Query to see if this Option can take many values.\n      *\n      * @return boolean flag indicating if multiple values are allowed\n      */\n     }\n \n     /** \n-     * <p>Sets the number of argument values this Option can take.</p>\n+     * Sets the number of argument values this Option can take.\n      *\n      * @param num the number of argument values\n      */\n     }\n \n     /**\n-     * <p>Sets the value separator.  For example if the argument value\n-     * was a Java property, the value separator would be '='.</p>\n+     * Sets the value separator.  For example if the argument value\n+     * was a Java property, the value separator would be '='.\n      *\n      * @param sep The value separator.\n      */\n     }\n \n     /**\n-     * <p>Returns the value separator character.</p>\n+     * Returns the value separator character.\n      *\n      * @return the value separator character.\n      */\n     }\n \n     /**\n-     * <p>Return whether this Option has specified a value separator.</p>\n+     * Return whether this Option has specified a value separator.\n      * \n-     * @return whether this Option has specified a value separator.</p>\n+     * @return whether this Option has specified a value separator.\n      */\n     public boolean hasValueSeparator()\n     {\n     }\n \n     /** \n-     * <p>Returns the number of argument values this Option can take.</p>\n+     * Returns the number of argument values this Option can take.\n      *\n      * @return num the number of argument values\n      */\n     }\n \n     /**\n-     * <p>Adds the specified value to this Option.</p>\n+     * Adds the specified value to this Option.\n      * \n      * @param value is a/the value of this Option\n      */\n     }\n \n     /**\n-     * <p>Processes the value.  If this Option has a value separator\n+     * Processes the value.  If this Option has a value separator\n      * the value will have to be parsed into individual tokens.  When\n      * n-1 tokens have been processed and there are more value separators\n      * in the value, parsing is ceased and the remaining characters are\n-     * added as a single token.</p>\n+     * added as a single token.\n      *\n      * @param value The String to be processed.\n      *\n     }\n \n     /**\n-     * <p>Add the value to this Option.  If the number of arguments\n+     * Add the value to this Option.  If the number of arguments\n      * is greater than zero and there is enough space in the list then\n      * add the value.  Otherwise, throw a runtime exception.\n-     * </p>\n      *\n      * @param value The value to be added to this Option\n      *\n     }\n \n     /** \n-     * <p>Dump state, suitable for debugging.</p>\n+     * Dump state, suitable for debugging.\n      *\n      * @return Stringified form of this object\n      */\n--- a/src/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/OptionBuilder.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     }\n \n     /**\n-     * <p>Resets the member variables to their default values.</p>\n+     * Resets the member variables to their default values.\n      */\n     private static void reset()\n     {\n     }\n \n     /**\n-     * <p>The next Option created will have the following long option value.</p>\n+     * The next Option created will have the following long option value.\n      *\n      * @param longopt the long option value\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option created will require an argument value.</p>\n+     * The next Option created will require an argument value.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * <p>The next Option created will require an argument value if\n-     * <code>hasArg</code> is true.</p>\n+     * The next Option created will require an argument value if\n+     * <code>hasArg</code> is true.\n      *\n      * @param hasArg if true then the Option has an argument value\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option created will have the specified argument value \n-     * name.</p>\n+     * The next Option created will have the specified argument value \n+     * name.\n      *\n      * @param name the name for the argument value\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option created will be required.</p>\n+     * The next Option created will be required.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * <p>The next Option created uses <code>sep</code> as a means to\n-     * separate argument values.</p>\n+     * The next Option created uses <code>sep</code> as a means to\n+     * separate argument values.\n      *\n      * <b>Example:</b>\n      * <pre>\n     }\n \n     /**\n-     * <p>The next Option created uses '<code>=</code>' as a means to\n-     * separate argument values.</p>\n+     * The next Option created uses '<code>=</code>' as a means to\n+     * separate argument values.\n      *\n      * <b>Example:</b>\n      * <pre>\n     }\n \n     /**\n-     * <p>The next Option created will be required if <code>required</code>\n-     * is true.</p>\n+     * The next Option created will be required if <code>required</code>\n+     * is true.\n      *\n      * @param required if true then the Option is required\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option created can have unlimited argument values.</p>\n+     * The next Option created can have unlimited argument values.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * <p>The next Option created can have <code>num</code> \n-     * argument values.</p>\n+     * The next Option created can have <code>num</code> \n+     * argument values.\n      *\n      * @param num the number of args that the option can have\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option can have an optional argument.</p>\n+     * The next Option can have an optional argument.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * <p>The next Option can have an unlimited number of\n-     * optional arguments.</p>\n+     * The next Option can have an unlimited number of\n+     * optional arguments.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * <p>The next Option can have the specified number of \n-     * optional arguments.</p>\n+     * The next Option can have the specified number of \n+     * optional arguments.\n      *\n      * @param numArgs - the maximum number of optional arguments\n      * the next Option created can have.\n     }\n \n     /**\n-     * <p>The next Option created will have a value that will be an instance \n-     * of <code>type</code>.</p>\n+     * The next Option created will have a value that will be an instance \n+     * of <code>type</code>.\n      *\n      * @param type the type of the Options argument value\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>The next Option created will have the specified description</p>\n+     * The next Option created will have the specified description\n      *\n      * @param description a description of the Option's purpose\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * <p>Create an Option using the current settings and with \n-     * the specified Option <code>char</code>.</p>\n+     * Create an Option using the current settings and with \n+     * the specified Option <code>char</code>.\n      *\n      * @param opt the character representation of the Option\n      * @return the Option instance\n     }\n \n     /**\n-     * <p>Create an Option using the current settings</p>\n+     * Create an Option using the current settings\n      *\n      * @return the Option instance\n      * @throws IllegalArgumentException if <code>longOpt</code> has\n     }\n \n     /**\n-     * <p>Create an Option using the current settings and with \n-     * the specified Option <code>char</code>.</p>\n+     * Create an Option using the current settings and with \n+     * the specified Option <code>char</code>.\n      *\n      * @param opt the <code>java.lang.String</code> representation \n      * of the Option\n--- a/src/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/OptionValidator.java\n+++ b/src/java/org/apache/commons/cli/OptionValidator.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n     /** a map of the option groups */\n     private Map optionGroups = new HashMap();\n \n-    /** <p>Construct a new Options descriptor</p>\n+    /** Construct a new Options descriptor\n      */\n     public Options()\n     {\n     }\n \n     /**\n-     * <p>Add the specified option group.</p>\n+     * Add the specified option group.\n      *\n      * @param group the OptionGroup that is to be added\n      * @return the resulting Options instance\n \n         return this;\n     }\n-\n-    /** <p>Add an option that only contains a short-name</p>\n-     * <p>It may be specified as requiring an argument.</p>\n+    \n+    /**\n+     * Lists the OptionGroups that are members of this Options instance.\n+     * @return a Collection of OptionGroup instances.\n+     */\n+    Collection getOptionGroups(){\n+    \treturn new HashSet(optionGroups.values());\n+    }\n+\n+    /** \n+     * Add an option that only contains a short-name.\n+     * It may be specified as requiring an argument.\n      *\n      * @param opt Short single-character name of the option.\n      * @param hasArg flag signally if an argument is required after this option\n         return this;\n     }\n \n-    /** <p>Add an option that contains a short-name and a long-name</p>\n-     * <p>It may be specified as requiring an argument.</p>\n+    /** \n+     * Add an option that contains a short-name and a long-name.\n+     * It may be specified as requiring an argument.\n      *\n      * @param opt Short single-character name of the option.\n      * @param longOpt Long multi-character name of the option.\n     }\n \n     /**\n-     * <p>Adds an option instance</p>\n+     * Adds an option instance\n      *\n      * @param opt the option that is to be added \n      * @return the resulting Options instance\n         return this;\n     }\n \n-    /** <p>Retrieve a read-only list of options in this set</p>\n+    /** \n+     * Retrieve a read-only list of options in this set\n      *\n      * @return read-only Collection of {@link Option} objects in this descriptor\n      */\n     }\n \n     /**\n-     * <p>Returns the Options for use by the HelpFormatter.</p>\n+     * Returns the Options for use by the HelpFormatter.\n      *\n      * @return the List of Options\n      */\n         return new ArrayList(opts);\n     }\n \n-    /** <p>Returns the required options as a \n-     * <code>java.util.Collection</code>.</p>\n+    /** \n+     * Returns the required options as a\n+     * <code>java.util.Collection</code>.\n      *\n      * @return Collection of required options\n      */\n         return requiredOpts;\n     }\n \n-    /** <p>Retrieve the named {@link Option}</p>\n+    /** \n+     * Retrieve the named {@link Option}\n      *\n      * @param opt short or long name of the {@link Option}\n      * @return the option represented by opt\n     }\n \n     /** \n-     * <p>Returns whether the named {@link Option} is a member\n-     * of this {@link Options}</p>\n+     * Returns whether the named {@link Option} is a member\n+     * of this {@link Options}.\n      *\n      * @param opt short or long name of the {@link Option}\n      * @return true if the named {@link Option} is a member\n         return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n     }\n \n-    /** <p>Returns the OptionGroup the <code>opt</code>\n-     * belongs to.</p>\n+    /** \n+     * Returns the OptionGroup the <code>opt</code>\n+     * belongs to.\n      * @param opt the option whose OptionGroup is being queried.\n      *\n      * @return the OptionGroup if <code>opt</code> is part\n         return (OptionGroup) optionGroups.get(opt.getKey());\n     }\n \n-    /** <p>Dump state, suitable for debugging.</p>\n+    /** \n+     * Dump state, suitable for debugging.\n      *\n      * @return Stringified form of this object\n      */\n--- a/src/java/org/apache/commons/cli/ParseException.java\n+++ b/src/java/org/apache/commons/cli/ParseException.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.14 $\n+ * @version $Revision: 1.15 $\n  */\n public abstract class Parser implements CommandLineParser {\n \n \n         if ((opt.getValues() == null) && !opt.hasOptionalArg())\n         {\n-            throw new MissingArgumentException(\"no argument for:\"\n+            throw new MissingArgumentException(\"Missing argument for option:\"\n                                                + opt.getKey());\n         }\n     }\n--- a/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.14 $\n+ * @version $Revision: 1.15 $\n  */\n public class PosixParser extends Parser {\n \n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+++ b/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n-/*\n+/**\n  * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/Argument.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * An Option that can process values passed on the command line in the form\n+ * \"--file README\".\n+ */\n+public interface Argument extends Option {\n+\n+    /**\n+     * Returns the initial separator character or\n+     * '\\0' if no character has been set.\n+     * \n+     * @return char the initial separator character\n+     */\n+    char getInitialSeparator();\n+    \n+    /**\n+     * Processes the \"README\" style element of the argument.\n+     *\n+     * Values identified should be added to the CommandLine object in\n+     * association with this Argument.\n+     *\n+     * @see WriteableCommandLine#addValue(Option,Object)\n+     *\n+     * @param commandLine The CommandLine object to store results in.\n+     * @param args The arguments to process.\n+     * @param option The option to register value against.\n+     * @throws OptionException if any problems occur.\n+     */\n+    void processValues(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args,\n+        final Option option)\n+            throws OptionException;\n+\n+    /**\n+     * Performs any necessary validation on the values added to the\n+     * CommandLine.\n+     *\n+     * Validation will typically involve using the\n+     * CommandLine.getValues(option) method to retrieve the values\n+     * and then either checking each value.  Optionally the String\n+     * value can be replaced by another Object such as a Number\n+     * instance or a File instance.\n+     *\n+     * @see CommandLine#getValues(Option)\n+     *\n+     * @param commandLine The CommandLine object to query.\n+     * @param option The option to lookup values with.\n+     * @throws OptionException if any problems occur.\n+     */\n+    void validate(final WriteableCommandLine commandLine, final Option option)\n+        throws OptionException;\n+\n+    /**\n+     * Indicates whether argument values must be present for the CommandLine to\n+     * be valid.\n+     *\n+     * @see #getMinimum()\n+     * @see #getMaximum()\n+     * @return true iff the CommandLine will be invalid without at least one \n+     *         value\n+     */\n+    boolean isRequired();\n+\n+    /**\n+     * Retrieves the minimum number of values required for a valid Argument\n+     *\n+     * @return the minimum number of values\n+     */\n+    int getMinimum();\n+\n+    /**\n+     * Retrieves the maximum number of values acceptable for a valid Argument\n+     *\n+     * @return the maximum number of values\n+     */\n+    int getMaximum();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/CommandLine.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Instances of CommandLine represent a command line that has been processed\n+ * according to the definition supplied to the parser.\n+ */\n+public interface CommandLine {\n+\t\n+    /**\n+     * Detects the presence of an option with the specified trigger in this \n+     * CommandLine.\n+     * \n+     * @param trigger the trigger to search for\n+     * @return true iff an option with this trigger is present\n+     */\n+    boolean hasOption(final String trigger);\n+    \n+    /**\n+     * Detects the presence of an option in this CommandLine.\n+     * \n+     * @param option the Option to search for\n+     * @return true iff the option is present\n+     */\n+    boolean hasOption(final Option option);\n+    \n+    /**\n+     * Finds the Option with the specified trigger\n+     * \n+     * @param trigger the name of the option to retrieve\n+     * @return the Option matching the trigger or null if none exists\n+     */\n+    Option getOption(final String trigger);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return a list of values or an empty List if none are found\n+     */\n+    List getValues(final String trigger);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValues the result to return if no values are found\n+     * @return a list of values or defaultValues if none are found\n+     */\n+    List getValues(final String trigger, final List defaultValues);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param option the Option associated with the values\n+     * @return a list of values or an empty List if none are found\n+     */\n+    List getValues(final Option option);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param option the Option associated with the values\n+     * @param defaultValues the result to return if no values are found\n+     * @return a list of values or defaultValues if none are found\n+     */\n+    List getValues(final Option option, final List defaultValues);\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the matching value or null if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final String trigger) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValue the result to use if no values are found\n+     * @return the matching value or defaultValue if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final String trigger, final Object defaultValue) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param option the Option associated with the value\n+     * @return the matching value or null if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final Option option) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param option the Option associated with the value\n+     * @param defaultValue the result to use if no values are found\n+     * @return the matching value or defaultValue if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final Option option, final Object defaultValue) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the Boolean associated with trigger or null if none exists\n+     */\n+    Boolean getSwitch(final String trigger);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValue the Boolean to use if none match\n+     * @return the Boolean associated with trigger or defaultValue if none exists\n+     */\n+    Boolean getSwitch(final String trigger, final Boolean defaultValue);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param option the Option associated with the value\n+     * @return the Boolean associated with option or null if none exists\n+     */\n+    Boolean getSwitch(final Option option);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param option the Option associated with the value\n+     * @param defaultValue the Boolean to use if none match\n+     * @return the Boolean associated with option or defaultValue if none exists\n+     */\n+    Boolean getSwitch(final Option option, final Boolean defaultValue);\n+    \n+    \n+    /**\n+     * Retrieves the value associated with the specified property \n+     * \n+     * @param property the property name to lookup\n+     * @return the value of the property or null\n+     */\n+    String getProperty(final String property);\n+    \n+    /**\n+     * Retrieves the value associated with the specified property \n+     * \n+     * @param property the property name to lookup\n+     * @param defaultValue the value to use if no other is found\n+     * @return the value of the property or defaultValue\n+     */\n+    String getProperty(final String property, final String defaultValue);\n+    \n+    /**\n+     * Retrieves the set of all property names associated with this CommandLine\n+     * \n+     * @return a none null set of property names \n+     */\n+    Set getProperties();\n+    \n+    /**\n+     * Retrieves the number of times the specified Option appeared in this \n+     * CommandLine\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the number of occurrences of the option\n+     */\n+    int getOptionCount(final String trigger);\n+    \n+    /**\n+     * Retrieves the number of times the specified Option appeared in this \n+     * CommandLine\n+     * \n+     * @param option the Option associated to check\n+     * @return the number of occurrences of the option\n+     */\n+    int getOptionCount(final Option option);\n+    \n+    /**\n+     * Retrieves a list of all Options found in this CommandLine\n+     * \n+     * @return a none null list of Options\n+     */\n+    List getOptions();\n+    \n+    /**\n+     * Retrieves a list of all Option triggers found in this CommandLine\n+     * \n+     * @return a none null list of Option triggers\n+     */\n+    Set getOptionTriggers();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/DisplaySetting.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * An enum of possible display settings. These settings are used to control the\n+ * presence of various features in the String representations of options,\n+ * CommandLines and usage strings.  Usually a Set of DisplaySetting instances\n+ * will be passed to a method that will lookup the presence of the values.\n+ */\n+public class DisplaySetting {\n+\t\n+    private static final Set all = new HashSet();\n+\n+    /**\n+     * A Set guarenteed to contain all possible DisplaySetting values\n+     */\n+    public static final Set ALL = Collections.unmodifiableSet(all);\n+    \n+    /**\n+     * A Set guarenteed to contain no DisplaySetting values\n+     */\n+    public static final Set NONE = Collections.EMPTY_SET;\n+    \n+    /**\n+     * Indicates that aliases should be included\n+     */\n+    public static final DisplaySetting DISPLAY_ALIASES =\n+        new DisplaySetting(\"DISPLAY_ALIASES\");\n+    \n+    /**\n+     * Indicates that optionality should be included\n+     */\n+    public static final DisplaySetting DISPLAY_OPTIONAL =\n+        new DisplaySetting(\"DISPLAY_OPTIONAL\");\n+    \n+    /**\n+     * Indicates that property options should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PROPERTY_OPTION =\n+        new DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n+    \n+    /**\n+     * Indicates that switches should be included enabled\n+     */\n+    public static final DisplaySetting DISPLAY_SWITCH_ENABLED =\n+        new DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n+    \n+    /**\n+     * Indicates that switches should be included disabled\n+     */\n+    public static final DisplaySetting DISPLAY_SWITCH_DISABLED =\n+        new DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n+    \n+    /**\n+     * Indicates that group names should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_NAME =\n+        new DisplaySetting(\"DISPLAY_GROUP_NAME\");\n+    \n+    /**\n+     * Indicates that groups should be included expanded\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_EXPANDED =\n+        new DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n+    \n+    /**\n+     * Indicates that group arguments should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\n+        new DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n+    \n+    /**\n+     * Indicates that group outer brackets should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_OUTER =\n+        new DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n+    \n+    /**\n+     * Indicates that arguments should be included numbered\n+     */\n+    public static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\n+        new DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n+    \n+    /**\n+     * Indicates that arguments should be included bracketed\n+     */\n+    public static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\n+        new DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n+    \n+    /**\n+     * Indicates that arguments of Parents should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\n+        new DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n+    \n+    /**\n+     * Indicates that children of Parents should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PARENT_CHILDREN =\n+        new DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n+    \n+    /**\n+     * The name of the setting\n+     */\n+    private final String name;\n+    \n+    /**\n+     * The hashCode of the setting\n+     */\n+    private final int hashCode;\n+\n+    /**\n+     * Creates a new DisplaySetting with the specified name\n+     * @param name the name of the setting\n+     */\n+    private DisplaySetting(final String name) {\n+        this.name = name;\n+        this.hashCode = name.hashCode();\n+        all.add(this);\n+    }\n+\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    public boolean equals(final Object that) {\n+        if (that instanceof DisplaySetting) {\n+            return name.compareTo(that.toString()) == 0;\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+\n+    public String toString() {\n+        return name;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/Group.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+/**\n+ * An Option representing a choice or group of Options in the form \"-a|-b|-c\".\n+ */\n+public interface Group extends Option {\n+\n+    /**\n+     * Appends usage information to the specified StringBuffer\n+     * \n+     * @param buffer the buffer to append to\n+     * @param helpSettings a set of display settings @see DisplaySetting\n+     * @param comp a comparator used to sort the Options\n+     * @param separator the String used to separate member Options \n+     */\n+    void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp,\n+        final String separator);\n+\n+    /**\n+     * Indicates whether group members must be present for the CommandLine to be\n+     * valid.\n+     *\n+     * @see #getMinimum()\n+     * @see #getMaximum()\n+     * @return true iff the CommandLine will be invalid without at least one \n+     *         member option\n+     */\n+    boolean isRequired();\n+\n+    /**\n+     * Retrieves the minimum number of members required for a valid Group\n+     *\n+     * @return the minimum number of members\n+     */\n+    int getMinimum();\n+\n+    /**\n+     * Retrieves the maximum number of members acceptable for a valid Group\n+     *\n+     * @return the maximum number of members\n+     */\n+    int getMaximum();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/HelpLine.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+/**\n+ * Represents a line of help for a particular Option.\n+ */\n+public interface HelpLine {\n+\n+    /**\n+     * @return The description of the option\n+     */\n+    String getDescription();\n+\n+    /**\n+     * @return The level of indentation for this line\n+     */\n+    int getIndent();\n+\n+    /**\n+     * @return The Option that the help line relates to\n+     */\n+    Option getOption();\n+\n+    /**\n+     * Builds a usage string for the option using the specified settings and\n+     * comparator.\n+     * \n+     * @param helpSettings\n+     *            the settings to apply\n+     * @param comparator\n+     *            a comparator to sort options when applicable\n+     * @return the usage string\n+     */\n+    String usage(final Set helpSettings, final Comparator comparator);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/Option.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * The super type of all options representing a particular element of the\n+ * command line interface.\n+ */\n+public interface Option {\n+\n+    /**\n+     * Processes String arguments into a CommandLine.\n+     * \n+     * The iterator will initially point at the first argument to be processed\n+     * and at the end of the method should point to the first argument not\n+     * processed. This method MUST process at least one argument from the\n+     * ListIterator.\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store results in\n+     * @param args\n+     *            The arguments to process\n+     * @throws OptionException\n+     *             if any problems occur\n+     */\n+    void process(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args)\n+        throws OptionException;\n+\n+    /**\n+     * Indicates whether this Option will be able to process the particular\n+     * argument.\n+     * \n+     * @param argument\n+     *            The argument to be tested\n+     * @return true if the argument can be processed by this Option\n+     */\n+    boolean canProcess(final String argument);\n+\n+    /**\n+     * Indicates whether this Option will be able to process the particular\n+     * argument. The ListIterator must be restored to the initial state before\n+     * returning the boolean.\n+     * \n+     * @see #canProcess(String)\n+     * @param arguments\n+     *            the ListIterator over String arguments\n+     * @return true if the argument can be processed by this Option\n+     */\n+    boolean canProcess(final ListIterator arguments);\n+\n+    /**\n+     * Identifies the argument prefixes that should trigger this option. This\n+     * is used to decide which of many Options should be tried when processing\n+     * a given argument string.\n+     * \n+     * The returned Set must not be null.\n+     * \n+     * @return The set of triggers for this Option\n+     */\n+    Set getTriggers();\n+\n+    /**\n+     * Identifies the argument prefixes that should be considered options. This\n+     * is used to identify whether a given string looks like an option or an\n+     * argument value. Typically an option would return the set [--,-] while\n+     * switches might offer [-,+].\n+     * \n+     * The returned Set must not be null.\n+     * \n+     * @return The set of prefixes for this Option\n+     */\n+    Set getPrefixes();\n+\n+    /**\n+     * Checks that the supplied CommandLine is valid with respect to this\n+     * option.\n+     * \n+     * @param commandLine\n+     *            The CommandLine to check.\n+     * @throws OptionException\n+     *             if the CommandLine is not valid.\n+     */\n+    void validate(final WriteableCommandLine commandLine)\n+        throws OptionException;\n+\n+    /**\n+     * Builds up a list of HelpLineImpl instances to be presented by HelpFormatter.\n+     * \n+     * @see HelpLine\n+     * @see HelpFormatter\n+     * @param depth\n+     *            the initial indent depth\n+     * @param helpSettings\n+     *            the HelpSettings that should be applied\n+     * @param comp\n+     *            a comparator used to sort options when applicable.\n+     * @return a List of HelpLineImpl objects\n+     */\n+    List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp);\n+\n+    /**\n+     * Appends usage information to the specified StringBuffer\n+     * \n+     * @param buffer the buffer to append to\n+     * @param helpSettings a set of display settings @see DisplaySetting\n+     * @param comp a comparator used to sort the Options\n+     */\n+    void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp);\n+\n+    /**\n+     * The preferred name of an option is used for generating help and usage\n+     * information.\n+     * \n+     * @return The preferred name of the option\n+     */\n+    String getPreferredName();\n+\n+    /**\n+     * Returns a description of the option. This string is used to build help\n+     * messages as in the HelpFormatter.\n+     * \n+     * @see HelpFormatter\n+     * @return a description of the option.\n+     */\n+    String getDescription();\n+\n+    /**\n+     * Returns the id of the option.  This can be used in a loop and switch \n+     * construct:\n+     * \n+     * <code>\n+     * for(Option o : cmd.getOptions()){\n+     *     switch(o.getId()){\n+     *         case POTENTIAL_OPTION:\n+     *             ...\n+     *     }\n+     * }\n+     * </code> \n+     * \n+     * The returned value is not guarenteed to be unique.\n+     * \n+     * @return the id of the option.\n+     */\n+    int getId();\n+\n+\t/**\n+\t * Recursively searches for an option with the supplied trigger.\n+\t *\n+\t * @param trigger the trigger to search for.\n+\t * @return the matching option or null.\n+\t */\n+\tOption findOption(final String trigger);\n+\n+    /**\n+     * Indicates whether this option is required to be present.\n+     * @return true iff the CommandLine will be invalid without this Option\n+     */\n+    boolean isRequired();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/OptionException.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A problem found while dealing with command line options.\n+ */\n+public class OptionException extends Exception {\n+\n+    /**\n+     * The settings used when displaying the related Option.\n+     * \n+     * @see DisplaySetting\n+     */\n+    public static final Set HELP_SETTINGS = \n+        Collections.unmodifiableSet(\n+            Collections.singleton(\n+                DisplaySetting.DISPLAY_PROPERTY_OPTION));;\n+\n+    /** The Option the exception relates to */\n+    private final Option option;\n+    \n+    /** The message explaining the Exception */\n+    private final String message;\n+\n+    /** resource helper instance */\n+    private static final ResourceHelper helper =\n+        ResourceHelper.getResourceHelper(OptionException.class);\n+    \n+    /**\n+     * Creates a new OptionException.\n+     * \n+     * @param option\n+     *            The Option the exception relates to\n+     */\n+    public OptionException(final Option option) {\n+        this(option, null, null);\n+    }\n+    \n+    /**\n+     * Creates a new OptionException.\n+     * @param option the Option the exception relates to\n+     * @param messageKey the id of the message to display\n+     */\n+    public OptionException(final Option option, final String messageKey) {\n+        this(option, messageKey, null);\n+    }\n+\n+    /**\n+     * Creates a new OptionException.\n+     * @param option the Option the exception relates to\n+     * @param messageKey the id of the message to display\n+     * @param value a value to display with the message\n+     */\n+    public OptionException(\n+            final Option option, \n+            final String messageKey, \n+            final String value) {\n+        \n+        this.option = option;\n+        \n+        if (messageKey != null) {\n+            final StringBuffer buffer = new StringBuffer();\n+            if (value != null) {\n+                buffer.append(helper.getMessage(messageKey, value));\n+            }\n+            else {\n+                buffer.append(helper.getMessage(messageKey));\n+            }\n+            buffer.append(\" \");\n+\n+            option.appendUsage(buffer, HELP_SETTINGS, null);\n+            message = buffer.toString();\n+        }\n+        else {\n+            message = \"\";\n+        }\n+    }\n+    \n+    /**\n+     * Gets the Option the exception relates to\n+     * \n+     * @return The related Option\n+     */\n+    public Option getOption() {\n+        return option;\n+    }\n+    \n+    public String getMessage() {\n+        return message;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/Parent.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * An Option that can have an argument and/or group of child Options in the form \n+ * \"-f &lt;arg&gt; [-a|-b|-c]\".\n+ */\n+public interface Parent extends Option {\n+\n+    /**\n+     * Processes the parent part of the Option.  The combination of parent,\n+     * argument and children is handled by the process method.\n+     * @see Option#process(WriteableCommandLine, ListIterator)\n+     * \n+     * @param commandLine the CommandLine to write results to\n+     * @param args a ListIterator over argument strings positioned at the next\n+     *             argument to process\n+     * @throws OptionException if an error occurs while processing\n+     */\n+    void processParent(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args)\n+        throws OptionException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+/**\n+ * A CommandLine that detected values and options can be written to.\n+ */\n+public interface WriteableCommandLine extends CommandLine {\n+    \n+    /**\n+     * Adds an Option to the CommandLine\n+     * @param option the Option to add\n+     */\n+    void addOption(final Option option);\n+    \n+    /**\n+     * Adds a value to an Option in the CommandLine.\n+     * @param option the Option to add to\n+     * @param value the value to add\n+     */\n+    void addValue(final Option option, final Object value);\n+    \n+    /**\n+     * Adds a switch value to an Option in the CommandLine.\n+     * @param option the Option to add to\n+     * @param value the switch value to add\n+     * @throws IllegalStateException if the switch has already been added\n+     */\n+    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n+    \n+    /**\n+     * Adds a property value to a name in the CommandLine.\n+     * Replaces any existing value for the property.\n+     * \n+     * @param property the name of the property\n+     * @param value the value of the property\n+     */\n+    void addProperty(final String property, final String value);\n+    \n+    /**\n+     * Detects whether the argument looks like an Option trigger \n+     * @param argument the argument to test\n+     * @return true if the argument looks like an Option trigger\n+     */\n+    boolean looksLikeOption(final String argument);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/ArgumentBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.option.ArgumentImpl;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * Builds Argument instances.\n+ */\n+public class ArgumentBuilder {\n+\n+    /** name of the argument. Used for display and lookups in CommandLine */\n+    private String name;\n+\n+    /** description of the argument. Used in the automated online help */\n+    private String description;\n+\n+    /** minimum number of values required */\n+    private int minimum;\n+\n+    /** maximum number of values permitted */\n+    private int maximum;\n+\n+    /** character used to separate the values from the option */\n+    private char initialSeparator;\n+\n+    /** character used to separate the values from each other */\n+    private char subsequentSeparator;\n+\n+    /** object that should be used to ensure the values are valid */\n+    private Validator validator;\n+\n+    /** used to identify the consume remaining option, typically \"--\" */\n+    private String consumeRemaining;\n+\n+    /** default values for argument */\n+    private List defaultValues;\n+\n+    /** id of the argument */\n+    private int id;\n+\n+    /**\n+     * Creates a new ArgumentBuilder instance\n+     */\n+    public ArgumentBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Argument instance using the options specified in this\n+     * ArgumentBuilder.\n+     * \n+     * @return A new Argument instance.\n+     */\n+    public final Argument create() {\n+        final Argument argument =\n+            new ArgumentImpl(\n+                name,\n+                description,\n+                minimum,\n+                maximum,\n+                initialSeparator,\n+                subsequentSeparator,\n+                validator,\n+                consumeRemaining,\n+                defaultValues,\n+                id);\n+\n+        reset();\n+\n+        return argument;\n+    }\n+\n+    /**\n+     * Resets the ArgumentBuilder to the defaults for a new Argument. The\n+     * method should be called automatically at the end of a create() call.\n+     */\n+    public final void reset() {\n+        name = \"arg\";\n+        description = null;\n+        minimum = 0;\n+        maximum = Integer.MAX_VALUE;\n+        initialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\n+        subsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\n+        consumeRemaining = \"--\";\n+        defaultValues = null;\n+        id = 0;\n+    }\n+\n+    /**\n+     * Sets the name of the argument. The name is used when displaying usage\n+     * information and to allow lookups in the CommandLine object.\n+     * \n+     * @see org.apache.commons.cli2.CommandLine#getValue(String)\n+     * \n+     * @param newName\n+     *            the name of the argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withName(final String newName) {\n+        this.name = newName;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the description of the argument.\n+     * \n+     * The description is used when displaying online help.\n+     * \n+     * @param newDescription\n+     *            a description of the argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the minimum number of values needed for the argument to be valid.\n+     * \n+     * @param newMinimum\n+     *            the number of values needed\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withMinimum(final int newMinimum) {\n+        this.minimum = newMinimum;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum number of values allowed for the argument to be valid.\n+     * \n+     * @param newMaximum\n+     *            the number of values allowed\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withMaximum(final int newMaximum) {\n+        this.maximum = newMaximum;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the character used to separate the values from the option. When an\n+     * argument is of the form -libs:dir1,dir2,dir3 the initialSeparator would\n+     * be ':'.\n+     * \n+     * @param newInitialSeparator\n+     *            the character used to separate the values from the option\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withInitialSeparator(final char newInitialSeparator) {\n+\n+        this.initialSeparator = newInitialSeparator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the character used to separate the values from each other. When an\n+     * argument is of the form -libs:dir1,dir2,dir3 the subsequentSeparator\n+     * would be ','.\n+     * \n+     * @param newSubsequentSeparator\n+     *            the character used to separate the values from each other\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withSubsequentSeparator(final char newSubsequentSeparator) {\n+\n+        this.subsequentSeparator = newSubsequentSeparator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the validator instance used to perform validation on the Argument\n+     * values.\n+     * \n+     * @param newValidator\n+     *            a Validator instance\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withValidator(final Validator newValidator) {\n+        this.validator = newValidator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the \"consume remaining\" option, defaults to \"--\". Use this if you\n+     * want to allow values that might be confused with option strings.\n+     * \n+     * @param newConsumeRemaining\n+     *            the string to use for the consume remaining option\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withConsumeRemaining(final String newConsumeRemaining) {\n+\n+        this.consumeRemaining = newConsumeRemaining;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default value.\n+     * \n+     * @param defaultValue\n+     *            the default value for the Argument\n+     * \n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDefault(final Object defaultValue) {\n+        if (this.defaultValues == null) {\n+            this.defaultValues = new ArrayList(1);\n+        }\n+        this.defaultValues.add(defaultValue);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default values.\n+     * \n+     * @param newDefaultValues\n+     *            the default values for the Argument\n+     * \n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDefaults(final List newDefaultValues) {\n+        this.defaultValues = newDefaultValues;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     * \n+     * @param newId\n+     *            the id of the Argument\n+     * \n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withId(final int newId) {\n+        this.id = newId;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/CommandBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.Command;\n+\n+/**\n+ * Builds Command instances\n+ */\n+public class CommandBuilder {\n+\n+    private String preferredName;\n+    private String description;\n+    private Set aliases;\n+    private boolean required;\n+    private Argument argument;\n+    private Group children;\n+    private int id;\n+\n+    /**\n+     * Creates a new CommandBuilder instance\n+     */\n+    public CommandBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Command instance using the properties of the\n+     * CommandBuilder.\n+     * \n+     * @return the new Command instance\n+     */\n+    public Command create() {\n+\n+        // check we have a valid name\n+        if (preferredName == null) {\n+            throw new IllegalStateException(\"Options must have at least one name\");\n+        }\n+\n+        // build the command\n+        final Command option =\n+            new Command(\n+                preferredName,\n+                description,\n+                aliases,\n+                required,\n+                argument,\n+                children,\n+                id);\n+\n+        // reset the builder\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets the CommandBuilder to the defaults for a new Command. The method\n+     * should be called automatically at the end of a create() call.\n+     */\n+    public void reset() {\n+        preferredName = null;\n+        description = null;\n+        aliases = new HashSet();\n+        required = false;\n+        argument = null;\n+        children = null;\n+        id = 0;\n+    }\n+\n+    /**\n+     * Sets the name of the command. The first name is used as the preferred\n+     * display name for the Command and then later names are used as aliases.\n+     * \n+     * @param name\n+     *            a name for the Command\n+     * @return this CommandBuilder\n+     */\n+    public CommandBuilder withName(final String name) {\n+        if (preferredName == null) {\n+            preferredName = name;\n+        }\n+        else {\n+            aliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the description of the command. The description is used to produce\n+     * online help for the command.\n+     * \n+     * @param newDescription\n+     *            The description of the command\n+     * @return this CommandBuilder\n+     */\n+    public CommandBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this optionality\n+     * @param newRequired true iff the Option is required\n+     * @return this builder\n+     */\n+    public CommandBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the children of the Command.\n+     * \n+     * @param newChildren\n+     *            the child options for the Command\n+     * @return this CommandBuilder\n+     */\n+    public CommandBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the argument of the Command.\n+     * \n+     * @param newArgument\n+     *            the argument for the Command\n+     * @return this CommandBuilder\n+     */\n+    public CommandBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     * \n+     * @param newId\n+     *            the id of the Command\n+     * @return this CommandBuilder\n+     */\n+    public final CommandBuilder withId(final int newId) {\n+        this.id = newId;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/DefaultOptionBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.DefaultOption;\n+\n+/**\n+ * Builds DefaultOption instances.\n+ */\n+public class DefaultOptionBuilder {\n+\n+    private final String shortPrefix;\n+    private final String longPrefix;\n+    private final boolean burstEnabled;\n+\n+    private String preferredName;\n+    private Set aliases;\n+    private Set burstAliases;\n+    private boolean required;\n+\n+    private String description;\n+    private Argument argument;\n+    private Group children;\n+    private int id;\n+\n+    /**\n+     * Creates a new DefaultOptionBuilder using defaults\n+     * @see DefaultOption#DEFAULT_SHORT_PREFIX\n+     * @see DefaultOption#DEFAULT_LONG_PREFIX\n+     * @see DefaultOption#DEFAULT_BURST_ENABLED\n+     */\n+    public DefaultOptionBuilder() {\n+        this(\n+            DefaultOption.DEFAULT_SHORT_PREFIX,\n+            DefaultOption.DEFAULT_LONG_PREFIX,\n+            DefaultOption.DEFAULT_BURST_ENABLED);\n+    }\n+\n+    /**\n+     * Creates a new DefaultOptionBuilder\n+     * @param shortPrefix the prefix to use for short options\n+     * @param longPrefix the prefix to use for long options\n+     * @param burstEnabled whether to allow gnu style bursting\n+     * @throws IllegalArgumentException if either prefix is less than on \n+     *                                  character long\n+     */\n+    public DefaultOptionBuilder(\n+        final String shortPrefix,\n+        final String longPrefix,\n+        final boolean burstEnabled) throws IllegalArgumentException{\n+        if (shortPrefix == null || shortPrefix.length() == 0) {\n+            throw new IllegalArgumentException(\"shortPrefix should be at least 1 character long\");\n+        }\n+        else {\n+            this.shortPrefix = shortPrefix;\n+        }\n+\n+        if (longPrefix == null || longPrefix.length() == 0) {\n+            throw new IllegalArgumentException(\"longPrefix should be at least 1 character long\");\n+        }\n+        else {\n+            this.longPrefix = longPrefix;\n+        }\n+\n+        this.burstEnabled = burstEnabled;\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a DefaultOption instance\n+     * @return the new instance\n+     * @throws IllegalStateException if no names have been supplied\n+     */\n+    public DefaultOption create() throws IllegalStateException {\n+        if (preferredName == null) {\n+            throw new IllegalStateException(\"Options must have at least one name\");\n+        }\n+\n+        final DefaultOption option =\n+            new DefaultOption(\n+                shortPrefix,\n+                longPrefix,\n+                burstEnabled,\n+                preferredName,\n+                description,\n+                aliases,\n+                burstAliases,\n+                required,\n+                argument,\n+                children,\n+                id);\n+\n+        reset();\n+\n+        return option;\n+    }\n+    \n+    /**\n+     * Resets the builder\n+     */\n+    public void reset() {\n+        preferredName = null;\n+        description = null;\n+        aliases = new HashSet();\n+        burstAliases = new HashSet();\n+        required = false;\n+        argument = null;\n+        children = null;\n+        id = 0;\n+    }\n+\n+    /**\n+     * Use this short option name\n+     * @param shortName the name to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withShortName(final String shortName) {\n+        final String name = shortPrefix + shortName;\n+\n+        if (preferredName == null) {\n+            preferredName = name;\n+        }\n+        else {\n+            aliases.add(name);\n+        }\n+\n+        if (burstEnabled && name.length() == shortPrefix.length() + 1) {\n+            burstAliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this long option name\n+     * @param longName the name to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withLongName(final String longName) {\n+        final String name = longPrefix + longName;\n+        if (preferredName == null) {\n+            preferredName = name;\n+        }\n+        else {\n+            aliases.add(name);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this optionality\n+     * @param newRequired true iff the Option is required\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this child Group\n+     * @param newChildren the child Group to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this Argument\n+     * @param newArgument the argument to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     * \n+     * @param newId\n+     *            the id of the DefaultOption\n+     * @return this DefaultOptionBuilder\n+     */\n+    public final DefaultOptionBuilder withId(final int newId) {\n+        this.id = newId;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/GroupBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+/**\n+ * Builds Group instances\n+ */\n+public class GroupBuilder {\n+\n+    private String name;\n+    private String description;\n+    private List options;\n+    private int minimum;\n+    private int maximum;\n+\n+    /**\n+     * Creates a new GroupBuilder\n+     */\n+    public GroupBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Group instance\n+     * @return the new Group instance\n+     */\n+    public Group create() {\n+        final GroupImpl group =\n+            new GroupImpl(options, name, description, minimum, maximum);\n+\n+        reset();\n+\n+        return group;\n+    }\n+\n+    /**\n+     * Resets the builder\n+     */\n+    public void reset() {\n+        name = null;\n+        description = null;\n+        options = new ArrayList();\n+        minimum = 0;\n+        maximum = Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public GroupBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option name\n+     * @param newName the name to use\n+     * @return this builder\n+     */\n+    public GroupBuilder withName(final String newName) {\n+        this.name = newName;\n+        return this;\n+    }\n+\n+    /**\n+     * A valid group requires at least this many options present\n+     * @param newMinimum the minimum Options required\n+     * @return this builder\n+     */\n+    public GroupBuilder withMinimum(final int newMinimum) {\n+        this.minimum = newMinimum;\n+        return this;\n+    }\n+\n+    /**\n+     * A valid group requires at most this many options present\n+     * @param newMaximum the maximum Options allowed\n+     * @return this builder\n+     */\n+    public GroupBuilder withMaximum(final int newMaximum) {\n+        this.maximum = newMaximum;\n+        return this;\n+    }\n+\n+    /**\n+     * Add this option to the group\n+     * @param option the Option to add\n+     * @return this builder\n+     */\n+    public GroupBuilder withOption(final Option option) {\n+        this.options.add(option);\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.validation.ClassValidator;\n+import org.apache.commons.cli2.validation.DateValidator;\n+import org.apache.commons.cli2.validation.FileValidator;\n+import org.apache.commons.cli2.validation.NumberValidator;\n+import org.apache.commons.cli2.validation.UrlValidator;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * Builds Options using a String pattern\n+ */\n+//TODO Document and link to the acceptable patterns\n+public class PatternBuilder {\n+\n+    private final GroupBuilder gbuilder;\n+    private final DefaultOptionBuilder obuilder;\n+    private final ArgumentBuilder abuilder;\n+\n+    /**\n+     * Creates a new PatternBuilder\n+     */\n+    public PatternBuilder() {\n+        this(\n+            new GroupBuilder(),\n+            new DefaultOptionBuilder(),\n+            new ArgumentBuilder());\n+    }\n+\n+    /**\n+     * Creates a new PatternBuilder\n+     * @param gbuilder the GroupBuilder to use\n+     * @param obuilder the DefaultOptionBuilder to use\n+     * @param abuilder the ArgumentBuilder to use\n+     */\n+    public PatternBuilder(\n+        final GroupBuilder gbuilder,\n+        final DefaultOptionBuilder obuilder,\n+        final ArgumentBuilder abuilder) {\n+        this.gbuilder = gbuilder;\n+        this.obuilder = obuilder;\n+        this.abuilder = abuilder;\n+    }\n+\n+    private final Set options = new HashSet();\n+\n+    /**\n+     * Creates a new Option instance.\n+     * @return a new Option instance\n+     */\n+    public Option create() {\n+        final Option option;\n+\n+        if (options.size() == 1) {\n+            option = (Option)options.iterator().next();\n+        }\n+        else {\n+            gbuilder.reset();\n+            for (final Iterator i = options.iterator(); i.hasNext();) {\n+                gbuilder.withOption((Option)i.next());\n+            }\n+            option = gbuilder.create();\n+        }\n+\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets this builder\n+     */\n+    public void reset() {\n+        options.clear();\n+    }\n+\n+    private void createOption(\n+        final char type,\n+        final boolean required,\n+        final char opt) {\n+        final Argument argument;\n+        if (type != ' ') {\n+            abuilder.reset();\n+            abuilder.withValidator(validator(type));\n+            if (required) {\n+                abuilder.withMinimum(1);\n+            }\n+            if (type != '*') {\n+                abuilder.withMaximum(1);\n+            }\n+            argument = abuilder.create();\n+        }\n+        else {\n+            argument = null;\n+        }\n+\n+        obuilder.reset();\n+        obuilder.withArgument(argument);\n+        obuilder.withShortName(String.valueOf(opt));\n+        obuilder.withRequired(required);\n+\n+        options.add(obuilder.create());\n+    }\n+\n+    /**\n+     * Builds an Option using a pattern string.\n+     * @param pattern the pattern to build from\n+     */\n+    public void withPattern(final String pattern) {\n+        int sz = pattern.length();\n+\n+        char opt = ' ';\n+        char ch = ' ';\n+        char type = ' ';\n+        boolean required = false;\n+\n+        for (int i = 0; i < sz; i++) {\n+            ch = pattern.charAt(i);\n+\n+            switch (ch) {\n+                case '!' :\n+                    required = true;\n+                    break;\n+                case '@' :\n+                case ':' :\n+                case '%' :\n+                case '+' :\n+                case '#' :\n+                case '<' :\n+                case '>' :\n+                case '*' :\n+                case '/' :\n+                    type = ch;\n+                    break;\n+                default :\n+                    if (opt != ' ') {\n+                        createOption(type, required, opt);\n+                        required = false;\n+                        type = ' ';\n+                    }\n+\n+                    opt = ch;\n+            }\n+        }\n+\n+        if (opt != ' ') {\n+            createOption(type, required, opt);\n+        }\n+    }\n+\n+    private static Validator validator(final char c) {\n+        switch (c) {\n+            case '@' :\n+                final ClassValidator classv = new ClassValidator();\n+                classv.setInstance(true);\n+                return classv;\n+            case '+' :\n+                final ClassValidator instancev = new ClassValidator();\n+                return instancev;\n+                //case ':':// no validator needed for a string\n+            case '%' :\n+                return NumberValidator.getNumberInstance();\n+            case '#' :\n+                return DateValidator.getDateInstance();\n+            case '<' :\n+                final FileValidator existingv = new FileValidator();\n+                existingv.setExisting(true);\n+                existingv.setFile(true);\n+                return existingv;\n+            case '>' :\n+            case '*' :\n+                return new FileValidator();\n+            case '/' :\n+                return new UrlValidator();\n+            default :\n+                return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.Switch;\n+\n+/**\n+ * Builds Switch instance.\n+ */\n+public class SwitchBuilder {\n+\n+    private final String enabledPrefix;\n+    private final String disabledPrefix;\n+\n+    private String description;\n+    private String preferredName;\n+    private Set aliases;\n+    private boolean required;\n+    private Argument argument;\n+    private Group children;\n+    private int id;\n+\n+    /**\n+     * Creates a new SwitchBuilder using defaults.\n+     * @see Switch#DEFAULT_ENABLED_PREFIX\n+     * @see Switch#DEFAULT_DISABLED_PREFIX\n+     */\n+    public SwitchBuilder() {\n+        this(Switch.DEFAULT_ENABLED_PREFIX, Switch.DEFAULT_DISABLED_PREFIX);\n+    }\n+\n+    /**\n+     * Creates a new SwitchBuilder\n+     * @param enabledPrefix the prefix to use for enabling the option\n+     * @param disabledPrefix the prefix to use for disabling the option\n+     * @throws IllegalArgumentException if either prefix is less than 1 \n+     *                                  character long or the prefixes match\n+     */\n+    public SwitchBuilder(\n+        final String enabledPrefix,\n+        final String disabledPrefix) throws IllegalArgumentException {\n+        if (enabledPrefix == null || enabledPrefix.length() < 1) {\n+            throw new IllegalArgumentException(\"enabledPrefix should be at least 1 character long\");\n+        }\n+        if (disabledPrefix == null || disabledPrefix.length() < 1) {\n+            throw new IllegalArgumentException(\"disabledPrefix should be at least 1 character long\");\n+        }\n+        if (enabledPrefix.equals(disabledPrefix)) {\n+            throw new IllegalArgumentException(\"disabledPrefix and enabledPrefix should be different\");\n+        }\n+        this.enabledPrefix = enabledPrefix;\n+        this.disabledPrefix = disabledPrefix;\n+        reset();\n+    }\n+    \n+    /**\n+     * Creates a new Switch instance\n+     * @return a new Switch instance\n+     */\n+    public Switch create() {\n+        final Switch option =\n+            new Switch(\n+                enabledPrefix,\n+                disabledPrefix,\n+                preferredName,\n+                aliases,\n+                description,\n+                required,\n+                argument,\n+                children,\n+                id);\n+\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets the builder\n+     */\n+    public void reset() {\n+        description = null;\n+        preferredName = null;\n+        required = false;\n+        aliases = new HashSet();\n+        argument = null;\n+        children = null;\n+        id = 0;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option name\n+     * @param name the name to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withName(final String name) {\n+        if (preferredName == null) {\n+            preferredName = name;\n+        }\n+        else {\n+            aliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this optionality\n+     * @param newRequired true iff the Option is required\n+     * @return this builder\n+     */\n+    public SwitchBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this Argument\n+     * @param newArgument the argument to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this child Group\n+     * @param newChildren the child Group to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     * \n+     * @param newId\n+     *            the id of the Switch\n+     * @return this SwitchBuilder\n+     */\n+    public final SwitchBuilder withId(final int newId) {\n+        this.id = newId;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/CommandLineImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * Instances of CommandLine represent a command line that has been processed\n+ * according to the definition supplied to the parser.\n+ */\n+public abstract class CommandLineImpl implements CommandLine {\n+\n+    public final boolean hasOption(final String trigger) {\n+        return hasOption(getOption(trigger));\n+    }\n+\n+    public final List getValues(final String trigger) {\n+        return getValues(getOption(trigger),Collections.EMPTY_LIST);\n+    }\n+\n+    public final List getValues(final String trigger, final List defaultValues) {\n+        return getValues(getOption(trigger), defaultValues);\n+    }\n+\n+    public final List getValues(final Option option) {\n+        return getValues(option, Collections.EMPTY_LIST);\n+    }\n+\n+    public final Object getValue(final String trigger) {\n+        return getValue(getOption(trigger),null);\n+    }\n+\n+    public final Object getValue(final String trigger, final Object defaultValue) {\n+        return getValue(getOption(trigger), defaultValue);\n+    }\n+\n+    public final Object getValue(final Option option) {\n+        return getValue(option, null);\n+    }\n+\n+    public final Object getValue(final Option option, final Object defaultValue) {\n+\n+        final List values;\n+        if (defaultValue == null) {\n+            values = getValues(option);\n+        }\n+        else {\n+            values = getValues(option, Collections.singletonList(defaultValue));\n+        }\n+\n+        if (values.size() > 1) {\n+            throw new IllegalStateException(\"More than one value was supplied\");\n+        }\n+\n+        if (values.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        return values.get(0);\n+    }\n+\n+    public final Boolean getSwitch(final String trigger) {\n+        return getSwitch(getOption(trigger), null);\n+    }\n+\n+    public final Boolean getSwitch(\n+        final String trigger,\n+        final Boolean defaultValue) {\n+        return getSwitch(getOption(trigger), defaultValue);\n+    }\n+\n+    public final Boolean getSwitch(final Option option) {\n+        return getSwitch(option, null);\n+    }\n+\n+    public final String getProperty(final String property) {\n+        return getProperty(property,null);\n+    }\n+\n+    public final int getOptionCount(final String trigger) {\n+        return getOptionCount(getOption(trigger));\n+    }\n+\n+    public final int getOptionCount(final Option option) {\n+        if (option == null) {\n+            return 0;\n+        }\n+\n+        int count = 0;\n+        for (Iterator i = getOptions().iterator(); i.hasNext();) {\n+            if (option.equals(i.next())) {\n+                ++count;\n+            }\n+        }\n+\n+        return count;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/DefaultingCommandLine.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * Manages a queue of default CommandLines. This CommandLine implementation is\n+ * backed by a queue of CommandLine instances which are queried in turn until a\n+ * suitable result is found.\n+ * \n+ * CommandLine instances can either be added to the back of the queue or can be\n+ * pushed in at a specific position.\n+ * \n+ * @see #appendCommandLine(CommandLine)\n+ * @see #insertCommandLine(int, CommandLine)\n+ */\n+public class DefaultingCommandLine extends CommandLineImpl {\n+\n+    /**\n+     * The list of default CommandLine instances\n+     */\n+    private final List commandLines = new ArrayList();\n+\n+    /**\n+     * Adds a CommandLine instance to the back of the queue. The supplied\n+     * CommandLine will be used as defaults when all other CommandLines produce\n+     * no result\n+     * \n+     * @param commandLine\n+     *            the default values to use if all CommandLines\n+     */\n+    public void appendCommandLine(final CommandLine commandLine) {\n+        commandLines.add(commandLine);\n+    }\n+    \n+    /**\n+     * Adds a CommandLine instance to a specified position in the queue.\n+     * \n+     * @param index ths position at which to insert\n+     * @param commandLine the CommandLine to insert\n+     */\n+    public void insertCommandLine(\n+        final int index,\n+        final CommandLine commandLine) {\n+        commandLines.add(index, commandLine);\n+    }\n+    \n+    /**\n+     * Builds an iterator over the build in CommandLines.\n+     * \n+     * @return an unmodifiable iterator\n+     */\n+    public Iterator commandLines(){\n+    \treturn Collections.unmodifiableList(commandLines).iterator();\n+    }\n+\n+    public Option getOption(String trigger) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final Option actual = commandLine.getOption(trigger);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public List getOptions() {\n+        final List options = new ArrayList();\n+\n+        final List temp = new ArrayList();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            temp.clear();\n+            temp.addAll(commandLine.getOptions());\n+            temp.removeAll(options);\n+            options.addAll(temp);\n+        }\n+\n+        return Collections.unmodifiableList(options);\n+    }\n+\n+    public Set getOptionTriggers() {\n+        final Set all = new HashSet();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            all.addAll(commandLine.getOptionTriggers());\n+        }\n+\n+        return Collections.unmodifiableSet(all);\n+    }\n+\n+    public boolean hasOption(Option option) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            if (commandLine.hasOption(option)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public List getValues(Option option, List defaultValues) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final List actual = commandLine.getValues(option);\n+            if (actual != null && !actual.isEmpty()) {\n+                return actual;\n+            }\n+        }\n+        if(defaultValues==null){\n+        \treturn Collections.EMPTY_LIST;\n+        }\n+        else{\n+        \treturn defaultValues;\n+        }\n+    }\n+\n+    public Boolean getSwitch(Option option, Boolean defaultValue) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final Boolean actual = commandLine.getSwitch(option);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public String getProperty(String property, String defaultValue) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final String actual = commandLine.getProperty(property);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public Set getProperties() {\n+        final Set all = new HashSet();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            all.addAll(commandLine.getProperties());\n+        }\n+        return Collections.unmodifiableSet(all);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/Parser.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * A class that implements the <code>Parser</code> interface can parse a\n+ * String array according to the {@link Group}specified and return a\n+ * {@link CommandLine}.\n+ * \n+ * @author John Keyes (john at integralsource.com)\n+ */\n+public class Parser {\n+    private HelpFormatter helpFormatter = new HelpFormatter();\n+    private Option helpOption = null;\n+    private String helpTrigger = null;\n+    private Group group = null;\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     * \n+     * @param arguments\n+     *            the command line arguments\n+     * \n+     * @return the list of atomic option and value tokens\n+     * @throws OptionException\n+     *             if there are any problems encountered while parsing the\n+     *             command line tokens.\n+     */\n+    public CommandLine parse(final String[] arguments) throws OptionException {\n+\n+        final List argumentList = new LinkedList(Arrays.asList(arguments));\n+        final ListIterator iterator = argumentList.listIterator();\n+        final WriteableCommandLine commandLine =\n+            new WriteableCommandLineImpl(group, new ArrayList());\n+\n+        while (group.canProcess(iterator)) {\n+            group.process(commandLine, iterator);\n+        }\n+\n+        if (iterator.hasNext()) {\n+            final String arg = (String)iterator.next();\n+            throw new OptionException(group, \"cli.error.unexpected\", arg);\n+        }\n+\n+        group.validate(commandLine);\n+\n+        return commandLine;\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties and\n+     * displays the usage screen if the CommandLine is not valid or the help\n+     * option was specified.\n+     * \n+     * @param arguments the command line arguments\n+     * @return a valid CommandLine or null if the parse was unsuccessful\n+     * @throws IOException if an error occurs while formatting help\n+     */\n+    public CommandLine parseAndHelp(final String[] arguments)\n+        throws IOException {\n+\n+        helpFormatter.setGroup(group);\n+\n+        try {\n+            // attempt to parse the command line\n+            final CommandLine commandLine = parse(arguments);\n+            if (!commandLine.hasOption(helpOption)\n+                && !commandLine.hasOption(helpTrigger)) {\n+\n+                return commandLine;\n+            }\n+        }\n+        catch (final OptionException oe) {\n+            // display help regarding the exception\n+            helpFormatter.setException(oe);\n+        }\n+\n+        // print help\n+        helpFormatter.print();\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the Group of options to parse against\n+     * @param group the group of options to parse against\n+     */\n+    public void setGroup(final Group group) {\n+        this.group = group;\n+    }\n+\n+    /**\n+     * Sets the HelpFormatter to use with the simplified parsing.\n+     * @see #parseAndHelp(String[])\n+     * @param helpFormatter the HelpFormatter to use with the simplified parsing\n+     */\n+    public void setHelpFormatter(final HelpFormatter helpFormatter) {\n+        this.helpFormatter = helpFormatter;\n+    }\n+\n+    /**\n+     * Sets the help option to use with the simplified parsing.  For example\n+     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.\n+     * @see #parseAndHelp(String[])\n+     * @param helpOption the help Option\n+     */\n+    public void setHelpOption(final Option helpOption) {\n+        this.helpOption = helpOption;\n+    }\n+\n+    /**\n+     * Sets the help option to use with the simplified parsing.  For example\n+     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.\n+     * @see #parseAndHelp(String[])\n+     * @param helpTrigger the trigger of the help Option\n+     */\n+    public void setHelpTrigger(final String helpTrigger) {\n+        this.helpTrigger = helpTrigger;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/PreferencesCommandLine.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.prefs.BackingStoreException;\n+import java.util.prefs.Preferences;\n+\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * A CommandLine implementation using the Preferences API, useful when\n+ * constructing a complex DefaultingCommandLine\n+ *\n+ * This implementation uses the children of a single preference node to populate\n+ * the CommandLine.  Options are keyed from their preferred name and presence in\n+ * the Preferences object is taken as presence in the CommandLine.  Argument\n+ * values are taken from the Preference value and are optionally separated using\n+ * the separator char defined, at construction time.  Switch values can be\n+ * specified using a simple value of <code>true</code> or <code>false</code>;\n+ * obviously this means that Switches with Arguments are not supported by this\n+ * implementation.\n+ *\n+ * @see java.util.prefs.Preferences\n+ * @see org.apache.commons.cli2.commandline.DefaultingCommandLine\n+ * @see org.apache.commons.cli2.Option#getPreferredName() \n+ */\n+public class PreferencesCommandLine extends CommandLineImpl {\n+\t\n+\tprivate static final char NUL = '\\0';\n+\tprivate final Preferences preferences;\n+\tprivate final Option root;\n+\tprivate final char separator;\n+\t\n+\t/**\n+     * Creates a new PreferencesCommandLine using the specified root Option and\n+     * Preferences node.  Argument values will be separated using the char 0.\n+     * \n+\t * @param root the CommandLine's root Option\n+\t * @param preferences the Preferences node to get values from\n+\t */\n+\tpublic PreferencesCommandLine(final Option root, final Preferences preferences){\n+\t\tthis(root,preferences,NUL);\n+\t}\n+\t\n+    /**\n+     * Creates a new PreferencesCommandLine using the specified root Option,\n+     * Preferences node and value separator.\n+     * \n+     * @param root the CommandLine's root Option\n+     * @param preferences the Preferences node to get values from\n+     * @param separator the character to split argument values\n+     */\n+\tpublic PreferencesCommandLine(final Option root, final Preferences preferences, final char separator){\n+\t\tthis.root = root;\n+\t\tthis.preferences = preferences;\n+\t\tthis.separator = separator;\n+\t}\n+\t\n+\tpublic boolean hasOption(Option option) {\n+\t\tif(option==null){\n+\t\t\treturn false;\n+\t\t}\n+\t\telse{\n+\t\t\ttry {\n+\t\t\t\treturn Arrays.asList(preferences.keys()).contains(option.getPreferredName());\n+\t\t\t} catch (BackingStoreException e) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic Option getOption(String trigger) {\n+\t\treturn root.findOption(trigger);\n+\t}\n+\n+\tpublic List getValues(final Option option, final List defaultValues) {\n+\t\tfinal String value = preferences.get(option.getPreferredName(),null);\n+\t\t\n+\t\tif(value==null){\n+\t\t\treturn defaultValues;\n+\t\t}\n+\t\telse if(separator>NUL){\n+\t\t\tfinal List values = new ArrayList();\n+\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\n+\t\t\t\n+\t\t\twhile(tokens.hasMoreTokens()){\n+\t\t\t\tvalues.add(tokens.nextToken());\n+\t\t\t}\n+\t\t\t\n+\t\t\treturn values;\n+\t\t}\n+\t\telse{\n+\t\t\treturn Collections.singletonList(value);\n+\t\t}\n+\t}\n+\n+\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+\t\tfinal String value = preferences.get(option.getPreferredName(),null);\n+\t\tif(\"true\".equals(value)){\n+\t\t\treturn Boolean.TRUE;\n+\t\t}\n+\t\telse if(\"false\".equals(value)){\n+\t\t\treturn Boolean.FALSE;\n+\t\t}\n+\t\telse{\n+\t\t\treturn defaultValue;\n+\t\t}\n+\t}\n+\t\n+\tpublic String getProperty(final String property, final String defaultValue) {\n+\t\treturn preferences.get(property, defaultValue);\n+\t}\n+\n+\tpublic Set getProperties() {\n+\t\ttry {\n+\t\t\treturn new HashSet(Arrays.asList(preferences.keys()));\n+\t\t} catch (BackingStoreException e) {\n+\t\t\treturn Collections.EMPTY_SET;\n+\t\t}\n+\t}\n+\n+\tpublic List getOptions() {\n+\t\ttry {\n+\t\t\tfinal List options = new ArrayList();\n+\t\t\tfinal Iterator keys = Arrays.asList(preferences.keys()).iterator();\n+\t\t\twhile (keys.hasNext()) {\n+\t\t\t\tfinal String trigger = (String) keys.next();\n+\t\t\t\tfinal Option option = root.findOption(trigger);\n+\t\t\t\tif (option != null) {\n+\t\t\t\t\toptions.add(option);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Collections.unmodifiableList(options);\n+\t\t} catch (BackingStoreException e) {\n+\t\t\treturn Collections.EMPTY_LIST;\n+\t\t}\n+\t}\n+\n+\tpublic Set getOptionTriggers() {\n+\t\tfinal Set triggers = new HashSet();\n+\t\tfinal Iterator options = getOptions().iterator();\n+\t\twhile(options.hasNext()){\n+\t\t\tfinal Option option = (Option)options.next();\n+\t\t\ttriggers.addAll(option.getTriggers());\n+\t\t}\n+\t\treturn Collections.unmodifiableSet(triggers);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/PropertiesCommandLine.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * A CommandLine implementation using a java Properties instance, useful for\n+ * constructing a complex DefaultingCommandLine\n+ *\n+ * Options are keyed from their property name and presence in the Properties\n+ * instance is taken as presence in the CommandLine.  Argument values are taken\n+ * from the property value and are optionally separated using the separator\n+ * char, defined at construction time.  Switch values can be specified using a\n+ * simple value of <code>true</code> or <code>false</code>; obviously this means\n+ * that Switches with Arguments are not supported by this implementation.\n+ *\n+ * @see java.util.Properties\n+ * @see org.apache.commons.cli2.commandline.DefaultingCommandLine\n+ * @see org.apache.commons.cli2.Option#getPreferredName() \n+ */\n+public class PropertiesCommandLine extends CommandLineImpl {\n+\t\n+\tprivate static final char NUL = '\\0';\n+\tprivate final Properties properties;\n+\tprivate final Option root;\n+\tprivate final char separator;\n+\t\n+    /**\n+     * Creates a new PropertiesCommandLine using the specified root Option,\n+     * Properties instance.  The character 0 is used as the value separator.\n+     *\n+     * @param root the CommandLine's root Option\n+     * @param properties the Properties instance to get values from\n+     */\n+\tpublic PropertiesCommandLine(final Option root, final Properties properties){\n+\t\tthis(root,properties,NUL);\n+\t}\n+\t\n+    /**\n+     * Creates a new PropertiesCommandLine using the specified root Option,\n+     * Properties instance and value separator.\n+     *\n+     * @param root the CommandLine's root Option\n+     * @param properties the Properties instance to get values from\n+     * @param separator the character to split argument values\n+     */\n+\tpublic PropertiesCommandLine(final Option root, final Properties properties, final char separator){\n+\t\tthis.root = root;\n+\t\tthis.properties = properties;\n+\t\tthis.separator = separator;\n+\t}\n+\t\n+\n+\tpublic boolean hasOption(Option option) {\n+\t\tif(option==null){\n+\t\t\treturn false;\n+\t\t}\n+\t\telse{\n+\t\t\treturn properties.containsKey(option.getPreferredName());\n+\t\t}\n+\t}\n+\n+\tpublic Option getOption(String trigger) {\n+\t\treturn root.findOption(trigger);\n+\t}\n+\n+\tpublic List getValues(final Option option, final List defaultValues) {\n+\t\tfinal String value = properties.getProperty(option.getPreferredName());\n+\t\t\n+\t\tif(value==null){\n+\t\t\treturn defaultValues;\n+\t\t}\n+\t\telse if(separator>NUL){\n+\t\t\tfinal List values = new ArrayList();\n+\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\n+\t\t\t\n+\t\t\twhile(tokens.hasMoreTokens()){\n+\t\t\t\tvalues.add(tokens.nextToken());\n+\t\t\t}\n+\t\t\t\n+\t\t\treturn values;\n+\t\t}\n+\t\telse{\n+\t\t\treturn Collections.singletonList(value);\n+\t\t}\n+\t}\n+\n+\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+\t\tfinal String value = properties.getProperty(option.getPreferredName());\n+\t\tif(\"true\".equals(value)){\n+\t\t\treturn Boolean.TRUE;\n+\t\t}\n+\t\telse if(\"false\".equals(value)){\n+\t\t\treturn Boolean.FALSE;\n+\t\t}\n+\t\telse{\n+\t\t\treturn defaultValue;\n+\t\t}\n+\t}\n+\t\n+\tpublic String getProperty(final String property, final String defaultValue) {\n+\t\treturn properties.getProperty(property,defaultValue);\n+\t}\n+\n+\tpublic Set getProperties() {\n+\t\treturn properties.keySet();\n+\t}\n+\n+\tpublic List getOptions() {\n+\t\tfinal List options = new ArrayList();\n+\t\tfinal Iterator keys = properties.keySet().iterator();\n+\t\twhile(keys.hasNext()){\n+\t\t\tfinal String trigger = (String)keys.next();\n+\t\t\tfinal Option option = root.findOption(trigger);\n+\t\t\tif(option!=null){\n+\t\t\t\toptions.add(option);\n+\t\t\t}\n+\t\t}\n+\t\treturn Collections.unmodifiableList(options);\n+\t}\n+\n+\tpublic Set getOptionTriggers() {\n+\t\tfinal Set triggers = new HashSet();\n+\t\tfinal Iterator options = getOptions().iterator();\n+\t\twhile(options.hasNext()){\n+\t\t\tfinal Option option = (Option)options.next();\n+\t\t\ttriggers.addAll(option.getTriggers());\n+\t\t}\n+\t\treturn Collections.unmodifiableSet(triggers);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * A WriteableCommandLine implementation allowing Options to write their\n+ * processed information to a CommandLine.\n+ */\n+public class WriteableCommandLineImpl extends CommandLineImpl implements WriteableCommandLine {\n+\n+    private final Properties properties = new Properties();\n+    private final List options = new ArrayList();\n+    private final Map nameToOption = new HashMap();\n+    private final Map values = new HashMap();\n+    private final Map switches = new HashMap();\n+    private final Map defaults = new HashMap();\n+    private final List normalised;\n+    private final Set prefixes;\n+\n+    private CommandLine defaultCommandLine = null;\n+\n+    /**\n+     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n+     * hold the parsed arguments.\n+     *\n+     * @param rootOption the CommandLine's root Option\n+     * @param arguments the arguments this CommandLine represents\n+     */\n+    public WriteableCommandLineImpl(final Option rootOption, final List arguments) {\n+        this.prefixes = rootOption.getPrefixes();\n+        this.normalised = arguments;\n+    }\n+\n+    public void addOption(Option option) {\n+        options.add(option);\n+        nameToOption.put(option.getPreferredName(), option);\n+        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n+            nameToOption.put(i.next(), option);\n+        }\n+    }\n+\n+    public void addValue(final Option option, final Object value) {\n+        if (option instanceof Argument) {\n+            addOption(option);\n+        }\n+        List valueList = (List)values.get(option);\n+        if (valueList == null) {\n+            valueList = new ArrayList();\n+            values.put(option, valueList);\n+        }\n+        valueList.add(value);\n+    }\n+\n+    public void addSwitch(final Option option, final boolean value) {\n+        addOption(option);\n+        if (switches.containsKey(option)) {\n+            throw new IllegalStateException(\"Switch already set\");\n+        }\n+        else {\n+            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+    }\n+\n+    public boolean hasOption(final Option option) {\n+        final boolean present = options.contains(option);\n+        if (!present && defaultCommandLine != null) {\n+            return defaultCommandLine.hasOption(option);\n+        }\n+        else {\n+            return present;\n+        }\n+    }\n+    \n+    public Option getOption(final String trigger) {\n+        return (Option)nameToOption.get(trigger);\n+    }\n+\n+    //TODO Document the order of values and defaults\n+    public List getValues(final Option option, final List defaultValues) {\n+\n+        // First grab the command line values\n+        List valueList = (List)values.get(option);\n+\n+        // Secondly try alternate CommandLines\n+        if ((valueList == null || valueList.isEmpty())\n+        && defaultCommandLine != null) {\n+            valueList = defaultCommandLine.getValues(option, null);\n+        }\n+\n+        // Thirdly try the defaults supplied to the method\n+        if (valueList == null || valueList.isEmpty()) {\n+            valueList = defaultValues;\n+        }\n+\n+        // Fourthly try the option's default values\n+        if (valueList == null || valueList.isEmpty()) {\n+            valueList = (List)this.defaults.get(option);\n+        }\n+\n+        // Finally use an empty list\n+        if (valueList == null) {\n+            valueList = Collections.EMPTY_LIST;\n+        }\n+\n+        return valueList;\n+    }\n+    \n+    public Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+        // First grab the command line values\n+        Boolean bool = (Boolean)switches.get(option);\n+\n+        // Secondly try alternate CommandLines\n+        if (bool == null && defaultCommandLine != null) {\n+            bool = defaultCommandLine.getSwitch(option);\n+        }\n+\n+        // Thirdly try the defaults supplied to the method\n+        if (bool == null) {\n+            bool = defaultValue;\n+        }\n+\n+        // Fourthly try the option's default values\n+        //????\n+\n+        return bool;\n+    }\n+\n+    public void addProperty(final String property, final String value) {\n+        properties.setProperty(property, value);\n+    }\n+    \n+    public String getProperty(final String property, final String defaultValue) {\n+        return properties.getProperty(property,defaultValue);\n+    }\n+\n+    public Set getProperties() {\n+        if (defaultCommandLine == null) {\n+            return Collections.unmodifiableSet(properties.keySet());\n+        }\n+        else {\n+            final Set props = new HashSet();\n+            props.addAll(properties.keySet());\n+            props.addAll(defaultCommandLine.getProperties());\n+            return Collections.unmodifiableSet(props);\n+        }\n+    }\n+    \n+    public boolean looksLikeOption(final String trigger) {\n+        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n+            final String prefix = (String)i.next();\n+            if (trigger.startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public String toString() {\n+        final StringBuffer buffer = new StringBuffer();\n+\n+        // need to add group header\n+\n+        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n+            final String arg = (String)i.next();\n+            if (arg.indexOf(' ') >= 0) {\n+                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n+            }\n+            else {\n+                buffer.append(arg);\n+            }\n+            if (i.hasNext()) {\n+                buffer.append(' ');\n+            }\n+        }\n+\n+        return buffer.toString();\n+    }\n+    \n+    public List getOptions() {\n+        return Collections.unmodifiableList(options);\n+    }\n+\n+    public Set getOptionTriggers() {\n+        return Collections.unmodifiableSet(nameToOption.keySet());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.InvalidArgumentException;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * An implementation of an Argument.\n+ */\n+public class ArgumentImpl extends OptionImpl implements Argument {\n+\n+    private final String name;\n+    private final String description;\n+    private final int minimum;\n+    private final int maximum;\n+    private final char initialSeparator;\n+    private final char subsequentSepatator;\n+    private final boolean subsequentSplit;\n+    private final Validator validator;\n+    private final String consumeRemaining;\n+    private final List defaultValues;\n+    private final ResourceHelper resources \n+        = ResourceHelper.getResourceHelper(ArgumentImpl.class);\n+\n+    private static final char NUL = '\\0';\n+    \n+    /**\n+     * The default value for the initial separator char.\n+     */\n+    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n+    \n+    /**\n+     * The default value for the subsequent separator char.\n+     */\n+    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n+    \n+    /**\n+     * The default token to indicate that remaining arguments should be consumed\n+     * as values.\n+     */\n+    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n+\n+    /**\n+     * Creates a new Argument instance.\n+     * \n+     * @param name\n+     *            The name of the argument\n+     * @param description\n+     *            A description of the argument\n+     * @param minimum\n+     *            The minimum number of values needed to be valid\n+     * @param maximum\n+     *            The maximum number of values allowed to be valid\n+     * @param initialSeparator\n+     *            The char separating option from value\n+     * @param subsequentSeparator\n+     *            The char separating values from each other\n+     * @param validator\n+     *            The object responsible for validating the values\n+     * @param consumeRemaining\n+     *            The String used for the \"consuming option\" group\n+     * @param defaultValues\n+     *            The values to be used if none are specified.\n+     * @param id\n+     *            The id of the option, 0 implies automatic assignment.\n+     * \n+     * @see OptionImpl#OptionImpl(int,boolean)\n+     */\n+    public ArgumentImpl(\n+        final String name,\n+        final String description,\n+        final int minimum,\n+        final int maximum,\n+        final char initialSeparator,\n+        final char subsequentSeparator,\n+        final Validator validator,\n+        final String consumeRemaining,\n+        final List defaultValues,\n+        final int id) {\n+        \n+        super(id,false);\n+\n+        this.name = (name == null) ? \"arg\" : name;\n+        this.description = description;\n+        this.minimum = minimum;\n+        this.maximum = maximum;\n+        this.initialSeparator = initialSeparator;\n+        this.subsequentSepatator = subsequentSeparator;\n+        this.subsequentSplit = subsequentSeparator != NUL;\n+        this.validator = validator;\n+        this.consumeRemaining = consumeRemaining;\n+        this.defaultValues = defaultValues;\n+\n+        if (minimum > maximum) {\n+            throw new IllegalArgumentException(\n+                resources.getMessage(\"cli.error.minimum.exceeds.maximum\"));\n+        }\n+\n+        if (defaultValues != null) {\n+            if (defaultValues.size() < minimum) {\n+                throw new IllegalArgumentException(\n+                    resources.getMessage(\"cli.error.too.few.defaults\"));\n+            }\n+\n+            if (defaultValues.size() > maximum) {\n+                throw new IllegalArgumentException(\n+                    resources.getMessage(\"cli.error.too.many.defaults\"));\n+            }\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return name;\n+    }\n+\n+    public void processValues(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments,\n+        final Option option)\n+        throws OptionException {\n+        int argumentCount = commandLine.getValues(option).size();\n+        final int initialCount = argumentCount;\n+        while (arguments.hasNext() && argumentCount < maximum) {\n+\n+            final String allValues =\n+                stripBoundaryQuotes((String)arguments.next());\n+            \n+            // should we ignore things that look like options?\n+            if (allValues.equals(consumeRemaining)) {\n+                while (arguments.hasNext() && argumentCount < maximum) {\n+                    ++argumentCount;\n+                    commandLine.addValue(option, arguments.next());\n+                }\n+            }\n+            // does it look like an option?\n+            else if (commandLine.looksLikeOption(allValues)) {\n+                arguments.previous();\n+                break;\n+            }\n+            // should we split the string up?\n+            else if (subsequentSplit) {\n+                final StringTokenizer values =\n+                    new StringTokenizer(\n+                        allValues,\n+                        String.valueOf(subsequentSepatator));\n+\n+                arguments.remove();\n+\n+                while (values.hasMoreTokens() && argumentCount < maximum) {\n+                    ++argumentCount;\n+                    final String token = values.nextToken();\n+                    commandLine.addValue(option, token);\n+                    arguments.add(token);\n+                }\n+\n+                if (values.hasMoreTokens()) {\n+                    throw new OptionException(\n+                        option,\n+                        \"cli.error.unexpected.value\",\n+                        values.nextToken());\n+                }\n+            }\n+            // it must be a value as it is\n+            else {\n+                ++argumentCount;\n+                commandLine.addValue(option, allValues);\n+            }\n+        }\n+\n+        if (this.defaultValues == null\n+            && (argumentCount < minimum || initialCount == argumentCount)) {\n+                throw new OptionException(option, \"cli.error.missing.values\");\n+        }\n+    }\n+\n+    public boolean canProcess(String arg) {\n+        return true;\n+    }\n+\n+    public Set getPrefixes() {\n+        return Collections.EMPTY_SET;\n+    }\n+\n+    public void process(WriteableCommandLine commandLine, ListIterator args)\n+        throws OptionException {\n+        processValues(commandLine, args, this);\n+    }\n+\n+    public char getInitialSeparator() {\n+        return this.initialSeparator;\n+    }\n+    \n+    public Set getTriggers() {\n+        return Collections.EMPTY_SET;\n+    }\n+\n+    public void validate(final WriteableCommandLine commandLine)\n+        throws OptionException {\n+        validate(commandLine, this);\n+    }\n+\n+    public void validate(\n+        final WriteableCommandLine commandLine,\n+        final Option option)\n+        throws OptionException {\n+\n+        final List values = commandLine.getValues(option);\n+\n+        if (values.size() < minimum) {\n+            throw new OptionException(option, \"cli.error.missing.values\");\n+        }\n+\n+        if (values.size() > maximum) {\n+            throw new OptionException(\n+                option,\n+                \"cli.error.unexpected.value\",\n+                (String)values.get(maximum));\n+        }\n+\n+        if (validator != null) {\n+            try {\n+                validator.validate(values);\n+            }\n+            catch (InvalidArgumentException ive) {\n+                throw new OptionException(\n+                        option, \n+                        \"cli.error.unexpected.value\", \n+                        ive.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        // do we display the outer optionality\n+        final boolean optional =\n+            helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+\n+        // allow numbering if multiple args\n+        final boolean numbered =\n+            maximum > 1\n+                && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+\n+        final boolean bracketed =\n+            helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+\n+        // if infinite args are allowed then crop the list\n+        final int max = maximum == Integer.MAX_VALUE ? 2 : maximum;\n+\n+        int i = 0;\n+        // for each argument\n+        while (i < max) {\n+            // if we're past the first add a space\n+            if (i > 0) {\n+                buffer.append(' ');\n+            }\n+            // if the next arg is optional\n+            if (i >= minimum && (optional || i > 0)) {\n+                buffer.append('[');\n+            }\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+            // add name\n+            buffer.append(name);\n+            ++i;\n+            // if numbering\n+            if (numbered) {\n+                buffer.append(i);\n+            }\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+        }\n+        // if infinite args are allowed\n+        if (maximum == Integer.MAX_VALUE) {\n+            // append elipsis\n+            buffer.append(\" ...\");\n+        }\n+        // for each argument\n+        while (i > 0) {\n+            --i;\n+            // if the next arg is optional\n+            if (i >= minimum && (optional || i > 0)) {\n+                buffer.append(']');\n+            }\n+        }\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+        final HelpLine helpLine = new HelpLineImpl(this, depth);\n+        return Collections.singletonList(helpLine);\n+    }\n+\n+    public int getMaximum() {\n+        return maximum;\n+    }\n+\n+    public int getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * If there are any leading or trailing quotes remove them from the\n+     * specified token.\n+     * \n+     * @param token\n+     *            the token to strip leading and trailing quotes\n+     * \n+     * @return String the possibly modified token\n+     */\n+    public String stripBoundaryQuotes(String token) {\n+        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n+            return token;\n+        }\n+        else {\n+            if (token.startsWith(\"\\\"\")) {\n+                token = token.substring(1, token.length());\n+            }\n+\n+            if (token.endsWith(\"\\\"\")) {\n+                token = token.substring(0, token.length() - 1);\n+            }\n+\n+            return token;\n+        }\n+    }\n+    \n+    public boolean isRequired() {\n+        return getMinimum()>0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/Command.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * Represents a cvs \"update\" style command line option.\n+ * \n+ * Like all Parents, Commands can have child options and can be part of\n+ * Arguments\n+ */\n+public class Command extends ParentImpl {\n+\n+    /** The display name for the command */\n+    private final String preferredName;\n+\n+    /** The aliases for this command */\n+    private final Set aliases;\n+\n+    /** All the names for this command */\n+    private final Set triggers;\n+\n+    /**\n+     * Creates a new Command instance.\n+     * \n+     * @param preferredName\n+     *            The name normally used to refer to the Command\n+     * @param description\n+     *            A description of the Command\n+     * @param aliases\n+     *            Alternative names for the Command\n+     * @param required\n+     *            Whether the Command is required\n+     * @param argument\n+     *            An Argument that the command takes\n+     * @param children\n+     *            The Group of child options for this Command\n+     * @param id\n+     *            A unique id for the Command\n+     * \n+     * @see ParentImpl#ParentImpl(Argument, Group, String, int, boolean)\n+     */\n+    public Command(\n+        final String preferredName,\n+        final String description,\n+        final Set aliases,\n+        final boolean required,\n+        final Argument argument,\n+        final Group children,\n+        final int id) {\n+\n+        super(argument, children, description, id, required);\n+\n+        // check the preferred name is valid\n+        if (preferredName == null || preferredName.length() < 1) {\n+            throw new IllegalArgumentException(\"preferredName must be at least 1 character\");\n+        }\n+\n+        this.preferredName = preferredName;\n+\n+        // gracefully and defensively handle aliases\n+        if (aliases == null) {\n+            this.aliases = Collections.EMPTY_SET;\n+        }\n+        else {\n+            this.aliases = Collections.unmodifiableSet(new HashSet(aliases));\n+        }\n+\n+        // populate the triggers Set\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(preferredName);\n+        newTriggers.addAll(this.aliases);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+    }\n+\n+    public void processParent(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments)\n+        throws OptionException {\n+\n+        // grab the argument to process\n+        final String arg = (String)arguments.next();\n+\n+        // if we can process it\n+        if (canProcess(arg)) {\n+\n+            // then note the option\n+            commandLine.addOption(this);\n+\n+            // normalise the argument list\n+            arguments.set(preferredName);\n+        }\n+        else {\n+            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this);\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases =\n+            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+        buffer.append(preferredName);\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String)i.next();\n+                buffer.append(alias);\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return preferredName;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/DefaultOption.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * A Parent implementation representing normal options.\n+ */\n+public class DefaultOption extends ParentImpl {\n+\n+    /**\n+     * The default token used to prefix a short option\n+     */\n+    public static final String DEFAULT_SHORT_PREFIX = \"-\";\n+    \n+    /**\n+     * The default token used to prefix a long option\n+     */\n+    public static final String DEFAULT_LONG_PREFIX = \"--\";\n+    \n+    /**\n+     * The default value for the burstEnabled constructor parameter\n+     */\n+    public static final boolean DEFAULT_BURST_ENABLED = true;\n+\n+    private final String preferredName;\n+    private final Set aliases;\n+    private final Set burstAliases;\n+    private final Set triggers;\n+    private final Set prefixes;\n+\n+    private final String shortPrefix;\n+    private final boolean burstEnabled;\n+\n+    private final int burstLength;\n+\n+    /**\n+     * Creates a new DefaultOption\n+     * \n+     * @param shortPrefix the prefix used for short options\n+     * @param longPrefix the prefix used for long options\n+     * @param burstEnabled should option bursting be enabled\n+     * @param preferredName the preferred name for this Option\n+     * @param description a description of this Option\n+     * @param aliases the alternative names for this Option\n+     * @param burstAliases the aliases that can be burst\n+     * @param required whether the Option is strictly required\n+     * @param argument the Argument belonging to this Parent, or null\n+     * @param children the Group children belonging to this Parent, ot null\n+     * @param id the unique identifier for this Option\n+     */\n+    public DefaultOption(\n+        final String shortPrefix,\n+        final String longPrefix,\n+        final boolean burstEnabled,\n+        final String preferredName,\n+        final String description,\n+        final Set aliases,\n+        final Set burstAliases,\n+        final boolean required,\n+        final Argument argument,\n+        final Group children,\n+        final int id) {\n+        super(argument, children, description, id, required);\n+\n+        this.shortPrefix = shortPrefix;\n+        this.burstEnabled = burstEnabled;\n+\n+        this.burstLength = shortPrefix.length() + 1;\n+\n+        this.preferredName = preferredName;\n+        if (aliases == null) {\n+            this.aliases = Collections.EMPTY_SET;\n+        }\n+        else {\n+            this.aliases = Collections.unmodifiableSet(new HashSet(aliases));\n+        }\n+\n+        if (burstAliases == null) {\n+            this.burstAliases = Collections.EMPTY_SET;\n+        }\n+        else {\n+            this.burstAliases =\n+                Collections.unmodifiableSet(new HashSet(burstAliases));\n+        }\n+\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(preferredName);\n+        newTriggers.addAll(this.aliases);\n+        newTriggers.addAll(this.burstAliases);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+\n+        final Set newPrefixes = new HashSet(super.getPrefixes());\n+        newPrefixes.add(shortPrefix);\n+        newPrefixes.add(longPrefix);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+    }\n+\n+    public boolean canProcess(final String argument) {\n+        return argument != null\n+            && (super.canProcess(argument)\n+                || (argument.length() >= burstLength\n+                    && burstAliases.contains(argument.substring(0, burstLength))));\n+    }\n+\n+    public void processParent(\n+        WriteableCommandLine commandLine,\n+        ListIterator arguments)\n+        throws OptionException {\n+\n+        final String argument = (String)arguments.next();\n+\n+        if (triggers.contains(argument)) {\n+            commandLine.addOption(this);\n+            arguments.set(preferredName);\n+        }\n+        else if (burstEnabled && argument.length() >= burstLength) {\n+            final String burst = argument.substring(0, burstLength);\n+\n+            if (burstAliases.contains(burst)) {\n+                commandLine.addOption(this);\n+\n+                //HMM test bursting all vs bursting one by one.\n+                arguments.set(preferredName);\n+\n+                if (getArgument() == null) {\n+                    arguments.add(\n+                        shortPrefix + argument.substring(burstLength));\n+                }\n+                else {\n+                    arguments.add(argument.substring(burstLength));\n+                }\n+\n+                arguments.previous();\n+            }\n+            else {\n+                throw new OptionException(this, \"cli.error.burst\", argument);\n+            }\n+        }\n+        else {\n+            throw new OptionException(this, \"cli.error.unexpected\", argument);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this);\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases =\n+            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+        buffer.append(preferredName);\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String)i.next();\n+                buffer.append(alias);\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return preferredName;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * An implementation of Group\n+ */\n+public class GroupImpl extends OptionImpl implements Group {\n+\n+    private final String name;\n+    private final String description;\n+    private final List options;\n+    private final int minimum;\n+    private final int maximum;\n+    private final List anonymous;\n+    private final SortedMap optionMap;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new GroupImpl using the specified parameters.\n+     * \n+     * @param options the Options and Arguments that make up the Group\n+     * @param name the name of this Group, or null\n+     * @param description a description of this Group\n+     * @param minimum the minimum number of Options for a valid CommandLine\n+     * @param maximum the maximum number of Options for a valid CommandLine\n+     */\n+    public GroupImpl(\n+        final List options,\n+        final String name,\n+        final String description,\n+        final int minimum,\n+        final int maximum) \n+    {\n+        super(0,false);\n+\n+        this.name = name;\n+        this.description = description;\n+        this.minimum = minimum;\n+        this.maximum = maximum;\n+\n+        // store a copy of the options to be used by the \n+        // help methods\n+        this.options = Collections.unmodifiableList(options);\n+\n+        // anonymous Argument temporary storage\n+        final List newAnonymous = new ArrayList();\n+        \n+        // map (key=trigger & value=Option) temporary storage\n+        final SortedMap newOptionMap =\n+            new TreeMap(ReverseStringComparator.getInstance());\n+\n+        // prefixes temporary storage\n+        final Set newPrefixes = new HashSet();\n+        \n+        // process the options\n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            \n+            final Option option = (Option) i.next();\n+\n+            if (option instanceof Argument) {\n+                i.remove();\n+                newAnonymous.add(option);\n+            } \n+            else {\n+                final Set triggers = option.getTriggers();\n+                \n+                for (Iterator j = triggers.iterator(); j.hasNext();) {\n+                    newOptionMap.put(j.next(), option);\n+                }\n+\n+                // store the prefixes\n+                newPrefixes.addAll(option.getPrefixes());\n+            }\n+        }\n+        \n+        this.anonymous = Collections.unmodifiableList(newAnonymous);\n+        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+    }\n+\n+    public boolean canProcess(String arg) {\n+        if (arg == null) {\n+            return false;\n+        }\n+\n+        // if arg does not require bursting\n+        if (optionMap.containsKey(arg)) {\n+            return true;\n+        }\n+\n+        // filter\n+        final Map tailMap = optionMap.tailMap(arg);\n+        \n+        // check if bursting is required\n+        for (final Iterator iter = tailMap.values().iterator();\n+            iter.hasNext();) {\n+            \n+            final Option option = (Option) iter.next();\n+            if (option.canProcess(arg)) {\n+                return true;\n+            }\n+        }\n+        \n+        // anonymous argument(s) means we can process it\n+        if (anonymous.size() > 0) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public Set getTriggers() {\n+        return optionMap.keySet();\n+    }\n+\n+    public void process(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments)\n+        throws OptionException {\n+\n+        // [START process each command line token\n+        while (arguments.hasNext()) {\n+       \n+            final String arg = (String)arguments.next();\n+            final Option opt = (Option)optionMap.get(arg);\n+\n+            // option found\n+            if (opt != null) {\n+                arguments.previous();\n+                opt.process(commandLine, arguments);\n+            }\n+            // [START option NOT found\n+            else {\n+                // it might be an anonymous argument continue search\n+                \n+                // [START argument may be anonymous\n+                if (commandLine.looksLikeOption(arg)) {\n+                    \n+                    // narrow the search\n+                    final Collection values = optionMap.tailMap(arg).values();\n+                    \n+                    for (Iterator i = values.iterator(); i.hasNext();) {\n+                        final Option option = (Option) i.next();\n+                        \n+                        if (option.canProcess(arg)) {\n+                            arguments.previous();\n+                            option.process(commandLine, arguments);\n+                        }\n+                    }\n+                } // [END argument may be anonymous\n+                \n+                // [START argument is NOT anonymous\n+                else {\n+                    // move iterator back, current value not used\n+                    arguments.previous();\n+\n+                    // if there are no anonymous arguments then this group can't\n+                    // process the argument\n+                    if(anonymous.isEmpty()){\n+                        break;\n+                    }\n+\n+                    // TODO: why do we iterate over all anonymous arguments?\n+                    // canProcess will always return true?\n+                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                        final Argument argument = (Argument)i.next();\n+                        if (argument.canProcess(arguments)) {\n+                            argument.process(commandLine, arguments);\n+                        }\n+                    }\n+                } // [END argument is NOT anonymous\n+            } // [END option NOT found\n+        } // [END process each command line token\n+    }\n+\n+    public void validate(final WriteableCommandLine commandLine)\n+        throws OptionException {\n+\n+        // number of options found\n+        int present = 0;\n+        \n+        // reference to first unexpected option\n+        Option unexpected = null;\n+        \n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            if (commandLine.hasOption(option)) {\n+                if (++present > maximum) {\n+                    unexpected = option;\n+                    break;\n+                }\n+                option.validate(commandLine);\n+            }\n+        }\n+\n+        // too many options\n+        if (unexpected != null) {\n+            throw new OptionException(\n+                this,\n+                \"cli.error.unexpected\",\n+                unexpected.getPreferredName());\n+        }\n+        \n+        // too few option\n+        if (present < minimum) {\n+            throw new OptionException(this, \"cli.error.missing.option\");\n+        }\n+\n+        // validate each anonymous argument\n+        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+            final Option option = (Option)i.next();\n+            option.validate(commandLine);\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+        appendUsage(buffer, helpSettings, comp, \"|\");\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp,\n+        final String separator) {\n+\n+        final Set helpSettingsCopy = new HashSet(helpSettings);\n+\n+        final boolean optional =\n+            minimum == 0\n+                && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+\n+        final boolean expanded =\n+            name == null\n+                || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+\n+        final boolean named =\n+            !expanded\n+                || (name != null\n+                    && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n+\n+        final boolean arguments =\n+            helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        final boolean outer =\n+            helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\n+        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\n+        final boolean both = named && expanded;\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+\n+        if (named) {\n+            buffer.append(name);\n+        }\n+        if (both) {\n+            buffer.append(\" (\");\n+        }\n+        if (expanded) {\n+            final Set childSettings;\n+            if (!helpSettingsCopy\n+                .contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n+                childSettings = DisplaySetting.NONE;\n+            }\n+            else {\n+                childSettings = new HashSet(helpSettingsCopy);\n+                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+            }\n+\n+            // grab a list of the group's options.\n+            final List list;\n+            if (comp == null) {\n+                // default to using the initial order\n+                list = options;\n+            }\n+            else {\n+                // sort options if comparator is supplied\n+                list = new ArrayList(options);\n+                Collections.sort(list, comp);\n+            }\n+\n+            // for each option.\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final Option option = (Option)i.next();\n+\n+                // append usage information\n+                option.appendUsage(buffer, childSettings, comp);\n+\n+                // add separators as needed\n+                if (i.hasNext()) {\n+                    buffer.append(separator);\n+                }\n+            }\n+        }\n+        if (both) {\n+            buffer.append(')');\n+        }\n+        if (optional && outer) {\n+            buffer.append(']');\n+        }\n+        if (arguments) {\n+            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                buffer.append(' ');\n+                final Option option = (Option)i.next();\n+                option.appendUsage(buffer, helpSettingsCopy, comp);\n+            }\n+        }\n+        if (optional && !outer) {\n+            buffer.append(']');\n+\n+        }\n+    }\n+\n+    public List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+        final List helpLines = new ArrayList();\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n+            final HelpLine helpLine = new HelpLineImpl(this, depth);\n+            helpLines.add(helpLine);\n+        }\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n+\n+            // grab a list of the group's options.\n+            final List list;\n+            if (comp == null) {\n+                // default to using the initial order\n+                list = options;\n+            }\n+            else {\n+                // sort options if comparator is supplied\n+                list = new ArrayList(options);\n+                Collections.sort(list, comp);\n+            }\n+\n+            // for each option\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final Option option = (Option)i.next();\n+                helpLines.addAll(\n+                    option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n+            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                final Option option = (Option)i.next();\n+                helpLines.addAll(\n+                    option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+        return helpLines;\n+    }\n+    \n+    /**\n+     * Gets the member Options of thie Group.\n+     * Note this does not include any Arguments\n+     * @return only the non Argument Options of the Group\n+     */\n+    public List getOptions(){\n+    \treturn options;\n+    }\n+    \n+    /**\n+     * Gets the anonymous Arguments of this Group.\n+     * @return the Argument options of this Group\n+     */\n+    public List getAnonymous(){\n+    \treturn anonymous;\n+    }\n+\t\n+\tpublic Option findOption(final String trigger) {\n+\t\tfinal Iterator i = getOptions().iterator();\n+\t\twhile(i.hasNext()){\n+\t\t\tfinal Option option = (Option)i.next();\n+\t\t\tfinal Option found = option.findOption(trigger);\n+\t\t\tif(found!=null){\n+\t\t\t\treturn found;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn null;\n+\t}\n+\t\n+\tpublic int getMinimum() {\n+\t\treturn minimum;\n+\t}\n+\t\n+\tpublic int getMaximum() {\n+\t\treturn maximum;\n+\t}\n+\n+    public boolean isRequired() {\n+        return getMinimum()>0;\n+    }\n+}\n+\n+class ReverseStringComparator implements Comparator {\n+    private static final Comparator instance = new ReverseStringComparator();\n+\n+    /**\n+     * Gets a singleton instance of a ReverseStringComparator\n+     * @return\n+     */\n+    public static final Comparator getInstance() {\n+        return instance;\n+    }\n+\n+    private ReverseStringComparator() {\n+        // just making sure nobody else creates one\n+    }\n+\n+    public int compare(final Object o1, final Object o2) {\n+        final String s1 = (String)o1;\n+        final String s2 = (String)o2;\n+\n+        return -s1.compareTo(s2);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/HelpLineImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * Represents a line in the help screen.\n+ */\n+public class HelpLineImpl implements HelpLine {\n+\n+    /** The option that this HelpLineImpl describes */\n+    private final Option option;\n+\n+    /** The level of indenting for this item */\n+    private final int indent;\n+\n+    /** The help settings used to obtain the previous usage */\n+    private transient Set cachedHelpSettings;\n+    \n+    /** The comparator used to obtain the previous usage */\n+    private transient Comparator cachedComparator;\n+    \n+    /** The previously obtained usage */\n+    private transient String cachedUsage;\n+    \n+    /**\n+     * Creates a new HelpLineImpl to represent a particular Option in the online\n+     * help.\n+     * \n+     * @param option\n+     *            Option that the HelpLineImpl describes\n+     * @param indent\n+     *            Level of indentation for this line\n+     */\n+    public HelpLineImpl(final Option option, final int indent) {\n+        this.option = option;\n+        this.indent = indent;\n+    }\n+\n+    /**\n+     * @return The description of the option\n+     */\n+    public String getDescription() {\n+        return option.getDescription();\n+    }\n+\n+    /**\n+     * @return The level of indentation for this line\n+     */\n+    public int getIndent() {\n+        return indent;\n+    }\n+\n+    /**\n+     * @return The Option that the help line relates to\n+     */\n+    public Option getOption() {\n+        return option;\n+    }\n+    \n+    /**\n+     * Builds a usage string for the option using the specified settings and \n+     * comparator.\n+     * \n+     *  \n+     * @param helpSettings the settings to apply\n+     * @param comparator a comparator to sort options when applicable\n+     * @return the usage string\n+     */\n+    public String usage(final Set helpSettings, final Comparator comparator) {\n+        if (cachedUsage == null\n+            || cachedHelpSettings != helpSettings\n+            || cachedComparator != comparator) {\n+            \n+            // cache the arguments to avoid redoing work\n+            cachedHelpSettings = helpSettings;\n+            cachedComparator = comparator;\n+            \n+            // build the new buffer\n+            final StringBuffer buffer = new StringBuffer();\n+            for (int i = 0; i < indent; ++i) {\n+                buffer.append(\"  \");\n+            }\n+            option.appendUsage(buffer, helpSettings, comparator);\n+            \n+            // cache the usage string\n+            cachedUsage = buffer.toString();\n+        }\n+        return cachedUsage;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/OptionImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * A base implementation of Option providing limited ground work for further\n+ * Option implementations.\n+ */\n+public abstract class OptionImpl implements Option {\n+\n+    private final int id;\n+    private final boolean required;\n+\n+    /**\n+     * Creates an OptionImpl with the specified id\n+     * @param id the unique id of this Option\n+     * @param required true iff this Option must be present\n+     */\n+    public OptionImpl(final int id, final boolean required) {\n+        this.id = id;\n+        this.required = required;\n+    }\n+\n+    public boolean canProcess(final ListIterator arguments) {\n+        if (arguments.hasNext()) {\n+            final String argument = (String)arguments.next();\n+            arguments.previous();\n+            return canProcess(argument);\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+\n+    public String toString() {\n+        final StringBuffer buffer = new StringBuffer();\n+        appendUsage(buffer, DisplaySetting.ALL, null);\n+        return buffer.toString();\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public boolean equals(final Object thatObj) {\n+        if (thatObj instanceof OptionImpl) {\n+            final OptionImpl that = (OptionImpl)thatObj;\n+\n+            return getId() == that.getId()\n+                && getPreferredName().equals(that.getPreferredName())\n+                && (getDescription() == that.getDescription()\n+                    || getDescription().equals(that.getDescription()))\n+                && getPrefixes().equals(that.getPrefixes())\n+                && getTriggers().equals(that.getTriggers());\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+\n+    public int hashCode() {\n+        int hashCode = getId();\n+        hashCode = hashCode * 37 + getPreferredName().hashCode();\n+        if (getDescription() != null) {\n+            hashCode = hashCode * 37 + getDescription().hashCode();\n+        }\n+        hashCode = hashCode * 37 + getPrefixes().hashCode();\n+        hashCode = hashCode * 37 + getTriggers().hashCode();\n+        return hashCode;\n+    }\n+    \n+\tpublic Option findOption(String trigger) {\n+\t\tif(getTriggers().contains(trigger)){\n+\t\t\treturn this;\n+\t\t}\n+\t\telse{\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+    public boolean isRequired() {\n+        return required;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/ParentImpl.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * A base implementation of Parent providing limited ground work for further\n+ * Parent implementations.\n+ */\n+public abstract class ParentImpl extends OptionImpl implements Parent {\n+\n+    private static final char NUL = '\\0';\n+    \n+    private final Group children;\n+\n+    private final Argument argument;\n+\n+    private final String description;\n+\n+    protected ParentImpl(\n+        final Argument argument,\n+        final Group children,\n+        final String description,\n+        final int id,\n+        final boolean required) {\n+        super(id,required);\n+        this.children = children;\n+        this.argument = argument;\n+        this.description = description;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#process(org.apache.commons.cli2.CommandLine,\n+     *      java.util.ListIterator)\n+     */\n+    public void process(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments)\n+        throws OptionException {\n+\n+        if (argument != null) {\n+            handleInitialSeparator(arguments, argument.getInitialSeparator());\n+        }\n+\n+        processParent(commandLine, arguments);\n+\n+        if (argument != null) {\n+            argument.processValues(commandLine, arguments, this);\n+        }\n+\n+        if (children != null && children.canProcess(arguments)) {\n+            children.process(commandLine, arguments);\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#canProcess(java.lang.String)\n+     */\n+    public boolean canProcess(final String arg) {\n+\n+        final Set triggers = getTriggers();\n+        \n+        if (argument != null) {\n+            final char separator = argument.getInitialSeparator();\n+            \n+            // if there is a valid separator character\n+            if (separator != NUL) {\n+                final int initialIndex = arg.indexOf(separator);\n+                \n+                // if there is a separator present\n+                if (initialIndex > 0) {\n+                    return triggers.contains(arg.substring(0, initialIndex));\n+                }\n+            }\n+        }\n+        \n+        return triggers.contains(arg);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#prefixes()\n+     */\n+    public Set getPrefixes() {\n+        if (children == null) {\n+            return Collections.EMPTY_SET;\n+        }\n+        else {\n+            return children.getPrefixes();\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#validate(org.apache.commons.cli2.CommandLine)\n+     */\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (commandLine.hasOption(this)) {\n+            if (argument != null) {\n+                argument.validate(commandLine, this);\n+            }\n+\n+            if (children != null) {\n+                children.validate(commandLine);\n+            }\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#appendUsage(java.lang.StringBuffer,\n+     *      java.util.Set, java.util.Comparator)\n+     */\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        final boolean displayArgument =\n+            this.argument != null\n+                && helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        final boolean displayChildren =\n+            this.children != null\n+                && helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\n+        if (displayArgument) {\n+            buffer.append(' ');\n+            argument.appendUsage(buffer, helpSettings, comp);\n+        }\n+\n+        if (displayChildren) {\n+            buffer.append(' ');\n+            children.appendUsage(buffer, helpSettings, comp);\n+        }\n+    }\n+\n+    /**\n+     * @return a description of this parent option\n+     */\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.Option#helpLines(int, java.util.Set,\n+     *      java.util.Comparator)\n+     */\n+    public List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+        final List helpLines = new ArrayList();\n+        helpLines.add(new HelpLineImpl(this, depth));\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT)\n+            && argument != null) {\n+            helpLines.addAll(argument.helpLines(depth + 1, helpSettings, comp));\n+        }\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN)\n+            && children != null) {\n+            helpLines.addAll(children.helpLines(depth + 1, helpSettings, comp));\n+        }\n+\n+        return helpLines;\n+    }\n+\n+    /**\n+     * @return Returns the argument.\n+     */\n+    public Argument getArgument() {\n+        return argument;\n+    }\n+\n+    /**\n+     * @return Returns the children.\n+     */\n+    public Group getChildren() {\n+        return children;\n+    }\n+\n+    /**\n+     * Split the token using the specified separator character.\n+     * @param arguments the current position in the arguments iterator\n+     * @param separator the separator char to split on\n+     */\n+    private void handleInitialSeparator(\n+        final ListIterator arguments, \n+        final char separator) {\n+        \n+        // next token\n+        final String newArgument = (String)arguments.next();\n+        \n+        // split the token\n+        final int initialIndex = newArgument.indexOf(separator);\n+        \n+        if (initialIndex > 0) {\n+            arguments.remove();\n+            arguments.add(newArgument.substring(0, initialIndex));\n+            arguments.add(newArgument.substring(initialIndex + 1));\n+            arguments.previous();\n+        }\n+        arguments.previous();        \n+    }\n+    \n+\t/*\n+\t * @see org.apache.commons.cli2.Option#findOption(java.lang.String)\n+\t */\n+\tpublic Option findOption(final String trigger) {\n+\t\tfinal Option found = super.findOption(trigger);\n+\t\tif(found==null && children!=null){\n+\t\t\treturn children.findOption(trigger);\n+\t\t}\n+\t\telse{\n+\t\t\treturn found;\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/PropertyOption.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * Handles the java style \"-Dprop=value\" opions\n+ */\n+public class PropertyOption extends OptionImpl {\n+\n+    private static final String DEFAULT_OPTION_STRING = \"-D\";\n+    private static final String DEFAULT_DESCRIPTION =\n+        \"Passes properties and values to the application\";\n+\n+    private final String optionString;\n+    private final String description;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new PropertyOption using the default settings of a \"-D\" trigger\n+     * and an id of 'D'\n+     */\n+    public PropertyOption() {\n+        this(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n+    }\n+\n+    /**\n+     * Creates a new PropertyOption using the specified parameters\n+     * @param optionString the trigger for the Option\n+     * @param description the description of the Option\n+     * @param id the id of the Option\n+     */\n+    public PropertyOption(\n+        final String optionString,\n+        final String description,\n+        final int id) {\n+        super(id,false);\n+        this.optionString = optionString;\n+        this.description = description;\n+        this.prefixes = Collections.singleton(optionString);\n+    }\n+\n+    /**\n+     * A default PropertyOption instance\n+     */\n+    public static final PropertyOption INSTANCE = new PropertyOption();\n+\n+    public boolean canProcess(final String argument) {\n+        return argument != null\n+            && argument.startsWith(optionString)\n+            && argument.length() > optionString.length();\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void process(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments)\n+        throws OptionException {\n+\n+        final String arg = (String)arguments.next();\n+\n+        if (!canProcess(arg)) {\n+            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+        }\n+\n+        final int propertyStart = optionString.length();\n+        final int equalsIndex = arg.indexOf('=', propertyStart);\n+        final String property;\n+        final String value;\n+        if (equalsIndex < 0) {\n+            property = arg.substring(propertyStart);\n+            value = \"true\";\n+        }\n+        else {\n+            property = arg.substring(propertyStart, equalsIndex);\n+            value = arg.substring(equalsIndex + 1);\n+        }\n+        commandLine.addProperty(property, value);\n+    }\n+\n+    public Set getTriggers() {\n+        return Collections.singleton(optionString);\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine) {\n+        // PropertyOption needs no validation\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        final boolean display =\n+            helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+\n+        final boolean bracketed =\n+            helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+\n+        if (display) {\n+            buffer.append(optionString);\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+            buffer.append(\"property\");\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+            buffer.append(\"=\");\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+            buffer.append(\"value\");\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return optionString;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION)) {\n+            final HelpLine helpLine = new HelpLineImpl(this, depth);\n+            return Collections.singletonList(helpLine);\n+        }\n+        else {\n+            return Collections.EMPTY_LIST;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/SourceDestArgument.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * An Argument implementation that allows a variable size Argument to precede a\n+ * fixed size argument.  The canonical example of it's use is in the unix\n+ * <code>cp</code> command where a number of source can be specified with\n+ * exactly one destination specfied at the end.\n+ */\n+public class SourceDestArgument extends ArgumentImpl {\n+    private static int sum(final int a, final int b) {\n+        return Math.max(a, Math.max(b, a + b));\n+    }\n+\n+    private final ArgumentImpl source;\n+    private final ArgumentImpl dest;\n+\n+    /**\n+     * Creates a SourceDestArgument using defaults where possible.\n+     * \n+     * @param source the variable size Argument\n+     * @param dest the fixed size Argument\n+     */\n+    public SourceDestArgument(\n+        final ArgumentImpl source,\n+        final ArgumentImpl dest) {\n+        this(\n+            source,\n+            dest,\n+            DEFAULT_INITIAL_SEPARATOR,\n+            DEFAULT_SUBSEQUENT_SEPARATOR,\n+            DEFAULT_CONSUME_REMAINING,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a SourceDestArgument using the specified parameters.\n+     * \n+     * @param source the variable size Argument\n+     * @param dest the fixed size Argument\n+     * @param initialSeparator the inistial separator to use\n+     * @param subsequentSeparator the subsequent separator to use\n+     * @param consumeRemaining the token triggering consume remaining behaviour \n+     * @param defaultValues the default values for the SourceDestArgument\n+     */\n+    public SourceDestArgument(\n+        final ArgumentImpl source,\n+        final ArgumentImpl dest,\n+        final char initialSeparator,\n+        final char subsequentSeparator,\n+        final String consumeRemaining,\n+        final List defaultValues) {\n+        super(\n+            \"SourceDestArgument\",\n+            null,\n+            sum(source.getMinimum(), dest.getMinimum()),\n+            sum(source.getMaximum(), dest.getMaximum()),\n+            initialSeparator,\n+            subsequentSeparator,\n+            null,\n+            consumeRemaining,\n+            defaultValues,\n+            0);\n+\n+        this.source = source;\n+        this.dest = dest;\n+\n+        if (dest.getMinimum() != dest.getMaximum()) {\n+            throw new IllegalArgumentException(\"The dest argument must enforce a fixed number of values\");\n+        }\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        final int length = buffer.length();\n+\n+        source.appendUsage(buffer, helpSettings, comp);\n+\n+        if (buffer.length() != length) {\n+            buffer.append(' ');\n+        }\n+\n+        dest.appendUsage(buffer, helpSettings, comp);\n+    }\n+\n+    public List helpLines(int depth, Set helpSettings, Comparator comp) {\n+        final List helpLines = new ArrayList();\n+        helpLines.addAll(source.helpLines(depth, helpSettings, comp));\n+        helpLines.addAll(dest.helpLines(depth, helpSettings, comp));\n+        return helpLines;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine, Option option)\n+        throws OptionException {\n+\n+        final List values = commandLine.getValues(option);\n+\n+        final int limit = values.size() - dest.getMinimum();\n+        int count = 0;\n+\n+        final Iterator i = values.iterator();\n+        while (count++ < limit) {\n+            commandLine.addValue(source, i.next());\n+        }\n+        while (i.hasNext()) {\n+            commandLine.addValue(dest, i.next());\n+        }\n+\n+        source.validate(commandLine, source);\n+        dest.validate(commandLine, dest);\n+    }\n+\n+    public boolean canProcess(final String arg) {\n+        return source.canProcess(arg) || dest.canProcess(arg);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/option/Switch.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * A Parent implementation representing normal switch options.\n+ * For example: <code>+d|-d</code> or <code>--enable-x|--disable-x</code>. \n+ */\n+public class Switch extends ParentImpl {\n+\n+    /**\n+     * The default prefix for enabled switches\n+     */\n+    public static final String DEFAULT_ENABLED_PREFIX = \"+\";\n+    \n+    /**\n+     * The default prefix for disabled switches\n+     */\n+    public static final String DEFAULT_DISABLED_PREFIX = \"-\";\n+\n+    private final String enabledPrefix;\n+    private final String disabledPrefix;\n+    private final Set triggers;\n+    private final String preferredName;\n+    private final Set aliases;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new Switch with the specified parameters\n+     * @param enabledPrefix the prefix used for enabled switches\n+     * @param disabledPrefix the prefix used for disabled switches\n+     * @param preferredName the preferred name of the switch\n+     * @param aliases the aliases by which the Switch is known\n+     * @param description a description of the Switch\n+     * @param required whether the Option is strictly required\n+     * @param argument the Argument belonging to this Parent, or null\n+     * @param children the Group children belonging to this Parent, ot null\n+     * @param id the unique identifier for this Option\n+     */\n+    public Switch(\n+        final String enabledPrefix,\n+        final String disabledPrefix,\n+        final String preferredName,\n+        final Set aliases,\n+        final String description,\n+        final boolean required,\n+        final Argument argument,\n+        final Group children,\n+        final int id) {\n+        super(argument, children, description, id, required);\n+\n+        if (enabledPrefix == null) {\n+            throw new IllegalArgumentException(\"enabledPrefix must be supplied\");\n+        }\n+\n+        if (disabledPrefix == null) {\n+            throw new IllegalArgumentException(\"enabledPrefix must be supplied\");\n+        }\n+\n+        if (enabledPrefix.startsWith(disabledPrefix)) {\n+            throw new IllegalArgumentException(\"The enabledPrefix cannot start the same as disabledPrefix\");\n+        }\n+\n+        if (disabledPrefix.startsWith(enabledPrefix)) {\n+            throw new IllegalArgumentException(\"The disabledPrefix cannot start the same as enabledPrefix\");\n+        }\n+\n+        this.enabledPrefix = enabledPrefix;\n+        this.disabledPrefix = disabledPrefix;\n+        this.preferredName = preferredName;\n+\n+        if (preferredName == null || preferredName.length() < 1) {\n+            throw new IllegalArgumentException(\"preferredName must be at least 1 character\");\n+        }\n+\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(enabledPrefix + preferredName);\n+        newTriggers.add(disabledPrefix + preferredName);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+\n+        if (aliases == null) {\n+            this.aliases = Collections.EMPTY_SET;\n+        }\n+        else {\n+            this.aliases = Collections.unmodifiableSet(new HashSet(aliases));\n+            for (final Iterator i = aliases.iterator(); i.hasNext();) {\n+                final String alias = (String)i.next();\n+                newTriggers.add(enabledPrefix + alias);\n+                newTriggers.add(disabledPrefix + alias);\n+            }\n+        }\n+\n+        final Set newPrefixes = new HashSet(super.getPrefixes());\n+        newPrefixes.add(enabledPrefix);\n+        newPrefixes.add(disabledPrefix);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+\n+    }\n+\n+    public void processParent(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator arguments)\n+        throws OptionException {\n+\n+        final String arg = (String)arguments.next();\n+\n+        if (canProcess(arg)) {\n+            commandLine.addOption(this);\n+            if (arg.startsWith(enabledPrefix)) {\n+                commandLine.addSwitch(this, true);\n+                arguments.set(enabledPrefix + preferredName);\n+            }\n+            if (arg.startsWith(disabledPrefix)) {\n+                commandLine.addSwitch(this, false);\n+                arguments.set(disabledPrefix + preferredName);\n+            }\n+        }\n+        else {\n+            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this);\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp) {\n+\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases =\n+            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+        final boolean disabled =\n+            helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        final boolean enabled =\n+            !disabled\n+                || helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        final boolean both = disabled && enabled;\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+        if (enabled) {\n+            buffer.append(enabledPrefix).append(preferredName);\n+        }\n+        if (both) {\n+            buffer.append('|');\n+        }\n+        if (disabled) {\n+            buffer.append(disabledPrefix).append(preferredName);\n+        }\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String)i.next();\n+\n+                if (enabled) {\n+                    buffer.append(enabledPrefix).append(alias);\n+                }\n+                if (both) {\n+                    buffer.append('|');\n+                }\n+                if (disabled) {\n+                    buffer.append(disabledPrefix).append(alias);\n+                }\n+\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return enabledPrefix + preferredName;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/resource/ResourceHelper.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.resource;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * A utility class used to provide internationalisation support.\n+ * @author John Keyes\n+ */\n+public class ResourceHelper {\n+\n+    /** resource bundle */\n+    private ResourceBundle bundle;\n+\n+    /** default bundle name */\n+    private static final String DEFAULT_BUNDLE = \"messages\";\n+\n+    /** cache */\n+    private static Map cache = new HashMap(13);\n+    \n+    /**\n+     * Gets the ResourceHelper appropriate to the specified class.\n+     * @param clazz the class to get resources for\n+     * @return a ResourceHelper\n+     */\n+    public static ResourceHelper getResourceHelper(final Class clazz) {\n+\n+        if (cache.containsKey(clazz)) {\n+            return (ResourceHelper)cache.get(clazz);\n+        }\n+\n+        return new ResourceHelper(clazz);\n+    }\n+\n+    /**\n+     * Create a new ResourceHelper for the specified class.\n+     * \n+     * @param clazz\n+     *            the Class that requires some resources\n+     */\n+    private ResourceHelper(final Class clazz) {\n+\n+        // get the name of the class\n+        final String className = clazz.getName();\n+\n+        // discover the package name\n+        final String packageName =\n+            className.substring(0, className.lastIndexOf(\".\") + 1);\n+\n+        final String bundleName = packageName + DEFAULT_BUNDLE;\n+\n+        // initialize the bundle\n+        try {\n+            bundle = ResourceBundle.getBundle(bundleName);\n+        }\n+        catch (MissingResourceException e) {\n+            //TODO Handle missing resources nicely\n+            bundle = null;\n+        }\n+\n+        // cache bundle\n+        cache.put(bundleName, bundle);\n+    }\n+\n+    /**\n+     * Returns the message for the specified key.\n+     * \n+     * @param key\n+     *            the unique identifier of the message\n+     * \n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key) {\n+        return getMessage(key, new Object[] {\n+        });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and argument.\n+     * \n+     * @param key\n+     *            the unique identifier of the message\n+     * \n+     * @param value\n+     *            the argument value\n+     * \n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key, final Object value) {\n+\n+        return getMessage(key, new Object[] { value });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     * \n+     * @param key\n+     *            the unique identifier of the message\n+     * \n+     * @param value1\n+     *            an argument value\n+     * \n+     * @param value2\n+     *            an argument value\n+     * \n+     * @return String the formatted String\n+     */\n+    public String getMessage(\n+        final String key,\n+        final Object value1,\n+        final Object value2) {\n+\n+        return getMessage(key, new Object[] { value1, value2 });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     * \n+     * @param key\n+     *            the unique identifier of the message\n+     * \n+     * @param value1\n+     *            an argument value\n+     * \n+     * @param value2\n+     *            an argument value\n+     * \n+     * @param value3\n+     *            an argument value\n+     * \n+     * @return String the formatted String\n+     */\n+    public String getMessage(\n+        final String key,\n+        final Object value1,\n+        final Object value2,\n+        final Object value3) {\n+\n+        return getMessage(key, new Object[] { value1, value2, value3 });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     * \n+     * @param key\n+     *            the unique identifier of the message\n+     * \n+     * @param values\n+     *            argument values\n+     * \n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key, final Object[] values) {\n+\n+        final String msgFormatStr = bundle.getString(key);\n+        final MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n+\n+        return msgFormat.format(values);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/util/Comparators.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.option.Command;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.option.Switch;\n+\n+/**\n+ * A collection of Comparators suitable for use with Option instances.\n+ */\n+public class Comparators {\n+\t\n+\tprivate Comparators(){\n+\t\t;// constructor hiden from potential users\n+\t}\n+\t\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final Comparator c0, final Comparator c1) {\n+        return chain(new Comparator[] { c0, c1 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2) {\n+        return chain(new Comparator[] { c0, c1, c2 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @param c3\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2,\n+        final Comparator c3) {\n+        return chain(new Comparator[] { c0, c1, c2, c3 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @param c3\n+     *            a comparator\n+     * @param c4\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2,\n+        final Comparator c3,\n+        final Comparator c4) {\n+        return chain(new Comparator[] { c0, c1, c2, c3, c4 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param comparators\n+     *            a List of comparators to chain together\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final List comparators) {\n+        return new Chain(\n+            (Comparator[])comparators.toArray(\n+                new Comparator[comparators.size()]));\n+    }\n+\n+    /**\n+     * Chains an array of comparators together. Each Comparator will be called\n+     * in turn until one of them return a non-zero value, this value will be\n+     * returned.\n+     * \n+     * @param comparators\n+     *            the array of comparators\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final Comparator[] comparators) {\n+        return new Chain(comparators);\n+    }\n+\n+    /**\n+     * Chains a series of Comparators together.\n+     */\n+    private static class Chain implements Comparator {\n+\n+        final Comparator[] chain;\n+\n+        /**\n+         * Creates a Comparator chain using the specified array of Comparators\n+         * @param chain the Comparators in the chain\n+         */\n+        public Chain(final Comparator[] chain) {\n+            this.chain = new Comparator[chain.length];\n+            System.arraycopy(chain, 0, this.chain, 0, chain.length);\n+        }\n+\n+        public int compare(final Object left, final Object right) {\n+            int result = 0;\n+            for (int i = 0; result == 0 && i < chain.length; ++i) {\n+                result = chain[i].compare(left, right);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Reverses a comparator's logic.\n+     * \n+     * @param wrapped\n+     *            the Comparator to reverse the logic of\n+     * @return a comparator with reverse logic\n+     */\n+    private static Comparator reverse(final Comparator wrapped) {\n+        return new Reverse(wrapped);\n+    }\n+\n+    private static class Reverse implements Comparator {\n+        private final Comparator wrapped;\n+\n+        /**\n+         * Creates a Comparator with reverse logic\n+         * @param wrapped the original logic\n+         */\n+        public Reverse(final Comparator wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public int compare(final Object left, final Object right) {\n+            return -wrapped.compare(left, right);\n+        }\n+    }\n+\n+    /**\n+     * Forces Group instances to appear at the beginning of lists\n+     * \n+     * @see Group\n+     * @return a new comparator\n+     */\n+    public static Comparator groupFirst() {\n+        return new GroupFirst();\n+    }\n+\n+    /**\n+     * Forces Group instances to appear at the end of lists\n+     * \n+     * @see Group\n+     * @return a new comparator\n+     */\n+    public static Comparator groupLast() {\n+        return reverse(groupFirst());\n+    }\n+\n+    private static class GroupFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Group;\n+            final boolean r = right instanceof Group;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Forces Switch instances to appear at the beginning of lists\n+     * \n+     * @see Switch\n+     * @return a new comparator\n+     */\n+    public static Comparator switchFirst() {\n+        return new SwitchFirst();\n+    }\n+\n+    /**\n+     * Forces Switch instances to appear at the end of lists\n+     * \n+     * @see Switch\n+     * @return a new comparator\n+     */\n+    public static Comparator switchLast() {\n+        return reverse(switchFirst());\n+    }\n+\n+    private static class SwitchFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Switch;\n+            final boolean r = right instanceof Switch;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Forces Command instances to appear at the beginning of lists\n+     * \n+     * @see Command\n+     * @return a new comparator\n+     */\n+    public static Comparator commandFirst() {\n+        return new CommandFirst();\n+    }\n+\n+    /**\n+     * Forces Command instances to appear at the end of lists\n+     * \n+     * @see Command\n+     * @return a new comparator\n+     */\n+    public static Comparator commandLast() {\n+        return reverse(commandFirst());\n+    }\n+\n+    private static class CommandFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Command;\n+            final boolean r = right instanceof Command;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Forces DefaultOption instances to appear at the beginning of lists\n+     * \n+     * @see DefaultOption\n+     * @return a new comparator\n+     */\n+    public static Comparator defaultOptionFirst() {\n+        return new DefaultOptionFirst();\n+    }\n+\n+    /**\n+     * Forces DefaultOption instances to appear at the end of lists\n+     * \n+     * @see DefaultOption\n+     * @return a new comparator\n+     */\n+    public static Comparator defaultOptionLast() {\n+        return reverse(defaultOptionFirst());\n+    }\n+\n+    private static class DefaultOptionFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof DefaultOption;\n+            final boolean r = right instanceof DefaultOption;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Forces Comparators with a particular trigger to appear at the beginning\n+     * of lists\n+     * \n+     * @param name\n+     *            the trigger name to select\n+     * @see Option#getTriggers()\n+     * @return a new comparator\n+     */\n+    public static Comparator namedFirst(final String name) {\n+        return new Named(name);\n+    }\n+\n+    /**\n+     * Forces Comparators with a particular trigger to appear at the end of\n+     * lists\n+     * \n+     * @param name\n+     *            the trigger name to select\n+     * @see Option#getTriggers()\n+     * @return a new comparator\n+     */\n+    public static Comparator namedLast(final String name) {\n+        return reverse(new Named(name));\n+    }\n+\n+    private static class Named implements Comparator {\n+        private final String name;\n+        \n+        /**\n+         * Creates a Comparator that sorts a particular name high in order\n+         * @param name the trigger name to select\n+         */\n+        public Named(final String name) {\n+            this.name = name;\n+        }\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+\n+            final boolean l = left.getTriggers().contains(name);\n+            final boolean r = right.getTriggers().contains(name);\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Orders Options by preferredName\n+     * \n+     * @see Option#getPreferredName()\n+     * @return a new comparator\n+     */\n+    public static Comparator preferredNameFirst() {\n+        return new PreferredName();\n+    }\n+\n+    /**\n+     * Orders Options by preferredName, reversed\n+     * \n+     * @see Option#getPreferredName()\n+     * @return a new comparator\n+     */\n+    public static Comparator preferredNameLast() {\n+        return reverse(preferredNameFirst());\n+    }\n+\n+    private static class PreferredName implements Comparator {\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+\n+            return left.getPreferredName().compareTo(right.getPreferredName());\n+        }\n+    }\n+\n+    /**\n+     * Orders Options grouping required Options first\n+     * \n+     * @see Option#isRequired()\n+     * @return a new comparator\n+     */\n+    public static Comparator requiredFirst() {\n+        return new Required();\n+    }\n+    \n+    /**\n+     * Orders Options grouping required Options last\n+     * \n+     * @see Option#isRequired()\n+     * @return a new comparator\n+     */\n+    public static Comparator requiredLast() {\n+        return reverse(requiredFirst());\n+    }\n+    \n+    private static class Required implements Comparator {\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+            \n+            final boolean l = left.isRequired();\n+            final boolean r = right.isRequired();\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                else {\n+                    return 1;\n+                }\n+            }\n+            else {\n+                return 0;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/util/HelpFormatter.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * Presents on screen help based on the application's Options\n+ */\n+public class HelpFormatter {\n+\n+    /**\n+     * The default screen width\n+     */\n+    public static final int DEFAULT_FULL_WIDTH = 80;\n+\n+    /**\n+     * The default screen furniture left of screen\n+     */\n+    public static final String DEFAULT_GUTTER_LEFT = \"\";\n+    \n+    /**\n+     * The default screen furniture right of screen\n+     */\n+    public static final String DEFAULT_GUTTER_CENTER = \"    \";\n+    \n+    /**\n+     * The default screen furniture between columns\n+     */\n+    public static final String DEFAULT_GUTTER_RIGHT = \"\";\n+\n+    /**\n+     * The default DisplaySettings used to select the elements to display in the\n+     * displayed line of full usage information.\n+     * \n+     * @see DisplaySetting\n+     */\n+    public static final Set DEFAULT_FULL_USAGE_SETTINGS;\n+    \n+    /**\n+     * The default DisplaySettings used to select the elements of usage per help \n+     * line in the main body of help\n+     * \n+     * @see DisplaySetting\n+     */\n+    public static final Set DEFAULT_LINE_USAGE_SETTINGS;\n+    \n+    /**\n+     * The default DisplaySettings used to select the help lines in the main\n+     * body of help \n+     */\n+    public static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n+\n+    static {\n+        final Set fullUsage = new HashSet(DisplaySetting.ALL);\n+        fullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\n+        fullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        DEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n+\n+        final Set lineUsage = new HashSet();\n+        lineUsage.add(DisplaySetting.DISPLAY_ALIASES);\n+        lineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        DEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n+\n+        final Set displayUsage = new HashSet(DisplaySetting.ALL);\n+        displayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        DEFAULT_DISPLAY_USAGE_SETTINGS =\n+            Collections.unmodifiableSet(displayUsage);\n+    }\n+\n+    private Set fullUsageSettings = new HashSet(DEFAULT_FULL_USAGE_SETTINGS);\n+    private Set lineUsageSettings = new HashSet(DEFAULT_LINE_USAGE_SETTINGS);\n+    private Set displaySettings = new HashSet(DEFAULT_DISPLAY_USAGE_SETTINGS);\n+    private OptionException exception = null;\n+    private Group group;\n+    private Comparator comparator = null;\n+\n+    private String divider = null;\n+\n+    private String header = null;\n+    private String footer = null;\n+\n+    private String shellCommand = \"\";\n+\n+    private PrintWriter out = new PrintWriter(System.out);\n+    //or should this default to .err?\n+\n+    private final String gutterLeft;\n+    private final String gutterCenter;\n+    private final String gutterRight;\n+\n+    private final int pageWidth;\n+\n+    /**\n+     * Creates a new HelpFormatter using the defaults\n+     */\n+    public HelpFormatter() {\n+        this(\n+            DEFAULT_GUTTER_LEFT,\n+            DEFAULT_GUTTER_CENTER,\n+            DEFAULT_GUTTER_RIGHT,\n+            DEFAULT_FULL_WIDTH);\n+    }\n+\n+    /**\n+     * Creates a new HelpFormatter using the specified parameters\n+     * @param gutterLeft the string marking left of screen\n+     * @param gutterCenter the string marking center of screen\n+     * @param gutterRight the string marking right of screen\n+     * @param fullWidth the width of the screen\n+     */\n+    public HelpFormatter(\n+        final String gutterLeft,\n+        final String gutterCenter,\n+        final String gutterRight,\n+        final int fullWidth) {\n+        if (gutterLeft == null) {\n+            this.gutterLeft = \"\";\n+        }\n+        else {\n+            this.gutterLeft = gutterLeft;\n+        }\n+\n+        if (gutterCenter == null) {\n+            this.gutterCenter = \"\";\n+        }\n+        else {\n+            this.gutterCenter = gutterCenter;\n+        }\n+\n+        if (gutterRight == null) {\n+            this.gutterRight = \"\";\n+        }\n+        else {\n+            this.gutterRight = gutterRight;\n+        }\n+\n+        this.pageWidth = fullWidth - gutterLeft.length() - gutterRight.length();\n+        if (fullWidth - pageWidth + gutterCenter.length() < 2) {\n+            throw new IllegalArgumentException(\n+                \"The gutter strings leave no space for output! \"\n+                    + \"Supply shorter gutters or more width.\");\n+        }\n+    }\n+    \n+    /**\n+     * Prints the Option help.\n+     * @throws IOException if an error occurs\n+     */\n+    public void print() throws IOException {\n+        printHeader();\n+        printException();\n+        printUsage();\n+        printHelp();\n+        printFooter();\n+        out.flush();\n+    }\n+\n+    /**\n+     * Prints any error message. \n+     * @throws IOException if an error occurs\n+     */\n+    public void printException() throws IOException {\n+        if (exception != null) {\n+            printDivider();\n+            printWrapped(exception.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Prints detailed help per option. \n+     * @throws IOException if an error occurs\n+     */\n+    public void printHelp() throws IOException {\n+        printDivider();\n+\n+        final Option option;\n+        if (exception != null && exception.getOption() != null) {\n+            option = exception.getOption();\n+        }\n+        else {\n+            option = group;\n+        }\n+        \n+        final List helpLines = option.helpLines(0, displaySettings, comparator);\n+        int usageWidth = 0;\n+        for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n+            final HelpLine helpLine = (HelpLine)i.next();\n+            final String usage = helpLine.usage(lineUsageSettings, comparator);\n+            usageWidth = Math.max(usageWidth, usage.length());\n+        }\n+        final StringBuffer blankBuffer = new StringBuffer();\n+        for (int i = 0; i < usageWidth; i++) {\n+            blankBuffer.append(' ');\n+        }\n+        final int descriptionWidth =\n+            pageWidth - gutterCenter.length() - usageWidth;\n+        for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n+            final HelpLine helpLine = (HelpLine)i.next();\n+            final List descriptionLines =\n+                wrap(helpLine.getDescription(), descriptionWidth);\n+            final Iterator j = descriptionLines.iterator();\n+\n+            printGutterLeft();\n+            pad(helpLine.usage(lineUsageSettings, comparator), usageWidth, out);\n+            out.print(gutterCenter);\n+            pad((String)j.next(), descriptionWidth, out);\n+            printGutterRight();\n+            out.println();\n+\n+            while (j.hasNext()) {\n+                printGutterLeft();\n+                //pad(helpLine.getUsage(),usageWidth,out);\n+                out.print(blankBuffer);\n+                out.print(gutterCenter);\n+                pad((String)j.next(), descriptionWidth, out);\n+                printGutterRight();\n+                out.println();\n+            }\n+        }\n+        printDivider();\n+    }\n+\n+    /**\n+     * Prints a single line of usage information (wrapping if necessary) \n+     * @throws IOException if an error occurs\n+     */\n+    public void printUsage() throws IOException {\n+        printDivider();\n+        final StringBuffer buffer = new StringBuffer(\"Usage:\\n\");\n+        buffer.append(shellCommand).append(' ');\n+        group.appendUsage(buffer, fullUsageSettings, comparator, \" \");\n+        printWrapped(buffer.toString());\n+    }\n+\n+    /**\n+     * Prints a header string if necessary \n+     * @throws IOException if an error occurs\n+     */\n+    public void printHeader() throws IOException {\n+        if (header != null) {\n+            printDivider();\n+            printWrapped(header);\n+        }\n+    }\n+\n+    /**\n+     * Prints a footer string if necessary \n+     * @throws IOException if an error occurs\n+     */\n+    public void printFooter() throws IOException {\n+        if (footer != null) {\n+            printWrapped(footer);\n+            printDivider();\n+        }\n+    }\n+\n+    /**\n+     * Prints a string wrapped if necessary\n+     * @param text the string to wrap \n+     * @throws IOException if an error occurs\n+     */\n+    protected void printWrapped(final String text)\n+        throws IOException {\n+        for (final Iterator i = wrap(text, pageWidth).iterator();\n+            i.hasNext();\n+            ) {\n+            printGutterLeft();\n+            pad((String)i.next(), pageWidth, out);\n+            printGutterRight();\n+            out.println();\n+        }\n+    }\n+\n+    /**\n+     * Prints the left gutter string \n+     */\n+    public void printGutterLeft() {\n+        if (gutterLeft != null) {\n+            out.print(gutterLeft);\n+        }\n+    }\n+\n+    /**\n+     * Prints the right gutter string \n+     */\n+    public void printGutterRight() {\n+        if (gutterRight != null) {\n+            out.print(gutterRight);\n+        }\n+    }\n+\n+    /**\n+     * Prints the divider text\n+     */\n+    public void printDivider() {\n+        if (divider != null) {\n+            out.println(divider);\n+        }\n+    }\n+\n+    protected static void pad(\n+        final String text,\n+        final int width,\n+        final Writer writer)\n+        throws IOException {\n+        int left;\n+        if (text == null) {\n+            left = 0;\n+        }\n+        else {\n+            writer.write(text);\n+            left = text.length();\n+        }\n+\n+        for (int i = left; i < width; ++i) {\n+            writer.write(' ');\n+        }\n+    }\n+\n+    protected static List wrap(final String text, final int width) {\n+        if (text == null) {\n+            return Collections.singletonList(\"\");\n+        }\n+\n+        final List lines = new ArrayList();\n+        final char[] chars = text.toCharArray();\n+        int left = 0;\n+\n+        while (left < chars.length) {\n+            int right = left;\n+            while (right < chars.length && chars[right] != '\\n') {\n+                right++;\n+            }\n+            if (right < chars.length) {\n+                final String line = new String(chars, left, right - left);\n+                lines.add(line);\n+                left = right + 1;\n+                if (left == chars.length) {\n+                    lines.add(\"\");\n+                }\n+                continue;\n+            }\n+\n+            right = left + width - 1;\n+            if (chars.length <= right) {\n+                final String line =\n+                    new String(chars, left, chars.length - left);\n+                lines.add(line);\n+                break;\n+            }\n+            while (right >= left && chars[right] != ' ') {\n+                right--;\n+            }\n+            if (right >= left) {\n+                final String line = new String(chars, left, right - left);\n+                lines.add(line);\n+                left = right;\n+                while (right < chars.length && chars[right] == ' ') {\n+                    right++;\n+                }\n+                left = right;\n+                continue;\n+            }\n+\n+            right = Math.min(left + width, chars.length);\n+            final String line = new String(chars, left, right - left);\n+            lines.add(line);\n+            while (right < chars.length && chars[right] == ' ') {\n+                right++;\n+            }\n+            left = right;\n+        }\n+\n+        return lines;\n+    }\n+\n+    /**\n+     * The Comparator to use when sorting Options\n+     * @param comparator Comparator to use when sorting Options\n+     */\n+    public void setComparator(Comparator comparator) {\n+        this.comparator = comparator;\n+    }\n+    \n+    /**\n+     * The DisplaySettings used to select the help lines in the main body of\n+     * help\n+     * \n+     * @param displaySettings the settings to use\n+     * @see DisplaySetting\n+     */\n+    public void setDisplaySettings(Set displaySettings) {\n+        this.displaySettings = displaySettings;\n+    }\n+\n+    /**\n+     * Sets the string to use as a divider between sections of help\n+     * @param divider the dividing string\n+     */\n+    public void setDivider(String divider) {\n+        this.divider = divider;\n+    }\n+    \n+    /**\n+     * Sets the exception to document\n+     * @param exception the exception that occured\n+     */\n+    public void setException(OptionException exception) {\n+        this.exception = exception;\n+    }\n+\n+    /**\n+     * Sets the footer text of the help screen\n+     * @param footer the footer text\n+     */\n+    public void setFooter(String footer) {\n+        this.footer = footer;\n+    }\n+\n+    /**\n+     * The DisplaySettings used to select the elements to display in the\n+     * displayed line of full usage information. \n+     * @see DisplaySetting\n+     * @param fullUsageSettings\n+     */\n+    public void setFullUsageSettings(Set fullUsageSettings) {\n+        this.fullUsageSettings = fullUsageSettings;\n+    }\n+\n+    /**\n+     * Sets the Group of Options to document\n+     * @param group the options to document\n+     */\n+    public void setGroup(Group group) {\n+        this.group = group;\n+    }\n+\n+    /**\n+     * Sets the footer text of the help screen\n+     * @param header the footer text\n+     */\n+    public void setHeader(String header) {\n+        this.header = header;\n+    }\n+\n+    /**\n+     * Sets the DisplaySettings used to select elements in the per helpline \n+     * usage strings.\n+     * @see DisplaySetting\n+     * @param lineUsageSettings the DisplaySettings to use\n+     */\n+    public void setLineUsageSettings(Set lineUsageSettings) {\n+        this.lineUsageSettings = lineUsageSettings;\n+    }\n+\n+    /**\n+     * Sets the command string used to invoke the application\n+     * @param shellCommand the invokation command\n+     */\n+    public void setShellCommand(String shellCommand) {\n+        this.shellCommand = shellCommand;\n+    }\n+\n+    /**\n+     * @return the Comparator used to sort the Group\n+     */\n+    public Comparator getComparator() {\n+        return comparator;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used to select HelpLines\n+     */\n+    public Set getDisplaySettings() {\n+        return displaySettings;\n+    }\n+\n+    /**\n+     * @return the String used as a horizontal section divider\n+     */\n+    public String getDivider() {\n+        return divider;\n+    }\n+\n+    /**\n+     * @return the Exception being documented by this HelpFormatter\n+     */\n+    public OptionException getException() {\n+        return exception;\n+    }\n+\n+    /**\n+     * @return the help screen footer text\n+     */\n+    public String getFooter() {\n+        return footer;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used in the full usage string\n+     */\n+    public Set getFullUsageSettings() {\n+        return fullUsageSettings;\n+    }\n+\n+    /**\n+     * @return the group documented by this HelpFormatter\n+     */\n+    public Group getGroup() {\n+        return group;\n+    }\n+\n+    /**\n+     * @return the String used as the central gutter\n+     */\n+    public String getGutterCenter() {\n+        return gutterCenter;\n+    }\n+\n+    /**\n+     * @return the String used as the left gutter\n+     */\n+    public String getGutterLeft() {\n+        return gutterLeft;\n+    }\n+\n+    /**\n+     * @return the String used as the right gutter\n+     */\n+    public String getGutterRight() {\n+        return gutterRight;\n+    }\n+\n+    /**\n+     * @return the help screen header text\n+     */\n+    public String getHeader() {\n+        return header;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used in the per help line usage strings\n+     */\n+    public Set getLineUsageSettings() {\n+        return lineUsageSettings;\n+    }\n+\n+    /**\n+     * @return the width of the screen in characters\n+     */\n+    public int getPageWidth() {\n+        return pageWidth;\n+    }\n+\n+    /**\n+     * @return the command used to execute the application  \n+     */\n+    public String getShellCommand() {\n+        return shellCommand;\n+    }\n+\n+    /**\n+     * @param out the PrintWriter to write to\n+     */\n+    public void setPrintWriter(PrintWriter out) {\n+        this.out = out;\n+    }\n+\n+    /**\n+     * @return the PrintWriter that will be written to\n+     */\n+    public PrintWriter getPrintWriter() {\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/ClassValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A validator checking for classnames\n+ */\n+public class ClassValidator implements Validator {\n+\n+    /** i18n */\n+    private static final ResourceHelper resources =\n+        ResourceHelper.getResourceHelper(ClassValidator.class);\n+\n+    private boolean loadable;\n+    private boolean instance;\n+\n+    private ClassLoader loader;\n+\n+    public void validate(final List values) throws InvalidArgumentException {\n+\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String)i.next();\n+\n+            if (!isPotentialClassName(name)) {\n+                throw new InvalidArgumentException(\n+                    resources.getMessage(\n+                        \"ClassValidator.error.bad.classname\",\n+                        name));\n+            }\n+\n+            if (loadable || instance) {\n+                final ClassLoader theLoader = getClassLoader();\n+                try {\n+                    final Class clazz = theLoader.loadClass(name);\n+                    if (instance) {\n+                        i.set(clazz.newInstance());\n+                    }\n+                    else {\n+                        i.set(clazz);\n+                    }\n+                }\n+                catch (final ClassNotFoundException exp) {\n+                    throw new InvalidArgumentException(\n+                        resources.getMessage(\n+                            \"ClassValidator.error.class.notfound\",\n+                            name));\n+                }\n+                catch (final IllegalAccessException exp) {\n+                    throw new InvalidArgumentException(\n+                        resources.getMessage(\n+                            \"ClassValidator.error.class.access\",\n+                            name,\n+                            exp.getMessage()));\n+                }\n+                catch (final InstantiationException exp) {\n+                    throw new InvalidArgumentException(\n+                        resources.getMessage(\n+                            \"ClassValidator.error.class.create\",\n+                            name));\n+                }\n+            }\n+        }\n+    }\n+\n+    protected boolean isPotentialClassName(final String name) {\n+        final char[] chars = name.toCharArray();\n+\n+        boolean expectingStart = true;\n+\n+        for (int i = 0; i < chars.length; ++i) {\n+            final char c = chars[i];\n+            if (expectingStart) {\n+                if (!Character.isJavaIdentifierStart(c)) {\n+                    return false;\n+                }\n+                else {\n+                    expectingStart = false;\n+                }\n+            }\n+            else {\n+                if (c == '.') {\n+                    expectingStart = true;\n+                }\n+                else if (!Character.isJavaIdentifierPart(c)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return !expectingStart;\n+    }\n+\n+    /**\n+     * @return true iff class must be loadable to be valid\n+     */\n+    public boolean isLoadable() {\n+        return loadable;\n+    }\n+\n+    /**\n+     * true iff class must be loadable to be valid\n+     * @param loadable new loadable value\n+     */\n+    public void setLoadable(boolean loadable) {\n+        this.loadable = loadable;\n+    }\n+\n+    /**\n+     * @return the classloader to resolve classes in\n+     */\n+    public ClassLoader getClassLoader() {\n+        if (loader == null) {\n+            loader = getClass().getClassLoader();\n+        }\n+        \n+        return loader;\n+    }\n+\n+    /**\n+     * @param loader the classloader to resolve classes in\n+     */\n+    public void setClassLoader(ClassLoader loader) {\n+        this.loader = loader;\n+    }\n+\n+    /**\n+     * @return true iff class instance is needed to be valid \n+     */\n+    public boolean isInstance() {\n+        return instance;\n+    }\n+\n+    /**\n+     * @param instance true iff class instance is needed to be valid\n+     */\n+    public void setInstance(boolean instance) {\n+        this.instance = instance;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/DateValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.DateFormat;\n+import java.text.ParsePosition;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * @author John Keyes\n+ * \n+ * @see java.text.DateFormat\n+ */\n+public class DateValidator implements Validator {\n+\n+    /** an array of permitted DateFormats */\n+    private final DateFormat[] formats;\n+\n+    /** minimum Date allowed i.e: a valid date occurs later than this date */\n+    private Date minimum;\n+\n+    /** maximum Date allowed i.e: a valid date occurs earlier than this date */\n+    private Date maximum;\n+\n+    /**\n+     * Creates a Validator for dates.\n+     * \n+     * @return DateValidator a Validator for dates\n+     */\n+    public static DateValidator getDateInstance() {\n+        return new DateValidator(DateFormat.getDateInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for times.\n+     * \n+     * @return DateValidator a Validator for times\n+     */\n+    public static DateValidator getTimeInstance() {\n+        return new DateValidator(DateFormat.getTimeInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for date/times\n+     * \n+     * @return DateValidator a Validator for date/times\n+     */\n+    public static DateValidator getDateTimeInstance() {\n+        return new DateValidator(DateFormat.getDateTimeInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for the default date/time format\n+     */\n+    public DateValidator() {\n+        this(DateFormat.getInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for the specified DateFormat.\n+     * \n+     * @param format\n+     *            a DateFormat which dates must conform to\n+     */\n+    public DateValidator(final DateFormat format) {\n+        this.formats = new DateFormat[] { format };\n+    }\n+\n+    /**\n+     * Creates a Validator for the List of specified DateFormats.\n+     * \n+     * @param formats\n+     *            a List of DateFormats which dates must conform to\n+     */\n+    public DateValidator(final List formats) {\n+        this.formats =\n+            (DateFormat[])formats.toArray(new DateFormat[formats.size()]);\n+    }\n+\n+    /**\n+     * Validate each String value in the specified List against this instances\n+     * permitted DateFormats.\n+     * \n+     * If a value is valid then it's <code>String</code> value in the list is\n+     * replaced with it's <code>Date</code> value.\n+     * \n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values) throws InvalidArgumentException {\n+\n+        // for each value\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+\n+            final String value = (String)i.next();\n+\n+            Date date = null;\n+\n+            // create a resuable ParsePosition instance\n+            final ParsePosition pp = new ParsePosition(0);\n+\n+            // for each permitted DateFormat\n+            for (int f = 0; f < this.formats.length && date == null; ++f) {\n+\n+                // reset the parse position\n+                pp.setIndex(0);\n+\n+                // TODO: should we call setLenient(false) on\n+                //       each DateFormat or allow the user\n+                //       to specify the parsing used\n+                date = this.formats[f].parse(value, pp);\n+\n+                // if the wrong number of characters have been parsed\n+                if (pp.getIndex() < value.length()) {\n+                    date = null;\n+                }\n+            }\n+\n+            // if date has not been set throw an InvalidArgumentException\n+            if (date == null) {\n+                throw new InvalidArgumentException(value);\n+            }\n+\n+            // if the date is outside the bounds\n+            if (isDateEarlier(date) || isDateLater(date)) {\n+                throw new InvalidArgumentException(\"Out of range: \" + value);\n+            }\n+\n+            // replace the value in the list with the actual Date\n+            i.set(date);\n+        }\n+    }\n+\n+    /**\n+     * Returns the maximum date permitted.\n+     * \n+     * @return Date the maximum date permitted. If no maximum date has been\n+     *         specified then return <code>null</code>.\n+     */\n+    public Date getMaximum() {\n+        return maximum;\n+    }\n+\n+    /**\n+     * Sets the maximum Date to the specified value.\n+     * \n+     * @param maximum\n+     *            the maximum Date permitted\n+     */\n+    public void setMaximum(final Date maximum) {\n+        this.maximum = maximum;\n+    }\n+\n+    /**\n+     * Returns the minimum date permitted.\n+     * \n+     * @return Date the minimum date permitted. If no minimum date has been\n+     *         specified then return <code>null</code>.\n+     */\n+    public Date getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * Sets the minimum Date to the specified value.\n+     * \n+     * @param minimum\n+     *            the minimum Date permitted\n+     */\n+    public void setMinimum(Date minimum) {\n+        this.minimum = minimum;\n+    }\n+\n+    /**\n+     * Returns whether the specified Date is later than the maximum date.\n+     * \n+     * @param date\n+     *            the Date to evaluate\n+     * \n+     * @return boolean whether <code>date</code> is earlier than the maximum\n+     *         date\n+     */\n+    private boolean isDateLater(Date date) {\n+        return maximum != null && date.getTime() > maximum.getTime();\n+    }\n+\n+    /**\n+     * Returns whether the specified Date is earlier than the minimum date.\n+     * \n+     * @param date\n+     *            the Date to evaluate\n+     * \n+     * @return boolean whether <code>date</code> is earlier than the minimum\n+     *         date\n+     */\n+    private boolean isDateEarlier(Date date) {\n+        return minimum != null && date.getTime() < minimum.getTime();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/EnumValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * A Validator for a list of known string values.\n+ * \n+ * @author John Keyes\n+ */\n+public class EnumValidator implements Validator {\n+\n+    /** List of permitted values */\n+    private Set validValues;\n+\n+    /**\n+     * Creates a new StringValidator for the specified values.\n+     * \n+     * @param values\n+     *            the list of permitted values\n+     */\n+    public EnumValidator(final Set values) {\n+        this.validValues = values;\n+    }\n+\n+    /**\n+     * Validate the list of values against the list of permitted values.\n+     * \n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values) throws InvalidArgumentException {\n+        for (final Iterator iter = values.iterator(); iter.hasNext();) {\n+            final String value = (String)iter.next();\n+\n+            if (!this.validValues.contains(value)) {\n+                throw new InvalidArgumentException(\n+                    \"'\"\n+                        + value\n+                        + \"' is not allowed.  Permitted values are:\"\n+                        + getValuesAsString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the permitted values in a String\n+     * \n+     * @return String formatted list of values\n+     */\n+    private String getValuesAsString() {\n+        final StringBuffer buff = new StringBuffer();\n+\n+        buff.append(\"[\");\n+\n+        for (final Iterator iter = this.validValues.iterator();\n+            iter.hasNext();\n+            ) {\n+\n+            buff.append(\"'\").append(iter.next()).append(\"'\");\n+\n+            if (iter.hasNext()) {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        buff.append(\"]\");\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/FileValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A Validator implmentation requiring File values \n+ */\n+public class FileValidator implements Validator {\n+\n+    /**\n+     * @return an instance requiring existing entries \n+     */\n+    public static FileValidator getExistingInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        return validator;\n+    }\n+\n+    /**\n+     * @return an instance requiring existing files\n+     */\n+    public static FileValidator getExistingFileInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        validator.setFile(true);\n+        return validator;\n+    }\n+\n+    /**\n+     * @return an instance requiring existing directories\n+     */\n+    public static FileValidator getExistingDirectoryInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        validator.setDirectory(true);\n+        return validator;\n+    }\n+\n+    private boolean readable = false;\n+    private boolean writable = false;\n+    private boolean existing = false;\n+    private boolean directory = false;\n+    private boolean file = false;\n+    private boolean hidden = false;\n+\n+    public void validate(final List values) throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String)i.next();\n+            final File f = new File(name);\n+\n+            if ((existing && !f.exists())\n+                || (file && !f.isFile())\n+                || (directory && !f.isDirectory())\n+                || (hidden && !f.isHidden())\n+                || (readable && !f.canRead())\n+                || (writable && !f.canWrite())) {\n+\n+                throw new InvalidArgumentException(name);\n+            }\n+            else {\n+                i.set(f);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return true iff the file is a directory\n+     */\n+    public boolean isDirectory() {\n+        return directory;\n+    }\n+\n+    /**\n+     * @param directory true if the file must be a directory\n+     */\n+    public void setDirectory(boolean directory) {\n+        this.directory = directory;\n+    }\n+\n+    /**\n+     * @return true iff the file exists\n+     */\n+    public boolean isExisting() {\n+        return existing;\n+    }\n+\n+    /**\n+     * @param existing true if the file must exist\n+     */\n+    public void setExisting(boolean existing) {\n+        this.existing = existing;\n+    }\n+\n+    /**\n+     * @return true iff the file is a file (not directory)\n+     */\n+    public boolean isFile() {\n+        return file;\n+    }\n+\n+    /**\n+     * @param file true if the file must be a file (not directory)\n+     */\n+    public void setFile(boolean file) {\n+        this.file = file;\n+    }\n+\n+    /**\n+     * @return true iff the file must be hidden\n+     */\n+    public boolean isHidden() {\n+        return hidden;\n+    }\n+\n+    /**\n+     * @param hidden true if the file must be hidden\n+     */\n+    public void setHidden(boolean hidden) {\n+        this.hidden = hidden;\n+    }\n+\n+    /**\n+     * @return true iff the file must be readable\n+     */\n+    public boolean isReadable() {\n+        return readable;\n+    }\n+\n+    /**\n+     * @param readable true if the file must be readable\n+     */\n+    public void setReadable(boolean readable) {\n+        this.readable = readable;\n+    }\n+\n+    /**\n+     * @return true iff the file must be writable\n+     */\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    /**\n+     * @param writable true if the file must be writable\n+     */\n+    public void setWritable(boolean writable) {\n+        this.writable = writable;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/InvalidArgumentException.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+/**\n+ * An exception indicating validation failure\n+ */\n+public class InvalidArgumentException extends Exception {\n+\n+    /**\n+     * Creates a new exception\n+     * @param message the reason for failure\n+     */\n+    public InvalidArgumentException(final String message) {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/NumberValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A Validator instance that parses Numbers\n+ */\n+public class NumberValidator implements Validator {\n+\n+    /**\n+     * @return an instance using local currency format\n+     */\n+    public static NumberValidator getCurrencyInstance() {\n+        return new NumberValidator(NumberFormat.getCurrencyInstance());\n+    }\n+\n+    /**\n+     * @return an instance using local integer format\n+     */\n+    public static NumberValidator getIntegerInstance() {\n+        final NumberFormat format = NumberFormat.getNumberInstance();\n+        format.setParseIntegerOnly(true);\n+        return new NumberValidator(format);\n+    }\n+\n+    /**\n+     * @return an instance using local percent format\n+     */\n+    public static NumberValidator getPercentInstance() {\n+        return new NumberValidator(NumberFormat.getPercentInstance());\n+    }\n+\n+    /**\n+     * @return an instance using local number format\n+     */\n+    public static NumberValidator getNumberInstance() {\n+        return new NumberValidator(NumberFormat.getNumberInstance());\n+    }\n+\n+    private final NumberFormat format;\n+    private Number minimum = null;\n+    private Number maximum = null;\n+\n+    /**\n+     * Creates a new NumberValidator\n+     */\n+    public NumberValidator() {\n+        this(NumberFormat.getInstance());\n+    }\n+\n+    /**\n+     * Creates a new NumberValidator based on the specified NumberFormat\n+     * @param format the format of numbers to accept\n+     */\n+    public NumberValidator(final NumberFormat format) {\n+        this.format = format;\n+    }\n+\n+    public void validate(final List values) throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String value = (String)i.next();\n+\n+            final ParsePosition pp = new ParsePosition(0);\n+            final Number number = format.parse(value, pp);\n+            if (pp.getIndex() < value.length()) {\n+                throw new InvalidArgumentException(value);\n+            }\n+\n+            if ((minimum != null\n+                && number.doubleValue() < minimum.doubleValue())\n+                || (maximum != null\n+                    && number.doubleValue() > maximum.doubleValue())) {\n+                throw new InvalidArgumentException(\"Out of range: \" + value);\n+            }\n+\n+            i.set(number);\n+        }\n+    }\n+\n+    /**\n+     * @return the format of a valid Number\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * @return the maximum value for a valid Number\n+     */\n+    public Number getMaximum() {\n+        return maximum;\n+    }\n+\n+    /**\n+     * @param maximum the maximum value for a valid Number\n+     */\n+    public void setMaximum(Number maximum) {\n+        this.maximum = maximum;\n+    }\n+\n+    /**\n+     * @return the minimum value for a valid Number\n+     */\n+    public Number getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * @param minimum the minimum value for a valid Number\n+     */\n+    public void setMinimum(Number minimum) {\n+        this.minimum = minimum;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/UrlValidator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A Validator instance that accepts urls\n+ */\n+public class UrlValidator implements Validator {\n+\n+    private String protocol = null;\n+\n+    public void validate(final List values) throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String)i.next();\n+            try {\n+                final URL url = new URL(name);\n+\n+                if (protocol != null && !protocol.equals(url.getProtocol())) {\n+                    throw new InvalidArgumentException(name);\n+                }\n+\n+                i.set(url);\n+            }\n+            catch (final MalformedURLException mue) {\n+                throw new InvalidArgumentException(\n+                    \"Cannot understand url: \" + name);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return the protocol that must be used by a valid url\n+     */\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    /**\n+     * @param protocol the protocol that a valid url must use\n+     */\n+    public void setProtocol(String protocol) {\n+        this.protocol = protocol;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/validation/Validator.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.List;\n+\n+/**\n+ * Identifies (and maybe converts) the acceptable Argument values \n+ */\n+public interface Validator {\n+\n+    /**\n+     * Validate the specified values (List of Strings).\n+     * \n+     * @param values\n+     *            the values to validate\n+     * \n+     * @throws InvalidArgumentException\n+     *             if any of the specified values are not valid\n+     */\n+    void validate(final List values) throws InvalidArgumentException;\n+}\n--- a/src/test/org/apache/commons/cli/ApplicationTest.java\n+++ b/src/test/org/apache/commons/cli/ApplicationTest.java\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/BugsTest.java\n+++ b/src/test/org/apache/commons/cli/BugsTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: BugsTest.java,v 1.17 2004/03/26 19:35:01 roxspring Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n         CommandLine line = parser.parse( options, args );\n         assertEquals( \"Two Words\", line.getOptionValue( \"m\" ) );\n     }\n-    \n-    public void test27575() {\n-    \tOptions options = PatternOptionBuilder.parsePattern(\"hc!<\");\n-    \tassertNotNull(options);\n-    \tOption h = options.getOption(\"-h\");\n-    \tassertNotNull(h);\n-    \tassertFalse(h.isRequired());\n-    \tOption c = options.getOption(\"-c\");\n-    \tassertNotNull(c);\n-    \tassertTrue(c.isRequired());\n-    }\n \n }\n--- a/src/test/org/apache/commons/cli/BuildTest.java\n+++ b/src/test/org/apache/commons/cli/BuildTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: BuildTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/CLI2ConverterTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.builder.PatternBuilder;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+import junit.framework.TestCase;\n+\n+public class CLI2ConverterTest extends TestCase {\n+\t\n+\tprivate Options aceOptions;\n+\tprivate OptionGroup aceOptionGroup;\n+\tprivate Options abcdeOptions;\n+\tprivate Options pattern;\n+\t\n+\tprivate Option a;\n+\tprivate Option bbb;\n+\tprivate Option c;\n+\tprivate Option ddd;\n+\tprivate Option e;\n+\tprivate Option f;\n+\tprivate Option g;\n+\tprivate Option h;\n+\tprivate Option i;\n+\t\n+\tpublic void setUp(){\n+\t\ta = OptionBuilder.withDescription(\"A description\").create('a');\n+\t\tbbb = OptionBuilder.create(\"bbb\");\n+\t\tc = OptionBuilder.withLongOpt(\"ccc\").create('c');\n+\t\tddd = OptionBuilder.withLongOpt(\"ddd\").create();\n+\t\te = OptionBuilder.isRequired(true).create(\"e\");\n+\t\tf = OptionBuilder.hasArg().withArgName(\"argument\").create('f');\n+\t\tg = OptionBuilder.hasArgs(5).create('g');\n+\t\th = OptionBuilder.hasOptionalArg().create('h');\n+\t\ti = OptionBuilder.hasOptionalArgs(5).create('i');\n+\n+\t\taceOptions = new Options();\n+\t\taceOptions.addOption(OptionBuilder.create('a'));\n+\t\taceOptions.addOption(OptionBuilder.create('c'));\n+\t\taceOptions.addOption(OptionBuilder.create('e'));\n+\t\t\n+\t\taceOptionGroup = new OptionGroup();\n+\t\taceOptionGroup.addOption(OptionBuilder.create('a'));\n+\t\taceOptionGroup.addOption(OptionBuilder.create('c'));\n+\t\taceOptionGroup.addOption(OptionBuilder.create('e'));\n+\t\t\n+\t\tabcdeOptions = new Options();\n+\t\tabcdeOptions.addOption(OptionBuilder.create('d'));\n+\t\tOptionGroup og = new OptionGroup();\n+\t\tog.addOption(OptionBuilder.create('a'));\n+\t\tog.addOption(OptionBuilder.create('c'));\n+\t\tog.addOption(OptionBuilder.create('e'));\n+\t\tabcdeOptions.addOptionGroup(og);\n+\t\tabcdeOptions.addOption(OptionBuilder.create('b'));\n+\t\t\n+\t\tpattern = PatternOptionBuilder.parsePattern(\"a%ce:\");\n+\t}\n+\t\n+\t/*\n+\t * Class to test for Option option(Option)\n+\t */\n+\tpublic void testOption() {\n+\t\tassertTrue(e.isRequired());\n+\t\t\n+\t\tassertEquals(\"A description\",a.getDescription());\n+\t\tassertEquals('a',a.getId());\n+\t\tassertEquals(\"[-a]\",CLI2Converter.option(a).toString());\n+\t\tassertEquals(\"[-bbb]\",CLI2Converter.option(bbb).toString());\n+\t\tassertEquals(\"[-c (--ccc)]\",CLI2Converter.option(c).toString());\n+\t\tassertEquals(\"[--ddd]\",CLI2Converter.option(ddd).toString());\n+\t\tassertEquals(\"-e\",CLI2Converter.option(e).toString());\n+\t\tassertEquals(\"[-f <argument>]\",CLI2Converter.option(f).toString());\n+\t\tassertEquals(\"[-g <arg1> <arg2> <arg3> <arg4> <arg5>]\",CLI2Converter.option(g).toString());\n+\t\tassertEquals(\"[-h [<arg>]]\",CLI2Converter.option(h).toString());\n+\t\tassertEquals(\"[-i [<arg1> [<arg2> [<arg3> [<arg4> [<arg5>]]]]]]\",CLI2Converter.option(i).toString());\n+\t}\n+\t/*\n+\t * Class to test for Group group(OptionGroup)\n+\t */\n+\tpublic void testGroupOptionGroup() {\n+\t\tGroupImpl group;\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptionGroup);\n+\t\tassertEquals(\"[-a|-c|-e]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(1,group.getMaximum());\n+\t\t\n+\t\taceOptionGroup.setRequired(true);\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptionGroup);\n+\t\tassertEquals(\"-a|-c|-e\",group.toString());\n+\t\tassertEquals(1,group.getMinimum());\n+\t\tassertEquals(1,group.getMaximum());\n+\t}\n+\t/*\n+\t * Class to test for Group group(Options)\n+\t */\n+\tpublic void testGroupOptions() {\n+\t\t\n+\t\tGroupImpl group;\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptions);\n+\t\tassertEquals(\"[-a|-c|-e]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(abcdeOptions);\n+\t\t\n+\t\tassertEquals(\"[-a|-c|-e|-d|-b]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(pattern);\n+\t\tassertEquals(\"[-a <arg>|-c|-e <arg>]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t}\n+}\n--- a/src/test/org/apache/commons/cli/GnuParseTest.java\n+++ b/src/test/org/apache/commons/cli/GnuParseTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: GnuParseTest.java,v 1.3 2002/09/19 22:59:44 jkeyes Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/HelpFormatterExamples.java\n+++ b/src/test/org/apache/commons/cli/HelpFormatterExamples.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: HelpFormatterExamples.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n package org.apache.commons.cli;\n \n--- a/src/test/org/apache/commons/cli/OptionBuilderTest.java\n+++ b/src/test/org/apache/commons/cli/OptionBuilderTest.java\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/OptionGroupTest.java\n+++ b/src/test/org/apache/commons/cli/OptionGroupTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: OptionGroupTest.java,v 1.1 2002/04/23 16:08:02 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/OptionsTest.java\n+++ b/src/test/org/apache/commons/cli/OptionsTest.java\n-/*\n- * Copyright 1999-2001,2004 The Apache Software Foundation.\n- * \n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * @author Rob Oxspring roxspring@apache.org\n- * @version $Revision: 1.3 $\n+ * @version $Revision: 1.4 $\n  */\n public class OptionsTest extends TestCase\n {\n--- a/src/test/org/apache/commons/cli/ParseRequiredTest.java\n+++ b/src/test/org/apache/commons/cli/ParseRequiredTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: ParseRequiredTest.java,v 1.1 2002/04/23 16:08:02 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/ParseTest.java\n+++ b/src/test/org/apache/commons/cli/ParseTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: ParseTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n+++ b/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: PatternOptionBuilderTest.java,v 1.1 2002/06/06 22:09:25 bayard Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n package org.apache.commons.cli;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n-\n-import java.io.StringWriter;\n-import java.io.PrintWriter;\n \n /** \n  * Test case for the PatternOptionBuilder class \n--- a/src/test/org/apache/commons/cli/TestHelpFormatter.java\n+++ b/src/test/org/apache/commons/cli/TestHelpFormatter.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: TestHelpFormatter.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n package org.apache.commons.cli;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n \n /** \n  * Test case for the HelpFormatter class \n        assertEquals(\"simple auto usage\", expected, out.toString().trim());\n        out.reset();\n \n-       expected = \"usage: app [-b] [-a]\";\n+       expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\")\n        .addOption(\"b\", false, \"bbb\" );\n        hf.printUsage( pw, 60, \"app\", options );\n--- a/src/test/org/apache/commons/cli/ValueTest.java\n+++ b/src/test/org/apache/commons/cli/ValueTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: ValueTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import junit.framework.Test;\n--- a/src/test/org/apache/commons/cli/ValuesTest.java\n+++ b/src/test/org/apache/commons/cli/ValuesTest.java\n-/*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n+/**\n+ * Copyright 2001-2004 The Apache Software Foundation\n  *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: ValueTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n-\n package org.apache.commons.cli;\n \n import java.util.Arrays;\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/CLITestCase.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public class CLITestCase extends TestCase {\n+\n+\tpublic static List list() {\n+\t    return Collections.EMPTY_LIST;\n+\t}\n+\n+\tpublic static List list(final Object args[]) {\n+\t    return new LinkedList(Arrays.asList(args));\n+\t}\n+\n+\tpublic static List list(final Object arg0) {\n+\t    return list(new Object[] { arg0 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1) {\n+\t    return list(new Object[] { arg0, arg1 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2) {\n+\t    return list(new Object[] { arg0, arg1, arg2 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4, final Object arg5) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4, arg5 });\n+\t}\n+\n+\tpublic static void assertListContentsEqual(final List expected, final List found) {\n+\t\n+\t    final Iterator e = expected.iterator();\n+\t    final Iterator f = found.iterator();\n+\t\n+\t    while (e.hasNext() && f.hasNext()) {\n+\t        assertEquals(e.next(), f.next());\n+\t    }\n+\t\n+\t    if (e.hasNext()) {\n+\t        fail(\"Expected more elements\");\n+\t    }\n+\t\n+\t    if (f.hasNext()) {\n+\t        fail(\"Found more elements\");\n+\t    }\n+\t}\n+\n+\tpublic static void assertContentsEqual(final Collection expected, final Collection found) {\n+\t    assertTrue(expected.containsAll(found));\n+\t    assertTrue(found.containsAll(expected));\n+\t    assertEquals(expected.size(), found.size());\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/CommandLineTestCase.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+import org.apache.commons.cli2.option.CommandTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+import org.apache.commons.cli2.option.OptionTestCase;\n+import org.apache.commons.cli2.option.PropertyOption;\n+import org.apache.commons.cli2.option.SwitchTest;\n+\n+public abstract class CommandLineTestCase extends CLITestCase {\n+\t\n+\tprotected abstract CommandLine createCommandLine();\n+\t\n+\tpublic final Option present = new DefaultOptionBuilder().withLongName(\"present\").withLongName(\"alsopresent\").create();\n+\tpublic final Option missing = new DefaultOptionBuilder().withLongName(\"missing\").create();\n+\tpublic final Option multiple = new DefaultOptionBuilder().withLongName(\"multiple\").create();\n+\tpublic final Option bool = new DefaultOptionBuilder().withLongName(\"bool\").create();\n+\t\n+\tpublic final Option root = new GroupBuilder().withOption(present).withOption(missing).withOption(multiple).withOption(bool).create();\n+\t\n+\tprivate CommandLine commandLine;\n+\t\n+\t/*\n+\t * @see TestCase#setUp()\n+\t */\n+\tpublic void setUp() throws Exception {\n+\t\tsuper.setUp();\n+\t\tcommandLine = createCommandLine();\n+\t}\n+\t/*\n+\t * Class to test for boolean hasOption(String)\n+\t */\n+\tpublic final void testHasOptionString() {\n+\t\tassertTrue(commandLine.hasOption(\"--present\"));\n+\t\tassertTrue(commandLine.hasOption(\"--alsopresent\"));\n+\t\tassertFalse(commandLine.hasOption(\"--missing\"));\n+\t}\n+\t\n+\t/*\n+\t * Class to test for boolean hasOption(Option)\n+\t */\n+\tpublic final void testHasOptionOption() {\n+\t\tassertTrue(commandLine.hasOption(present));\n+\t\tassertFalse(commandLine.hasOption(missing));\n+\t}\n+\tpublic final void testGetOption() {\n+\t\tassertSame(present,commandLine.getOption(\"--present\"));\n+\t\tassertSame(present,commandLine.getOption(\"--alsopresent\"));\n+\t\t//TODO decide whether the following assertion is valid\n+\t\t//assertSame(missing,commandLine.getOption(\"--missing\"));\n+\t}\n+\t/*\n+\t * Class to test for List getValues(String)\n+\t */\n+\tpublic final void testGetValuesString() {\n+\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--present\"));\n+\t\tassertListContentsEqual(list(\"value 1\",\"value 2\",\"value 3\"),commandLine.getValues(\"--multiple\"));\n+\t\tassertTrue(commandLine.getValues(\"--missing\").isEmpty());\n+\t}\n+\t/*\n+\t * Class to test for List getValues(String, List)\n+\t */\n+\tpublic final void testGetValuesStringList() {\n+\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--present\",null));\n+\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--alsopresent\",null));\n+\t\tassertSame(commandLine.getValues(\"--missing\",Collections.EMPTY_LIST),Collections.EMPTY_LIST);\n+\t\tfinal List def = Collections.singletonList(\"default value\");\n+\t\tassertSame(def,commandLine.getValues(\"--missing\",def));\n+\t}\n+\t/*\n+\t * Class to test for List getValues(Option)\n+\t */\n+\tpublic final void testGetValuesOption() {\n+\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(present));\n+\t\tassertTrue(commandLine.getValues(missing).isEmpty());\n+\t}\n+\t/*\n+\t * Class to test for List getValues(Option, List)\n+\t */\n+\tpublic final void testGetValuesOptionList() {\n+\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(present));\n+\t\tassertSame(commandLine.getValues(missing,Collections.EMPTY_LIST),Collections.EMPTY_LIST);\n+\t\tfinal List defs = Collections.singletonList(\"custom default\");\n+\t\tassertSame(defs,commandLine.getValues(missing,defs));\n+\t}\n+\t/*\n+\t * Class to test for Object getValue(String)\n+\t */\n+\tpublic final void testGetValueString() {\n+\t\tassertEquals(\"present value\",commandLine.getValue(\"--present\"));\n+\t\tassertEquals(\"present value\",commandLine.getValue(\"--alsopresent\"));\n+\t\tassertNull(commandLine.getValue(\"--missing\"));\n+\t\ttry{\n+\t\t\tcommandLine.getValue(\"--multiple\");\n+\t\t\tfail(\"expected IllegalStateException\");\n+\t\t}\n+\t\tcatch(IllegalStateException e){\n+\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n+\t\t}\n+\t}\n+\t/*\n+\t * Class to test for Object getValue(String, Object)\n+\t */\n+\tpublic final void testGetValueStringObject() {\n+\t\tassertEquals(\"present value\",commandLine.getValue(\"--present\",\"default value\"));\n+\t\tassertEquals(\"present value\",commandLine.getValue(\"--alsopresent\",\"default value\"));\n+\t\tassertEquals(\"default value\",commandLine.getValue(\"--missing\",\"default value\"));\n+\t\ttry{\n+\t\t\tcommandLine.getValue(\"--multiple\");\n+\t\t\tfail(\"expected IllegalStateException\");\n+\t\t}\n+\t\tcatch(IllegalStateException e){\n+\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n+\t\t}\n+\t}\n+\t/*\n+\t * Class to test for Object getValue(Option)\n+\t */\n+\tpublic final void testGetValueOption() {\n+\t\tassertEquals(\"present value\",commandLine.getValue(present));\n+\t\tassertNull(commandLine.getValue(missing));\n+\t\ttry{\n+\t\t\tcommandLine.getValue(multiple);\n+\t\t\tfail(\"expected IllegalStateException\");\n+\t\t}\n+\t\tcatch(IllegalStateException e){\n+\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n+\t\t}\n+\t}\n+\t/*\n+\t * Class to test for Object getValue(Option, Object)\n+\t */\n+\tpublic final void testGetValueOptionObject() {\n+\t\tassertEquals(\"present value\",commandLine.getValue(present,\"default value\"));\n+\t\tassertEquals(\"default value\",commandLine.getValue(missing,\"default value\"));\n+\t\ttry{\n+\t\t\tcommandLine.getValue(multiple);\n+\t\t\tfail(\"expected IllegalStateException\");\n+\t\t}\n+\t\tcatch(IllegalStateException e){\n+\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n+\t\t}\n+\t}\n+\t/*\n+\t * Class to test for Boolean getSwitch(String)\n+\t */\n+\tpublic final void testGetSwitchString() {\n+\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(\"--bool\"));\n+\t\tassertNull(commandLine.getSwitch(\"--missing\"));\n+\t}\n+\t/*\n+\t * Class to test for Boolean getSwitch(String, Boolean)\n+\t */\n+\tpublic final void testGetSwitchStringBoolean() {\n+\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(\"--bool\",Boolean.FALSE));\n+\t\tassertEquals(Boolean.FALSE,commandLine.getSwitch(\"--missing\",Boolean.FALSE));\n+\t}\n+\t/*\n+\t * Class to test for Boolean getSwitch(Option)\n+\t */\n+\tpublic final void testGetSwitchOption() {\n+\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(bool));\n+\t\tassertNull(commandLine.getSwitch(missing));\n+\t}\n+\t/*\n+\t * Class to test for Boolean getSwitch(Option, Boolean)\n+\t */\n+\tpublic final void testGetSwitchOptionBoolean() {\n+\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(bool,Boolean.FALSE));\n+\t\tassertEquals(Boolean.FALSE,commandLine.getSwitch(missing,Boolean.FALSE));\n+\t}\n+\t/*\n+\t * Class to test for String getProperty(String)\n+\t */\n+\tpublic final void testGetPropertyString() {\n+\t\tassertEquals(\"present property\",commandLine.getProperty(\"present\"));\n+\t\tassertNull(commandLine.getProperty(\"missing\"));\n+\t}\n+\t/*\n+\t * Class to test for String getProperty(String, String)\n+\t */\n+\tpublic final void testGetPropertyStringString() {\n+\t\tassertEquals(\"present property\",commandLine.getProperty(\"present\",\"default property\"));\n+\t\tassertEquals(\"default property\",commandLine.getProperty(\"missing\",\"default property\"));\n+\t}\n+\tpublic final void testGetProperties() {\n+\t\tassertTrue(commandLine.getProperties().containsAll(list(\"present\")));\n+\t}\n+\t/*\n+\t * Class to test for int getOptionCount(String)\n+\t */\n+\tpublic final void testGetOptionCountString() {\n+\t\t// one option, one switch\n+\t\tassertTrue(1<=commandLine.getOptionCount(\"--present\"));\n+\t\tassertTrue(1<=commandLine.getOptionCount(\"--bool\"));\n+\t\tassertEquals(0,commandLine.getOptionCount(\"--missing\"));\n+\t}\n+\t/*\n+\t * Class to test for int getOptionCount(Option)\n+\t */\n+\tpublic final void testGetOptionCountOption() {\n+\t\t// one option, one switch\n+\t\tassertTrue(1<=commandLine.getOptionCount(present));\n+\t\tassertTrue(1<=commandLine.getOptionCount(bool));\n+\t\tassertEquals(0,commandLine.getOptionCount(missing));\n+\t}\n+\tpublic final void testGetOptions() {\n+\t\t//TODO Implement getOptions().\n+\t}\n+\tpublic final void testGetOptionTriggers() {\n+\t\t//TODO Implement getOptionTriggers().\n+\t}\n+\t\n+\t\n+\t// OLD TESTS FOLLOW\n+\n+    public final void testProperties() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        assertTrue(commandLine.getProperties().isEmpty());\n+\n+        commandLine.addProperty(\"myprop\", \"myval\");\n+        assertEquals(1, commandLine.getProperties().size());\n+        assertEquals(\"myval\", commandLine.getProperty(\"myprop\"));\n+\n+        commandLine.addProperty(\"myprop\", \"myval2\");\n+        assertEquals(1, commandLine.getProperties().size());\n+        assertEquals(\"myval2\", commandLine.getProperty(\"myprop\"));\n+\n+        commandLine.addProperty(\"myprop2\", \"myval3\");\n+        assertEquals(2, commandLine.getProperties().size());\n+        assertEquals(\"myval3\", commandLine.getProperty(\"myprop2\"));\n+    }\n+\n+    public final void testOptions() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertFalse(commandLine.hasOption(start));\n+        assertFalse(commandLine.hasOption(\"start\"));\n+        assertFalse(commandLine.hasOption(\"go\"));\n+\n+        commandLine.addOption(start);\n+\n+        assertTrue(commandLine.hasOption(start));\n+        assertTrue(commandLine.hasOption(\"start\"));\n+        assertTrue(commandLine.hasOption(\"go\"));\n+    }\n+\n+    public final void testValues() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertNull(commandLine.getValue(start));\n+        assertTrue(commandLine.getValues(start).isEmpty());\n+\n+        commandLine.addOption(start);\n+\n+        assertTrue(commandLine.getValues(start).isEmpty());\n+\n+        commandLine.addValue(start, \"file1\");\n+\n+        assertEquals(\"file1\", commandLine.getValue(start));\n+        assertEquals(\"file1\", commandLine.getValue(\"start\"));\n+        assertEquals(\"file1\", commandLine.getValue(\"go\"));\n+        assertEquals(1, commandLine.getValues(start).size());\n+        assertEquals(1, commandLine.getValues(\"start\").size());\n+        assertEquals(1, commandLine.getValues(\"go\").size());\n+        assertTrue(commandLine.getValues(start).contains(\"file1\"));\n+        assertTrue(commandLine.getValues(\"start\").contains(\"file1\"));\n+        assertTrue(commandLine.getValues(\"go\").contains(\"file1\"));\n+\n+        commandLine.addValue(start, \"file2\");\n+\n+        try {\n+            commandLine.getValue(start);\n+            fail(\"Cannot get single value if multiple are present\");\n+        }\n+        catch (IllegalStateException ise) {\n+            assertEquals(\"More than one value was supplied\", ise.getMessage());\n+        }\n+\n+        try {\n+            commandLine.getValue(\"start\");\n+            fail(\"Cannot get single value if multiple are present\");\n+        }\n+        catch (IllegalStateException ise) {\n+            assertEquals(\"More than one value was supplied\", ise.getMessage());\n+        }\n+\n+        commandLine.getValues(start).add(\"file3\");\n+    }\n+\n+    public final void testSwitches() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertNull(commandLine.getSwitch(start));\n+        assertNull(commandLine.getSwitch(\"start\"));\n+        assertNull(commandLine.getSwitch(\"go\"));\n+\n+        commandLine.addSwitch(start, true);\n+        try {\n+            commandLine.addSwitch(start, false);\n+            fail(\"Switch cannot be changed\");\n+        }\n+        catch (IllegalStateException ise) {\n+            assertEquals(\"Switch already set\", ise.getMessage());\n+        }\n+    }\n+\n+    public final void testSwitches_True() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        commandLine.addSwitch(start, true);\n+        assertSame(Boolean.TRUE, commandLine.getSwitch(start));\n+    }\n+\n+    public final void testSwitches_False() {\n+        final Option option = new PropertyOption();\n+        final List args = OptionTestCase.list();\n+        final WriteableCommandLine commandLine =\n+            OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        commandLine.addSwitch(start, false);\n+        assertSame(Boolean.FALSE, commandLine.getSwitch(start));\n+    }\n+\n+//    public final void testLooksLikeOption() {\n+//        final Option option = new PropertyOption();\n+//        final List args = OptionTestCase.list();\n+//        final WriteableCommandLine commandLine =\n+//            OptionTestCase.commandLine(option, args);\n+//\n+//        assertTrue(commandLine.looksLikeOption(\"-D\"));\n+//        assertFalse(commandLine.looksLikeOption(\"--help\"));\n+//        assertFalse(commandLine.looksLikeOption(\"+display\"));\n+//        assertFalse(commandLine.looksLikeOption(\"myprefix\"));\n+//        assertFalse(commandLine.looksLikeOption(\"myprefix2\"));\n+//        assertFalse(commandLine.looksLikeOption(\"myprefference\"));\n+//        assertFalse(commandLine.looksLikeOption(\"/SCANDISK\"));\n+//        assertFalse(commandLine.looksLikeOption(\"update\"));\n+//    }\n+\n+    public final void testGetOptions_Order() throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+\n+        final Group group =\n+            new GroupBuilder()\n+                .withOption(help)\n+                .withOption(login)\n+                .withOption(targets)\n+                .create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+        final CommandLine cl =\n+            parser.parse(\n+                new String[] {\n+                    \"login\",\n+                    \"rob\",\n+                    \"--help\",\n+                    \"target1\",\n+                    \"target2\" });\n+\n+        final Iterator i = cl.getOptions().iterator();\n+\n+        assertSame(login, i.next());\n+        assertSame(help, i.next());\n+        assertSame(targets, i.next());\n+        assertSame(targets, i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public final void testGetOptionCount() throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+        final Option display = SwitchTest.buildDisplaySwitch();\n+\n+        final Group group =\n+            new GroupBuilder()\n+                .withOption(help)\n+                .withOption(login)\n+                .withOption(targets)\n+                .withOption(display)\n+                .create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+        final CommandLine cl =\n+            parser.parse(\n+                new String[] {\n+                    \"--help\",\n+                    \"login\",\n+                    \"rob\",\n+                    \"--help\",\n+                    \"--help\",\n+                    \"target1\",\n+                    \"target2\" });\n+\n+        assertEquals(1, cl.getOptionCount(login));\n+        assertEquals(3, cl.getOptionCount(help));\n+        assertEquals(2, cl.getOptionCount(targets));\n+        assertEquals(0, cl.getOptionCount(display));\n+    }\n+\n+    public final void testGetOptionCount_Strings() throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+        final Option display = SwitchTest.buildDisplaySwitch();\n+\n+        final Group group =\n+            new GroupBuilder()\n+                .withOption(help)\n+                .withOption(login)\n+                .withOption(targets)\n+                .withOption(display)\n+                .create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+        final CommandLine cl =\n+            parser.parse(\n+                new String[] {\n+                    \"--help\",\n+                    \"login\",\n+                    \"rob\",\n+                    \"--help\",\n+                    \"--help\",\n+                    \"target1\",\n+                    \"target2\" });\n+\n+        assertEquals(1, cl.getOptionCount(\"login\"));\n+        assertEquals(3, cl.getOptionCount(\"-?\"));\n+        assertEquals(0, cl.getOptionCount(\"+display\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/DocumentationTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.PropertyOption;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * @author Rob\n+ * \n+ * To change the template for this generated type comment go to Window -\n+ * Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class DocumentationTest extends TestCase {\n+\n+    public void testBasicUsage() throws IOException, OptionException {\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        //ignore all printed\n+        helpFormatter.setPrintWriter(new PrintWriter(new StringWriter()));\n+\n+        /*\n+         * --version -? -h --help -log file -s|-q|-v|-d Bursting File/Num/Date\n+         * validation Switches Commands Auto help Auto exception help\n+         *  \n+         */\n+        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        Option version =\n+            obuilder\n+                .withLongName(\"version\")\n+                .withDescription(\"Displays version information and then exits\")\n+                .create();\n+\n+        Option help =\n+            obuilder\n+                .withShortName(\"h\")\n+                .withShortName(\"?\")\n+                .withLongName(\"help\")\n+                .withDescription(\"Displays help on usage and then exits\")\n+                .create();\n+\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+        Argument logFile =\n+            abuilder\n+                .withDescription(\"The log file to write to\")\n+                .withName(\"file\")\n+                .withMinimum(1)\n+                .withMaximum(1)\n+                .create();\n+        Option log =\n+            obuilder\n+                .withArgument(logFile)\n+                .withShortName(\"log\")\n+                .withDescription(\"Log progress information to a file\")\n+                .create();\n+\n+        GroupBuilder gbuilder = new GroupBuilder();\n+        Group outputQuality =\n+            gbuilder\n+                .withName(\"quality\")\n+                .withDescription(\"Controls the quality of console output\")\n+                .withMaximum(1)\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"s\")\n+                        .withDescription(\"Silent\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"q\")\n+                        .withDescription(\"Quiet\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"n\")\n+                        .withDescription(\"Normal\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"v\")\n+                        .withDescription(\"Verbose\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"d\")\n+                        .withDescription(\"Debug\")\n+                        .create())\n+                .create();\n+\n+        Group options =\n+            new GroupBuilder()\n+                .withName(\"options\")\n+                .withOption(version)\n+                .withOption(help)\n+                .withOption(log)\n+                .withOption(outputQuality)\n+                .create();\n+\n+        final String[] args = new String[] { \"--bad-option\" };\n+\n+        Parser parser = new Parser();\n+        parser.setHelpFormatter(helpFormatter);\n+        parser.setGroup(options);\n+        parser.setHelpOption(help);\n+        CommandLine commandLine = parser.parseAndHelp(args);\n+        if (commandLine != null) {\n+            if (commandLine.hasOption(version)) {\n+                System.out.println(\"MyApp ver 1.0\");\n+                return;\n+            }\n+            if (commandLine.hasOption(\"-log\")) {\n+                String filename = (String)commandLine.getValue(\"-log\");\n+                //...\n+            }\n+        }\n+\n+        try {\n+            commandLine = parser.parse(args);\n+            fail(\"Unexpected Option!\");\n+        }\n+        catch (OptionException uoe) {\n+            assertEquals(\n+                \"Unexpected --bad-option while processing options\",\n+                uoe.getMessage());\n+        }\n+    }\n+\n+    public void testExampleAnt() throws IOException {\n+        // Based on Ant 1.5.3\n+\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        Option help =\n+            obuilder\n+                .withShortName(\"help\")\n+                .withDescription(\"print this message\")\n+                .create();\n+        Option projecthelp =\n+            obuilder\n+                .withShortName(\"projecthelp\")\n+                .withDescription(\"print project help information\")\n+                .create();\n+        Option version =\n+            obuilder\n+                .withShortName(\"version\")\n+                .withDescription(\"print the version information and exit\")\n+                .create();\n+        Option diagnostics =\n+            obuilder\n+                .withShortName(\"diagnostics\")\n+                .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                .create();\n+        Option quiet =\n+            obuilder\n+                .withShortName(\"quiet\")\n+                .withShortName(\"q\")\n+                .withDescription(\"be extra quiet\")\n+                .create();\n+        Option verbose =\n+            obuilder\n+                .withShortName(\"verbose\")\n+                .withShortName(\"v\")\n+                .withDescription(\"be extra verbose\")\n+                .create();\n+        Option debug =\n+            obuilder\n+                .withShortName(\"debug\")\n+                .withDescription(\"print debugging information\")\n+                .create();\n+        Option emacs =\n+            obuilder\n+                .withShortName(\"emacs\")\n+                .withDescription(\"produce logging information without adornments\")\n+                .create();\n+        Option logfile =\n+            obuilder\n+                .withShortName(\"logfile\")\n+                .withShortName(\"l\")\n+                .withDescription(\"produce logging information without adornments\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option logger =\n+            obuilder\n+                .withShortName(\"logger\")\n+                .withDescription(\"the class which is to perform logging\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"classname\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option listener =\n+            obuilder\n+                .withShortName(\"listener\")\n+                .withDescription(\"add an instance of class as a project listener\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"classname\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option buildfile =\n+            obuilder\n+                .withShortName(\"buildfile\")\n+                .withShortName(\"b\")\n+                .withShortName(\"file\")\n+                .withDescription(\"use given buildfile\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option property = new PropertyOption();\n+        Option propertyfile =\n+            obuilder\n+                .withShortName(\"propertyfile\")\n+                .withDescription(\"load all properties from file with -D properties taking precedence\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"name\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option inputhandler =\n+            obuilder\n+                .withShortName(\"inputhandler\")\n+                .withDescription(\"the class which will handle input requests\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"class\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option find =\n+            obuilder\n+                .withShortName(\"find\")\n+                .withDescription(\"search for buildfile towards the root of the filesystem and use it\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option targets = abuilder.withName(\"target\").create();\n+\n+        Group options =\n+            gbuilder\n+                .withName(\"options\")\n+                .withOption(help)\n+                .withOption(projecthelp)\n+                .withOption(version)\n+                .withOption(diagnostics)\n+                .withOption(quiet)\n+                .withOption(verbose)\n+                .withOption(debug)\n+                .withOption(emacs)\n+                .withOption(logfile)\n+                .withOption(logger)\n+                .withOption(listener)\n+                .withOption(buildfile)\n+                .withOption(property)\n+                .withOption(propertyfile)\n+                .withOption(inputhandler)\n+                .withOption(find)\n+                .withOption(targets)\n+                .create();\n+\n+        HelpFormatter hf = new HelpFormatter();\n+        hf.setShellCommand(\"ant\");\n+        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+        hf.getFullUsageSettings().remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+\n+        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+\n+        hf.getDisplaySettings().remove(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        hf.setGroup(options);\n+        // redirect printed stuff to a string\n+        hf.setPrintWriter(new PrintWriter(new StringWriter()));\n+        hf.print();\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/PrecedenceTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author Rob Oxspring\n+ * \n+ * To change the template for this generated type comment go to Window -\n+ * Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class PrecedenceTest extends TestCase {\n+    private final String[] args = new String[] { \"-file\" };\n+\n+    public void testSimple() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+\n+        final Group options =\n+            new GroupBuilder()\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-file\" }, cl);\n+    }\n+\n+    public void testArgument() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            new GroupBuilder()\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"f\").create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void testChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgument() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(oBuilder.withShortName(\"f\").create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(\n+            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },\n+            cl);\n+    }\n+\n+    public void testArgumentVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testArgumentVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"bi\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"bl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"be\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(\n+            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },\n+            cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void testArgumentVsBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsBurstVsChildren()\n+        throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public CommandLine buildCommandLine(final Group group, final String[] args)\n+        throws OptionException {\n+        Parser p = new Parser();\n+        p.setGroup(group);\n+        return p.parse(args);\n+    }\n+\n+    public void assertEquals(final String options[], final CommandLine line) {\n+        final List expected = Arrays.asList(options);\n+        final Set actual = line.getOptionTriggers();\n+\n+        //System.out.println(getName() + \": \" + actual);\n+\n+        assertTrue(expected.containsAll(actual));\n+        assertTrue(actual.containsAll(expected));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/WriteableCommandLineTestCase.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import org.apache.commons.cli2.option.ArgumentTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window - Preferences - Java - Code Generation - Code and Comments\n+ */\n+public abstract class WriteableCommandLineTestCase extends CommandLineTestCase {\n+\t\n+\tprivate WriteableCommandLine writeable;\n+\t\n+\tprotected abstract WriteableCommandLine createWriteableCommandLine();\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected final CommandLine createCommandLine() {\n+\t\tfinal WriteableCommandLine writeable = createWriteableCommandLine();\n+\t\twriteable.addOption(present);\n+\t\twriteable.addProperty(\"present\",\"present property\");\n+\t\twriteable.addSwitch(bool,true);\n+\t\twriteable.addValue(present,\"present value\");\n+\t\twriteable.addOption(multiple);\n+\t\twriteable.addValue(multiple,\"value 1\");\n+\t\twriteable.addValue(multiple,\"value 2\");\n+\t\twriteable.addValue(multiple,\"value 3\");\n+\t\treturn writeable;\n+\t}\n+\t\n+\t/*\n+\t * @see CommandLineTest#setUp()\n+\t */\n+\tpublic void setUp() throws Exception {\n+\t\tsuper.setUp();\n+\t\twriteable = createWriteableCommandLine();\n+\t}\n+\tpublic final void testAddOption() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\twriteable.addOption(present);\n+\t\tassertTrue(writeable.hasOption(present));\n+\t}\n+\tpublic final void testAddValue() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\tassertTrue(writeable.getValues(present).isEmpty());\n+\t\twriteable.addValue(present,\"value\");\n+\t\tassertContentsEqual(list(\"value\"),writeable.getValues(present));\n+\t\t\n+\t\t// most options shouldn't appear due to adding values\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\t\n+\t\tfinal Argument arg = ArgumentTest.buildHostArgument();\n+\t\t\n+\t\tassertFalse(writeable.hasOption(arg));\n+\t\tassertTrue(writeable.getValues(arg).isEmpty());\n+\t\twriteable.addValue(arg,\"value\");\n+\t\tassertContentsEqual(list(\"value\"),writeable.getValues(arg));\n+\t\t\n+\t\t// Arguments should force the option present\n+\t\tassertTrue(writeable.hasOption(arg));\n+\t}\n+\tpublic final void testAddSwitch() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\tassertNull(writeable.getSwitch(present));\n+\t\twriteable.addSwitch(present,true);\n+\t\tassertEquals(Boolean.TRUE,writeable.getSwitch(present));\n+\t\tassertTrue(writeable.hasOption(present));\n+\t}\n+\tpublic final void testAddProperty() {\n+\t\tassertNull(writeable.getProperty(\"present\"));\n+\t\twriteable.addProperty(\"present\",\"present value\");\n+\t\tassertEquals(\"present value\",writeable.getProperty(\"present\"));\n+\t}\n+\tpublic final void testLooksLikeOption() {\n+\t\t//TODO Implement looksLikeOption().\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/application/AntTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.PropertyOption;\n+\n+//TODO Build up AntTest like CpTest\n+public class AntTest extends TestCase {\n+    public void testAnt() throws OptionException {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Group options =\n+            gbuilder\n+                .withName(\"ant\")\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"help\")\n+                        .withDescription(\"print this message\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"projecthelp\")\n+                        .withDescription(\"print project help information\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"version\")\n+                        .withDescription(\"print the version information and exit\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"diagnostics\")\n+                        .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"quiet\")\n+                        .withShortName(\"q\")\n+                        .withDescription(\"be extra quiet\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"verbose\")\n+                        .withShortName(\"v\")\n+                        .withDescription(\"be extra verbose\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"debug\")\n+                        .withDescription(\"print debugging information\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"emacs\")\n+                        .withDescription(\"produce logging information without adornments\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"logfile\")\n+                        .withShortName(\"l\")\n+                        .withDescription(\"use given file for log\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"logger\")\n+                        .withDescription(\"the class which is to perform logging\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"classname\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"listener\")\n+                        .withDescription(\"add an instance of class as a project listener\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"classname\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"buildfile\")\n+                        .withShortName(\"file\")\n+                        .withShortName(\"f\")\n+                        .withDescription(\"use given buildfile\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(PropertyOption.INSTANCE)\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"propertyfile\")\n+                        .withDescription(\"load all properties from file with -D properties taking precedence\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"name\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"inputhandler\")\n+                        .withDescription(\"the class which will handle input requests\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"class\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"find\")\n+                        .withDescription(\"search for buildfile towards the root of the filesystem and use it\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(abuilder.withName(\"target\").create())\n+                .create();\n+\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line =\n+            parser.parse(\n+                new String[] {\n+                    \"-buildfile\",\n+                    \"mybuild.xml\",\n+                    \"-Dproperty=value\",\n+                    \"-Dproperty1=value1\",\n+                    \"-projecthelp\",\n+                    \"compile\",\n+                    \"docs\" });\n+\n+        // check properties\n+        assertEquals(2, line.getProperties().size());\n+        assertEquals(\"value\", line.getProperty(\"property\"));\n+        assertEquals(\"value1\", line.getProperty(\"property1\"));\n+\n+        // check single values\n+        assertEquals(\"mybuild.xml\", line.getValue(\"-buildfile\"));\n+        assertTrue(line.hasOption(\"-projecthelp\"));\n+        assertFalse(line.hasOption(\"-help\"));\n+\n+        assertTrue(line.hasOption(\"target\"));\n+        final List targets = new ArrayList();\n+        targets.add(\"compile\");\n+        targets.add(\"docs\");\n+        assertEquals(targets, line.getValues(\"target\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/application/CpTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.ArgumentImpl;\n+import org.apache.commons.cli2.option.SourceDestArgument;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * <p>Test the <code>cp</code> command. Duplicated Option types are not\n+ * tested e.g. -a and -d are the same Option type.</p>\n+ * \n+ * <p>The following is the man output for 'cp'. See\n+ * http://www.rt.com/man/cp.1.html.</p>\n+ * \n+ * <pre>\n+ *  CP(1) FSF CP(1)\n+ * \n+ *  NAME cp - copy files and directories\n+ * \n+ *  SYNOPSIS cp [OPTION]... SOURCE DEST cp [OPTION]... SOURCE... DIRECTORY\n+ * \n+ *  DESCRIPTION Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n+ * \n+ *  -a, --archive same as -dpR\n+ * \n+ *  -b, --backup make backup before removal\n+ * \n+ *  -d, --no-dereference preserve links\n+ * \n+ *  -f, --force remove existing destinations, never prompt\n+ * \n+ *  -i, --interactive prompt before overwrite\n+ * \n+ *  -l, --link link files instead of copying\n+ * \n+ *  -p, --preserve preserve file attributes if possible\n+ * \n+ *  -P, --parents append source path to DIRECTORY\n+ * -r copy recursively, non-directories as files\n+ * \n+ *  --sparse=WHEN control creation of sparse files\n+ * \n+ *  -R, --recursive copy directories recursively\n+ * \n+ *  -s, --symbolic-link make symbolic links instead of copying\n+ * \n+ *  -S, --suffix=SUFFIX override the usual backup suffix\n+ * \n+ *  -u, --update copy only when the SOURCE file is newer than the destination file or when the destination file is missing\n+ * \n+ *  -v, --verbose explain what is being done\n+ * \n+ *  -V, --version-control=WORD override the usual version control\n+ * \n+ *  -x, --one-file-system stay on this file system\n+ * \n+ *  --help display this help and exit\n+ * \n+ *  --version output version information and exit\n+ * \n+ *  By default, sparse SOURCE files are detected by a crude heuristic and the corresponding DEST file is made sparse as well. That is the behavior selected by --sparse=auto. Specify --sparse=always to create a sparse DEST file when- ever the SOURCE file contains a long enough sequence of zero bytes. Use --sparse=never to inhibit creation of sparse files.\n+ * \n+ *  The backup suffix is ~, unless set with SIMPLE_BACKUP_SUF- FIX. The version control may be set with VERSION_CONTROL, values are:\n+ * t, numbered make numbered backups\n+ * \n+ *  nil, existing numbered if numbered backups exist, simple other- wise\n+ * \n+ *  never, simple always make simple backups\n+ * \n+ *  As a special case, cp makes a backup of SOURCE when the force and backup options are given and SOURCE and DEST are the same name for an existing, regular file. * </pre>\n+ * </pre>\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class CpTest extends TestCase {\n+\n+    /** Option Builder */\n+    private static final DefaultOptionBuilder oBuilder =\n+        new DefaultOptionBuilder();\n+\n+    /** Argument Builder */\n+    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+    /** Group Builder */\n+    private static final GroupBuilder gBuilder = new GroupBuilder();\n+\n+    private Group options;\n+\n+    public static Test suite() {\n+        return new TestSuite(CpTest.class);\n+    }\n+\n+    private ArgumentImpl source;\n+    private ArgumentImpl dest;\n+    private Argument targets;\n+\n+    private Option archive;\n+    private Option backup;\n+    private Option noDereference;\n+    private Option force;\n+    private Option interactive;\n+    private Option link;\n+    private Option preserve;\n+    private Option parents;\n+    private Option recursive1;\n+    private Option sparse;\n+    private Option recursive2;\n+    private Option symbolicLink;\n+    private Option suffix;\n+    private Option update;\n+    private Option verbose;\n+    private Option versionControl;\n+    private Option oneFileSystem;\n+    private Option help;\n+    private Option version;\n+\n+    public void setUp() {\n+        source =\n+            (ArgumentImpl)aBuilder.withName(\"SOURCE\").withMinimum(1).create();\n+        dest =\n+            (ArgumentImpl)aBuilder\n+                .withName(\"DEST\")\n+                .withMinimum(1)\n+                .withMaximum(1)\n+                .create();\n+        targets = new SourceDestArgument(source, dest);\n+\n+        archive =\n+            oBuilder\n+                .withShortName(\"a\")\n+                .withLongName(\"archive\")\n+                .withDescription(\"same as -dpR\")\n+                .create();\n+\n+        backup =\n+            oBuilder\n+                .withShortName(\"b\")\n+                .withLongName(\"backup\")\n+                .withDescription(\"make backup before removal\")\n+                .create();\n+\n+        noDereference =\n+            oBuilder\n+                .withShortName(\"d\")\n+                .withLongName(\"no-dereference\")\n+                .withDescription(\"preserve links\")\n+                .create();\n+\n+        force =\n+            oBuilder\n+                .withShortName(\"f\")\n+                .withLongName(\"force\")\n+                .withDescription(\"remove existing destinations, never prompt\")\n+                .create();\n+\n+        interactive =\n+            oBuilder\n+                .withShortName(\"i\")\n+                .withLongName(\"interactive\")\n+                .withDescription(\"prompt before overwrite\")\n+                .create();\n+\n+        link =\n+            oBuilder\n+                .withShortName(\"l\")\n+                .withLongName(\"link\")\n+                .withDescription(\"link files instead of copying\")\n+                .create();\n+\n+        preserve =\n+            oBuilder\n+                .withShortName(\"p\")\n+                .withLongName(\"preserve\")\n+                .withDescription(\"preserve file attributes if possible\")\n+                .create();\n+\n+        parents =\n+            oBuilder\n+                .withShortName(\"P\")\n+                .withLongName(\"parents\")\n+                .withDescription(\"append source path to DIRECTORY\")\n+                .create();\n+\n+        recursive1 =\n+            oBuilder\n+                .withShortName(\"r\")\n+                .withDescription(\"copy recursively, non-directories as files\")\n+                .create();\n+\n+        sparse =\n+            oBuilder\n+                .withLongName(\"sparse\")\n+                .withDescription(\"control creation of sparse files\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"WHEN\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .withInitialSeparator('=')\n+                        .create())\n+                .create();\n+\n+        recursive2 =\n+            oBuilder\n+                .withShortName(\"R\")\n+                .withLongName(\"recursive\")\n+                .withDescription(\"copy directories recursively\")\n+                .create();\n+\n+        symbolicLink =\n+            oBuilder\n+                .withShortName(\"s\")\n+                .withLongName(\"symbolic-link\")\n+                .withDescription(\"make symbolic links instead of copying\")\n+                .create();\n+\n+        suffix =\n+            oBuilder\n+                .withShortName(\"S\")\n+                .withLongName(\"suffix\")\n+                .withDescription(\"override the usual backup suffix\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"SUFFIX\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+\n+        update =\n+            oBuilder\n+                .withShortName(\"u\")\n+                .withLongName(\"update\")\n+                .withDescription(\"copy only when the SOURCE file is newer than the destination file or when the destination file is missing\")\n+                .create();\n+\n+        verbose =\n+            oBuilder\n+                .withShortName(\"v\")\n+                .withLongName(\"verbose\")\n+                .withDescription(\"explain what is being done\")\n+                .create();\n+\n+        versionControl =\n+            oBuilder\n+                .withShortName(\"V\")\n+                .withLongName(\"version-contol\")\n+                .withDescription(\"explain what is being done\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"WORD\")\n+                        .withInitialSeparator('=')\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+\n+        oneFileSystem =\n+            oBuilder\n+                .withShortName(\"x\")\n+                .withLongName(\"one-file-system\")\n+                .withDescription(\"stay on this file system\")\n+                .create();\n+\n+        help =\n+            oBuilder\n+                .withLongName(\"help\")\n+                .withDescription(\"display this help and exit\")\n+                .create();\n+\n+        version =\n+            oBuilder\n+                .withLongName(\"version\")\n+                .withDescription(\"output version information and exit\")\n+                .create();\n+\n+        options =\n+            gBuilder\n+                .withOption(archive)\n+                .withOption(backup)\n+                .withOption(noDereference)\n+                .withOption(force)\n+                .withOption(interactive)\n+                .withOption(link)\n+                .withOption(preserve)\n+                .withOption(parents)\n+                .withOption(recursive1)\n+                .withOption(sparse)\n+                .withOption(recursive2)\n+                .withOption(symbolicLink)\n+                .withOption(suffix)\n+                .withOption(update)\n+                .withOption(verbose)\n+                .withOption(versionControl)\n+                .withOption(oneFileSystem)\n+                .withOption(help)\n+                .withOption(version)\n+                .withOption(targets)\n+                .withName(\"OPTIONS\")\n+                .create();\n+    }\n+\n+    public void testNoSource() throws OptionException {\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        try {\n+            parser.parse(new String[0]);\n+        }\n+        catch (OptionException mve) {\n+            assertEquals(\n+                \"Missing value(s) SOURCE [SOURCE ...]\",\n+                mve.getMessage());\n+        }\n+    }\n+\n+    public void testOneSource() throws OptionException {\n+        final String[] args = new String[] { \"source1\", \"dest1\" };\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        final CommandLine commandLine = parser.parse(args);\n+\n+        assertTrue(commandLine.getValues(source).contains(\"source1\"));\n+        assertEquals(1, commandLine.getValues(source).size());\n+        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));\n+        assertEquals(1, commandLine.getValues(dest).size());\n+    }\n+\n+    public void testMultiSource() throws OptionException {\n+        final String[] args =\n+            new String[] { \"source1\", \"source2\", \"source3\", \"dest1\" };\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        final CommandLine commandLine = parser.parse(args);\n+\n+        assertTrue(commandLine.getValues(source).contains(\"source1\"));\n+        assertTrue(commandLine.getValues(source).contains(\"source2\"));\n+        assertTrue(commandLine.getValues(source).contains(\"source3\"));\n+        assertEquals(3, commandLine.getValues(source).size());\n+\n+        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));\n+        assertEquals(1, commandLine.getValues(dest).size());\n+    }\n+\n+    public void testHelp() throws IOException {\n+        final StringWriter out = new StringWriter();\n+        final HelpFormatter helpFormatter = new HelpFormatter();\n+        helpFormatter.setGroup(options);\n+        helpFormatter.setPrintWriter(new PrintWriter(out));\n+        helpFormatter.print();\n+\n+        final BufferedReader in =\n+            new BufferedReader(new StringReader(out.toString()));\n+        assertEquals(\n+            \"Usage:                                                                          \",\n+            in.readLine());\n+        assertEquals(\n+            \" [-a -b -d -f -i -l -p -P -r --sparse <WHEN> -R -s -S <SUFFIX> -u -v -V <WORD>  \",\n+            in.readLine());\n+        assertEquals(\n+            \"-x --help --version] <SOURCE1> [<SOURCE2> ...] <DEST>                           \",\n+            in.readLine());\n+        assertEquals(\n+            \"OPTIONS                                                                         \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -a (--archive)            same as -dpR                                        \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -b (--backup)             make backup before removal                          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -d (--no-dereference)     preserve links                                      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -f (--force)              remove existing destinations, never prompt          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -i (--interactive)        prompt before overwrite                             \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -l (--link)               link files instead of copying                       \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -p (--preserve)           preserve file attributes if possible                \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -P (--parents)            append source path to DIRECTORY                     \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -r                        copy recursively, non-directories as files          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --sparse                  control creation of sparse files                    \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -R (--recursive)          copy directories recursively                        \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -s (--symbolic-link)      make symbolic links instead of copying              \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -S (--suffix)             override the usual backup suffix                    \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -u (--update)             copy only when the SOURCE file is newer than the    \",\n+            in.readLine());\n+        assertEquals(\n+            \"                            destination file or when the destination file is    \",\n+            in.readLine());\n+        assertEquals(\n+            \"                            missing                                             \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -v (--verbose)            explain what is being done                          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -V (--version-contol)     explain what is being done                          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -x (--one-file-system)    stay on this file system                            \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --help                    display this help and exit                          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --version                 output version information and exit                 \",\n+            in.readLine());\n+        assertEquals(\n+            \"  SOURCE [SOURCE ...]                                                           \",\n+            in.readLine());\n+        assertEquals(\n+            \"  DEST                                                                          \",\n+            in.readLine());\n+        assertNull(in.readLine());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/application/CvsTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+\n+//TODO Build up CvsTest like CpTest\n+public class CvsTest extends TestCase {\n+    public void testCVS() {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final CommandBuilder cbuilder = new CommandBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Group commands =\n+            gbuilder\n+                .withName(\"commands\")\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"add\")\n+                        .withName(\"ad\")\n+                        .withName(\"new\")\n+                        .withDescription(\"Add a new file/directory to the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"admin\")\n+                        .withName(\"adm\")\n+                        .withName(\"rcs\")\n+                        .withDescription(\"Administration front end for rcs\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"annotate\")\n+                        .withName(\"ann\")\n+                        .withDescription(\"Show last revision where each line was modified\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"checkout\")\n+                        .withName(\"co\")\n+                        .withName(\"get\")\n+                        .withDescription(\"Checkout sources for editing\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"commit\")\n+                        .withName(\"ci\")\n+                        .withName(\"com\")\n+                        .withDescription(\"Check files into the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"diff\")\n+                        .withName(\"di\")\n+                        .withName(\"dif\")\n+                        .withDescription(\"Show differences between revisions\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"edit\")\n+                        .withDescription(\"Get ready to edit a watched file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"editors\")\n+                        .withDescription(\"See who is editing a watched file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"export\")\n+                        .withName(\"exp\")\n+                        .withName(\"ex\")\n+                        .withDescription(\"Export sources from CVS, similar to checkout\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"history\")\n+                        .withName(\"hi\")\n+                        .withName(\"his\")\n+                        .withDescription(\"Show repository access history\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"import\")\n+                        .withName(\"im\")\n+                        .withName(\"imp\")\n+                        .withDescription(\"Import sources into CVS, using vendor branches\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"init\")\n+                        .withDescription(\"Create a CVS repository if it doesn't exist\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"log\")\n+                        .withName(\"lo\")\n+                        .withName(\"rlog\")\n+                        .withDescription(\"Print out history information for files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"login\")\n+                        .withName(\"logon\")\n+                        .withName(\"lgn\")\n+                        .withDescription(\"Prompt for password for authenticating server\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"logout\")\n+                        .withDescription(\"Removes entry in .cvspass for remote repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"rdiff\")\n+                        .withName(\"patch\")\n+                        .withName(\"pa\")\n+                        .withDescription(\"Create 'patch' format diffs between releases\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"release\")\n+                        .withName(\"re\")\n+                        .withName(\"rel\")\n+                        .withDescription(\"Indicate that a Module is no longer in use\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"remove\")\n+                        .withName(\"rm\")\n+                        .withName(\"delete\")\n+                        .withDescription(\"Remove an entry from the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"rtag\")\n+                        .withName(\"rt\")\n+                        .withName(\"rfreeze\")\n+                        .withDescription(\"Add a symbolic tag to a module\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"status\")\n+                        .withName(\"st\")\n+                        .withName(\"stat\")\n+                        .withDescription(\"Display status information on checked out files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"tag\")\n+                        .withName(\"ta\")\n+                        .withName(\"freeze\")\n+                        .withDescription(\"Add a symbolic tag to checked out version of files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"unedit\")\n+                        .withDescription(\"Undo an edit command\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"update\")\n+                        .withName(\"up\")\n+                        .withName(\"upd\")\n+                        .withDescription(\"Bring work tree in sync with repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"watch\")\n+                        .withDescription(\"Set watches\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"watchers\")\n+                        .withDescription(\"See who is watching a file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"version\")\n+                        .withName(\"ve\")\n+                        .withName(\"ver\")\n+                        .withDescription(\"????\")\n+                        .create())\n+                .withOption(ArgumentTest.buildTargetsArgument())\n+                .create();\n+\n+        final Group cvsOptions =\n+            new GroupBuilder()\n+                .withName(\"cvs-options\")\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"H\")\n+                        .withDescription(\"Displays usage information for command.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"Q\")\n+                        .withDescription(\"Cause CVS to be really quiet.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"q\")\n+                        .withDescription(\"Cause CVS to be somewhat quiet.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"r\")\n+                        .withDescription(\"Make checked-out files read-only.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"w\")\n+                        .withDescription(\"Make checked-out files read-write (default).\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"l\")\n+                        .withDescription(\"Turn history logging off.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"n\")\n+                        .withDescription(\"Do not execute anything that will change the disk.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"t\")\n+                        .withDescription(\"Show trace of program execution -- try with -n.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"v\")\n+                        .withDescription(\"CVS version and copyright.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withLongName(\"crlf\")\n+                        .withDescription(\"Use the Dos line feed for text files (default).\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withLongName(\"lf\")\n+                        .withDescription(\"Use the Unix line feed for text files.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"T\")\n+                        .withDescription(\"Use 'tmpdir' for temporary files.\")\n+                        .withArgument(abuilder.withName(\"tmpdir\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"e\")\n+                        .withDescription(\"Use 'editor' for editing log information.\")\n+                        .withArgument(abuilder.withName(\"editor\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"d\")\n+                        .withDescription(\"Overrides $CVSROOT as the root of the CVS tree.\")\n+                        .withArgument(abuilder.withName(\"CVS_root\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"f\")\n+                        .withDescription(\"Do not use the ~/.cvsrc file.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"z\")\n+                        .withDescription(\"Use compression level '#' for net traffic.\")\n+                        .withArgument(abuilder.withName(\"#\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"a\")\n+                        .withDescription(\"Authenticate all net traffic.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"s\")\n+                        .withDescription(\"Set CVS user variable.\")\n+                        .withArgument(abuilder.withName(\"VAR=VAL\").create())\n+                        .create())\n+                .withOption(commands)\n+                .create();\n+\n+        assertNotNull(cvsOptions);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/application/LsTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.validation.EnumValidator;\n+\n+/**\n+ * <p>Test the <code>ls</code> command. Duplicated Option types are not\n+ * tested e.g. -a and -d are the same Option type.</p>\n+ * \n+ * <p>The following is the man output for 'ls'. See\n+ * http://www.rt.com/man/ls.1.html.</p>\n+ * \n+ * <pre>\n+ *  LS(1) FSF LS(1)\n+ * \n+ *  NAME ls - list directory contents\n+ * \n+ *  SYNOPSIS ls [OPTION]... [FILE]...\n+ * \n+ *  DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuSUX nor --sort.\n+ * \n+ *  -a, --all do not hide entries starting with .\n+ * \n+ *  -A, --almost-all do not list implied . and ..\n+ * \n+ *  -b, --escape print octal escapes for nongraphic characters\n+ * \n+ *  --block-size=SIZE use SIZE-byte blocks\n+ * \n+ *  -B, --ignore-backups do not list implied entries ending with ~ -c sort by change time; with -l: show ctime -C list entries by columns\n+ * \n+ *  --color[=WHEN] control whether color is used to distinguish file types. WHEN may be `never', `always', or `auto'\n+ * \n+ *  -d, --directory list directory entries instead of contents\n+ * \n+ *  -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -lst\n+ * \n+ *  -F, --classify append indicator (one of /=@|*) to entries\n+ * \n+ *  --format=WORD across -x, commas -m, horizontal -x, long -l, sin- gle-column -1, verbose -l, vertical -C\n+ * \n+ *  --full-time list both full date and full time -g (ignored)\n+ * \n+ *  -G, --no-group inhibit display of group information\n+ * \n+ *  -h, --human-readable print sizes in human readable format (e.g., 1K 234M 2G)\n+ * \n+ *  -H, --si likewise, but use powers of 1000 not 1024\n+ * \n+ *  --indicator-style=WORD append indicator with style WORD to entry names: none (default), classify (-F), file-type (-p)\n+ * \n+ *  -i, --inode print index number of each file\n+ * \n+ *  -I, --ignore=PATTERN do not list implied entries matching shell PATTERN\n+ * \n+ *  -k, --kilobytes like --block-size=1024 -l use a long listing format\n+ * \n+ *  -L, --dereference list entries pointed to by symbolic links -m fill width with a comma separated list of entries\n+ * \n+ *  -n, --numeric-uid-gid list numeric UIDs and GIDs instead of names\n+ * \n+ *  -N, --literal print raw entry names (don't treat e.g. control characters specially) -o use long listing format without group info\n+ * \n+ *  -p, --file-type append indicator (one of /=@|) to entries\n+ * \n+ *  -q, --hide-control-chars print ? instead of non graphic characters\n+ * \n+ *  --show-control-chars show non graphic characters as-is (default)\n+ * \n+ *  -Q, --quote-name enclose entry names in double quotes\n+ * \n+ *  --quoting-style=WORD use quoting style WORD for entry names: literal, shell, shell-always, c, escape\n+ * \n+ *  -r, --reverse reverse order while sorting\n+ * \n+ *  -R, --recursive list subdirectories recursively\n+ * \n+ *  -s, --size print size of each file, in blocks -S sort by file size\n+ * \n+ *  --sort=WORD extension -X, none -U, size -S, time -t, version -v status -c, time -t, atime -u, access -u, use -u\n+ * \n+ *  --time=WORD show time as WORD instead of modification time: atime, access, use, ctime or status; use specified time as sort key if --sort=time -t sort by modification time\n+ * \n+ *  -T, --tabsize=COLS assume tab stops at each COLS instead of 8 -u sort by last access time; with -l: show atime -U do not sort; list entries in directory order -v sort by version\n+ * \n+ *  -w, --width=COLS assume screen width instead of current value -x list entries by lines instead of by columns -X sort alphabetically by entry extension -1 list one file per line\n+ * \n+ *  --help display this help and exit\n+ * \n+ *  --version output version information and exit\n+ * \n+ *  By default, color is not used to distinguish types of files. That is equivalent to using --color=none. Using the --color option without the optional WHEN argument is equivalent to using --color=always. With --color=auto, color codes are output only if standard output is con- nected to a terminal (tty).\n+ * </pre>\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class LsTest extends TestCase {\n+\n+    /** Option Builder */\n+    private static final DefaultOptionBuilder oBuilder =\n+        new DefaultOptionBuilder();\n+\n+    /** Argument Builder */\n+    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+    /** Group Builder */\n+    private static final GroupBuilder gBuilder = new GroupBuilder();\n+\n+    private static Group options;\n+\n+    public static Test suite() {\n+        return new TestSuite(LsTest.class);\n+    }\n+\n+    /**\n+     * Required ctor.\n+     * \n+     * @param name\n+     *            the name of the TestCase\n+     */\n+    public LsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        if (LsTest.options == null) {\n+            final Option a =\n+                oBuilder\n+                    .withShortName(\"a\")\n+                    .withLongName(\"all\")\n+                    .withDescription(\"do not hide entries starting with .\")\n+                    .create();\n+\n+            final Option blockSize =\n+                oBuilder\n+                    .withLongName(\"block-size\")\n+                    .withRequired(false)\n+                    .withDescription(\"use SIZE-byte blocks\")\n+                    .withArgument(\n+                        aBuilder\n+                            .withMaximum(1)\n+                            .withMinimum(1)\n+                            .withInitialSeparator('=')\n+                            .create())\n+                    .create();\n+\n+            final Option c =\n+                oBuilder\n+                    .withShortName(\"c\")\n+                    .withRequired(false)\n+                    .withDescription(\"with -lt: sort by, and show, ctime (time of last modification of file status information) with -l:show ctime and sort by name otherwise: sort by ctime\")\n+                    .create();\n+\n+            final Set colors = new HashSet();\n+            colors.add(\"never\");\n+            colors.add(\"always\");\n+            colors.add(\"auto\");\n+            final Option color =\n+                oBuilder\n+                    .withLongName(\"color\")\n+                    .withRequired(false)\n+                    .withDescription(\"control  whether  color is used to distinguish file types.  WHEN may be `never', `always', or `auto'\")\n+                    .withArgument(\n+                        aBuilder\n+                            .withMaximum(1)\n+                            .withMinimum(1)\n+                            .withInitialSeparator('=')\n+                            .withValidator(new EnumValidator(colors))\n+                            .create())\n+                    .create();\n+\n+            LsTest.options =\n+                gBuilder\n+                    .withOption(a)\n+                    .withOption(blockSize)\n+                    .withOption(c)\n+                    .withOption(color)\n+                    .create();\n+        }\n+    }\n+\n+    public void testLs() throws OptionException {\n+        // create the command line parser\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line =\n+            parser.parse(new String[] { \"--block-size=10\", \"--color=never\" });\n+\n+        assertTrue(line.hasOption(\"--block-size\"));\n+        assertEquals(line.getValue(\"--block-size\"), \"10\");\n+        assertFalse(line.hasOption(\"--ignore-backups\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug13886Test.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug13886Test extends TestCase {\n+\n+    public Bug13886Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testMandatoryGroup() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option a = obuilder.withShortName(\"a\").create();\n+\n+        final Option b = obuilder.withShortName(\"b\").create();\n+\n+        final Group options =\n+            gbuilder\n+                .withOption(a)\n+                .withOption(b)\n+                .withMaximum(1)\n+                .withMinimum(1)\n+                .create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        try {\n+            parser.parse(new String[] {\n+            });\n+            fail(\"Expected MissingOptionException not caught\");\n+        }\n+        catch (final OptionException exp) {\n+            assertEquals(\"Missing option -a|-b\", exp.getMessage());\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-a\" });\n+        }\n+        catch (final OptionException exp) {\n+            fail(\"Unexpected MissingOptionException caught\");\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-b\" });\n+        }\n+        catch (final OptionException exp) {\n+            fail(\"Unexpected MissingOptionException caught\");\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-a\", \"-b\" });\n+            fail(\"Expected UnexpectedOptionException not caught\");\n+        }\n+        catch (final OptionException exp) {\n+            assertEquals(\n+                \"Unexpected -b while processing -a|-b\",\n+                exp.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug13935Test.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug13935Test extends TestCase {\n+\n+    public Bug13935Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testRequiredGroup() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option testOption =\n+            obuilder\n+                .withShortName(\"a\")\n+                .withArgument(abuilder.withName(\"quoted string\").create())\n+                .create();\n+\n+        final Group options = gbuilder.withOption(testOption).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        final CommandLine cmdLine =\n+            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });\n+\n+        assertTrue(cmdLine.hasOption(\"-a\"));\n+        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug15046Test.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug15046Test extends TestCase {\n+\n+    public Bug15046Test(String name) {\n+        super(name);\n+    }\n+\n+    public void testParamNamedAsOption() throws Exception {\n+        final String[] CLI_ARGS = new String[] { \"-z\", \"c\" };\n+\n+        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+\n+        Option option =\n+            obuilder\n+                .withShortName(\"z\")\n+                .withLongName(\"timezone\")\n+                .withDescription(\"affected option\")\n+                .withArgument(abuilder.withName(\"timezone\").create())\n+                .create();\n+\n+        GroupBuilder gbuilder = new GroupBuilder();\n+        Group options =\n+            gbuilder.withName(\"bug15046\").withOption(option).create();\n+\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line = parser.parse(CLI_ARGS);\n+\n+        assertEquals(\"c\", line.getValue(\"-z\"));\n+\n+        Option c =\n+            obuilder\n+                .withShortName(\"c\")\n+                .withLongName(\"conflict\")\n+                .withDescription(\"conflicting option\")\n+                .withArgument(abuilder.withName(\"conflict\").create())\n+                .create();\n+\n+        options =\n+            gbuilder\n+                .withName(\"bug15046\")\n+                .withOption(option)\n+                .withOption(c)\n+                .create();\n+\n+        parser.setGroup(options);\n+        line = parser.parse(CLI_ARGS);\n+\n+        assertEquals(\"c\", line.getValue(\"-z\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug15648Test.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug15648Test extends TestCase {\n+\n+    public Bug15648Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testQuotedArgumentValue() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option testOption =\n+            obuilder\n+                .withShortName(\"a\")\n+                .withArgument(abuilder.withName(\"quoted string\").create())\n+                .create();\n+\n+        final Group options = gbuilder.withOption(testOption).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        final CommandLine cmdLine =\n+            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });\n+\n+        assertTrue(cmdLine.hasOption(\"-a\"));\n+        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug27575Test.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import java.util.Iterator;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.PatternBuilder;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+public class Bug27575Test extends TestCase {\n+\n+\tpublic void testRequiredOptions(){\n+\t\tPatternBuilder builder = new PatternBuilder();\n+\t\tbuilder.withPattern(\"hc!<\");\n+\t\tOption option = builder.create();\n+\t\tassertTrue(option instanceof GroupImpl);\n+\t\t\n+\t\tGroupImpl group = (GroupImpl)option;\n+\t\tIterator i = group.getOptions().iterator();\n+\t\tassertEquals(\"[-h]\",i.next().toString());\n+\t\tassertEquals(\"-c <arg>\",i.next().toString());\n+\t\tassertFalse(i.hasNext());\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/bug/Bug28005Test.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.Command;\n+import junit.framework.TestCase;\n+\n+public class Bug28005Test extends TestCase {\n+    public void testInfiniteLoop() {\n+        final DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder argumentBuilder = new ArgumentBuilder();\n+        final GroupBuilder groupBuilder = new GroupBuilder();\n+        final CommandBuilder commandBuilder = new CommandBuilder();\n+        \n+        final Option inputFormatOption = \n+            optionBuilder\n+                .withLongName(\"input-format\")\n+                //.withArgument(argumentBuilder.create())\n+                .create();\n+                \n+        final Argument argument = \n+            argumentBuilder\n+                .withName(\"file\")\n+                .create();\n+                \n+        final Group children = \n+            groupBuilder\n+                .withName(\"options\")\n+                .withOption(inputFormatOption)\n+                .create();\n+                \n+        final Option command = \n+            commandBuilder\n+                .withName(\"convert\")\n+                .withChildren(children)\n+                .withArgument(argument)\n+                .create();\n+                \n+        final Group root = \n+            groupBuilder\n+                .withName(\"commands\")\n+                .withOption(command)\n+                .create();\n+                \n+        final Parser parser = new Parser();\n+        parser.setGroup(root);\n+        final String[] args = new String[]{\"convert\", \"test.txt\",\n+                \"--input-format\", \"a\"};\n+                \n+        try {\n+            parser.parse(args);\n+            fail(\"a isn't valid!!\");\n+        } catch (OptionException e) {\n+            assertEquals(\"Unexpected a while processing commands\",e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/builder/DefaultOptionBuilderTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.DefaultOption;\n+\n+\n+public class DefaultOptionBuilderTest extends TestCase {\n+\n+    private DefaultOptionBuilder defaultOptionBuilder;\n+    \n+    /*\n+     * @see TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        this.defaultOptionBuilder = new DefaultOptionBuilder();\n+    }\n+\n+    /*\n+     * Class to test for void DefaultOptionBuilder(String, String, boolean)\n+     */\n+    public void testCtor() {\n+        {\n+            try {\n+                DefaultOptionBuilder builder = new DefaultOptionBuilder(null, null,\n+                        false);\n+                fail(\"null short prefix is not permitted\");\n+            }\n+            catch(IllegalArgumentException exp) {\n+            }\n+        }\n+\n+        {\n+            try {\n+                DefaultOptionBuilder builder = new DefaultOptionBuilder(\"\", null,\n+                        false);\n+                fail(\"empty short prefix is not permitted\");\n+            }\n+            catch(IllegalArgumentException exp) {\n+            }\n+        }\n+        \n+        {\n+            try {\n+                DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", null,\n+                        false);\n+                fail(\"null long prefix is not permitted\");\n+            }\n+            catch(IllegalArgumentException exp) {\n+            }\n+        }\n+\n+        {\n+            try {\n+                DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"\",\n+                        false);\n+                fail(\"empty long prefix is not permitted\");\n+            }\n+            catch(IllegalArgumentException exp) {\n+            }\n+        }\n+    }\n+\n+    public void testCreate() {\n+        try {\n+            this.defaultOptionBuilder.create();\n+            fail(\"options must have a name\");\n+        }\n+        catch (IllegalStateException exp) {\n+        }\n+        \n+        {\n+            this.defaultOptionBuilder.withShortName(\"j\");\n+            this.defaultOptionBuilder.create();\n+        }\n+        \n+        {\n+            this.defaultOptionBuilder.withLongName(\"jkeyes\");\n+            this.defaultOptionBuilder.create();\n+        }\n+\n+        {\n+            DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"--\",\n+                    true);\n+            builder.withShortName(\"mx\");\n+        }\n+        \n+        {\n+        }\n+    }\n+\n+    public void testName() {\n+        // withLongName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+        }\n+\n+        // withShortName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+        }\n+\n+        // withShortName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+        }\n+\n+    }\n+\n+    public void testWithDescription() {\n+        String description = \"desc\";\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withDescription(description);\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+        assertEquals(\"wrong description found\", description, \n+                opt.getDescription());\n+    }\n+\n+    public void testWithRequired() {\n+        {\n+            boolean required = false;\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withRequired(required);\n+            DefaultOption opt = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong required found\", required, \n+                    opt.isRequired());\n+        }\n+\n+        {\n+            boolean required = true;\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withRequired(required);\n+            DefaultOption opt = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong required found\", required, \n+                    opt.isRequired());\n+        }\n+}\n+\n+    public void testWithChildren() {\n+        GroupBuilder gbuilder = new GroupBuilder();\n+        \n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withRequired(true);\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        Group group = \n+            gbuilder.withName(\"withchildren\")\n+                .withOption(opt)\n+                .create();\n+        {\n+            this.defaultOptionBuilder.withShortName(\"b\");\n+            this.defaultOptionBuilder.withChildren(group);\n+            DefaultOption option = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong children found\", group, option.getChildren());\n+        }\n+    }\n+\n+    public void testWithArgument() {\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+        abuilder.withName(\"myarg\");\n+        Argument arg = abuilder.create();\n+        \n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withRequired(true);\n+        this.defaultOptionBuilder.withArgument(arg);\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        assertEquals(\"wrong argument found\", arg, opt.getArgument());\n+    }\n+\n+    public void testWithId() {\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withId(0);\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        assertEquals(\"wrong id found\", 0, opt.getId());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window - Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class DefaultingCommandLineTest extends CommandLineTestCase {\n+\t\n+\tprivate DefaultingCommandLine defaults;\n+\t\n+\tprivate CommandLine first;\n+\tprivate CommandLine second;\n+\t\n+\tprivate Option inFirst = new DefaultOptionBuilder().withLongName(\"infirst\").create(); \n+\tprivate Option inBoth = new DefaultOptionBuilder().withLongName(\"inboth\").create(); \n+\tprivate Option inSecond = new DefaultOptionBuilder().withLongName(\"insecond\").create(); \n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected final CommandLine createCommandLine() {\n+\t\tfinal WriteableCommandLine writeable = new WriteableCommandLineImpl(root,new ArrayList());\n+\t\twriteable.addOption(present);\n+\t\twriteable.addProperty(\"present\",\"present property\");\n+\t\twriteable.addSwitch(bool,true);\n+\t\twriteable.addValue(present,\"present value\");\n+\t\twriteable.addOption(multiple);\n+\t\twriteable.addValue(multiple,\"value 1\");\n+\t\twriteable.addValue(multiple,\"value 2\");\n+\t\twriteable.addValue(multiple,\"value 3\");\n+\t\t\n+\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n+\t\tdefaults.appendCommandLine(writeable);\n+\t\treturn defaults;\n+\t}\n+\t\n+\tpublic void setUp() throws Exception{\n+\t\tsuper.setUp();\n+\t\t\n+\t\tWriteableCommandLine writeable;\n+\t\t\n+\t\twriteable = new WriteableCommandLineImpl(root,new ArrayList());\n+\t\twriteable.addOption(inFirst);\n+\t\twriteable.addOption(inBoth);\n+\t\twriteable.addProperty(\"infirst\",\"infirst first value\");\n+\t\twriteable.addProperty(\"inboth\",\"inboth first value\");\n+\t\twriteable.addSwitch(inFirst,true);\n+\t\twriteable.addSwitch(inBoth,true);\n+\t\twriteable.addValue(inFirst,\"infirst first value 1\");\n+\t\twriteable.addValue(inFirst,\"infirst first value 2\");\n+\t\twriteable.addValue(inBoth,\"inboth first value 1\");\n+\t\twriteable.addValue(inBoth,\"inboth first value 2\");\n+\t\tfirst = writeable;\n+\t\t\n+\t\twriteable = new WriteableCommandLineImpl(root,new ArrayList());\n+\t\twriteable.addOption(inSecond);\n+\t\twriteable.addOption(inBoth);\n+\t\twriteable.addProperty(\"insecond\",\"insecond second value\");\n+\t\twriteable.addProperty(\"inboth\",\"inboth second value\");\n+\t\twriteable.addSwitch(inSecond,true);\n+\t\twriteable.addSwitch(inBoth,true);\n+\t\twriteable.addValue(inSecond,\"insecond second value 1\");\n+\t\twriteable.addValue(inSecond,\"insecond second value 2\");\n+\t\twriteable.addValue(inBoth,\"inboth second value 1\");\n+\t\twriteable.addValue(inBoth,\"inboth second value 2\");\n+\t\tsecond = writeable;\n+\t}\n+\t\n+\tpublic final void testAppendCommandLine() {\n+\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n+\t\tIterator i;\n+\t\t\n+\t\ti = defaults.commandLines();\n+\t\tassertFalse(i.hasNext());\n+\t\t\n+\t\tdefaults.appendCommandLine(first);\n+\t\ti = defaults.commandLines();\n+\t\tassertSame(first,i.next());\n+\t\tassertFalse(i.hasNext());\n+\t\t\n+\t\tdefaults.appendCommandLine(second);\n+\t\ti = defaults.commandLines();\n+\t\tassertSame(first,i.next());\n+\t\tassertSame(second,i.next());\n+\t\tassertFalse(i.hasNext());\n+\t}\n+\t\n+\tpublic final void testInsertCommandLine() {\n+\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n+\t\tIterator i;\n+\t\t\n+\t\ti = defaults.commandLines();\n+\t\tassertFalse(i.hasNext());\n+\t\t\n+\t\tdefaults.insertCommandLine(0,first);\n+\t\ti = defaults.commandLines();\n+\t\tassertSame(first,i.next());\n+\t\tassertFalse(i.hasNext());\n+\t\t\n+\t\tdefaults.insertCommandLine(0,second);\n+\t\ti = defaults.commandLines();\n+\t\tassertSame(second,i.next());\n+\t\tassertSame(first,i.next());\n+\t\tassertFalse(i.hasNext());\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.prefs.Preferences;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window - Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class PreferencesCommandLineTest extends CommandLineTestCase {\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected CommandLine createCommandLine() {\n+\t\t// TODO Auto-generated method stub\n+\t\tfinal Preferences props = Preferences.userNodeForPackage(PreferencesCommandLineTest.class);\n+\t\tprops.put(\"--present\",\"present value\");\n+\t\tprops.put(\"--alsopresent\",\"\");\n+\t\tprops.put(\"--multiple\",\"value 1|value 2|value 3\");\n+\t\tprops.put(\"--bool\",\"true\");\n+\t\t\n+\t\tprops.put(\"present\",\"present property\");\n+\t\t\n+\t\treturn new PreferencesCommandLine(root,props,'|');\n+\t}\n+\t\n+\tpublic void testToMakeEclipseSpotTheTestCase(){\n+\t\t// nothing to test\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.Properties;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window - Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class PropertiesCommandLineTest extends CommandLineTestCase {\n+\t\n+\tprivate Properties props = null;\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected CommandLine createCommandLine() {\n+\t\t// TODO Auto-generated method stub\n+\t\tprops = new Properties();\n+\t\tprops.setProperty(\"--present\",\"present value\");\n+\t\tprops.setProperty(\"--alsopresent\",\"\");\n+\t\tprops.setProperty(\"--multiple\",\"value 1|value 2|value 3\");\n+\t\tprops.setProperty(\"--bool\",\"true\");\n+\t\t\n+\t\tprops.setProperty(\"present\",\"present property\");\n+\t\treturn new PropertiesCommandLine(root,props,'|');\n+\t}\n+\t\n+\tpublic void testToMakeEclipseSpotTheTestCase(){\n+\t\t// nothing to test\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.WriteableCommandLineTestCase;\n+\n+public class WriteableCommandLineImplTest extends WriteableCommandLineTestCase {\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.WriteableCommandLineTest#createWriteableCommandLine()\n+\t */\n+\tprotected WriteableCommandLine createWriteableCommandLine() {\n+\t\treturn new WriteableCommandLineImpl(root,new ArrayList());\n+\t}\n+\t\n+\tpublic void testToMakeEclipseSpotTheTestCase(){\n+\t\t// nothing to test\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/jdepend/JDependTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.jdepend;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import jdepend.framework.JDepend;\n+import jdepend.framework.JavaPackage;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ * \n+ * To change the template for this generated type comment go to Window -\n+ * Preferences - Java - Code Generation - Code and Comments\n+ */\n+public class JDependTest extends TestCase {\n+\n+    private JDepend dependancies = null;\n+\n+    public void setUp() throws IOException {\n+        dependancies = new JDepend();\n+        dependancies.addDirectory(\"target/classes\");\n+        dependancies.analyze();\n+    }\n+\n+    public void testJUnitNotPresent() {\n+        // if junit dependancy is found then jdepend has been poluted\n+        // with test classes and all tests are meaningless\n+        assertNull(\n+            \"JUnit dependancy found\",\n+            dependancies.getPackage(\"junit.framework\"));\n+\n+        // the same applies to jdepend\n+        assertNull(\n+            \"JDepend dependancy found\",\n+            dependancies.getPackage(\"jdepend.framework\"));\n+    }\n+\n+    public void testAcceptableDistance() {\n+        Collection packages = dependancies.getPackages();\n+        // only interested in cli2\n+        packages = cli2Packages(packages);\n+        // resources is well off the line\n+        packages =\n+            namedPackages(packages, \"org.apache.commons.cli2.resource\", false);\n+\n+        for (final Iterator i = packages.iterator(); i.hasNext();) {\n+            final JavaPackage pkg = (JavaPackage)i.next();\n+            final float distance = pkg.distance();\n+            final String message = pkg.getName() + \" too far from line: \" + distance;\n+            assertTrue(\n+                message,\n+                distance < 0.21d);\n+        }\n+    }\n+\n+    public void testNoCyclesPresnet() {\n+        assertEquals(\"Cycles exist\", false, dependancies.containsCycles());\n+    }\n+\n+    public void testApiIndependance() {\n+        dependancies.analyze();\n+\n+        final JavaPackage apiPackage =\n+            dependancies.getPackage(\"org.apache.commons.cli2\");\n+        final Collection dependsUpon = cli2Packages(apiPackage.getEfferents());\n+\n+        assertEquals(\"Api should depend on one package\", 1, dependsUpon.size());\n+        \n+        JavaPackage pkg = (JavaPackage) dependsUpon.iterator().next();\n+        assertEquals(\n+                \"Wrong package name\", \n+                \"org.apache.commons.cli2.resource\",\n+                pkg.getName());\n+    }\n+\n+    private Collection cli2Packages(final Collection incoming) {\n+        return namedPackages(incoming, \"org.apache.commons.cli2\", true);\n+    }\n+\n+    private Collection namedPackages(\n+        final Collection incoming,\n+        final String name,\n+        final boolean include) {\n+        final Collection outgoing = new ArrayList();\n+        for (final Iterator i = incoming.iterator(); i.hasNext();) {\n+            final JavaPackage pkg = (JavaPackage)i.next();\n+            if (include ^ !pkg.getName().startsWith(name)) {\n+                outgoing.add(pkg);\n+            }\n+        }\n+        return outgoing;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/ArgumentTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.DateValidator;\n+import org.apache.commons.cli2.validation.DateValidatorTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ArgumentTest extends ArgumentTestCase {\n+\n+    private ResourceHelper resources = ResourceHelper.getResourceHelper(ArgumentTest.class);\n+    \n+    public static Argument buildUsernameArgument() {\n+        return new ArgumentImpl(\n+            \"username\",\n+            \"The user to connect as\",\n+            1,\n+            1,\n+            '\\0',\n+            '\\0',\n+            null,\n+            ArgumentImpl.DEFAULT_CONSUME_REMAINING,\n+            null,\n+            0);\n+    }\n+\n+    public static Argument buildHostArgument() {\n+        return new ArgumentImpl(\n+            \"host\",\n+            \"The host name\",\n+            2,\n+            3,\n+            '\\0',\n+            ',',\n+            null,\n+            null,\n+            null,\n+            0);\n+    }\n+\n+    public static Argument buildPathArgument() {\n+        return new ArgumentImpl(\n+            \"path\",\n+            \"The place to look for files\",\n+            1,\n+            Integer.MAX_VALUE,\n+            '=',\n+            ';',\n+            null,\n+            ArgumentImpl.DEFAULT_CONSUME_REMAINING,\n+            null,\n+            0);\n+    }\n+\n+    public static Argument buildDateLimitArgument() {\n+        return new ArgumentImpl(\n+            \"limit\",\n+            \"the last acceptable date\",\n+            0,\n+            1,\n+            '=',\n+            '\\0',\n+            new DateValidator(DateValidatorTest.YYYY_MM_YY),\n+            null,\n+            null,\n+            0);\n+    }\n+\n+    public static Argument buildTargetsArgument() {\n+        return new ArgumentImpl(\n+            \"target\",\n+            \"The targets ant should build\",\n+            0,\n+            Integer.MAX_VALUE,\n+            '\\0',\n+            ',',\n+            null,\n+            null,\n+            null,\n+            0);\n+    }\n+    \n+    public static Argument buildSizeArgument() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"10\");\n+\n+        return new ArgumentImpl(\n+            \"size\",\n+            \"The number of units\",\n+            1,\n+            1,\n+            '\\0',\n+            '\\0',\n+            null,\n+            ArgumentImpl.DEFAULT_CONSUME_REMAINING,\n+            defaults,\n+            0);\n+    }\n+\n+    public static Argument buildBoundsArgument() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"5\");\n+        defaults.add(\"10\");\n+\n+        return new ArgumentImpl(\n+            \"size\",\n+            \"The number of units\",\n+            2,\n+            2,\n+            '\\0',\n+            '\\0',\n+            null,\n+            ArgumentImpl.DEFAULT_CONSUME_REMAINING,\n+            defaults,\n+            0);\n+    }\n+\n+    public void testNew() {\n+        {\n+            try {\n+                new ArgumentImpl(\n+                        \"limit\",\n+                        \"the last acceptable date\",\n+                        10,\n+                        5,\n+                        '=',\n+                        '\\0',\n+                        new DateValidator(DateValidatorTest.YYYY_MM_YY),\n+                        null,\n+                        null,\n+                        0);\n+            } catch (IllegalArgumentException e) {\n+                assertEquals(\n+                        resources.getMessage(\"cli.error.minimum.exceeds.maximum\"),\n+                        e.getMessage());\n+            }\n+        }\n+        {\n+            ArgumentImpl arg = new ArgumentImpl(\n+                    null,\n+                    \"the last acceptable date\",\n+                    5,\n+                    5,\n+                    '=',\n+                    '\\0',\n+                    new DateValidator(DateValidatorTest.YYYY_MM_YY),\n+                    null,\n+                    null,\n+                    0);\n+            assertEquals(\"wrong arg name\", \"arg\", arg.getPreferredName());\n+        }\n+\n+        {\n+            List defaults = new ArrayList();\n+            \n+            try {\n+                ArgumentImpl arg = new ArgumentImpl(\n+                    null,\n+                    \"the last acceptable date\",\n+                    1,\n+                    1,\n+                    '=',\n+                    '\\0',\n+                    new DateValidator(DateValidatorTest.YYYY_MM_YY),\n+                    null,\n+                    defaults,\n+                    0);\n+            }\n+            catch(IllegalArgumentException exp) {\n+                assertEquals(\n+                        resources.getMessage(\"cli.error.too.few.defaults\"),\n+                        exp.getMessage());\n+            }\n+        }\n+\n+        {\n+            try {\n+                List defaults = new ArrayList();\n+                defaults.add(\"1\");\n+                defaults.add(\"2\");\n+            \n+                ArgumentImpl arg = new ArgumentImpl(\n+                    null,\n+                    \"the last acceptable date\",\n+                    1,\n+                    1,\n+                    '=',\n+                    '\\0',\n+                    new DateValidator(DateValidatorTest.YYYY_MM_YY),\n+                    null,\n+                    defaults,\n+                    0);\n+            }\n+            catch(IllegalArgumentException exp) {\n+                assertEquals(\n+                    resources.getMessage(\"cli.error.too.many.defaults\"),\n+                    exp.getMessage());\n+            }\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.ArgumentTestCase#testProcessValues()\n+     */\n+    public void testProcessValues() throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final List args = list(\"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"username\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    public void testProcessValues_SpareValues() throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final List args = list(\"rob\", \"secret\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertTrue(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"username\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    public void testProcessValues_Optional() throws OptionException {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.processValues(commandLine, iterator, option);\n+        }\n+        catch (final OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+            assertEquals(\n+                \"Missing value(s) target [target ...]\",\n+                mve.getMessage());\n+        }\n+\n+        assertFalse(iterator.hasNext());\n+        assertFalse(commandLine.hasOption(option));\n+        assertFalse(commandLine.hasOption(\"username\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessValues_Multiple() throws OptionException {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list(\"compile\", \"test\", \"docs\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertFalse(commandLine.getValues(option).isEmpty());\n+        assertListContentsEqual(args, commandLine.getValues(option));\n+    }\n+\n+    public void testProcessValues_Contracted() throws OptionException {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list(\"compile,test,javadoc\", \"checkstyle,jdepend\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertListContentsEqual(\n+            list(\"compile\", \"test\", \"javadoc\", \"checkstyle\", \"jdepend\"),\n+            commandLine.getValues(option));\n+    }\n+\n+    public void testProcessValues_ContractedTooFew() throws OptionException {\n+        final Argument option = buildHostArgument();\n+        final List args = list(\"box1\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        try {\n+            option.processValues(commandLine, iterator, option);\n+            fail(\"Expected MissingValueException\");\n+        }\n+        catch (OptionException mve) {\n+            assertSame(option, mve.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.canProcess(\"any value\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.getPrefixes().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() throws OptionException {\n+        final Argument option = buildPathArgument();\n+        final List args = list(\"-path=/lib;/usr/lib;/usr/local/lib\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"path\"));\n+        assertListContentsEqual(\n+            list(\"-path=/lib\", \"/usr/lib\", \"/usr/local/lib\"),\n+            commandLine.getValues(option));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.getTriggers().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"rob\");\n+\n+        option.validate(commandLine);\n+    }\n+\n+    public void testValidate_Minimum() throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"UnexpectedValue\");\n+        }\n+        catch (OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+        }\n+    }\n+\n+    public void testValidate_Maximum() throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"rob\");\n+        commandLine.addValue(option, \"oxspring\");\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"UnexpectedValue\");\n+        }\n+        catch (OptionException uve) {\n+            assertEquals(option, uve.getOption());\n+        }\n+    }\n+\n+    public void testValidate_Validator()\n+        throws OptionException, ParseException {\n+        final Argument option = buildDateLimitArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"2004-01-01\");\n+\n+        option.validate(commandLine, option);\n+        assertContentsEqual(\n+            Arrays.asList(\n+                new Object[] {\n+                     DateValidatorTest.YYYY_MM_YY.parse(\"2004-01-01\")}),\n+            commandLine.getValues(option));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildUsernameArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"<username>\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Infinite() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[<target1> [<target2> ...]]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_InfiniteNoOptional() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"<target1> [<target2> ...]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_InfiniteNoNumbering() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[<target> [<target> ...]]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Minimum() {\n+        final Option option = buildHostArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"<host1> <host2> [<host3>]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildPathArgument();\n+        assertEquals(\"path\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildHostArgument();\n+        assertEquals(\"The host name\", option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = buildHostArgument();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine)i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testCanProcess_ConsumeRemaining() {\n+        final Option option = buildUsernameArgument();\n+\n+        assertTrue(option.canProcess(\"--\"));\n+    }\n+\n+    public void testProcess_ConsumeRemaining() throws OptionException {\n+        final Option option = buildPathArgument();\n+        final List args = list(\"options\", \"--\", \"--ignored\", \"-Dprop=val\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+        final List values = commandLine.getValues(option);\n+        assertTrue(values.contains(\"options\"));\n+        assertTrue(values.contains(\"--ignored\"));\n+        assertTrue(values.contains(\"-Dprop=val\"));\n+        assertEquals(3, values.size());\n+        assertFalse(iterator.hasNext());\n+    }\n+\n+    public void testProcess_ConsumeNothing() throws OptionException {\n+        final Option option = buildPathArgument();\n+        final List args = list(\"--\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.process(commandLine, iterator);\n+            fail(\"Missing Value!\");\n+        }\n+        catch (OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+            assertEquals(\"Missing value(s) path [path ...]\", mve.getMessage());\n+        }\n+\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+        assertFalse(iterator.hasNext());\n+    }\n+\n+//    public void testProcess_DefinedDefaultValue() throws OptionException {\n+//        final Option size = buildSizeArgument();\n+//        final List args = list();\n+//        final WriteableCommandLine commandLine = commandLine(size, args);\n+//        final ListIterator iterator = args.listIterator();\n+//\n+//        size.process(commandLine, iterator);\n+//\n+//        assertEquals(\"10\", commandLine.getValue(size));\n+//    }\n+//\n+//    public void testProcess_DefinedDefaultValues() throws OptionException {\n+//        final Option bounds = buildBoundsArgument();\n+//        final List args = list();\n+//        final WriteableCommandLine commandLine = commandLine(bounds, args);\n+//        final ListIterator iterator = args.listIterator();\n+//\n+//        bounds.process(commandLine, iterator);\n+//\n+//        List values = new ArrayList();\n+//        values.add(\"5\");\n+//        values.add(\"10\");\n+//        assertEquals(values, commandLine.getValues(bounds));\n+//    }\n+\n+    public void testProcess_InterrogatedDefaultValue() throws OptionException {\n+        final Option size = buildSizeArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(size, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        size.process(commandLine, iterator);\n+\n+        assertEquals(\n+            new Integer(20),\n+            commandLine.getValue(size, new Integer(20)));\n+    }\n+\n+    public void testProcess_InterrogatedDefaultValues()\n+        throws OptionException {\n+        final Option bounds = buildBoundsArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(bounds, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        bounds.process(commandLine, iterator);\n+\n+        List values = new ArrayList();\n+        values.add(\"50\");\n+        values.add(\"100\");\n+        assertEquals(values, commandLine.getValues(bounds, values));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/ArgumentTestCase.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class ArgumentTestCase extends OptionTestCase {\n+\n+    public abstract void testProcessValues() throws OptionException;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/CommandTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * @author Rob Oxspring\n+ * \n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class CommandTest extends ParentTestCase {\n+\n+    public static Command buildStartCommand() {\n+        return new Command(\n+            \"start\",\n+            \"Begins the process\",\n+            Collections.singleton(\"go\"),\n+            false,\n+            null,\n+            null,\n+            0);\n+    }\n+\n+    public static Command buildCommitCommand() {\n+        return new Command(\n+            \"commit\",\n+            \"Commit the changes to the database\",\n+            null,\n+            true,\n+            null,\n+            null,\n+            0);\n+    }\n+\n+    public static Command buildLoginCommand() {\n+        return new Command(\n+            \"login\",\n+            \"Initiates a session for the user\",\n+            null,\n+            false,\n+            ArgumentTest.buildUsernameArgument(),\n+            null,\n+            0);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent() throws OptionException {\n+        final Command option = buildStartCommand();\n+        final List args = list(\"go\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"start\"));\n+        assertTrue(commandLine.hasOption(\"go\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Spare() throws OptionException {\n+        final Command option = buildLoginCommand();\n+        final List args = list(\"login\", \"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertEquals(\"rob\", iterator.next());\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"login\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        assertTrue(buildStartCommand().canProcess(\"start\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        assertFalse(buildStartCommand().canProcess(\"stop\"));\n+    }\n+\n+    public void testCanProcess_Alias() {\n+        assertTrue(buildStartCommand().canProcess(\"go\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Command option = buildStartCommand();\n+        assertTrue(option.getPrefixes().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() throws OptionException {\n+        final Command option = buildLoginCommand();\n+        final List args = list(\"login\", \"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"login\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Command option = buildStartCommand();\n+        final Set triggers = option.getTriggers();\n+        assertContentsEqual(list(\"start\", \"go\"), triggers);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Parent option = buildCommitCommand();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        }\n+        catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[start (go)]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"start (go)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[start]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildStartCommand();\n+        assertEquals(\"start\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildLoginCommand();\n+        assertEquals(\n+            \"Initiates a session for the user\",\n+            option.getDescription());\n+    }\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/DefaultOptionTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * @author roberto\n+ * \n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class DefaultOptionTest extends ParentTestCase {\n+\n+    public static DefaultOption buildHelpOption() {\n+        final Set aliases = new HashSet(list(\"-h\", \"-?\"));\n+        return new DefaultOption(\n+            \"-\",\n+            \"--\",\n+            true,\n+            \"--help\",\n+            \"Displays the help\",\n+            aliases,\n+            aliases,\n+            false,\n+            null,\n+            null,\n+            'h');\n+    }\n+\n+    public static DefaultOption buildXOption() {\n+        return new DefaultOption(\n+            \"-\",\n+            \"--\",\n+            true,\n+            \"-X\",\n+            \"This is needed\",\n+            null,\n+            null,\n+            true,\n+            null,\n+            null,\n+            'X');\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent() throws OptionException {\n+        final DefaultOption option = buildHelpOption();\n+        final List args = list(\"--help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Burst() throws OptionException {\n+        final DefaultOption option = buildHelpOption();\n+        final List args = list(\"-help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertEquals(\"-elp\", iterator.next());\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final DefaultOption option = buildHelpOption();\n+        assertTrue(option.canProcess(\"-?\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final DefaultOption option = buildHelpOption();\n+        assertFalse(option.canProcess(\"-H\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final DefaultOption option = buildHelpOption();\n+        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final DefaultOption option = buildHelpOption();\n+        assertContentsEqual(list(\"-?\", \"-h\", \"--help\"), option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Parent option = buildXOption();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        }\n+        catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[--help (-?,-h)]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"--help (-?,-h)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[--help]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildHelpOption();\n+        assertEquals(\"--help\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildHelpOption();\n+        assertEquals(\"Displays the help\", option.getDescription());\n+    }\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/GroupTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class GroupTest extends GroupTestCase {\n+\n+    public static final Command COMMAND_START =\n+        new Command(\"start\", \"Starts the server\", null, false, null, null, 0);\n+    public static final Command COMMAND_STOP =\n+        new Command(\"stop\", \"Stops the server\", null, false, null, null, 0);\n+    public static final Command COMMAND_RESTART =\n+        new Command(\n+            \"restart\",\n+            \"Stops and starts the server\",\n+            null,\n+            false,\n+            null,\n+            null,\n+            0);\n+    public static final Command COMMAND_GRACEFUL =\n+        new Command(\n+            \"graceful\",\n+            \"Restarts the server without interruption\",\n+            null,\n+            false,\n+            null,\n+            null,\n+            0);\n+\n+    public static Group buildApacheCommandGroup() {\n+        final List options = new ArrayList();\n+        options.add(COMMAND_GRACEFUL);\n+        options.add(COMMAND_RESTART);\n+        options.add(COMMAND_START);\n+        options.add(COMMAND_STOP);\n+        return new GroupImpl(\n+            options,\n+            \"httpd-cmds\",\n+            \"The command to pass to the server\",\n+            1,\n+            1);\n+    }\n+\n+    public static Group buildApachectlGroup() {\n+        final List options = new ArrayList();\n+        options.add(DefaultOptionTest.buildHelpOption());\n+        options.add(ParentTest.buildKParent());\n+        return new GroupImpl(\n+            options,\n+            \"apachectl\",\n+            \"Controls the apache http deamon\",\n+            0,\n+            Integer.MAX_VALUE);\n+    }\n+\n+    public static Group buildAntGroup() {\n+        final List options = new ArrayList();\n+        options.add(DefaultOptionTest.buildHelpOption());\n+        options.add(ArgumentTest.buildTargetsArgument());\n+        return new GroupImpl(\n+            options,\n+            \"ant\",\n+            \"The options for ant\",\n+            0,\n+            Integer.MAX_VALUE);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.GroupTestCase#testProcessAnonymousArguments()\n+     */\n+    public void testProcessAnonymousArguments() throws OptionException {\n+        final Group option = buildAntGroup();\n+        final List args = list(\"compile,test\", \"dist\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertListContentsEqual(commandLine.getValues(\"target\"), args);\n+        assertListContentsEqual(list(\"compile\", \"test\", \"dist\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.GroupTestCase#testProcessOptions()\n+     */\n+    public void testProcessOptions() throws OptionException {\n+        final Group option = buildApachectlGroup();\n+        final List args = list(\"-?\", \"-k\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertFalse(commandLine.hasOption(\"start\"));\n+        assertListContentsEqual(list(\"--help\", \"-k\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Group option = buildApacheCommandGroup();\n+        assertTrue(option.canProcess(\"start\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Group option = buildApacheCommandGroup();\n+        assertFalse(option.canProcess(\"begin\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Group option = buildApachectlGroup();\n+        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() throws OptionException {\n+        final Group option = buildAntGroup();\n+        final List args = list(\"--help\", \"compile,test\", \"dist\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertListContentsEqual(\n+            list(\"compile\", \"test\", \"dist\"),\n+            commandLine.getValues(\"target\"));\n+    }\n+\n+    public void testProcess_Nested() throws OptionException {\n+        final Group option = buildApachectlGroup();\n+        final List args = list(\"-h\", \"-k\", \"graceful\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertTrue(commandLine.hasOption(\"graceful\"));\n+        assertFalse(commandLine.hasOption(\"stop\"));\n+        assertTrue(commandLine.getValues(\"start\").isEmpty());\n+        assertListContentsEqual(list(\"--help\", \"-k\", \"graceful\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Group option = buildApachectlGroup();\n+        assertContentsEqual(\n+            list(\"--help\", \"-?\", \"-h\", \"-k\"),\n+            option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addOption(COMMAND_RESTART);\n+\n+        option.validate(commandLine);\n+    }\n+\n+    public void testValidate_UnexpectedOption() throws OptionException {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addOption(COMMAND_RESTART);\n+        commandLine.addOption(COMMAND_GRACEFUL);\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Too many options\");\n+        }\n+        catch (OptionException uoe) {\n+            assertEquals(option, uoe.getOption());\n+        }\n+    }\n+\n+    public void testValidate_MissingOption() throws OptionException {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        }\n+        catch (OptionException moe) {\n+            assertEquals(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        //settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\n+            \"httpd-cmds (graceful|restart|start|stop)\",\n+            buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\n+            \"httpd-cmds (graceful|restart|start|stop)\",\n+            buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoExpand() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoExpandOrName() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoName() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"graceful|restart|start|stop\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_WithArgs() {\n+        final Option option = buildAntGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\n+            \"[ant (--help (-?,-h)) [<target1> [<target2> ...]]]\",\n+            buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildAntGroup();\n+        assertEquals(\"ant\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildApachectlGroup();\n+        assertEquals(\n+            \"Controls the apache http deamon\",\n+            option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = buildApacheCommandGroup();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine)i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        final HelpLine line2 = (HelpLine)i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMMAND_GRACEFUL, line2.getOption());\n+\n+        final HelpLine line3 = (HelpLine)i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMMAND_RESTART, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine)i.next();\n+        assertEquals(1, line4.getIndent());\n+        assertEquals(COMMAND_START, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine)i.next();\n+        assertEquals(1, line5.getIndent());\n+        assertEquals(COMMAND_STOP, line5.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoExpanded() {\n+        final Option option = buildApacheCommandGroup();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine)i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoName() {\n+        final Option option = buildApacheCommandGroup();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line2 = (HelpLine)i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMMAND_GRACEFUL, line2.getOption());\n+\n+        final HelpLine line3 = (HelpLine)i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMMAND_RESTART, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine)i.next();\n+        assertEquals(1, line4.getIndent());\n+        assertEquals(COMMAND_START, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine)i.next();\n+        assertEquals(1, line5.getIndent());\n+        assertEquals(COMMAND_STOP, line5.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/GroupTestCase.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ * \n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public abstract class GroupTestCase extends OptionTestCase {\n+    public abstract void testProcessOptions() throws OptionException;\n+\n+    public abstract void testProcessAnonymousArguments()\n+        throws OptionException;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/OptionTestCase.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.List;\n+\n+import org.apache.commons.cli2.CLITestCase;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class OptionTestCase extends CLITestCase {\n+\n+    public static WriteableCommandLine commandLine(\n+        final Option option,\n+        final List args) {\n+        return new WriteableCommandLineImpl(option, args);\n+    }\n+\n+    public abstract void testTriggers();\n+\n+    public abstract void testPrefixes();\n+\n+    public abstract void testCanProcess();\n+\n+    public abstract void testProcess() throws OptionException;\n+\n+    public abstract void testValidate() throws OptionException;\n+\n+    public abstract void testAppendUsage() throws OptionException;\n+\n+    public abstract void testGetPreferredName();\n+\n+    public abstract void testGetDescription();\n+\n+    public abstract void testHelpLines();\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/ParentTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ParentTest extends ParentTestCase {\n+\n+\tpublic static Parent buildLibParent() {\n+\t\tfinal Argument argument = ArgumentTest.buildPathArgument();\n+\t\treturn new DefaultOption(\n+\t\t\t\"-\",\n+\t\t\t\"--\",\n+\t\t\tfalse,\n+\t\t\t\"--lib\",\n+\t\t\t\"Specifies library search path\",\n+\t\t\tnull,\n+\t\t\tnull,\n+\t\t\tfalse,\n+\t\t\targument,\n+\t\t\tnull, \n+            'l');\n+\t}\n+\n+\tpublic static Parent buildKParent() {\n+\t\tfinal Group children = GroupTest.buildApacheCommandGroup();\n+\t\treturn new DefaultOption(\n+\t\t\t\"-\",\n+\t\t\t\"--\",\n+\t\t\tfalse,\n+\t\t\t\"-k\",\n+\t\t\t\"desc\",\n+\t\t\tnull,\n+\t\t\tnull,\n+\t\t\tfalse,\n+\t\t\tnull,\n+\t\t\tchildren, \n+            'k');\n+\t}\n+\n+\tpublic static final Argument COMPLEX_ARGUMENT =\n+\t\tnew ArgumentBuilder()\n+\t\t\t.withName(\"username\")\n+\t\t\t.withMinimum(1)\n+\t\t\t.withMaximum(1)\n+\t\t\t.create();\n+\n+\tpublic static final Option COMPLEX_CHILD_SSL =\n+\t\tnew DefaultOptionBuilder()\n+\t\t\t.withLongName(\"ssl\")\n+\t\t\t.withShortName(\"s\")\n+\t\t\t.create();\n+\n+\tpublic static final Option COMPLEX_CHILD_BASIC =\n+\t\tnew DefaultOptionBuilder()\n+\t\t\t.withLongName(\"basic\")\n+\t\t\t.withShortName(\"b\")\n+\t\t\t.create();\n+\n+\tpublic static final Option COMPLEX_CHILD_DIGEST =\n+\t\tnew DefaultOptionBuilder()\n+\t\t\t.withLongName(\"digest\")\n+\t\t\t.withShortName(\"d\")\n+\t\t\t.create();\n+\n+\tpublic static final Group COMPLEX_CHILDREN =\n+\t\tnew GroupBuilder()\n+\t\t\t.withName(\"login-opts\")\n+\t\t\t.withOption(COMPLEX_CHILD_BASIC)\n+\t\t\t.withOption(COMPLEX_CHILD_DIGEST)\n+            .withOption(COMPLEX_CHILD_SSL)\n+\t\t\t.create();\n+\n+\tpublic static Parent buildComplexParent() {\n+\t\treturn new CommandBuilder()\n+\t\t\t.withName(\"login\")\n+\t\t\t.withName(\"lo\")\n+\t\t\t.withArgument(COMPLEX_ARGUMENT)\n+\t\t\t.withChildren(COMPLEX_CHILDREN)\n+\t\t\t.create();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+\t */\n+\tpublic void testProcessParent() throws OptionException {\n+\t\tfinal Parent option = buildKParent();\n+\t\tfinal List args = list(\"-k\", \"start\");\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, args);\n+\t\tfinal ListIterator iterator = args.listIterator();\n+\t\toption.processParent(commandLine, iterator);\n+\n+\t\tassertEquals(\"start\", iterator.next());\n+\t\tassertFalse(iterator.hasNext());\n+\t\tassertTrue(commandLine.hasOption(option));\n+\t\tassertTrue(commandLine.hasOption(\"-k\"));\n+\t\tassertTrue(commandLine.getValues(option).isEmpty());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+\t */\n+\tpublic void testCanProcess() {\n+\t\tfinal Parent option = buildKParent();\n+\t\tassertTrue(option.canProcess(\"-k\"));\n+\t}\n+\n+\tpublic void testCanProcess_BadMatch() {\n+\t\tfinal Parent option = buildKParent();\n+\t\tassertFalse(option.canProcess(\"-K\"));\n+\t}\n+\n+\tpublic void testCanProcess_ContractedArgument() {\n+\t\tfinal Parent option = buildLibParent();\n+\t\tassertTrue(option.canProcess(\"--lib=/usr/lib\"));\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+\t */\n+\tpublic void testPrefixes() {\n+\t\tfinal Parent option = buildKParent();\n+\t\tassertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+\t */\n+\tpublic void testProcess() throws OptionException {\n+\t\tfinal Parent option = CommandTest.buildStartCommand();\n+\t\tfinal List args = list(\"start\");\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, args);\n+\t\tfinal ListIterator iterator = args.listIterator();\n+\t\toption.process(commandLine, iterator);\n+\n+\t\tassertFalse(iterator.hasNext());\n+\t\tassertTrue(commandLine.hasOption(option));\n+\t\tassertTrue(commandLine.hasOption(\"start\"));\n+\t\tassertFalse(commandLine.hasOption(\"stop\"));\n+\t\tassertTrue(commandLine.getValues(option).isEmpty());\n+\t}\n+\n+\tpublic void testProcess_Children() throws OptionException {\n+\t\tfinal Parent option = buildKParent();\n+\t\tfinal List args = list(\"-k\", \"start\");\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, args);\n+\t\tfinal ListIterator iterator = args.listIterator();\n+\t\toption.process(commandLine, iterator);\n+\n+\t\tassertFalse(iterator.hasNext());\n+\t\tassertTrue(commandLine.hasOption(option));\n+\t\tassertTrue(commandLine.hasOption(\"-k\"));\n+\t\tassertTrue(commandLine.hasOption(\"start\"));\n+\t\tassertFalse(commandLine.hasOption(\"stop\"));\n+\t\tassertTrue(commandLine.getValues(option).isEmpty());\n+\t}\n+\n+\tpublic void testProcess_Argument() throws OptionException {\n+\t\tfinal Parent option = buildLibParent();\n+\t\tfinal List args = list(\"--lib=C:\\\\WINDOWS;C:\\\\WINNT;C:\\\\\");\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, args);\n+\t\tfinal ListIterator iterator = args.listIterator();\n+\t\toption.process(commandLine, iterator);\n+\n+\t\tassertFalse(iterator.hasNext());\n+\t\tassertTrue(commandLine.hasOption(option));\n+\t\tassertTrue(commandLine.hasOption(\"--lib\"));\n+\t\tassertContentsEqual(\n+\t\t\tlist(\"C:\\\\WINDOWS\", \"C:\\\\WINNT\", \"C:\\\\\"),\n+\t\t\tcommandLine.getValues(option));\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+\t */\n+\tpublic void testTriggers() {\n+\t\tfinal Parent option = buildKParent();\n+\t\tassertContentsEqual(list(\"-k\"), option.getTriggers());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+\t */\n+\tpublic void testValidate() throws OptionException {\n+\t\tfinal Parent option = CommandTest.buildStartCommand();\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, list());\n+\n+\t\toption.validate(commandLine);\n+\n+\t\tcommandLine.addOption(option);\n+\n+\t\toption.validate(commandLine);\n+\t}\n+\n+\tpublic void testValidate_Children() throws OptionException {\n+\t\tfinal Parent option = buildKParent();\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, list());\n+\n+\t\toption.validate(commandLine);\n+\t\tcommandLine.addOption(option);\n+\n+\t\ttry {\n+\t\t\toption.validate(commandLine);\n+\t\t\tfail(\"Missing a command\");\n+\t\t} catch (OptionException moe) {\n+\t\t\tassertNotNull(moe.getOption());\n+\t\t\tassertNotSame(option, moe.getOption());\n+\t\t}\n+\t}\n+\n+\tpublic void testValidate_Argument() throws OptionException {\n+\t\tfinal Command option = CommandTest.buildLoginCommand();\n+\t\tfinal WriteableCommandLine commandLine = commandLine(option, list());\n+\n+\t\toption.validate(commandLine);\n+\n+\t\tcommandLine.addOption(option);\n+\n+\t\ttry {\n+\t\t\toption.validate(commandLine);\n+\t\t\tfail(\"Missing a value\");\n+\t\t} catch (OptionException moe) {\n+\t\t\tassertSame(option, moe.getOption());\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+\t */\n+\tpublic void testAppendUsage() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal StringBuffer buffer = new StringBuffer();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\t\toption.appendUsage(buffer, settings, null);\n+\n+\t\tassertEquals(\n+\t\t\t\"[login (lo) <username> [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",\n+\t\t\tbuffer.toString());\n+\t}\n+\n+\tpublic void testAppendUsage_NoArguments() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal StringBuffer buffer = new StringBuffer();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\t\toption.appendUsage(buffer, settings, null);\n+\n+\t\tassertEquals(\n+\t\t\t\"[login (lo) [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",\n+\t\t\tbuffer.toString());\n+\t}\n+\n+\tpublic void testAppendUsage_NoChildren() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal StringBuffer buffer = new StringBuffer();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\t\toption.appendUsage(buffer, settings, null);\n+\n+\t\tassertEquals(\"[login (lo) <username>]\", buffer.toString());\n+\t}\n+\n+\tpublic void testAppendUsage_NoArgumentsOrChildren() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal StringBuffer buffer = new StringBuffer();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+\t\toption.appendUsage(buffer, settings, null);\n+\n+\t\tassertEquals(\"[login (lo)]\", buffer.toString());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+\t */\n+\tpublic void testGetPreferredName() {\n+\t\tfinal Option option = buildLibParent();\n+\t\tassertEquals(\"--lib\", option.getPreferredName());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+\t */\n+\tpublic void testGetDescription() {\n+\t\tfinal Option option = buildLibParent();\n+\t\tassertEquals(\"Specifies library search path\", option.getDescription());\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+\t */\n+\tpublic void testHelpLines() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal List lines =\n+\t\t\toption.helpLines(0, DisplaySetting.ALL, null);\n+\t\tfinal Iterator i = lines.iterator();\n+\n+\t\tfinal HelpLine line1 = (HelpLine) i.next();\n+\t\tassertEquals(0, line1.getIndent());\n+\t\tassertEquals(option, line1.getOption());\n+\n+\t\tfinal HelpLine line2 = (HelpLine) i.next();\n+\t\tassertEquals(1, line2.getIndent());\n+\t\tassertEquals(COMPLEX_ARGUMENT, line2.getOption());\n+\n+\t\tfinal HelpLine line3 = (HelpLine) i.next();\n+\t\tassertEquals(1, line3.getIndent());\n+\t\tassertEquals(COMPLEX_CHILDREN, line3.getOption());\n+\n+\t\tfinal HelpLine line4 = (HelpLine) i.next();\n+\t\tassertEquals(2, line4.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_BASIC, line4.getOption());\n+\n+\t\tfinal HelpLine line5 = (HelpLine) i.next();\n+\t\tassertEquals(2, line5.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());\n+\n+\t\tfinal HelpLine line6 = (HelpLine) i.next();\n+\t\tassertEquals(2, line6.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_SSL, line6.getOption());\n+\n+\t\tassertFalse(i.hasNext());\n+\t}\n+\n+\tpublic void testHelpLines_NoArgument() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+\t\tfinal List lines = option.helpLines(0, settings, null);\n+\t\tfinal Iterator i = lines.iterator();\n+\n+\t\tfinal HelpLine line1 = (HelpLine) i.next();\n+\t\tassertEquals(0, line1.getIndent());\n+\t\tassertEquals(option, line1.getOption());\n+\n+\t\tfinal HelpLine line3 = (HelpLine) i.next();\n+\t\tassertEquals(1, line3.getIndent());\n+\t\tassertEquals(COMPLEX_CHILDREN, line3.getOption());\n+\n+\t\tfinal HelpLine line4 = (HelpLine) i.next();\n+\t\tassertEquals(2, line4.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_BASIC, line4.getOption());\n+\n+\t\tfinal HelpLine line5 = (HelpLine) i.next();\n+\t\tassertEquals(2, line5.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());\n+\n+\t\tfinal HelpLine line6 = (HelpLine) i.next();\n+\t\tassertEquals(2, line6.getIndent());\n+\t\tassertEquals(COMPLEX_CHILD_SSL, line6.getOption());\n+\n+\t\tassertFalse(i.hasNext());\n+\t}\n+\n+\tpublic void testHelpLines_NoChildren() {\n+\t\tfinal Option option = buildComplexParent();\n+\t\tfinal Set settings = new HashSet(DisplaySetting.ALL);\n+\t\tsettings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\t\tfinal List lines = option.helpLines(0, settings, null);\n+\t\tfinal Iterator i = lines.iterator();\n+\n+\t\tfinal HelpLine line1 = (HelpLine) i.next();\n+\t\tassertEquals(0, line1.getIndent());\n+\t\tassertEquals(option, line1.getOption());\n+\n+\t\tfinal HelpLine line2 = (HelpLine) i.next();\n+\t\tassertEquals(1, line2.getIndent());\n+\t\tassertEquals(COMPLEX_ARGUMENT, line2.getOption());\n+\n+\t\tassertFalse(i.hasNext());\n+\t}\n+    \n+    public void testGetId(){\n+        assertEquals('h', DefaultOptionTest.buildHelpOption().getId());\n+        assertEquals('X', DefaultOptionTest.buildXOption().getId());\n+        assertEquals(0, CommandTest.buildStartCommand().getId());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/ParentTestCase.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class ParentTestCase extends OptionTestCase {\n+    public abstract void testProcessParent() throws OptionException;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/PropertyOptionTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class PropertyOptionTest extends OptionTestCase {\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Option option = new PropertyOption();\n+        assertTrue(option.canProcess(\"-Dmyprop=myval\"));\n+    }\n+\n+    public void testCanProcess_Null() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess((String) null));\n+    }\n+\n+    public void testCanProcess_TooShort() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess(\"-D\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess(\"-dump\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Option option = new PropertyOption();\n+        assertContentsEqual(list(\"-D\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop=myvalue\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+        assertEquals(\"myvalue\", commandLine.getProperty(\"myprop\"));\n+        assertFalse(iterator.hasNext());\n+        assertEquals(1, commandLine.getProperties().size());\n+    }\n+\n+    public void testProcess_UnexpectedOptionException()\n+        throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"--help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.process(commandLine, iterator);\n+            fail(\"UnexpectedOption\");\n+        }\n+        catch (final OptionException uoe) {\n+            assertEquals(option, uoe.getOption());\n+            assertEquals(\n+                \"Unexpected --help while processing -Dproperty=value\",\n+                uoe.getMessage());\n+        }\n+    }\n+\n+    public void testProcess_BadPropertyException() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+\n+        assertEquals(\"true\", commandLine.getProperty(\"myprop\"));\n+    }\n+\n+    public void testProcess_SetToEmpty() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop=\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+        assertEquals(\"\", commandLine.getProperty(\"myprop\"));\n+        assertFalse(iterator.hasNext());\n+        assertEquals(1, commandLine.getProperties().size());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Option option = new PropertyOption();\n+\n+        assertContentsEqual(list(\"-D\"), option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dproperty=value\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+\n+        option.validate(commandLine);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = new PropertyOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"-D<property>=<value>\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Hidden() {\n+        final Option option = new PropertyOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = new PropertyOption();\n+        assertEquals(\"-D\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = new PropertyOption();\n+        assertEquals(\n+            \"Passes properties and values to the application\",\n+            option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = new PropertyOption();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine)i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoDisplay() {\n+        final Option option = new PropertyOption();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        assertFalse(i.hasNext());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/option/SwitchTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * @author Rob Oxspring\n+ * \n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class SwitchTest extends ParentTestCase {\n+\n+    public static Switch buildDisplaySwitch() {\n+        final Set aliases = new HashSet();\n+        aliases.add(\"d\");\n+        aliases.add(\"disp\");\n+        return new Switch(\n+            \"+\",\n+            \"-\",\n+            \"display\",\n+            aliases,\n+            \"Sets whether to display to screen\",\n+            true,\n+            null,\n+            null,\n+            'd');\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent() throws OptionException {\n+        final Switch option = buildDisplaySwitch();\n+        final List args = list(\"+d\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"+d\"));\n+        assertTrue(commandLine.hasOption(\"-display\"));\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"-d\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Disabled() throws OptionException {\n+        final Switch option = buildDisplaySwitch();\n+        final List args = list(\"-disp\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"+d\"));\n+        assertTrue(commandLine.hasOption(\"-display\"));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"-d\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Switch option = buildDisplaySwitch();\n+        assertTrue(option.canProcess(\"+d\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Switch option = buildDisplaySwitch();\n+        assertFalse(option.canProcess(\"-dont\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Switch option = buildDisplaySwitch();\n+        assertContentsEqual(list(\"-\", \"+\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Switch option = buildDisplaySwitch();\n+        assertContentsEqual(\n+            list(\"-d\", \"+d\", \"-disp\", \"+disp\", \"+display\", \"-display\"),\n+            option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Parent option = buildDisplaySwitch();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        }\n+        catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\n+            \"+display|-display (+d|-d,+disp|-disp)\",\n+            buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display|-display\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoDisabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display (+d,+disp)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoEnabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"-display (-d,-disp)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoDisabledOrEnabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display (+d,+disp)\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildDisplaySwitch();\n+        assertEquals(\"+display\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildDisplaySwitch();\n+        assertEquals(\n+            \"Sets whether to display to screen\",\n+            option.getDescription());\n+    }\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/util/ComparatorsTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.SwitchBuilder;\n+import org.apache.commons.cli2.option.CommandTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+import org.apache.commons.cli2.option.GroupTest;\n+import org.apache.commons.cli2.option.OptionTestCase;\n+import org.apache.commons.cli2.option.ParentTest;\n+import org.apache.commons.cli2.option.SwitchTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ComparatorsTest extends TestCase {\n+    public void testGroupFirst() {\n+        final Option o1 = GroupTest.buildAntGroup();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.groupFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testGroupLast() {\n+        final Option o1 = GroupTest.buildAntGroup();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.groupLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testSwitchFirst() {\n+        final Option o1 = SwitchTest.buildDisplaySwitch();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.switchFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testSwitchLast() {\n+        final Option o1 = SwitchTest.buildDisplaySwitch();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final Option o3 = new SwitchBuilder().withName(\"hidden\").create();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.switchLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testCommandFirst() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.commandFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testCommandLast() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.commandLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testDefaultOptionFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = CommandTest.buildCommitCommand();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.defaultOptionFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testDefaultOptionLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = CommandTest.buildCommitCommand();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.defaultOptionLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testNamedFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.namedFirst(\"--help\"));\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testNamedLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.namedLast(\"--help\"));\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testPreferredNameFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.preferredNameFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testPreferredNameLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.preferredNameLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testRequiredFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = DefaultOptionTest.buildXOption();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.requiredFirst());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testRequiredLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = DefaultOptionTest.buildXOption();\n+        final List list = OptionTestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.requiredLast());\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o1, o2),\n+            list);\n+    }\n+    \n+    public void testChained() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = SwitchTest.buildDisplaySwitch();\n+        final Option o3 = DefaultOptionTest.buildHelpOption();\n+        final List list = OptionTestCase.list(o1, o2, o3);\n+        \n+        Collections.sort(\n+            list, \n+            Comparators.chain(\n+                Comparators.namedFirst(\"--help\"),\n+                Comparators.commandFirst()));\n+\n+        OptionTestCase.assertListContentsEqual(\n+            OptionTestCase.list(o3, o1, o2),\n+            list);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/util/HelpFormatterTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.Iterator;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+\n+public class HelpFormatterTest extends TestCase {\n+    private HelpFormatter helpFormatter;\n+    private Option verbose;\n+\n+    public void setUp() {\n+        helpFormatter = new HelpFormatter(\"|*\", \"*-*\", \"*|\", 80);\n+        helpFormatter.setDivider(\n+            \"+------------------------------------------------------------------------------+\");\n+        helpFormatter.setHeader(\"Jakarta Commons CLI\");\n+        helpFormatter.setFooter(\"Copyright 2003\\nApache Software Foundation\");\n+        helpFormatter.setShellCommand(\"ant\");\n+\n+        verbose =\n+            new DefaultOptionBuilder()\n+                .withLongName(\"verbose\")\n+                .withDescription(\"print the version information and exit\")\n+                .create();\n+\n+        helpFormatter.setGroup(\n+            new GroupBuilder()\n+                .withName(\"options\")\n+                .withOption(DefaultOptionTest.buildHelpOption())\n+                .withOption(ArgumentTest.buildTargetsArgument())\n+                .withOption(\n+                    new DefaultOptionBuilder()\n+                        .withLongName(\"diagnostics\")\n+                        .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                        .create())\n+                .withOption(\n+                    new DefaultOptionBuilder()\n+                        .withLongName(\"projecthelp\")\n+                        .withDescription(\"print project help information\")\n+                        .create())\n+                .withOption(verbose)\n+                .create());\n+    }\n+\n+    public void testPrint() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.print();\n+\n+        //System.out.println(writer.toString());\n+\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Jakarta Commons CLI                                                         *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Usage:                                                                      *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*...]]                                                                       *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*options              *-*                                                    *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*                     *-*or report problems.                                 *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --projecthelp      *-*print project help information                      *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --verbose          *-*print the version information and exit              *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  target [target ...]*-*The targets ant should build                        *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Copyright 2003                                                              *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Apache Software Foundation                                                  *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printHelp();\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*options              *-*                                                    *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*                     *-*or report problems.                                 *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --projecthelp      *-*print project help information                      *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  --verbose          *-*print the version information and exit              *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*  target [target ...]*-*The targets ant should build                        *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp_WithException() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.setException(new OptionException(verbose));\n+        helpFormatter.printHelp();\n+        //System.out.println(writer);\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*--verbose*-*print the version information and exit                          *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintException() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.setException(new OptionException(verbose, \"cli.error.missing.option\"));\n+        helpFormatter.printException();\n+        //System.out.println(writer);\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Missing option --verbose                                                    *|\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintUsage() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printUsage();\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Usage:                                                                      *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*...]]                                                                       *|\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHeader() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printHeader();\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Jakarta Commons CLI                                                         *|\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintFooter() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printFooter();\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"|*Copyright 2003                                                              *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"|*Apache Software Foundation                                                  *|\",\n+            reader.readLine());\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintDivider() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printDivider();\n+        final BufferedReader reader =\n+            new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\n+            \"+------------------------------------------------------------------------------+\",\n+            reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testWrap() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"Apache Software Foundation\", 30).iterator();\n+        assertEquals(\"Apache Software Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_WrapNeeded() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"Apache Software Foundation\", 20).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_BeforeSpace() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"Apache Software Foundation\", 16).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_AfterSpace() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"Apache Software Foundation\", 17).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_InWord() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"Apache Software Foundation\", 8).iterator();\n+        assertEquals(\"Apache\", i.next());\n+        assertEquals(\"Software\", i.next());\n+        assertEquals(\"Foundati\", i.next());\n+        assertEquals(\"on\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_NewLine() {\n+        final Iterator i =\n+            HelpFormatter.wrap(\"\\nApache Software Foundation\\n\", 30).iterator();\n+        assertEquals(\"\", i.next());\n+        assertEquals(\"Apache Software Foundation\", i.next());\n+        assertEquals(\"\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testPad() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(\"hello\", 10, writer);\n+        assertEquals(\"hello     \", writer.toString());\n+    }\n+\n+    public void testPad_Null() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(null, 10, writer);\n+        assertEquals(\"          \", writer.toString());\n+    }\n+\n+    public void testPad_TooLong() throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(\"hello world\", 10, writer);\n+        assertEquals(\"hello world\", writer.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/ClassValidatorTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class ClassValidatorTest extends TestCase {\n+\n+    private final static ResourceHelper resources =\n+        ResourceHelper.getResourceHelper(ClassValidatorTest.class);\n+\n+    private ClassValidator validator;\n+\n+    protected void setUp() {\n+        validator = new ClassValidator();\n+    }\n+\n+    public void testValidName() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"MyApp\", \"org.apache.ant.Main\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.validate(list);\n+\n+        assertEquals(\"Name is incorrect\", \"MyApp\", list.get(0));\n+        assertEquals(\"Name is incorrect\", \"org.apache.ant.Main\", list.get(1));\n+    }\n+\n+    public void testNameBadStart() {\n+        final String className = \"1stClass\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Class name cannot start with a number.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.error.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testNameBadEnd() {\n+        final String className = \"My.Class.\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Trailing period not permitted.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.error.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testNameBadMiddle() {\n+        final String className = \"My..Class\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Two consecutive periods is not permitted.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.error.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testIllegalNameChar() {\n+        final String className = \"My?Class\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Illegal character not allowed in Class name.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.error.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testLoadable() throws InvalidArgumentException {\n+        assertFalse(\"Validator is loadable\", validator.isLoadable());\n+        validator.setLoadable(true);\n+        assertTrue(\"Validator is NOT loadable\", validator.isLoadable());\n+        validator.setLoadable(false);\n+        assertFalse(\"Validator is loadable\", validator.isLoadable());\n+    }\n+\n+    public void testLoadValid() throws InvalidArgumentException {\n+        final Object[] array =\n+            new Object[] {\n+                \"org.apache.commons.cli2.Option\",\n+                \"java.util.Vector\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setLoadable(true);\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\n+            \"org.apache.commons.cli2.Option\",\n+            ((Class) i.next()).getName());\n+        assertEquals(\"java.util.Vector\", ((Class) i.next()).getName());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testLoadInvalid() {\n+        final String className = \"org.apache.commons.cli2.NonOption\";\n+\n+        final Object[] array = new Object[] { className, \"java.util.Vectors\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setLoadable(true);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Class Not Found\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.error.class.notfound\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testInstantiate() throws InvalidArgumentException {\n+        assertFalse(\"Validator creates instances\", validator.isInstance());\n+        validator.setInstance(true);\n+        assertTrue(\n+            \"Validator does NOT create instances\",\n+            validator.isInstance());\n+        validator.setInstance(false);\n+        assertFalse(\"Validator creates instances\", validator.isInstance());\n+    }\n+\n+    public void testCreateClassInstance() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"java.util.Vector\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+\n+        validator.validate(list);\n+        assertTrue(\n+            \"Vector instance NOT found\",\n+            list.get(0) instanceof java.util.Vector);\n+    }\n+\n+    public void testCreateInterfaceInstance() throws InvalidArgumentException {\n+        final String className = \"java.util.Map\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+        \n+        try {\n+            validator.validate(list);\n+            fail(\"It's not possible to create a '\" + className + \"'\");\n+        }\n+        catch (final InvalidArgumentException ive) {\n+            assertEquals(\n+                    resources.getMessage(\n+                            \"ClassValidator.error.class.create\",\n+                            className),\n+                            ive.getMessage());\n+        }\n+    }\n+\n+    public void testCreateProtectedInstance() throws InvalidArgumentException {\n+        final String className = \"org.apache.commons.cli2.validation.protect.ProtectedClass\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+        \n+        try {\n+            validator.validate(list);\n+            fail(\"It's not possible to create a '\" + className + \"'\");\n+        }\n+        catch (final InvalidArgumentException ive) {\n+            assertEquals(\n+                    resources.getMessage(\n+                            \"ClassValidator.error.class.access\",\n+                            className,\n+                            \"Class org.apache.commons.cli2.validation.ClassValidator \" +\n+                            \"can not access a member of class \" +\n+                            \"org.apache.commons.cli2.validation.protect.ProtectedClass \" +\n+                            \"with modifiers \\\"protected\\\"\"),\n+                            ive.getMessage());\n+        }\n+    }\n+    \n+    public void testClassloader() throws InvalidArgumentException {\n+        assertEquals(\n+            \"Wrong classloader found\",\n+            validator.getClass().getClassLoader(),\n+            validator.getClassLoader());\n+\n+        URLClassLoader classloader = new URLClassLoader(new URL[] {\n+        });\n+        validator.setClassLoader(classloader);\n+\n+        assertEquals(\n+            \"Wrong classloader found\",\n+            classloader,\n+            validator.getClassLoader());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/DateValidatorTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class DateValidatorTest extends TestCase {\n+    public static final DateFormat D_M_YY = new SimpleDateFormat(\"d/M/yy\");\n+    public static final DateFormat YYYY_MM_YY =\n+        new SimpleDateFormat(\"yyyy-MM-dd\");\n+    private List formats = Arrays.asList(new Object[] { D_M_YY, YYYY_MM_YY });\n+\n+    public void testValidate() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator(formats);\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date)i.next()));\n+        assertEquals(\"2002-10-12\", YYYY_MM_YY.format((Date)i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testMinimumBounds() throws InvalidArgumentException {\n+        final DateValidator validator = new DateValidator(formats);\n+        final Calendar cal = Calendar.getInstance();\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2002, 1, 12);\n+            final Date min = cal.getTime();\n+            validator.setMinimum(min);\n+            validator.validate(list);\n+        }\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2003, 1, 12);\n+            final Date min = cal.getTime();\n+            validator.setMinimum(min);\n+\n+            try {\n+                validator.validate(list);\n+                fail(\"minimum out of bounds exception not caught\");\n+            }\n+            catch (final InvalidArgumentException exp) {\n+                assertEquals(\"Out of range: 2002-10-12\", exp.getMessage());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/EnumValidatorTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import junit.framework.TestCase;\n+\n+public class EnumValidatorTest extends TestCase {\n+    private final Set enum = new TreeSet(\n+            Arrays.asList(\n+                    new Object[]{\"red\", \"green\", \"blue\"}));\n+    \n+    public void testValidate() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"red\", \"green\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new EnumValidator(enum);\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\"red\", i.next());\n+        assertEquals(\"green\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+    \n+    public void testNonMember() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"red\", \"pink\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new EnumValidator(enum);\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"'pink' is not allowed.  Permitted values are:['blue', 'green', 'red']\",e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/FileValidatorTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public class FileValidatorTest extends TestCase {\n+    \n+    public void testValidate() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"src\", \"project.xml\", \"veryunlikelyfilename\"};\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = new FileValidator();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(new File(\"src\"), i.next());\n+        assertEquals(new File(\"project.xml\"), i.next());\n+        assertEquals(new File(\"veryunlikelyfilename\"), i.next());\n+        assertFalse(i.hasNext());\n+    }\n+    \n+    public void testValidate_Directory() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"src\", \"project.xml\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = FileValidator.getExistingDirectoryInstance();\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"project.xml\",e.getMessage());\n+        }\n+    }\n+    \n+    public void testValidate_File() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"project.xml\", \"src\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = FileValidator.getExistingFileInstance();\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"src\",e.getMessage());\n+        }\n+    }\n+    \n+    public void testValidate_Existing() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"project.xml\", \"veryunlikelyfilename\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = FileValidator.getExistingInstance();\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"veryunlikelyfilename\",e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/NumberValidatorTest.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.NumberFormat;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public class NumberValidatorTest extends TestCase {\n+    \n+    public void testValidate_Number() throws InvalidArgumentException {\n+        final NumberFormat format = NumberFormat.getNumberInstance();\n+        \n+        final Object[] array = \n+            new Object[] { \n+                format.format(1d), \n+                format.format(1.07d), \n+                format.format(-.45d)};\n+        \n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getNumberInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Currency() throws InvalidArgumentException {\n+        NumberFormat format = NumberFormat.getCurrencyInstance();\n+        final Object[] array =\n+            new Object[] {\n+                format.format(1d),\n+                format.format(1.07),\n+                format.format(-0.45)};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getCurrencyInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Percent() throws InvalidArgumentException {\n+        final NumberFormat format = NumberFormat.getPercentInstance();\n+        \n+        final Object[] array \n+            = new Object[] { \n+                format.format(.01), \n+                format.format(1.07),\n+                format.format(-.45),\n+                format.format(0.001) };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getPercentInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(0.01d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(0.00001d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Integer() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"1\", \"107\", \"-45\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getIntegerInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(107d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(-45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_ExcessChars() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"10DowningStreet\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getIntegerInstance();\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"10DowningStreet\",e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_Maximum() {\n+        final Object[] array = new Object[] { \"1\", \"107\" };\n+        final List list = Arrays.asList(array);\n+        final NumberValidator validator = NumberValidator.getIntegerInstance();\n+        validator.setMaximum(new Integer(100));\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"107 too big\");\n+        }\n+        catch (InvalidArgumentException ive) {\n+            assertEquals(\"Out of range: 107\", ive.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_Minimum() {\n+        final Object[] array = new Object[] { \"107\", \"1\" };\n+        final List list = Arrays.asList(array);\n+        final NumberValidator validator = NumberValidator.getIntegerInstance();\n+        validator.setMinimum(new Integer(100));\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"1 too small\");\n+        }\n+        catch (InvalidArgumentException ive) {\n+            assertEquals(\"Out of range: 1\", ive.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/UrlValidatorTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public class UrlValidatorTest extends TestCase {\n+    \n+    public void testValidate() throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\"};\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new UrlValidator();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(new URL(\"http://www.apache.org/\"), i.next());\n+        assertEquals(new URL(\"file:///etc\"), i.next());\n+        assertFalse(i.hasNext());\n+    }\n+    \n+    public void testBadProtocol() throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\"};\n+        final List list = Arrays.asList(array);\n+        final UrlValidator validator = new UrlValidator();\n+        validator.setProtocol(\"http\");\n+\n+        try{\n+            validator.validate(list);\n+            fail(\"Expected InvalidArgumentException\");\n+        }\n+        catch(InvalidArgumentException e){\n+            assertEquals(\"file:///etc\",e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/validation/protect/ProtectedClass.java\n+/**\n+ * Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation.protect;\n+\n+class ProtectedClass {\n+    protected ProtectedClass() {\n+    }\n+};", "timestamp": 1082674816, "metainfo": ""}