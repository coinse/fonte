{"sha": "491340dc5e6c8d4233cc575571e15dd357f20b70", "log": "trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n import java.util.Iterator;\n import java.util.List;\n \n-/** \n+/**\n  * A formatter of help messages for the current command line options\n  *\n  * @author Slawek Zachcial\n     /**\n      * Comparator used to sort the options when they output in help text.\n      * Defaults to case-insensitive alphabetical sorting by option key.\n-     * \n+     *\n      * @since 1.2\n      */\n     public Comparator<Option> getOptionComparator()\n     /**\n      * Set the comparator used to sort the options when they output in help text.\n      * Passing in a null comparator will keep the options in the order they were declared.\n-     * \n+     *\n      * @since 1.2\n      */\n     public void setOptionComparator(Comparator<Option> comparator)\n         {\n             // get the next Option\n             Option option = (Option) i.next();\n-            \n+\n             // check if the option is part of an OptionGroup\n             OptionGroup group = options.getOptionGroup(option);\n \n             buff.append(\"]\");\n         }\n     }\n-    \n+\n     /**\n      * Print the cmdLineSyntax to the specified writer, using the\n      * specified width.\n         // sort options ascending\n         int max = 0;\n         List<StringBuffer> prefixList = new ArrayList<StringBuffer>();\n-        \n+\n         List<Option> optList = options.helpOptions();\n-        \n+\n         if (getOptionComparator() != null)\n         {\n             Collections.sort(optList, getOptionComparator());\n         }\n-        \n+\n         for (Option option : optList)\n         {\n             StringBuffer optBuf = new StringBuffer();\n-            \n+\n             if (option.getOpt() == null)\n             {\n                 optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n \n                 return sb;\n             }\n-            \n+\n             if ((text.length() > width) && (pos == nextLineTabStop - 1))\n             {\n                 pos = width;\n     /**\n      * Render the specified text width a maximum width. This method differs\n      * from renderWrappedText by not removing leading spaces after a new line.\n-     * \n+     *\n      * @param sb The StringBuffer to place the rendered text into.\n      * @param width The number of characters to display per line\n      * @param nextLineTabStop The position on the next line for the first tab.\n     protected int findWrapPos(String text, int width, int startPos)\n     {\n         int pos;\n-        \n+\n         // the line ends before the max wrap pos or a new line char found\n         if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                 || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n         {\n             return pos;\n         }\n-        \n+\n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        \n+\n         return pos == text.length() ? -1 : pos;\n     }\n \n     {\n         char[] padding = new char[len];\n         Arrays.fill(padding, ' ');\n-        \n+\n         return new String(padding);\n     }\n ", "timestamp": 1303384966, "metainfo": ""}