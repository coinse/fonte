{"sha": "58fac658aba985ba77f8bd0156c6d01bec8d991b", "log": "[JXPATH-93] relational operators did not conform to XPath spec  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n-\n /**\n  * Implementation of Expression for the operation \"&gt;\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class CoreOperationGreaterThan extends CoreOperation {\n+public class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n \n     public CoreOperationGreaterThan(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    public Object computeValue(EvalContext context) {\n-        double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n-        double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n-        return l > r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-    \n-    protected int getPrecedence() {\n-        return 3;\n+    protected boolean evaluateCompare(int compare) {\n+        return compare > 0;\n     }\n \n-    protected boolean isSymmetric() {\n-        return false;\n-    }\n-    \n     public String getSymbol() {\n         return \">\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n-\n /**\n  * Implementation of Expression for the operation \"&gt;=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class CoreOperationGreaterThanOrEqual extends CoreOperation {\n+public class CoreOperationGreaterThanOrEqual extends\n+        CoreOperationRelationalExpression {\n \n     public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    public Object computeValue(EvalContext context) {\n-        double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n-        double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n-        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-    \n-    protected int getPrecedence() {\n-        return 3;\n+    protected boolean evaluateCompare(int compare) {\n+        return compare >= 0;\n     }\n \n-    protected boolean isSymmetric() {\n-        return false;\n-    }\n-    \n     public String getSymbol() {\n         return \">=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n-\n /**\n  * Implementation of Expression for the operation \"&lt;\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class CoreOperationLessThan extends CoreOperation {\n+public class CoreOperationLessThan extends CoreOperationRelationalExpression {\n \n     public CoreOperationLessThan(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    public Object computeValue(EvalContext context) {\n-        double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n-        double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n-        return l < r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-    \n-    protected int getPrecedence() {\n-        return 3;\n+    protected boolean evaluateCompare(int compare) {\n+        return compare < 0;\n     }\n \n-    protected boolean isSymmetric() {\n-        return false;\n-    }\n-    \n     public String getSymbol() {\n         return \"<\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n-\n /**\n  * Implementation of Expression for the operation \"&lt;=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class CoreOperationLessThanOrEqual extends CoreOperation {\n+public class CoreOperationLessThanOrEqual extends\n+        CoreOperationRelationalExpression {\n \n     public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    public Object computeValue(EvalContext context) {\n-        double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n-        double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n-        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-    \n-    protected int getPrecedence() {\n-        return 3;\n+    protected boolean evaluateCompare(int compare) {\n+        return compare <= 0;\n     }\n \n-    protected boolean isSymmetric() {\n-        return false;\n-    }\n-    \n     public String getSymbol() {\n         return \"<=\";\n     }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n+import org.apache.commons.jxpath.ri.axes.SelfContext;\n+\n+/**\n+ * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n+ *\n+ * @author Matt Benson\n+ * @version $Revision:$ $Date:$\n+ */\n+public abstract class CoreOperationRelationalExpression extends CoreOperation {\n+\n+    protected CoreOperationRelationalExpression(Expression[] args) {\n+        super(args);\n+    }\n+\n+    public final Object computeValue(EvalContext context) {\n+        return compute(args[0].computeValue(context), args[1]\n+                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected final int getPrecedence() {\n+        return 3;\n+    }\n+\n+    protected final boolean isSymmetric() {\n+        return false;\n+    }\n+\n+    protected abstract boolean evaluateCompare(int compare);\n+\n+    private boolean compute(Object left, Object right) {\n+        left = reduce(left);\n+        right = reduce(right);\n+\n+        if (left instanceof InitialContext) {\n+            ((InitialContext) left).reset();\n+        }\n+        if (right instanceof InitialContext) {\n+            ((InitialContext) right).reset();\n+        }\n+        if (left instanceof Iterator && right instanceof Iterator) {\n+            return findMatch((Iterator) left, (Iterator) right);\n+        }\n+        if (left instanceof Iterator) {\n+            return containsMatch((Iterator) left, right);\n+        }\n+        if (right instanceof Iterator) {\n+            return containsMatch((Iterator) right, left);\n+        }\n+        return evaluateCompare(compare(left, right));\n+    }\n+\n+    private Object reduce(Object o) {\n+        if (o instanceof SelfContext) {\n+            o = ((EvalContext) o).getSingleNodePointer();\n+        }\n+        if (o instanceof Collection) {\n+            o = ((Collection) o).iterator();\n+        }\n+        return o;\n+    }\n+\n+    private boolean containsMatch(Iterator it, Object value) {\n+        while (it.hasNext()) {\n+            Object element = it.next();\n+            if (evaluateCompare(compare(element, value))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean findMatch(Iterator lit, Iterator rit) {\n+        HashSet left = new HashSet();\n+        while (lit.hasNext()) {\n+            left.add(lit.next());\n+        }\n+        while (rit.hasNext()) {\n+            if (containsMatch(left.iterator(), rit.next())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private int compare(Object l, Object r) {\n+        double ld = InfoSetUtil.doubleValue(l);\n+        double rd = InfoSetUtil.doubleValue(r);\n+        return ld == rd ? 0 : ld < rd ? -1 : 1;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n             context = JXPathContext.newContext(null);\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"integer\", new Integer(1));\n+            vars.declareVariable(\"array\", new double[] { 0.25, 0.5, 0.75 });\n         }\n     }\n \n \n         assertXPathValue(context, \"'true'\", Boolean.TRUE, Boolean.class);\n     }\n+\n+    public void testNodeSetOperations() {\n+        assertXPathValue(context, \"$array > 0\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array >= 0\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array = 0\", Boolean.FALSE, Boolean.class);\n+        assertXPathValue(context, \"$array = 0.25\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array = 0.5\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array = 0.50000\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array = 0.75\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array < 1\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array <= 1\", Boolean.TRUE, Boolean.class);\n+        assertXPathValue(context, \"$array = 1\", Boolean.FALSE, Boolean.class);\n+        assertXPathValue(context, \"$array > 1\", Boolean.FALSE, Boolean.class);\n+        assertXPathValue(context, \"$array < 0\", Boolean.FALSE, Boolean.class);\n+    }\n }", "timestamp": 1184104785, "metainfo": ""}