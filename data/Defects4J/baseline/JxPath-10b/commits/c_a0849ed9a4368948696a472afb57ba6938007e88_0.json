{"sha": "a0849ed9a4368948696a472afb57ba6938007e88", "log": "getParent() will now return the actual parent NodePointer,  not some intermediate helper NodePointer   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.39 $ $Date: 2004/03/02 01:32:20 $\n+ * @version $Revision: 1.40 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext {\n     \n                 // is going to have isActual == false, but its parent,\n                 // which is a non-node pointer identifying the bean property,\n                 // will return isActual() == true.\n-                NodePointer parent = ((NodePointer) result).getParent();\n+                NodePointer parent = \n+                    ((NodePointer) result).getImmediateParentPointer();\n                 if (parent == null\n                     || !parent.isContainer()\n                     || !parent.isActual()) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2004/02/29 14:17:37 $\n+ * @version $Revision: 1.15 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class AncestorContext extends EvalContext {\n     private NodeTest nodeTest;\n         }\n \n         while (true) {\n-            currentNodePointer = currentNodePointer.getParent();\n+            currentNodePointer = currentNodePointer.getImmediateParentPointer();\n \n             if (currentNodePointer == null) {\n                 return false;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2004/02/29 14:17:37 $\n+ * @version $Revision: 1.16 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class ChildContext extends EvalContext {\n     private NodeTest nodeTest;\n         }\n         if (startFromParentLocation) {\n             NodePointer pointer = parent.getParent();\n-            while (pointer != null && pointer.isContainer()) {\n-                pointer = pointer.getParent();\n-            }\n-\n             iterator = pointer.childIterator(nodeTest, reverse, parent);\n         }\n         else {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n  * EvalContext that walks the \"parent::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2004/02/29 14:17:37 $\n+ * @version $Revision: 1.15 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class ParentContext extends EvalContext {\n     private NodeTest nodeTest;\n         }\n         setStarted = true;\n         NodePointer thisLocation = parentContext.getCurrentNodePointer();\n-        currentNodePointer = thisLocation.getParent();\n+        currentNodePointer = thisLocation.getImmediateParentPointer();\n         while (currentNodePointer != null\n             && currentNodePointer.isContainer()) {\n-            currentNodePointer = currentNodePointer.getParent();\n+            currentNodePointer = currentNodePointer.getImmediateParentPointer();\n         }\n         if (currentNodePointer != null\n             && currentNodePointer.testNode(nodeTest)) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n  * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2004/02/29 14:17:38 $\n+ * @version $Revision: 1.15 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n         if (!setStarted) {\n             setStarted = true;\n             currentRootLocation = parentContext.getCurrentNodePointer();\n-            NodePointer parent =\n-                getMaterialPointer(currentRootLocation.getParent());\n+            NodePointer parent = currentRootLocation.getParent();\n             if (parent != null) {\n                 // TBD: check type\n                 stack.push(\n \n         while (true) {\n             if (stack.isEmpty()) {\n-                currentRootLocation =\n-                    getMaterialPointer(currentRootLocation.getParent());\n+                currentRootLocation = currentRootLocation.getParent();\n \n                 if (currentRootLocation == null\n                     || currentRootLocation.isRoot()) {\n                     break;\n                 }\n \n-                NodePointer parent =\n-                    getMaterialPointer(currentRootLocation.getParent());\n+                NodePointer parent = currentRootLocation.getParent();\n                 if (parent != null) {\n                     stack.push(\n                         parent.childIterator(\n         }\n         return false;\n     }\n-\n-    /**\n-     * If  the pointer is auxiliary, return the parent; otherwise - the pointer\n-     * itself\n-     */\n-    private NodePointer getMaterialPointer(NodePointer pointer) {\n-        while (pointer != null && pointer.isContainer()) {\n-            pointer = pointer.getParent();\n-        }\n-        return pointer;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n         int quality = PERFECT_MATCH;\n         while (pointer != null && !pointer.isActual()) {\n             quality--;\n-            pointer = pointer.getParent();\n+            pointer = pointer.getImmediateParentPointer();\n         }\n         return quality;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n  * attribute and only simple, context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.22 $ $Date: 2004/02/29 14:17:45 $\n+ * @version $Revision: 1.23 $ $Date: 2004/03/25 03:49:50 $\n  */\n public abstract class NodePointer implements Pointer {\n \n     }\n \n     public NodePointer getParent() {\n+        NodePointer pointer = parent;\n+        while (pointer != null && pointer.isContainer()) {\n+            pointer = pointer.getImmediateParentPointer();\n+        }\n+        return pointer;\n+    }\n+    \n+    public NodePointer getImmediateParentPointer() {\n         return parent;\n     }\n \n                     + pointer.getClass().getName()\n                     + \")\");\n         }\n-        if (pointer.getParent() != null) {\n-            printDeep(pointer.getParent(), indent + \"  \");\n+        if (pointer.getImmediateParentPointer() != null) {\n+            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.17 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.18 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n      */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        NodePointer parent = getParent();\n+        NodePointer parent = getImmediateParentPointer();\n         if (parent != null) {\n             buffer.append(parent.asPath());\n             if (index != WHOLE_COLLECTION) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n  * with index 2 (= 3 - 1) and a \"foo\" pointer as the parent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.16 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.17 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class NullElementPointer extends CollectionPointer {\n \n     }\n \n     public int hashCode() {\n-        return getParent().hashCode() + index;\n+        return getImmediateParentPointer().hashCode() + index;\n     }\n \n     public boolean equals(Object object) {\n         }\n \n         NullElementPointer other = (NullElementPointer) object;\n-        return getParent() == other.getParent() && index == other.index;\n+        return getImmediateParentPointer() == other.getImmediateParentPointer() \n+            && index == other.index;\n     }\n \n     public int getLength() {\n     \n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        NodePointer parent = getParent();\n+        NodePointer parent = getImmediateParentPointer();\n         if (parent != null) {\n             buffer.append(parent.asPath());\n         }\n             if (parent != null && parent.getIndex() != WHOLE_COLLECTION) {\n                 buffer.append(\"/.\");\n             }\n-            else if (\n-                parent != null\n-                    && parent.getParent() != null\n-                    && parent.getParent().getIndex() != WHOLE_COLLECTION) {\n+            else if (parent != null\n+                    && parent.getImmediateParentPointer() != null\n+                    && parent.getImmediateParentPointer().getIndex() != \n+                            WHOLE_COLLECTION) \n+            {\n                 buffer.append(\"/.\");\n             }\n             buffer.append(\"[\").append(index + 1).append(']');\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.17 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.18 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n         }\n         else {\n             StringBuffer buffer = new StringBuffer();\n-            buffer.append(getParent().asPath());\n+            buffer.append(getImmediateParentPointer().asPath());\n             buffer.append(\"[@name='\");\n             buffer.append(escape(getPropertyName()));\n             buffer.append(\"']\");\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n  * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.13 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class PropertyIterator implements NodeIterator {\n     private boolean empty = false;\n             this.startIndex = -1;\n         }\n         if (startWith != null) {\n-            while (startWith != null && startWith.getParent() != pointer) {\n-                startWith = startWith.getParent();\n+            while (startWith != null \n+                    && startWith.getImmediateParentPointer() != pointer) {\n+                startWith = startWith.getImmediateParentPointer();\n             }\n             if (startWith == null) {\n                 throw new JXPathException(\n         catch (Throwable ex) {\n             // @todo: should this exception be reported in any way?\n             NullPropertyPointer npp =\n-                new NullPropertyPointer(propertyNodePointer.getParent());\n+                new NullPropertyPointer(\n+                        propertyNodePointer.getImmediateParentPointer());\n             npp.setPropertyName(propertyNodePointer.getPropertyName());\n             npp.setIndex(propertyNodePointer.getIndex());\n             return npp.getValuePointer();\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n  * a property of the parent object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.13 $ $Date: 2004/03/25 03:49:50 $\n  */\n public abstract class PropertyPointer extends NodePointer {\n     public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n \n     public Object getBean() {\n         if (bean == null) {\n-            bean = getParent().getNode();\n+            bean = getImmediateParentPointer().getNode();\n         }\n         return bean;\n     }\n     }\n \n     public int hashCode() {\n-        return getParent().hashCode() + propertyIndex + index;\n+        return getImmediateParentPointer().hashCode() + propertyIndex + index;\n     }\n \n     public boolean equals(Object object) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2004/02/29 14:17:44 $\n+ * @version $Revision: 1.7 $ $Date: 2004/03/25 03:49:50 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n     \n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        buffer.append(getParent().asPath());\n+        buffer.append(getImmediateParentPointer().asPath());\n         if (buffer.length() == 0) {\n             buffer.append(\"/.\");\n         }\n--- a/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n         else {\n             System.err.println(\"UNKNOWN TYPE: \" + pointer.getClass());\n         }\n-        return pointerSignature(((NodePointer) pointer).getParent()) + type;\n+        NodePointer parent = \n+            ((NodePointer) pointer).getImmediateParentPointer();\n+        return pointerSignature(parent) + type;\n     }\n }\n ", "timestamp": 1080186590, "metainfo": ""}