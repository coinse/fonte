{"sha": "8778c3cbe1146ece404662cc9f2611a1c819b883", "log": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Modifier;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n      * Returns true if it can convert the supplied\n      * object to the specified class.\n      */\n-    public boolean canConvert(Object object, Class toType) {\n+    public boolean canConvert(Object object, final Class toType) {\n         if (object == null) {\n             return true;\n         }\n-\n-        if (toType == Object.class) {\n+        final Class useType = TypeUtils.wrapPrimitive(toType);\n+        Class fromType = object.getClass();\n+\n+        if (useType.isAssignableFrom(fromType)) {\n             return true;\n         }\n \n-        Class fromType = object.getClass();\n-        if (fromType.equals(toType)) {\n+        if (useType == String.class) {\n             return true;\n         }\n \n-        if (toType.isAssignableFrom(fromType)) {\n-            return true;\n-        }\n-\n-        if (toType == String.class) {\n-            return true;\n-        }\n-\n         if (object instanceof Boolean) {\n-            if (toType == boolean.class\n-                || Number.class.isAssignableFrom(toType)) {\n+            if (Number.class.isAssignableFrom(useType)\n+                    || \"java.util.concurrent.atomic.AtomicBoolean\"\n+                            .equals(useType.getName())) {\n                 return true;\n             }\n         }\n         if (object instanceof Number) {\n-            if (toType.isPrimitive()\n-                || Number.class.isAssignableFrom(toType)) {\n+            if (Number.class.isAssignableFrom(useType) || useType == Boolean.class) {\n                 return true;\n             }\n         }\n-        if (object instanceof Character) {\n-            if (toType == char.class) {\n-                return true;\n-            }\n-        }\n         if (object instanceof String) {\n-            if (toType.isPrimitive()) {\n-                return true;\n-            }\n-            if (toType == Boolean.class\n-                || toType == Character.class\n-                || toType == Byte.class\n-                || toType == Short.class\n-                || toType == Integer.class\n-                || toType == Long.class\n-                || toType == Float.class\n-                || toType == Double.class) {\n+            if (useType == Boolean.class\n+                || useType == Character.class\n+                || useType == Byte.class\n+                || useType == Short.class\n+                || useType == Integer.class\n+                || useType == Long.class\n+                || useType == Float.class\n+                || useType == Double.class) {\n                 return true;\n             }\n         }\n         if (fromType.isArray()) {\n             // Collection -> array\n-            if (toType.isArray()) {\n-                Class cType = toType.getComponentType();\n+            if (useType.isArray()) {\n+                Class cType = useType.getComponentType();\n                 int length = Array.getLength(object);\n                 for (int i = 0; i < length; i++) {\n                     Object value = Array.get(object, i);\n                 }\n                 return true;\n             }\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                return canCreateCollection(toType);\n+            if (Collection.class.isAssignableFrom(useType)) {\n+                return canCreateCollection(useType);\n             }\n             if (Array.getLength(object) > 0) {\n                 Object value = Array.get(object, 0);\n-                return canConvert(value, toType);\n-            }\n-            return canConvert(\"\", toType);\n+                return canConvert(value, useType);\n+            }\n+            return canConvert(\"\", useType);\n         }\n         if (object instanceof Collection) {\n             // Collection -> array\n-            if (toType.isArray()) {\n-                Class cType = toType.getComponentType();\n+            if (useType.isArray()) {\n+                Class cType = useType.getComponentType();\n                 Iterator it = ((Collection) object).iterator();\n                 while (it.hasNext()) {\n                     Object value = it.next();\n                 }\n                 return true;\n             }\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                return canCreateCollection(toType);\n+            if (Collection.class.isAssignableFrom(useType)) {\n+                return canCreateCollection(useType);\n             }\n             if (((Collection) object).size() > 0) {\n                 Object value;\n                     Iterator it = ((Collection) object).iterator();\n                     value = it.next();\n                 }\n-                return canConvert(value, toType);\n-            }\n-            return canConvert(\"\", toType);\n+                return canConvert(value, useType);\n+            }\n+            return canConvert(\"\", useType);\n         }\n         if (object instanceof NodeSet) {\n-            return canConvert(((NodeSet) object).getValues(), toType);\n+            return canConvert(((NodeSet) object).getValues(), useType);\n         }\n         if (object instanceof Pointer) {\n-            return canConvert(((Pointer) object).getValue(), toType);\n-        }\n-        return ConvertUtils.lookup(toType) != null;\n+            return canConvert(((Pointer) object).getValue(), useType);\n+        }\n+        return ConvertUtils.lookup(useType) != null;\n     }\n \n     /**\n      * type. Throws a runtime exception if the conversion is\n      * not possible.\n      */\n-    public Object convert(Object object, Class toType) {\n+    public Object convert(Object object, final Class toType) {\n         if (object == null) {\n             return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n         }\n             }\n             return object;\n         }\n-\n+        final Class useType = TypeUtils.wrapPrimitive(toType);\n         Class fromType = object.getClass();\n-        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n+\n+        if (useType.isAssignableFrom(fromType)) {\n             return object;\n         }\n \n         if (fromType.isArray()) {\n             int length = Array.getLength(object);\n-            if (toType.isArray()) {\n-                Class cType = toType.getComponentType();\n+            if (useType.isArray()) {\n+                Class cType = useType.getComponentType();\n \n                 Object array = Array.newInstance(cType, length);\n                 for (int i = 0; i < length; i++) {\n                 }\n                 return array;\n             }\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                Collection collection = allocateCollection(toType);\n+            if (Collection.class.isAssignableFrom(useType)) {\n+                Collection collection = allocateCollection(useType);\n                 for (int i = 0; i < length; i++) {\n                     collection.add(Array.get(object, i));\n                 }\n             }\n             if (length > 0) { \n                 Object value = Array.get(object, 0);\n-                return convert(value, toType);\n-            }\n-            return convert(\"\", toType);\n+                return convert(value, useType);\n+            }\n+            return convert(\"\", useType);\n         }\n         if (object instanceof Collection) {\n             int length = ((Collection) object).size();\n-            if (toType.isArray()) {\n-                Class cType = toType.getComponentType();\n+            if (useType.isArray()) {\n+                Class cType = useType.getComponentType();\n                 Object array = Array.newInstance(cType, length);\n                 Iterator it = ((Collection) object).iterator();\n                 for (int i = 0; i < length; i++) {\n                 }\n                 return array;\n             }\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                Collection collection = allocateCollection(toType);\n+            if (Collection.class.isAssignableFrom(useType)) {\n+                Collection collection = allocateCollection(useType);\n                 collection.addAll((Collection) object);\n                 return unmodifiableCollection(collection);\n             }\n                     Iterator it = ((Collection) object).iterator();\n                     value = it.next();\n                 }\n-                return convert(value, toType);\n-            }\n-            return convert(\"\", toType);\n+                return convert(value, useType);\n+            }\n+            return convert(\"\", useType);\n         }\n         if (object instanceof NodeSet) {\n-            return convert(((NodeSet) object).getValues(), toType);\n+            return convert(((NodeSet) object).getValues(), useType);\n         }\n         if (object instanceof Pointer) {\n-            return convert(((Pointer) object).getValue(), toType);\n-        }\n-        if (toType == String.class) {\n+            return convert(((Pointer) object).getValue(), useType);\n+        }\n+        if (useType == String.class) {\n             return object.toString();\n         }\n         if (object instanceof Boolean) {\n-            if (toType == boolean.class) {\n-                return object;\n-            }\n-            if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-                boolean value = ((Boolean) object).booleanValue();\n-                return allocateNumber(toType, value ? 1 : 0);\n+            if (Number.class.isAssignableFrom(useType)) {\n+                return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);\n+            }\n+            if (\"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n+                try {\n+                    return useType.getConstructor(new Class[] { boolean.class })\n+                            .newInstance(new Object[] { object });\n+                } catch (Exception e) {\n+                    throw new JXPathTypeConversionException(useType.getName(), e);\n+                }\n             }\n         }\n         if (object instanceof Number) {\n             double value = ((Number) object).doubleValue();\n-            if (toType == boolean.class || toType == Boolean.class) {\n+            if (useType == Boolean.class) {\n                 return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n             }\n-            if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-                return allocateNumber(toType, value);\n-            }\n-        }\n-        if (object instanceof Character) {\n-            if (toType == char.class) {\n-                return object;\n+            if (Number.class.isAssignableFrom(useType)) {\n+                return allocateNumber(useType, value);\n             }\n         }\n         if (object instanceof String) {\n-            Object value = convertStringToPrimitive(object, toType);\n+            Object value = convertStringToPrimitive(object, useType);\n             if (value != null) {\n                 return value;\n             }\n         }\n \n-        Converter converter = ConvertUtils.lookup(toType);\n+        Converter converter = ConvertUtils.lookup(useType);\n         if (converter != null) {\n-            return converter.convert(toType, object);\n+            return converter.convert(useType, object);\n         }\n \n         throw new JXPathTypeConversionException(\"Cannot convert \"\n-                + object.getClass() + \" to \" + toType);\n+                + object.getClass() + \" to \" + useType);\n     }\n \n     protected Object convertNullToPrimitive(Class toType) {\n     }\n \n     protected Object convertStringToPrimitive(Object object, Class toType) {\n-        if (toType == boolean.class || toType == Boolean.class) {\n+        toType = TypeUtils.wrapPrimitive(toType);\n+        if (toType == Boolean.class) {\n             return Boolean.valueOf((String) object);\n         }\n-        if (toType == char.class || toType == Character.class) {\n+        if (toType == Character.class) {\n             return new Character(((String) object).charAt(0));\n         }\n-        if (toType == byte.class || toType == Byte.class) {\n+        if (toType == Byte.class) {\n             return new Byte((String) object);\n         }\n-        if (toType == short.class || toType == Short.class) {\n+        if (toType == Short.class) {\n             return new Short((String) object);\n         }\n-        if (toType == int.class || toType == Integer.class) {\n+        if (toType == Integer.class) {\n             return new Integer((String) object);\n         }\n-        if (toType == long.class || toType == Long.class) {\n+        if (toType == Long.class) {\n             return new Long((String) object);\n         }\n-        if (toType == float.class || toType == Float.class) {\n+        if (toType == Float.class) {\n             return new Float((String) object);\n         }\n-        if (toType == double.class || toType == Double.class) {\n+        if (toType == Double.class) {\n             return new Double((String) object);\n         }\n         return null;\n     }\n     \n     protected Number allocateNumber(Class type, double value) {\n-        if (type == Byte.class || type == byte.class) {\n+        type = TypeUtils.wrapPrimitive(type);\n+        if (type == Byte.class) {\n             return new Byte((byte) value);\n         }\n-        if (type == Short.class || type == short.class) {\n+        if (type == Short.class) {\n             return new Short((short) value);\n         }\n-        if (type == Integer.class || type == int.class) {\n+        if (type == Integer.class) {\n             return new Integer((int) value);\n         }\n-        if (type == Long.class || type == long.class) {\n+        if (type == Long.class) {\n             return new Long((long) value);\n         }\n-        if (type == Float.class || type == float.class) {\n+        if (type == Float.class) {\n             return new Float((float) value);\n         }\n-        if (type == Double.class || type == double.class) {\n+        if (type == Double.class) {\n             return new Double(value);\n+        }\n+        if (type == BigInteger.class) {\n+            return BigInteger.valueOf((long) value);\n+        }\n+        if (type == BigDecimal.class) {\n+            return new BigDecimal(value);\n+        }\n+        String classname = type.getName();\n+        Class initialValueType = null;\n+        if (\"java.util.concurrent.atomic.AtomicInteger\".equals(classname)) {\n+            initialValueType = int.class;\n+        }\n+        if (\"java.util.concurrent.atomic.AtomicLong\".equals(classname)) {\n+            initialValueType = long.class;\n+        }\n+        if (initialValueType != null) {\n+            try {\n+                return (Number) type.getConstructor(\n+                        new Class[] { initialValueType })\n+                        .newInstance(\n+                                new Object[] { allocateNumber(initialValueType,\n+                                        value) });\n+            } catch (Exception e) {\n+                throw new JXPathTypeConversionException(classname, e);\n+            }\n         }\n         return null;\n     }\n \n     protected boolean canCreateCollection(Class type) {\n         if (!type.isInterface()\n-            && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) {\n-            return true;\n-        }\n-\n-        if (type == List.class) {\n-            return true;\n-        }\n-\n-        if (type == Set.class) {\n-            return true;\n-        }\n-        return false;\n+                && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) {\n+            try {\n+                type.getConstructor(new Class[0]);\n+                return true;\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return type == List.class || type == Collection.class || type == Set.class;\n     }\n \n     protected Collection allocateCollection(Class type) {\n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n  */\n package org.apache.commons.jxpath.util;\n \n+import java.util.HashMap;\n+\n /**\n  * Global type conversion utilities.\n  *\n  */\n public class TypeUtils {\n     private static TypeConverter typeConverter = new BasicTypeConverter();\n+    private static final HashMap PRIMITIVE_TYPE_MAP = new HashMap() {\n+        {\n+            put(int.class, Integer.class);\n+            put(byte.class, Byte.class);\n+            put(short.class, Short.class);\n+            put(char.class, Character.class);\n+            put(long.class, Long.class);\n+            put(float.class, Float.class);\n+            put(double.class, Double.class);\n+            put(boolean.class, Boolean.class);\n+        }\n+    };\n \n     /**\n      * Install an alternative type converter.\n     public static Object convert(Object object, Class toType) {\n         return typeConverter.convert(object, toType);\n     }\n+\n+    /**\n+     * Return the appropriate wrapper type for the specified class.\n+     * @param p Class for which to retrieve a wrapper class.\n+     * @return the wrapper if <code>p</code> is primitive, else <code>p</code>.\n+     * @since JXPath 1.3\n+     */\n+    public static Class wrapPrimitive(Class p) {\n+        return p.isPrimitive() ? (Class) PRIMITIVE_TYPE_MAP.get(p) : p;\n+    }\n }", "timestamp": 1183493231, "metainfo": ""}