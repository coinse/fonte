{"sha": "48e1a07f2923036311b3ecc0ac90f4eb812d805d", "log": "Added JDOM support   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.20 2002/08/10 01:30:39 dmitri Exp $\n- * $Revision: 1.20 $\n- * $Date: 2002/08/10 01:30:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.21 2002/08/26 22:29:49 dmitri Exp $\n+ * $Revision: 1.21 $\n+ * $Date: 2002/08/26 22:29:49 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.20 $ $Date: 2002/08/10 01:30:39 $\n+ * @version $Revision: 1.21 $ $Date: 2002/08/26 22:29:49 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n         if (domFactory != null){\n             nodeFactories.add(domFactory);\n         }\n-/* TBD\n+\n         Object jdomFactory = allocateConditionally(\n                 \"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory\",\n                 \"org.jdom.Document\");\n         if (jdomFactory != null){\n             nodeFactories.add(jdomFactory);\n         }\n-*/\n+\n         nodeFactories.add(new ContainerPointerFactory());\n         createNodeFactoryArray();\n     }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.jdom.*;\n+\n+/**\n+ * An iterator of attributes of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMAttributeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private QName name;\n+    private List attributes;\n+    private int position = 0;\n+\n+    public JDOMAttributeIterator(NodePointer parent, QName name){\n+        this.parent = parent;\n+        this.name = name;\n+        if (parent.getNode() instanceof Element){\n+            Element element = (Element)parent.getNode();\n+//            System.err.println(\"ELEMENT: \" + element.getName());\n+//            List a = element.getAttributes();\n+//            for (int i = 0; i < a.size(); i++){\n+//                Attribute x = (Attribute)a.get(i);\n+//                System.err.println(\"ATTR: \" + x.getName() + \" \" + x.getNamespace());\n+//            }\n+            String prefix = name.getPrefix();\n+            Namespace ns;\n+            if (prefix != null){\n+                if (prefix.equals(\"xml\")){\n+                    ns = Namespace.XML_NAMESPACE;\n+                }\n+                else {\n+                    ns = element.getNamespace(prefix);\n+                    if (ns == null){\n+                        // TBD: no attributes\n+                        attributes = Collections.EMPTY_LIST;\n+                        return;\n+                    }\n+                }\n+            }\n+            else {\n+                ns = Namespace.NO_NAMESPACE;\n+            }\n+\n+            String lname = name.getName();\n+            if (!lname.equals(\"*\")){\n+                attributes = new ArrayList();\n+                if (ns != null){\n+                    Attribute attr = element.getAttribute(lname, ns);\n+//                    System.err.println(\"LNAME=\" + lname + \"  NS: \" + ns + \" ATTR: \" + attr);\n+                    if (attr != null){\n+                        attributes.add(attr);\n+                    }\n+                }\n+            }\n+            else {\n+                attributes = new ArrayList();\n+                List allAttributes = element.getAttributes();\n+                for (int i = 0; i < allAttributes.size(); i++){\n+                    Attribute attr = (Attribute)allAttributes.get(i);\n+                    if (attr.getNamespace().equals(ns)){\n+                        attributes.add(attr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+    private boolean testAttr(Attr attr, QName testName){\n+        String nodePrefix = DOMNodePointer.getPrefix(attr);\n+        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n+\n+        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        String testLocalName = name.getName();\n+        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)){\n+            String testPrefix = testName.getPrefix();\n+\n+            if (equalStrings(testPrefix, nodePrefix)){\n+                return true;\n+            }\n+\n+            String testNS = null;\n+            if (testPrefix != null){\n+                testNS = parent.getNamespaceURI(testPrefix);\n+            }\n+\n+            String nodeNS = null;\n+            if (nodePrefix != null){\n+                nodeNS = parent.getNamespaceURI(nodePrefix);\n+            }\n+            return equalStrings(testNS, nodeNS);\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private Attr getAttribute(Element element, QName name){\n+        String testPrefix = name.getPrefix();\n+        String testNS = null;\n+\n+        if (testPrefix != null){\n+            testNS = parent.getNamespaceURI(testPrefix);\n+        }\n+\n+        if (testNS != null){\n+            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n+            if (attr == null){\n+                // This may mean that the parser does not support NS for\n+                // attributes, example - the version of Crimson bundled\n+                // with JDK 1.4.0\n+                NamedNodeMap nnm = element.getAttributes();\n+                for (int i = 0; i < nnm.getLength(); i++){\n+                    attr = (Attr)nnm.item(i);\n+                    if (testAttr(attr, name)){\n+                        return attr;\n+                    }\n+                }\n+            }\n+            return attr;\n+        }\n+        else {\n+            return element.getAttributeNode(name.getName());\n+        }\n+    }\n+*/\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        return new JDOMAttributePointer(parent, (Attribute)attributes.get(index));\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (attributes == null){\n+            return false;\n+        }\n+        this.position = position;\n+        return position >= 1 && position <= attributes.size();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.TypeUtils;\n+import org.jdom.Attribute;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMAttributePointer extends NodePointer {\n+    private Attribute attr;\n+\n+    public JDOMAttributePointer(NodePointer parent, Attribute attr){\n+        super(parent);\n+        this.attr = attr;\n+    }\n+\n+    public QName getName(){\n+        return new QName(JDOMNodePointer.getPrefix(attr), JDOMNodePointer.getLocalName(attr));\n+    }\n+\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(),  attr.getName());\n+    }\n+\n+    public String getNamespaceURI(){\n+        String uri = attr.getNamespaceURI();\n+        if (uri != null && uri.equals(\"\")){\n+            uri = null;\n+        }\n+        return uri;\n+//        String prefix = DOMNodePointer.getPrefix(attr);\n+//        if (prefix == null){\n+//            return null;\n+//        }\n+//        return parent.getNamespaceURI(prefix);\n+    }\n+\n+    public Object getBaseValue(){\n+        return attr;\n+    }\n+\n+    public Object getNode(){\n+        String value = attr.getValue();\n+        if (value == null){\n+            return null;\n+        }\n+//        if (value.equals(\"\") && !attr.getSpecified()){\n+//            return null;\n+//        }\n+        return value;\n+    }\n+\n+    public boolean isActual(){\n+        return true;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+//    public boolean testNode(NodeTest nodeTest){\n+//        return nodeTest == null ||\n+//                ((nodeTest instanceof NodeTypeTest) &&\n+//                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+//    }\n+\n+    /**\n+     * Sets the value of this attribute.\n+     */\n+    public void setValue(Object value){\n+        attr.setValue((String)TypeUtils.convert(value, String.class));\n+    }\n+\n+    public void remove(){\n+        attr.getParent().removeAttribute(attr);\n+    }\n+\n+    /**\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append('@');\n+        buffer.append(getName());\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(attr);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof JDOMAttributePointer)){\n+            return false;\n+        }\n+\n+        JDOMAttributePointer other = (JDOMAttributePointer)object;\n+        return attr == other.attr;\n+    }\n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        // Won't happen - attributes don't have children\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.jdom.*;\n+\n+/**\n+ * An iterator of namespaces of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMNamespaceIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private List namespaces;\n+    private Set prefixes;\n+    private int position = 0;\n+\n+    public JDOMNamespaceIterator(NodePointer parent){\n+        this.parent = parent;\n+        Object node = parent.getNode();\n+        if (node instanceof Element){\n+            namespaces = new ArrayList();\n+            prefixes = new HashSet();\n+            collectNamespaces((Element)parent.getNode());\n+//            System.err.println(\"NAMESPACES: \" + namespaces);\n+        }\n+    }\n+\n+    private void collectNamespaces(Element element){\n+//            NamedNodeMap map = node.getAttributes();\n+//            int count = map.getLength();\n+//            for (int i = 0; i < count; i++){\n+//                Attr attr = (Attr)map.item(i);\n+//                String prefix = DOMNodePointer.getPrefix(attr);\n+//                String name = DOMNodePointer.getLocalName(attr);\n+//                if ((prefix != null && prefix.equals(\"xmlns\")) ||\n+//                        (prefix == null && name.equals(\"xmlns\"))){\n+//                    attributes.add(attr);\n+//                }\n+//            }\n+        Namespace ns = element.getNamespace();\n+        if (ns != null && !prefixes.contains(ns.getPrefix())){\n+            namespaces.add(ns);\n+            prefixes.add(ns.getPrefix());\n+        }\n+        List others = element.getAdditionalNamespaces();\n+        for (int i = 0; i < others.size(); i++){\n+            ns = (Namespace)others.get(i);\n+            if (ns != null && !prefixes.contains(ns.getPrefix())){\n+                namespaces.add(ns);\n+                prefixes.add(ns.getPrefix());\n+            }\n+        }\n+        Element parent = element.getParent();\n+        if (parent != null){\n+            collectNamespaces(parent);\n+        }\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        String prefix = \"\";\n+        Namespace ns = (Namespace)namespaces.get(index);\n+//        String name = attr.getPrefix();\n+//        if (name != null && name.equals(\"xmlns\")){\n+//            prefix = JDOMNodePointer.getLocalName(attr);\n+//        }\n+        return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position >= 1 && position <= namespaces.size();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * Represents a namespace node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMNamespacePointer extends NodePointer {\n+    private String prefix;\n+    private String namespaceURI;\n+\n+    public JDOMNamespacePointer(NodePointer parent, String prefix){\n+        super(parent);\n+        this.prefix = prefix;\n+    }\n+\n+    public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI){\n+        super(parent);\n+        this.prefix = prefix;\n+        this.namespaceURI = namespaceURI;\n+    }\n+\n+    public QName getName(){\n+        return new QName(getNamespaceURI(), prefix);\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public Object getNode(){\n+        return getNamespaceURI();\n+    }\n+\n+    public String getNamespaceURI(){\n+        if (namespaceURI == null){\n+            namespaceURI = parent.getNamespaceURI(prefix);\n+        }\n+        return namespaceURI;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot modify a namespace\");\n+    }\n+\n+    /*\n+    public boolean testNode(NodeTest nodeTest){\n+        return nodeTest == null ||\n+                ((nodeTest instanceof NodeTypeTest) &&\n+                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    }\n+*/\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append(\"namespace::\");\n+        buffer.append(prefix);\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        return prefix.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof JDOMNamespacePointer)){\n+            return false;\n+        }\n+\n+        JDOMNamespacePointer other = (JDOMNamespacePointer)object;\n+        return prefix.equals(other.prefix);\n+    }\n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        // Won't happen - namespaces don't have children\n+        return 0;\n+    }\n+ }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.jdom.Document;\n+import org.jdom.Element;\n+\n+/**\n+ * An iterator of children of a JDOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMNodeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private NodeTest nodeTest;\n+\n+    private boolean reverse;\n+    private int position = 0;\n+    private int index = 0;\n+//    private Element node;\n+    private List children;\n+    private Object child;\n+\n+    public JDOMNodeIterator(\n+            NodePointer parent, NodeTest nodeTest, \n+            boolean reverse, NodePointer startWith)\n+    {\n+        this.parent = parent;\n+        if (startWith != null){\n+            this.child = startWith.getNode();\n+        }\n+        // TBD: optimize me for different node tests\n+        Object node = parent.getNode();\n+        if (node instanceof Document){\n+            this.children = ((Document)node).getContent();\n+        }\n+        else if (node instanceof Element){\n+            this.children = ((Element)node).getContent();\n+        }\n+        else {\n+            this.children = Collections.EMPTY_LIST;\n+        }\n+        this.nodeTest = nodeTest;\n+        this.reverse = reverse;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (child == null){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+\n+        return new JDOMNodePointer(parent, child);\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        while (this.position > position){\n+            if (!previous()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean previous(){\n+        System.err.println(\"PREVIOUS\");     // TBD\n+//        position--;\n+//        if (!reverse){\n+//            child = child.getPreviousSibling();\n+//            while (child != null && !testChild()){\n+//                child = child.getPreviousSibling();\n+//            }\n+//        }\n+//        else {\n+//            child = child.getNextSibling();\n+//            while (child != null && !testChild()){\n+//                child = child.getNextSibling();\n+//            }\n+//        }\n+//        return child != null;\n+        return false;\n+    }\n+\n+    private boolean next(){\n+        position++;\n+        if (!reverse){\n+            if (position == 1){\n+                index = 0;\n+                if (child != null){\n+                    index = children.indexOf(child) + 1;\n+                }\n+            }\n+            else {\n+                index++;\n+            }\n+            for (;index < children.size(); index++){\n+                child = children.get(index);\n+                if (testChild()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        else {\n+            if (position == 1){\n+                index = children.size() - 1;\n+                if (child != null){\n+                    index = children.indexOf(child) - 1;\n+                }\n+            }\n+            else {\n+                index--;\n+            }\n+            for (;index >= 0; index--){\n+                child = children.get(index);\n+                if (testChild()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private boolean testChild(){\n+        return JDOMNodePointer.testNode(parent, child, nodeTest);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n+import org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.TypeUtils;\n+import org.jdom.Attribute;\n+import org.jdom.CDATA;\n+import org.jdom.Comment;\n+import org.jdom.Element;\n+import org.jdom.Namespace;\n+import org.jdom.ProcessingInstruction;\n+import org.jdom.Text;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMNodePointer extends NodePointer {\n+    private Object node;\n+    private Map namespaces;\n+    private String defaultNamespace;\n+    private String id;\n+\n+    public static final String XML_NAMESPACE_URI =\n+            \"http://www.w3.org/XML/1998/namespace\";\n+    public static final String XMLNS_NAMESPACE_URI =\n+            \"http://www.w3.org/2000/xmlns/\";\n+\n+    public JDOMNodePointer(Object node, Locale locale){\n+        super(null, locale);\n+        this.node = node;\n+    }\n+\n+    public JDOMNodePointer(Object node, Locale locale, String id){\n+        super(null, locale);\n+        this.node = node;\n+        this.id = id;\n+    }\n+\n+    public JDOMNodePointer(NodePointer parent, Object node){\n+        super(parent);\n+        this.node = node;\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse,\n+                    NodePointer startWith) {\n+        return new JDOMNodeIterator(this, test, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return new JDOMAttributeIterator(this, name);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return new JDOMNamespaceIterator(this);\n+    }\n+\n+    public NodePointer namespacePointer(String prefix){\n+        return new JDOMNamespacePointer(this, prefix);\n+    }\n+\n+    public String getNamespaceURI(){\n+        if (node instanceof Element){\n+            Element element = (Element)node;\n+            return element.getNamespaceURI();\n+        }\n+        return null;\n+    }\n+\n+    public String getNamespaceURI(String prefix){\n+        if (node instanceof Element){\n+            Element element = (Element)node;\n+            Namespace ns = element.getNamespace(prefix);\n+//            System.err.println(\"PREFIX: \" + prefix + \" NS: \" + ns);\n+            if (ns == null){\n+                return null;\n+            }\n+            return ns.getURI();\n+        }\n+        return null;\n+    }\n+\n+    public int compareChildNodePointers(\n+                NodePointer pointer1, NodePointer pointer2)\n+    {\n+        Object node1 = pointer1.getBaseValue();\n+        Object node2 = pointer2.getBaseValue();\n+        if (node1 == node2){\n+            return 0;\n+        }\n+\n+        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)){\n+            return -1;\n+        }\n+        else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)){\n+            return 1;\n+        }\n+        else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)){\n+            List list = ((Element)getNode()).getAttributes();\n+            int length = list.size();\n+            for (int i = 0; i < length; i++){\n+                Object n = list.get(i);\n+                if (n == node1){\n+                    return -1;\n+                }\n+                else if (n == node2){\n+                    return 1;\n+                }\n+            }\n+            return 0;       // Should not happen\n+        }\n+\n+        if (!(node instanceof Element)){\n+            throw new RuntimeException(\"JXPath internal error: \" +\n+                    \"compareChildNodes called for \" + node);\n+        }\n+\n+        List children = ((Element)node).getContent();\n+        int length = children.size();\n+        for (int i = 0; i < length; i++){\n+            Object n = children.get(i);\n+            if (n == node1){\n+                return -1;\n+            }\n+            else if (n == node2){\n+                return 1;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n+\n+    /**\n+     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n+     */\n+    public Object getBaseValue() {\n+        return node;\n+    }\n+\n+\n+    /**\n+     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n+     */\n+    public QName getName() {\n+        String ns = null;\n+        String ln = null;\n+        if (node instanceof Element){\n+            ns = ((Element)node).getNamespacePrefix();\n+            if (ns != null && ns.equals(\"\")){\n+                ns = null;\n+            }\n+            ln = ((Element)node).getName();\n+        }\n+        else if (node instanceof ProcessingInstruction){\n+            ln = ((ProcessingInstruction)node).getTarget();\n+        }\n+        return new QName(ns, ln);\n+    }\n+\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(), getName().getName());\n+    }\n+\n+    /**\n+     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n+     */\n+    public Object getNode() {\n+        return node;\n+    }\n+\n+    public Object getValue(){\n+        if (node instanceof Element){\n+            return ((Element)node).getTextTrim();\n+        }\n+        else if (node instanceof Comment){\n+            String text = ((Comment)node).getText();\n+            if (text != null){\n+                text = text.trim();\n+            }\n+            return text;\n+        }\n+        else if (node instanceof Text){\n+            return ((Text)node).getTextTrim();\n+        }\n+        else if (node instanceof CDATA){\n+            return ((CDATA)node).getTextTrim();\n+        }\n+        else if (node instanceof ProcessingInstruction){\n+            String text = ((ProcessingInstruction)node).getData();\n+            if (text != null){\n+                text = text.trim();\n+            }\n+            return text;\n+        }\n+        return null;\n+    }\n+\n+\n+    /**\n+     * @see org.apache.commons.jxpath.Pointer#setValue(Object)\n+     */\n+    public void setValue(Object value) {\n+        String string = null;\n+        if (value != null){\n+            string = (String)TypeUtils.convert(value, String.class);\n+            if (string.equals(\"\")){\n+                string = null;\n+            }\n+        }\n+\n+        if (node instanceof Text){\n+            if (string != null){\n+                ((Text)node).setText(string);\n+            }\n+            else {\n+                nodeParent(node).removeContent((Text)node);\n+            }\n+        }\n+        else {\n+            Element element = (Element)node;\n+            // First remove all text from the element\n+            List content = new ArrayList(element.getContent());\n+            for (int i = content.size(); --i >= 0;){\n+                Object child = content.get(i);\n+                if (child instanceof Text){\n+                    element.removeContent((Text)node);\n+                }\n+                else if (child instanceof CDATA){\n+                    element.removeContent((CDATA)node);\n+                }\n+            }\n+            if (string != null){\n+                element.addContent(new Text(string));\n+            }\n+        }\n+    }\n+\n+    public boolean testNode(NodeTest test){\n+        return testNode(this, node, test);\n+    }\n+\n+    public static boolean testNode(\n+            NodePointer pointer, Object node, NodeTest test)\n+    {\n+        if (test == null){\n+            return true;\n+        }\n+        else if (test instanceof NodeNameTest){\n+            if (!(node instanceof Element)){\n+                return false;\n+            }\n+\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\") ||\n+                    testLocalName.equals(\n+                            JDOMNodePointer.getLocalName((Element)node))){\n+                String testPrefix = testName.getPrefix();\n+                String nodePrefix = JDOMNodePointer.getPrefix((Element)node);\n+                if (equalStrings(testPrefix, nodePrefix)){\n+                    return true;\n+                }\n+\n+                String testNS = pointer.getNamespaceURI(testPrefix);\n+                if (testNS == null){\n+                    return false;\n+                }\n+                String nodeNS = pointer.getNamespaceURI(nodePrefix);\n+                return equalStrings(testNS, nodeNS);\n+            }\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            switch (((NodeTypeTest)test).getNodeType()){\n+                case Compiler.NODE_TYPE_NODE:\n+                    return node instanceof Element;\n+                case Compiler.NODE_TYPE_TEXT:\n+                    return (node instanceof Text) ||\n+                        (node instanceof CDATA);\n+                case Compiler.NODE_TYPE_COMMENT:\n+                    return node instanceof Comment;\n+                case Compiler.NODE_TYPE_PI:\n+                    return node instanceof ProcessingInstruction;\n+            }\n+            return false;\n+        }\n+        else if (test instanceof ProcessingInstructionTest){\n+            if (node instanceof ProcessingInstruction){\n+                String testPI = ((ProcessingInstructionTest)test).getTarget();\n+                String nodePI = ((ProcessingInstruction)node).getTarget();\n+                return testPI.equals(nodePI);\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && s2 == null){\n+            return false;\n+        }\n+\n+        if (s1 != null && !s1.trim().equals(s2.trim())){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public static String getPrefix(Object node){\n+        if (node instanceof Element){\n+            String prefix = ((Element)node).getNamespacePrefix();\n+            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n+        }\n+        else if (node instanceof Attribute){\n+            String prefix = ((Attribute)node).getNamespacePrefix();\n+            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n+        }\n+        return null;\n+    }\n+\n+    public static String getLocalName(Object node){\n+        if (node instanceof Element){\n+            return ((Element)node).getName();\n+        }\n+        else if (node instanceof Attribute){\n+            return ((Attribute)node).getName();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns true if the xml:lang attribute for the current node\n+     * or its parent has the specified prefix <i>lang</i>.\n+     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n+     */\n+    public boolean isLanguage(String lang){\n+        String current = getLanguage();\n+        if (current == null){\n+            return super.isLanguage(lang);\n+        }\n+        return current.toUpperCase().startsWith(lang.toUpperCase());\n+    }\n+\n+    protected String getLanguage(){\n+        Object n = node;\n+        while (n != null){\n+            if (n instanceof Element){\n+                Element e = (Element)n;\n+                String attr = e.getAttributeValue(\"lang\",\n+                        Namespace.XML_NAMESPACE);\n+                if (attr != null && !attr.equals(\"\")){\n+                    return attr;\n+                }\n+            }\n+            n = nodeParent(n);\n+        }\n+        return null;\n+    }\n+\n+    private Element nodeParent(Object node){\n+        if (node instanceof Element){\n+            return ((Element)node).getParent();\n+        }\n+        else if (node instanceof Text){\n+            return ((Text)node).getParent();\n+        }\n+        else if (node instanceof CDATA){\n+            return ((CDATA)node).getParent();\n+        }\n+        else if (node instanceof ProcessingInstruction){\n+            return ((ProcessingInstruction)node).getParent();\n+        }\n+        else if (node instanceof Comment){\n+            return ((Comment)node).getParent();\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createChild(\n+            JXPathContext context, QName name, int index)\n+    {\n+        if (index == WHOLE_COLLECTION){\n+            index = 0;\n+        }\n+        if (!getAbstractFactory(context).\n+                    createObject(context, this, node, name.toString(), index)){\n+            throw new JXPathException(\"Factory could not create \" +\n+                    \"a child node for path: \" +\n+                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n+        }\n+        NodeIterator it = childIterator(new NodeNameTest(name), false, null);\n+        if (it == null || !it.setPosition(index + 1)){\n+            throw new JXPathException(\"Factory could not create \" +\n+                    \"a child node for path: \" +\n+                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n+        }\n+        return it.getNodePointer();\n+    }\n+\n+    public NodePointer createChild(\n+            JXPathContext context, QName name, int index, Object value)\n+    {\n+        NodePointer ptr = createChild(context, name, index);\n+        ptr.setValue(value);\n+        return ptr;\n+    }\n+\n+    public void remove(){\n+        Element parent = nodeParent(node);\n+        if (parent == null){\n+            throw new JXPathException(\"Cannot remove root JDOM node\");\n+        }\n+        parent.getContent().remove(node);\n+    }\n+\n+    public String asPath(){\n+        if (id != null){\n+            return \"id('\" + escape(id) + \"')\";\n+        }\n+\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+        }\n+        if (node instanceof Element){\n+            // If the parent pointer is not a JDOMNodePointer, it is\n+            // the parent's responsibility to produce the node test part\n+            // of the path\n+            if (parent instanceof JDOMNodePointer){\n+                buffer.append('/');\n+                buffer.append(getName());\n+                buffer.append('[');\n+                buffer.append(getRelativePositionByName());\n+                buffer.append(']');\n+            }\n+        }\n+        else if (node instanceof Text || node instanceof CDATA){\n+            buffer.append(\"/text()\");\n+            buffer.append('[').\n+                    append(getRelativePositionOfTextNode()).\n+                    append(']');\n+        }\n+        else if (node instanceof ProcessingInstruction){\n+            String target = ((ProcessingInstruction)node).getTarget();\n+            buffer.append(\"/processing-instruction(\\'\").\n+                    append(target).\n+                    append(\"')\");\n+            buffer.append('[').\n+                    append(getRelativePositionOfPI(target)).\n+                    append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) +\n+                    \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) +\n+                    \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n+\n+    private int getRelativePositionByName(){\n+        if (node instanceof Element){\n+            Element parent = ((Element)node).getParent();\n+            if (parent == null){\n+                return 1;\n+            }\n+            List children = parent.getContent();\n+            int count = 0;\n+            String name = ((Element)node).getQualifiedName();\n+            for (int i = 0; i < children.size(); i++){\n+                Object child = children.get(i);\n+                if ((child instanceof Element) &&\n+                    ((Element)child).getQualifiedName().equals(name)){\n+                    count++;\n+                }\n+                if (child == node){\n+                    break;\n+                }\n+            }\n+            return count;\n+        }\n+        return 1;\n+    }\n+\n+    private int getRelativePositionOfTextNode(){\n+        Element parent;\n+        if (node instanceof Text){\n+            parent = ((Text)node).getParent();\n+        }\n+        else {\n+            parent = ((CDATA)node).getParent();\n+        }\n+        if (parent == null){\n+            return 1;\n+        }\n+        List children = parent.getContent();\n+        int count = 0;\n+        for (int i = 0; i < children.size(); i++){\n+            Object child = children.get(i);\n+            if (child instanceof Text || child instanceof CDATA){\n+                count++;\n+            }\n+            if (child == node){\n+                break;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private int getRelativePositionOfPI(String target){\n+        Element parent = ((ProcessingInstruction)node).getParent();\n+        if (parent == null){\n+            return 1;\n+        }\n+        List children = parent.getContent();\n+        int count = 0;\n+        for (int i = 0; i < children.size(); i++){\n+            Object child = children.get(i);\n+            if (child instanceof ProcessingInstruction &&\n+                  (target == null ||\n+                   target.equals(((ProcessingInstruction)child).getTarget()))){\n+                count++;\n+            }\n+            if (child == node){\n+                break;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(node);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof JDOMNodePointer)){\n+            return false;\n+        }\n+\n+        JDOMNodePointer other = (JDOMNodePointer)object;\n+        return node == other.node;\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new JXPathException(\n+                    \"Factory is not set on the JXPathContext - \" +\n+                    \"cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:48 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+import org.jdom.Document;\n+import org.jdom.Element;\n+\n+/**\n+ * Implements NodePointerFactory for DOM elements.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ */\n+public class JDOMPointerFactory implements NodePointerFactory {\n+\n+    public static final int JDOM_POINTER_FACTORY_ORDER = 110;\n+\n+    public int getOrder(){\n+        return JDOM_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(\n+            QName name, Object bean, Locale locale)\n+    {\n+        if (bean instanceof Document){\n+            return new JDOMNodePointer(bean, locale);\n+        }\n+        else if (bean instanceof Element){\n+            return new JDOMNodePointer(bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(\n+            NodePointer parent, QName name, Object bean)\n+    {\n+        if (bean instanceof Document){\n+            return new JDOMNodePointer(parent, bean);\n+        }\n+        else if (bean instanceof Element){\n+            return new JDOMNodePointer(parent, bean);\n+        }\n+        return null;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java,v 1.1 2002/08/10 01:28:49 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/10 01:28:49 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java,v 1.2 2002/08/26 22:29:49 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/08/26 22:29:49 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * read at all.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/10 01:28:49 $\n+ * @version $Revision: 1.2 $ $Date: 2002/08/26 22:29:49 $\n  */\n public class DocumentContainer implements Container {\n \n     public static final String MODEL_DOM = \"DOM\";\n-//    public static final String MODEL_JDOM = \"JDOM\";\n+    public static final String MODEL_JDOM = \"JDOM\";\n \n     private Object document;\n     private URL xmlURL;\n     private String model;\n-    \n+\n     private static HashMap parserClasses = new HashMap();\n     static {\n-        parserClasses.put(MODEL_DOM, \n+        parserClasses.put(MODEL_DOM,\n                           \"org.apache.commons.jxpath.xml.DOMParser\");\n-//        parserClasses.put(MODEL_JDOM, \n-//                          \"org.apache.commons.jxpath.xml.JDOMParser\");\n+        parserClasses.put(MODEL_JDOM,\n+                          \"org.apache.commons.jxpath.xml.JDOMParser\");\n     }\n+\n     private static HashMap parsers = new HashMap();\n \n     /**\n      * Use this constructor if the desired model is DOM.\n-     * \n-     * @param URL is a URL for an XML file. \n-     * Use getClass().getResource(resourceName) to load XML from a \n+     *\n+     * @param URL is a URL for an XML file.\n+     * Use getClass().getResource(resourceName) to load XML from a\n      * resource file.\n      */\n     public DocumentContainer(URL xmlURL){\n-        this(xmlURL, MODEL_DOM);\n+        this(xmlURL, MODEL_JDOM);\n     }\n \n     /**\n     public void setValue(Object value){\n         throw new UnsupportedOperationException();\n     }\n-    \n+\n     /**\n      * Maps a model type to a parser.\n      */\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/JDOMParser.java,v 1.1 2002/08/26 22:29:49 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/26 22:29:49 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.xml;\n+\n+import java.io.InputStream;\n+\n+import org.apache.commons.jxpath.JXPathException;\n+import org.jdom.input.SAXBuilder;\n+\n+/**\n+ * An implementation of the XMLParser interface that produces a JDOM Document.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:49 $\n+ */\n+public class JDOMParser implements XMLParser {\n+\n+    public Object parseXML(InputStream stream){\n+        try {\n+            SAXBuilder builder = new SAXBuilder();\n+            return builder.build(stream);\n+        }\n+        catch (Exception ex){\n+            throw new JXPathException(\"JDOM parser error\", ex);\n+        }\n+    }\n+}", "timestamp": 1030400989, "metainfo": ""}