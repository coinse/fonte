{"sha": "b309e5f13acc315b4fd18dc8d151a61f46d7d7f7", "log": "Fixed bug in comparison implementations   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.8 2003/01/11 05:41:23 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2003/01/11 05:41:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.9 2003/01/12 01:52:57 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/12 01:52:57 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import java.util.Collection;\n import java.util.HashSet;\n import java.util.Iterator;\n-import java.util.Set;\n \n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.axes.InitialContext;\n import org.apache.commons.jxpath.ri.axes.SelfContext;\n import org.apache.commons.jxpath.ri.axes.UnionContext;\n-import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * A compile tree element representing one of the core operations like \"+\",\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:23 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/12 01:52:57 $\n  */\n public class CoreOperation extends Operation {\n     public CoreOperation(int code, Expression args[]) {\n         Expression left,\n         Expression right) \n     {\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return l < r ? Boolean.TRUE : Boolean.FALSE;\n+        return test(context, left, right, LT_TEST)\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n     }\n \n     /**\n         Expression left,\n         Expression right) \n     {\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return l > r ? Boolean.TRUE : Boolean.FALSE;\n+        return test(context, left, right, GT_TEST)\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n     }\n \n     /**\n         Expression left,\n         Expression right) \n     {\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n+        return test(context, left, right, LTE_TEST)\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n     }\n \n     /**\n         Expression left,\n         Expression right) \n     {\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n+        return test(context, left, right, GTE_TEST)\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n     }\n \n     /**\n         Expression left,\n         Expression right) \n     {\n-        return equal(context, left, right) ? Boolean.TRUE : Boolean.FALSE;\n+        return test(context, left, right, EQUAL_TEST)\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n     }\n \n     /**\n         Expression left,\n         Expression right) \n     {\n-        return equal(context, left, right) ? Boolean.FALSE : Boolean.TRUE;\n-    }\n-\n-    /**\n-     * Compares two values\n-     */\n-    protected boolean equal(\n-        EvalContext context,\n-        Expression left,\n-        Expression right) \n+        return test(context, left, right, EQUAL_TEST)\n+            ? Boolean.FALSE\n+            : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * When the left and/or right side of a comparisons like =, &lt;, &gt;, \n+     * &lt;= and &gt;= is a NodeSet (i.e. a collection), we are supposed to\n+     * perform a search for a pair of matching nodes. That's exactly what this\n+     * method does.  It takes a \"PairTest\" static object that implements the\n+     * comparison of two nodes.\n+     */\n+    protected boolean test(EvalContext context,\n+            Expression left,\n+            Expression right,\n+            NodeComparator pairTest)\n     {\n         Object l = left.compute(context);\n         Object r = right.compute(context);\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n         if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n+            l = ((EvalContext) l).getSingleNodePointer().getValue();\n         }\n \n         if (r instanceof InitialContext || r instanceof SelfContext) {\n-            r = ((EvalContext) r).getSingleNodePointer();\n-        }\n-\n-        if (l instanceof Collection) {\n-            l = ((Collection) l).iterator();\n-        }\n-\n-        if (r instanceof Collection) {\n-            r = ((Collection) r).iterator();\n+            r = ((EvalContext) r).getSingleNodePointer().getValue();\n+        }\n+\n+        if (ValueUtils.isCollection(l)) {\n+            l = ValueUtils.iterate(l);\n+        }\n+\n+        if (ValueUtils.isCollection(r)) {\n+            r = ValueUtils.iterate(r);\n         }\n \n         if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n-            return contains((Iterator) l, r);\n+            return contains((Iterator) l, r, pairTest);\n         }\n         else if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n-            return contains((Iterator) r, l);\n+            Iterator it = (Iterator) r;\n+            while (it.hasNext()) {\n+                Object element = it.next();\n+                if (pairTest.isTrue(element, l)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n         }\n         else if (l instanceof Iterator && r instanceof Iterator) {\n-            return findMatch((Iterator) l, (Iterator) r);\n-        }\n-\n-        return equal(l, r);\n-    }\n-\n-    protected boolean contains(Iterator it, Object value) {\n+            return findMatch((Iterator) l, (Iterator) r, pairTest);\n+        }\n+\n+        return pairTest.isTrue(l, r);\n+    }\n+\n+    protected boolean contains(\n+        Iterator it,\n+        Object value,\n+        NodeComparator pairTest) \n+    {\n         while (it.hasNext()) {\n             Object element = it.next();\n-            if (equal(element, value)) {\n+            if (pairTest.isTrue(element, value)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    protected boolean findMatch(Iterator lit, Iterator rit) {\n+    protected boolean findMatch(Iterator lit, Iterator rit, NodeComparator pairTest) {\n         HashSet left = new HashSet();\n         while (lit.hasNext()) {\n             left.add(lit.next());\n         }\n         while (rit.hasNext()) {\n-            if (contains(left.iterator(), rit.next())) {\n+            if (contains(left.iterator(), rit.next(), pairTest)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    protected boolean equal(Object l, Object r) {\n-        if (l instanceof Pointer && r instanceof Pointer) {\n-            if (l.equals(r)) {\n+    private static abstract class NodeComparator {\n+        abstract boolean compare(Object left, Object right);\n+\n+        boolean isTrue(Object left, Object right){\n+            if (left instanceof Pointer) {\n+                left = ((Pointer) left).getValue();\n+            }\n+\n+            if (right instanceof Pointer) {\n+                right = ((Pointer) right).getValue();\n+            }\n+            return compare(left, right);\n+        }\n+    }\n+    \n+    private static final NodeComparator EQUAL_TEST = new NodeComparator() {\n+        public boolean isTrue(Object l, Object r) {\n+            if (l instanceof Pointer && r instanceof Pointer) {\n+                if (l.equals(r)) {\n+                    return true;\n+                }\n+            }\n+\n+            if (l instanceof Pointer) {\n+                l = ((Pointer) l).getValue();\n+            }\n+\n+            if (r instanceof Pointer) {\n+                r = ((Pointer) r).getValue();\n+            }\n+\n+            if (l == r) {\n                 return true;\n             }\n-        }\n-\n-        if (l instanceof Pointer) {\n-            l = ((Pointer) l).getValue();\n-        }\n-\n-        if (r instanceof Pointer) {\n-            r = ((Pointer) r).getValue();\n-        }\n-\n-        if (l == r) {\n-            return true;\n-        }\n-\n-//        System.err.println(\"COMPARING VALUES: \" + l + \" \" + r);\n-        if (l instanceof Boolean || r instanceof Boolean) {\n-            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n-        }\n-        else if (l instanceof Number || r instanceof Number) {\n-            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n-        }\n-        else if (l instanceof String || r instanceof String) {\n-            return (\n-                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n-        }\n-        else if (l == null) {\n-            return r == null;\n-        }\n-        return l.equals(r);\n-    }\n-\n-    /**\n-     * Extracts all values from a context\n-     */\n-    private Set valueSet(EvalContext context) {\n-        HashSet set = new HashSet();\n-        while (context.hasNext()) {\n-            context.next();\n-            NodePointer pointer = context.getCurrentNodePointer();\n-            set.add(pointer.getValue());\n-        }\n-        return set;\n-    }\n+\n+            if (l instanceof Boolean || r instanceof Boolean) {\n+                return (\n+                    InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n+            }\n+            else if (l instanceof Number || r instanceof Number) {\n+                return (\n+                    InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n+            }\n+            else if (l instanceof String || r instanceof String) {\n+                return (\n+                    InfoSetUtil.stringValue(l).equals(\n+                        InfoSetUtil.stringValue(r)));\n+            }\n+            else if (l == null) {\n+                return r == null;\n+            }\n+            return l.equals(r);\n+        }\n+        \n+        boolean compare(Object left, Object right){\n+            // Not used\n+            return false;\n+        }\n+    };\n+\n+    private static final NodeComparator LT_TEST = new NodeComparator() {\n+        public boolean compare(Object l, Object r) {\n+            return InfoSetUtil.doubleValue(l) < InfoSetUtil.doubleValue(r);\n+        }\n+    };\n+    \n+    private static final NodeComparator GT_TEST = new NodeComparator() {\n+        public boolean compare(Object l, Object r) {\n+            return InfoSetUtil.doubleValue(l) > InfoSetUtil.doubleValue(r);\n+        }\n+    };\n+    \n+    private static final NodeComparator LTE_TEST = new NodeComparator() {\n+        public boolean compare(Object l, Object r) {\n+            return InfoSetUtil.doubleValue(l) <= InfoSetUtil.doubleValue(r);\n+        }\n+    };\n+\n+    private static final NodeComparator GTE_TEST = new NodeComparator() {\n+        public boolean compare(Object l, Object r) {\n+            return InfoSetUtil.doubleValue(l) >= InfoSetUtil.doubleValue(r);\n+        }\n+    };\n \n     /**\n      * Computes <code>\"left and right\"<code>\n         }\n         return Boolean.FALSE;\n     }\n+    \n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.10 2003/01/11 05:41:24 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/01/11 05:41:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.11 2003/01/12 01:52:56 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/01/12 01:52:56 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Variables;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2003/01/11 05:41:24 $\n+ * @version $Revision: 1.11 $ $Date: 2003/01/12 01:52:56 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n         }\n         return value;\n     }\n-\n+    \n     public void setValue(Object value) {\n         if (!actual) {\n             throw new JXPathException(\"Cannot set undefined variable: \" + name);\n             Object value = null;\n             if (actual) {\n                 value = getImmediateNode();\n-            }\n-            valuePointer = NodePointer.newChildNodePointer(this, null, value);\n+                valuePointer =\n+                    NodePointer.newChildNodePointer(this, null, value);\n+            }\n+            else {\n+                return new NullPointer(this, getName()) {\n+                    public Object getImmediateNode() {\n+                        throw new JXPathException(\n+                            \"Undefined variable: \" + name);\n+                    }\n+                };\n+            }\n         }\n         return valuePointer;\n     }\n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.6 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.7 2003/01/12 01:52:57 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/12 01:52:57 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/12 01:52:57 $\n  */\n \n public abstract class BeanModelTestCase extends JXPathTestCase\n                 list(new Integer(1), new Integer(2)));\n     }\n \n+    public void testBooleanPredicateWithSearch(){\n+        context.getVariables().declareVariable(\n+            \"numbers\",\n+            new String[] { \"2\", \"3\" });\n+\n+        context.setValue(\"/beans[1]/strings\", new String[] { \"1\", \"2\" });\n+        context.setValue(\"/beans[2]/strings\", new String[] { \"3\", \"4\" });\n+\n+        // Find beans with any string == 2        \n+        assertXPathValueIterator(context,\n+            \"/beans[strings = '2']/name\",\n+            list(\"Name 1\")\n+        );\n+\n+        // Find beans with any string in the variable $numbers\n+        assertXPathValueIterator(context,\n+            \"/beans[strings = $numbers]/name\",\n+            list(\"Name 1\", \"Name 2\")\n+        );\n+\n+        // Find beans without any strings == 2\n+        assertXPathValueIterator(context,\n+            \"/beans[strings != '2']/name\",\n+            list(\"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings > '1']/name\",\n+            list(\"Name 1\", \"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings > $numbers]/name\",\n+            list(\"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings >= '2']/name\",\n+            list(\"Name 1\", \"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings >= '3']/name\",\n+            list(\"Name 2\")\n+        );\n+        \n+        assertXPathValueIterator(context,\n+            \"/beans[strings < '4']/name\",\n+            list(\"Name 1\", \"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings < 3]/name\",\n+            list(\"Name 1\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings <= '3']/name\",\n+            list(\"Name 1\", \"Name 2\")\n+        );\n+\n+        assertXPathValueIterator(context,\n+            \"/beans[strings <= '2']/name\",\n+            list(\"Name 1\")\n+        );\n+    }\n+    \n     public void testDocumentOrder(){\n         assertDocumentOrder(context,\n                 \"boolean\", \"int\", -1);", "timestamp": 1042336377, "metainfo": ""}