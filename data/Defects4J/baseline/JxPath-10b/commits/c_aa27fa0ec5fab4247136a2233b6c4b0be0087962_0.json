{"sha": "aa27fa0ec5fab4247136a2233b6c4b0be0087962", "log": "Added CompiledExpressions   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/CompiledExpression.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/CompiledExpression.java,v 1.1 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/28 04:37:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Represents a compiled XPath. The interpretation of compiled XPaths\n+ * may be faster, because it bypasses the compilation step. The reference\n+ * implementation of JXPathContext also globally caches some of the\n+ * results of compilation, so the direct use of JXPathContext is not\n+ * always less efficient than the use of CompiledExpression.\n+ * <p>\n+ * Use CompiledExpression only when there is a need to evaluate the\n+ * same expression multiple times and the CompiledExpression can be\n+ * conveniently cached.  \n+ * <p>\n+ * To acqure a CompiledExpression, call {@link JXPathContext#compile\n+ * JXPathContext.compile}\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/28 04:37:01 $\n+ */\n+public interface CompiledExpression {\n+    \n+    /**\n+     * Evaluates the xpath and returns the resulting object. Primitive\n+     * types are wrapped into objects.\n+     */\n+    Object getValue(JXPathContext context);\n+\n+    /**\n+     * Evaluates the xpath, converts the result to the specified class and\n+     * returns the resulting object.\n+     */\n+    Object getValue(JXPathContext context, Class requiredType);\n+\n+    /**\n+     * Modifies the value of the property described by the supplied xpath.\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>The xpath does not in fact describe an existing property\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    void setValue(JXPathContext context, Object value);\n+\n+    /**\n+     * The same as setValue, except it creates intermediate elements of\n+     * the path by invoking an AbstractFactory, which should first be\n+     * installed on the context by calling \"setFactory\".\n+     * <p>\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>Elements of the xpath aleady exist, by the path does not in\n+     *  fact describe an existing property\n+     * <li>The AbstractFactory fails to create an instance for an intermediate\n+     * element.\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    void createPath(JXPathContext context, Object value);\n+\n+    /**\n+     * Traverses the xpath and returns a Iterator of all results found\n+     * for the path. If the xpath matches no properties\n+     * in the graph, the Iterator will not be null.\n+     */\n+    Iterator iterate(JXPathContext context);\n+\n+    /**\n+     * Traverses the xpath and returns a Pointer.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the pointer will be null.\n+     */\n+    Pointer getPointer(JXPathContext context, String xpath);\n+    \n+    /**\n+     * Traverses the xpath and returns an Iterator of Pointers.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the Iterator be empty, but not null.\n+     */\n+    Iterator iteratePointers(JXPathContext context);\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPath.java\n+++ b/src/java/org/apache/commons/jxpath/JXPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Attic/JXPath.java,v 1.3 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Attic/JXPath.java,v 1.4 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/28 04:37:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * <li>There is a need to use an AbstractFactory, which can create new objects.\n  * <li>There is a need to use a hierarchy of evaluation contexts.\n  * </ul>\n+ * \n+ * @deprecated This class will soon be removed - use JXPathContext.newInstance()\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/28 04:37:01 $\n  */\n public final class JXPath {\n \n     /**\n      * Traverses the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n+     * \n+     * @deprecated This class is going away\n      */\n     public static Object getValue(Object bean, String xpath){\n         return JXPathContext.newContext(bean).getValue(xpath);\n      * <li>The xpath does not in fact describe an existing property\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n+     * \n+     * @deprecated This class is going away\n      */\n     public static void setValue(Object bean, String xpath, Object value){\n         JXPathContext.newContext(bean).setValue(xpath, value);\n      * there is only one object that matches the xpath, it will be returned\n      * as a collection with one element.  If the xpath matches no properties\n      * in the graph, the List will be empty.\n+     * \n+     * @deprecated This class is going away\n      */\n     public static List eval(Object bean, String xpath){\n         return JXPathContext.newContext(bean).eval(xpath);\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.6 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.7 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/04/28 04:37:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.List;\n-import java.util.Locale;\n+import java.util.*;\n \n /**\n  * JXPathContext provides APIs for the traversal of graphs of JavaBeans using\n  * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.7 $ $Date: 2002/04/28 04:37:01 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n         return lenient;\n     }\n \n+    /**\n+     * Compiles the supplied XPath and returns an internal representation\n+     * of the path that can then be evaluated.  Use CompiledExpressions\n+     * when you need to evaluate the same expression multiple times\n+     * and there is a convenient place to cache CompiledExpression\n+     * between invocations.\n+     */\n+    public abstract CompiledExpression compile(String xpath);\n+    \n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n     public abstract void createPath(String xpath, Object value);\n \n     /**\n-     * Traverses the xpath and returns a List of objects. Even if\n-     * there is only one object that matches the xpath, it will be returned\n-     * as a collection with one element.  If the xpath matches no properties\n-     * in the graph, the List will be empty.\n-     */\n-    public abstract List eval(String xpath);\n+     * @deprecated Please use iterate\n+     */\n+    public List eval(String xpath){\n+        ArrayList list = new ArrayList();\n+        Iterator it = iterate(xpath);\n+        while (it.hasNext()){\n+            list.add(it.next());\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns a Iterator of all results found\n+     * for the path. If the xpath matches no properties\n+     * in the graph, the Iterator will not be null.\n+     */\n+    public abstract Iterator iterate(String xpath);\n+\n+\n+    /**\n+     * @deprecated Please use getPointer(String xpath)\n+     */\n+    public Pointer locateValue(String xpath){\n+        return getPointer(xpath);\n+    }\n \n     /**\n      * Traverses the xpath and returns a Pointer.\n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n-     * in the graph, the List will be empty.\n-     */\n-    public abstract Pointer locateValue(String xpath);\n-\n-    /**\n-     * Traverses the xpath and returns a List of Pointers.\n+     * in the graph, the pointer will be null.\n+     */\n+    public abstract Pointer getPointer(String xpath);\n+    \n+    /**\n+     * @deprecated Please use iteratePointers\n+     */\n+    public List locate(String xpath){\n+        ArrayList list = new ArrayList();\n+        Iterator it = iteratePointers(xpath);\n+        while (it.hasNext()){\n+            list.add(it.next());\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns an Iterator of Pointers.\n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n-     * in the graph, the List will be empty.\n-     */\n-    public abstract List locate(String xpath);\n+     * in the graph, the Iterator be empty, but not null.\n+     */\n+    public abstract Iterator iteratePointers(String xpath);\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.1 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/28 04:37:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.CompiledExpression;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+\n+/**\n+ * \n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/28 04:37:01 $\n+ */\n+public class JXPathCompiledExpression implements CompiledExpression {\n+\n+    private String xpath;\n+    private Expression expression;\n+    \n+    public JXPathCompiledExpression(String xpath, Expression expression){\n+        this.xpath = xpath;\n+        this.expression = expression;\n+    }\n+    \n+    /**\n+     * @see CompiledExpression#getValue(JXPathContext)\n+     */\n+    public Object getValue(JXPathContext context) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    getValue(xpath, expression);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#getValue(JXPathContext, Class)\n+     */\n+    public Object getValue(JXPathContext context, Class requiredType) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    getValue(xpath, expression, requiredType);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#setValue(JXPathContext, Object)\n+     */\n+    public void setValue(JXPathContext context, Object value) {\n+        ((JXPathContextReferenceImpl)context).\n+                    setValue(xpath, expression, value);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#createPath(JXPathContext, Object)\n+     */\n+    public void createPath(JXPathContext context, Object value) {\n+        ((JXPathContextReferenceImpl)context).\n+                    createPath(xpath, expression, value);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#iterate(JXPathContext)\n+     */\n+    public Iterator iterate(JXPathContext context) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    iterate(xpath, expression);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#getPointer(JXPathContext, String)\n+     */\n+    public Pointer getPointer(JXPathContext context, String xpath) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    getPointer(xpath, expression);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#iteratePointers(JXPathContext)\n+     */\n+    public Iterator iteratePointers(JXPathContext context) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    iteratePointers(xpath, expression);\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.13 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.13 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.14 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.14 $\n+ * $Date: 2002/04/28 04:37:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.13 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.14 $ $Date: 2002/04/28 04:37:01 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n     public static NodePointerFactory[] getNodePointerFactories(){\n         return nodeFactoryArray;\n     }\n-\n-    private static Expression compile(String xpath){\n+    \n+    public CompiledExpression compile(String xpath){\n+        return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n+    }\n+\n+    private static Expression compileExpression(String xpath){\n         Expression expr;\n         if (useSoftCache){\n             expr = null;\n                 compiled.put(xpath, expr);\n             }\n         }\n-//        }\n         return expr;\n     }\n \n     private static void cleanupCache(){\n-//        System.gc();\n         Iterator it = compiled.entrySet().iterator();\n         while (it.hasNext()){\n             Map.Entry me = (Map.Entry)it.next();\n      * types are wrapped into objects.\n      */\n     public Object getValue(String xpath){\n-//        System.err.println(\"XPATH: \" + xpath);\n-        Object result = eval(xpath, true);\n+        return getValue(xpath, compileExpression(xpath));\n+    }\n+    \n+    public Object getValue(String xpath, Expression expr){    \n+        Object result = getRootContext().eval(expr);        \n         if (result == null && !lenient){\n             throw new JXPathException(\"No value for xpath: \" + xpath);\n         }\n      * and returns the result of the conversion.\n      */\n     public Object getValue(String xpath, Class requiredType){\n-        Object value = getValue(xpath);\n+        Expression expr = compileExpression(xpath);\n+        return getValue(xpath, expr, requiredType);\n+    }\n+    \n+    public Object getValue(String xpath, Expression expr, Class requiredType){\n+        Object value = getValue(xpath, expr);\n         if (value != null && requiredType != null){\n             if (!TypeUtils.canConvert(value, requiredType)){\n                 throw new JXPathException(\"Invalid expression type. '\" + xpath +\n     }\n \n     /**\n-     * Traverses the xpath and returns a List of objects. Even if\n-     * there is only one object that matches the xpath, it will be returned\n-     * as a collection with one element.  If the xpath matches no properties\n-     * in the graph, the List will be empty.\n+     * Traverses the xpath and returns a Iterator of all results found\n+     * for the path. If the xpath matches no properties\n+     * in the graph, the Iterator will not be null.\n      */\n-    public List eval(String xpath){\n-//        System.err.println(\"XPATH: \" + xpath);\n-        Object result = eval(xpath, false);\n-        if (result instanceof EvalContext){\n-            return ((EvalContext)result).getValueList();\n-        }\n-        else if (result instanceof Pointer){\n-            return Collections.singletonList(((Pointer)result).getValue());\n-        }\n-        else {\n-            return Collections.singletonList(result);\n-        }\n-    }\n-\n-    public Pointer locateValue(String xpath){\n-//        System.err.println(\"XPATH: \" + xpath);\n-        Object result = eval(xpath, true);\n+    public Iterator iterate(String xpath){\n+        return iterate(xpath, compileExpression(xpath));\n+    }\n+    \n+    public Iterator iterate(String xpath, Expression expr){\n+        return getRootContext().iterate(expr);        \n+    }\n+\n+    public Pointer getPointer(String xpath){\n+        return getPointer(xpath, compileExpression(xpath));\n+    }\n+    \n+    public Pointer getPointer(String xpath, Expression expr){\n+        Object result = getRootContext().eval(expr);        \n         if (result instanceof EvalContext){\n             result = ((EvalContext)result).getSingleNodePointer();\n         }\n         }\n     }\n \n-    /**\n-     */\n     public void setValue(String xpath, Object value){\n+        setValue(xpath, compileExpression(xpath), value);\n+    }\n+    \n+    \n+    public void setValue(String xpath, Expression expr, Object value){\n         try {\n-            setValue(xpath, value, false);\n+            setValue(xpath, expr, value, false);\n         }\n         catch (Throwable ex){\n             throw new JXPathException(\n         }\n     }\n \n-    /**\n-     */\n     public void createPath(String xpath, Object value){\n-//        System.err.println(\"CREATING XPATH: \" + xpath);\n+        createPath(xpath, compileExpression(xpath), value);\n+    }\n+    \n+    public void createPath(String xpath, Expression expr, Object value){\n         try {\n-            setValue(xpath, value, true);\n+            setValue(xpath, expr, value, true);\n         }\n         catch (Throwable ex){\n             throw new JXPathException(\n         }\n     }\n \n-    private void setValue(String xpath, Object value, boolean create){\n-        Object result = eval(xpath, true);\n+    private void setValue(String xpath, Expression expr, Object value, boolean create){\n+        Object result = getRootContext().eval(expr);        \n //        System.err.println(\"RESULT: \" + result);\n         Pointer pointer = null;\n \n         }\n     }\n \n-    public List locate(String xpath){\n-        Object result = eval(xpath, false);\n-        if (result instanceof EvalContext){\n-            return ((EvalContext)result).getPointerList();\n-        }\n-        else if (result instanceof Pointer){\n-            return Collections.singletonList((Pointer)result);\n-        }\n-        else {\n-            return Collections.singletonList(\n-                    NodePointer.newNodePointer(null, result, getLocale()));\n-        }\n-    }\n-\n-    private Object eval(String xpath, boolean firstMatchLookup) {\n-        Expression expr = compile(xpath);\n-        return getRootContext().eval(expr, firstMatchLookup);\n-    }\n-\n+    /**\n+     * Traverses the xpath and returns an Iterator of Pointers.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the Iterator be empty, but not null.\n+     */\n+    public Iterator iteratePointers(String xpath){\n+        return iteratePointers(xpath, compileExpression(xpath));\n+    }\n+\n+    public Iterator iteratePointers(String xpath, Expression expr){\n+        return getRootContext().iteratePointers(expr);\n+    }\n+    \n     private void printPointer(NodePointer pointer){\n         Pointer p = pointer;\n         while (p != null){\n \n     private EvalContext getRootContext(){\n         return new RootContext(this, getRootPointer());\n-    }\n-\n-    private List resolveNodeSet(List list){\n-        List result = new ArrayList();\n-        for (int i = 0; i < list.size(); i++){\n-            Object element = list.get(i);\n-            if (element instanceof NodePointer){\n-                element = ((NodePointer)element).getNodeValue();\n-            }\n-            result.add(element);\n-        }\n-        return result;\n     }\n \n     public NodePointer getVariablePointer(QName name){\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.14 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.15 2002/04/28 04:37:01 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/04/28 04:37:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.15 $ $Date: 2002/04/28 04:37:01 $\n  */\n \n public class JXPathTestCase extends TestCase\n     private void testGetValue(JXPathContext context, String xpath, Object expected) {\n         Object actual = context.getValue(xpath);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+        \n+        CompiledExpression expr = context.compile(xpath);\n+        actual = expr.getValue(context);\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n     }\n \n     private void testGetValue(JXPathContext context, String xpath, Object expected, Class requiredType) {\n         Object actual = context.getValue(xpath, requiredType);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n-    }\n+ \n+        CompiledExpression expr = context.compile(xpath);\n+        actual = expr.getValue(context, requiredType);\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n+     }\n \n     /**\n      * Test JXPath.eval() with various arguments\n     }\n \n     private void testEval(JXPathContext context, String xpath, Object expected) {\n-        Object actual = context.eval(xpath);\n+        Iterator it = context.iterate(xpath);\n+        ArrayList actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+\n+        CompiledExpression expr = context.compile(xpath);\n+        it = expr.iterate(context);\n+        actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n     }\n \n     public void testContextDependency(){\n     }\n \n     private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n-        NodePointer np1 = (NodePointer)context.locateValue(path1);\n-        NodePointer np2 = (NodePointer)context.locateValue(path2);\n+        NodePointer np1 = (NodePointer)context.getPointer(path1);\n+        NodePointer np2 = (NodePointer)context.getPointer(path2);\n         int res = np1.compareTo(np2);\n         if (res < 0){\n             res = -1;\n                     }\n                     else {\n                         if (xpath_tests[i].eval){\n-                            List list = ctx.locate(xpath_tests[i].xpath);\n+                            Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n                             List paths = new ArrayList();\n-                            for (Iterator it = list.iterator(); it.hasNext();){\n+                            while (it.hasNext()){\n                                 paths.add(((Pointer)it.next()).asPath());\n                             }\n                             actual = paths;\n                         }\n                         else {\n-                            actual = ctx.locateValue(xpath_tests[i].xpath).asPath();\n+                            actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n                         }\n                     }\n                 }\n                 else {\n                     if (xpath_tests[i].eval){\n-                        actual = ctx.eval(xpath_tests[i].xpath);\n+                        ArrayList list = new ArrayList();\n+                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n+                        while (it.hasNext()){\n+                            list.add(it.next());\n+                        }\n+                        actual = list;\n                     }\n                     else {\n                         ctx.setLenient(xpath_tests[i].lenient);\n         for (int i=0; i < xpath_tests.length; i++) {\n             try {\n                 if (!xpath_tests[i].path && !xpath_tests[i].eval){\n-                    Pointer ptr = ctx.locateValue(xpath_tests[i].xpath);\n-                    Pointer test = ctx.locateValue(ptr.asPath());\n+                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n+                    Pointer test = ctx.getPointer(ptr.asPath());\n                     assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n                 }\n             }", "timestamp": 1019968621, "metainfo": ""}