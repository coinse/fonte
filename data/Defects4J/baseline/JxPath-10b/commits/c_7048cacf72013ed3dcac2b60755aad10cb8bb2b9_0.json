{"sha": "7048cacf72013ed3dcac2b60755aad10cb8bb2b9", "log": "Support for namespaces, implementation clean-up   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/Compiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Compiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Compiler.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Compiler.java,v 1.2 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * <p>\n  * Since objects returned by Compiler methods are passed as arguments to\n  * other Compiler methods, the descriptions of these methods use virtual\n- * types.  There are three virtual object types: EXPRESSION, QNAME and STEP.\n+ * types.  There are four virtual object types: EXPRESSION, QNAME, STEP and NODE_TEST.\n  * <p>\n  * The following example illustrates this notion.  This sequence compiles\n  * the xpath \"foo[round(1 div 2)]/text()\":\n  *      Object expr2 = compiler.number(\"2\");\n  *      Object expr3 = compiler.div(expr1, expr2);\n  *      Object expr4 = compiler.coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});\n- *      Object step1 = compiler.nodeNameTest(Compiler.AXIS_CHILD, qname1, new Object[]{expr4});\n- *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, Compiler.NODE_TYPE_TEXT, null);\n+ *      Object test1 = compiler.nodeNameTest(qname1);\n+ *      Object step1 = compiler.step(Compiler.AXIS_CHILD, test1, new Object[]{expr4});\n+ *      Object test2 = compiler.nodeTypeTest(Compiler.NODE_TYPE_TEXT);\n+ *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, test2, null);\n  *      Object expr5 = compiler.locationPath(false, new Object[]{step1, step2});\n  * </pre></blockquote>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:43 $\n  */\n public interface Compiler {\n \n     public static final int FUNCTION_FLOOR = 25;\n     public static final int FUNCTION_CEILING = 26;\n     public static final int FUNCTION_ROUND = 27;\n-//    public static final int FUNCTION_KEY = 28;\n+    public static final int FUNCTION_NULL = 28;\n+//    public static final int FUNCTION_KEY = 29;\n \n     /**\n      * Produces an EXPRESSION object that represents a numeric constant.\n     Object union(Object[] arguments);\n \n     /**\n-     * Produces a STEP object that represents a node name test.\n+     * Produces a NODE_TEST object that represents a node name test.\n+     *\n+     * @param qname is a QNAME object\n+     */\n+    Object nodeNameTest(Object qname);\n+\n+    /**\n+     * Produces a NODE_TEST object that represents a node type test.\n+     *\n+     * @param qname is a QNAME object\n+     */\n+    Object nodeTypeTest(int nodeType);\n+\n+    /**\n+     * Produces a NODE_TEST object that represents a processing instruction test.\n+     *\n+     * @param qname is a QNAME object\n+     */\n+    Object processingInstructionTest(String instruction);\n+\n+    /**\n+     * Produces a STEP object that represents a node test.\n      *\n      * @param axis is one of the AXIS_... constants\n-     * @param qname is a QNAME object\n+     * @param nodeTest is a NODE_TEST object\n      * @param predicates are EXPRESSION objects\n      */\n-    Object nodeNameTest(int axis, Object qname, Object[] predicates);\n-\n-    /**\n-     * Produces a STEP object that represents a node type test.\n-     *\n-     * @param axis is one of the AXIS_... constants\n-     * @param nodeType is one of the NODE_TYPE_... constants\n-     * @param predicates are EXPRESSION objects\n-     */\n-    Object nodeTypeTest(int axis, int nodeType, Object[] predicates);\n-\n-    /**\n-     * Produces a STEP object that represents a processing instruction test.\n-     *\n-     * @param axis is one of the AXIS_... constants\n-     * @param instruction is a processing instruction\n-     * @param predicates are EXPRESSION objects\n-     */\n-    Object processingInstructionTest(int axis, String instruction, Object[] predicates);\n+    Object step(int axis, Object nodeTest, Object[] predicates);\n \n     /**\n      * Produces an EXPRESSION object representing a location path\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n  */\n public abstract class EvalContext implements ExpressionContext {\n     protected EvalContext parentContext;\n     protected RootContext rootContext;\n-    private HashSet visitedNodes = new HashSet();\n     protected int position = 0;\n+    private boolean startedSetIteration = false;\n \n     public EvalContext(EvalContext parentContext){\n         this.parentContext = parentContext;\n \n     /**\n      * Sets current position = 0, which is the pre-iteration state.\n+     * @deprecated\n      */\n     protected void reset(){\n         position = 0;\n      * Returns true if there is another sets of objects to interate over.\n      * Resets the current position and node.\n      */\n-    public abstract boolean nextSet();\n+    public boolean nextSet(){\n+        setPosition(0);     // Restart iteration within the set\n+\n+        // Most of the time you have one set per parent node\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!startedSetIteration){\n+            startedSetIteration = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n     /**\n      * Returns true if there is another object in the current set.\n      * Switches the current position and node to the next object.\n      */\n-    public boolean next(){\n-        while (nextIgnoreDuplicates()){\n-            NodePointer location = getCurrentNodePointer();\n-            if (!visitedNodes.contains(location)){\n-                visitedNodes.add(location.clone());\n-                position++;\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Returns true if there is another object in the current set, even\n-     * if that object has already been encountered in the same iteration.\n-     */\n-    protected boolean nextIgnoreDuplicates(){\n-        return false;\n-    }\n+    public abstract boolean next();\n \n     /**\n      * Moves the current position to the specified index. Used with integer\n      * predicates to quickly get to the n'th element of the node set.\n      * Returns false if the position is out of the node set range.\n-     */\n-    public abstract boolean setPosition(int position);\n+     * You can call it with 0 as the position argument to restart the iteration.\n+     */\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return true;\n+    }\n \n     /**\n      * Creates an EvalContext with the value of the specified\n         else if (l instanceof String || r instanceof String){\n             result = (stringValue(l).equals(stringValue(r)));\n         }\n+        else if (l == null){\n+            return r == null;\n+        }\n         else {\n             result = l.equals(r);\n         }\n             return \"\";\n         }\n         else if (object instanceof Node){\n-            NodeList list = ((Node)object).getChildNodes();\n-            StringBuffer buf = new StringBuffer(16);\n-            for(int i = 0; i < list.getLength();i++) {\n-                Node child = list.item(i);\n-                if (child.getNodeType() == Node.TEXT_NODE){\n-                    buf.append(child.getNodeValue());\n+            Node node = (Node)object;\n+            int nodeType = node.getNodeType();\n+            if (nodeType == Node.COMMENT_NODE){\n+                String text = ((Comment)node).getData();\n+                return text == null ? \"\" : text.trim();\n+            }\n+            else if (nodeType == Node.TEXT_NODE ||\n+                    nodeType == Node.CDATA_SECTION_NODE){\n+                String text = node.getNodeValue();\n+                return text == null ? \"\" : text.trim();\n+            }\n+            else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE){\n+                String text = ((ProcessingInstruction)node).getData();\n+                return text == null ? \"\" : text.trim();\n+            }\n+            else {\n+                NodeList list = node.getChildNodes();\n+                StringBuffer buf = new StringBuffer(16);\n+                for(int i = 0; i < list.getLength();i++) {\n+                    Node child = list.item(i);\n+                    if (child.getNodeType() == Node.TEXT_NODE){\n+                        buf.append(child.getNodeValue());\n+                    }\n+                    else {\n+                        buf.append(stringValue(child));\n+                    }\n                 }\n-                else {\n-                    buf.append(stringValue(child));\n-                }\n-            }\n-            return buf.toString().trim();\n+                return buf.toString().trim();\n+            }\n         }\n         else if (object instanceof NodePointer){\n             return stringValue(((NodePointer)object).getValue());\n             rootContext = this;\n         }\n         if (firstMatch){\n-            boolean basic = path.getEvaluationHint(LocationPath.BASIC_PATH_HINT) == Boolean.TRUE;\n+            boolean basic = path.getEvaluationHint(LocationPath.BASIC_PATH_HINT).equals(Boolean.TRUE);\n             if (basic){\n                 Object result = tryBasicPath(new InitialContext(rootContext), steps);\n                 if (result != FAILURE){\n         }\n         PropertyOwnerPointer pointer = (PropertyOwnerPointer)ptr.clone();\n         for (int i = 0; i < steps.length; i++){\n-            String propertyName = ((NodeNameTest)steps[i]).getNodeName().getName();\n+            String propertyName = ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName();\n             pointer = pointer.getPropertyPointer();\n             ((PropertyPointer)pointer).setPropertyName(propertyName);\n \n      */\n     private Object evalSteps(EvalContext context, Step steps[], boolean firstMatch){\n         for (int i = 0; i < steps.length; i++){\n-            context = createContextForStep(context, steps[i]);\n+            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n             Expression predicates[] = steps[i].getPredicates();\n             if (predicates != null){\n                 for (int j = 0; j < predicates.length; j++){\n         }\n \n         if (firstMatch){\n-            return context.getContextNodePointer();\n+            Pointer ptr = context.getContextNodePointer();\n+//            System.err.println(\"GETTING CTX POINTER: \" + context + \" \" + ptr);\n+            return ptr;\n         }\n         else {\n             return context;\n      * Different axes are serviced by different contexts. This method\n      * allocates the right context for the supplied step.\n      */\n-    protected EvalContext createContextForStep(EvalContext context, Step step){\n-        if (step instanceof NodeNameTest){\n-            QName name = ((NodeNameTest)step).getNodeName();\n-            switch(step.getAxis()){\n-                case Compiler.AXIS_ANCESTOR:\n-                    return new AncestorContext(context, false, name);\n-                case Compiler.AXIS_ANCESTOR_OR_SELF:\n-                    return new AncestorContext(context, true, name);\n-                case Compiler.AXIS_ATTRIBUTE:\n-                    return new AttributeContext(context, name);\n-                case Compiler.AXIS_CHILD:\n-                    return new ChildContext(context, name, false, false);\n-                case Compiler.AXIS_DESCENDANT:\n-                    return new DescendantContext(context, false, name);\n-                case Compiler.AXIS_DESCENDANT_OR_SELF:\n-                    return new DescendantContext(context, true, name);\n-                case Compiler.AXIS_FOLLOWING:\n-                    return new PrecedingOrFollowingContext(context, name, false);\n-                case Compiler.AXIS_FOLLOWING_SIBLING:\n-                    return new ChildContext(context, name, true, false);\n-                case Compiler.AXIS_NAMESPACE:\n-                    break;\n-                case Compiler.AXIS_PARENT:\n-                    return new ParentContext(context, name);\n-                case Compiler.AXIS_PRECEDING:\n-                    return new PrecedingOrFollowingContext(context, name, true);\n-                case Compiler.AXIS_PRECEDING_SIBLING:\n-                    return new ChildContext(context, name, true, true);\n-                case Compiler.AXIS_SELF:\n-                    return new SelfContext(context, name);\n-            }\n-        }\n-        else if (step instanceof NodeTypeTest){\n-            switch (step.getAxis()){\n-                case Compiler.AXIS_ANCESTOR:\n-                    return new AncestorContext(context, false, null);\n-                case Compiler.AXIS_ANCESTOR_OR_SELF:\n-                    return new AncestorContext(context, true, null);\n-                case Compiler.AXIS_ATTRIBUTE:\n-                    return new AttributeContext(context, null);\n-                case Compiler.AXIS_CHILD:\n-                    return new ChildContext(context, null, false, false);\n-                case Compiler.AXIS_DESCENDANT:\n-                    return new DescendantContext(context, false, null);\n-                case Compiler.AXIS_DESCENDANT_OR_SELF:\n-                    return new DescendantContext(context, true, null);\n-                case Compiler.AXIS_FOLLOWING:\n-                    return new PrecedingOrFollowingContext(context, null, false);\n-                case Compiler.AXIS_FOLLOWING_SIBLING:\n-                    return new ChildContext(context, null, true, false);\n-                case Compiler.AXIS_NAMESPACE:\n-                    break;\n-                case Compiler.AXIS_PARENT:\n-                    return new ParentContext(context, null);\n-                case Compiler.AXIS_PRECEDING:\n-                    return new PrecedingOrFollowingContext(context, null, true);\n-                case Compiler.AXIS_PRECEDING_SIBLING:\n-                    return new ChildContext(context, null, true, true);\n-                case Compiler.AXIS_SELF:\n-                    return context;\n-            }\n-        }\n-        throw new RuntimeException(\"Cannot create context for step: \" + step);\n+    protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest){\n+        switch(axis){\n+            case Compiler.AXIS_ANCESTOR:\n+                return new AncestorContext(context, false, nodeTest);\n+            case Compiler.AXIS_ANCESTOR_OR_SELF:\n+                return new AncestorContext(context, true, nodeTest);\n+            case Compiler.AXIS_ATTRIBUTE:\n+                return new AttributeContext(context, nodeTest);\n+            case Compiler.AXIS_CHILD:\n+                return new ChildContext(context, nodeTest, false, false);\n+            case Compiler.AXIS_DESCENDANT:\n+                return new DescendantContext(context, false, nodeTest);\n+            case Compiler.AXIS_DESCENDANT_OR_SELF:\n+                return new DescendantContext(context, true, nodeTest);\n+            case Compiler.AXIS_FOLLOWING:\n+                return new PrecedingOrFollowingContext(context, nodeTest, false);\n+            case Compiler.AXIS_FOLLOWING_SIBLING:\n+                return new ChildContext(context, nodeTest, true, false);\n+            case Compiler.AXIS_NAMESPACE:\n+                return new NamespaceContext(context, nodeTest);\n+            case Compiler.AXIS_PARENT:\n+                return new ParentContext(context, nodeTest);\n+            case Compiler.AXIS_PRECEDING:\n+                return new PrecedingOrFollowingContext(context, nodeTest, true);\n+            case Compiler.AXIS_PRECEDING_SIBLING:\n+                return new ChildContext(context, nodeTest, true, true);\n+            case Compiler.AXIS_SELF:\n+                return new SelfContext(context, nodeTest);\n+        }\n+        return null;        // Never happens\n     }\n \n     /**\n         }\n         Function function = getRootContext().getFunction(functionName, parameters);\n         if (function == null){\n-            throw new RuntimeException(\"No such function: \" + functionName.asString() +\n+            throw new RuntimeException(\"No such function: \" + functionName +\n                  Arrays.asList(parameters));\n         }\n \n \n             case Compiler.FUNCTION_LANG:\n             case Compiler.FUNCTION_ID:\n-            case Compiler.FUNCTION_LOCAL_NAME:\n-            case Compiler.FUNCTION_NAMESPACE_URI:{\n+            {\n                 System.err.println(\"UNIMPLEMENTED: \" + function);\n                 return null;\n             }\n-\n+            case Compiler.FUNCTION_LOCAL_NAME:          return functionLocalName(function);\n+            case Compiler.FUNCTION_NAMESPACE_URI:       return functionNamespaceURI(function);\n             case Compiler.FUNCTION_NAME:                return functionName(function);\n             case Compiler.FUNCTION_STRING:              return functionString(function);\n             case Compiler.FUNCTION_CONCAT:              return functionConcat(function);\n             case Compiler.FUNCTION_NOT:                 return functionNot(function);\n             case Compiler.FUNCTION_TRUE:                return functionTrue(function);\n             case Compiler.FUNCTION_FALSE:               return functionFalse(function);\n+            case Compiler.FUNCTION_NULL:                return functionNull(function);\n             case Compiler.FUNCTION_NUMBER:              return functionNumber(function);\n             case Compiler.FUNCTION_SUM:                 return functionSum(function);\n             case Compiler.FUNCTION_FLOOR:               return functionFloor(function);\n         // Move the position to the beginning and iterate through\n         // the context to count nodes.\n         int old = getCurrentPosition();\n+        setPosition(0);\n         int count = 0;\n-        if (setPosition(1)){\n-            count = 1;\n-            while (next()){\n-                count++;\n-            }\n-        }\n+        while(next()){\n+            count++;\n+        }\n+\n         // Restore the current position.\n         if (old != 0){\n             setPosition(old);\n         }\n-        return new Integer(count);\n+        return new Double(count);\n     }\n \n     protected Object functionPosition(CoreFunction function){\n         return new Double(count);\n     }\n \n-    protected Object functionName(CoreFunction function){\n+    protected Object functionNamespaceURI(CoreFunction function){\n         if (function.getArgumentCount() == 0){\n             return getCurrentNodePointer();\n         }\n         if (set instanceof EvalContext){\n             EvalContext ctx = (EvalContext)set;\n             if (ctx.nextSet() && ctx.next()){\n-                return ctx.getCurrentNodePointer().getName().asString();\n+                return ctx.getCurrentNodePointer().getNamespaceURI();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionLocalName(CoreFunction function){\n+        if (function.getArgumentCount() == 0){\n+            return getCurrentNodePointer();\n+        }\n+        assertArgCount(function, 1);\n+        Object set = eval(function.getArg1(), false);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.nextSet() && ctx.next()){\n+                return ctx.getCurrentNodePointer().getName().getName();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionName(CoreFunction function){\n+        if (function.getArgumentCount() == 0){\n+            return getCurrentNodePointer();\n+        }\n+        assertArgCount(function, 1);\n+        Object set = eval(function.getArg1(), false);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.nextSet() && ctx.next()){\n+                return ctx.getCurrentNodePointer().getExpandedName().toString();\n             }\n         }\n         return \"\";\n         return Boolean.FALSE;\n     }\n \n+    protected Object functionNull(CoreFunction function){\n+        assertArgCount(function, 0);\n+        return null;\n+    }\n+\n     protected Object functionNumber(CoreFunction function){\n         if (function.getArgumentCount() == 0){\n             return number(getCurrentNodePointer());\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.3 2001/09/08 20:59:58 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/08 20:59:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.4 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/08 20:59:58 $\n+ * @version $Revision: 1.4 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n      */\n     public Object getValue(String xpath){\n         Object result = eval(xpath, true);\n-        if (result instanceof NodePointer){\n-            result = ((NodePointer)result).getValue();\n-        }\n-        else if (result instanceof EvalContext){\n+        if (result instanceof EvalContext){\n             EvalContext ctx = (EvalContext)result;\n-            while(ctx.nextSet()){\n-                if (ctx.next()){\n-                    result = ctx.getCurrentNodePointer().getValue();\n-                    break;\n-                }\n-            }\n+            result = ctx.getContextNodePointer();\n+        }\n+\n+        if (result instanceof Pointer){\n+            result = ((Pointer)result).getValue();\n         }\n         if (result instanceof Node){\n             result = EvalContext.stringValue((Node)result);\n \n     public Pointer locateValue(String xpath){\n         Object result = eval(xpath, true);\n+        if (result instanceof EvalContext){\n+            result = ((EvalContext)result).getContextNodePointer();\n+        }\n         if (result instanceof Pointer){\n             return (Pointer)result;\n         }\n     }\n \n     public NodePointer getVariablePointer(QName name){\n-        String varName = name.asString();\n+        String varName = name.toString();\n         JXPathContext varCtx = this;\n         Variables vars = null;\n         while (varCtx != null){\n         if (func != null){\n             return func;\n         }\n-        throw new RuntimeException(\"Undefined function: \" + functionName.asString());\n+        throw new RuntimeException(\"Undefined function: \" + functionName.toString());\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class AncestorContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private boolean started = false;\n     private NodePointer currentNodePointer;\n     private boolean includeSelf;\n+    private HashSet visitedNodes = new HashSet();\n \n     /**\n      * @param parentContext represents the previous step on the path\n      * @param includeSelf differentiates between \"ancestor::\" and \"ancestor-or-self::\" axes\n      * @param nameTest is the name of the element(s) we are looking for\n      */\n-    public AncestorContext(EvalContext parentContext, boolean includeSelf, QName nameTest){\n+    public AncestorContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest){\n         super(parentContext);\n         this.includeSelf = includeSelf;\n-        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n-            this.nameTest = nameTest;\n-        }\n-        reset();\n+        this.nodeTest = nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n     }\n \n     public boolean setPosition(int position){\n-        if (position < this.position){\n-            reset();\n+        if (position == 0 || position < getCurrentPosition()){\n+            setStarted = false;\n         }\n \n-        while (this.position < position){\n+        while (getCurrentPosition() < position){\n             if (!next()){\n                 return false;\n             }\n         return true;\n     }\n \n-    public boolean nextSet(){\n-        reset();\n-\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n+    public boolean next(){\n+        while (nextIgnoreDuplicates()){\n+            NodePointer location = getCurrentNodePointer();\n+            if (!visitedNodes.contains(location)){\n+                visitedNodes.add(location.clone());\n+                position++;\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    public boolean nextIgnoreDuplicates(){\n+    /**\n+     * Returns true if there is another object in the current set, even\n+     * if that object has already been encountered in the same iteration.\n+     */\n+    private boolean nextIgnoreDuplicates(){\n         if (!setStarted){\n             setStarted = true;\n             currentNodePointer = parentContext.getCurrentNodePointer();\n             if (includeSelf){\n-                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                if (currentNodePointer.testNode(nodeTest)){\n                     return true;\n                 }\n             }\n         }\n \n         currentNodePointer = currentNodePointer.getParent();\n-        if (currentNodePointer == null){\n-            return false;\n-        }\n \n-        if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    /**\n-     * Back to position=0\n-     */\n-    protected void reset(){\n-        super.reset();\n-        setStarted = false;\n+        return currentNodePointer != null && currentNodePointer.testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.1 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.2 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"attribute::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class AttributeContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private boolean started = false;\n-    private DOMAttributeIterator iterator;\n+    private NodeIterator iterator;\n     private NodePointer currentNodePointer;\n \n     /**\n      * @param parentContext represents the previous step on the path\n      * @param nameTest is the name of the attribute we are looking for\n      */\n-    public AttributeContext(EvalContext parentContext, QName nameTest){\n+    public AttributeContext(EvalContext parentContext, NodeTest nodeTest){\n         super(parentContext);\n-        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n-            this.nameTest = nameTest;\n-        }\n-        reset();\n+        this.nodeTest = nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n     }\n \n     public boolean setPosition(int position){\n-        if (position < this.position){\n-            reset();\n+        if (position == 0 || position < getCurrentPosition()){\n+            setStarted = false;\n+            iterator = null;\n+            super.setPosition(0);\n         }\n \n-        while (this.position < position){\n+        while (getCurrentPosition() < position){\n             if (!next()){\n                 return false;\n             }\n         return true;\n     }\n \n-    public boolean nextSet(){\n-        reset();\n-\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n     public boolean next(){\n+        super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted){\n             setStarted = true;\n-            if (nameTest != null){\n-                currentNodePointer = parentContext.getCurrentNodePointer().attributePointer(nameTest);\n-                return currentNodePointer != null;\n+            if (!(nodeTest instanceof NodeNameTest)){\n+                return false;\n             }\n-            else {\n-                iterator = new DOMAttributeIterator(parentContext.getCurrentNodePointer());\n-            }\n+            QName name = ((NodeNameTest)nodeTest).getNodeName();\n+            iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\n         }\n \n         if (iterator == null){\n         currentNodePointer = iterator.getNodePointer();\n         return true;\n     }\n-\n-    /**\n-     * Back to position=0\n-     */\n-    protected void reset(){\n-        super.reset();\n-        setStarted = false;\n-        iterator = null;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class ChildContext extends EvalContext {\n-    private boolean started = false;\n-    private QName property;\n+    private NodeTest nodeTest;\n     private boolean startFromParentLocation;\n     private boolean reverse;\n     private NodeIterator iterator;\n-    private boolean firstIteration = true;\n-    private int parentCount;\n-    private NodePointer singleParentPointer;\n \n-    public ChildContext(EvalContext parentContext, QName property, boolean startFromParentLocation, boolean reverse){\n+    public ChildContext(EvalContext parentContext, NodeTest nodeTest, boolean startFromParentLocation, boolean reverse){\n         super(parentContext);\n-        this.property = property;\n+        this.nodeTest = nodeTest;\n         this.startFromParentLocation = startFromParentLocation;\n         this.reverse = reverse;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n-        return iterator.getNodePointer();\n+        if (iterator != null){\n+            return iterator.getNodePointer();\n+        }\n+        else {\n+            return null;\n+        }\n     }\n \n     /**\n      * of books rather than the first book from that collection.\n      */\n     public Pointer getContextNodePointer(){\n-        Pointer ptr = super.getContextNodePointer();\n-        if (parentCount != 1){\n-            return ptr;\n+        if (position == 0){\n+            while(nextSet()){\n+                prepare();\n+                if (iterator == null){\n+                    return null;\n+                }\n+                // See if there is a property there, singular or collection\n+                if (iterator.getNodePointer() != null){\n+                    break;\n+                }\n+            }\n         }\n-        else {\n-            if (startFromParentLocation){\n-                // TBD: check type\n-                iterator = singleParentPointer.siblingIterator(property, reverse);\n-            }\n-            else {\n-                iterator = singleParentPointer.childIterator(property, reverse);\n-            }\n-            return iterator.getNodePointer();\n-        }\n+        return getCurrentNodePointer();\n     }\n \n     public boolean next(){\n-        if (iterator == null){\n-            prepare();\n-        }\n-        return iterator.setPosition(iterator.getPosition() + 1);\n+        return setPosition(getCurrentPosition() + 1);\n     }\n \n     public boolean setPosition(int position){\n-        if (iterator == null){\n-            prepare();\n-        }\n-        return iterator.setPosition(position);\n-    }\n-\n-    public int getCurrentPosition(){\n-        return iterator.getPosition();\n-    }\n-\n-    public boolean nextSet(){\n-        iterator = null;\n-\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    parentCount++;\n-                    singleParentPointer = parentContext.getCurrentNodePointer();\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-                    parentCount++;\n-                    singleParentPointer = parentContext.getCurrentNodePointer();\n+        int oldPosition = getCurrentPosition();\n+        super.setPosition(position);\n+        if (position == 0){\n+            iterator = null;\n             return true;\n         }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n-                    parentCount++;\n-                    singleParentPointer = parentContext.getCurrentNodePointer();\n-                return true;\n+        else {\n+            if (oldPosition == 0){\n+                prepare();\n             }\n+            if (iterator == null){\n+                return false;\n+            }\n+            return iterator.setPosition(position);\n         }\n-        return false;\n     }\n \n     /**\n     private void prepare(){\n         NodePointer parent = parentContext.getCurrentNodePointer();\n         if (startFromParentLocation){\n-            // TBD: check type\n-            iterator = parent.siblingIterator(property, reverse);\n+            iterator = parent.siblingIterator(nodeTest, reverse);\n         }\n         else {\n-            iterator = parent.childIterator(property, reverse);\n+            iterator = parent.childIterator(nodeTest, reverse);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class DescendantContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private boolean started = false;\n     private Stack stack;\n     private NodePointer currentNodePointer;\n     private boolean includeSelf;\n \n-    public DescendantContext(EvalContext parentContext, boolean includeSelf, QName nameTest){\n+    public DescendantContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest){\n         super(parentContext);\n         this.includeSelf = includeSelf;\n-        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n-            this.nameTest = nameTest;\n-        }\n-        reset();\n+        this.nodeTest = nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n     }\n \n     public boolean setPosition(int position){\n-        if (position < this.position){\n-            reset();\n+        if (position == 0 || position < this.position){\n+            stack = new Stack();\n+            setStarted = false;\n         }\n \n         while (this.position < position){\n         return true;\n     }\n \n-    public boolean nextSet(){\n-        reset();\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n     public boolean next(){\n         if (!setStarted){\n             setStarted = true;\n                 stack.push(currentNodePointer.childIterator(null, false));\n             }\n             if (includeSelf){\n-                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                if (currentNodePointer.testNode(nodeTest)){\n                     position++;\n                     return true;\n                 }\n                 if (!currentNodePointer.isLeaf()){\n                     stack.push(currentNodePointer.childIterator(null, false));\n                 }\n-                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                if (currentNodePointer.testNode(nodeTest)){\n                     position++;\n                     return true;\n                 }\n         }\n         return false;\n     }\n-\n-    protected void reset(){\n-        super.reset();\n-        stack = new Stack();\n-        setStarted = false;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.2 2001/09/21 23:22:43 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:43 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.pointers.*;\n import java.util.*;\n \n /**\n+ * A single-set EvalContext that provides access to the current node of\n+ * the parent context and nothing else.  It does not pass the iteration\n+ * on to the parent context.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:43 $\n  */\n public class InitialContext extends EvalContext {\n     private boolean startedSet = false;\n     public InitialContext(EvalContext parentContext){\n         super(parentContext);\n         nodePointer = (NodePointer)parentContext.getCurrentNodePointer().clone();\n-        position = 0;\n         collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n+    }\n+\n+    public Pointer getContextNodePointer(){\n+        return nodePointer;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.1 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/21 23:22:44 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+\n+import java.util.*;\n+\n+/**\n+ * EvalContext that walks the \"namespace::\" axis.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/21 23:22:44 $\n+ */\n+public class NamespaceContext extends EvalContext {\n+    private NodeTest nodeTest;\n+    private boolean setStarted = false;\n+    private NodeIterator iterator;\n+    private NodePointer currentNodePointer;\n+\n+    /**\n+     * @param parentContext represents the previous step on the path\n+     * @param nodeTest is the name of the namespace we are looking for\n+     */\n+    public NamespaceContext(EvalContext parentContext, NodeTest nodeTest){\n+        super(parentContext);\n+        this.nodeTest = nodeTest;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (position == 0 || position < getCurrentPosition()){\n+            setStarted = false;\n+            iterator = null;\n+            super.setPosition(0);\n+        }\n+\n+        while (getCurrentPosition() < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean next(){\n+        super.setPosition(getCurrentPosition() + 1);\n+        if (!setStarted){\n+            setStarted = true;\n+            if (!(nodeTest instanceof NodeNameTest)){\n+                return false;\n+            }\n+\n+            QName testName = ((NodeNameTest)nodeTest).getNodeName();\n+            if (testName.getPrefix() != null){\n+                return false;\n+            }\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\")){\n+                iterator = parentContext.getCurrentNodePointer().namespaceIterator();\n+            }\n+            else {\n+                currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testLocalName);\n+                return currentNodePointer != null;\n+            }\n+        }\n+\n+        if (iterator == null){\n+            return false;\n+        }\n+        if (!iterator.setPosition(iterator.getPosition() + 1)){\n+            return false;\n+        }\n+        currentNodePointer = iterator.getNodePointer();\n+        return true;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n \n /**\n+ * EvalContext that walks the \"parent::\" axis.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class ParentContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private boolean started = false;\n     private NodePointer currentNodePointer;\n     private HashSet visitedNodes = new HashSet();\n \n-    public ParentContext(EvalContext parentContext, QName nameTest){\n+    public ParentContext(EvalContext parentContext, NodeTest nodeTest){\n         super(parentContext);\n-        if (nameTest != null && nameTest.getName() != \"*\"){\n-            this.nameTest = nameTest;\n-        }\n+        this.nodeTest = nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n     }\n \n     public boolean setPosition(int position){\n+        super.setPosition(position);\n+        if (position == 0){\n+            setStarted = false;\n+        }\n         return position == 1;\n     }\n \n-    public boolean nextSet(){\n-        setStarted = false;\n-\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (nextParent()){\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (nextParent()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (nextParent()){\n+    public boolean next(){\n+        while (nextIgnoreDuplicates()){\n+            NodePointer location = getCurrentNodePointer();\n+            if (!visitedNodes.contains(location)){\n+                visitedNodes.add(location.clone());\n+                position++;\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean nextParent(){\n-        while (parentContext.next()){\n-            NodePointer thisLocation = parentContext.getCurrentNodePointer();\n-            currentNodePointer = thisLocation.getParent();\n-            if (currentNodePointer != null && !visitedNodes.contains(currentNodePointer)){\n-                if (nameTest == null || currentNodePointer.getName().equals(nameTest)){\n-                    visitedNodes.add(currentNodePointer.clone());\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public boolean next(){\n+    /**\n+     * Returns true if there is another object in the current set, even\n+     * if that object has already been encountered in the same iteration.\n+     */\n+    private boolean nextIgnoreDuplicates(){\n         // Each set contains exactly one node: the parent\n         if (setStarted){\n             return false;\n         }\n         setStarted = true;\n-        return true;\n+        NodePointer thisLocation = parentContext.getCurrentNodePointer();\n+        currentNodePointer = thisLocation.getParent();\n+        return currentNodePointer != null && currentNodePointer.testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.3 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.beans.*;\n \n /**\n+ * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean setStarted = false;\n     private boolean started = false;\n     private Stack stack;\n     private boolean includeSelf;\n     private boolean reverse;\n \n-    public PrecedingOrFollowingContext(EvalContext parentContext, QName nameTest, boolean reverse){\n+    public PrecedingOrFollowingContext(EvalContext parentContext, NodeTest nodeTest, boolean reverse){\n         super(parentContext);\n         this.includeSelf = includeSelf;\n-        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n-            this.nameTest = nameTest;\n-        }\n+        this.nodeTest = nodeTest;\n         this.reverse = reverse;\n-        reset();\n-    }\n-\n-    protected void reset(){\n-        super.reset();\n-        stack = new Stack();\n-        setStarted = false;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n     }\n \n     public boolean setPosition(int position){\n-        if (position < this.position){\n-            reset();\n+        if (position == 0 || position < this.position){\n+            stack = new Stack();\n+            setStarted = false;\n         }\n \n         while (this.position < position){\n             }\n         }\n         return true;\n-    }\n-\n-    public boolean nextSet(){\n-        reset();\n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n \n     public boolean next(){\n                 if (currentRootLocation == null || currentRootLocation.isRoot()){\n                     break;\n                 }\n-//                System.err.println(\"PUSHING: \" + currentRootLocation);\n                 // TBD: check type\n                 stack.push(currentRootLocation.siblingIterator(null, reverse));\n             }\n \n             while (!stack.isEmpty()){\n                 if (!reverse){\n-                    PropertyIterator it = (PropertyIterator)stack.peek();\n+                    NodeIterator it = (NodeIterator)stack.peek();\n                     if (it.setPosition(it.getPosition() + 1)){\n                         currentNodePointer = it.getNodePointer();\n                         if (!currentNodePointer.isLeaf()){\n                             stack.push(currentNodePointer.childIterator(null, reverse));\n                         }\n-                        if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n-                            position++;\n+                        if (currentNodePointer.testNode(nodeTest)){\n+                            super.setPosition(getCurrentPosition() + 1);\n                             return true;\n                         }\n                     }\n                     }\n                 }\n                 else {\n-                    PropertyIterator it = (PropertyIterator)stack.peek();\n+                    NodeIterator it = (NodeIterator)stack.peek();\n                     if (it.setPosition(it.getPosition() + 1)){\n                         currentNodePointer = it.getNodePointer();\n                         if (!currentNodePointer.isLeaf()){\n                             stack.push(currentNodePointer.childIterator(null, reverse));\n                         }\n-                        else if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n-                            position++;\n+                        else if (currentNodePointer.testNode(nodeTest)){\n+                            super.setPosition(getCurrentPosition() + 1);\n                             return true;\n                         }\n                     }\n                         if (!stack.isEmpty()){\n                             it = (PropertyIterator)stack.peek();\n                             currentNodePointer = it.getNodePointer();\n-                            if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n-                                position++;\n+                            if (currentNodePointer.testNode(nodeTest)){\n+                                super.setPosition(getCurrentPosition() + 1);\n                                 return true;\n                             }\n                         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.3 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.EvalContext;\n \n /**\n+ * EvalContext that checks predicates.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n         this.expression = expression;\n         dynamicPropertyNameExpression = (Expression)expression.\n             getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-    }\n-\n-    public int getCurrentPosition(){\n-        return position;\n     }\n \n     public boolean next(){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n \n /**\n+ * EvalContext that is used to hold the root node for the path traversal.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class RootContext extends EvalContext {\n     private boolean startedSet = false;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.pointers.*;\n import java.util.*;\n \n /**\n+ * EvalContext that returns the current node from the parent context if the test succeeds.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class SelfContext extends EvalContext {\n-    private QName nameTest;\n+    private NodeTest nodeTest;\n     private boolean startedSet = false;\n-    private boolean started = false;\n+    private NodePointer contextNodePointer;\n+    private NodePointer nodePointer;\n \n-    public SelfContext(EvalContext parentContext, QName nameTest){\n+    public SelfContext(EvalContext parentContext, NodeTest nodeTest){\n         super(parentContext);\n-        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n-            this.nameTest = nameTest;\n+        this.nodeTest = nodeTest;\n+    }\n+\n+    public Pointer getContextNodePointer(){\n+        if (setPosition(1)){\n+            return contextNodePointer;\n         }\n+        return null;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n-        return parentContext.getCurrentNodePointer();\n+        return nodePointer;\n     }\n \n-    public int getCurrentPosition(){\n-        return 1;\n+    public boolean next(){\n+        return setPosition(getCurrentPosition() + 1);\n     }\n \n     public boolean setPosition(int position){\n-        return position == 1;\n-    }\n+        super.setPosition(position);\n+        if (position == 0){\n+            startedSet = false;\n+            return true;\n+        }\n \n-    public boolean nextSet(){\n-        startedSet = false;\n+        if (!startedSet){\n+            startedSet = true;\n+            contextNodePointer = (NodePointer)parentContext.getContextNodePointer();\n+        }\n \n-        // First time this method is called, we should look for\n-        // the first parent set that contains at least one node.\n-        if (!started){\n-            started = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    return true;\n-                }\n-            }\n+        if (contextNodePointer == null){\n             return false;\n         }\n \n-        // In subsequent calls, we see if the parent context\n-        // has any nodes left in the current set\n-        if (parentContext.next()){\n-            return true;\n-        }\n-\n-        // If not, we look for the next set that contains\n-        // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    public boolean next(){\n-        if (startedSet){\n+        nodePointer = (NodePointer)contextNodePointer.clone();\n+        if (position < 1 || position > nodePointer.getLength()){\n             return false;\n         }\n-\n-        startedSet = true;\n-\n-        if (nameTest != null){\n-            return nameTest.equals(getCurrentNodePointer().getName());\n-        }\n-\n-        return true;\n+        nodePointer.setIndex(position - 1);\n+        return nodeTest == null || nodePointer.testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of a union operation like (a | b)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class UnionContext extends EvalContext {\n     private boolean startedSet = false;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class CoreOperation extends Operation {\n \n                 Step[] steps = ((LocationPath)arg1).getSteps();\n                 if (steps.length == 1 &&\n                         steps[0].getAxis() == Compiler.AXIS_ATTRIBUTE &&\n-                        steps[0] instanceof NodeNameTest &&\n-                        ((NodeNameTest)steps[0]).getNodeName().equals(QNAME_NAME)){\n+                        steps[0].getNodeTest() instanceof NodeNameTest &&\n+                        ((NodeNameTest)steps[0].getNodeTest()).getNodeName().equals(QNAME_NAME)){\n                     dynamicPropertyAccessHint = getArg2();\n                 }\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class LocationPath extends Path {\n \n             Step[] steps = getSteps();\n             for (int i = 0; i < steps.length; i++){\n                 if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n-                        !(steps[i] instanceof NodeNameTest) ||\n-                        ((NodeNameTest)steps[i]).getNodeName().getName().equals(\"*\")){\n+                        !(steps[i].getNodeTest() instanceof NodeNameTest) ||\n+                        ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName().equals(\"*\")){\n                     basic = false;\n                     break;\n                 }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n-public class NodeNameTest extends Step {\n+public class NodeNameTest extends NodeTest {\n     private QName qname;\n \n-    public NodeNameTest(int axis, QName qname, Expression predicates[]){\n-        super(axis, predicates);\n+    public NodeNameTest(QName qname){\n         this.qname = qname;\n     }\n \n     }\n \n     public String toString(){\n-        StringBuffer buffer = new StringBuffer();\n-        buffer.append(\"(NODE_NAME_TEST \");\n-        buffer.append(axisToString(getAxis()));\n-        buffer.append(\" \");\n-        buffer.append(qname);\n-        Expression[] predicates = getPredicates();\n-        if (predicates != null){\n-            buffer.append(' ');\n-            for (int i = 0; i < predicates.length; i++){\n-                buffer.append('[');\n-                buffer.append(predicates[i]);\n-                buffer.append(']');\n-            }\n-        }\n-        buffer.append(')');\n-        return buffer.toString();\n+        return qname.toString();\n     }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTest.java,v 1.1 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/21 23:22:44 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/21 23:22:44 $\n+ */\n+public abstract class NodeTest {\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n-public class NodeTypeTest extends Step {\n+public class NodeTypeTest extends NodeTest {\n     private int nodeType;\n \n-    public NodeTypeTest(int axis, int nodeType, Expression predicates[]){\n-        super(axis, predicates);\n+    public NodeTypeTest(int nodeType){\n         this.nodeType = nodeType;\n     }\n \n     }\n \n     public String toString(){\n-        StringBuffer buffer = new StringBuffer();\n-        buffer.append(\"(NODE_TYPE_TEST \");\n-        buffer.append(axisToString(getAxis()));\n-        buffer.append(\" \");\n-        buffer.append(nodeTypeToString(nodeType));\n-        Expression predicates[] = getPredicates();\n-        if (predicates != null){\n-            buffer.append(' ');\n-            for (int i = 0; i < predicates.length; i++){\n-                buffer.append('[');\n-                buffer.append(predicates[i]);\n-                buffer.append(']');\n-            }\n-        }\n-        buffer.append(')');\n-        return buffer.toString();\n+        return nodeTypeToString(nodeType) + \"()\";\n     }\n \n     public static String nodeTypeToString(int code){\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n-public class ProcessingInstructionTest extends Step {\n-    private String instruction;\n+public class ProcessingInstructionTest extends NodeTest {\n+    private String target;\n \n-    public ProcessingInstructionTest(int axis, String instruction, Expression predicates[]){\n-        super(axis, predicates);\n-        this.instruction = instruction;\n+    public ProcessingInstructionTest(String target){\n+        this.target = target;\n+    }\n+\n+    public String getTarget(){\n+        return target;\n     }\n \n     public String toString(){\n-        StringBuffer buffer = new StringBuffer();\n-        buffer.append(\"(PROCESSING-INSTRUCTION \");\n-        buffer.append(axisToString(getAxis()));\n-        buffer.append(\" \");\n-        buffer.append(instruction);\n-        Expression predicates[] = getPredicates();\n-        if (predicates != null){\n-            buffer.append(' ');\n-            for (int i = 0; i < predicates.length; i++){\n-                buffer.append('[');\n-                buffer.append(predicates[i]);\n-                buffer.append(']');\n-            }\n-        }\n-        buffer.append(')');\n-        return buffer.toString();\n+        return \"processing-instruction(\" + target + \")\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/QName.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Attic/QName.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Attic/QName.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class QName {\n     private String prefix;\n         return name;\n     }\n \n-    public String asString(){\n+    public String toString(){\n         if (prefix != null){\n             return prefix + ':' + name;\n         }\n         return true;\n     }\n \n-    public String toString(){\n-        StringBuffer buffer = new StringBuffer();\n-        buffer.append(\"(QNAME \");\n-        buffer.append(asString());\n-        buffer.append(')');\n-        return buffer.toString();\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n-public abstract class Step {\n+public class Step {\n     private int axis;\n+    private NodeTest nodeTest;\n     private Expression[] predicates;\n \n-    protected Step(int axis, Expression[] predicates){\n+    protected Step(int axis, NodeTest nodeTest, Expression[] predicates){\n         this.axis = axis;\n+        this.nodeTest = nodeTest;\n         this.predicates = predicates;\n     }\n \n     public int getAxis(){\n         return axis;\n+    }\n+\n+    public NodeTest getNodeTest(){\n+        return nodeTest;\n     }\n \n     public Expression[] getPredicates(){\n         }\n     }\n \n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(axisToString(getAxis()));\n+        buffer.append(\"::\");\n+        buffer.append(nodeTest);\n+        Expression[] predicates = getPredicates();\n+        if (predicates != null){\n+            for (int i = 0; i < predicates.length; i++){\n+                buffer.append('[');\n+                buffer.append(predicates[i]);\n+                buffer.append(']');\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n     public static String axisToString(int axis){\n         switch (axis){\n             case Compiler.AXIS_SELF:                 return \"self\";\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:44 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n  */\n public class TreeCompiler implements Compiler {\n \n         return new ExpressionPath((Expression)expression, toExpressionArray(predicates), toStepArray(steps));\n     }\n \n-    public Object nodeNameTest(int axis, Object qname, Object[] predicates){\n-        return new NodeNameTest(axis, (QName)qname, toExpressionArray(predicates));\n-    }\n-\n-    public Object nodeTypeTest(int axis, int nodeType, Object[] predicates){\n-        return new NodeTypeTest(axis, nodeType, toExpressionArray(predicates));\n-    }\n-\n-    public Object processingInstructionTest(int axis, String instruction, Object[] predicates){\n-        return new ProcessingInstructionTest(axis, instruction, toExpressionArray(predicates));\n+    public Object nodeNameTest(Object qname){\n+        return new NodeNameTest((QName)qname);\n+    }\n+\n+    public Object nodeTypeTest(int nodeType){\n+        return new NodeTypeTest(nodeType);\n+    }\n+\n+    public Object processingInstructionTest(String instruction){\n+        return new ProcessingInstructionTest(instruction);\n+    }\n+\n+    public Object step(int axis, Object nodeTest, Object[] predicates){\n+        return new Step(axis, (NodeTest)nodeTest, toExpressionArray(predicates));\n     }\n \n     private Expression[] toExpressionArray(Object[] array){\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParser.java\n     case FUNCTION_FALSE:\n       jj_consume_token(FUNCTION_FALSE);\n       break;\n+    case FUNCTION_NULL:\n+      jj_consume_token(FUNCTION_NULL);\n+      break;\n     case FUNCTION_LANG:\n       jj_consume_token(FUNCTION_LANG);\n       break;\n       jj_consume_token(FUNCTION_FALSE);\n                                       code = Compiler.FUNCTION_FALSE;\n       break;\n+    case FUNCTION_NULL:\n+      jj_consume_token(FUNCTION_NULL);\n+                                      code = Compiler.FUNCTION_NULL;\n+      break;\n     case FUNCTION_LANG:\n       jj_consume_token(FUNCTION_LANG);\n                                       code = Compiler.FUNCTION_LANG;\n  String nc1, nc2 = null;\n     nc1 = NCName();\n     switch (jj_nt.kind) {\n-    case 72:\n-      jj_consume_token(72);\n+    case 73:\n+      jj_consume_token(73);\n       nc2 = NCName();\n       break;\n     default:\n     String nc1, nc2 = null;\n     if (jj_2_1(2147483647)) {\n       nc1 = NCName();\n-      jj_consume_token(72);\n+      jj_consume_token(73);\n       nc2 = NCName();\n     } else {\n       switch (jj_nt.kind) {\n     case FUNCTION_NOT:\n     case FUNCTION_TRUE:\n     case FUNCTION_FALSE:\n+    case FUNCTION_NULL:\n     case FUNCTION_LANG:\n     case FUNCTION_NUMBER:\n     case FUNCTION_SUM:\n     case FUNCTION_CEILING:\n     case FUNCTION_ROUND:\n     case NCName:\n-    case 75:\n     case 76:\n-    case 79:\n-    case 81:\n+    case 77:\n+    case 80:\n+    case 82:\n       ex = RelativeLocationPath();\n       break;\n     case SLASH:\n \n /* [4] Step ::= AxisSpecifier NodeTest Predicate*   | AbbreviatedStep  */\n   final public void LocationStep(ArrayList steps) throws ParseException {\n+    Object t;\n     Object s;\n     switch (jj_nt.kind) {\n     case SLASH:\n     case SLASHSLASH:\n       jj_consume_token(SLASHSLASH);\n             // Abbreviated step: descendant-or-self::node()\n-            steps.add(compiler.nodeTypeTest(Compiler.AXIS_DESCENDANT_OR_SELF, Compiler.NODE_TYPE_NODE, null));\n+            t = compiler.nodeTypeTest(Compiler.NODE_TYPE_NODE);\n+            steps.add(compiler.step(Compiler.AXIS_DESCENDANT_OR_SELF, t, null));\n       break;\n     default:\n       jj_la1[9] = jj_gen;\n     case FUNCTION_NOT:\n     case FUNCTION_TRUE:\n     case FUNCTION_FALSE:\n+    case FUNCTION_NULL:\n     case FUNCTION_LANG:\n     case FUNCTION_NUMBER:\n     case FUNCTION_SUM:\n     case FUNCTION_CEILING:\n     case FUNCTION_ROUND:\n     case NCName:\n-    case 79:\n-    case 81:\n+    case 80:\n+    case 82:\n       axis = AxisSpecifier();\n       if (jj_2_3(2147483647)) {\n         type = NodeType();\n-        jj_consume_token(73);\n         jj_consume_token(74);\n+        jj_consume_token(75);\n       } else if (jj_2_4(2147483647)) {\n         jj_consume_token(PI);\n-        jj_consume_token(73);\n+        jj_consume_token(74);\n         jj_consume_token(Literal);\n-                                                    instruction = token.image;\n-        jj_consume_token(74);\n+                    instruction = unescape(token.image.substring(1, token.image.length() - 1));\n+        jj_consume_token(75);\n       } else {\n         switch (jj_nt.kind) {\n         case OR:\n         case FUNCTION_NOT:\n         case FUNCTION_TRUE:\n         case FUNCTION_FALSE:\n+        case FUNCTION_NULL:\n         case FUNCTION_LANG:\n         case FUNCTION_NUMBER:\n         case FUNCTION_SUM:\n         case FUNCTION_CEILING:\n         case FUNCTION_ROUND:\n         case NCName:\n-        case 81:\n+        case 82:\n           name = WildcardName();\n           break;\n         default:\n         }\n       }\n       break;\n-    case 75:\n-      jj_consume_token(75);\n+    case 76:\n+      jj_consume_token(76);\n                     axis = Compiler.AXIS_SELF;\n                     type = Compiler.NODE_TYPE_NODE;\n       break;\n-    case 76:\n-      jj_consume_token(76);\n+    case 77:\n+      jj_consume_token(77);\n                     axis = Compiler.AXIS_PARENT;\n                     type = Compiler.NODE_TYPE_NODE;\n       break;\n     label_3:\n     while (true) {\n       switch (jj_nt.kind) {\n-      case 77:\n+      case 78:\n         ;\n         break;\n       default:\n                 ps.add(p);\n     }\n         if (name != null){\n-            s = compiler.nodeNameTest(axis, name, ps.toArray());\n+            s = compiler.nodeNameTest(name);\n         }\n         else if (instruction != null){\n-            s = compiler.processingInstructionTest(axis, instruction, ps.toArray());\n+            s = compiler.processingInstructionTest(instruction);\n         }\n         else {\n-            s = compiler.nodeTypeTest(axis, type, ps.toArray());\n+            s = compiler.nodeTypeTest(type);\n         }\n-        steps.add(s);\n+        steps.add(compiler.step(axis, s, ps.toArray()));\n   }\n \n /* [5] AxisSpecifier ::=    AxisName '::' | AbbreviatedAxisSpecifier  */\n /* [9] PredicateExpr ::=  Expr  */\n   final public Object Predicate() throws ParseException {\n     Object ex;\n-    jj_consume_token(77);\n+    jj_consume_token(78);\n     ex = Expression();\n-    jj_consume_token(78);\n+    jj_consume_token(79);\n         {if (true) return ex;}\n     throw new Error(\"Missing return statement in function\");\n   }\n   final public int AbbreviatedAxisSpecifier() throws ParseException {\n     int axis = Compiler.AXIS_CHILD;\n     switch (jj_nt.kind) {\n-    case 79:\n-      jj_consume_token(79);\n+    case 80:\n+      jj_consume_token(80);\n            axis = Compiler.AXIS_ATTRIBUTE;\n       break;\n     default:\n     case VARIABLE:\n       ex = VariableReference();\n       break;\n-    case 73:\n-      jj_consume_token(73);\n+    case 74:\n+      jj_consume_token(74);\n       ex = Expression();\n-      jj_consume_token(74);\n+      jj_consume_token(75);\n       break;\n     case Literal:\n       jj_consume_token(Literal);\n         case FUNCTION_NOT:\n         case FUNCTION_TRUE:\n         case FUNCTION_FALSE:\n+        case FUNCTION_NULL:\n         case FUNCTION_LANG:\n         case FUNCTION_NUMBER:\n         case FUNCTION_SUM:\n   final public ArrayList ArgumentList() throws ParseException {\n     ArrayList args = null;\n     Object arg;\n-    jj_consume_token(73);\n+    jj_consume_token(74);\n     switch (jj_nt.kind) {\n     case SLASH:\n     case SLASHSLASH:\n     case FUNCTION_NOT:\n     case FUNCTION_TRUE:\n     case FUNCTION_FALSE:\n+    case FUNCTION_NULL:\n     case FUNCTION_LANG:\n     case FUNCTION_NUMBER:\n     case FUNCTION_SUM:\n     case FUNCTION_CEILING:\n     case FUNCTION_ROUND:\n     case NCName:\n-    case 73:\n-    case 75:\n+    case 74:\n     case 76:\n-    case 79:\n-    case 81:\n+    case 77:\n+    case 80:\n+    case 82:\n       arg = Argument();\n                                 args = new ArrayList(); args.add(arg);\n       label_4:\n       while (true) {\n         switch (jj_nt.kind) {\n-        case 80:\n+        case 81:\n           ;\n           break;\n         default:\n           jj_la1[18] = jj_gen;\n           break label_4;\n         }\n-        jj_consume_token(80);\n+        jj_consume_token(81);\n         arg = Argument();\n                                        args.add(arg);\n       }\n       jj_la1[19] = jj_gen;\n       ;\n     }\n-    jj_consume_token(74);\n+    jj_consume_token(75);\n         {if (true) return args;}\n     throw new Error(\"Missing return statement in function\");\n   }\n       case FUNCTION_NOT:\n       case FUNCTION_TRUE:\n       case FUNCTION_FALSE:\n+      case FUNCTION_NULL:\n       case FUNCTION_LANG:\n       case FUNCTION_NUMBER:\n       case FUNCTION_SUM:\n       case FUNCTION_CEILING:\n       case FUNCTION_ROUND:\n       case NCName:\n-      case 75:\n       case 76:\n-      case 79:\n-      case 81:\n+      case 77:\n+      case 80:\n+      case 82:\n         ex = LocationPath();\n         break;\n       default:\n     label_6:\n     while (true) {\n       switch (jj_nt.kind) {\n-      case 77:\n+      case 78:\n         ;\n         break;\n       default:\n       switch (jj_nt.kind) {\n       case MOD:\n       case DIV:\n-      case 81:\n+      case 82:\n         ;\n         break;\n       default:\n         break label_14;\n       }\n       switch (jj_nt.kind) {\n-      case 81:\n-        jj_consume_token(81);\n+      case 82:\n+        jj_consume_token(82);\n         r = UnaryExpr();\n                                     ex = compiler.multiply(ex, r);\n         break;\n     case FUNCTION_NOT:\n     case FUNCTION_TRUE:\n     case FUNCTION_FALSE:\n+    case FUNCTION_NULL:\n     case FUNCTION_LANG:\n     case FUNCTION_NUMBER:\n     case FUNCTION_SUM:\n     case FUNCTION_CEILING:\n     case FUNCTION_ROUND:\n     case NCName:\n-    case 73:\n-    case 75:\n+    case 74:\n     case 76:\n-    case 79:\n-    case 81:\n+    case 77:\n+    case 80:\n+    case 82:\n       ex = UnionExpr();\n       break;\n     case MINUS:\n     Object qn;\n     String nc1, nc2 = null;\n     switch (jj_nt.kind) {\n-    case 81:\n-      jj_consume_token(81);\n+    case 82:\n+      jj_consume_token(82);\n       break;\n     case OR:\n     case AND:\n     case FUNCTION_NOT:\n     case FUNCTION_TRUE:\n     case FUNCTION_FALSE:\n+    case FUNCTION_NULL:\n     case FUNCTION_LANG:\n     case FUNCTION_NUMBER:\n     case FUNCTION_SUM:\n     }\n                            nc1 = token.image;\n     switch (jj_nt.kind) {\n-    case 72:\n-      jj_consume_token(72);\n+    case 73:\n+      jj_consume_token(73);\n       switch (jj_nt.kind) {\n-      case 81:\n-        jj_consume_token(81);\n+      case 82:\n+        jj_consume_token(82);\n         break;\n       case OR:\n       case AND:\n       case FUNCTION_NOT:\n       case FUNCTION_TRUE:\n       case FUNCTION_FALSE:\n+      case FUNCTION_NULL:\n       case FUNCTION_LANG:\n       case FUNCTION_NUMBER:\n       case FUNCTION_SUM:\n     return retval;\n   }\n \n+  final private boolean jj_3R_87() {\n+    if (jj_scan_token(FUNCTION_ROUND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_59() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_58() {\n+    if (jj_scan_token(COMMENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_86() {\n+    if (jj_scan_token(FUNCTION_CEILING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_57() {\n+    if (jj_scan_token(NODE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_85() {\n+    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_84() {\n+    if (jj_scan_token(FUNCTION_SUM)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_56() {\n+    if (jj_scan_token(TEXT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_83() {\n+    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_82() {\n+    if (jj_scan_token(FUNCTION_LANG)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_81() {\n+    if (jj_scan_token(FUNCTION_NULL)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_80() {\n+    if (jj_scan_token(FUNCTION_FALSE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_79() {\n+    if (jj_scan_token(FUNCTION_TRUE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_78() {\n+    if (jj_scan_token(FUNCTION_NOT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_17() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_56()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_57()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_58()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_59()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_77() {\n+    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_76() {\n+    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_75() {\n+    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_74() {\n+    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_102() {\n+    if (jj_3R_116()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_115()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_151() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_73() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_72() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_71() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_70() {\n+    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_5() {\n+    if (jj_3R_18()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_69() {\n+    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_68() {\n+    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_128() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_150() {\n+    if (jj_scan_token(82)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_67() {\n+    if (jj_scan_token(FUNCTION_STRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_66() {\n+    if (jj_scan_token(FUNCTION_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_65() {\n+    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n   final private boolean jj_3R_64() {\n-    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n+    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_63() {\n-    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(FUNCTION_ID)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_129() {\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_150()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_151()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_62() {\n-    if (jj_scan_token(FUNCTION_ID)) return true;\n+    if (jj_scan_token(FUNCTION_COUNT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_127() {\n+    if (jj_scan_token(82)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_61() {\n-    if (jj_scan_token(FUNCTION_COUNT)) return true;\n+    if (jj_scan_token(FUNCTION_POSITION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_93() {\n+    if (jj_3R_102()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_60() {\n-    if (jj_scan_token(FUNCTION_POSITION)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_59() {\n     if (jj_scan_token(FUNCTION_LAST)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n-  final private boolean jj_3R_98() {\n-    if (jj_3R_112()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+  final private boolean jj_3R_92() {\n+    if (jj_3R_101()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_91() {\n+    if (jj_scan_token(Number)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_90() {\n+    if (jj_scan_token(Literal)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_89() {\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_100()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_88() {\n+    if (jj_3R_99()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_119() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_127()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_128()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    xsp = jj_scanpos;\n+    if (jj_3R_129()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_18() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_59()) {\n-    jj_scanpos = xsp;\n     if (jj_3R_60()) {\n     jj_scanpos = xsp;\n     if (jj_3R_61()) {\n     jj_scanpos = xsp;\n     if (jj_3R_84()) {\n     jj_scanpos = xsp;\n-    if (jj_3R_85()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_105() {\n-    if (jj_scan_token(DIV)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_104() {\n-    if (jj_scan_token(MOD)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_103() {\n-    if (jj_scan_token(AND)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_102() {\n-    if (jj_scan_token(OR)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_101() {\n-    if (jj_scan_token(NCName)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_92() {\n+    if (jj_3R_85()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_86()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_87()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_19() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_101()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_102()) {\n-    jj_scanpos = xsp;\n+    if (jj_3R_88()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_89()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_90()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_91()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_92()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_93()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_107() {\n+    if (jj_scan_token(DIV)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_106() {\n+    if (jj_scan_token(MOD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_105() {\n+    if (jj_scan_token(AND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_104() {\n+    if (jj_scan_token(OR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_103() {\n+    if (jj_scan_token(NCName)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_99() {\n+    if (jj_scan_token(VARIABLE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_113()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_94() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n     if (jj_3R_103()) {\n     jj_scanpos = xsp;\n     if (jj_3R_104()) {\n     jj_scanpos = xsp;\n-    if (jj_3R_105()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_105()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_106()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_107()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_100() {\n+    if (jj_3R_114()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_52() {\n+    if (jj_scan_token(FUNCTION_ROUND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_51() {\n+    if (jj_scan_token(FUNCTION_CEILING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_116() {\n+    if (jj_3R_124()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_50() {\n+    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_49() {\n+    if (jj_scan_token(FUNCTION_SUM)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_48() {\n+    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_47() {\n+    if (jj_scan_token(FUNCTION_LANG)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_46() {\n+    if (jj_scan_token(FUNCTION_NULL)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_45() {\n+    if (jj_scan_token(FUNCTION_FALSE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_44() {\n+    if (jj_scan_token(FUNCTION_TRUE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_43() {\n+    if (jj_scan_token(FUNCTION_NOT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_42() {\n+    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_41() {\n+    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_40() {\n+    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_39() {\n+    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_38() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_37() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_36() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_35() {\n+    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_34() {\n+    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_33() {\n+    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_32() {\n+    if (jj_scan_token(FUNCTION_STRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_31() {\n+    if (jj_scan_token(FUNCTION_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_149() {\n+    if (jj_scan_token(80)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_30() {\n+    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_29() {\n+    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_126() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_149()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_28() {\n+    if (jj_scan_token(FUNCTION_ID)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_27() {\n+    if (jj_scan_token(FUNCTION_COUNT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_26() {\n+    if (jj_scan_token(FUNCTION_POSITION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_25() {\n+    if (jj_scan_token(FUNCTION_LAST)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_24() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_23() {\n+    if (jj_scan_token(COMMENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_22() {\n+    if (jj_scan_token(TEXT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_21() {\n+    if (jj_scan_token(NODE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_20() {\n+    if (jj_3R_94()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_15() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_20()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_21()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_22()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_23()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_24()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_25()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_26()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_27()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_28()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_29()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_30()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_31()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_32()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_33()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_34()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_35()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_36()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_37()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_38()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_39()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_40()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_41()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_42()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_43()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_44()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_45()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_46()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_47()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_48()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_49()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_50()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_51()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_52()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_112() {\n+    if (jj_scan_token(78)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_100()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(79)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_169() {\n+    if (jj_scan_token(MINUS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_166()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_167() {\n-    if (jj_scan_token(MINUS)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_164()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_165() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_170()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_171()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_172()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_168() {\n+    if (jj_3R_173()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_166() {\n     Token xsp;\n     xsp = jj_scanpos;\n     if (jj_3R_168()) {\n     jj_scanpos = xsp;\n-    if (jj_3R_169()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_170()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_51() {\n-    if (jj_scan_token(FUNCTION_ROUND)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_166() {\n-    if (jj_3R_171()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_50() {\n-    if (jj_scan_token(FUNCTION_CEILING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_49() {\n-    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n+    if (jj_3R_169()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_148() {\n+    if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_147() {\n-    if (jj_scan_token(79)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_48() {\n-    if (jj_scan_token(FUNCTION_SUM)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_47() {\n-    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_124() {\n+    if (jj_scan_token(AXIS_PRECEDING_SIBLING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_146() {\n+    if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_172() {\n+    if (jj_scan_token(MOD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_166()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_145() {\n+    if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_171() {\n+    if (jj_scan_token(DIV)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_166()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_144() {\n+    if (jj_scan_token(AXIS_DESCENDANT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_170() {\n+    if (jj_scan_token(82)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_166()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_143() {\n+    if (jj_scan_token(AXIS_FOLLOWING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_142() {\n+    if (jj_scan_token(AXIS_PRECEDING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_141() {\n+    if (jj_scan_token(AXIS_NAMESPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_140() {\n+    if (jj_scan_token(AXIS_ATTRIBUTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_139() {\n+    if (jj_scan_token(AXIS_ANCESTOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_138() {\n+    if (jj_scan_token(AXIS_PARENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_137() {\n+    if (jj_scan_token(AXIS_CHILD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_136() {\n+    if (jj_scan_token(AXIS_SELF)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_164() {\n+    if (jj_3R_166()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_167()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_125() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_147()) jj_scanpos = xsp;\n-    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_46() {\n-    if (jj_scan_token(FUNCTION_LANG)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_164() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_166()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_167()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_45() {\n-    if (jj_scan_token(FUNCTION_FALSE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_44() {\n-    if (jj_scan_token(FUNCTION_TRUE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_43() {\n-    if (jj_scan_token(FUNCTION_NOT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_42() {\n-    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_41() {\n-    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_40() {\n-    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_170() {\n-    if (jj_scan_token(MOD)) return true;\n+    if (jj_3R_136()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_137()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_138()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_139()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_140()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_141()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_142()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_143()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_144()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_145()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_146()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_147()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_148()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_165() {\n+    if (jj_scan_token(MINUS)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     if (jj_3R_164()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n-  final private boolean jj_3R_39() {\n-    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_169() {\n-    if (jj_scan_token(DIV)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_164()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_38() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_168() {\n-    if (jj_scan_token(81)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_164()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_37() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_36() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_35() {\n-    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_34() {\n-    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_33() {\n-    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_110() {\n-    if (jj_scan_token(77)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_98()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(78)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_32() {\n-    if (jj_scan_token(FUNCTION_STRING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_31() {\n-    if (jj_scan_token(FUNCTION_NAME)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_30() {\n-    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_29() {\n-    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_28() {\n-    if (jj_scan_token(FUNCTION_ID)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_162() {\n+  final private boolean jj_3R_159() {\n+    if (jj_scan_token(PLUS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_158()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_158() {\n     if (jj_3R_164()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     return false;\n   }\n \n-  final private boolean jj_3R_27() {\n-    if (jj_scan_token(FUNCTION_COUNT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_26() {\n-    if (jj_scan_token(FUNCTION_POSITION)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_25() {\n-    if (jj_scan_token(FUNCTION_LAST)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_24() {\n-    if (jj_scan_token(PI)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_23() {\n-    if (jj_scan_token(COMMENT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_22() {\n-    if (jj_scan_token(TEXT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_21() {\n-    if (jj_scan_token(NODE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_163() {\n-    if (jj_scan_token(MINUS)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_162()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_20() {\n-    if (jj_3R_92()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_146() {\n-    if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_145() {\n-    if (jj_scan_token(AXIS_PRECEDING_SIBLING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_144() {\n-    if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_15() {\n+  final private boolean jj_3R_118() {\n+    if (jj_3R_126()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_117() {\n+    if (jj_3R_125()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_108() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_20()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_21()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_22()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_23()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_24()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_25()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_26()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_27()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_28()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_29()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_30()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_31()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_32()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_33()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_34()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_35()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_36()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_37()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_38()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_39()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_40()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_41()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_42()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_43()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_44()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_45()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_46()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_47()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_48()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_49()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_50()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_51()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_143() {\n-    if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_157() {\n-    if (jj_scan_token(PLUS)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_156()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_142() {\n-    if (jj_scan_token(AXIS_DESCENDANT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_141() {\n-    if (jj_scan_token(AXIS_FOLLOWING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_140() {\n-    if (jj_scan_token(AXIS_PRECEDING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_139() {\n-    if (jj_scan_token(AXIS_NAMESPACE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_156() {\n-    if (jj_3R_162()) return true;\n+    if (jj_3R_117()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_118()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_155() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_160()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_161()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_162()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_163()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_154() {\n+    if (jj_3R_158()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     while (true) {\n       xsp = jj_scanpos;\n-      if (jj_3R_163()) { jj_scanpos = xsp; break; }\n+      if (jj_3R_159()) { jj_scanpos = xsp; break; }\n       if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     }\n     return false;\n   }\n \n-  final private boolean jj_3R_138() {\n-    if (jj_scan_token(AXIS_ATTRIBUTE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_137() {\n-    if (jj_scan_token(AXIS_ANCESTOR)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_136() {\n-    if (jj_scan_token(AXIS_PARENT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_135() {\n-    if (jj_scan_token(AXIS_CHILD)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_134() {\n-    if (jj_scan_token(AXIS_SELF)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_123() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_134()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_135()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_136()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_137()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_138()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_139()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_140()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_141()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_142()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_143()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_144()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_145()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_146()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+  final private boolean jj_3R_98() {\n+    if (jj_3R_112()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_4() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_3() {\n+    if (jj_3R_17()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_163() {\n+    if (jj_scan_token(GTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_154()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_97() {\n+    if (jj_scan_token(77)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_162() {\n+    if (jj_scan_token(LTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_154()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_161() {\n+    if (jj_scan_token(GT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_154()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_153() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_158()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_159()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_160()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_161()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_156()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_157()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_96() {\n+    if (jj_scan_token(76)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_160() {\n+    if (jj_scan_token(LT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_154()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_111() {\n+    if (jj_3R_119()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_110() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(Literal)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_109() {\n+    if (jj_3R_17()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_152() {\n-    if (jj_3R_156()) return true;\n+    if (jj_3R_154()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     while (true) {\n       xsp = jj_scanpos;\n-      if (jj_3R_157()) { jj_scanpos = xsp; break; }\n+      if (jj_3R_155()) { jj_scanpos = xsp; break; }\n       if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     }\n     return false;\n   }\n \n-  final private boolean jj_3R_116() {\n-    if (jj_3R_124()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_115() {\n-    if (jj_3R_123()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_161() {\n-    if (jj_scan_token(GTE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_152()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_106() {\n+  final private boolean jj_3R_95() {\n+    if (jj_3R_108()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_115()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_116()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_160() {\n-    if (jj_scan_token(LTE)) return true;\n+    if (jj_3R_109()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_110()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_111()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_157() {\n+    if (jj_scan_token(NEQ)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     if (jj_3R_152()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n-  final private boolean jj_3R_159() {\n-    if (jj_scan_token(GT)) return true;\n+  final private boolean jj_3R_156() {\n+    if (jj_scan_token(EQ)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     if (jj_3R_152()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n-  final private boolean jj_3R_151() {\n+  final private boolean jj_3R_55() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_154()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_155()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_158() {\n-    if (jj_scan_token(LT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_152()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_150() {\n+    if (jj_3R_95()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_96()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_97()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_98()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_130() {\n     if (jj_3R_152()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     return false;\n   }\n \n-  final private boolean jj_3R_155() {\n-    if (jj_scan_token(NEQ)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_150()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_154() {\n-    if (jj_scan_token(EQ)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_150()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_96() {\n-    if (jj_3R_110()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3_4() {\n-    if (jj_scan_token(PI)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3_3() {\n-    if (jj_3R_17()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(74)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_95() {\n-    if (jj_scan_token(76)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_94() {\n-    if (jj_scan_token(75)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_109() {\n-    if (jj_3R_117()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_108() {\n-    if (jj_scan_token(PI)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(Literal)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(74)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_128() {\n-    if (jj_3R_150()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_151()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_107() {\n-    if (jj_3R_17()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(74)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_93() {\n-    if (jj_3R_106()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_107()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_108()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_109()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_129() {\n+  final private boolean jj_3R_189() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_54() {\n+    if (jj_scan_token(SLASHSLASH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_131() {\n     if (jj_scan_token(AND)) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_128()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_54() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_93()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_94()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_95()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_96()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_187() {\n-    if (jj_3R_16()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_119() {\n-    if (jj_3R_128()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_129()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n+    if (jj_3R_130()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n   final private boolean jj_3R_53() {\n-    if (jj_scan_token(SLASHSLASH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_52() {\n     if (jj_scan_token(SLASH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_184() {\n-    if (jj_3R_16()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n   final private boolean jj_3R_16() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_52()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_53()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_53()) {\n+    jj_scanpos = xsp;\n     if (jj_3R_54()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_120() {\n-    if (jj_scan_token(OR)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_119()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_112() {\n-    if (jj_3R_119()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_120()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_182() {\n-    if (jj_3R_54()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_184()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3_2() {\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_55()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_186() {\n     if (jj_3R_16()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_179() {\n-    if (jj_3R_16()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_186() {\n-    if (jj_scan_token(SLASH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_185() {\n-    if (jj_3R_16()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_187()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_178() {\n-    if (jj_3R_110()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_183() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_185()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_186()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_176() {\n-    if (jj_3R_19()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_178()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_179()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_181() {\n-    if (jj_3R_183()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_180() {\n-    if (jj_3R_182()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3_6() {\n-    if (jj_3R_19()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_177() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_180()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_181()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_175() {\n-    if (jj_3R_177()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_174() {\n-    if (jj_3R_176()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_172() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_174()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_175()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_173() {\n-    if (jj_scan_token(UNION)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_172()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_171() {\n-    if (jj_3R_172()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    while (true) {\n-      xsp = jj_scanpos;\n-      if (jj_3R_173()) { jj_scanpos = xsp; break; }\n-      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    }\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_130() {\n-    if (jj_3R_98()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_131() {\n-    if (jj_scan_token(80)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_130()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n     return false;\n   }\n \n-  final private boolean jj_3R_113() {\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+  final private boolean jj_3R_122() {\n+    if (jj_scan_token(OR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_121()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_184() {\n+    if (jj_3R_55()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_186()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3_2() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_114() {\n+    if (jj_3R_121()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_122()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_188() {\n+    if (jj_scan_token(SLASH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_187() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_189()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_185() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_121()) jj_scanpos = xsp;\n-    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(74)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_58() {\n-    if (jj_scan_token(PI)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_57() {\n-    if (jj_scan_token(COMMENT)) return true;\n+    if (jj_3R_187()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_188()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_183() {\n+    if (jj_3R_185()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_182() {\n+    if (jj_3R_184()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_181() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_179() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_182()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_183()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_180() {\n+    if (jj_3R_112()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_178() {\n+    if (jj_3R_19()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_180()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_181()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3_6() {\n+    if (jj_3R_19()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_177() {\n+    if (jj_3R_179()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_176() {\n+    if (jj_3R_178()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_174() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_176()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_177()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_175() {\n+    if (jj_scan_token(UNION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_174()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_173() {\n+    if (jj_3R_174()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_175()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_132() {\n+    if (jj_3R_100()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n   final private boolean jj_3_1() {\n     if (jj_3R_15()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(72)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_56() {\n-    if (jj_scan_token(NODE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_55() {\n-    if (jj_scan_token(TEXT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_17() {\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_133() {\n+    if (jj_scan_token(81)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_132()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_135() {\n+    if (jj_3R_94()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_123() {\n+    if (jj_3R_132()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_133()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_134() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_120() {\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_115() {\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_55()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_56()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_57()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_58()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_133() {\n-    if (jj_3R_92()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_132() {\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(72)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_149() {\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_126() {\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_148() {\n-    if (jj_scan_token(81)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_118() {\n-    if (jj_scan_token(72)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_99() {\n-    if (jj_3R_18()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_113()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_122() {\n+    if (jj_3R_123()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_124() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_132()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_133()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_127() {\n-    if (jj_scan_token(72)) return true;\n+    if (jj_3R_134()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_135()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_113() {\n+    if (jj_3R_15()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_148()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_149()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_125() {\n-    if (jj_scan_token(81)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_117() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_125()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_126()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    xsp = jj_scanpos;\n-    if (jj_3R_127()) jj_scanpos = xsp;\n+    if (jj_3R_120()) jj_scanpos = xsp;\n     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n \n-  final private boolean jj_3R_111() {\n-    if (jj_3R_15()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_118()) jj_scanpos = xsp;\n-    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_100() {\n-    if (jj_3R_114()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_113()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3_5() {\n+  final private boolean jj_3R_101() {\n     if (jj_3R_18()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_85() {\n-    if (jj_scan_token(FUNCTION_ROUND)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_97() {\n-    if (jj_scan_token(VARIABLE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_111()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_84() {\n-    if (jj_scan_token(FUNCTION_CEILING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_83() {\n-    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_82() {\n-    if (jj_scan_token(FUNCTION_SUM)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_81() {\n-    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_80() {\n-    if (jj_scan_token(FUNCTION_LANG)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_79() {\n-    if (jj_scan_token(FUNCTION_FALSE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_91() {\n-    if (jj_3R_100()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_78() {\n-    if (jj_scan_token(FUNCTION_TRUE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_90() {\n-    if (jj_3R_99()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_77() {\n-    if (jj_scan_token(FUNCTION_NOT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_89() {\n-    if (jj_scan_token(Number)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_76() {\n-    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_88() {\n-    if (jj_scan_token(Literal)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_75() {\n-    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_87() {\n-    if (jj_scan_token(73)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_3R_98()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    if (jj_scan_token(74)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_74() {\n-    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_86() {\n-    if (jj_3R_97()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_73() {\n-    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_72() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_114() {\n-    if (jj_3R_122()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_71() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_70() {\n-    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_69() {\n-    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_68() {\n-    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_19() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_86()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_87()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_88()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_89()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_90()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_91()) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_67() {\n-    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_66() {\n-    if (jj_scan_token(FUNCTION_STRING)) return true;\n-    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n-    return false;\n-  }\n-\n-  final private boolean jj_3R_65() {\n-    if (jj_scan_token(FUNCTION_NAME)) return true;\n+    if (jj_3R_115()) return true;\n     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n     return false;\n   }\n   final private int[] jj_la1 = new int[39];\n   final private int[] jj_la1_0 = {0x7f800000,0x7800000,0x0,0x0,0x7800000,0xff80000c,0xc,0x4,0xc,0xc,0x7f800000,0xff800000,0x0,0x80000000,0x80000000,0x0,0x16000,0x7f800000,0x0,0xff81604c,0x10,0xff80000c,0x0,0xc,0x800000,0x1000000,0x180,0x180,0x1e00,0x1e00,0x20,0x40,0x6000000,0x6000000,0xff81604c,0x7f800000,0x7f800000,0x0,0x78000000,};\n   final private int[] jj_la1_1 = {0xfffff000,0x0,0xfffff000,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xfffff000,0xffffffff,0x0,0xfff,0xfff,0x0,0x0,0xfffff000,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xfffff000,0xfffff000,0x0,0x0,};\n-  final private int[] jj_la1_2 = {0xff,0x80,0x7f,0x100,0x80,0x298ff,0x0,0x0,0x0,0x0,0x200ff,0x298ff,0x2000,0x0,0x0,0x8000,0x200,0xff,0x10000,0x29aff,0x0,0x298ff,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x29aff,0x200ff,0x200ff,0x100,0x0,};\n+  final private int[] jj_la1_2 = {0x1ff,0x100,0xff,0x200,0x100,0x531ff,0x0,0x0,0x0,0x0,0x401ff,0x531ff,0x4000,0x0,0x0,0x10000,0x400,0x1ff,0x20000,0x535ff,0x0,0x531ff,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x535ff,0x401ff,0x401ff,0x200,0x0,};\n   final private JJCalls[] jj_2_rtns = new JJCalls[6];\n   private boolean jj_rescan = false;\n   private int jj_gc = 0;\n \n   final public ParseException generateParseException() {\n     jj_expentries.removeAllElements();\n-    boolean[] la1tokens = new boolean[82];\n-    for (int i = 0; i < 82; i++) {\n+    boolean[] la1tokens = new boolean[83];\n+    for (int i = 0; i < 83; i++) {\n       la1tokens[i] = false;\n     }\n     if (jj_kind >= 0) {\n         }\n       }\n     }\n-    for (int i = 0; i < 82; i++) {\n+    for (int i = 0; i < 83; i++) {\n       if (la1tokens[i]) {\n         jj_expentry = new int[1];\n         jj_expentry[0] = i;\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParserConstants.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserConstants.java\n   int FUNCTION_NOT = 62;\n   int FUNCTION_TRUE = 63;\n   int FUNCTION_FALSE = 64;\n-  int FUNCTION_LANG = 65;\n-  int FUNCTION_NUMBER = 66;\n-  int FUNCTION_SUM = 67;\n-  int FUNCTION_FLOOR = 68;\n-  int FUNCTION_CEILING = 69;\n-  int FUNCTION_ROUND = 70;\n-  int NCName = 71;\n+  int FUNCTION_NULL = 65;\n+  int FUNCTION_LANG = 66;\n+  int FUNCTION_NUMBER = 67;\n+  int FUNCTION_SUM = 68;\n+  int FUNCTION_FLOOR = 69;\n+  int FUNCTION_CEILING = 70;\n+  int FUNCTION_ROUND = 71;\n+  int NCName = 72;\n \n   int DEFAULT = 0;\n \n     \"\\\"not\\\"\",\n     \"\\\"true\\\"\",\n     \"\\\"false\\\"\",\n+    \"\\\"null\\\"\",\n     \"\\\"lang\\\"\",\n     \"\\\"number\\\"\",\n     \"\\\"sum\\\"\",\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n    switch (pos)\n    {\n       case 0:\n-         if ((active1 & 0x1800L) != 0L)\n+         if ((active1 & 0x3000L) != 0L)\n             return 11;\n-         if ((active0 & 0xffffffffff800000L) != 0L || (active1 & 0x7fL) != 0L)\n-         {\n-            jjmatchedKind = 71;\n+         if ((active0 & 0xffffffffff800000L) != 0L || (active1 & 0xffL) != 0L)\n+         {\n+            jjmatchedKind = 72;\n             return 13;\n          }\n          return -1;\n       case 1:\n          if ((active0 & 0x800000800000L) != 0L)\n             return 13;\n-         if ((active0 & 0xffff7fffff000000L) != 0L || (active1 & 0x7fL) != 0L)\n-         {\n-            jjmatchedKind = 71;\n+         if ((active0 & 0xffff7fffff000000L) != 0L || (active1 & 0xffL) != 0L)\n+         {\n+            jjmatchedKind = 72;\n             jjmatchedPos = 1;\n             return 13;\n          }\n          return -1;\n       case 2:\n-         if ((active0 & 0xbfff7ffff8000000L) != 0L || (active1 & 0x77L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n+         if ((active0 & 0xbfff7ffff8000000L) != 0L || (active1 & 0xefL) != 0L)\n+         {\n+            jjmatchedKind = 72;\n             jjmatchedPos = 2;\n             return 13;\n          }\n-         if ((active0 & 0x4000000007000000L) != 0L || (active1 & 0x8L) != 0L)\n+         if ((active0 & 0x4000000007000000L) != 0L || (active1 & 0x10L) != 0L)\n             return 13;\n          return -1;\n       case 3:\n-         if ((active0 & 0x3ff96fefe0000000L) != 0L || (active1 & 0x75L) != 0L)\n+         if ((active0 & 0x8006101018000000L) != 0L || (active1 & 0x6L) != 0L)\n+            return 13;\n+         if ((active0 & 0x3ff96fefe0000000L) != 0L || (active1 & 0xe9L) != 0L)\n          {\n             if (jjmatchedPos != 3)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 3;\n             }\n             return 13;\n          }\n-         if ((active0 & 0x8006101018000000L) != 0L || (active1 & 0x2L) != 0L)\n-            return 13;\n          return -1;\n       case 4:\n+         if ((active0 & 0x400000000000L) != 0L || (active1 & 0xa1L) != 0L)\n+            return 13;\n+         if ((active0 & 0x3ffb2fff60000000L) != 0L || (active1 & 0x48L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 4;\n+            return 13;\n+         }\n          if ((active0 & 0x80000000L) != 0L)\n          {\n             if (jjmatchedPos < 3)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 3;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x400000000000L) != 0L || (active1 & 0x51L) != 0L)\n-            return 13;\n-         if ((active0 & 0x3ffb2fff60000000L) != 0L || (active1 & 0x24L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 4;\n-            return 13;\n-         }\n          return -1;\n       case 5:\n-         if ((active0 & 0x3be32ffe60000000L) != 0L || (active1 & 0x20L) != 0L)\n+         if ((active0 & 0x100000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 4)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 4;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x418000000000000L) != 0L || (active1 & 0x8L) != 0L)\n+            return 13;\n+         if ((active0 & 0x80000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 3)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 3;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x3be32ffe60000000L) != 0L || (active1 & 0x40L) != 0L)\n          {\n             if (jjmatchedPos != 5)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 5;\n             }\n             return 13;\n          }\n+         return -1;\n+      case 6:\n          if ((active0 & 0x100000000L) != 0L)\n          {\n             if (jjmatchedPos < 4)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 4;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x80000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 3)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 3;\n+         if ((active0 & 0x2000000020000000L) != 0L || (active1 & 0x40L) != 0L)\n+            return 13;\n+         if ((active0 & 0x200000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 5)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 5;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x418000000000000L) != 0L || (active1 & 0x4L) != 0L)\n-            return 13;\n-         return -1;\n-      case 6:\n+         if ((active0 & 0x1fe32ffc40000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 6;\n+            return 13;\n+         }\n+         return -1;\n+      case 7:\n+         if ((active0 & 0x40200000000000L) != 0L)\n+            return 13;\n          if ((active0 & 0x200000000L) != 0L)\n          {\n             if (jjmatchedPos < 5)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 5;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x100000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 4)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 4;\n+         if ((active0 & 0x1fa30ffc40000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 7;\n+            return 13;\n+         }\n+         return -1;\n+      case 8:\n+         if ((active0 & 0x1380000000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0x400000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 7)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 7;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x1fe32ffc40000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 6;\n-            return 13;\n-         }\n-         if ((active0 & 0x2000000020000000L) != 0L || (active1 & 0x20L) != 0L)\n-            return 13;\n-         return -1;\n-      case 7:\n-         if ((active0 & 0x200000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 5)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 5;\n-            }\n-            return -1;\n-         }\n-         if ((active0 & 0x40200000000000L) != 0L)\n-            return 13;\n-         if ((active0 & 0x1fa30ffc40000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 7;\n-            return 13;\n-         }\n-         return -1;\n-      case 8:\n          if ((active0 & 0xc230ff840000000L) != 0L)\n          {\n             if (jjmatchedPos != 8)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 8;\n             }\n             return 13;\n          }\n-         if ((active0 & 0x400000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 7)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 7;\n-            }\n-            return -1;\n-         }\n-         if ((active0 & 0x1380000000000000L) != 0L)\n-            return 13;\n          return -1;\n       case 9:\n          if ((active0 & 0x7800000000L) != 0L)\n          {\n             if (jjmatchedPos < 8)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 8;\n             }\n             return -1;\n          }\n+         if ((active0 & 0x1000000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0xda20f8040000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 9;\n+            return 13;\n+         }\n          if ((active0 & 0x400000000L) != 0L)\n          {\n             if (jjmatchedPos < 7)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 7;\n             }\n             return -1;\n          }\n-         if ((active0 & 0xda20f8040000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 9;\n-            return 13;\n-         }\n-         if ((active0 & 0x1000000000000L) != 0L)\n-            return 13;\n          return -1;\n       case 10:\n+         if ((active0 & 0x7800000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 8)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 8;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x20000000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0xd820f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 10;\n+            return 13;\n+         }\n          if ((active0 & 0x8000000000L) != 0L)\n          {\n             if (jjmatchedPos < 9)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 9;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x7800000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 8)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 8;\n+         return -1;\n+      case 11:\n+         if ((active0 & 0xd820f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 11;\n+            return 13;\n+         }\n+         if ((active0 & 0x8000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 9)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 9;\n             }\n             return -1;\n          }\n-         if ((active0 & 0xd820f0040000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 10;\n-            return 13;\n-         }\n-         if ((active0 & 0x20000000000000L) != 0L)\n-            return 13;\n-         return -1;\n-      case 11:\n-         if ((active0 & 0x8000000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 9)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 9;\n-            }\n-            return -1;\n-         }\n-         if ((active0 & 0xd820f0040000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 11;\n-            return 13;\n-         }\n          return -1;\n       case 12:\n+         if ((active0 & 0x402000000000000L) != 0L)\n+            return 13;\n          if ((active0 & 0x9800f0040000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 12;\n             return 13;\n          }\n-         if ((active0 & 0x402000000000000L) != 0L)\n-            return 13;\n          return -1;\n       case 13:\n          if ((active0 & 0x9800f0040000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 13;\n             return 13;\n          }\n             return 13;\n          if ((active0 & 0x800f0040000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 14;\n             return 13;\n          }\n             return 13;\n          if ((active0 & 0xf0040000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 15;\n             return 13;\n          }\n          {\n             if (jjmatchedPos < 15)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 15;\n             }\n             return -1;\n          }\n          if ((active0 & 0xe0040000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 16;\n             return 13;\n          }\n          return -1;\n       case 17:\n+         if ((active0 & 0x10000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 15)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 15;\n+            }\n+            return -1;\n+         }\n          if ((active0 & 0x60000000000L) != 0L)\n          {\n             if (jjmatchedPos < 16)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 16;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x10000000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 15)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 15;\n+         if ((active0 & 0x80040000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 17;\n+            return 13;\n+         }\n+         return -1;\n+      case 18:\n+         if ((active0 & 0x60000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 16)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 16;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x80040000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 17;\n-            return 13;\n-         }\n-         return -1;\n-      case 18:\n+         if ((active0 & 0x40000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 18;\n+            return 13;\n+         }\n          if ((active0 & 0x80000000000L) != 0L)\n          {\n             if (jjmatchedPos < 17)\n             {\n-               jjmatchedKind = 71;\n+               jjmatchedKind = 72;\n                jjmatchedPos = 17;\n             }\n             return -1;\n          }\n-         if ((active0 & 0x60000000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 16)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 16;\n+         return -1;\n+      case 19:\n+         if ((active0 & 0x40000000L) != 0L)\n+         {\n+            jjmatchedKind = 72;\n+            jjmatchedPos = 19;\n+            return 13;\n+         }\n+         if ((active0 & 0x80000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 17)\n+            {\n+               jjmatchedKind = 72;\n+               jjmatchedPos = 17;\n             }\n             return -1;\n-         }\n-         if ((active0 & 0x40000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 18;\n-            return 13;\n-         }\n-         return -1;\n-      case 19:\n-         if ((active0 & 0x80000000000L) != 0L)\n-         {\n-            if (jjmatchedPos < 17)\n-            {\n-               jjmatchedKind = 71;\n-               jjmatchedPos = 17;\n-            }\n-            return -1;\n-         }\n-         if ((active0 & 0x40000000L) != 0L)\n-         {\n-            jjmatchedKind = 71;\n-            jjmatchedPos = 19;\n-            return 13;\n          }\n          return -1;\n       case 20:\n          if ((active0 & 0x40000000L) != 0L)\n          {\n-            jjmatchedKind = 71;\n+            jjmatchedKind = 72;\n             jjmatchedPos = 20;\n             return 13;\n          }\n       case 36:\n          return jjStopAtPos(0, 13);\n       case 40:\n-         return jjStopAtPos(0, 73);\n+         return jjStopAtPos(0, 74);\n       case 41:\n-         return jjStopAtPos(0, 74);\n+         return jjStopAtPos(0, 75);\n       case 42:\n-         return jjStopAtPos(0, 81);\n+         return jjStopAtPos(0, 82);\n       case 43:\n          return jjStopAtPos(0, 5);\n       case 44:\n-         return jjStopAtPos(0, 80);\n+         return jjStopAtPos(0, 81);\n       case 45:\n          return jjStopAtPos(0, 6);\n       case 46:\n-         jjmatchedKind = 75;\n-         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L);\n+         jjmatchedKind = 76;\n+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L);\n       case 47:\n          jjmatchedKind = 2;\n          return jjMoveStringLiteralDfa1_0(0x8L, 0x0L);\n       case 58:\n-         return jjStopAtPos(0, 72);\n+         return jjStopAtPos(0, 73);\n       case 60:\n          jjmatchedKind = 9;\n          return jjMoveStringLiteralDfa1_0(0x400L, 0x0L);\n          jjmatchedKind = 11;\n          return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L);\n       case 64:\n+         return jjStopAtPos(0, 80);\n+      case 91:\n+         return jjStopAtPos(0, 78);\n+      case 93:\n          return jjStopAtPos(0, 79);\n-      case 91:\n-         return jjStopAtPos(0, 77);\n-      case 93:\n-         return jjStopAtPos(0, 78);\n       case 97:\n          return jjMoveStringLiteralDfa1_0(0x10c01000000L, 0x0L);\n       case 98:\n          return jjMoveStringLiteralDfa1_0(0x2000000000000000L, 0x0L);\n       case 99:\n-         return jjMoveStringLiteralDfa1_0(0x50400120000000L, 0x20L);\n+         return jjMoveStringLiteralDfa1_0(0x50400120000000L, 0x40L);\n       case 100:\n          return jjMoveStringLiteralDfa1_0(0x88004000000L, 0x0L);\n       case 102:\n-         return jjMoveStringLiteralDfa1_0(0x24000000000L, 0x11L);\n+         return jjMoveStringLiteralDfa1_0(0x24000000000L, 0x21L);\n       case 105:\n          return jjMoveStringLiteralDfa1_0(0x800000000000L, 0x0L);\n       case 108:\n-         return jjMoveStringLiteralDfa1_0(0x1100000000000L, 0x2L);\n+         return jjMoveStringLiteralDfa1_0(0x1100000000000L, 0x4L);\n       case 109:\n          return jjMoveStringLiteralDfa1_0(0x2000000L, 0x0L);\n       case 110:\n-         return jjMoveStringLiteralDfa1_0(0x4806001008000000L, 0x4L);\n+         return jjMoveStringLiteralDfa1_0(0x4806001008000000L, 0xaL);\n       case 111:\n          return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);\n       case 112:\n          return jjMoveStringLiteralDfa1_0(0x242240000000L, 0x0L);\n       case 114:\n-         return jjMoveStringLiteralDfa1_0(0x0L, 0x40L);\n+         return jjMoveStringLiteralDfa1_0(0x0L, 0x80L);\n       case 115:\n-         return jjMoveStringLiteralDfa1_0(0x7a8000080000000L, 0x8L);\n+         return jjMoveStringLiteralDfa1_0(0x7a8000080000000L, 0x10L);\n       case 116:\n          return jjMoveStringLiteralDfa1_0(0x9000000010000000L, 0x0L);\n       case 124:\n    switch(curChar)\n    {\n       case 46:\n-         if ((active1 & 0x1000L) != 0L)\n-            return jjStopAtPos(1, 76);\n+         if ((active1 & 0x2000L) != 0L)\n+            return jjStopAtPos(1, 77);\n          break;\n       case 47:\n          if ((active0 & 0x8L) != 0L)\n             return jjStopAtPos(1, 12);\n          break;\n       case 97:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x6101200000000L, active1, 0x3L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x6101200000000L, active1, 0x5L);\n       case 100:\n          if ((active0 & 0x800000000000L) != 0L)\n             return jjStartNfaWithStates_0(1, 47, 13);\n          break;\n       case 101:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x88090000000L, active1, 0x20L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x88090000000L, active1, 0x40L);\n       case 104:\n          return jjMoveStringLiteralDfa2_0(active0, 0x100000000L, active1, 0L);\n       case 105:\n          return jjMoveStringLiteralDfa2_0(active0, 0x4000000L, active1, 0L);\n       case 108:\n-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x20L);\n       case 110:\n          return jjMoveStringLiteralDfa2_0(active0, 0x10401000000L, active1, 0L);\n       case 111:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x685162402a000000L, active1, 0x40L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x685162402a000000L, active1, 0x80L);\n       case 114:\n          if ((active0 & 0x800000L) != 0L)\n             return jjStartNfaWithStates_0(1, 23, 13);\n       case 116:\n          return jjMoveStringLiteralDfa2_0(active0, 0x428000800000000L, active1, 0L);\n       case 117:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x380000000000000L, active1, 0xcL);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x380000000000000L, active1, 0x1aL);\n       default :\n          break;\n    }\n       case 101:\n          return jjMoveStringLiteralDfa3_0(active0, 0x42000000000L, active1, 0L);\n       case 105:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0x20L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0x40L);\n       case 108:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x24080000000L, active1, 0x1L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x24080000000L, active1, 0x3L);\n       case 109:\n-         if ((active1 & 0x8L) != 0L)\n-            return jjStartNfaWithStates_0(2, 67, 13);\n-         return jjMoveStringLiteralDfa3_0(active0, 0x6001020000000L, active1, 0x4L);\n+         if ((active1 & 0x10L) != 0L)\n+            return jjStartNfaWithStates_0(2, 68, 13);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x6001020000000L, active1, 0x8L);\n       case 110:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x50000000000000L, active1, 0x2L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x50000000000000L, active1, 0x4L);\n       case 111:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x2000000040000000L, active1, 0x10L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x2000000040000000L, active1, 0x20L);\n       case 114:\n          return jjMoveStringLiteralDfa3_0(active0, 0xc08000200000000L, active1, 0L);\n       case 115:\n             return jjStartNfaWithStates_0(2, 62, 13);\n          return jjMoveStringLiteralDfa3_0(active0, 0x800000000L, active1, 0L);\n       case 117:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x8000400000000000L, active1, 0x40L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x8000400000000000L, active1, 0x80L);\n       case 118:\n          if ((active0 & 0x4000000L) != 0L)\n             return jjStartNfaWithStates_0(2, 26, 13);\n       case 97:\n          return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000L, active1, 0L);\n       case 98:\n-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4L);\n+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x8L);\n       case 99:\n          return jjMoveStringLiteralDfa4_0(active0, 0x100ca040000000L, active1, 0L);\n       case 101:\n       case 102:\n          return jjMoveStringLiteralDfa4_0(active0, 0x80000000L, active1, 0L);\n       case 103:\n-         if ((active1 & 0x2L) != 0L)\n-            return jjStartNfaWithStates_0(3, 65, 13);\n+         if ((active1 & 0x4L) != 0L)\n+            return jjStartNfaWithStates_0(3, 66, 13);\n          break;\n       case 105:\n          return jjMoveStringLiteralDfa4_0(active0, 0x408200000000000L, active1, 0L);\n       case 108:\n-         return jjMoveStringLiteralDfa4_0(active0, 0x2000024100000000L, active1, 0x20L);\n+         if ((active1 & 0x2L) != 0L)\n+            return jjStartNfaWithStates_0(3, 65, 13);\n+         return jjMoveStringLiteralDfa4_0(active0, 0x2000024100000000L, active1, 0x40L);\n       case 109:\n          return jjMoveStringLiteralDfa4_0(active0, 0x800000020000000L, active1, 0L);\n       case 110:\n-         return jjMoveStringLiteralDfa4_0(active0, 0x1000400000000000L, active1, 0x40L);\n+         return jjMoveStringLiteralDfa4_0(active0, 0x1000400000000000L, active1, 0x80L);\n       case 111:\n-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x10L);\n+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x20L);\n       case 114:\n          return jjMoveStringLiteralDfa4_0(active0, 0x20000800000000L, active1, 0L);\n       case 115:\n       case 97:\n          return jjMoveStringLiteralDfa5_0(active0, 0x850000000000000L, active1, 0L);\n       case 100:\n-         if ((active1 & 0x40L) != 0L)\n-            return jjStartNfaWithStates_0(4, 70, 13);\n+         if ((active1 & 0x80L) != 0L)\n+            return jjStartNfaWithStates_0(4, 71, 13);\n          return jjMoveStringLiteralDfa5_0(active0, 0x100000000L, active1, 0L);\n       case 101:\n          if ((active1 & 0x1L) != 0L)\n             return jjStartNfaWithStates_0(4, 64, 13);\n-         return jjMoveStringLiteralDfa5_0(active0, 0x20000ca060000000L, active1, 0x4L);\n+         return jjMoveStringLiteralDfa5_0(active0, 0x20000ca060000000L, active1, 0x8L);\n       case 105:\n-         return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0x20L);\n+         return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0x40L);\n       case 108:\n          return jjMoveStringLiteralDfa5_0(active0, 0x1000000000000L, active1, 0L);\n       case 110:\n       case 111:\n          return jjMoveStringLiteralDfa5_0(active0, 0x24000000000L, active1, 0L);\n       case 114:\n-         if ((active1 & 0x10L) != 0L)\n-            return jjStartNfaWithStates_0(4, 68, 13);\n+         if ((active1 & 0x20L) != 0L)\n+            return jjStartNfaWithStates_0(4, 69, 13);\n          break;\n       case 115:\n          return jjMoveStringLiteralDfa5_0(active0, 0x1002011400000000L, active1, 0L);\n       case 108:\n          return jjMoveStringLiteralDfa6_0(active0, 0x1800000000000000L, active1, 0L);\n       case 110:\n-         return jjMoveStringLiteralDfa6_0(active0, 0x88020000000L, active1, 0x20L);\n+         return jjMoveStringLiteralDfa6_0(active0, 0x88020000000L, active1, 0x40L);\n       case 112:\n          return jjMoveStringLiteralDfa6_0(active0, 0x2001000000000L, active1, 0L);\n       case 114:\n-         if ((active1 & 0x4L) != 0L)\n-            return jjStartNfaWithStates_0(5, 66, 13);\n+         if ((active1 & 0x8L) != 0L)\n+            return jjStartNfaWithStates_0(5, 67, 13);\n          return jjMoveStringLiteralDfa6_0(active0, 0x380000000000000L, active1, 0L);\n       case 115:\n          return jjMoveStringLiteralDfa6_0(active0, 0x20000040000000L, active1, 0L);\n       case 100:\n          return jjMoveStringLiteralDfa7_0(active0, 0x88000000000L, active1, 0L);\n       case 103:\n-         if ((active1 & 0x20L) != 0L)\n-            return jjStartNfaWithStates_0(6, 69, 13);\n+         if ((active1 & 0x40L) != 0L)\n+            return jjStartNfaWithStates_0(6, 70, 13);\n          break;\n       case 105:\n          return jjMoveStringLiteralDfa7_0(active0, 0xb80066000000000L, active1, 0L);\n                case 13:\n                   if ((0x3ff600000000000L & l) == 0L)\n                      break;\n-                  if (kind > 71)\n-                     kind = 71;\n+                  if (kind > 72)\n+                     kind = 72;\n                   jjstateSet[jjnewStateCnt++] = 13;\n                   break;\n                default : break;\n                case 13:\n                   if ((0x7fffffe87fffffeL & l) == 0L)\n                      break;\n-                  if (kind > 71)\n-                     kind = 71;\n+                  if (kind > 72)\n+                     kind = 72;\n                   jjCheckNAdd(13);\n                   break;\n                case 2:\n                case 1:\n                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                      break;\n-                  if (kind > 71)\n-                     kind = 71;\n+                  if (kind > 72)\n+                     kind = 72;\n                   jjCheckNAdd(13);\n                   break;\n                case 2:\n                case 13:\n                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2))\n                      break;\n-                  if (kind > 71)\n-                     kind = 71;\n+                  if (kind > 72)\n+                     kind = 72;\n                   jjCheckNAdd(13);\n                   break;\n                default : break;\n \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\142\\145\\146\\157\\162\\145\", \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\141\\146\\164\\145\\162\", \n \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\", \"\\163\\164\\162\\151\\156\\147\\55\\154\\145\\156\\147\\164\\150\", \n \"\\156\\157\\162\\155\\141\\154\\151\\172\\145\\55\\163\\160\\141\\143\\145\", \"\\164\\162\\141\\156\\163\\154\\141\\164\\145\", \"\\142\\157\\157\\154\\145\\141\\156\", \n-\"\\156\\157\\164\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\154\\141\\156\\147\", \n-\"\\156\\165\\155\\142\\145\\162\", \"\\163\\165\\155\", \"\\146\\154\\157\\157\\162\", \"\\143\\145\\151\\154\\151\\156\\147\", \n-\"\\162\\157\\165\\156\\144\", null, \"\\72\", \"\\50\", \"\\51\", \"\\56\", \"\\56\\56\", \"\\133\", \"\\135\", \"\\100\", \"\\54\", \n-\"\\52\", };\n+\"\\156\\157\\164\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\156\\165\\154\\154\", \n+\"\\154\\141\\156\\147\", \"\\156\\165\\155\\142\\145\\162\", \"\\163\\165\\155\", \"\\146\\154\\157\\157\\162\", \n+\"\\143\\145\\151\\154\\151\\156\\147\", \"\\162\\157\\165\\156\\144\", null, \"\\72\", \"\\50\", \"\\51\", \"\\56\", \"\\56\\56\", \"\\133\", \n+\"\\135\", \"\\100\", \"\\54\", \"\\52\", };\n public static final String[] lexStateNames = {\n    \"DEFAULT\", \n };\n static final long[] jjtoToken = {\n-   0xffffffffff817ffdL, 0x3ffffL, \n+   0xffffffffff817ffdL, 0x7ffffL, \n };\n static final long[] jjtoSkip = {\n    0x2L, 0x0L, \n--- a/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a path, following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     }\n \n     public int hashCode(){\n-        return System.identityHashCode(bean) + name.hashCode();\n+        return name == null ? 0 : name.hashCode();\n     }\n \n     public boolean equals(Object object){\n         }\n \n         BeanPointer other = (BeanPointer)object;\n-        return bean == other.bean &&\n-                name.equals(other.name);\n+        if ((name == null && other.name != null) ||\n+                (name != null && !name.equals(other.name))){\n+            return false;\n+        }\n+\n+        if (bean instanceof Number || bean instanceof String || bean instanceof Boolean){\n+            return bean.equals(other.bean);\n+        }\n+        return bean == other.bean;\n     }\n \n     /**\n         if (parent != null){\n             return super.asPath();\n         }\n+        else if (bean == null){\n+            return \"null()\";\n+        }\n+        else if (bean instanceof Number){\n+            String string = bean.toString();\n+            if (string.endsWith(\".0\")){\n+                string = string.substring(0, string.length() - 2);\n+            }\n+            return string;\n+        }\n+        else if (bean instanceof Boolean){\n+            return ((Boolean)bean).booleanValue() ? \"true()\" : \"false()\";\n+        }\n+        else if (bean instanceof String){\n+            return \"'\" + bean + \"'\";\n+        }\n         return \"\";\n     }\n-\n-    public String toString(){\n-        return bean.getClass().getName() + \"@\" + System.identityHashCode(bean) +\n-            \"(\" + name + \")\";\n-    }\n-\n-    public Object clone(){\n-        BeanPointer pointer = new BeanPointer(name, bean, beanInfo);\n-        pointer.index = index;\n-//        pointer.value = value;\n-        pointer.propertyDescriptors = propertyDescriptors;\n-        pointer.names = names;\n-        return pointer;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private JXPathBeanInfo beanInfo;\n         return pd.getName();\n     }\n \n-    public Object clone(){\n-        BeanPropertyPointer newHolder = new BeanPropertyPointer(getParent(), beanInfo);\n-        newHolder.propertyIndex = propertyIndex;\n-        newHolder.propertyDescriptors = propertyDescriptors;\n-        newHolder.propertyDescriptor = propertyDescriptor;\n-        newHolder.names = names;\n-        newHolder.bean = bean;\n-        newHolder.index = index;\n-        return newHolder;\n-    }\n-\n     /**\n      * Finds the property descriptor corresponding to the current property index.\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointer.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n                 index == other.index;\n     }\n \n-    public String toString(){\n-        return asPath();\n+    public NodeIterator childIterator(NodeTest test, boolean reverse){\n+        return getValuePointer().childIterator(test, reverse);\n     }\n \n-    public Object clone(){\n-        ContainerPointer pointer = new ContainerPointer(parent, container);\n-        return pointer;\n+    public NodeIterator siblingIterator(NodeTest test, boolean reverse){\n+        return getValuePointer().siblingIterator(test, reverse);\n     }\n \n-    public NodeIterator childIterator(QName name, boolean reverse){\n-        return getValuePointer().childIterator(name, reverse);\n+    public NodeIterator attributeIterator(QName name){\n+        return getValuePointer().attributeIterator(name);\n     }\n \n-    public NodeIterator siblingIterator(QName name, boolean reverse){\n-        return getValuePointer().siblingIterator(name, reverse);\n+    public NodeIterator namespaceIterator(){\n+        return getValuePointer().namespaceIterator();\n     }\n \n-    public NodeIterator attributeIterator(){\n-        return getValuePointer().attributeIterator();\n+    public NodePointer namespacePointer(String namespace){\n+        return getValuePointer().namespacePointer(namespace);\n     }\n \n-    public NodePointer attributePointer(QName name){\n-        return getValuePointer().attributePointer(name);\n+    public boolean testNode(NodeTest nodeTest){\n+        return getValuePointer().testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributeIterator.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.w3c.dom.*;\n \n /**\n- * An iterator of children of a DOM Node.\n+ * An iterator of attributes of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DOMAttributeIterator implements NodeIterator {\n     private NodePointer parent;\n-    private NamedNodeMap attributes;\n+    private QName name;\n+    private List attributes;\n     private int position = 0;\n \n-    public DOMAttributeIterator(NodePointer parent){\n+    public DOMAttributeIterator(NodePointer parent, QName name){\n         this.parent = parent;\n-        attributes = ((Node)parent.getValue()).getAttributes();\n+        this.name = name;\n+        attributes = new ArrayList();\n+        Node node = (Node)parent.getValue();\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            String lname = name.getName();\n+            if (!lname.equals(\"*\")){\n+                Attr attr = getAttribute((Element)node, name);\n+                if (attr != null){\n+                    attributes.add(attr);\n+                }\n+            }\n+            else {\n+                NamedNodeMap map = node.getAttributes();\n+                int count = map.getLength();\n+                for (int i = 0; i < count; i++){\n+                    Attr attr = (Attr)map.item(i);\n+                    if (testAttr(attr, name)){\n+                        attributes.add(attr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean testAttr(Attr attr, QName testName){\n+        String nodePrefix = DOMNodePointer.getPrefix(attr);\n+        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n+\n+        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        String testLocalName = name.getName();\n+        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)){\n+            String testPrefix = testName.getPrefix();\n+\n+            if (equalStrings(testPrefix, nodePrefix)){\n+                return true;\n+            }\n+\n+            String testNS = null;\n+            if (testPrefix != null){\n+                testNS = parent.getNamespaceURI(testPrefix);\n+            }\n+\n+            String nodeNS = null;\n+            if (nodePrefix != null){\n+                nodeNS = parent.getNamespaceURI(nodePrefix);\n+            }\n+            return equalStrings(testNS, nodeNS);\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private Attr getAttribute(Element element, QName name){\n+        String testPrefix = name.getPrefix();\n+        String testNS = null;\n+\n+        if (testPrefix != null){\n+            testNS = parent.getNamespaceURI(testPrefix);\n+        }\n+\n+        Node attr;\n+        if (testNS != null){\n+            return element.getAttributeNodeNS(testNS, name.getName());\n+        }\n+        else {\n+            return element.getAttributeNode(name.getName());\n+        }\n     }\n \n     public NodePointer getNodePointer(){\n         if (index < 0){\n             index = 0;\n         }\n-        return new DOMAttributePointer(parent, (Attr)attributes.item(index));\n+        return new DOMAttributePointer(parent, (Attr)attributes.get(index));\n     }\n \n     public int getPosition(){\n \n     public boolean setPosition(int position){\n         this.position = position;\n-        return position >= 1 && position <= attributes.getLength();\n+        return position >= 1 && position <= attributes.size();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributePointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributePointer.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n     }\n \n     public QName getName(){\n-        return new QName(attr.getNamespaceURI(), attr.getNodeName());\n+        return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr));\n     }\n \n-    public NodeIterator childIterator(QName name, boolean reverse){\n-        return null;\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(),  DOMNodePointer.getLocalName(attr));\n     }\n \n-    public NodeIterator siblingIterator(QName name, boolean reverse){\n-        return null;\n+    public String getNamespaceURI(){\n+        String prefix = DOMNodePointer.getPrefix(attr);\n+        if (prefix == null){\n+            return null;\n+        }\n+        return parent.getNamespaceURI(prefix);\n     }\n \n     public Object getBaseValue(){\n         return true;\n     }\n \n+    public boolean testNode(NodeTest nodeTest){\n+        return nodeTest == null ||\n+                ((nodeTest instanceof NodeTypeTest) &&\n+                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    }\n+\n     /**\n      * Throws UnsupportedOperationException.\n      */\n             buffer.append('/');\n         }\n         buffer.append('@');\n-        buffer.append(getName().asString());\n+        buffer.append(getName());\n         return buffer.toString();\n     }\n \n         DOMAttributePointer other = (DOMAttributePointer)object;\n         return attr == other.attr;\n     }\n-\n-    public String toString(){\n-        return attr.toString();\n-    }\n-\n-    public Object clone(){\n-        DOMAttributePointer pointer = new DOMAttributePointer(parent, attr);\n-        return pointer;\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNamespaceIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNamespaceIterator.java,v 1.1 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/21 23:22:45 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of namespaces of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/21 23:22:45 $\n+ */\n+public class DOMNamespaceIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private List attributes;\n+    private int position = 0;\n+\n+    public DOMNamespaceIterator(NodePointer parent){\n+        this.parent = parent;\n+        attributes = new ArrayList();\n+        collectNamespaces(attributes, (Node)parent.getValue());\n+    }\n+\n+    private void collectNamespaces(List attributes, Node node){\n+        Node parent = node.getParentNode();\n+        if (parent != null){\n+            collectNamespaces(attributes, parent);\n+        }\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            NamedNodeMap map = node.getAttributes();\n+            int count = map.getLength();\n+            for (int i = 0; i < count; i++){\n+                Attr attr = (Attr)map.item(i);\n+                String prefix = DOMNodePointer.getPrefix(attr);\n+                String name = DOMNodePointer.getLocalName(attr);\n+                if ((prefix != null && prefix.equals(\"xmlns\")) ||\n+                        (prefix == null && name.equals(\"xmlns\"))){\n+                    attributes.add(attr);\n+                }\n+            }\n+        }\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        String prefix = \"\";\n+        Attr attr = (Attr)attributes.get(index);\n+        String name = attr.getPrefix();\n+        if (name != null && name.equals(\"xmlns\")){\n+            prefix = DOMNodePointer.getLocalName(attr);\n+        }\n+        return new NamespacePointer(parent, prefix, attr.getValue());\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position >= 1 && position <= attributes.size();\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodeIterator.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of children of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DOMNodeIterator implements NodeIterator {\n     private NodePointer parent;\n-    private QName name;\n+    private NodeTest nodeTest;\n+    private String namespaceURI;\n     private Node node;\n     private Node child = null;\n     private boolean children;\n     private boolean reverse;\n     private int position = 0;\n \n-    public DOMNodeIterator(NodePointer parent, boolean children, QName name, boolean reverse){\n+    public DOMNodeIterator(NodePointer parent, boolean children, NodeTest nodeTest, boolean reverse){\n         this.parent = parent;\n         this.children = children;\n         this.node = (Node)parent.getValue();\n-        this.name = name;\n+        this.nodeTest = nodeTest;\n         this.reverse = reverse;\n     }\n \n     }\n \n     private boolean testChild(){\n-        if (name == null){\n-            return true;\n-        }\n-        String ns = child.getNamespaceURI();\n-        String nodeName = child.getNodeName();\n-        if (nodeName != null && nodeName.equals(name.getName())){\n-            return true;\n-        }\n-        return false;\n+        return DOMNodePointer.testNode(parent, child, nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodePointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodePointer.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n+    private Map namespaces;\n+    private String defaultNamespace;\n+\n+    public static final String XML_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\";\n+    public static final String XMLNS_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\";\n \n     public DOMNodePointer(Node node){\n         super(null);\n         this.node = node;\n     }\n \n+    public boolean testNode(NodeTest test){\n+        return testNode(this, node, test);\n+    }\n+\n+    public static boolean testNode(NodePointer pointer, Node node, NodeTest test){\n+        if (test == null){\n+            return true;\n+        }\n+        else if (test instanceof NodeNameTest){\n+            if (node.getNodeType() != Node.ELEMENT_NODE){\n+                return false;\n+            }\n+\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\") || testLocalName.equals(DOMNodePointer.getLocalName(node))){\n+                String testPrefix = testName.getPrefix();\n+                String nodePrefix = DOMNodePointer.getPrefix(node);\n+                if (equalStrings(testPrefix, nodePrefix)){\n+                    return true;\n+                }\n+\n+                String testNS = pointer.getNamespaceURI(testPrefix);\n+                String nodeNS = pointer.getNamespaceURI(nodePrefix);\n+                return equalStrings(testNS, nodeNS);\n+            }\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            int nodeType = node.getNodeType();\n+            switch (((NodeTypeTest)test).getNodeType()){\n+                case Compiler.NODE_TYPE_NODE:\n+                    return nodeType == Node.ELEMENT_NODE;\n+                case Compiler.NODE_TYPE_TEXT:\n+                    return nodeType == Node.CDATA_SECTION_NODE ||\n+                            nodeType == Node.TEXT_NODE;\n+                case Compiler.NODE_TYPE_COMMENT:\n+                    return nodeType == Node.COMMENT_NODE;\n+                case Compiler.NODE_TYPE_PI:\n+                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n+            }\n+            return false;\n+        }\n+        else if (test instanceof ProcessingInstructionTest){\n+            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE){\n+                String testPI = ((ProcessingInstructionTest)test).getTarget();\n+                String nodePI = ((ProcessingInstruction)node).getTarget();\n+                return testPI.equals(nodePI);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     public QName getName(){\n+        int type = node.getNodeType();\n+        if (type == Node.ELEMENT_NODE){\n+            return new QName(DOMNodePointer.getPrefix(node), DOMNodePointer.getLocalName(node));\n+        }\n+        else if (type == Node.PROCESSING_INSTRUCTION_NODE){\n+            return new QName(null, ((ProcessingInstruction)node).getTarget());\n+        }\n+        return null;\n+    }\n+\n+    public String getNamespaceURI(){\n         if (node.getNodeType() == Node.ELEMENT_NODE){\n-            return new QName(node.getNamespaceURI(), node.getNodeName());\n+            return getNamespaceURI(getName().getPrefix());\n         }\n         return null;\n     }\n \n-    public NodeIterator childIterator(QName name, boolean reverse){\n-        return new DOMNodeIterator(this, true, name, reverse);\n-    }\n-\n-    public NodeIterator siblingIterator(QName name, boolean reverse){\n-        return new DOMNodeIterator(this, false, name, reverse);\n-    }\n-\n-    public NodePointer attributePointer(QName name){\n-        NamedNodeMap map = node.getAttributes();\n-        Node attr;\n-        if (name.getPrefix() == null){\n-            attr = map.getNamedItem(name.getName());\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(), getName().getName());\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse){\n+        return new DOMNodeIterator(this, true, test, reverse);\n+    }\n+\n+    public NodeIterator siblingIterator(NodeTest test, boolean reverse){\n+        return new DOMNodeIterator(this, false, test, reverse);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return new DOMAttributeIterator(this, name);\n+    }\n+\n+    public NodePointer namespacePointer(String prefix){\n+        return new NamespacePointer(this, prefix);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return new DOMNamespaceIterator(this);\n+    }\n+\n+    public String getNamespaceURI(String prefix){\n+        if (prefix == null || prefix.equals(\"\")){\n+            return getDefaultNamespaceURI();\n+        }\n+\n+        if (prefix.equals(\"xml\")){\n+            return XML_NAMESPACE_URI;\n+        }\n+\n+        if (prefix.equals(\"xmlns\")){\n+            return XMLNS_NAMESPACE_URI;\n+        }\n+\n+        String namespace = null;\n+        if (namespaces == null){\n+            namespaces = new HashMap();\n         }\n         else {\n-            attr = map.getNamedItemNS(name.getPrefix(), name.getName());\n-        }\n-        if (attr == null){\n-            return null;\n-        }\n-        else {\n-            return new DOMAttributePointer(this, (Attr)attr);\n-        }\n+            namespace = (String)namespaces.get(prefix);\n+        }\n+\n+        if (namespace == null){\n+            String qname = \"xmlns:\" + prefix;\n+            Node aNode = node;\n+            while (aNode != null){\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n+                    Attr attr = ((Element)aNode).getAttributeNode(qname);\n+                    if (attr != null){\n+                        namespace = attr.getValue();\n+                        break;\n+                    }\n+                }\n+                aNode = aNode.getParentNode();\n+            }\n+            if (namespace == null || namespace.equals(\"\")){\n+                namespace = NodePointer.UNKNOWN_NAMESPACE;\n+            }\n+        }\n+\n+        namespaces.put(prefix, namespace);\n+        // TBD: We are supposed to resolve relative URIs to absolute ones.\n+        return namespace;\n+    }\n+\n+    public String getDefaultNamespaceURI(){\n+        if (defaultNamespace == null){\n+            Node aNode = node;\n+            while (aNode != null){\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n+                    Attr attr = ((Element)aNode).getAttributeNode(\"xmlns\");\n+                    if (attr != null){\n+                        defaultNamespace = attr.getValue();\n+                        break;\n+                    }\n+                }\n+                aNode = aNode.getParentNode();\n+            }\n+        }\n+        if (defaultNamespace == null){\n+            defaultNamespace = \"\";\n+        }\n+        // TBD: We are supposed to resolve relative URIs to absolute ones.\n+        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n     }\n \n     public Object getBaseValue(){\n \n     public Object getValue(){\n         return node;\n+    }\n+\n+    public boolean isCollection(){\n+        return false;\n+    }\n+\n+    public int getLength(){\n+        return 1;\n     }\n \n     public boolean isLeaf(){\n         throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n     }\n \n-    /**\n-     */\n     public String asPath(){\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null){\n         }\n         switch(node.getNodeType()){\n             case Node.ELEMENT_NODE:\n-                buffer.append('/');\n-                buffer.append(getName().asString());\n-                buffer.append('[').append(getRelativePositionByName()).append(']');\n+                // If the parent pointer is not a DOMNodePointer, it is\n+                // the parent's responsibility to produce the node test part\n+                // of the path\n+                if (parent instanceof DOMNodePointer){\n+                    buffer.append('/');\n+                    buffer.append(getName());\n+                    buffer.append('[').append(getRelativePositionByName()).append(']');\n+                }\n                 break;\n             case Node.TEXT_NODE:\n             case Node.CDATA_SECTION_NODE:\n-                // TBD: position\n-                buffer.append(\"/self::text()\");\n+                buffer.append(\"/text()\");\n+                buffer.append('[').append(getRelativePositionOfTextNode()).append(']');\n                 break;\n             case Node.PROCESSING_INSTRUCTION_NODE:\n-                // TBD: position\n                 String target = ((ProcessingInstruction)node).getTarget();\n-                buffer.append(\"/self::processing-instruction(\").append(target).append(')');\n+                buffer.append(\"/processing-instruction(\\'\").append(target).append(\"')\");\n+                buffer.append('[').append(getRelativePositionOfPI(target)).append(']');\n                 break;\n             case Node.DOCUMENT_NODE:\n                 // That'll be empty\n         Node n = node.getPreviousSibling();\n         while (n != null){\n             if (n.getNodeType() == Node.ELEMENT_NODE){\n-                String ns = n.getNamespaceURI();\n                 String nm = n.getNodeName();\n-                if ((ns != null && ns.equals(node.getNamespaceURI())) ||\n-                    (ns == null && node.getNamespaceURI() == null)){\n-                    if ((nm != null && nm.equals(node.getNodeName())) ||\n-                        (nm == null && node.getNodeName() == null)){\n-                        count ++;\n-                    }\n+                if (nm.equals(node.getNodeName())){\n+                    count ++;\n                 }\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    private int getRelativePositionOfTextNode(){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE){\n+                count ++;\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    private int getRelativePositionOfPI(String target){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE &&\n+                    ((ProcessingInstruction)n).getTarget().equals(target)){\n+                count ++;\n             }\n             n = n.getPreviousSibling();\n         }\n         return node == other.node;\n     }\n \n-    public String toString(){\n-        return node.toString();\n-    }\n-\n-    public Object clone(){\n-        DOMNodePointer pointer = new DOMNodePointer(parent, node);\n-        return pointer;\n+    public static String getPrefix(Node node){\n+        String prefix = node.getPrefix();\n+        if (prefix != null){\n+            return prefix;\n+        }\n+\n+        String name = node.getNodeName();\n+        int index = name.lastIndexOf(':');\n+        if (index == -1){\n+            return null;\n+        }\n+\n+        return name.substring(0, index);\n+    }\n+\n+    public static String getLocalName(Node node){\n+        String localName = node.getLocalName();\n+        if (localName != null){\n+            return localName;\n+        }\n+\n+        String name = node.getNodeName();\n+        int index = name.lastIndexOf(':');\n+        if (index == -1){\n+            return name;\n+        }\n+\n+        return name.substring(index + 1);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * for the first element of a path; following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DynamicPointer extends PropertyOwnerPointer {\n     private QName name;\n         return bean.getClass().getName() + \"@\" + System.identityHashCode(bean) +\n             \"(\" + name + \")\";\n     }\n-\n-    public Object clone(){\n-        DynamicPointer pointer = new DynamicPointer(name, bean, handler);\n-        pointer.index = index;\n-        pointer.names = names;\n-        return pointer;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n         }\n     }\n \n-    public Object clone(){\n-        DynamicPropertyPointer newHolder = new DynamicPropertyPointer(getParent(), handler);\n-        newHolder.propertyIndex = propertyIndex;\n-        newHolder.name = name;\n-        newHolder.names = names;\n-        newHolder.bean = bean;\n-        newHolder.index = index;\n-        return newHolder;\n-    }\n-\n     public String asPath(){\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getParent().asPath());\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NamespacePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NamespacePointer.java,v 1.1 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/21 23:22:45 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * Represents a namespace node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/21 23:22:45 $\n+ */\n+public class NamespacePointer extends NodePointer {\n+    private String prefix;\n+    private String namespaceURI;\n+\n+    public NamespacePointer(NodePointer parent, String prefix){\n+        super(parent);\n+        this.prefix = prefix;\n+    }\n+\n+    public NamespacePointer(NodePointer parent, String prefix, String namespaceURI){\n+        super(parent);\n+        this.prefix = prefix;\n+        this.namespaceURI = namespaceURI;\n+    }\n+\n+    public QName getName(){\n+        return new QName(getNamespaceURI(), prefix);\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public Object getValue(){\n+        return getNamespaceURI();\n+    }\n+\n+    public String getNamespaceURI(){\n+        if (namespaceURI == null){\n+            namespaceURI = parent.getNamespaceURI(prefix);\n+        }\n+        return namespaceURI;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return nodeTest == null ||\n+                ((nodeTest instanceof NodeTypeTest) &&\n+                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append(\"namespace::\");\n+        buffer.append(prefix);\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        String nsURI = getNamespaceURI();\n+        if (nsURI == null){\n+            return 0;\n+        }\n+        else {\n+            return nsURI.hashCode();\n+        }\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NamespacePointer)){\n+            return false;\n+        }\n+\n+        NamespacePointer other = (NamespacePointer)object;\n+        String nsURI = getNamespaceURI();\n+        String otherNSURI = other.getNamespaceURI();\n+        return (nsURI == null && otherNSURI == null) ||\n+               (nsURI != null && nsURI.endsWith(otherNSURI));\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodeIterator.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Definition for an iterator for all kinds of Nodes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public interface NodeIterator {\n \n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Common superclass for Poitners of all kinds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable {\n \n     public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n     protected int index = WHOLE_COLLECTION;\n+    public static String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n \n     public static NodePointer createNodePointer(QName name, Object bean){\n         if (bean == null){\n      * Returns a NodeIterator that iterates over all children or all children\n      * with the given name.\n      */\n-    public abstract NodeIterator childIterator(QName name, boolean reverse);\n+    public NodeIterator childIterator(NodeTest test, boolean reverse){\n+        return null;\n+    }\n \n     /**\n      * Returns a NodeIterator that iterates over all siblings or all siblings\n      * with the given name starting with this pointer and excluding the value\n      * currently pointed at.\n      */\n-    public abstract NodeIterator siblingIterator(QName name, boolean reverse);\n-\n-    /**\n-     * Returns a NodeIterator that iterates over all attributes of the value\n+    public NodeIterator siblingIterator(NodeTest test, boolean reverse){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all attributes of the current node\n+     * matching the supplied node name (could have a wildcard).\n+     * May return null if the object does not support the attributes.\n+     */\n+    public NodeIterator attributeIterator(QName qname){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all namespaces of the value\n      * currently pointed at.\n-     * May return null if the object does not support the attributes.\n-     */\n-    public NodeIterator attributeIterator(){\n-        return null;\n-    }\n-\n-    /**\n-     * Returns a NodePointer for the specified attribute. May return null\n-     * if attributes are not supported or if there is no such attribute.\n-     */\n-    public NodePointer attributePointer(QName attribute){\n-        return null;\n+     * May return null if the object does not support the namespaces.\n+     */\n+    public NodeIterator namespaceIterator(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodePointer for the specified namespace. Will return null\n+     * if namespaces are not supported. Will return UNKNOWN_NAMESPACE if there is no such namespace.\n+     */\n+    public NodePointer namespacePointer(String namespace){\n+        return null;\n+    }\n+\n+    public String getNamespaceURI(String prefix){\n+        return null;\n+    }\n+\n+    public String getNamespaceURI(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns true if the supplied prefix represents the\n+     * default namespace in the context of the current node.\n+     */\n+    protected boolean isDefaultNamespace(String prefix){\n+        if (prefix == null){\n+            return true;\n+        }\n+\n+        String namespace = getNamespaceURI(prefix);\n+        if (namespace == null){\n+            return false;       // undefined namespace\n+        }\n+\n+        return namespace.equals(getDefaultNamespaceURI());\n+    }\n+\n+    protected String getDefaultNamespaceURI(){\n+        return null;\n+    }\n+\n+    public QName getExpandedName(){\n+        return getName();\n     }\n \n     protected NodePointer parent;\n     public abstract QName getName();\n     public abstract Object getBaseValue();\n     public abstract void setValue(Object value);\n-    public abstract Object clone();\n+    public abstract boolean testNode(NodeTest nodeTest);\n \n     public String asPath(){\n         StringBuffer buffer = new StringBuffer();\n             if (getParent() != null){\n                 buffer.append('/');\n             }\n-            buffer.append(name.asString());\n+            buffer.append(name);\n         }\n         if (index != WHOLE_COLLECTION && isCollection()){\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n     }\n+\n+    public Object clone(){\n+        try {\n+            return super.clone();\n+        }\n+        catch (CloneNotSupportedException ex){\n+            // Of course it is supported\n+            ex.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    public String toString(){\n+        return asPath();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class NullPointer extends PropertyOwnerPointer {\n     private QName name;\n     }\n \n     public int hashCode(){\n-        return name.hashCode();\n+        return name == null ? 0 : name.hashCode();\n     }\n \n     public boolean equals(Object object){\n         }\n \n         NullPointer other = (NullPointer)object;\n-        return name.equals(other.name);\n-    }\n-\n-    public String toString(){\n-        return \"null(\" + name + \")\";\n+        return (name == null && other.name == null) ||\n+               (name != null && name.equals(other.name));\n     }\n \n     public String asPath(){\n         if (parent != null){\n             return super.asPath();\n         }\n-        return \"\";\n+        return \"null()\";\n     }\n \n     public int getLength(){\n         return 0;\n     }\n-\n-    public Object clone(){\n-        return new NullPointer(name);\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n     public String[] getPropertyNames(){\n         return new String[0];\n     }\n-\n-    public Object clone(){\n-        NullPropertyPointer newHolder = new NullPropertyPointer(getParent());\n-        newHolder.propertyName = propertyName;\n-        return newHolder;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyIterator.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class PropertyIterator implements NodeIterator {\n     boolean empty = false;\n     private int position = 0;\n     private PropertyPointer propertyNodePointer;\n     private int startPropertyIndex;\n-    private boolean firstIteration = true;\n \n     private boolean ready = false;\n     private boolean includeStart = false;\n     }\n \n     public NodePointer getNodePointer(){\n-        if (firstIteration){\n-            firstIteration = false;\n+        if (position == 0){\n             if (name != null){\n                 if (!targetReady){\n                     prepare();\n     }\n \n     public boolean setPosition(int position){\n-        firstIteration = false;\n         if (name != null){\n             return setPositionIndividual(position);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyOwnerPointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyOwnerPointer.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n-    public NodeIterator childIterator(QName name, boolean reverse){\n-        String property;\n-        if (name == null || name.getName().equals(\"*\")){\n-            property = null;\n-        }\n-        else {\n-            property = name.getName();\n-        }\n-        // TBD: qname\n-        return new PropertyIterator(this, true, property, reverse);\n+    public NodeIterator childIterator(NodeTest test, boolean reverse){\n+        return nodeIterator(test, reverse, true);\n     }\n \n-    public NodeIterator siblingIterator(QName name, boolean reverse){\n-        String property;\n-        if (name == null || name.getName().equals(\"*\")){\n-            property = null;\n-        }\n-        else {\n-            property = name.getName();\n-        }\n-        // TBD: qname\n-        return new PropertyIterator(this, false, property, reverse);\n+    public NodeIterator siblingIterator(NodeTest test, boolean reverse){\n+        return nodeIterator(test, reverse, false);\n     }\n \n+    private NodeIterator nodeIterator(NodeTest test, boolean reverse, boolean children){\n+        if (test == null){\n+            return new PropertyIterator(this, children, null, reverse);\n+        }\n+        else if (test instanceof NodeNameTest){\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            String property;\n+            if (!isDefaultNamespace(testName.getPrefix())){\n+                return null;\n+            }\n+            else if (testName.getName().equals(\"*\")){\n+                property = null;\n+            }\n+            else {\n+                property = testName.getName();\n+            }\n+            return new PropertyIterator(this, children, property, reverse);\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+                return new PropertyIterator(this, children, null, reverse);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean testNode(NodeTest test){\n+        if (test == null){\n+            return true;\n+        }\n+        else if (test instanceof NodeNameTest){\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            QName nodeName = getName();\n+            String testPrefix = testName.getPrefix();\n+            String nodePrefix = nodeName.getPrefix();\n+            if (!equalStrings(testPrefix, nodePrefix)){\n+                String testNS = getNamespaceURI(testPrefix);\n+                String nodeNS = getNamespaceURI(nodePrefix);\n+                if (!equalStrings(testNS, nodeNS)){\n+                    return false;\n+                }\n+            }\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\")){\n+                return true;\n+            }\n+            return testLocalName.equals(nodeName.getName());\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n \n     public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n \n \n     public abstract QName getName();\n     public abstract void setValue(Object value);\n-    public abstract Object clone();\n \n     public PropertyPointer getPropertyPointer(){\n         Object value = getValue();\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public abstract class PropertyPointer extends PropertyOwnerPointer {\n     protected int propertyIndex = UNSPECIFIED_PROPERTY;\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.w3c.dom.Node;\n \n /**\n+ * Pointer to a context variable.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n     private QName name;\n     private NodePointer valuePointer;\n \n-    /**\n-     * Used for the root node\n-     */\n     public VariablePointer(Variables variables, QName name){\n         super(null);\n         this.variables = variables;\n                 index == other.index;\n     }\n \n-    public String toString(){\n-        return asPath();\n-    }\n-\n     public String asPath(){\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('$');\n-        buffer.append(name.asString());\n+        buffer.append(name);\n         if (index != WHOLE_COLLECTION && isCollection()){\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n     }\n \n-    public Object clone(){\n-        VariablePointer pointer = new VariablePointer(variables, name);\n-        pointer.index = index;\n-        return pointer;\n+    public NodeIterator childIterator(NodeTest test, boolean reverse){\n+        return getValuePointer().childIterator(test, reverse);\n     }\n \n-//    private\n-\n-    public NodeIterator childIterator(QName name, boolean reverse){\n-        return getValuePointer().childIterator(name, reverse);\n+    public NodeIterator siblingIterator(NodeTest test, boolean reverse){\n+        return getValuePointer().siblingIterator(test, reverse);\n     }\n \n-    public NodeIterator siblingIterator(QName name, boolean reverse){\n-        return getValuePointer().siblingIterator(name, reverse);\n+    public NodeIterator attributeIterator(QName name){\n+        return getValuePointer().attributeIterator(name);\n     }\n \n-    public NodeIterator attributeIterator(){\n-        return getValuePointer().attributeIterator();\n+    public NodeIterator namespaceIterator(){\n+        return getValuePointer().namespaceIterator();\n     }\n \n-    public NodePointer attributePointer(QName name){\n-        return getValuePointer().attributePointer(name);\n+    public NodePointer namespacePointer(String name){\n+        return getValuePointer().namespacePointer(name);\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return getValuePointer().testNode(nodeTest);\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.5 2001/09/11 23:34:26 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2001/09/11 23:34:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.6 2001/09/21 23:22:45 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2001/09/21 23:22:45 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2001/09/11 23:34:26 $\n+ * @version $Revision: 1.6 $ $Date: 2001/09/21 23:22:45 $\n  */\n \n public class JXPathTestCase extends TestCase\n {\n-    private boolean enabled = true;\n+    private boolean enabled = false;\n \n     /**\n      * Exercises this test case only\n             PropertyPointer holder = root.getPropertyPointer();\n             holder.setPropertyIndex(relativeProperty(holder, relativePropertyIndex));\n             holder.setIndex(offset);\n-            it = holder.siblingIterator(new QName(null, \"integers\"), reverse);\n+            it = holder.siblingIterator(new NodeNameTest(new QName(null, \"integers\")), reverse);\n         }\n         else {\n-//            it = PropertyIterator.iterator(root, \"integers\", reverse);\n-            it = root.childIterator(new QName(null, \"integers\"), reverse);\n+            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse);\n         }\n \n         int size = 0;\n \n             testGetValue(context, \"$z/int\",  new Integer(1));\n             testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n-\n+            testGetValue(context, \".\",  bean.getBeans());\n             testGetValue(context, \".[2]/name\",  \"Name 2\");\n             testGetValue(context, \"$t[2]\",  \"b\");\n             testGetValue(context, \"$m/Key1\",  \"Value 1\");\n-//          testGetValue(context, \"[1]\",  new Integer(2));\n         }\n     }\n \n     private void testGetValue(JXPathContext context, String xpath, Object expected) {\n         Object actual = context.getValue(xpath);\n+//        System.err.println(\"xpath: \" + xpath + \" ACTUAL: \" + actual);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n     }\n \n     }\n \n     public void testParserReferenceImpl(){\n+        if (!enabled){\n+            return;\n+        }\n         System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n                 \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n         testParser(JXPathContextFactory.newInstance().newContext(null, bean), false);\n                 ex.printStackTrace();\n             }\n         }\n+\n+        // Make sure that location paths are properly constructed\n+        for (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n+                    Pointer ptr = ctx.locateValue(xpath_tests[i].xpath);\n+//                  System.err.println(xpath_tests[i].xpath + \" ptr: \" + ptr.getClass() + \"\\n  \" + ptr.asPath());\n+                    Pointer test = ctx.locateValue(ptr.asPath());\n+                    assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n+                }\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during pointer test <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n     }\n \n     private static class XP {\n \n         // Variables\n         test(\"$a\", new Double(1)),\n+        testPath(\"$a\", \"$a\"),\n         test(\"$a = $b\", Boolean.TRUE),\n         test(\"$a = $test\", Boolean.FALSE),\n \n         // child::\n         test(\"count(set)\", new Double(3)),\n         test(\"boolean\", Boolean.FALSE),\n+        testEval(\"foo:boolean\", list()),\n+        test(\"@*\", null),\n         testPath(\"boolean\", \"/boolean\"),\n         testEvalPath(\"boolean\", list(\"/boolean\")),\n         test(\"nestedBean/name\", \"Name 0\"),\n         testEval(\"//self::node()[name = 'Name 0']/name\", list(\"Name 0\")),\n         testEval(\"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n                 list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n-        test(\"count(//self::beans)\", new Double(2)),\n-        test(\"count(nestedBean//.)\", new Double(7)),\n+        test(\"count(//self::beans)\", new Double(4)),\n+        test(\"count(nestedBean//.)\", new Double(13)),\n         testEval(\"descendant-or-self::name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n         test(\"count(descendant-or-self::root)\", new Double(1)),\n         test(\"count(descendant-or-self::node())\", new Double(66)),\n         test(\"ceiling(-1.5)\", new Double(-1)),\n         test(\"round(1.5)\", new Double(2)),\n         test(\"round(-1.5)\", new Double(-1)),\n+        test(\"null()\", null),\n \n         // Extension functions\n         test(\"string(test:new())\", \"foo=0; bar=null\"),\n         testEval(\"$testnull/nothing[1]\", Collections.EMPTY_LIST),\n     };\n \n+    private static List list(){\n+        return Collections.EMPTY_LIST;\n+    }\n+\n     private static List list(Object o1){\n         List list = new ArrayList();\n         list.add(o1);\n     }\n \n     public void testDOM(){\n+//        if (!enabled){\n+//            return;\n+//        }\n         System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n                 \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n         try {\n     }\n \n     static final XP[] dom_tests = new XP[]{\n-        // Numbers\n         test(\"vendor/location/address/street\", \"Some street\"),\n         test(\"vendor/location[2]/address/street\", \"Other street\"),\n         test(\"//street\", \"Some street\"),\n-        test(\"name(//street/..)\", \"address\"),\n+        test(\"local-name(//street/..)\", \"address\"),\n         test(\"number(vendor/location/employeeCount)\", new Double(10)),\n         test(\"vendor/location/employeeCount + 1\", new Double(11)),\n         test(\"vendor/location/employeeCount and true()\", Boolean.TRUE),\n         test(\"vendor/location/@id\", \"100\"),\n         testPath(\"vendor/location/@id\", \"/vendor[1]/location[1]/@id\"),\n         testEval(\"vendor/location/@id\", list(\"100\", \"101\")),\n+        test(\"vendor/nsnode/foo:bar\", \"BAR\"),\n+        test(\"namespace-uri(vendor/nsnode/foo:bar)\", \"foonamespace\"),\n+        test(\"local-name(vendor/nsnode/foo:bar)\", \"bar\"),\n+        test(\"name(vendor/nsnode/foo:bar)\", \"foonamespace:bar\"),\n+        test(\"vendor/nsnode/baz\", \"BAZ\"),\n+        test(\"vendor/nsnode/baz/namespace::foo\", \"foonamespace\"),\n+        testPath(\"vendor/nsnode/baz/namespace::foo\", \"/vendor[1]/nsnode[1]/baz[1]/namespace::foo\"),\n+        test(\"count(vendor/nsnode/namespace::*)\", new Double(3)),\n+        test(\"name(vendor/nsnode/baz/namespace::foo)\", \"foonamespace:foo\"),\n+        test(\"local-name(vendor/nsnode/baz/namespace::foo)\", \"foo\"),\n+        test(\"vendor/nsnode/foo:bar/@foo:attr\", \"A\"),\n+        test(\"vendor/nsnode/zoo:bar/@zoo:attr\", \"A\"),\n+        test(\"namespace-uri(vendor/nsnode/foo:bar/@foo:attr)\", \"foonamespace\"),\n+        test(\"local-name(vendor/nsnode/foo:bar/@foo:attr)\", \"attr\"),\n+        test(\"name(vendor/nsnode/foo:bar/@foo:attr)\", \"foonamespace:attr\"),\n+        test(\"vendor/nsnode/foo:bar/@attr\", \"B\"),\n+        test(\"namespace-uri(vendor/nsnode/foo:bar/@attr)\", null),\n+        test(\"local-name(vendor/nsnode/foo:bar/@attr)\", \"attr\"),\n+        test(\"name(vendor/nsnode/foo:bar/@attr)\", \"attr\"),\n+        test(\"vendor/nsnode/foo:x/y/ancestor::foo:x/y\", \"why\"),\n+        test(\"vendor/nsnode/foo:x/ancestor-or-self::foo:x/y\", \"why\"),\n+        test(\"vendor/nsnode/foo:x/y/ancestor::foo:*\" + \"/y\", \"why\"),\n+        test(\"count(vendor/nsnode/foo:*)\", new Double(2)),\n+        test(\"count(vendor/nsnode/zoo:*)\", new Double(2)),\n+        test(\"count(vendor/nsnode/*)\", new Double(1)),\n+        testEval(\"vendor/nsnode/foo:bar/@foo:*\", list(\"A\")),\n+        testEval(\"vendor/nsnode/foo:bar/@*\", list(\"B\")),\n+        test(\"count(//foo:*)\", new Double(2)),\n+        test(\"vendor/nsnode/foo:x/y/parent::foo:*\" + \"/y\", \"why\"),\n+        test(\"//location/following::foo:x/y\", \"why\"),\n+        test(\"//foo:x/self::foo:x/y\", \"why\"),\n+        test(\"//foo:x/self::x/y\", null),\n+\n+        test(\"//nsnode/comment()\", \"z\"),\n+        test(\"//nsnode/text()\", \"text\"),\n+        testPath(\"//nsnode/text()\", \"/vendor[1]/nsnode[1]/text()[1]\"),\n+        test(\"//nsnode/processing-instruction()\", \"ahead\"),\n+        test(\"//nsnode/processing-instruction('do')\", \"it\"),\n+        testPath(\"//nsnode/processing-instruction('do')\", \"/vendor[1]/nsnode[1]/processing-instruction('do')[1]\"),\n+        test(\"name(//nsnode/processing-instruction()[1])\", \"go\"),\n+\n         test(\"vendor/location/@blank\", \"\"),\n         test(\"vendor/location/@missing\", null),\n         test(\"count(vendor/location[1]/@*)\", new Double(3)),\n         test(\"vendor/location[@id='101']//street\", \"Other street\"),\n         test(\"$test/int\", new Integer(1)),\n         test(\"$test/vendor/location[1]//street\", \"Some street\"),\n+        testPath(\"$test/vendor/location[1]//street\", \"$test/vendor/location[1]/address[1]/street[1]\"),\n         test(\"$dom/vendor//street\", \"Some street\"),\n         test(\"$test/object/vendor/location[1]//street\", \"Some street\"),\n         testPath(\"$test/object/vendor/location[1]//street\", \"$test/object/vendor[1]/location[1]/address[1]/street[1]\"),", "timestamp": 1001114565, "metainfo": ""}