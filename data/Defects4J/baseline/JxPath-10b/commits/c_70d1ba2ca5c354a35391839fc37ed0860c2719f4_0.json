{"sha": "70d1ba2ca5c354a35391839fc37ed0860c2719f4", "log": "[JXPATH-91] add full key() function support; initial submission by Sergey Vladimirov  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ExtendedKeyManager.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath;\n+\n+/**\n+ * More complete implementation for the XPath <code>\"key()\"</code> function.\n+ * Returns NodeSet results and allows Object values for better compatibility\n+ * with non-XML graphs.\n+ *\n+ * @author Sergey Vladimirov\n+ * @author Matt Benson\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface ExtendedKeyManager extends KeyManager {\n+\n+    /**\n+     * Find a NodeSet by key/value.\n+     * @param context\n+     * @param key\n+     * @param value\n+     */\n+    NodeSet getNodeSetByKey(JXPathContext context, String key, Object value);\n+\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n+\n+import org.apache.commons.jxpath.util.KeyManagerUtils;\n \n /**\n  * JXPathContext  provides APIs for the traversal of graphs of JavaBeans using\n     }\n \n     /**\n+     * Locates a NodeSet by key/value.\n+     * @param key\n+     * @param value\n+     */\n+    public NodeSet getNodeSetByKey(String key, Object value) {\n+        KeyManager manager = getKeyManager();\n+        if (manager != null) {\n+            return KeyManagerUtils.getExtendedKeyManager(manager)\n+                    .getNodeSetByKey(this, key, value);\n+        }\n+        throw new JXPathException(\"Cannot find an element by key - \"\n+                + \"no KeyManager has been specified\");\n+    }\n+\n+    /**\n      * Registers a namespace prefix.\n      * \n      * @param prefix A namespace prefix\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n import java.util.Collection;\n import java.util.Locale;\n \n+import org.apache.commons.jxpath.BasicNodeSet;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.JXPathInvalidSyntaxException;\n+import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n+import org.apache.commons.jxpath.ri.axes.NodeSetContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n \n         return false;\n     }\n-    \n+\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getFunctionName());\n     }\n \n     protected Object functionKey(EvalContext context) {\n-        assertArgCount(2);\n+        assertArgRange(2, 3);\n         String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n-        String value = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        Object value = getArg2().compute(context);\n+        EvalContext ec = null;\n+        if (value instanceof EvalContext) {\n+            ec = (EvalContext) value;\n+            if (ec.hasNext()) {\n+                value = ((NodePointer) ec.next()).getValue();\n+            } else { // empty context -> empty results\n+                return new BasicNodeSet();\n+            }\n+        }\n         JXPathContext jxpathContext = context.getJXPathContext();\n-        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n-        return pointer.getPointerByKey(jxpathContext, key, value);\n+        if (getArgumentCount() == 3) {\n+            Object arg3 = getArg3().computeValue(context);\n+            if (arg3 instanceof EvalContext) {\n+                arg3 = ((EvalContext) arg3).getCurrentNodePointer();\n+            }\n+            if (!(arg3 instanceof NodePointer)) {\n+                throw new JXPathException(\"invalid third key() argument: \" + arg3);\n+            }\n+            jxpathContext = jxpathContext.getRelativeContext((NodePointer) arg3);\n+        }\n+        NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);\n+        if (ec != null && ec.hasNext()) {\n+            BasicNodeSet accum = new BasicNodeSet();\n+            accum.add(nodeSet);\n+            while (ec.hasNext()) {\n+                value = ((NodePointer) ec.next()).getValue();\n+                accum.add(jxpathContext.getNodeSetByKey(key, value));\n+            }\n+            nodeSet = accum;\n+        }\n+        return new NodeSetContext(context, nodeSet);\n     }\n \n     protected Object functionNamespaceURI(EvalContext context) {\n     }\n \n     private void assertArgCount(int count) {\n-        if (getArgumentCount() != count) {\n+        assertArgRange(count, count);\n+    }\n+\n+    private void assertArgRange(int min, int max) {\n+        int ct = getArgumentCount();\n+        if (ct < min || ct > max) {\n             throw new JXPathInvalidSyntaxException(\n-                    \"Incorrect number of argument: \" + this);\n+                    \"Incorrect number of arguments: \" + this);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n  */\n package org.apache.commons.jxpath.ri.model;\n \n+import java.util.HashSet;\n import java.util.Locale;\n \n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n     }\n \n     /**\n+     * Find a NodeSet by key/value.\n+     * @param context\n+     * @param key\n+     * @param value\n+     * @return NodeSet\n+     */\n+    public NodeSet getNodeSetByKey(JXPathContext context, String key, Object value) {\n+        return context.getNodeSetByKey(key, value);\n+    }\n+\n+    /**\n      * Returns an XPath that maps to this Pointer.\n      */\n     public String asPath() {\n     }\n \n     public int compareTo(Object object) {\n+        if (object == this) {\n+            return 0;\n+        }\n         // Let it throw a ClassCastException\n         NodePointer pointer = (NodePointer) object;\n         if (parent == pointer.parent) {\n         // Task 1: find the common parent\n         int depth1 = 0;\n         NodePointer p1 = this;\n+        HashSet parents1 = new HashSet();\n         while (p1 != null) {\n             depth1++;\n             p1 = p1.parent;\n-        }\n+            if (p1 != null) {\n+                parents1.add(p1);\n+            }\n+        }\n+        boolean commonParentFound = false;\n         int depth2 = 0;\n         NodePointer p2 = pointer;\n         while (p2 != null) {\n             depth2++;\n             p2 = p2.parent;\n-        }\n-        return compareNodePointers(this, depth1, pointer, depth2);\n+            if (parents1.contains(p2)) {\n+                commonParentFound = true;\n+            }\n+        }\n+        //nodes from different graphs are equal, else continue comparison:\n+        return commonParentFound ? compareNodePointers(this, depth1, pointer, depth2) : 0;\n     }\n \n     private int compareNodePointers(\n             return r == 0 ? 1 : r;\n         }\n         //henceforth depth1 == depth2:\n-        if (depth1 == 1 || p1 == p2 || p1 != null && p1.equals(p2)) {\n+        if (p1 == p2 || p1 != null && p1.equals(p2)) {\n             return 0;\n+        }\n+        if (depth1 == 1) {\n+            throw new JXPathException(\n+                    \"Cannot compare pointers that do not belong to the same tree: '\"\n+                    + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         return r == 0 ? p1.parent.compareChildNodePointers(p1, p2) : r;\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/KeyManagerUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import org.apache.commons.jxpath.BasicNodeSet;\n+import org.apache.commons.jxpath.ExtendedKeyManager;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.KeyManager;\n+import org.apache.commons.jxpath.NodeSet;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n+\n+/**\n+ * Utility class.\n+ * @author Matt Benson\n+ * @version $Revision:$ $Date:$\n+ */\n+public class KeyManagerUtils {\n+    private static class SingleNodeExtendedKeyManager implements\n+            ExtendedKeyManager {\n+        private KeyManager delegate;\n+\n+        public SingleNodeExtendedKeyManager(KeyManager delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        public NodeSet getNodeSetByKey(JXPathContext context, String key,\n+                Object value) {\n+            Pointer pointer = delegate.getPointerByKey(context, key, InfoSetUtil.stringValue(value));\n+            BasicNodeSet result = new BasicNodeSet();\n+            result.add(pointer);\n+            return result;\n+        }\n+\n+        public Pointer getPointerByKey(JXPathContext context, String keyName,\n+                String keyValue) {\n+            return delegate.getPointerByKey(context, keyName, keyValue);\n+        }\n+    }\n+\n+    /**\n+     * Get an ExtendedKeyManager from the specified KeyManager.\n+     * @param keyManager\n+     * @return <code>keyManager</code> if it implements ExtendedKeyManager\n+     *         or a basic single-result ExtendedKeyManager that delegates to\n+     *         <code>keyManager</code>.\n+     */\n+    public static ExtendedKeyManager getExtendedKeyManager(KeyManager keyManager) {\n+        return keyManager instanceof ExtendedKeyManager ? (ExtendedKeyManager) keyManager\n+                : new SingleNodeExtendedKeyManager(keyManager);\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.text.DecimalFormatSymbols;\n-\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.jxpath.ExtendedKeyManager;\n import org.apache.commons.jxpath.IdentityManager;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathTestCase;\n import org.apache.commons.jxpath.KeyManager;\n+import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.TestMixedModelBean;\n import org.apache.commons.jxpath.Variables;\n             }\n         });\n \n-        assertEquals(\"Test key\", \"42\", context.getValue(\"key('a', 'b')\"));\n-    }\n-    \n+        assertXPathValue(context, \"key('a', 'b')\", \"42\");\n+    }\n+\n+    public void testExtendedKeyFunction() {\n+        context.setKeyManager(new ExtendedKeyManager() {\n+            public Pointer getPointerByKey(JXPathContext context, String key,\n+                    String value) {\n+                return NodePointer.newNodePointer(null, \"incorrect\", null);\n+            }\n+\n+            public NodeSet getNodeSetByKey(JXPathContext context,\n+                    String keyName, Object keyValue) {\n+                return new NodeSet() {\n+\n+                    public List getNodes() {\n+                        return Arrays.asList(new Object[] { \"53\", \"64\" });\n+                    }\n+\n+                    public List getPointers() {\n+                        return Arrays.asList(new NodePointer[] {\n+                                NodePointer.newNodePointer(null, \"53\", null),\n+                                NodePointer.newNodePointer(null, \"64\", null) });\n+                    }\n+\n+                    public List getValues() {\n+                        return Arrays.asList(new Object[] { \"53\", \"64\" });\n+                    }\n+\n+                };\n+            }\n+        });\n+        assertXPathValue(context, \"key('a', 'b')\", \"53\");\n+        assertXPathValue(context, \"key('a', 'b')[1]\", \"53\");\n+        assertXPathValue(context, \"key('a', 'b')[2]\", \"64\");\n+        assertXPathValueIterator(context, \"key('a', 'b')\", list(\"53\", \"64\"));\n+        assertXPathValueIterator(context, \"'x' | 'y'\", list(\"x\", \"y\"));\n+        assertXPathValueIterator(context, \"key('a', 'x' | 'y')\", list(\"53\", \"64\", \"53\", \"64\"));\n+        assertXPathValueIterator(context, \"key('a', /list[position() < 4])\", list(\"53\", \"64\", \"53\", \"64\", \"53\", \"64\"));\n+        context.getVariables().declareVariable(\"ints\", new int[] { 0, 0 });\n+        assertXPathValueIterator(context, \"key('a', $ints)\", list(\"53\", \"64\", \"53\", \"64\"));\n+        assertXPathValueIterator(context, \"key('a', 'b', /list)\", list(\"53\", \"64\"));\n+        assertXPathValueIterator(context, \"key('a', $ints, /list)\", list(\"53\", \"64\", \"53\", \"64\"));\n+    }\n+\n     public void testFormatNumberFunction() {\n         \n         DecimalFormatSymbols symbols = new DecimalFormatSymbols();", "timestamp": 1183756901, "metainfo": ""}