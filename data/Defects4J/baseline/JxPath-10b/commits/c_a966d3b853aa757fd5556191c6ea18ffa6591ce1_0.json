{"sha": "a966d3b853aa757fd5556191c6ea18ffa6591ce1", "log": "Complete overhaul of the test suites   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.29 2002/10/20 03:48:21 dmitri Exp $\n+ * $Revision: 1.29 $\n+ * $Date: 2002/10/20 03:48:21 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n+import java.beans.*;\n+\n+/**\n+ * Abstract superclass for various JXPath tests.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.29 $ $Date: 2002/10/20 03:48:21 $\n+ */\n+\n+public abstract class JXPathTestCase extends TestCase\n+{\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public JXPathTestCase(String name)\n+    {\n+        super(name);\n+    }\n+/*\n+    protected void testXPaths(JXPathContext ctx, XPathTest xpath_tests[])\n+            throws Exception\n+    {\n+        Exception exception = null;\n+        for  (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                Object actual;\n+                // System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n+                if (xpath_tests[i].path){\n+                    if (xpath_tests[i].eval){\n+                        Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n+                        List paths = new ArrayList();\n+                        while (it.hasNext()){\n+                            paths.add(((Pointer)it.next()).asPath());\n+                        }\n+                        actual = paths;\n+                    }\n+                    else {\n+                        ctx.setLenient(xpath_tests[i].lenient);\n+                        actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n+                    }\n+                }\n+                else {\n+                    if (xpath_tests[i].eval){\n+                        ArrayList list = new ArrayList();\n+                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n+                        while (it.hasNext()){\n+                            list.add(it.next());\n+                        }\n+                        actual = list;\n+                    }\n+                    else {\n+                        ctx.setLenient(xpath_tests[i].lenient);\n+                        actual = ctx.getValue(xpath_tests[i].xpath);\n+                        ctx.setLenient(false);\n+                    }\n+                }\n+                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\",\n+                        xpath_tests[i].expected, actual);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during <\" +\n+                    xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+                exception = ex;\n+            }\n+            if (exception != null){\n+                throw exception;\n+            }\n+        }\n+\n+        // Make sure that location paths are properly constructed\n+        for (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n+                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n+                    Pointer test = ctx.getPointer(ptr.asPath());\n+                    assertEquals(\n+                        \"Testing pointer for <\" + xpath_tests[i].xpath + \">\",\n+                        ptr.asPath(), test.asPath());\n+                }\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during pointer test <\" +\n+                        xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+*/\n+    protected void assertXPathValue(JXPathContext ctx,\n+                String xpath, Object expected)\n+    {\n+        ctx.setLenient(false);\n+        Object actual = ctx.getValue(xpath);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    protected void assertXPathValue(JXPathContext ctx,\n+                String xpath, Object expected, Class resultType)\n+    {\n+        ctx.setLenient(false);\n+        Object actual = ctx.getValue(xpath, resultType);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    protected void assertXPathValueLenient(JXPathContext ctx,\n+                String xpath, Object expected)\n+    {\n+        ctx.setLenient(true);\n+        Object actual = ctx.getValue(xpath);\n+        ctx.setLenient(false);\n+        assertEquals(\"Evaluating lenient <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    protected void assertXPathSetValue(JXPathContext ctx,\n+                String xpath, Object value)\n+    {\n+        assertXPathSetValue(ctx, xpath, value, value);\n+    }\n+    \n+    protected void assertXPathSetValue(JXPathContext ctx,\n+                String xpath, Object value, Object expected)\n+    {\n+        ctx.setValue(xpath, value);\n+        Object actual = ctx.getValue(xpath);\n+        assertEquals(\"Modifying <\" + xpath + \">\", expected, actual);\n+    }\n+    \n+    protected void assertXPathCreatePath(JXPathContext ctx,\n+                String xpath, \n+                Object expectedValue, String expectedPath)\n+    {\n+        Pointer pointer = ctx.createPath(xpath);\n+        assertEquals(\"Creating path <\" + xpath + \">\", \n+                expectedPath, pointer.asPath());\n+                \n+        assertEquals(\"Creating path (pointer value) <\" + xpath + \">\", \n+                expectedValue, pointer.getValue());\n+                \n+        assertEquals(\"Creating path (context value) <\" + xpath + \">\", \n+                expectedValue, ctx.getValue(pointer.asPath()));\n+    }\n+    \n+    protected void assertXPathCreatePathAndSetValue(JXPathContext ctx,\n+                String xpath, Object value,\n+                String expectedPath)\n+    {\n+        Pointer pointer = ctx.createPathAndSetValue(xpath, value);\n+        assertEquals(\"Creating path <\" + xpath + \">\", \n+                expectedPath, pointer.asPath());\n+                \n+        assertEquals(\"Creating path (pointer value) <\" + xpath + \">\", \n+                value, pointer.getValue());\n+                \n+        assertEquals(\"Creating path (context value) <\" + xpath + \">\", \n+                value, ctx.getValue(pointer.asPath()));\n+    }    \n+    \n+    protected void assertXPathPointer(JXPathContext ctx,\n+                String xpath, String expected)\n+    {\n+        ctx.setLenient(false);\n+        Pointer pointer = ctx.getPointer(xpath);\n+        String actual = pointer.toString();\n+        assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    protected void assertXPathPointerLenient(JXPathContext ctx,\n+                String xpath, String expected)\n+    {\n+        ctx.setLenient(true);\n+        Pointer pointer = ctx.getPointer(xpath);\n+        String actual = pointer.toString();\n+        assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    protected void assertXPathValueAndPointer(JXPathContext ctx,\n+                String xpath, Object expectedValue, String expectedPointer)\n+    {\n+        assertXPathValue(ctx, xpath, expectedValue);\n+        assertXPathPointer(ctx, xpath, expectedPointer);\n+    }\n+    \n+    protected void assertXPathValueIterator(JXPathContext ctx,\n+                String xpath, Collection expected)\n+    {\n+        Collection actual;\n+        if (expected instanceof List){\n+            actual = new ArrayList();\n+        }\n+        else {\n+            actual = new HashSet();\n+        }\n+        Iterator it = ctx.iterate(xpath);\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n+        assertEquals(\"Evaluating value iterator <\" + xpath + \">\",\n+                expected, actual);\n+    }\n+\n+    protected void assertXPathPointerIterator(JXPathContext ctx,\n+                String xpath, Collection expected)\n+    {\n+        Collection actual;\n+        if (expected instanceof List){\n+            actual = new ArrayList();\n+        }\n+        else {\n+            actual = new HashSet();\n+        }\n+        Iterator it = ctx.iteratePointers(xpath);\n+        while (it.hasNext()){\n+            Pointer pointer = (Pointer)it.next();\n+            actual.add(pointer.toString());\n+        }\n+        assertEquals(\"Evaluating pointer iterator <\" + xpath + \">\",\n+                expected, actual);\n+    }\n+\n+    protected void assertDocumentOrder(JXPathContext context, \n+            String path1, String path2, int expected)\n+    {\n+        NodePointer np1 = (NodePointer)context.getPointer(path1);\n+        NodePointer np2 = (NodePointer)context.getPointer(path2);\n+        int res = np1.compareTo(np2);\n+        if (res < 0){\n+            res = -1;\n+        }\n+        else if (res > 0){\n+            res = 1;\n+        }\n+        assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", \n+                expected, res);\n+    }    \n+\n+    protected static List list(){\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    protected static List list(Object o1){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3){\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3, Object o4){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3, Object o4){\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3,\n+                Object o4, Object o5)\n+    {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3, \n+                Object o4, Object o5){\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3,\n+                Object o4, Object o5, Object o6)\n+    {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3,\n+                Object o4, Object o5, Object o6)\n+    {\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        return list;\n+    }\n+    \n+    protected static List list(Object o1, Object o2, Object o3,\n+                Object o4, Object o5, Object o6, Object o7)\n+    {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        list.add(o7);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3,\n+                Object o4, Object o5, Object o6, Object o7)\n+    {\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        list.add(o7);\n+        return list;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestSuite.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestSuite.java,v 1.1 2002/10/20 03:48:21 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:21 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.jxpath.ri.axes.SimplePathInterpreterTest;\n+import org.apache.commons.jxpath.ri.compiler.ContextDependencyTest;\n+import org.apache.commons.jxpath.ri.compiler.CoreFunctionTest;\n+import org.apache.commons.jxpath.ri.compiler.CoreOperationTest;\n+import org.apache.commons.jxpath.ri.compiler.ExtensionFunctionTest;\n+import org.apache.commons.jxpath.ri.compiler.VariableTest;\n+import org.apache.commons.jxpath.ri.model.MixedModelTest;\n+import org.apache.commons.jxpath.ri.model.beans.BeanModelTest;\n+import org.apache.commons.jxpath.ri.model.beans.DynamicPropertiesModelTest;\n+import org.apache.commons.jxpath.ri.model.dom.DOMModelTest;\n+import org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanModelTest;\n+import org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest;\n+import org.apache.commons.jxpath.util.BasicTypeConverterTest;\n+\n+/**\n+ * <p>\n+ *  Test Suite for the JXPath class.  The majority of these tests use\n+ *  instances of the TestBean class, so be sure to update the tests if you\n+ *  change the characteristics of that class.\n+ * </p>\n+ *\n+ * <p>\n+ *   Note that the tests are dependent upon the static aspects\n+ *   (such as array sizes...) of the TestBean.java class, so ensure\n+ *   that all changes to TestBean are reflected here and in other JXPath tests.\n+ * </p>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:21 $\n+ */\n+\n+public class JXPathTestSuite extends TestCase\n+{\n+    private static boolean enabled = true;\n+\n+    /**\n+     * Exercise the whole suite\n+     */\n+    public static void main(String args[]) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public JXPathTestSuite(String name){\n+        super(name);\n+    }\n+\n+    /**\n+     * Return the tests included in this test suite.\n+     */\n+    public static Test suite()\n+    {\n+        TestSuite suite = new TestSuite();\n+        suite.addTestSuite(SimplePathInterpreterTest.class);\n+        suite.addTestSuite(ContextDependencyTest.class);\n+        suite.addTestSuite(CoreFunctionTest.class);\n+        suite.addTestSuite(CoreOperationTest.class);\n+        suite.addTestSuite(ExtensionFunctionTest.class);\n+        suite.addTestSuite(VariableTest.class);\n+        suite.addTestSuite(BeanModelTest.class);\n+        suite.addTestSuite(DynamicPropertiesModelTest.class);\n+        suite.addTestSuite(DOMModelTest.class);\n+        suite.addTestSuite(DynaBeanModelTest.class);\n+        suite.addTestSuite(JDOMModelTest.class);\n+        suite.addTestSuite(MixedModelTest.class);\n+        suite.addTestSuite(BasicTypeConverterTest.class);\n+        return suite;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/TestBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.2 2002/04/10 03:40:21 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.3 2002/10/20 03:48:21 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/10/20 03:48:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:21 $\n+ * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:21 $\n  */\n public class TestBean {\n \n         beans = new NestedTestBean[2];\n         beans[0] = new NestedTestBean(\"Name 1\");\n         beans[1] = new NestedTestBean(\"Name 2\");\n+        beans[1].setInt(3);\n     }\n \n     public NestedTestBean[] getBeans(){\n         return map;\n     }\n \n-    public void setMap(HashMap map){\n-        this.map = map;\n+    public void setMap(Map map){\n+        this.map = (HashMap)map;\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestMixedModelBean.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestMixedModelBean.java,v 1.1 2002/10/20 03:48:21 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:21 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * Mixed model test bean: Java, collections, map, DOM, Container.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:21 $\n+ */\n+public class TestMixedModelBean {\n+    private String string;\n+    private TestBean bean;\n+    private Container container;\n+    private Document document;\n+    private Element element;\n+\n+    private Map map;\n+\n+    private List list;\n+\n+    public TestMixedModelBean(){\n+        string = \"string\";\n+        bean = new TestBean();\n+        map = new HashMap();\n+        list = new ArrayList();\n+\n+        container = new DocumentContainer(getClass().getResource(\"Vendor.xml\"));\n+        document = (Document)container.getValue();\n+        element = document.getDocumentElement();\n+\n+        map.put(\"string\", string);\n+        map.put(\"bean\", bean);\n+        map.put(\"map\", map);\n+        map.put(\"list\", list);\n+        map.put(\"document\", document);\n+        map.put(\"element\", element);\n+        map.put(\"container\", container);\n+\n+        list.add(string);\n+        list.add(bean);\n+        list.add(map);\n+        list.add(Collections.singletonList(\"string2\"));\n+        list.add(document);\n+        list.add(element);\n+        list.add(container);\n+    }\n+\n+    public String getString(){\n+        return string;\n+    }\n+    \n+    public TestBean getBean() {\n+        return bean;\n+    }\n+    \n+    public Map getMap(){\n+        return map;\n+    }\n+\n+    public List getList() {\n+        return list;\n+    }\n+        \n+    public Document getDocument() {\n+        return document;\n+    }\n+    \n+    public Element getElement() {\n+        return element;\n+    }\n+    \n+    public Container getContainer(){\n+        return container;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n \n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.TestBeanWithNode;\n import org.apache.commons.jxpath.TestNull;\n-import org.apache.commons.jxpath.TestFactory;\n import org.apache.commons.jxpath.NestedTestBean;\n import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.model.beans.*;\n         bean.getMap().put(\"Key6\", new Object[0]);\n         context = JXPathContext.newContext(null, bean);\n         context.setLenient(true);\n-        context.setFactory(new TestFactory());\n+        context.setFactory(new TestBeanFactory());\n     }\n \n     public void test_doStep_noPredicates_propertyOwner(){\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n+import org.w3c.dom.Document;\n+\n+/**\n+ * Test bean for mixed model JUnit tests.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestBeanWithNode extends TestBean {\n+    private Object node;\n+    private Object object;\n+\n+    public Object getVendor(){\n+        return node;\n+    }\n+\n+    public Object[] getVendors(){\n+        return new Object[]{node};\n+    }\n+\n+    public void setVendor(Object node){\n+        this.node = node;\n+    }\n+\n+    public Object getObject(){\n+        return object;\n+    }\n+\n+    public void setObject(Object object){\n+        this.object = object;\n+    }\n+\n+    public static TestBeanWithNode createTestBeanWithDOM(){\n+        DocumentContainer docCtr = new DocumentContainer(\n+                JXPathTestCase.class.getResource(\"Vendor.xml\"));\n+        Document doc = (Document)docCtr.getValue();\n+        TestBeanWithNode tbwdom = new TestBeanWithNode();\n+        tbwdom.setVendor(doc.getDocumentElement());\n+        tbwdom.setObject(docCtr);\n+        return tbwdom;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.ri.Parser;\n+\n+/**\n+ * Tests the determination of whether an expression is context dependent.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class ContextDependencyTest extends JXPathTestCase\n+{\n+    public ContextDependencyTest(String name){\n+        super(name);\n+    }\n+\n+    public void testContextDependency(){\n+        testContextDependency(\"1\", false);\n+        testContextDependency(\"$x\", false);\n+        testContextDependency(\"/foo\", false);\n+        testContextDependency(\"foo\", true);\n+        testContextDependency(\"/foo[3]\", false);\n+        testContextDependency(\"/foo[$x]\", false);\n+        testContextDependency(\"/foo[bar]\", true);\n+        testContextDependency(\"3 + 5\", false);\n+        testContextDependency(\"test:func(3, 5)\", true);\n+        testContextDependency(\"test:func(3, foo)\", true);\n+    }\n+\n+    public void testContextDependency(String xpath, boolean expected){\n+        Expression expr = \n+            (Expression)Parser.parseExpression(xpath, new TreeCompiler());\n+        \n+        assertEquals(\"Context dependency <\" + xpath + \">\", \n+                expected, \n+                expr.isContextDependent());\n+    }   \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.IdentityManager;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.KeyManager;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestMixedModelBean;\n+import org.apache.commons.jxpath.Variables;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * Test basic functionality of JXPath - core functions.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class CoreFunctionTest extends JXPathTestCase\n+{\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public CoreFunctionTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(new TestMixedModelBean());\n+            Variables vars = context.getVariables();\n+            vars.declareVariable(\"nan\", new Double(Double.NaN));\n+        }\n+    }\n+\n+    public void testCoreFunctions(){\n+        assertXPathValue(context,\"string(2)\", \"2\");\n+        assertXPathValue(context,\"string($nan)\", \"NaN\");\n+        assertXPathValue(context,\"string(-$nan)\", \"NaN\");\n+        assertXPathValue(context,\"string(-2 div 0)\", \"-Infinity\");\n+        assertXPathValue(context,\"string(2 div 0)\", \"Infinity\");\n+        assertXPathValue(context,\"concat('a', 'b', 'c')\", \"abc\");\n+        assertXPathValue(context,\"starts-with('abc', 'ab')\", Boolean.TRUE);\n+        assertXPathValue(context,\"starts-with('xabc', 'ab')\", Boolean.FALSE);\n+        assertXPathValue(context,\"contains('xabc', 'ab')\", Boolean.TRUE);\n+        assertXPathValue(context,\"contains('xabc', 'ba')\", Boolean.FALSE);\n+        assertXPathValue(context,\"substring-before('1999/04/01', '/')\", \"1999\");\n+        assertXPathValue(context,\"substring-after('1999/04/01', '/')\", \"04/01\");\n+        assertXPathValue(context,\"substring('12345', 2, 3)\", \"234\");\n+        assertXPathValue(context,\"substring('12345', 2)\", \"2345\");\n+        assertXPathValue(context,\"substring('12345', 1.5, 2.6)\", \"234\");\n+        assertXPathValue(context,\"substring('12345', 0, 3)\", \"12\");\n+        assertXPathValue(context,\"substring('12345', 0 div 0, 3)\", \"\");\n+        assertXPathValue(context,\"substring('12345', 1, 0 div 0)\", \"\");\n+        assertXPathValue(context,\"substring('12345', -42, 1 div 0)\", \"12345\");\n+        assertXPathValue(context,\"substring('12345', -1 div 0, 1 div 0)\", \"\");\n+        assertXPathValue(context,\"string-length('12345')\", new Double(5));\n+        assertXPathValue(context,\"normalize-space(' abc  def  ')\", \"abc def\");\n+        assertXPathValue(context,\"normalize-space('abc def')\", \"abc def\");\n+        assertXPathValue(context,\"normalize-space('   ')\", \"\");\n+        assertXPathValue(context,\"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\");\n+        assertXPathValue(context,\"boolean(1)\", Boolean.TRUE);\n+        assertXPathValue(context,\"boolean(0)\", Boolean.FALSE);\n+        assertXPathValue(context,\"boolean('x')\", Boolean.TRUE);\n+        assertXPathValue(context,\"boolean('')\", Boolean.FALSE);\n+        \n+        assertXPathValue(context,\"true()\", Boolean.TRUE);\n+        assertXPathValue(context,\"false()\", Boolean.FALSE);\n+        assertXPathValue(context,\"not(false())\", Boolean.TRUE);\n+        assertXPathValue(context,\"not(true())\", Boolean.FALSE);\n+        assertXPathValue(context,\"number('1')\", new Double(1));\n+        assertXPathValue(context,\"floor(1.5)\", new Double(1));\n+        assertXPathValue(context,\"floor(-1.5)\", new Double(-2));\n+        assertXPathValue(context,\"ceiling(1.5)\", new Double(2));\n+        assertXPathValue(context,\"ceiling(-1.5)\", new Double(-1));\n+        assertXPathValue(context,\"round(1.5)\", new Double(2));\n+        assertXPathValue(context,\"round(-1.5)\", new Double(-1));\n+        assertXPathValue(context,\"null()\", null);\n+    }\n+\n+    public void testIDFunction(){\n+        context.setIdentityManager(new IdentityManager(){\n+            public Pointer getPointerByID(JXPathContext context, String id){\n+                NodePointer ptr = (NodePointer)context.getPointer(\"/document\");\n+                return ptr.getPointerByID(context, id);\n+            }\n+        });\n+\n+        assertXPathValueAndPointer(context,\n+                \"id(101)//street\",\n+                \"Tangerine Drive\",\n+                \"id('101')/address[1]/street[1]\");\n+\n+        assertXPathPointerLenient(context,\n+                \"id(105)/address/street\",\n+                \"id(105)/address/street\");\n+    }\n+    \n+    public void testKeyFunction(){\n+        context.setKeyManager(new KeyManager(){\n+            public Pointer getPointerByKey(JXPathContext context,\n+                                            String key, String value){\n+                return NodePointer.newNodePointer(null, \"42\", null);\n+            }\n+        });\n+        \n+        assertEquals(\"Test key\", \"42\",\n+            context.getValue(\"key('a', 'b')\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.Variables;\n+\n+/**\n+ * Test basic functionality of JXPath - infoset types,\n+ * operations.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class CoreOperationTest extends JXPathTestCase\n+{\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public CoreOperationTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(null);\n+            Variables vars = context.getVariables();\n+            vars.declareVariable(\"integer\", new Integer(1));\n+        }\n+    }\n+\n+    public void testInfoSetTypes(){\n+\n+        // Numbers\n+        assertXPathValue(context, \"1\",  new Double(1.0));\n+        assertXPathPointer(context, \"1\", \"1\");\n+        assertXPathValueIterator(context,\"1\", list(new Double(1.0)));\n+\n+        assertXPathPointerIterator(context, \"1\", list(\"1\"));\n+\n+        assertXPathValue(context,\"-1\", new Double(-1.0));\n+        assertXPathValue(context,\"2 + 2\", new Double(4.0));\n+        assertXPathValue(context,\"3 - 2\", new Double(1.0));\n+        assertXPathValue(context,\"1 + 2 + 3 - 4 + 5\", new Double(7.0));\n+        assertXPathValue(context,\"3 * 2\", new Double(3.0*2.0));\n+        assertXPathValue(context,\"3 div 2\", new Double(3.0/2.0));\n+        assertXPathValue(context,\"5 mod 2\", new Double(1.0));\n+\n+        // This test produces a different result with Xalan?\n+        assertXPathValue(context,\"5.9 mod 2.1\", new Double(1.0));\n+\n+        assertXPathValue(context,\"5 mod -2\", new Double(1.0));\n+        assertXPathValue(context,\"-5 mod 2\", new Double(-1.0));\n+        assertXPathValue(context,\"-5 mod -2\", new Double(-1.0));\n+        assertXPathValue(context,\"1 < 2\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 > 2\", Boolean.FALSE);\n+        assertXPathValue(context,\"1 <= 1\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 >= 2\", Boolean.FALSE);\n+        assertXPathValue(context,\"3 > 2 > 1\", Boolean.FALSE);\n+        assertXPathValue(context,\"3 > 2 and 2 > 1\", Boolean.TRUE);\n+        assertXPathValue(context,\"3 > 2 and 2 < 1\", Boolean.FALSE);\n+        assertXPathValue(context,\"3 < 2 or 2 > 1\", Boolean.TRUE);\n+        assertXPathValue(context,\"3 < 2 or 2 < 1\", Boolean.FALSE);\n+        assertXPathValue(context,\"1 = 1\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 = '1'\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 > 2 = 2 > 3\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 > 2 = 0\", Boolean.TRUE);\n+        assertXPathValue(context,\"1 = 2\", Boolean.FALSE);\n+\n+        assertXPathValue(context, \n+                \"$integer\",\n+                new Double(1), \n+                Double.class);\n+                \n+        assertXPathValue(context, \n+                \"2 + 3\",\n+                \"5.0\",\n+                String.class);\n+                \n+        assertXPathValue(context, \n+                \"2 + 3\",\n+                Boolean.TRUE, \n+                boolean.class);\n+                \n+        assertXPathValue(context, \n+                \"'true'\",\n+                Boolean.TRUE, \n+                Boolean.class);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.ClassFunctions;\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.FunctionLibrary;\n+import org.apache.commons.jxpath.Functions;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.PackageFunctions;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.Variables;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * Test extension functions.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class ExtensionFunctionTest extends JXPathTestCase\n+{\n+    private Functions functions;\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public ExtensionFunctionTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(new TestBean());\n+            Variables vars = context.getVariables();\n+            vars.declareVariable(\"test\", new TestFunctions(4, \"test\"));\n+           \n+            FunctionLibrary lib = new FunctionLibrary();\n+            lib.addFunctions(new ClassFunctions(TestFunctions.class, \"test\"));\n+            lib.addFunctions(new ClassFunctions(TestFunctions2.class, \"test\"));\n+            lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n+            lib.addFunctions(\n+                    new PackageFunctions(\"org.apache.commons.jxpath.\", \n+                            \"jxpathtest\"));\n+            context.setFunctions(lib);\n+        }\n+        functions = new ClassFunctions(TestFunctions.class, \"test\");\n+    }\n+    \n+    public void testConstructorLookup(){\n+        Object[] args = new Object[]{new Integer(1), \"x\"};\n+        Function func = functions.getFunction(\"test\", \"new\", args);\n+        \n+        assertEquals(\"test:new(1, x)\", \n+            func.invoke(new Context(null), args).toString(), \n+            \"foo=1; bar=x\");\n+    }\n+    \n+    public void testConstructorLookupWithExpressionContext(){\n+        Object[] args = new Object[]{\"baz\"};\n+        Function func =functions.getFunction(\"test\", \"new\", args);\n+        assertEquals(\"test:new('baz')\", \n+                func.invoke(new Context(new Integer(1)), args).toString(), \n+                \"foo=1; bar=baz\");\n+    }\n+    \n+    public void testStaticMethodLookup(){\n+        Object[] args = new Object[]{new Integer(1), \"x\"};\n+        Function func =functions.getFunction(\"test\", \"build\", args);\n+        assertEquals(\"test:build(1, x)\", \n+                func.invoke(new Context(null), args).toString(), \n+                \"foo=1; bar=x\");\n+    }\n+    \n+    public void testStaticMethodLookupWithConversion(){\n+        Object[] args = new Object[]{\"7\", new Integer(1)};\n+        Function func =functions.getFunction(\"test\", \"build\", args);\n+        assertEquals(\"test:build('7', 1)\", \n+                func.invoke(new Context(null), args).toString(), \n+                \"foo=7; bar=1\");\n+    }\n+    \n+    public void testMethodLookup(){\n+        Object[] args = new Object[]{new TestFunctions()};\n+        Function func =functions.getFunction(\"test\", \"getFoo\", args);\n+        assertEquals(\"test:getFoo($test, 1, x)\", \n+                func.invoke(new Context(null), args).toString(), \n+                \"0\");\n+    }\n+    \n+    public void testStaticMethodLookupWithExpressionContext(){\n+        Object[] args = new Object[0];\n+        Function func =functions.getFunction(\"test\", \"path\", args);\n+        assertEquals(\"test:path()\", \n+                func.invoke(new Context(new Integer(1)), args), \n+                \"1\");\n+    }\n+    \n+    public void testMethodLookupWithExpressionContext(){\n+        Object[] args = new Object[]{new TestFunctions()};\n+        Function func =functions.getFunction(\"test\", \"instancePath\", args);\n+        assertEquals(\"test:instancePath()\", \n+                func.invoke(new Context(new Integer(1)), args), \n+                \"1\");\n+    }\n+    \n+    public void testMethodLookupWithExpressionContextAndArgument(){\n+        Object[] args = new Object[]{new TestFunctions(), \"*\"};\n+        Function func =functions.getFunction(\"test\", \"pathWithSuffix\", args);\n+        assertEquals(\"test:pathWithSuffix('*')\", \n+                func.invoke(new Context(new Integer(1)), args), \n+                \"1*\");\n+    }    \n+\n+    public void testAllocation(){ \n+        \n+        // Allocate new object using the default constructor\n+        assertXPathValue(context, \n+                \"string(test:new())\", \n+                \"foo=0; bar=null\");\n+                \n+        // Allocate new object using PackageFunctions and class name\n+        assertXPathValue(context, \n+                \"string(jxpathtest:TestFunctions.new())\", \n+                \"foo=0; bar=null\");\n+                \n+        // Allocate new object using a fully qualified class name\n+        assertXPathValue(context, \n+                \"string(\" + TestFunctions.class.getName() + \".new())\", \n+                \"foo=0; bar=null\");\n+                \n+        // Allocate new object using a custom constructor\n+        assertXPathValue(context, \n+                \"string(test:new(3, 'baz'))\", \n+                \"foo=3; bar=baz\");\n+                \n+        // Allocate new object using a custom constructor - type conversion\n+        assertXPathValue(context, \n+                \"string(test:new('3', 4))\", \n+                \"foo=3; bar=4.0\");                \n+    }\n+\n+    public void testMethodCall(){ \n+        assertXPathValue(context, \n+                \"length('foo')\", \n+                new Integer(3));\n+                \n+        // We are just calling a method - prefix is ignored\n+        assertXPathValue(context, \n+                \"call:substring('foo', 1, 2)\", \n+                \"o\");\n+        \n+        // Invoke a function implemented as a regular method\n+        assertXPathValue(context, \n+                \"string(test:getFoo($test))\", \n+                \"4\");\n+        \n+        // Note that the prefix is ignored anyway, we are just calling a method\n+        assertXPathValue(context, \n+                \"string(call:getFoo($test))\", \n+                \"4\");\n+        \n+        // We don't really need to supply a prefix in this case\n+        assertXPathValue(context, \n+                \"string(getFoo($test))\", \n+                \"4\");                \n+\n+        // Method with two arguments\n+        assertXPathValue(context, \n+                \"string(test:setFooAndBar($test, 7, 'biz'))\", \n+                \"foo=7; bar=biz\");\n+    }\n+\n+    public void testStaticMethodCall(){ \n+                                \n+        assertXPathValue(context, \n+                \"string(test:build(8, 'goober'))\", \n+                \"foo=8; bar=goober\");\n+                \n+        // Call a static method using PackageFunctions and class name\n+        assertXPathValue(context, \n+                \"string(jxpathtest:TestFunctions.build(8, 'goober'))\", \n+                \"foo=8; bar=goober\");\n+        \n+        // Call a static method with a fully qualified class name\n+        assertXPathValue(context, \n+                \"string(\" + TestFunctions.class.getName() + \n+                        \".build(8, 'goober'))\", \n+                \"foo=8; bar=goober\");\n+                \n+        // Two ClassFunctions are sharing the same prefix.\n+        // This is TestFunctions2\n+        assertXPathValue(context, \n+                \"string(test:increment(8))\", \n+                \"9\");\n+                \n+    }\n+\n+    public void testExpressionContext(){ \n+        // Execute an extension function for each node while searching\n+        // The function uses ExpressionContext to get to the current\n+        // node.\n+        assertXPathValue(context, \n+                \"//.[test:isMap()]/Key1\", \n+                \"Value 1\");\n+                \n+        // The function uses ExpressionContext to get to all\n+        // nodes in the context that is passed to it.\n+        assertXPathValue(context, \n+                \"count(//.[test:count(strings) = 3])\", \n+                new Double(7));\n+\n+        // The function uses ExpressionContext to get to the current\n+        // pointer and returns its path.\n+        assertXPathValue(context, \n+                \"/beans[contains(test:path(), '[2]')]/name\", \n+                \"Name 2\");\n+    }\n+    \n+    private static class Context implements ExpressionContext {\n+        private Object object;\n+\n+        public Context(Object object){\n+            this.object = object;\n+        }\n+\n+        public Pointer getContextNodePointer(){\n+            return NodePointer.newNodePointer(null, object, Locale.getDefault());\n+        }\n+\n+        public List getContextNodeList(){\n+            return null;\n+        }\n+\n+        public JXPathContext getJXPathContext(){\n+            return null;\n+        }\n+\n+        public int getPosition(){\n+            return 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.Pointer;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestFunctions {\n+\n+    private int foo;\n+    private String bar;\n+\n+    public TestFunctions(){\n+    }\n+\n+    public TestFunctions(int foo, String bar){\n+        this.foo = foo;\n+        this.bar = bar;\n+    }\n+\n+    public TestFunctions(ExpressionContext context, String bar){\n+        this.foo = ((Number)context.getContextNodePointer().getValue()).\n+        \t\tintValue();\n+        this.bar = bar;\n+    }\n+\n+    public int getFoo(){\n+        return foo;\n+    }\n+\n+    public String getBar(){\n+        return bar;\n+    }\n+\n+    public void doit(){\n+    }\n+\n+    public TestFunctions setFooAndBar(int foo, String bar){\n+        this.foo = foo;\n+        this.bar = bar;\n+        return this;\n+    }\n+\n+    public static TestFunctions build(int foo, String bar){\n+        return new TestFunctions(foo, bar);\n+    }\n+\n+    public String toString(){\n+        return \"foo=\" + foo + \"; bar=\" + bar;\n+    }\n+\n+    public static String path(ExpressionContext context){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    public String instancePath(ExpressionContext context){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    public String pathWithSuffix(ExpressionContext context, String suffix){\n+        return context.getContextNodePointer().asPath() + suffix;\n+    }\n+\n+    public String className(ExpressionContext context, ExpressionContext child){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    /**\n+     * Returns true if the current node in the current context is a map\n+     */\n+    public static boolean isMap(ExpressionContext context){\n+        Pointer ptr = context.getContextNodePointer();\n+        return ptr == null ? false : (ptr.getValue() instanceof Map);\n+    }\n+\n+    /**\n+     * Returns the number of nodes in the context that is passed as\n+     * the first argument.\n+     */\n+    public static int count(ExpressionContext context, Collection col){\n+        return col.size();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestFunctions2 {\n+\n+    public static int increment(int i){\n+        return i + 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class VariableFactory extends AbstractFactory {\n+\n+    /**\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        if (name.equals(\"testArray\")){\n+            ((TestBean[])parent)[index] = new TestBean();\n+            return true;\n+        }\n+        else if (name.equals(\"stringArray\")){\n+            ((String[])parent)[index] = \"\";\n+            return true;\n+        }\n+        else if (name.equals(\"array\")){\n+            ((String[])parent)[index] = \"\";\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Create a new object and set it on the specified variable\n+     */\n+    public boolean declareVariable(JXPathContext context, String name){\n+        if (name.equals(\"test\")){\n+            context.getVariables().declareVariable(name, new TestBean());\n+            return true;\n+        }\n+        else if (name.equals(\"testArray\")){\n+            context.getVariables().declareVariable(name, new TestBean[0]);\n+            return true;\n+        }\n+        else if (name.equals(\"stringArray\")){\n+            context.getVariables().declareVariable(name, new String[]{\"Value1\"});\n+            return true;\n+        }\n+        context.getVariables().declareVariable(name, null);\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.Variables;\n+\n+/**\n+ * Test basic functionality of JXPath - infoset types,\n+ * operations.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class VariableTest extends JXPathTestCase\n+{\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public VariableTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(null);\n+            context.setFactory(new VariableFactory());\n+        \n+            Variables vars = context.getVariables();\n+            vars.declareVariable(\"a\", new Double(1));\n+            vars.declareVariable(\"b\", new Double(1));\n+            vars.declareVariable(\"c\", null);            \n+            vars.declareVariable(\"d\", new String[]{\"a\", \"b\"});\n+            vars.declareVariable(\"integer\", new Integer(1));\n+            vars.declareVariable(\"nan\", new Double(Double.NaN));\n+            vars.declareVariable(\"x\", null);\n+        }\n+    }\n+\n+    public void testVariables(){\n+        // Variables\n+        assertXPathValueAndPointer(context,\n+                \"$a\", \n+                new Double(1),\n+                \"$a\");\n+    }\n+    \n+    public void testVariablesInExpressions(){\n+        assertXPathValue(context,\n+                \"$a = $b\", \n+                Boolean.TRUE);\n+                \n+        assertXPathValue(context,\n+                \"$a = $nan\", \n+                Boolean.FALSE);\n+\n+        assertXPathValue(context,\n+                \"$a + 1\", \n+                new Double(2));\n+\n+        assertXPathValue(context,\n+                \"$c\", \n+                null);\n+                \n+        assertXPathValue(context, \n+                \"$d[2]\",  \n+                \"b\");\n+    }\n+    \n+    public void testInvalidVariableName(){                \n+        boolean exception = false;\n+        try {\n+            context.getValue(\"$none\");\n+        }\n+        catch (Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Evaluating '$none', expected exception - did not get it\", \n+                exception);\n+\n+        exception = false;\n+        try {\n+            context.setValue(\"$none\", new Integer(1));\n+        }\n+        catch (Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Setting '$none = 1', expected exception - did not get it\", \n+            exception);\n+    }\n+    \n+    public void testNestedContext(){\n+        JXPathContext nestedContext = \n+                JXPathContext.newContext(context, null);\n+\n+        assertXPathValue(nestedContext, \n+                \"$a\",  \n+                new Double(1));\n+    }    \n+    \n+    public void testSetValue(){        \n+        assertXPathSetValue(context, \n+                \"$x\",\n+                new Integer(1));\n+    }\n+    \n+    public void testCreatePathDeclareVariable(){\n+        // Calls factory.declareVariable(\"string\")\n+        assertXPathCreatePath(context, \n+                \"$string\", \n+                null,\n+                \"$string\");\n+    }\n+    \n+    public void testCreatePathAndSetValueDeclareVariable(){\n+        // Calls factory.declareVariable(\"string\")\n+        assertXPathCreatePathAndSetValue(context, \n+                \"$string\", \n+                \"Value\",\n+                \"$string\");\n+    }\n+    \n+    public void testCreatePathDeclareVariableSetCollectionElement(){\n+        // Calls factory.declareVariable(\"stringArray\"). \n+        // The factory needs to create a collection\n+        assertXPathCreatePath(context, \n+                \"$stringArray[2]\", \n+                \"\",\n+                \"$stringArray[2]\");\n+        \n+        // See if the factory populated the first element as well\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \n+                \"Value1\", \n+                context.getValue(\"$stringArray[1]\"));\n+    }\n+\n+    public void testCreateAndSetValuePathDeclareVariableSetCollectionElement(){\n+        // Calls factory.declareVariable(\"stringArray\"). \n+        // The factory needs to create a collection\n+        assertXPathCreatePathAndSetValue(context, \n+                \"$stringArray[2]\", \n+                \"Value2\",\n+                \"$stringArray[2]\");\n+        \n+        // See if the factory populated the first element as well\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \n+                \"Value1\", \n+                context.getValue(\"$stringArray[1]\"));\n+    }\n+\n+    public void testCreatePathExpandCollection(){\n+        context.getVariables().\n+            declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        assertXPathCreatePath(context, \n+                \"$array[2]\", \n+                \"\", \n+                \"$array[2]\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \n+                \"Value1\", \n+                context.getValue(\"$array[1]\"));\n+    }\n+\n+    public void testCreatePathAndSetValueExpandCollection(){\n+        context.getVariables().\n+            declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        assertXPathCreatePathAndSetValue(context, \n+                \"$array[2]\", \n+                \"Value2\", \n+                \"$array[2]\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \n+                \"Value1\", \n+                context.getValue(\"$array[1]\"));\n+    }\n+\n+    public void testCreatePathDeclareVariableSetProperty(){\n+        // Calls factory.declareVariable(\"test\"). \n+        // The factory should create a TestBean\n+        assertXPathCreatePath(context, \n+                \"$test/boolean\", \n+                Boolean.FALSE, \n+                \"$test/boolean\");\n+\n+    }\n+\n+    public void testCreatePathAndSetValueDeclareVariableSetProperty(){\n+        // Calls factory.declareVariable(\"test\"). \n+        // The factory should create a TestBean\n+        assertXPathCreatePathAndSetValue(context, \n+                \"$test/boolean\", \n+                Boolean.TRUE, \n+                \"$test/boolean\");\n+\n+    }\n+\n+    public void testCreatePathDeclareVariableSetCollectionElementProperty(){\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and \n+        // put it in the collection at index 1.\n+        assertXPathCreatePath(context, \n+                \"$testArray[2]/boolean\", \n+                Boolean.FALSE, \n+                \"$testArray[2]/boolean\");\n+    }\n+    \n+    public void testCreatePathAndSetValueDeclVarSetCollectionElementProperty(){\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and \n+        // put it in the collection at index 1.\n+        assertXPathCreatePathAndSetValue(context, \n+                \"$testArray[2]/boolean\", \n+                Boolean.TRUE, \n+                \"$testArray[2]/boolean\");\n+    }\n+    \n+    public void testRemovePathUndeclareVariable(){\n+        // Undeclare variable\n+        context.getVariables().declareVariable(\"temp\", \"temp\");\n+        context.removePath(\"$temp\");\n+        assertTrue(\"Undeclare variable\",\n+                !context.getVariables().isDeclaredVariable(\"temp\"));\n+\n+    }\n+    \n+    public void testRemovePathArrayElement(){\n+        // Remove array element - reassigns the new array to the var\n+        context.getVariables().\n+                declareVariable(\"temp\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove array element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+    }\n+    \n+    public void testRemovePathCollectionElement(){\n+        // Remove list element - does not create a new list\n+        context.getVariables().\n+                declareVariable(\"temp\", list(\"temp1\", \"temp2\"));\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove collection element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n+\n+/**\n+ * Abstract superclass for Bean access with JXPath.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public abstract class BeanModelTestCase extends JXPathTestCase\n+{\n+    private static boolean enabled = true;\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public BeanModelTestCase(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(createContextBean());\n+            context.setLocale(Locale.US);\n+            context.setFactory(getAbstractFactory());\n+        }\n+    }\n+\n+    protected abstract Object createContextBean();\n+    protected abstract AbstractFactory getAbstractFactory();\n+\n+    /**\n+     * Test property iterators, the core of the graph traversal engine\n+     */\n+    public void testIndividualIterators(){\n+        if (!enabled){\n+            return;\n+        }\n+//        testIndividual(0, 0, true, false, 3);\n+        testIndividual(+1, 0, true, false, 0);\n+        testIndividual(-1, 0, true, false, 4);\n+\n+        testIndividual(0, -1, true, true, 4);\n+        testIndividual(+1, -1, true, true, 4);\n+        testIndividual(-1, -1, true, true, 0);\n+\n+        testIndividual(0, 1, true, false, 2);\n+        testIndividual(0, 1, true, true, 1);\n+\n+        testIndividual(0, 0, false, false, 4);\n+        testIndividual(0, 0, false, true, 4);\n+    }\n+\n+    private void testIndividual(int relativePropertyIndex, int offset,\n+                boolean useStartLocation, boolean reverse, int expected)\n+    {\n+        PropertyOwnerPointer root =\n+            (PropertyOwnerPointer)NodePointer.newNodePointer(\n+                    new QName(null, \"root\"), createContextBean(),\n+                    Locale.getDefault());\n+\n+        NodeIterator it;\n+\n+        PropertyPointer start = null;\n+\n+        if (useStartLocation){\n+            start = root.getPropertyPointer();\n+            start.setPropertyIndex(relativeProperty(start, relativePropertyIndex));\n+            start.setIndex(offset);\n+        }\n+        it = root.childIterator(\n+                new NodeNameTest(new QName(null, \"integers\")),\n+                reverse, start);\n+\n+        int size = 0;\n+        while(it.setPosition(it.getPosition() + 1)){\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Individual, relativePropertyIndex=\" +\n+            relativePropertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    /**\n+     * Test property iterators with multiple properties returned\n+     */\n+    public void testMultipleIterators(){\n+        if (!enabled){\n+            return;\n+        }\n+        testMultiple(0, 0, true, false, 20);\n+\n+        testMultiple(3, 0, true, false, 16);\n+        testMultiple(3, -1, true, true, 8);\n+        testMultiple(3, 0, true, true, 4);\n+        testMultiple(0, 0, false, false, 21);\n+        testMultiple(0, 0, false, true, 21);\n+\n+        testMultiple(3, 1, true, false, 15);\n+        testMultiple(3, 3, true, false, 13);\n+    }\n+\n+    private void testMultiple(int propertyIndex, int offset,\n+                boolean useStartLocation, boolean reverse, int expected)\n+    {\n+        PropertyOwnerPointer root =\n+                (PropertyOwnerPointer)NodePointer.newNodePointer(\n+                        new QName(null, \"root\"), createContextBean(),\n+                        Locale.getDefault());\n+        NodeIterator it;\n+\n+        PropertyPointer start = null;\n+\n+        if (useStartLocation){\n+            start = root.getPropertyPointer();\n+            start.setPropertyIndex(propertyIndex);\n+            start.setIndex(offset);\n+        }\n+        it = root.childIterator(null, reverse, start);\n+\n+        int size = 0;\n+        while(it.setPosition(it.getPosition() + 1)){\n+//            System.err.println(\"LOC: \" + it.getCurrentNodePointer());\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Multiple, propertyIndex=\" + propertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    private int relativeProperty(PropertyPointer holder, int offset){\n+        String[] names = holder.getPropertyNames();\n+        for (int i = 0; i < names.length; i++){\n+            if (names[i].equals(\"integers\")){\n+                return i + offset;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public void testIteratePropertyArrayWithHasNext(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        while(it.hasNext()){\n+            actual.add(((Pointer)it.next()).asPath());\n+        }\n+        assertEquals(\"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n+            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n+            actual);\n+    }\n+\n+    public void testIteratePropertyArrayWithoutHasNext(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        for (int i = 0; i < 4; i++){\n+            actual.add(it.next().toString());\n+        }\n+        assertEquals(\"Iterating 'next'<\" + \"/integers\" + \">\",\n+            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n+            actual);\n+    }\n+\n+    public void testIterateAndSet(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+\n+        Iterator it = context.iteratePointers(\"beans/int\");\n+        int i = 5;\n+        while (it.hasNext()){\n+            NodePointer pointer = (NodePointer)it.next();\n+            pointer.setValue(new Integer(i++));\n+        }\n+\n+        it = context.iteratePointers(\"beans/int\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(((Pointer)it.next()).getValue());\n+        }\n+        assertEquals(\"Iterating <\" + \"beans/int\" + \">\",\n+                list(new Integer(5), new Integer(6)), actual);\n+    }\n+\n+    /**\n+     * Test contributed by Kate Dvortsova\n+     */\n+    public void testIteratePointerSetValue() {\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+\n+        assertXPathValue(context, \"/beans[1]/name\", \"Name 1\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+        // Test setting via context\n+        context.setValue(\"/beans[2]/name\", \"Name 2 set\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2 set\");\n+\n+        // Restore original value\n+        context.setValue(\"/beans[2]/name\", \"Name 2\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+        int iter_count = 0;\n+        Iterator iter = context.iteratePointers(\"/beans/name\");\n+        while (iter.hasNext()) {\n+            iter_count++;\n+            Pointer pointer = (Pointer) iter.next();\n+            String s = (String) pointer.getValue();\n+            s = s + \"suffix\";\n+            pointer.setValue(s);\n+            assertEquals(\"pointer.getValue\", s, pointer.getValue());\n+            // fails right here, the value isn't getting set in the bean.\n+            assertEquals(\"context.getValue\", s, context.getValue(pointer.asPath()));\n+        }\n+        assertEquals(\"Iteration count\", 2, iter_count);\n+\n+        assertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n+    }\n+\n+    public void testRoot(){\n+        assertXPathValueAndPointer(context,\n+                \"/\",\n+                context.getContextBean(),\n+                \"/\");\n+    }\n+\n+    public void testAxisAncestor(){\n+        // ancestor::\n+        assertXPathValue(context,\n+                \"int/ancestor::root = /\",\n+                Boolean.TRUE);\n+\n+        assertXPathValue(context,\n+                \"count(beans/name/ancestor-or-self::node())\",\n+                new Double(5));\n+\n+        assertXPathValue(context,\n+                \"beans/name/ancestor-or-self::node()[3] = /\",\n+                Boolean.TRUE);\n+    }\n+\n+    public void testAxisChild(){\n+        assertXPathValue(context,\n+                \"boolean\",\n+                Boolean.FALSE);\n+\n+        assertXPathPointer(context,\n+                \"boolean\",\n+                \"/boolean\");\n+\n+        assertXPathPointerIterator(context,\n+                \"boolean\",\n+                list(\"/boolean\"));\n+\n+        // Count elements in a child collection\n+        assertXPathValue(context,\n+                \"count(set)\",\n+                new Double(3));\n+\n+//        assertXPathValue(context,\"boolean/class/name\", \"java.lang.Boolean\");\n+\n+        // Child with namespace - should not find any\n+        assertXPathValueIterator(context,\n+                \"foo:boolean\",\n+                list());\n+\n+        // Count all children with a wildcard\n+        assertXPathValue(context,\n+                \"count(*)\",\n+                new Double(21));\n+\n+        // Same, constrained by node type = node()\n+        assertXPathValue(context,\n+                \"count(child::node())\",\n+                new Double(21));\n+    }\n+\n+    public void testAxisChildNestedBean(){\n+        // Nested bean\n+        assertXPathValue(context,\n+                \"nestedBean/name\",\n+                \"Name 0\");\n+\n+        assertXPathPointer(context,\n+                \"nestedBean/name\",\n+                \"/nestedBean/name\");\n+\n+        assertXPathPointerIterator(context,\n+                \"nestedBean/name\",\n+                list(\"/nestedBean/name\"));\n+    }\n+\n+    public void testAxisChildNestedCollection(){\n+        assertXPathValueIterator(context,\n+                \"integers\",\n+                list(new Integer(1), new Integer(2),\n+                     new Integer(3), new Integer(4)));\n+\n+        assertXPathPointer(context,\n+                \"integers\",\n+                \"/integers\");\n+\n+        assertXPathPointerIterator(context,\n+                \"integers\",\n+                list(\"/integers[1]\", \"/integers[2]\",\n+                     \"/integers[3]\", \"/integers[4]\"));\n+    }\n+\n+    public void testIndexPredicate(){\n+        assertXPathValue(context,\n+                \"integers[2]\",\n+                new Integer(2));\n+\n+        assertXPathPointer(context,\n+                \"integers[2]\",\n+                \"/integers[2]\");\n+\n+        assertXPathPointerIterator(context,\n+                \"integers[2]\",\n+                list(\"/integers[2]\"));\n+\n+        assertXPathValue(context,\n+                \"beans[1]/name\",\n+                \"Name 1\");\n+\n+        assertXPathPointer(context,\n+                \"beans[1]/name\",\n+                \"/beans[1]/name\");\n+\n+        assertXPathValueIterator(context,\n+                \"beans[1]/strings\",\n+                list(\"String 1\", \"String 2\", \"String 3\"));\n+\n+        assertXPathValueIterator(context,\n+                \"beans/strings[2]\",\n+                list(\"String 2\", \"String 2\"));\n+\n+        // Find the first match\n+        assertXPathValue(context,\n+                \"beans/strings[2]\",\n+                \"String 2\");\n+\n+        // Indexing in a set collected from a UnionContext\n+        assertXPathValue(context,\n+                \"(beans/strings[2])[1]\",\n+                \"String 2\");\n+    }\n+\n+    public void testAxisDescendant(){\n+       // descendant::\n+        assertXPathValue(context,\n+                \"count(descendant::node())\",\n+                new Double(65));\n+\n+        // Should not find any descendants with name root\n+        assertXPathValue(context,\n+                \"count(descendant::root)\",\n+                new Double(0));\n+\n+        assertXPathValue(context,\n+                \"count(descendant::name)\",\n+                new Double(7));\n+    }\n+\n+    public void testAxisDescendantOrSelf(){\n+        // descendant-or-self::\n+        assertXPathValueIterator(context,\n+                \"descendant-or-self::name\",\n+                set(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n+                     \"Name 0\", \"Name 5\", \"Name 4\"));\n+\n+        // Same - abbreviated syntax\n+        assertXPathValueIterator(context,\n+                \"//name\",\n+                set(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n+                     \"Name 0\", \"Name 5\", \"Name 4\"));\n+\n+        // See that it actually finds self\n+        assertXPathValue(context,\n+                \"count(descendant-or-self::root)\",\n+                new Double(1));\n+\n+        // Combine descendant-or-self:: and and self::\n+        assertXPathValue(context,\n+                \"count(nestedBean//.)\",\n+                new Double(7));\n+\n+        // Combine descendant-or-self:: and and self::name\n+        assertXPathValue(context,\n+                \"count(//self::beans)\",\n+                new Double(2));\n+\n+        // Count all nodes in the tree\n+        assertXPathValue(context,\n+                \"count(descendant-or-self::node())\",\n+                new Double(66));\n+\n+    }\n+\n+    public void testAxisFollowing(){\n+        // following::\n+        assertXPathValue(context,\n+                \"count(nestedBean/strings[2]/following::node())\",\n+                new Double(21));\n+\n+        assertXPathValue(context,\n+                \"count(nestedBean/strings[2]/following::strings)\",\n+                new Double(7));\n+    }\n+\n+    public void testAxisFollowingSibling(){\n+        // following-sibling::\n+        assertXPathValue(context,\n+                \"count(/nestedBean/following-sibling::node())\",\n+                new Double(8));\n+\n+        assertXPathValue(context,\n+                \"count(/nestedBean/following-sibling::object)\",\n+                new Double(1));\n+\n+        // Combine parent:: and following-sibling::\n+        assertXPathValue(context,\n+                \"count(/nestedBean/boolean/../following-sibling::node())\",\n+                new Double(8));\n+\n+        assertXPathValue(context,\n+                \"count(/nestedBean/boolean/../following-sibling::object)\",\n+                new Double(1));\n+\n+        // Combine descendant:: and following-sibling::\n+        assertXPathValue(context,\n+                \"count(/descendant::boolean/following-sibling::node())\",\n+                new Double(53));\n+\n+        assertXPathValue(context,\n+                \"count(/descendant::boolean/following-sibling::name)\",\n+                new Double(7));\n+    }\n+\n+    public void testAxisParent(){\n+        // parent::\n+        assertXPathValue(context,\n+                \"count(/beans/..)\",\n+                new Double(1));\n+\n+        assertXPathValue(context,\n+                \"count(//..)\",\n+                new Double(9));\n+\n+        assertXPathValue(context,\n+                \"count(//../..)\",\n+                new Double(2));\n+\n+        assertXPathValueIterator(context,\n+                \"//parent::beans/name\",\n+                list(\"Name 1\", \"Name 2\"));\n+    }\n+\n+    public void testAxisPreceding(){\n+        // preceding::\n+        assertXPathValue(context,\n+                \"count(beans[2]/int/preceding::node())\",\n+                new Double(8));\n+\n+        assertXPathValue(context,\n+                \"count(beans[2]/int/preceding::boolean)\",\n+                new Double(2));\n+    }\n+\n+    public void testAxisPrecedingSibling(){\n+        // preceding-sibling::\n+        assertXPathValue(context,\n+                \"count(/boolean/preceding-sibling::node())\",\n+                new Double(2));\n+\n+        assertXPathValue(context,\n+                \"count(/nestedBean/int/../preceding-sibling::node())\",\n+                new Double(12));\n+\n+        assertXPathValue(context,\n+                \"count(/descendant::int/preceding-sibling::node())\",\n+                new Double(10));\n+    }\n+\n+    public void testAxisSelf(){\n+        // self::\n+        assertXPathValue(context,\n+                \"self::node() = /\",\n+                Boolean.TRUE);\n+\n+        assertXPathValue(context,\n+                \"self::root = /\",\n+                Boolean.TRUE);\n+    }\n+\n+    public void testUnion(){\n+        // Union - note corrected document order\n+        assertXPathValueIterator(context,\n+                \"integers | beans[1]/strings\",\n+                list(\"String 1\", \"String 2\", \"String 3\",\n+                     new Integer(1), new Integer(2),\n+                     new Integer(3), new Integer(4)));\n+\n+        assertXPathValue(context,\n+                \"count((integers | beans[1]/strings)[contains(., '1')])\",\n+                new Double(2));\n+\n+        assertXPathValue(context,\n+                \"count((integers | beans[1]/strings)[name(.) = 'strings'])\",\n+                new Double(3));\n+\n+        // Note that the following is different from \"integer[2]\" -\n+        // it is a filter expression\n+        assertXPathValue(context,\n+                \"(integers)[2]\",\n+                new Integer(2));\n+     }\n+\n+    public void testAxisAttribute(){\n+        // Attributes are just like children to beans\n+        assertXPathValue(context,\n+                \"count(@*)\",\n+                new Double(21.0));\n+\n+        // Unknown attribute\n+        assertXPathValueLenient(context,\n+                \"@foo\",\n+                null);\n+    }\n+\n+    /**\n+     * Testing the pseudo-attribute \"name\" that java beans\n+     * objects appear to have.\n+     */\n+    public void testAttributeName(){\n+        assertXPathValue(context,\n+                \"nestedBean[@name = 'int']\",\n+                new Integer(1));\n+\n+        assertXPathPointer(context,\n+                \"nestedBean[@name = 'int']\",\n+                \"/nestedBean/int\");\n+    }\n+\n+    public void testAttributeLang(){\n+\n+        assertXPathValue(context,\n+                \"@xml:lang\",\n+                \"en-US\");\n+\n+        assertXPathValue(context,\n+                \"count(@xml:*)\",\n+                new Double(1));\n+\n+        assertXPathValue(context,\"lang('en')\", Boolean.TRUE);\n+        assertXPathValue(context,\"lang('fr')\", Boolean.FALSE);\n+        assertXPathValueIterator(context, \"beans[1]/strings[string-length() = 8]\", list(\"String 1\", \"String 2\", \"String 3\"));\n+        assertXPathValue(context,\"boolean(boolean)\", Boolean.FALSE);\n+        assertXPathValue(context,\"boolean(integers[position() < 3])\", Boolean.TRUE);\n+        assertXPathValue(context,\"boolean(integers[position() > 4])\", Boolean.FALSE);\n+        assertXPathValue(context,\"sum(integers)\", new Double(10));\n+    }\n+\n+    public void testBooleanPredicate(){\n+        // use child axis\n+        assertXPathValue(context,\n+                \"beans[int > 2]/name\",\n+                \"Name 2\");\n+\n+        // use some fancy axis and the child axis in the predicate\n+        assertXPathValueIterator(context,\n+                \"//self::node()[name = 'Name 0']/name\",\n+                list(\"Name 0\"));\n+\n+        // use context-dependent function in the predicate\n+        assertXPathValue(context,\n+                \"beans/strings[name(.)='strings'][2]\",\n+                \"String 2\");\n+\n+        // use context-independent function in the predicate\n+        assertXPathValueIterator(context,\n+                \"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n+                list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n+                     \"Name 0\", \"Name 5\", \"Name 4\"));\n+\n+        assertXPathValueIterator(context,\n+                \"integers[position()<3]\",\n+                list(new Integer(1), new Integer(2)));\n+    }\n+\n+    public void testDocumentOrder(){\n+        assertDocumentOrder(context,\n+                \"boolean\", \"int\", -1);\n+\n+        assertDocumentOrder(context,\n+                \"integers[1]\", \"integers[2]\", -1);\n+\n+        assertDocumentOrder(context,\n+                \"integers[1]\", \"integers[1]\", 0);\n+\n+        assertDocumentOrder(context,\n+                \"nestedBean/int\", \"nestedBean\", 1);\n+\n+        assertDocumentOrder(context,\n+                \"nestedBean/int\", \"nestedBean/strings\", -1);\n+\n+        assertDocumentOrder(context,\n+                \"nestedBean/int\", \"object/int\", -1);\n+    }\n+\n+    public void testSetPropertyValue(){\n+        // Simple property\n+        assertXPathSetValue(context,\n+                \"int\",\n+                new Integer(2));\n+\n+        // Simple property with conversion from string\n+        assertXPathSetValue(context,\n+                \"int\",\n+                \"3\",\n+                new Integer(3));\n+\n+        // Simple property with conversion from array\n+        assertXPathSetValue(context,\n+                \"int\",\n+                new int[]{4},\n+                new Integer(4));\n+\n+        // Attribute (which is the same as a child for beans\n+        assertXPathSetValue(context,\n+                \"@int\",\n+                new Integer(10));\n+    }\n+\n+    public void testSetCollectionElement(){\n+        // Collection element\n+        assertXPathSetValue(context,\n+                \"integers[2]\",\n+                new Integer(5));\n+\n+        // Collection element with conversion\n+        assertXPathSetValue(context,\n+                \"integers[2]\",\n+                new int[]{6},\n+                new Integer(6));\n+    }\n+\n+    public void testSetContextDependentNode(){\n+        // Find node without using SimplePathInterpreter\n+        assertXPathSetValue(context,\n+                \"integers[position() = 1]\",\n+                new Integer(8));\n+\n+        // Find node without using SimplePathInterpreter and set its property\n+        assertXPathSetValue(context,\n+                \"beans[name = 'Name 1']/int\",\n+                new Integer(9));\n+\n+    }\n+\n+    public void testSetNonPrimitiveValue(){\n+        // First, let's see if we can set a collection element to null\n+        assertXPathSetValue(context,\n+                \"beans[2]\",\n+                null);\n+\n+        // Now, assign it a whole bean\n+        context.setValue(\"beans[2]\", new NestedTestBean(\"Name 9\"));\n+\n+        assertEquals(\"Modified <\" + \"beans[2]/name\" + \">\",\n+            \"Name 9\", context.getValue(\"beans[2]/name\"));\n+    }\n+\n+    public void testCreatePath(){\n+        context.setValue(\"nestedBean\", null);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        assertXPathCreatePath(context,\n+                \"/nestedBean/int\",\n+                new Integer(1),\n+                \"/nestedBean/int\");\n+    }\n+\n+    public void testCreatePathAndSetValue(){\n+        context.setValue(\"nestedBean\", null);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        assertXPathCreatePathAndSetValue(context,\n+                \"/nestedBean/int\",\n+                new Integer(2),\n+                \"/nestedBean/int\");\n+    }\n+\n+    public void testCreatePathExpandNewCollection(){\n+        context.setValue(\"beans\", null);\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        assertXPathCreatePath(context,\n+                \"/beans[2]/int\",\n+                new Integer(1),\n+                \"/beans[2]/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueExpandNewCollection(){\n+        context.setValue(\"beans\", null);\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        assertXPathCreatePathAndSetValue(context,\n+                \"/beans[2]/int\",\n+                new Integer(2),\n+                \"/beans[2]/int\");\n+    }\n+\n+    public void testCreatePathExpandExistingCollection(){\n+        // Another, but the collection already exists\n+        assertXPathCreatePath(context,\n+                \"/beans[3]/int\",\n+                new Integer(1),\n+                \"/beans[3]/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueExpandExistingCollection(){\n+        // Another, but the collection already exists\n+        assertXPathCreatePathAndSetValue(context,\n+                \"/beans[3]/int\",\n+                new Integer(2),\n+                \"/beans[3]/int\");\n+    }\n+\n+    public void testCreatePathCreateBeanExpandCollection(){\n+        context.setValue(\"nestedBean\", null);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        // Calls factory.expandCollection(..., nestedBean, \"strings\", 2)\n+        assertXPathCreatePath(context,\n+                \"/nestedBean/strings[2]\",\n+                \"String 2\",\n+                \"/nestedBean/strings[2]\");\n+    }\n+\n+    public void testCreatePathAndSetValueCreateBeanExpandCollection(){\n+        context.setValue(\"nestedBean\", null);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        // Calls factory.expandCollection(..., nestedBean, \"strings\", 2)\n+        assertXPathCreatePathAndSetValue(context,\n+                \"/nestedBean/strings[2]\",\n+                \"Test\",\n+                \"/nestedBean/strings[2]\");\n+    }\n+\n+    public void testRemovePathPropertyValue(){\n+        // Remove property value\n+        context.removePath(\"nestedBean/int\");\n+        assertEquals(\"Remove property value\", new Integer(0),\n+                    context.getValue(\"nestedBean/int\"));\n+    }\n+\n+    public void testRemovePathArrayElement(){\n+        // Assigns a new array to the property\n+        context.removePath(\"nestedBean/strings[1]\");\n+        assertEquals(\"Remove array element\", \"String 2\",\n+                    context.getValue(\"nestedBean/strings[1]\"));\n+    }\n+\n+    public void testRemovePathBeanValue(){\n+        context.removePath(\"nestedBean\");\n+        assertEquals(\"Remove collection element\", null,\n+                    context.getValue(\"nestedBean\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.TestMixedModelBean;\n+import org.apache.commons.jxpath.TestNull;\n+import org.apache.commons.jxpath.Variables;\n+\n+/**\n+ * Tests JXPath with mixed model: beans, maps, DOM etc.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class MixedModelTest extends JXPathTestCase\n+{\n+    private static final boolean enabled = true;\n+\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public MixedModelTest(String name){\n+        super(name);\n+    }\n+\n+    /**\n+     * Return the tests included in this test suite.\n+     */\n+    public static Test suite(){\n+        return (new TestSuite(MixedModelTest.class));\n+    }\n+\n+    public void setUp(){\n+        TestMixedModelBean bean = new TestMixedModelBean();\n+        context = JXPathContext.newContext(bean);\n+        context.setFactory(new TestMixedModelFactory());\n+        context.setLocale(Locale.US);\n+        Variables vars = context.getVariables();\n+        vars.declareVariable(\"string\", bean.getString());\n+        vars.declareVariable(\"bean\", bean.getBean());\n+        vars.declareVariable(\"map\", bean.getMap());\n+        vars.declareVariable(\"list\", bean.getList());\n+        vars.declareVariable(\"document\", bean.getDocument());\n+        vars.declareVariable(\"element\", bean.getElement());\n+        vars.declareVariable(\"container\", bean.getContainer());\n+        \n+        vars.declareVariable(\"testnull\", new TestNull());\n+    }\n+\n+    public void testVarPrimitive(){\n+        assertXPathValueAndPointer(context,\n+                \"$string\",\n+                \"string\",\n+                \"$string\");\n+    }\n+\n+    public void testVarBean(){\n+        assertXPathValueAndPointer(context,\n+                \"$bean/int\",\n+                new Integer(1),\n+                \"$bean/int\");\n+    }\n+\n+    public void testVarMap(){\n+        assertXPathValueAndPointer(context,\n+                \"$map/string\",\n+                \"string\",\n+                \"$map[@name='string']\");\n+    }\n+\n+    public void testVarList(){\n+        assertXPathValueAndPointer(context,\n+                \"$list[1]\",\n+                \"string\",\n+                \"$list[1]\");\n+    }\n+\n+    public void testVarDocument(){\n+        assertXPathValueAndPointer(context,\n+                \"$document/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"$document/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testVarElement(){\n+        assertXPathValueAndPointer(context,\n+                \"$element/location/address/city\",\n+                \"Fruit Market\",\n+                \"$element/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testVarContainer(){\n+        assertXPathValueAndPointer(context,\n+                \"$container/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"$container/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+\n+    // ----------------------------------------------------------------------\n+\n+    public void testBeanPrimitive(){\n+        assertXPathValueAndPointer(context,\n+                \"string\",\n+                \"string\",\n+                \"/string\");\n+    }\n+\n+    public void testBeanBean(){\n+        assertXPathValueAndPointer(context,\n+                \"bean/int\",\n+                new Integer(1),\n+                \"/bean/int\");\n+    }\n+\n+    public void testBeanMap(){\n+        assertXPathValueAndPointer(context,\n+                \"map/string\",\n+                \"string\",\n+                \"/map[@name='string']\");\n+    }\n+\n+    public void testBeanList(){\n+        assertXPathValueAndPointer(context,\n+                \"list[1]\",\n+                \"string\",\n+                \"/list[1]\");\n+    }\n+\n+    public void testBeanDocument(){\n+        assertXPathValueAndPointer(context,\n+                \"document/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/document/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testBeanElement(){\n+        assertXPathValueAndPointer(context,\n+                \"element/location/address/city\",\n+                \"Fruit Market\",\n+                \"/element/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testBeanContainer(){\n+        assertXPathValueAndPointer(context,\n+                \"container/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/container/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    // ----------------------------------------------------------------------\n+\n+    public void testMapPrimitive(){\n+        assertXPathValueAndPointer(context,\n+                \"map/string\",\n+                \"string\",\n+                \"/map[@name='string']\");\n+    }\n+\n+    public void testMapBean(){\n+        assertXPathValueAndPointer(context,\n+                \"map/bean/int\",\n+                new Integer(1),\n+                \"/map[@name='bean']/int\");\n+    }\n+\n+    public void testMapMap(){\n+        assertXPathValueAndPointer(context,\n+                \"map/map/string\",\n+                \"string\",\n+                \"/map[@name='map'][@name='string']\");\n+    }\n+\n+    public void testMapList(){\n+        assertXPathValueAndPointer(context,\n+                \"map/list[1]\",\n+                \"string\",\n+                \"/map[@name='list'][1]\");\n+    }\n+\n+    public void testMapDocument(){\n+        assertXPathValueAndPointer(context,\n+                \"map/document/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/map[@name='document']\" +\n+                        \"/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testMapElement(){\n+        assertXPathValueAndPointer(context,\n+                \"map/element/location/address/city\",\n+                \"Fruit Market\",\n+                \"/map[@name='element']/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testMapContainer(){\n+        assertXPathValueAndPointer(context,\n+                \"map/container/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/map[@name='container']\" +\n+                        \"/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    // ----------------------------------------------------------------------\n+\n+    public void testListPrimitive(){\n+        assertXPathValueAndPointer(context,\n+                \"list[1]\",\n+                \"string\",\n+                \"/list[1]\");\n+    }\n+\n+    public void testListBean(){\n+        assertXPathValueAndPointer(context,\n+                \"list[2]/int\",\n+                new Integer(1),\n+                \"/list[2]/int\");\n+    }\n+\n+    public void testListMap(){\n+        assertXPathValueAndPointer(context,\n+                \"list[3]/string\",\n+                \"string\",\n+                \"/list[3][@name='string']\");\n+    }\n+\n+    public void testListList(){\n+        /** @todo: what is this supposed to do? Should we stick to XPath,\n+         *  in which case [1] is simply ignored, or Java, in which case\n+         *  it is supposed to extract the first element from the list?\n+         */\n+//        assertXPathValueAndPointer(context,\n+//                \"list[4][1]\",\n+//                \"string2\",\n+//                \"/list[4][1]\");\n+\n+        assertXPathValueAndPointer(context,\n+                \"list[4]/.[1]\",\n+                \"string2\",\n+                \"/list[4]/.[1]\");\n+    }\n+\n+    public void testListDocument(){\n+        assertXPathValueAndPointer(context,\n+                \"list[5]/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/list[5]/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testListElement(){\n+        assertXPathValueAndPointer(context,\n+                \"list[6]/location/address/city\",\n+                \"Fruit Market\",\n+                \"/list[6]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testListContainer(){\n+        assertXPathValueAndPointer(context,\n+                \"list[7]/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/list[7]/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testNull(){\n+\n+        assertXPathPointerLenient(context, \n+                \"$null\", \n+                \"$null\");\n+                \n+        assertXPathPointerLenient(context, \n+                \"$null[3]\", \n+                \"$null[3]\");\n+                \n+        assertXPathPointerLenient(context, \n+                \"$testnull/nothing\", \n+                \"$testnull/nothing\");\n+                \n+        assertXPathPointerLenient(context, \n+                \"$testnull/nothing[2]\", \n+                \"$testnull/nothing[2]\");\n+        \n+        assertXPathPointerLenient(context, \n+                \"beans[8]/int\", \n+                \"/beans[8]/int\");\n+        \n+        assertXPathValueIterator(context, \n+                \"$testnull/nothing[1]\", \n+                Collections.EMPTY_LIST);\n+                \n+        JXPathContext ctx = JXPathContext.newContext(new TestNull());\n+        assertXPathValue(ctx, \n+                \"nothing\", \n+                null);\n+                \n+        assertXPathValue(ctx, \n+                \"child/nothing\", \n+                null);\n+                \n+        assertXPathValue(ctx, \n+                \"array[2]\", \n+                null);\n+                \n+        assertXPathValueLenient(ctx, \n+                \"nothing/something\", \n+                null);\n+                \n+        assertXPathValueLenient(ctx, \n+                \"array[2]/something\", \n+                null);\n+    }\n+    \n+    public void testRootAsCollection(){\n+        assertXPathValue(context, \n+                \".[1]/string\",\n+                \"string\");\n+    }\n+    \n+    public void testCreatePath(){\n+        context = JXPathContext.newContext(new TestBean());\n+        context.setFactory(new TestMixedModelFactory());\n+        \n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey5']/nestedBean/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey5']/nestedBean/int\");\n+                \n+        bean.setMap(null);\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey5']/beans[2]/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey5']/beans[2]/int\");\n+    }\n+    \n+    /**\n+     * Test JXPath.iterate() with map containing an array\n+     */\n+    public void testIterateArray(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+\n+        assertXPathValueIterator(context,\n+            \"foo\",\n+            list(\"a\", \"b\", \"c\"));\n+    }\n+\n+    public void testIteratePointersArray(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+\n+        Iterator it = context.iteratePointers(\"foo\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            Pointer ptr = (Pointer)it.next();\n+            actual.add(context.getValue(ptr.asPath()));\n+        }\n+        assertEquals(\"Iterating pointers <\" + \"foo\" + \">\",\n+                list(\"a\", \"b\", \"c\"), actual);\n+    }\n+\n+    public void testIteratePointersArrayElementWithVariable(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+        context.getVariables().declareVariable(\"x\", new Integer(2));\n+        Iterator it = context.iteratePointers(\"foo[$x]\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            Pointer ptr = (Pointer)it.next();\n+            actual.add(context.getValue(ptr.asPath()));\n+        }\n+        assertEquals(\"Iterating pointers <\" + \"foo\" + \">\", list(\"b\"), actual);\n+    }\n+\n+    public void testIterateVector(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        Vector vec = new Vector();\n+        vec.add(new HashMap());\n+        vec.add(new HashMap());\n+\n+        map.put(\"vec\", vec);\n+        JXPathContext context = JXPathContext.newContext(map);\n+        assertXPathPointerIterator(context,\n+            \"/vec\",\n+            list(\"/.[@name='vec'][1]\", \"/.[@name='vec'][2]\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestDynamicPropertyFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/Attic/TestDynamicPropertyFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.jdom.Element;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestDynamicPropertyFactory extends AbstractFactory {\n+\n+    /**\n+     * Create a new instance and put it in the collection on the parent object.\n+     * Return <b>false</b> if this factory cannot create the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        if (name.equals(\"map\")){\n+            ((TestBean)parent).setMap(new HashMap());\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey1\")){\n+            ((Map)parent).put(name, \"\");\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey2\")){\n+            ((Map)parent).put(name, new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey3\")){\n+            Vector v = new Vector();\n+            for (int i = 0; i <= index; i++){\n+                v.add(null);\n+            }\n+            ((Map)parent).put(name, v);\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey4\")){\n+            ((Map)parent).put(name, new Object[]{new TestBean()});\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.jdom.Element;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestMixedModelFactory extends AbstractFactory {\n+\n+    /**\n+     * Create a new instance and put it in the collection on the parent object.\n+     * Return <b>false</b> if this factory cannot create the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        if (name.equals(\"nestedBean\")){\n+            ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"beans\")){\n+            TestBean bean = (TestBean)parent;\n+            if (bean.getBeans() == null || index >= bean.getBeans().length){\n+                bean.setBeans(new NestedTestBean[index + 1]);\n+            }\n+            ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        else if (name.equals(\"map\")){\n+            ((TestBean)parent).setMap(new HashMap());\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey5\")){\n+            TestBean tb = new TestBean();\n+            tb.setNestedBean(null);\n+            tb.setBeans(null);\n+            ((Map)parent).put(name, tb);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.1 2002/10/13 03:01:03 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/13 03:01:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.2 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/10/20 03:48:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-import org.w3c.dom.*;\n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n-import java.beans.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.IdentityManager;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.Variables;\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n \n /**\n  * Abstract superclass for pure XPath 1.0.  Subclasses\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/13 03:01:03 $\n+ * @version $Revision: 1.2 $ $Date: 2002/10/20 03:48:22 $\n  */\n \n-public abstract class XMLModelTestCase extends TestCase\n+public abstract class XMLModelTestCase extends JXPathTestCase\n {\n-    private boolean enabled = true;\n+    private JXPathContext context;\n \n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public XMLModelTestCase(String name)\n-    {\n+    public XMLModelTestCase(String name){\n         super(name);\n     }\n \n+    public void setUp(){\n+        if (context == null){\n+            DocumentContainer docCtr = createDocumentContainer();\n+            context = createContext();\n+            Variables vars = context.getVariables();\n+            vars.declareVariable(\"document\", docCtr.getValue());\n+            vars.declareVariable(\"container\", docCtr);\n+        }\n+    }\n \n     protected abstract String getModel();\n \n     protected DocumentContainer createDocumentContainer(){\n         return new DocumentContainer(\n-                getClass().getClassLoader().\n-                        getResource(\"org/apache/commons/jxpath/Vendor.xml\"),\n+                JXPathTestCase.class.getResource(\"Vendor.xml\"),\n                 getModel());\n     }\n+    \n+    protected abstract AbstractFactory getAbstractFactory();\n \n     protected JXPathContext createContext(){\n         JXPathContext context =\n                 JXPathContext.newContext(createDocumentContainer());\n-        context.setFactory(new TestFactory());\n+        context.setFactory(getAbstractFactory());\n         return context;\n     }\n \n+\t/**\n+\t * An XML signature is used to determine if we have the right result\n+\t * after a modification of XML by JXPath.  It is basically a piece\n+\t * of simplified XML.\n+\t */    \n+    protected abstract String getXMLSignature(Object node, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi);\n+\n+\tprotected void assertXMLSignature(JXPathContext context,\n+\t\t\tString path, String signature,\n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n+\t{\n+\t\tObject node = context.getPointer(path).getNode();\n+\t\tString sig = getXMLSignature(node, elements, attributes, text, pi);\n+\t\tassertEquals(\"XML Signature mismatch: \", signature, sig);\n+\t}\n+\t\n     // ------------------------------------------------ Individual Test Methods\n \n     public void testDocumentOrder(){\n-        if (!enabled){\n-            return;\n-        }\n-\n-        JXPathContext context = createContext();\n-        testDocumentOrder(context, \"vendor/location\", \"vendor/location/address/street\", -1);\n-        testDocumentOrder(context, \"vendor/location[@id = '100']\", \"vendor/location[@id = '101']\", -1);\n-        testDocumentOrder(context, \"vendor//price:amount\", \"vendor/location\", 1);\n-    }\n-\n-    private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n-        NodePointer np1 = (NodePointer)context.getPointer(path1);\n-        NodePointer np2 = (NodePointer)context.getPointer(path2);\n-        try {\n-            int res = np1.compareTo(np2);\n-            if (res < 0){\n-                res = -1;\n-            }\n-            else if (res > 0){\n-                res = 1;\n-            }\n-            assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n-        }\n-        catch (Exception ex){\n-            System.err.println(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\");\n-            ex.printStackTrace();\n-        }\n-    }\n-\n+        assertDocumentOrder(context, \n+                \"vendor/location\", \n+                \"vendor/location/address/street\", \n+                -1);\n+                \n+        assertDocumentOrder(context, \n+                \"vendor/location[@id = '100']\", \n+                \"vendor/location[@id = '101']\", \n+                -1);\n+                \n+        assertDocumentOrder(context, \n+                \"vendor//price:amount\", \n+                \"vendor/location\", \n+                1);\n+    }\n+\n+\tpublic void testSetValue(){\n+\t\tassertXPathSetValue(context,\n+\t\t\t\t\"vendor/location[@id = '100']\",\n+\t\t\t\t\"New Text\");\n+\t\t\n+\t\tassertXMLSignature(context,\n+\t\t\t\t\"vendor/location[@id = '100']\",\n+\t\t\t\t\"<E>New Text</E>\",\n+\t\t\t\tfalse, false, true, false);\n+\t\t\t\t\n+\t\tassertXPathSetValue(context,\n+\t\t\t\t\"vendor/location[@id = '101']\",\n+\t\t\t\t\"Replacement Text\");\n+\n+\t\tassertXMLSignature(context,\n+\t\t\t\t\"vendor/location[@id = '101']\",\n+\t\t\t\t\"<E>Replacement Text</E>\",\n+\t\t\t\tfalse, false, true, false);\t\t\t\t\n+\t}\n+\t\n     /**\n      * Test JXPathContext.createPath() with various arguments\n      */\n     public void testCreatePath(){\n-        if (!enabled){\n-            return;\n-        }\n-\n-        JXPathContext context = createContext();\n-\n         // Create a DOM element\n-        testCreatePath(context, \"/vendor[1]/location[3]\", \"\");\n+        assertXPathCreatePath(context, \n+                \"/vendor[1]/location[3]\", \n+                \"\",\n+                \"/vendor[1]/location[3]\");\n \n         // Create a DOM element with contents\n-        testCreatePath(context, \"/vendor[1]/location[3]/address/street\", \"\",\n+        assertXPathCreatePath(context, \n+                \"/vendor[1]/location[3]/address/street\", \n+                \"\",\n                 \"/vendor[1]/location[3]/address[1]/street[1]\");\n \n         // Create a DOM attribute\n-        testCreatePath(context, \"/vendor[1]/location[2]/@manager\", \"\");\n-        testCreatePath(context, \"/vendor[1]/location[1]/@name\", \"local\");\n-    }\n-\n-    private void testCreatePath(JXPathContext context, String path, Object value){\n-        testCreatePath(context, path, value, path);\n-    }\n-\n-    private void testCreatePath(JXPathContext context, String path,\n-                Object value, String expectedPath){\n-        Pointer ptr = null;\n-        try {\n-            ptr = context.createPath(path);\n-        }\n-        catch(JXPathException ex){\n-            ex.getException().printStackTrace();\n-        }\n-\n-        assertEquals(\"Pointer <\" + path + \">\", expectedPath, ptr.asPath());\n-        assertEquals(\"Created <\" + path + \">\", value, ptr.getValue());\n+        assertXPathCreatePath(context, \n+                \"/vendor[1]/location[2]/@manager\", \n+                \"\",\n+                \"/vendor[1]/location[2]/@manager\");\n+\n+        assertXPathCreatePath(context, \n+                \"/vendor[1]/location[1]/@name\", \n+                \"local\",\n+                \"/vendor[1]/location[1]/@name\");\n     }\n \n \n      * Test JXPath.createPathAndSetValue() with various arguments\n      */\n     public void testCreatePathAndSetValue(){\n-        if (!enabled){\n-            return;\n-        }\n-        JXPathContext context = createContext();\n-\n         // Create a XML element\n-        testCreatePathAndSetValue(context, \"vendor/location[3]\", \"\");\n+        assertXPathCreatePathAndSetValue(context, \n+                \"vendor/location[3]\", \n+                \"\",\n+                \"/vendor[1]/location[3]\");\n \n         // Create a DOM element with contents\n-        testCreatePathAndSetValue(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n+        assertXPathCreatePathAndSetValue(context, \n+                \"vendor/location[3]/address/street\", \n+                \"Lemon Circle\",\n+                \"/vendor[1]/location[3]/address[1]/street[1]\");\n \n         // Create an attribute\n-        testCreatePathAndSetValue(context, \"vendor/location[2]/@manager\", \"John Doe\");\n-        testCreatePathAndSetValue(context, \"vendor/location[1]/@manager\", \"John Doe\");\n-\n-        testCreatePathAndSetValue(context, \"vendor/product/name/attribute::price:language\", \"English\");\n-    }\n-\n-    private void testCreatePathAndSetValue(JXPathContext context, String path, Object value){\n-        Pointer ptr = context.createPathAndSetValue(path, value);\n-        assertTrue(\"Pointer <\" + path + \">\", ptr != null);\n-        assertEquals(\"Created <\" + path + \">\", value, context.getValue(path));\n-        assertEquals(\"Pointer value <\" + path + \">\", value, ptr.getValue());\n+        assertXPathCreatePathAndSetValue(context, \n+                \"vendor/location[2]/@manager\", \n+                \"John Doe\",\n+                \"/vendor[1]/location[2]/@manager\");\n+                \n+        assertXPathCreatePathAndSetValue(context,\n+                \"vendor/location[1]/@manager\", \n+                \"John Doe\",\n+                \"/vendor[1]/location[1]/@manager\");\n+\n+        assertXPathCreatePathAndSetValue(context, \n+                \"vendor/product/name/attribute::price:language\", \n+                \"English\",\n+                \"/vendor[1]/product[1]/name[1]/@price:language\");\n     }\n \n     /**\n      * Test JXPathContext.removePath() with various arguments\n      */\n     public void testRemovePath(){\n-        if (!enabled){\n-            return;\n-        }\n-        JXPathContext context = createContext();\n-\n         // Remove XML nodes\n         context.removePath(\"vendor/location[@id = '101']//street/text()\");\n         assertEquals(\"Remove DOM text\", \"\",\n     }\n \n     public void testID(){\n-        if (!enabled){\n-            return;\n-        }\n-        JXPathContext context = createContext();\n         context.setIdentityManager(new IdentityManager(){\n             public Pointer getPointerByID(JXPathContext context, String id){\n                 NodePointer ptr = (NodePointer)context.getPointer(\"/\");\n                 return ptr.getPointerByID(context, id);\n             }\n         });\n-        context.setKeyManager(new KeyManager(){\n-            public Pointer getPointerByKey(JXPathContext context,\n-                                            String key, String value){\n-                return NodePointer.newNodePointer(null, \"42\", null);\n-            }\n-        });\n-        assertEquals(\"Test ID\", \"Tangerine Drive\",\n-            context.getValue(\"id(101)//street\"));\n-        assertEquals(\"Test ID Path\", \"id('101')/address[1]/street[1]\",\n-            context.getPointer(\"id(101)//street\").asPath());\n-\n-        context.setLenient(true);\n-        assertEquals(\"Test ID Path Null\", \"id(105)/address/street\",\n-            context.getPointer(\"id(105)/address/street\").asPath());\n-    }\n-\n-    public void testModel() throws Exception {\n-        if (!enabled){\n-            return;\n-        }\n-\n-        DocumentContainer docCtr = createDocumentContainer();\n-        JXPathContext context = createContext();\n-        context.getVariables().declareVariable(\"document\", docCtr.getValue());\n-        context.getVariables().declareVariable(\"container\", docCtr);\n-        testXPaths(context, dom_tests, false);\n-    }\n-\n-    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath) throws Exception{\n-        Exception exception = null;\n-        for  (int i=0; i < xpath_tests.length; i++) {\n-            try {\n-                Object actual;\n-                // System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n-                if (xpath_tests[i].path){\n-                    if (ignorePath){\n-                        actual = xpath_tests[i].expected;\n-                    }\n-                    else {\n-                        if (xpath_tests[i].eval){\n-                            Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n-                            List paths = new ArrayList();\n-                            while (it.hasNext()){\n-                                paths.add(((Pointer)it.next()).asPath());\n-                            }\n-                            actual = paths;\n-                        }\n-                        else {\n-                            ctx.setLenient(xpath_tests[i].lenient);\n-                            actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n-                        }\n-                    }\n-                }\n-                else {\n-                    if (xpath_tests[i].eval){\n-                        ArrayList list = new ArrayList();\n-                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n-                        while (it.hasNext()){\n-                            list.add(it.next());\n-                        }\n-                        actual = list;\n-                    }\n-                    else {\n-                        ctx.setLenient(xpath_tests[i].lenient);\n-                        actual = ctx.getValue(xpath_tests[i].xpath);\n-                        ctx.setLenient(false);\n-                    }\n-                }\n-                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\", xpath_tests[i].expected, actual);\n-            }\n-            catch (Exception ex){\n-                System.err.println(\"Exception during <\" + xpath_tests[i].xpath + \">\");\n-                ex.printStackTrace();\n-                exception = ex;\n-            }\n-            if (exception != null){\n-                throw exception;\n-            }\n-        }\n-\n-        // Make sure that location paths are properly constructed\n-        for (int i=0; i < xpath_tests.length; i++) {\n-            try {\n-                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n-                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n-                    Pointer test = ctx.getPointer(ptr.asPath());\n-                    assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n-                }\n-            }\n-            catch (Exception ex){\n-                System.err.println(\"Exception during pointer test <\" + xpath_tests[i].xpath + \">\");\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    private static class XP {\n-        public String xpath;\n-        public Object expected;\n-        public boolean eval;\n-        public boolean path;\n-        public boolean lenient;\n-\n-        public XP(String xpath,  Object expected, boolean eval, boolean path, boolean lenient){\n-            this.xpath = xpath;\n-            this.expected = expected;\n-            this.eval = eval;\n-            this.path = path;\n-            this.lenient = lenient;\n-        }\n-    }\n-\n-    private static XP test(String xpath, Object expected){\n-        return new XP(xpath, expected, false, false, false);\n-    }\n-\n-    private static XP testLenient(String xpath, Object expected){\n-        return new XP(xpath, expected, false, false, true);\n-    }\n-\n-    private static XP testEval(String xpath, Object expected){\n-        return new XP(xpath, expected, true, false, false);\n-    }\n-\n-    private static XP testPath(String xpath, Object expected){\n-        return new XP(xpath, expected, false, true, true);\n-    }\n-\n-    private static XP testEvalPath(String xpath, Object expected){\n-        return new XP(xpath, expected, true, true, false);\n-    }\n-\n-    private static List list(Object o1){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        return list;\n-    }\n-\n-    private static List list(Object o1, Object o2){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        list.add(o2);\n-        return list;\n-    }\n-\n-\n-    static final XP[] dom_tests = new XP[]{\n-        test(\"vendor/location/address/street\", \"Orchard Road\"),\n-        test(\"vendor/location[2]/address/street\", \"Tangerine Drive\"),\n-        test(\"vendor/location/address/city\", \"Fruit Market\"),\n-        test(\"//street\", \"Orchard Road\"),\n-        test(\"local-name(//street/..)\", \"address\"),\n-        test(\"number(vendor/location/employeeCount)\", new Double(10)),\n-        test(\"vendor/location/employeeCount + 1\", new Double(11)),\n-        test(\"vendor/location/employeeCount and true()\", Boolean.TRUE),\n-        test(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\", \"Tangerine Drive\"),\n-        testPath(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\",\n-                \"/vendor[1]/location[2]/address[1]/street[1]\"),\n-        testPath(\"//location[2]/preceding-sibling::location//street\",\n-                \"/vendor[1]/location[1]/address[1]/street[1]\"),\n-        test(\"vendor/location/@id\", \"100\"),\n-        testPath(\"vendor/location/@id\", \"/vendor[1]/location[1]/@id\"),\n-        testEval(\"vendor/location/@id\", list(\"100\", \"101\")),\n-        test(\"vendor/product/price:amount\", \"45.95\"),\n-        test(\"namespace-uri(vendor/product/price:amount)\", \"priceNS\"),\n-        test(\"local-name(vendor/product/price:amount)\", \"amount\"),\n-        test(\"name(vendor/product/price:amount)\", \"priceNS:amount\"),\n-        test(\"vendor/product/prix\", \"934.99\"),\n-        test(\"vendor/product/prix/namespace::price\", \"priceNS\"),\n-        testPath(\"vendor/product/prix/namespace::price\", \"/vendor[1]/product[1]/prix[1]/namespace::price\"),\n-        test(\"count(vendor/product/namespace::*)\", new Double(3)),\n-        test(\"name(vendor/product/prix/namespace::price)\", \"priceNS:price\"),\n-        test(\"local-name(vendor/product/prix/namespace::price)\", \"price\"),\n-        test(\"vendor/product/price:amount/@price:discount\", \"10%\"),\n-        test(\"vendor/product/value:amount/@value:discount\", \"10%\"),\n-        test(\"namespace-uri(vendor/product/price:amount/@price:discount)\", \"priceNS\"),\n-        test(\"local-name(vendor/product/price:amount/@price:discount)\", \"discount\"),\n-        test(\"name(vendor/product/price:amount/@price:discount)\", \"priceNS:discount\"),\n-        test(\"vendor/product/price:amount/@discount\", \"20%\"),\n-        test(\"namespace-uri(vendor/product/price:amount/@discount)\", \"\"),\n-        test(\"local-name(vendor/product/price:amount/@discount)\", \"discount\"),\n-        test(\"name(vendor/product/price:amount/@discount)\", \"discount\"),\n-        test(\"vendor/product/price:sale/saleEnds/ancestor::price:sale/saleEnds\", \"never\"),\n-        test(\"vendor/product/price:sale/ancestor-or-self::price:sale/saleEnds\", \"never\"),\n-        test(\"vendor/product/price:sale/saleEnds/ancestor::price:*\" + \"/saleEnds\", \"never\"),\n-        test(\"count(vendor/product/price:*)\", new Double(2)),\n-        test(\"count(vendor/product/value:*)\", new Double(2)),\n-        test(\"count(vendor/product/*)\", new Double(2)),\n-        testEval(\"vendor/product/price:amount/@price:*\", list(\"10%\")),\n-        testEval(\"vendor/product/price:amount/@*\", list(\"20%\")),\n-        test(\"count(//price:*)\", new Double(2)),\n-        test(\"vendor/product/price:sale/saleEnds/parent::price:*\" + \"/saleEnds\", \"never\"),\n-        test(\"//location/following::price:sale/saleEnds\", \"never\"),\n-        test(\"//price:sale/self::price:sale/saleEnds\", \"never\"),\n-        testLenient(\"//price:sale/self::x/saleEnds\", null),\n-\n-        test(\"//product/comment()\", \"We are not buying this product, ever\"),\n-        test(\"//product/text()[. != '']\", \"We love this product.\"),\n-        testPath(\"//product/text()\", \"/vendor[1]/product[1]/text()[1]\"),\n-        test(\"//product/processing-instruction()\", \"do not show anybody\"),\n-        test(\"//product/processing-instruction('report')\", \"average only\"),\n-        testPath(\"//product/processing-instruction('report')\",\n-            \"/vendor[1]/product[1]/processing-instruction('report')[1]\"),\n-        test(\"name(//product/processing-instruction()[1])\", \"security\"),\n-\n-        test(\"//product/prix/@xml:lang\", \"fr\"),\n-        test(\"//product/prix[lang('fr')]\", \"934.99\"),\n-        test(\"//product/price:sale[lang('en')]/saleEnds\", \"never\"),\n-        test(\"vendor/location/@manager\", \"\"),\n-        testLenient(\"vendor/location/@missing\", null),\n-        test(\"count(vendor/location[1]/@*)\", new Double(3)),\n-        test(\"vendor/location[@id='101']//street\", \"Tangerine Drive\"),\n-\n-        test(\"$document/vendor/location[1]//street\", \"Orchard Road\"),\n-        testPath(\"$document/vendor/location[1]//street\",\n-            \"$document/vendor[1]/location[1]/address[1]/street[1]\"),\n-        test(\"$document/vendor//street\", \"Orchard Road\"),\n-        test(\"$container/vendor//street\", \"Orchard Road\"),\n-        test(\"$container//street\", \"Orchard Road\"),\n-        testPath(\"$container//street\", \"$container/vendor[1]/location[1]/address[1]/street[1]\"),\n-\n-        testEval(\"vendor/contact/following::location//street\",\n-            list(\"Orchard Road\", \"Tangerine Drive\")),\n-   };\n+\n+        assertXPathValueAndPointer(context,\n+                \"id(101)//street\",\n+                \"Tangerine Drive\",\n+                \"id('101')/address[1]/street[1]\");\n+\n+        assertXPathPointerLenient(context,\n+                \"id(105)/address/street\",\n+                \"id(105)/address/street\");\n+    }\n+\n+    public void testAxisChild() {\n+        assertXPathValue(context,\n+                \"vendor/location/address/street\",\n+                \"Orchard Road\");\n+\n+        // child:: - first child does not match, need to search\n+        assertXPathValue(context,\n+                \"vendor/location/address/city\",\n+                \"Fruit Market\");\n+        // local-name(qualified)\n+        assertXPathValue(context,\n+                \"local-name(vendor/product/price:amount)\",\n+                \"amount\");\n+\n+        // local-name(non-qualified)\n+        assertXPathValue(context,\n+                \"local-name(vendor/location)\",\n+                \"location\");\n+\n+        // name (qualified)\n+        assertXPathValue(context,\n+                \"name(vendor/product/price:amount)\",\n+                \"priceNS:amount\");\n+\n+        // name (non-qualified)\n+        assertXPathValue(context,\n+                \"name(vendor/location)\",\n+                \"location\");\n+\n+        // namespace-uri (qualified)\n+        assertXPathValue(context,\n+                \"namespace-uri(vendor/product/price:amount)\",\n+                \"priceNS\");\n+\n+        // default namespace does not affect search\n+        assertXPathValue(context,\n+                \"vendor/product/prix\",\n+                \"934.99\");\n+\n+        // child:: with a wildcard\n+        assertXPathValue(context,\n+                \"count(vendor/product/price:*)\",\n+                new Double(2));\n+\n+        // child:: with a namespace and wildcard\n+        assertXPathValue(context,\n+                \"count(vendor/product/value:*)\",\n+                new Double(2));\n+\n+        // child:: with the default namespace\n+        assertXPathValue(context,\n+                \"count(vendor/product/*)\",\n+                new Double(2));\n+\n+        // child:: with a qualified name\n+        assertXPathValue(context,\n+                \"vendor/product/price:amount\",\n+                \"45.95\");\n+    }\n+\n+    public void testAxisChildIndexPredicate() {\n+        assertXPathValue(context,\n+                \"vendor/location[2]/address/street\",\n+                \"Tangerine Drive\");\n+    }\n+\n+    public void testAxisDescendant() {\n+        // descendant::\n+        assertXPathValue(context,\n+                \"//street\",\n+                \"Orchard Road\");\n+\n+        // descendent:: with a namespace and wildcard\n+        assertXPathValue(context,\n+                \"count(//price:*)\",\n+                new Double(2));\n+    }\n+\n+    public void testAxisParent() {\n+        // parent::\n+        assertXPathPointer(context,\n+                \"//street/..\",\n+                \"/vendor[1]/location[1]/address[1]\");\n+\n+        // parent:: (note reverse document order)\n+        assertXPathPointerIterator(context,\n+                \"//street/..\",\n+                list(\"/vendor[1]/location[2]/address[1]\",\n+                     \"/vendor[1]/location[1]/address[1]\"));\n+\n+        // parent:: with a namespace and wildcard\n+        assertXPathValue(context,\n+                \"vendor/product/price:sale/saleEnds/parent::price:*\" +\n+                        \"/saleEnds\",\n+                \"never\");\n+    }\n+\n+    public void testAxisFollowingSibling() {\n+        // following-sibling::\n+        assertXPathValue(context,\n+                \"vendor/location[.//employeeCount = 10]/\" +\n+                        \"following-sibling::location//street\",\n+                \"Tangerine Drive\");\n+\n+        // following-sibling:: produces the correct pointer\n+        assertXPathPointer(context,\n+                \"vendor/location[.//employeeCount = 10]/\" +\n+                        \"following-sibling::location//street\",\n+                \"/vendor[1]/location[2]/address[1]/street[1]\");\n+    }\n+\n+    public void testAxisPrecedingSibling() {\n+        // preceding-sibling:: produces the correct pointer\n+        assertXPathPointer(context,\n+                \"//location[2]/preceding-sibling::location//street\",\n+                \"/vendor[1]/location[1]/address[1]/street[1]\");\n+    }\n+\n+    public void testAxisAttribute() {\n+        // attribute::\n+        assertXPathValue(context,\n+                \"vendor/location/@id\",\n+                \"100\");\n+\n+        // attribute:: produces the correct pointer\n+        assertXPathPointer(context,\n+                \"vendor/location/@id\",\n+                \"/vendor[1]/location[1]/@id\");\n+\n+        // iterate over attributes\n+        assertXPathValueIterator(context,\n+                \"vendor/location/@id\",\n+                list(\"100\", \"101\"));\n+\n+        // Using different prefixes for the same namespace\n+        assertXPathValue(context,\n+                \"vendor/product/price:amount/@price:discount\",\n+                \"10%\");\n+        assertXPathValue(context,\n+                \"vendor/product/value:amount/@value:discount\",\n+                \"10%\");\n+\n+        // namespace uri for an attribute\n+        assertXPathValue(context,\n+                \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n+                \"priceNS\");\n+\n+        // local name of an attribute\n+        assertXPathValue(context,\n+                \"local-name(vendor/product/price:amount/@price:discount)\",\n+                \"discount\");\n+\n+        // name for an attribute\n+        assertXPathValue(context,\n+                \"name(vendor/product/price:amount/@price:discount)\",\n+                \"priceNS:discount\");\n+\n+        // attribute:: with the default namespace\n+        assertXPathValue(context,\n+                \"vendor/product/price:amount/@discount\",\n+                \"20%\");\n+\n+        // namespace uri of an attribute with the default namespace\n+        assertXPathValue(context,\n+                \"namespace-uri(vendor/product/price:amount/@discount)\",\n+                \"\");\n+\n+        // local name of an attribute with the default namespace\n+        assertXPathValue(context,\n+                \"local-name(vendor/product/price:amount/@discount)\",\n+                \"discount\");\n+\n+        // name of an attribute with the default namespace\n+        assertXPathValue(context,\n+                \"name(vendor/product/price:amount/@discount)\",\n+                \"discount\");\n+\n+        // attribute:: with a namespace and wildcard\n+        assertXPathValueIterator(context,\n+                \"vendor/product/price:amount/@price:*\",\n+                list(\"10%\"));\n+\n+        // attribute:: with a wildcard\n+        assertXPathValueIterator(context,\n+                \"vendor/location[1]/@*\",\n+                set(\"100\", \"\", \"local\"));\n+\n+        // attribute:: with default namespace and wildcard\n+        assertXPathValueIterator(context,\n+                \"vendor/product/price:amount/@*\",\n+                list(\"20%\"));\n+\n+\n+        // Empty attribute\n+        assertXPathValue(context,\n+                \"vendor/location/@manager\",\n+                \"\");\n+\n+        // Missing attribute\n+        assertXPathValueLenient(context,\n+                \"vendor/location/@missing\",\n+                null);\n+\n+        // Using attribute in a predicate\n+        assertXPathValue(context,\n+                \"vendor/location[@id='101']//street\",\n+                \"Tangerine Drive\");\n+    }\n+\n+    public void testAxisNamespace() {\n+        // namespace::\n+        assertXPathValue(context,\n+                \"vendor/product/prix/namespace::price\",\n+                \"priceNS\");\n+\n+        // namespace:: pointer\n+        assertXPathPointer(context,\n+                \"vendor/product/prix/namespace::price\",\n+                \"/vendor[1]/product[1]/prix[1]/namespace::price\");\n+\n+        // namespace::*\n+        assertXPathValue(context,\n+                \"count(vendor/product/namespace::*)\",\n+                new Double(3));\n+\n+        // name of namespace\n+        assertXPathValue(context,\n+                \"name(vendor/product/prix/namespace::price)\",\n+                \"priceNS:price\");\n+\n+        // local name of namespace\n+        assertXPathValue(context,\n+                \"local-name(vendor/product/prix/namespace::price)\",\n+                \"price\");\n+    }\n+\n+    public void testAxisAncestor() {\n+        // ancestor::\n+        assertXPathValue(context,\n+                \"vendor/product/price:sale/saleEnds/\" +\n+                        \"ancestor::price:sale/saleEnds\",\n+                \"never\");\n+\n+        // ancestor:: with a wildcard\n+        assertXPathValue(context,\n+                \"vendor/product/price:sale/saleEnds/ancestor::price:*\" +\n+                        \"/saleEnds\",\n+                \"never\");\n+    }\n+\n+    public void testAxisAncestorOrSelf() {\n+        // ancestor-or-self::\n+        assertXPathValue(context,\n+                \"vendor/product/price:sale/\" +\n+                        \"ancestor-or-self::price:sale/saleEnds\",\n+                \"never\");\n+    }\n+\n+    public void testAxisFollowing() {\n+        assertXPathValueIterator(context,\n+                \"vendor/contact/following::location//street\",\n+                list(\"Orchard Road\", \"Tangerine Drive\"));\n+\n+        // following:: with a namespace\n+        assertXPathValue(context,\n+                \"//location/following::price:sale/saleEnds\",\n+                \"never\");\n+    }\n+\n+    public void testAxisSelf() {\n+        // self:: with a namespace\n+        assertXPathValue(context,\n+                \"//price:sale/self::price:sale/saleEnds\",\n+                \"never\");\n+\n+        // self:: with an unmatching name\n+        assertXPathValueLenient(context,\n+                \"//price:sale/self::x/saleEnds\",\n+                null);\n+    }\n+\n+    public void testNodeTypeComment() {\n+        // comment()\n+        assertXPathValue(context,\n+                \"//product/comment()\",\n+                \"We are not buying this product, ever\");\n+    }\n+\n+    public void testNodeTypeText() {\n+        // text()\n+        assertXPathValue(context,\n+                \"//product/text()[. != '']\",\n+                \"We love this product.\");\n+\n+        // text() pointer\n+        assertXPathPointer(context,\n+                \"//product/text()\",\n+                \"/vendor[1]/product[1]/text()[1]\");\n+\n+    }\n+\n+    public void testNodeTypeProcessingInstruction() {\n+        // processing-instruction() without an argument\n+        assertXPathValue(context,\n+                \"//product/processing-instruction()\",\n+                \"do not show anybody\");\n+\n+        // processing-instruction() with an argument\n+        assertXPathValue(context,\n+                \"//product/processing-instruction('report')\",\n+                \"average only\");\n+\n+        // processing-instruction() pointer without an argument\n+        assertXPathPointer(context,\n+                \"//product/processing-instruction('report')\",\n+                \"/vendor[1]/product[1]/processing-instruction('report')[1]\");\n+\n+        // processing-instruction name\n+        assertXPathValue(context,\n+                \"name(//product/processing-instruction()[1])\",\n+                \"security\");\n+    }\n+\n+    public void testLang() {\n+        // xml:lang built-in attribute\n+        assertXPathValue(context,\n+                \"//product/prix/@xml:lang\",\n+                \"fr\");\n+\n+        // lang() used the built-in xml:lang attribute\n+        assertXPathValue(context,\n+                \"//product/prix[lang('fr')]\",\n+                \"934.99\");\n+\n+        // Default language\n+        assertXPathValue(context,\n+                \"//product/price:sale[lang('en')]/saleEnds\",\n+                \"never\");\n+    }\n+\n+    public void testDocument() {\n+        assertXPathValue(context,\n+                \"$document/vendor/location[1]//street\",\n+                \"Orchard Road\");\n+\n+        assertXPathPointer(context,\n+                \"$document/vendor/location[1]//street\",\n+                \"$document/vendor[1]/location[1]/address[1]/street[1]\");\n+\n+        assertXPathValue(context,\n+                \"$document/vendor//street\",\n+                \"Orchard Road\");\n+\n+    }\n+\n+    public void testContainer() {\n+        assertXPathValue(context,\n+                \"$container/vendor//street\",\n+                \"Orchard Road\");\n+\n+        assertXPathValue(context,\n+                \"$container//street\",\n+                \"Orchard Road\");\n+\n+        assertXPathPointer(context,\n+                \"$container//street\",\n+                \"$container/vendor[1]/location[1]/address[1]/street[1]\");\n+\n+        // Conversion to number\n+        assertXPathValue(context,\n+                \"number(vendor/location/employeeCount)\",\n+                new Double(10));\n+    }\n+\n+    public void testTypeConversions() {\n+        // Implicit conversion to number\n+        assertXPathValue(context,\n+                \"vendor/location/employeeCount + 1\",\n+                new Double(11));\n+\n+        // Implicit conversion to boolean\n+        assertXPathValue(context,\n+                \"vendor/location/employeeCount and true()\",\n+                Boolean.TRUE);\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n+import java.beans.*;\n+\n+/**\n+ * Tests JXPath with JavaBeans\n+*\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class BeanModelTest extends BeanModelTestCase\n+{\n+    private static final boolean enabled = true;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public BeanModelTest(String name){\n+        super(name);\n+    }\n+\n+    /**\n+     * Return the tests included in this test suite.\n+     */\n+    public static TestSuite suite(){\n+//        return (new TestSuite(BeanModelTest.class));\n+        TestSuite s = new TestSuite();\n+        s.addTest(new BeanModelTest(\"testAxisParent\"));\n+        return s;\n+    }\n+\n+    protected Object createContextBean(){\n+        return new TestBean();\n+    }\n+\n+    protected AbstractFactory getAbstractFactory(){\n+        return new TestBeanFactory();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/DynamicPropertiesModelTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertiesModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n+import java.beans.*;\n+\n+/**\n+ * @todo more iterator testing with maps\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class DynamicPropertiesModelTest extends JXPathTestCase\n+{\n+    private static boolean enabled = true;\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public DynamicPropertiesModelTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(new TestBean());\n+            context.setFactory(new TestDynamicPropertyFactory());\n+        }\n+    }\n+\n+    public void testAxisChild(){\n+        assertXPathValue(context,\n+                \"map/Key1\",\n+                \"Value 1\");\n+\n+        assertXPathPointer(context,\n+                \"map/Key1\",\n+                \"/map[@name='Key1']\");\n+\n+        assertXPathValue(context,\n+                \"map/Key2/name\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"map/Key2/name\",\n+                \"/map[@name='Key2']/name\");\n+    }\n+\n+    public void testAxisDescendant(){\n+        assertXPathValue(context,\n+                \"//Key1\",\n+                \"Value 1\");\n+    }\n+\n+    /**\n+     * Testing the pseudo-attribute \"name\" that dynamic property\n+     * objects appear to have.\n+     */\n+    public void testAttributeName(){\n+        assertXPathValue(context,\n+                \"map[@name = 'Key1']\",\n+                \"Value 1\");\n+\n+        assertXPathPointer(context,\n+                \"map[@name = 'Key1']\",\n+                \"/map[@name='Key1']\");\n+\n+        assertXPathPointerLenient(context,\n+                \"map[@name = 'Key&quot;&apos;&quot;&apos;1']\",\n+                \"/map[@name='Key&quot;&apos;&quot;&apos;1']\");\n+\n+        assertXPathValue(context,\n+                \"/.[@name='map']/Key2/name\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/.[@name='map']/Key2/name\",\n+                \"/map[@name='Key2']/name\");\n+\n+        // Bean in a map\n+        assertXPathValue(context,\n+                \"/map[@name='Key2'][@name='name']\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/map[@name='Key2'][@name='name']\",\n+                \"/map[@name='Key2']/name\");\n+\n+        // Map in a bean in a map\n+        assertXPathValue(context,\n+                \"/.[@name='map'][@name='Key2'][@name='name']\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/.[@name='map'][@name='Key2'][@name='name']\",\n+                \"/map[@name='Key2']/name\");\n+    }\n+    \n+    public void testSetPrimitiveValue(){\n+        assertXPathSetValue(context, \n+                \"map/Key1\",\n+                new Integer(6));\n+    }\n+    \n+    public void testSetCollection(){\n+        // See if we can assign a whole collection        \n+        context.setValue(\n+                \"map/Key1\", \n+                new Integer[]{new Integer(7), new Integer(8)});\n+        \n+        // And then an element in that collection\n+        assertXPathSetValue(context,\n+                \"map/Key1[1]\", \n+                new Integer(9));\n+    }\n+    \n+    public void testSetNewKey(){\n+        assertXPathSetValue(context,\n+                \"map/Key4\", \n+                new Integer(7));\n+    }\n+    \n+    public void testCreatePath(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey1']\", \n+                \"\", \n+                \"/map[@name='TestKey1']\");\n+    }\n+    \n+    public void testCreatePathAndSetValue(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey1']\", \n+                \"Test\", \n+                \"/map[@name='TestKey1']\");\n+    }\n+    \n+    public void testCreatePathCreateBean(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey2']/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey2']/int\");\n+    }\n+    \n+    public void testCreatePathAndSetValueCreateBean(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey2']/int\", \n+                new Integer(4),\n+                \"/map[@name='TestKey2']/int\");\n+    }\n+    \n+    public void testCreatePathCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey3[2]\", \n+                null,\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey3'][3]\", \n+                null,\n+                \"/map[@name='TestKey3'][3]\");\n+    }\n+    \n+    public void testCreatePathAndSetValueCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey3[2]\", \n+                \"Test1\",\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey3'][3]\", \n+                \"Test2\",\n+                \"/map[@name='TestKey3'][3]\");\n+    }\n+    \n+    public void testCreatePathNewCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Create an element of a dynamic map element, which is a collection\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        bean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+    }\n+    \n+    public void testCreatePathAndSetValueNewCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Create an element of a dynamic map element, which is a collection\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(2),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        bean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(3),\n+                \"/map[@name='TestKey4'][1]/int\");\n+    }\n+    \n+    public void testRemovePath(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.getMap().put(\"TestKey1\", \"test\");\n+\n+        // Remove dynamic property\n+        context.removePath(\"map[@name = 'TestKey1']\");\n+        assertEquals(\"Remove dynamic property value\", null,\n+                    context.getValue(\"map[@name = 'TestKey1']\"));\n+    }\n+    \n+    public void testRemovePathArrayElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+\n+        bean.getMap().put(\"TestKey2\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"map[@name = 'TestKey2'][1]\");\n+        assertEquals(\"Remove dynamic property collection element\", \"temp2\",\n+                    context.getValue(\"map[@name = 'TestKey2'][1]\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.jdom.Element;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestBeanFactory extends AbstractFactory {\n+\n+    /**\n+     * Return <b>false</b> if this factory cannot create the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, \n+                Pointer pointer, Object parent, String name, int index)\n+    {\n+        if (name.equals(\"nestedBean\")){\n+            ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"beans\")){\n+            TestBean bean = (TestBean)parent;\n+            if (bean.getBeans() == null || index >= bean.getBeans().length){\n+                bean.setBeans(new NestedTestBean[index + 1]);\n+            }\n+            ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Create a new object and set it on the specified variable\n+     */\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.2 2002/10/13 03:01:03 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/13 03:01:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.3 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/10/20 03:48:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.dom;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n import junit.framework.Test;\n-import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n+\n import org.w3c.dom.*;\n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n-import java.beans.*;\n \n /**\n- * Abstract superclass for pure XPath 1.0.  Subclasses\n- * apply the same XPaths to contexts using different models:\n- * DOM, JDOM etc.\n+ * Tests JXPath with DOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/13 03:01:03 $\n+ * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:22 $\n  */\n \n public class DOMModelTest extends XMLModelTestCase\n {\n-    /**\n-     * Exercises this test case only\n-     */\n-    public static void main(String args[]) {\n-        junit.textui.TestRunner.run(suite());\n-    }\n-\n     /**\n      * Construct a new instance of this test case.\n      *\n     protected String getModel(){\n         return DocumentContainer.MODEL_DOM;\n     }\n+    \n+    protected AbstractFactory getAbstractFactory(){\n+        return new TestDOMFactory();\n+    }\n+    \n+    protected String getXMLSignature(Object node, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n+    \tStringBuffer buffer = new StringBuffer();\n+    \tappendXMLSignature(buffer, node, elements, attributes, text, pi);\n+    \treturn buffer.toString();\n+    }\n+    \n+    private void appendXMLSignature(StringBuffer buffer, Object object, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n+    \tNode node = (Node)object;\n+    \tint type = node.getNodeType();\n+    \tswitch (type){\n+    \t\tcase Node.DOCUMENT_NODE:\n+    \t\t\tbuffer.append(\"<D>\");\n+    \t\t\tappendXMLSignature(buffer, node.getChildNodes(), \n+    \t\t\t\t\telements, attributes, text, pi);\n+    \t\t\tbuffer.append(\"</D\");\n+    \t\t\tbreak;\n+    \t\t\t\n+    \t\tcase Node.ELEMENT_NODE:\n+    \t\t\tString tag = elements ? ((Element)node).getTagName() : \"E\";\n+\t\t\t\tbuffer.append(\"<\");\n+\t\t\t\tbuffer.append(tag);\n+\t\t\t\tbuffer.append(\">\");\n+    \t\t\tappendXMLSignature(buffer, node.getChildNodes(), \n+    \t\t\t\t\telements, attributes, text, pi);\n+\t\t\t\tbuffer.append(\"</\");\n+\t\t\t\tbuffer.append(tag);\n+\t\t\t\tbuffer.append(\">\");    \t\t\t\t\n+\t\t\t\tbreak;\n+\t\t\t\t\n+    \t\tcase Node.TEXT_NODE:\n+    \t\tcase Node.CDATA_SECTION_NODE:\n+    \t\t\tif (text){\n+    \t\t\t\tString string = node.getNodeValue();\n+    \t\t\t\tstring = string.replace('\\n', '=');\n+    \t\t\t\tbuffer.append(string);\n+    \t\t\t}\n+\t\t\t\tbreak;\n+    \t}\n+\t}\n+\t\n+    private void appendXMLSignature(StringBuffer buffer, NodeList children, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n+    {\n+    \tfor (int i = 0; i < children.getLength(); i++){\n+\t\t\tappendXMLSignature(buffer, children.item(i), \n+\t\t\t\t\telements, attributes, text, pi);\n+    \t}\n+\t}\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestDOMFactory extends AbstractFactory {\n+\n+    /**\n+     * Return <b>false</b> if this factory cannot create the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, \n+                Pointer pointer, Object parent, String name, int index)\n+    {\n+        if (name.equals(\"location\") || \n+                name.equals(\"address\") || \n+                name.equals(\"street\")){\n+            addDOMElement((Node)parent, index, name);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private void addDOMElement(Node parent, int index, String tag){\n+        Node child = parent.getFirstChild();\n+        int count = 0;\n+        while (child != null){\n+            if (child.getNodeName().equals(tag)){\n+                count++;\n+            }\n+            child = child.getNextSibling();\n+        }\n+\n+        // Keep inserting new elements until we have index + 1 of them\n+        while (count <= index){\n+            Node newElement = parent.getOwnerDocument().createElement(tag);\n+            parent.appendChild(newElement);\n+            count++;\n+        }\n+    }\n+\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.dynabeans;\n+\n+import org.apache.commons.beanutils.WrapDynaBean;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.ri.model.BeanModelTestCase;\n+\n+import junit.framework.*;\n+\n+/**\n+ * Test for support of DynaBeans (see BeanUtils)\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+\n+public class DynaBeanModelTest extends BeanModelTestCase\n+{\n+    public DynaBeanModelTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public static TestSuite suite(){\n+//        return (new TestSuite(BeanModelTest.class));\n+        TestSuite s = new TestSuite();\n+        s.addTest(new DynaBeanModelTest(\"testAxisParent\"));\n+        return s;\n+    }\n+\n+    protected Object createContextBean(){\n+        return new WrapDynaBean(new TestBean());\n+    }\n+\n+    protected AbstractFactory getAbstractFactory(){\n+        return new TestDynaBeanFactory();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.dynabeans;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import org.apache.commons.beanutils.DynaBean;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestDynaBeanFactory extends AbstractFactory {\n+\n+    /**\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        if (name.equals(\"nestedBean\")){\n+            ((DynaBean)parent).set(\"nestedBean\", new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"beans\")){\n+            DynaBean bean = (DynaBean)parent;\n+            Object beans[] = (Object[])bean.get(\"beans\");\n+            if (beans == null || index >= beans.length){\n+                beans = new NestedTestBean[index + 1];\n+                bean.set(\"beans\", beans);\n+            }\n+            beans[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    /**\n+     */\n+    public boolean declareVariable(JXPathContext context, String name){\n+        context.getVariables().declareVariable(name, null);\n+        return true;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.2 2002/10/13 03:01:03 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/13 03:01:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.3 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/10/20 03:48:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.w3c.dom.*;\n import java.util.*;\n import java.lang.reflect.*;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import org.apache.commons.jxpath.xml.*;\n+import org.jdom.*;\n+\n import java.beans.*;\n \n /**\n- * Abstract superclass for pure XPath 1.0.  Subclasses\n- * apply the same XPaths to contexts using different models:\n- * DOM, JDOM etc.\n+ * Tests JXPath with JDOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/13 03:01:03 $\n+ * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:22 $\n  */\n \n public class JDOMModelTest extends XMLModelTestCase\n {\n-    /**\n-     * Exercises this test case only\n-     */\n-    public static void main(String args[]) {\n-        junit.textui.TestRunner.run(suite());\n-    }\n-\n     /**\n      * Construct a new instance of this test case.\n      *\n     public void testID(){\n         // id() is not supported by JDOM\n     }\n+\n+    protected AbstractFactory getAbstractFactory(){\n+        return new TestJDOMFactory();\n+    }\n+    \n+    protected String getXMLSignature(Object node, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n+    \tStringBuffer buffer = new StringBuffer();\n+    \tappendXMLSignature(buffer, node, elements, attributes, text, pi);\n+    \treturn buffer.toString();\n+    }\n+    \n+    private void appendXMLSignature(StringBuffer buffer, Object object, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n+    \tif (object instanceof Document){\n+\t\t\tbuffer.append(\"<D>\");\n+\t\t\tappendXMLSignature(buffer, ((Document)object).getContent(), \n+\t\t\t\t\telements, attributes, text, pi);\n+\t\t\tbuffer.append(\"</D\");\n+    \t}\n+    \telse if (object instanceof Element){\n+\t\t\tString tag = elements ? ((Element)object).getName() : \"E\";\n+\t\t\tbuffer.append(\"<\");\n+\t\t\tbuffer.append(tag);\n+\t\t\tbuffer.append(\">\");\n+\t\t\tappendXMLSignature(buffer, ((Element)object).getContent(), \n+\t\t\t\t\telements, attributes, text, pi);\n+\t\t\tbuffer.append(\"</\");\n+\t\t\tbuffer.append(tag);\n+\t\t\tbuffer.append(\">\");    \t\t\t\t\n+    \t}\n+    \telse if (object instanceof Text || object instanceof CDATA){\n+\t\t\tif (text){\n+\t\t\t\tString string = ((Text)object).getText();\n+\t\t\t\tstring = string.replace('\\n', '=');\n+\t\t\t\tbuffer.append(string);\n+\t\t\t}\n+    \t}\n+\t}\n+\t\n+    private void appendXMLSignature(StringBuffer buffer, List children, \n+    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n+    {\n+    \tfor (int i = 0; i < children.size(); i++){\n+\t\t\tappendXMLSignature(buffer, children.get(i), \n+\t\t\t\t\telements, attributes, text, pi);\n+    \t}\n+\t}  \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:22 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.jdom;\n+\n+import java.util.List;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.jdom.Element;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ */\n+public class TestJDOMFactory extends AbstractFactory {\n+\n+    /**\n+     * Create a new instance and put it in the collection on the parent object.\n+     * Return <b>false</b> if this factory cannot create the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, \n+                Pointer pointer, Object parent, String name, int index)\n+    {\n+        if (name.equals(\"location\") || \n+                name.equals(\"address\") || name.equals(\"street\")){\n+            addJDOMElement((Element)parent, index, name);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private void addJDOMElement(Element parent, int index, String tag){\n+        List children = parent.getContent();\n+        int count = 0;\n+        for (int i = 0; i < children.size(); i++){\n+            Object child = children.get(i);\n+            if (child instanceof Element &&\n+                    ((Element)child).getQualifiedName().equals(tag)){\n+                count++;\n+            }\n+        }\n+\n+        // Keep inserting new elements until we have index + 1 of them\n+        while (count <= index){\n+            // In a real factory we would need to do the right thing with\n+            // the namespace prefix.\n+            Element newElement = new Element(tag);\n+            parent.addContent(newElement);\n+            count++;\n+        }\n+    }\n+\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java,v 1.1 2002/10/20 03:48:23 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/20 03:48:23 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.util;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests BasicTypeConverter\n+ * \n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:23 $\n+ */\n+\n+public class BasicTypeConverterTest extends TestCase\n+{\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public BasicTypeConverterTest(String name)\n+    {\n+        super(name);\n+    }\n+    \n+    public void testPrimitiveToString(){\n+        assertConversion(\n+                new Integer(1), \n+                String.class, \n+                \"1\");\n+    }\n+    \n+    public void testArrayToList(){\n+        assertConversion(\n+                new int[]{1, 2}, \n+                List.class,\n+                Arrays.asList(new Object[]{new Integer(1), new Integer(2)}));\n+    }\n+    \n+    public void testArrayToArray(){\n+        assertConversion(\n+                new int[]{1, 2}, \n+                String[].class,\n+                Arrays.asList(new String[]{\"1\", \"2\"}));\n+    }\n+    \n+    public void testListToArray(){\n+        assertConversion(\n+                Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}),\n+                String[].class,\n+                Arrays.asList(new String[]{\"1\", \"2\"}));\n+                \n+        assertConversion(\n+                Arrays.asList(new String[]{\"1\", \"2\"}),\n+                int[].class,\n+                Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}));\n+    }\n+    \n+    public void testInvalidConversion(){\n+        boolean exception = false;\n+        try {\n+            TypeUtils.convert(\n+                    \"'foo'\",\n+                    Date.class);\n+        }\n+        catch (Throwable ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Type conversion exception\", exception);\n+    }\n+    \n+    public void assertConversion(Object from, Class toType, Object expected) {\n+        boolean can = TypeUtils.canConvert(from, toType);\n+        assertTrue(\"Can convert: \" + from.getClass() + \n+                \" to \" + toType, can);\n+        Object result = TypeUtils.convert(from, toType);\n+        if (result.getClass().isArray()){\n+            ArrayList list = new ArrayList();\n+            for (int j = 0; j < Array.getLength(result); j++){\n+                list.add(Array.get(result, j));\n+            }\n+            result = list;\n+        }\n+        assertEquals(\"Convert: \" + from.getClass() + \n+                \" to \" + toType, expected, result);\n+    }\n+}", "timestamp": 1035085703, "metainfo": ""}