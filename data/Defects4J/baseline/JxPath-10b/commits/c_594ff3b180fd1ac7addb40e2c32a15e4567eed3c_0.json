{"sha": "594ff3b180fd1ac7addb40e2c32a15e4567eed3c", "log": "Replaced tabs with spaces   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.15 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.15 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.16 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.16 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n     }\n \n     public boolean nextNode(){\n-\t\tif (done) {\n-\t\t\treturn false;\n-\t\t}\n-\t\twhile (parentContext.nextNode()) {\n-\t\t\tif (setupDynamicPropertyPointer()) {\n-\t\t\t\tObject pred = nameTestExpression.computeValue(parentContext);\n-\t\t\t\tif (pred instanceof NodePointer) {\n-\t\t\t\t\tpred = ((NodePointer) pred).getValue();\n-\t\t\t\t}\n-\t\t\t\tdynamicPropertyPointer.setPropertyName(\n-\t\t\t\t\tInfoSetUtil.stringValue(pred));\n-\t\t\t\tposition = 1;\n-\t\t\t\tdone = true;\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tObject pred = expression.computeValue(parentContext);\n-\t\t\t\tif (pred instanceof Iterator) {\n-\t\t\t\t\tif (!((Iterator) pred).hasNext()) {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tpred = ((Iterator) pred).next();\n-\t\t\t\t}\n-\n-\t\t\t\tif (pred instanceof NodePointer) {\n-\t\t\t\t\tpred = ((NodePointer) pred).getNode();\n-\t\t\t\t}\n-\n-\t\t\t\tif (pred instanceof Number) {\n-\t\t\t\t\tint pos = (int) InfoSetUtil.doubleValue(pred);\n-\t\t\t\t\tposition++;\n-\t\t\t\t\tdone = true;\n-\t\t\t\t\treturn parentContext.setPosition(pos);\n-\t\t\t\t}\n-\t\t\t\telse if (InfoSetUtil.booleanValue(pred)) {\n-\t\t\t\t\tposition++;\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+        if (done) {\n+            return false;\n+        }\n+        while (parentContext.nextNode()) {\n+            if (setupDynamicPropertyPointer()) {\n+                Object pred = nameTestExpression.computeValue(parentContext);\n+                if (pred instanceof NodePointer) {\n+                    pred = ((NodePointer) pred).getValue();\n+                }\n+                dynamicPropertyPointer.setPropertyName(\n+                    InfoSetUtil.stringValue(pred));\n+                position = 1;\n+                done = true;\n+                return true;\n+            }\n+            else {\n+                Object pred = expression.computeValue(parentContext);\n+                if (pred instanceof Iterator) {\n+                    if (!((Iterator) pred).hasNext()) {\n+                        return false;\n+                    }\n+                    pred = ((Iterator) pred).next();\n+                }\n+\n+                if (pred instanceof NodePointer) {\n+                    pred = ((NodePointer) pred).getNode();\n+                }\n+\n+                if (pred instanceof Number) {\n+                    int pos = (int) InfoSetUtil.doubleValue(pred);\n+                    position++;\n+                    done = true;\n+                    return parentContext.setPosition(pos);\n+                }\n+                else if (InfoSetUtil.booleanValue(pred)) {\n+                    position++;\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n     }\n \n     /**\n     }\n \n     public boolean setPosition(int position){\n-\t\tif (nameTestExpression == null) {\n-\t\t\treturn setPositionStandard(position);\n-\t\t}\n-\t\telse {\n-\t\t\tif (dynamicPropertyPointer == null) {\n-\t\t\t\tif (!setupDynamicPropertyPointer()) {\n-\t\t\t\t\treturn setPositionStandard(position);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (position < 1\n-\t\t\t\t|| position > dynamicPropertyPointer.getLength()) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tdynamicPropertyPointer.setIndex(position - 1);\n-\t\t\treturn true;\n-\t\t}\n+        if (nameTestExpression == null) {\n+            return setPositionStandard(position);\n+        }\n+        else {\n+            if (dynamicPropertyPointer == null) {\n+                if (!setupDynamicPropertyPointer()) {\n+                    return setPositionStandard(position);\n+                }\n+            }\n+            if (position < 1\n+                || position > dynamicPropertyPointer.getLength()) {\n+                return false;\n+            }\n+            dynamicPropertyPointer.setIndex(position - 1);\n+            return true;\n+        }\n     }\n \n     public NodePointer getCurrentNodePointer(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.9 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * in the chain.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     private Object bean;\n     private JXPathBeanInfo beanInfo;\n \n-\tpublic BeanPointer(\n-    \t\tQName name,\n-    \t\tObject bean,\n-    \t\tJXPathBeanInfo beanInfo,\n-    \t\tLocale locale) \n+    public BeanPointer(\n+            QName name,\n+            Object bean,\n+            JXPathBeanInfo beanInfo,\n+            Locale locale) \n     {\n-\t\tsuper(null, locale);\n-\t\tthis.name = name;\n-\t\tthis.bean = bean;\n-\t\tthis.beanInfo = beanInfo;\n-\t}\n+        super(null, locale);\n+        this.name = name;\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n \n     /**\n      * @param name is the name given to the first node\n      */\n-\tpublic BeanPointer(\n-    \t\tNodePointer parent,\n-    \t\tQName name,\n-    \t\tObject bean,\n-    \t\tJXPathBeanInfo beanInfo) \n+    public BeanPointer(\n+            NodePointer parent,\n+            QName name,\n+            Object bean,\n+            JXPathBeanInfo beanInfo) \n     {\n-\t\tsuper(parent);\n-\t\tthis.name = name;\n-\t\tthis.bean = bean;\n-\t\tthis.beanInfo = beanInfo;\n-\t}\n+        super(parent);\n+        this.name = name;\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n \n     public PropertyPointer getPropertyPointer(){\n         return new BeanPropertyPointer(this, beanInfo);\n         return name == null ? 0 : name.hashCode();\n     }\n \n-\tpublic boolean equals(Object object) {\n-\t\tif (object == this) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tif (!(object instanceof BeanPointer)) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tBeanPointer other = (BeanPointer) object;\n-\t\tif (parent != other.parent) {\n-\t\t\tif (parent == null || !parent.equals(other.parent)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ((name == null && other.name != null)\n-\t\t\t|| (name != null && !name.equals(other.name))) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tint i_this = (index == WHOLE_COLLECTION ? 0 : index);\n-\t\tint i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-\t\tif (i_this != i_other) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (bean instanceof Number\n-\t\t\t|| bean instanceof String\n-\t\t\t|| bean instanceof Boolean) {\n-\t\t\treturn bean.equals(other.bean);\n-\t\t}\n-\t\treturn bean == other.bean;\n-\t}\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+\n+        if (!(object instanceof BeanPointer)) {\n+            return false;\n+        }\n+\n+        BeanPointer other = (BeanPointer) object;\n+        if (parent != other.parent) {\n+            if (parent == null || !parent.equals(other.parent)) {\n+                return false;\n+            }\n+        }\n+\n+        if ((name == null && other.name != null)\n+            || (name != null && !name.equals(other.name))) {\n+            return false;\n+        }\n+\n+        int i_this = (index == WHOLE_COLLECTION ? 0 : index);\n+        int i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n+        if (i_this != i_other) {\n+            return false;\n+        }\n+\n+        if (bean instanceof Number\n+            || bean instanceof String\n+            || bean instanceof Boolean) {\n+            return bean.equals(other.bean);\n+        }\n+        return bean == other.bean;\n+    }\n \n     /**\n      * If the pointer has a parent, then parent's path.\n      * If the bean is a primitive value, the value itself.\n      * Otherwise - an empty string.\n      */\n-\tpublic String asPath() {\n-\t\tif (parent != null) {\n-\t\t\treturn super.asPath();\n-\t\t}\n-\t\telse if (bean == null) {\n-\t\t\treturn \"null()\";\n-\t\t}\n-\t\telse if (bean instanceof Number) {\n-\t\t\tString string = bean.toString();\n-\t\t\tif (string.endsWith(\".0\")) {\n-\t\t\t\tstring = string.substring(0, string.length() - 2);\n-\t\t\t}\n-\t\t\treturn string;\n-\t\t}\n-\t\telse if (bean instanceof Boolean) {\n-\t\t\treturn ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n-\t\t}\n-\t\telse if (bean instanceof String) {\n-\t\t\treturn \"'\" + bean + \"'\";\n-\t\t}\n-\t\treturn \"/\";\n-\t}\n+    public String asPath() {\n+        if (parent != null) {\n+            return super.asPath();\n+        }\n+        else if (bean == null) {\n+            return \"null()\";\n+        }\n+        else if (bean instanceof Number) {\n+            String string = bean.toString();\n+            if (string.endsWith(\".0\")) {\n+                string = string.substring(0, string.length() - 2);\n+            }\n+            return string;\n+        }\n+        else if (bean instanceof Boolean) {\n+            return ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n+        }\n+        else if (bean instanceof String) {\n+            return \"'\" + bean + \"'\";\n+        }\n+        return \"/\";\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.9 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n     }\n \n     public boolean isCollection(){\n-    \treturn true;\n+        return true;\n     }\n \n     public int getLength(){\n     }\n \n     public NodePointer createChild(JXPathContext context, \n-    \t\t\tQName name, int index, Object value)\n+                QName name, int index, Object value)\n     {\n         if (parent instanceof PropertyPointer){\n             return parent.createChild(context, name, index, value);\n     }\n \n     public NodePointer createChild(JXPathContext context, \n-    \t\t\tQName name, int index)\n+                QName name, int index)\n     {\n         if (parent instanceof PropertyPointer){\n             return parent.createChild(context, name, index);\n     }\n \n     public NodeIterator childIterator(NodeTest test, \n-    \t\t\tboolean reverse, NodePointer startWith)\n+                boolean reverse, NodePointer startWith)\n     {\n         if (index == WHOLE_COLLECTION){\n             return null;\n     }\n \n     public int compareChildNodePointers(\n-    \t\t\tNodePointer pointer1, NodePointer pointer2)\n+                NodePointer pointer1, NodePointer pointer2)\n     {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPointer.java,v 1.6 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPointer.java,v 1.7 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * for the first element of a path; following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class DynamicPointer extends PropertyOwnerPointer {\n     private QName name;\n     }    \n     \n     public boolean isCollection(){\n-    \treturn false;\n+        return false;\n     }\n \n     /**\n      * Returns 1.\n      */\n     public int getLength(){\n-    \treturn 1;\n+        return 1;\n     }\n \n     public String asPath(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.11 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.11 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n     private String[] names;\n     private String requiredPropertyName;\n \n-\tpublic DynamicPropertyPointer(\n-    \t\tNodePointer parent,\n-    \t\tDynamicPropertyHandler handler) \n+    public DynamicPropertyPointer(\n+            NodePointer parent,\n+            DynamicPropertyHandler handler) \n     {\n-\t\tsuper(parent);\n-\t\tthis.handler = handler;\n-\t}\n+        super(parent);\n+        this.handler = handler;\n+    }\n     /**\n      * This type of node is auxiliary.\n      */\n      * and the value will be the property itself.\n      */\n     public Object getImmediateNode(){\n-\t\tObject value;\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\tvalue = handler.getProperty(getBean(), getPropertyName());\n-\t\t}\n-\t\telse {\n-\t\t\tvalue =\n-\t\t\t\tValueUtils.getValue(\n-\t\t\t\t\thandler.getProperty(getBean(), getPropertyName()),\n-\t\t\t\t\tindex);\n-\t\t}\n-\t\treturn value;\n+        Object value;\n+        if (index == WHOLE_COLLECTION) {\n+            value = handler.getProperty(getBean(), getPropertyName());\n+        }\n+        else {\n+            value =\n+                ValueUtils.getValue(\n+                    handler.getProperty(getBean(), getPropertyName()),\n+                    index);\n+        }\n+        return value;\n     }\n \n     /**\n      * represented by the property.\n      */\n     public void setValue(Object value){\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), value);\n-\t\t}\n-\t\telse {\n-\t\t\tValueUtils.setValue(\n-\t\t\t\thandler.getProperty(getBean(), getPropertyName()),\n-\t\t\t\tindex,\n-\t\t\t\tvalue);\n-\t\t}\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            ValueUtils.setValue(\n+                handler.getProperty(getBean(), getPropertyName()),\n+                index,\n+                value);\n+        }\n     }\n \n     public NodePointer createPath(JXPathContext context, Object value){\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n-\t\t// Ignore the name passed to us, use our own data\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), value);\n-\t\t}\n-\t\telse {\n-\t\t\tObject collection = getBaseValue();\n-\t\t\tif (collection == null) {\n-\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\t\tif (!factory\n-\t\t\t\t\t.createObject(\n-\t\t\t\t\t\tcontext,\n-\t\t\t\t\t\tthis,\n-\t\t\t\t\t\tgetBean(),\n-\t\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\t\t0)) {\n-\t\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\t\"Factory could not create an object for path: \"\n-\t\t\t\t\t\t\t+ asPath());\n-\t\t\t\t}\n-\t\t\t\tcollection = getBaseValue();\n-\t\t\t}\n-\n-\t\t\tif (index < 0) {\n-\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n-\t\t\t}\n-\n-\t\t\tif (index >= getLength()) {\n-\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n-\t\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n-\t\t\t}\n-\n-\t\t\tValueUtils.setValue(collection, index, value);\n-\t\t}\n-\t\tNodePointer ptr = (NodePointer) clone();\n-\t\tptr.setIndex(index);\n-\t\treturn ptr;\n+        // Ignore the name passed to us, use our own data\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (collection == null) {\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory\n+                    .createObject(\n+                        context,\n+                        this,\n+                        getBean(),\n+                        getPropertyName(),\n+                        0)) {\n+                    throw new JXPathException(\n+                        \"Factory could not create an object for path: \"\n+                            + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0) {\n+                throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()) {\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                handler.setProperty(getBean(), getPropertyName(), collection);\n+            }\n+\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+        NodePointer ptr = (NodePointer) clone();\n+        ptr.setIndex(index);\n+        return ptr;\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index){\n-\t\t// Ignore the name passed to us, use our own data\n-\t\tObject collection = getBaseValue();\n-\t\tif (collection == null) {\n-\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\tif (!factory\n-\t\t\t\t.createObject(context, this, getBean(), getPropertyName(), 0)) {\n-\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n-\t\t\t}\n-\t\t\tcollection = getBaseValue();\n-\t\t}\n-\n-\t\tif (index < 0) {\n-\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n-\t\t}\n-\n-\t\tif (index >= getLength()) {\n-\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n-\t\t}\n-\n-\t\tDynamicPropertyPointer pointer = (DynamicPropertyPointer) this.clone();\n-\t\tpointer.setIndex(index);\n-\t\treturn pointer;\n+        // Ignore the name passed to us, use our own data\n+        Object collection = getBaseValue();\n+        if (collection == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory\n+                .createObject(context, this, getBean(), getPropertyName(), 0)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+            collection = getBaseValue();\n+        }\n+\n+        if (index < 0) {\n+            throw new JXPathException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()) {\n+            collection = ValueUtils.expandCollection(collection, index + 1);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+\n+        DynamicPropertyPointer pointer = (DynamicPropertyPointer) this.clone();\n+        pointer.setIndex(index);\n+        return pointer;\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-\t\tif (getNode() == null) {\n-\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\tint inx = (index == WHOLE_COLLECTION ? 0 : index);\n-\t\t\tif (!factory\n-\t\t\t\t.createObject(\n-\t\t\t\t\tcontext,\n-\t\t\t\t\tthis,\n-\t\t\t\t\tgetBean(),\n-\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\tinx)) {\n-\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n-\t\t\t}\n-\t\t}\n-\t\treturn this;\n+        if (getNode() == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory\n+                .createObject(\n+                    context,\n+                    this,\n+                    getBean(),\n+                    getPropertyName(),\n+                    inx)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        return this;\n     }\n \n     public void remove(){\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), null);\n-\t\t}\n-\t\telse if (isCollection()) {\n-\t\t\tObject collection = ValueUtils.remove(getBaseValue(), index);\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n-\t\t}\n-\t\telse if (index == 0) {\n-\t\t\thandler.setProperty(getBean(), getPropertyName(), null);\n-\t\t}\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n+        else if (isCollection()) {\n+            Object collection = ValueUtils.remove(getBaseValue(), index);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+        else if (index == 0) {\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n     }\n \n     public String asPath(){\n-\t\tStringBuffer buffer = new StringBuffer();\n-\t\tbuffer.append(getParent().asPath());\n-\t\tif (buffer.length() == 0) {\n-\t\t\tbuffer.append(\"/.\");\n-\t\t}\n-\t\telse if (buffer.charAt(buffer.length() - 1) == '/') {\n-\t\t\tbuffer.append('.');\n-\t\t}\n-\t\tbuffer.append(\"[@name='\");\n-\t\tbuffer.append(escape(getPropertyName()));\n-\t\tbuffer.append(\"']\");\n-\t\tif (index != WHOLE_COLLECTION && isCollection()) {\n-\t\t\tbuffer.append('[').append(index + 1).append(']');\n-\t\t}\n-\t\treturn buffer.toString();\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getParent().asPath());\n+        if (buffer.length() == 0) {\n+            buffer.append(\"/.\");\n+        }\n+        else if (buffer.charAt(buffer.length() - 1) == '/') {\n+            buffer.append('.');\n+        }\n+        buffer.append(\"[@name='\");\n+        buffer.append(escape(getPropertyName()));\n+        buffer.append(\"']\");\n+        if (index != WHOLE_COLLECTION && isCollection()) {\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n     }\n \n     private String escape(String string){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.6 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.7 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of the attribute is based on the locale supplied to it in the constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class LangAttributePointer extends NodePointer {\n     public LangAttributePointer(NodePointer parent){\n             buffer.append(parent.asPath());\n             if (buffer.length() == 0 ||\n                     buffer.charAt(buffer.length()-1) != '/'){\n-            \tbuffer.append('/');\n+                buffer.append('/');\n             }\n         }\n         buffer.append(\"@xml:lang\");\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.8 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.9 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n             buffer.append(parent.asPath());\n             if (buffer.length() == 0 ||\n                     buffer.charAt(buffer.length()-1) != '/'){\n-            \tbuffer.append('/');\n+                buffer.append('/');\n             }\n         }\n         buffer.append('@');\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.12 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.13 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.13 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n     private String id;\n \n     public static final String XML_NAMESPACE_URI = \n-    \t\t\"http://www.w3.org/XML/1998/namespace\";\n+            \"http://www.w3.org/XML/1998/namespace\";\n     public static final String XMLNS_NAMESPACE_URI = \n-    \t\t\"http://www.w3.org/2000/xmlns/\";\n+            \"http://www.w3.org/2000/xmlns/\";\n \n     public DOMNodePointer(Node node, Locale locale){\n         super(null, locale);\n     }\n \n     public static boolean testNode(\n-    \t\tNodePointer pointer, Node node, NodeTest test)\n+            NodePointer pointer, Node node, NodeTest test)\n     {\n         if (test == null){\n             return true;\n             QName testName = ((NodeNameTest)test).getNodeName();\n             String testLocalName = testName.getName();\n             if (testLocalName.equals(\"*\") || \n-            \t\ttestLocalName.equals(DOMNodePointer.getLocalName(node))){\n+                    testLocalName.equals(DOMNodePointer.getLocalName(node))){\n                 String testPrefix = testName.getPrefix();\n                 String nodePrefix = DOMNodePointer.getPrefix(node);\n                 if (equalStrings(testPrefix, nodePrefix)){\n      */\n     public void setValue(Object value){\n         if (node.getNodeType() == Node.TEXT_NODE ||\n-        \t\tnode.getNodeType() == Node.CDATA_SECTION_NODE){\n+                node.getNodeType() == Node.CDATA_SECTION_NODE){\n             String string = (String)TypeUtils.convert(value, String.class);\n             if (string != null && !string.equals(\"\")){\n                 node.setNodeValue(string);\n         else {\n             NodeList children = node.getChildNodes();\n             int count = children.getLength();\n-\t        for (int i = count; --i >= 0;){\n-\t            Node child = children.item(i);\n-\t            node.removeChild(child);\n-\t        }\n+            for (int i = count; --i >= 0;){\n+                Node child = children.item(i);\n+                node.removeChild(child);\n+            }\n             \n-        \tif (value instanceof Node){\n-        \t\tNode valueNode = (Node)value;\n-        \t\tif (valueNode instanceof Element ||\n-        \t\t\t\tvalueNode instanceof Document){\n-        \t\t\tchildren = valueNode.getChildNodes();\n-        \t\t\tfor (int i = 0; i < children.getLength(); i++){\n-        \t\t\t\tNode child = children.item(i);\n-        \t\t\t\tnode.appendChild(child.cloneNode(true));\n-        \t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tnode.appendChild(valueNode.cloneNode(true));\n-\t\t\t\t}        \t\n-        \t}\n-        \telse {\n-\t            String string = (String)TypeUtils.convert(value, String.class);\n-\t            if (string != null && !string.equals(\"\")){\n-\t            \tNode textNode = \n-\t            \t\t\tnode.getOwnerDocument().createTextNode(string);\n-\t                node.appendChild(textNode);\n-\t            }\n-        \t}\n+            if (value instanceof Node){\n+                Node valueNode = (Node)value;\n+                if (valueNode instanceof Element ||\n+                        valueNode instanceof Document){\n+                    children = valueNode.getChildNodes();\n+                    for (int i = 0; i < children.getLength(); i++){\n+                        Node child = children.item(i);\n+                        node.appendChild(child.cloneNode(true));\n+                    }\n+                }\n+                else {\n+                    node.appendChild(valueNode.cloneNode(true));\n+                }            \n+            }\n+            else {\n+                String string = (String)TypeUtils.convert(value, String.class);\n+                if (string != null && !string.equals(\"\")){\n+                    Node textNode = \n+                            node.getOwnerDocument().createTextNode(string);\n+                    node.appendChild(textNode);\n+                }\n+            }\n         }\n     }\n     \n     public NodePointer createChild(JXPathContext context, \n-    \t\t\tQName name, int index)\n+                QName name, int index)\n     {\n         if (index == WHOLE_COLLECTION){\n             index = 0;\n             String ns = getNamespaceURI(prefix);\n             if (ns == null){\n                 throw new JXPathException(\n-                \t\"Unknown namespace prefix: \" + prefix);\n+                    \"Unknown namespace prefix: \" + prefix);\n             }\n             element.setAttributeNS(ns, name.toString(), \"\");\n         }\n                 if (parent instanceof DOMNodePointer){\n                     if (buffer.length() == 0 ||\n                             buffer.charAt(buffer.length()-1) != '/'){\n-                    \tbuffer.append('/');\n+                        buffer.append('/');\n                     }\n                     buffer.append(getName());\n                     buffer.append('[');\n         int index = string.indexOf('\\'');\n         while (index != -1){\n             string = string.substring(0, index) + \n-            \t\"&apos;\" + string.substring(index + 1);\n+                \"&apos;\" + string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n         while (index != -1){\n             string = string.substring(0, index) + \n-            \t\"&quot;\" + string.substring(index + 1);\n+                \"&quot;\" + string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n         return string;\n         Node n = node.getPreviousSibling();\n         while (n != null){\n             if (n.getNodeType() == Node.TEXT_NODE || \n-            \t\t\tn.getNodeType() == Node.CDATA_SECTION_NODE){\n+                        n.getNodeType() == Node.CDATA_SECTION_NODE){\n                 count ++;\n             }\n             n = n.getPreviousSibling();\n         AbstractFactory factory = context.getFactory();\n         if (factory == null){\n             throw new JXPathException(\n-            \t\"Factory is not set on the JXPathContext - \" +\n-            \t\"cannot create path: \" + asPath());\n+                \"Factory is not set on the JXPathContext - \" +\n+                \"cannot create path: \" + asPath());\n         }\n         return factory;\n     }\n \n     public int compareChildNodePointers(\n-    \t\tNodePointer pointer1, NodePointer pointer2)\n+            NodePointer pointer1, NodePointer pointer2)\n     {\n         Node node1 = (Node)pointer1.getBaseValue();\n         Node node2 = (Node)pointer2.getBaseValue();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.7 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.8 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class NamespacePointer extends NodePointer {\n     private String prefix;\n             buffer.append(parent.asPath());\n             if (buffer.length() == 0 ||\n                     buffer.charAt(buffer.length()-1) != '/'){\n-            \tbuffer.append('/');\n+                buffer.append('/');\n             }\n         }\n         buffer.append(\"namespace::\");\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.4 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a DynaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class DynaBeanPropertyPointer extends PropertyPointer {\n     private DynaBean dynaBean;\n     public NodePointer createChild(JXPathContext context,\n             QName name, int index, Object value)\n     {\n-\t\t// Ignore the name passed to us, use our own data\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\tsetValue(index, value);\n-\t\t}\n-\t\telse if (isIndexedProperty()) {\n-\t\t\tdynaBean.set(getPropertyName(), index, convert(value, true));\n-\t\t}\n-\t\telse {\n-\t\t\tObject collection = getBaseValue();\n-\t\t\tif (collection == null) {\n-\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\t\tif (!factory\n-\t\t\t\t\t.createObject(\n-\t\t\t\t\t\tcontext,\n-\t\t\t\t\t\tthis,\n-\t\t\t\t\t\tgetBean(),\n-\t\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\t\t0)) {\n-\t\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\t\"Factory could not create an object for path: \"\n-\t\t\t\t\t\t\t+ asPath());\n-\t\t\t\t}\n-\t\t\t\tcollection = getBaseValue();\n-\t\t\t}\n-\n-\t\t\tif (index < 0) {\n-\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n-\t\t\t}\n-\n-\t\t\tif (index >= getLength()) {\n-\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n-\t\t\t\tdynaBean.set(getPropertyName(), collection);\n-\t\t\t}\n-\n-\t\t\tValueUtils.setValue(collection, index, value);\n-\t\t}\n-\t\tNodePointer ptr = (NodePointer) clone();\n-\t\tptr.setIndex(index);\n-\t\treturn ptr;\n+        // Ignore the name passed to us, use our own data\n+        if (index == WHOLE_COLLECTION) {\n+            setValue(index, value);\n+        }\n+        else if (isIndexedProperty()) {\n+            dynaBean.set(getPropertyName(), index, convert(value, true));\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (collection == null) {\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory\n+                    .createObject(\n+                        context,\n+                        this,\n+                        getBean(),\n+                        getPropertyName(),\n+                        0)) {\n+                    throw new JXPathException(\n+                        \"Factory could not create an object for path: \"\n+                            + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0) {\n+                throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()) {\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                dynaBean.set(getPropertyName(), collection);\n+            }\n+\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+        NodePointer ptr = (NodePointer) clone();\n+        ptr.setIndex(index);\n+        return ptr;\n     }\n \n     public NodePointer createChild(JXPathContext context,\n             QName name, int index)\n     {\n-\t\tif (isIndexedProperty()) {\n-\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\tif (!factory\n-\t\t\t\t.createObject(\n-\t\t\t\t\tcontext,\n-\t\t\t\t\tthis,\n-\t\t\t\t\tdynaBean,\n-\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\tindex)) {\n-\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\t// Ignore the name passed to us, use our own data\n-\t\t\tObject collection = getBaseValue();\n-\t\t\tif (collection == null) {\n-\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\t\tif (!factory\n-\t\t\t\t\t.createObject(\n-\t\t\t\t\t\tcontext,\n-\t\t\t\t\t\tthis,\n-\t\t\t\t\t\tdynaBean,\n-\t\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\t\tindex)) {\n-\t\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\t\"Factory could not create an object for path: \"\n-\t\t\t\t\t\t\t+ asPath());\n-\t\t\t\t}\n-\t\t\t\tcollection = getBaseValue();\n-\t\t\t}\n-\n-\t\t\tif (index < 0) {\n-\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n-\t\t\t}\n-\n-\t\t\tif (index >= getLength()) {\n-\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n-\t\t\t\tdynaBean.set(getPropertyName(), collection);\n-\t\t\t}\n-\t\t}\n-\n-\t\tDynaBeanPropertyPointer pointer =\n-\t\t\t(DynaBeanPropertyPointer) this.clone();\n-\t\tpointer.setIndex(index);\n-\t\treturn pointer;\n+        if (isIndexedProperty()) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory\n+                .createObject(\n+                    context,\n+                    this,\n+                    dynaBean,\n+                    getPropertyName(),\n+                    index)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        else {\n+            // Ignore the name passed to us, use our own data\n+            Object collection = getBaseValue();\n+            if (collection == null) {\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory\n+                    .createObject(\n+                        context,\n+                        this,\n+                        dynaBean,\n+                        getPropertyName(),\n+                        index)) {\n+                    throw new JXPathException(\n+                        \"Factory could not create an object for path: \"\n+                            + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0) {\n+                throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()) {\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                dynaBean.set(getPropertyName(), collection);\n+            }\n+        }\n+\n+        DynaBeanPropertyPointer pointer =\n+            (DynaBeanPropertyPointer) this.clone();\n+        pointer.setIndex(index);\n+        return pointer;\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-\t\tif (getNode() == null) {\n-\t\t\tAbstractFactory factory = getAbstractFactory(context);\n-\t\t\tint inx = (index == WHOLE_COLLECTION ? 0 : index);\n-\t\t\tif (!factory\n-\t\t\t\t.createObject(\n-\t\t\t\t\tcontext,\n-\t\t\t\t\tthis,\n-\t\t\t\t\tdynaBean,\n-\t\t\t\t\tgetPropertyName(),\n-\t\t\t\t\tinx)) {\n-\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n-\t\t\t}\n-\t\t}\n+        if (getNode() == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory\n+                .createObject(\n+                    context,\n+                    this,\n+                    dynaBean,\n+                    getPropertyName(),\n+                    inx)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n         return this;\n     }\n \n     public void remove(){\n-\t\tif (index == WHOLE_COLLECTION) {\n-\t\t\tdynaBean.set(getPropertyName(), null);\n-\t\t}\n-\t\telse if (isIndexedProperty()) {\n-\t\t\tdynaBean.set(getPropertyName(), index, null);\n-\t\t}\n-\t\telse if (isCollection()) {\n-\t\t\tObject collection = ValueUtils.remove(getBaseValue(), index);\n-\t\t\tdynaBean.set(getPropertyName(), collection);\n-\t\t}\n-\t\telse if (index == 0) {\n-\t\t\tdynaBean.set(getPropertyName(), null);\n-\t\t}\n+        if (index == WHOLE_COLLECTION) {\n+            dynaBean.set(getPropertyName(), null);\n+        }\n+        else if (isIndexedProperty()) {\n+            dynaBean.set(getPropertyName(), index, null);\n+        }\n+        else if (isCollection()) {\n+            Object collection = ValueUtils.remove(getBaseValue(), index);\n+            dynaBean.set(getPropertyName(), collection);\n+        }\n+        else if (index == 0) {\n+            dynaBean.set(getPropertyName(), null);\n+        }\n     }\n \n     private AbstractFactory getAbstractFactory(JXPathContext context){\n-\t\tAbstractFactory factory = context.getFactory();\n-\t\tif (factory == null) {\n-\t\t\tthrow new JXPathException(\n-\t\t\t\t\"Factory is not set on the JXPathContext - cannot create path: \"\n-\t\t\t\t\t+ asPath());\n-\t\t}\n-\t\treturn factory;\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null) {\n+            throw new JXPathException(\n+                \"Factory is not set on the JXPathContext - cannot create path: \"\n+                    + asPath());\n+        }\n+        return factory;\n     }\n \n     private void setValue(int index, Object value){\n \n \n     private Object convert(Object value, boolean element){\n-\t\tDynaClass dynaClass = (DynaClass) dynaBean.getDynaClass();\n-\t\tDynaProperty property = dynaClass.getDynaProperty(getPropertyName());\n-\t\tClass type = property.getType();\n-\t\tif (element) {\n-\t\t\tif (type.isArray()) {\n-\t\t\t\ttype = type.getComponentType();\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\treturn value; // No need to convert\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry {\n-\t\t\treturn TypeUtils.convert(value, type);\n-\t\t}\n-\t\tcatch (Exception ex) {\n-\t\t\tex.printStackTrace();\n-\t\t\tthrow new JXPathException(\n-\t\t\t\t\"Cannot convert value of class \"\n-\t\t\t\t\t+ (value == null ? \"null\" : value.getClass().getName())\n-\t\t\t\t\t+ \" to type \"\n-\t\t\t\t\t+ type,\n-\t\t\t\tex);\n-\t\t}\n+        DynaClass dynaClass = (DynaClass) dynaBean.getDynaClass();\n+        DynaProperty property = dynaClass.getDynaProperty(getPropertyName());\n+        Class type = property.getType();\n+        if (element) {\n+            if (type.isArray()) {\n+                type = type.getComponentType();\n+            }\n+            else {\n+                return value; // No need to convert\n+            }\n+        }\n+\n+        try {\n+            return TypeUtils.convert(value, type);\n+        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new JXPathException(\n+                \"Cannot convert value of class \"\n+                    + (value == null ? \"null\" : value.getClass().getName())\n+                    + \" to type \"\n+                    + type,\n+                ex);\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.4 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class JDOMAttributePointer extends NodePointer {\n     private Attribute attr;\n         this.attr = attr;\n     }\n \n-\tpublic QName getName() {\n-\t\treturn new QName(\n-\t\t\tJDOMNodePointer.getPrefix(attr),\n-\t\t\tJDOMNodePointer.getLocalName(attr));\n-\t}\n+    public QName getName() {\n+        return new QName(\n+            JDOMNodePointer.getPrefix(attr),\n+            JDOMNodePointer.getLocalName(attr));\n+    }\n \n     public QName getExpandedName(){\n         return new QName(getNamespaceURI(),  attr.getName());\n             buffer.append(parent.asPath());\n             if (buffer.length() == 0 ||\n                     buffer.charAt(buffer.length()-1) != '/'){\n-            \tbuffer.append('/');\n+                buffer.append('/');\n             }\n         }\n         buffer.append('@');\n         return attr == other.attr;\n     }\n \n-\tpublic int compareChildNodePointers(\n-    \t\tNodePointer pointer1,\n-    \t\tNodePointer pointer2) \n+    public int compareChildNodePointers(\n+            NodePointer pointer1,\n+            NodePointer pointer2) \n     {\n-\t\t// Won't happen - attributes don't have children\n-\t\treturn 0;\n-\t}\n+        // Won't happen - attributes don't have children\n+        return 0;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.4 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class JDOMNamespacePointer extends NodePointer {\n     private String prefix;\n         this.prefix = prefix;\n     }\n \n-\tpublic JDOMNamespacePointer(\n-    \t\tNodePointer parent,\n-    \t\tString prefix,\n-    \t\tString namespaceURI) \n+    public JDOMNamespacePointer(\n+            NodePointer parent,\n+            String prefix,\n+            String namespaceURI) \n     {\n-\t\tsuper(parent);\n-\t\tthis.prefix = prefix;\n-\t\tthis.namespaceURI = namespaceURI;\n-\t}\n+        super(parent);\n+        this.prefix = prefix;\n+        this.namespaceURI = namespaceURI;\n+    }\n \n     public QName getName(){\n         return new QName(getNamespaceURI(), prefix);\n             buffer.append(parent.asPath());\n             if (buffer.length() == 0 ||\n                     buffer.charAt(buffer.length()-1) != '/'){\n-            \tbuffer.append('/');\n+                buffer.append('/');\n             }\n         }\n         buffer.append(\"namespace::\");\n         return prefix.equals(other.prefix);\n     }\n \n-\tpublic int compareChildNodePointers(\n-\t\tNodePointer pointer1,\n-\t\tNodePointer pointer2) \n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n     {\n-\t\t// Won't happen - namespaces don't have children\n-\t\treturn 0;\n-\t}\n+        // Won't happen - namespaces don't have children\n+        return 0;\n+    }\n  }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.4 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.5 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.5 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class JDOMNodePointer extends NodePointer {\n     private Object node;\n             }\n         }\n         else {\n-        \tElement element = (Element)node;\n-        \telement.getContent().clear();\n-        \t            \n-        \tif (value instanceof Element){\n-        \t\tElement valueElement = (Element)value;\n-        \t\taddContent(valueElement.getContent());\n-        \t}\n-        \telse if (value instanceof Document){\n-        \t\tDocument valueDocument = (Document)value;        \t\t\n-        \t\taddContent(valueDocument.getContent());\n-        \t}\n-        \telse if (value instanceof Text ||\n-        \t\t\t value instanceof CDATA){\n-        \t\tString string = ((Text)value).getText();\n-        \t\telement.addContent(new Text(string));\n-\t\t\t}\n-\t\t\telse if (value instanceof ProcessingInstruction){\n-\t\t\t\tProcessingInstruction pi = (ProcessingInstruction)\n-\t\t\t\t\t\t((ProcessingInstruction)value).clone();\n-\t\t\t\telement.addContent(pi);\n-\t\t\t}\n-\t\t\telse if (value instanceof Comment){\n-\t\t\t\tComment comment = (Comment)((Comment)value).clone();\n-\t\t\t\telement.addContent(comment);\n-\t\t\t}\n-        \telse {\n-\t            String string = (String)TypeUtils.convert(value, String.class);\n-\t            if (string != null && !string.equals(\"\")){\n-\t                element.addContent(new Text(string));\n-\t            }\n-        \t}\n+            Element element = (Element)node;\n+            element.getContent().clear();\n+                        \n+            if (value instanceof Element){\n+                Element valueElement = (Element)value;\n+                addContent(valueElement.getContent());\n+            }\n+            else if (value instanceof Document){\n+                Document valueDocument = (Document)value;                \n+                addContent(valueDocument.getContent());\n+            }\n+            else if (value instanceof Text ||\n+                     value instanceof CDATA){\n+                String string = ((Text)value).getText();\n+                element.addContent(new Text(string));\n+            }\n+            else if (value instanceof ProcessingInstruction){\n+                ProcessingInstruction pi = (ProcessingInstruction)\n+                        ((ProcessingInstruction)value).clone();\n+                element.addContent(pi);\n+            }\n+            else if (value instanceof Comment){\n+                Comment comment = (Comment)((Comment)value).clone();\n+                element.addContent(comment);\n+            }\n+            else {\n+                String string = (String)TypeUtils.convert(value, String.class);\n+                if (string != null && !string.equals(\"\")){\n+                    element.addContent(new Text(string));\n+                }\n+            }\n         }\n     }\n     \n     private void addContent(List content){\n-    \tElement element = (Element)node;\n-    \tint count = content.size();\n-    \t\n-    \tfor (int i = 0; i < count; i++){\n-    \t\tObject child = content.get(i);\n-    \t\tif (child instanceof Element){\n-    \t\t\tchild = ((Element)child).clone();\n-    \t\t\telement.addContent((Element)child);\n-    \t\t}\n-\t        else if (child instanceof Text){\n-    \t\t\tchild = ((Text)child).clone();\n-    \t\t\telement.addContent((Text)child);\n-\t        }\n-\t        else if (node instanceof CDATA){\n-    \t\t\tchild = ((CDATA)child).clone();\n-    \t\t\telement.addContent((CDATA)child);\n-\t        }\n-\t        else if (node instanceof ProcessingInstruction){\n-    \t\t\tchild = ((ProcessingInstruction)child).clone();\n-    \t\t\telement.addContent((ProcessingInstruction)child);\n-\t        }\n-\t        else if (node instanceof Comment){\n-    \t\t\tchild = ((Comment)child).clone();\n-    \t\t\telement.addContent((Comment)child);\n-\t        }\n-    \t}\n+        Element element = (Element)node;\n+        int count = content.size();\n+        \n+        for (int i = 0; i < count; i++){\n+            Object child = content.get(i);\n+            if (child instanceof Element){\n+                child = ((Element)child).clone();\n+                element.addContent((Element)child);\n+            }\n+            else if (child instanceof Text){\n+                child = ((Text)child).clone();\n+                element.addContent((Text)child);\n+            }\n+            else if (node instanceof CDATA){\n+                child = ((CDATA)child).clone();\n+                element.addContent((CDATA)child);\n+            }\n+            else if (node instanceof ProcessingInstruction){\n+                child = ((ProcessingInstruction)child).clone();\n+                element.addContent((ProcessingInstruction)child);\n+            }\n+            else if (node instanceof Comment){\n+                child = ((Comment)child).clone();\n+                element.addContent((Comment)child);\n+            }\n+        }\n     }\n     \n     public boolean testNode(NodeTest test){\n     }\n \n     public NodePointer createAttribute(JXPathContext context, QName name){\n-\t\tif (!(node instanceof Element)) {\n-\t\t\treturn super.createAttribute(context, name);\n-\t\t}\n-\n-\t\tElement element = (Element) node;\n-\t\tString prefix = name.getPrefix();\n-\t\tif (prefix != null) {\n-\t\t\tNamespace ns = element.getNamespace(prefix);\n-\t\t\tif (ns == null) {\n-\t\t\t\tthrow new JXPathException(\n-\t\t\t\t\t\"Unknown namespace prefix: \" + prefix);\n-\t\t\t}\n-\t\t\tAttribute attr = element.getAttribute(name.getName(), ns);\n-\t\t\tif (attr == null) {\n-\t\t\t\telement.setAttribute(name.getName(), \"\", ns);\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tAttribute attr = element.getAttribute(name.getName());\n-\t\t\tif (attr == null) {\n-\t\t\t\telement.setAttribute(name.getName(), \"\");\n-\t\t\t}\n-\t\t}\n-\t\tNodeIterator it = attributeIterator(name);\n-\t\tit.setPosition(1);\n-\t\treturn it.getNodePointer();\n+        if (!(node instanceof Element)) {\n+            return super.createAttribute(context, name);\n+        }\n+\n+        Element element = (Element) node;\n+        String prefix = name.getPrefix();\n+        if (prefix != null) {\n+            Namespace ns = element.getNamespace(prefix);\n+            if (ns == null) {\n+                throw new JXPathException(\n+                    \"Unknown namespace prefix: \" + prefix);\n+            }\n+            Attribute attr = element.getAttribute(name.getName(), ns);\n+            if (attr == null) {\n+                element.setAttribute(name.getName(), \"\", ns);\n+            }\n+        }\n+        else {\n+            Attribute attr = element.getAttribute(name.getName());\n+            if (attr == null) {\n+                element.setAttribute(name.getName(), \"\");\n+            }\n+        }\n+        NodeIterator it = attributeIterator(name);\n+        it.setPosition(1);\n+        return it.getNodePointer();\n     }\n \n     public void remove(){\n             if (parent instanceof JDOMNodePointer){\n                 if (buffer.length() == 0 ||\n                         buffer.charAt(buffer.length()-1) != '/'){\n-                \tbuffer.append('/');\n+                    buffer.append('/');\n                 }\n                 buffer.append(getName());\n                 buffer.append('[');\n     }\n \n     private int getRelativePositionOfPI(String target){\n-\t\tElement parent = ((ProcessingInstruction) node).getParent();\n-\t\tif (parent == null) {\n-\t\t\treturn 1;\n-\t\t}\n-\t\tList children = parent.getContent();\n-\t\tint count = 0;\n-\t\tfor (int i = 0; i < children.size(); i++) {\n-\t\t\tObject child = children.get(i);\n-\t\t\tif (child instanceof ProcessingInstruction\n-\t\t\t\t&& (target == null\n-\t\t\t\t\t|| target.equals(\n-\t\t\t\t\t\t((ProcessingInstruction) child).getTarget()))) {\n-\t\t\t\tcount++;\n-\t\t\t}\n-\t\t\tif (child == node) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn count;\n+        Element parent = ((ProcessingInstruction) node).getParent();\n+        if (parent == null) {\n+            return 1;\n+        }\n+        List children = parent.getContent();\n+        int count = 0;\n+        for (int i = 0; i < children.size(); i++) {\n+            Object child = children.get(i);\n+            if (child instanceof ProcessingInstruction\n+                && (target == null\n+                    || target.equals(\n+                        ((ProcessingInstruction) child).getTarget()))) {\n+                count++;\n+            }\n+            if (child == node) {\n+                break;\n+            }\n+        }\n+        return count;\n     }\n \n     public int hashCode(){\n         return node == other.node;\n     }\n \n-\tprivate AbstractFactory getAbstractFactory(JXPathContext context) {\n-\t\tAbstractFactory factory = context.getFactory();\n-\t\tif (factory == null) {\n-\t\t\tthrow new JXPathException(\n-\t\t\t\t\"Factory is not set on the JXPathContext - cannot create path: \"\n-\t\t\t\t\t+ asPath());\n-\t\t}\n-\t\treturn factory;\n-\t}\n+    private AbstractFactory getAbstractFactory(JXPathContext context) {\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null) {\n+            throw new JXPathException(\n+                \"Factory is not set on the JXPathContext - cannot create path: \"\n+                    + asPath());\n+        }\n+        return factory;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.10 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.11 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Collection and property access utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.11 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class ValueUtils {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n         }\n \n         // Check the implemented interfaces and subinterfaces\n-\t\tmethod =\n-\t\t\tgetAccessibleMethodFromInterfaceNest(\n-\t\t\t\tclazz,\n-\t\t\t\tmethod.getName(),\n-\t\t\t\tmethod.getParameterTypes());\n+        method =\n+            getAccessibleMethodFromInterfaceNest(\n+                clazz,\n+                method.getName(),\n+                method.getParameterTypes());\n         return (method);\n     }\n \n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.2 2002/10/20 04:00:21 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 04:00:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.3 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test extension functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 04:00:21 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:34 $\n  */\n \n public class ExtensionFunctionTest extends JXPathTestCase\n             lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n             lib.addFunctions(\n                     new PackageFunctions(\n-                    \t\t\"org.apache.commons.jxpath.ri.compiler.\", \n+                            \"org.apache.commons.jxpath.ri.compiler.\", \n                             \"jxpathtest\"));\n             context.setFunctions(lib);\n         }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.2 2002/11/26 01:33:34 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:33:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:33:34 $\n  */\n public class TestFunctions {\n \n \n     public TestFunctions(ExpressionContext context, String bar){\n         this.foo = ((Number)context.getContextNodePointer().getValue()).\n-        \t\tintValue();\n+                intValue();\n         this.bar = bar;\n     }\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n  */\n \n public abstract class BeanModelTestCase extends JXPathTestCase\n     private void testIndividual(int relativePropertyIndex, int offset,\n                 boolean useStartLocation, boolean reverse, int expected)\n     {\n-\t\tPropertyOwnerPointer root =\n-\t\t\t(PropertyOwnerPointer) NodePointer.newNodePointer(\n-\t\t\t\tnew QName(null, \"root\"),\n-\t\t\t\tcreateContextBean(),\n-\t\t\t\tLocale.getDefault());\n-\n-\t\tNodeIterator it;\n-\n-\t\tPropertyPointer start = null;\n-\n-\t\tif (useStartLocation) {\n-\t\t\tstart = root.getPropertyPointer();\n-\t\t\tstart.setPropertyIndex(\n-\t\t\t\trelativeProperty(start, relativePropertyIndex));\n-\t\t\tstart.setIndex(offset);\n-\t\t}\n-\t\tit =\n-\t\t\troot.childIterator(\n-\t\t\t\tnew NodeNameTest(new QName(null, \"integers\")),\n-\t\t\t\treverse,\n-\t\t\t\tstart);\n-\n-\t\tint size = 0;\n-\t\twhile (it.setPosition(it.getPosition() + 1)) {\n-\t\t\tsize++;\n-\t\t}\n-\t\tassertEquals(\n-\t\t\t\"ITERATIONS: Individual, relativePropertyIndex=\"\n-\t\t\t\t+ relativePropertyIndex\n-\t\t\t\t+ \", offset=\"\n-\t\t\t\t+ offset\n-\t\t\t\t+ \", useStartLocation=\"\n-\t\t\t\t+ useStartLocation\n-\t\t\t\t+ \", reverse=\"\n-\t\t\t\t+ reverse,\n-\t\t\texpected,\n-\t\t\tsize);\n+        PropertyOwnerPointer root =\n+            (PropertyOwnerPointer) NodePointer.newNodePointer(\n+                new QName(null, \"root\"),\n+                createContextBean(),\n+                Locale.getDefault());\n+\n+        NodeIterator it;\n+\n+        PropertyPointer start = null;\n+\n+        if (useStartLocation) {\n+            start = root.getPropertyPointer();\n+            start.setPropertyIndex(\n+                relativeProperty(start, relativePropertyIndex));\n+            start.setIndex(offset);\n+        }\n+        it =\n+            root.childIterator(\n+                new NodeNameTest(new QName(null, \"integers\")),\n+                reverse,\n+                start);\n+\n+        int size = 0;\n+        while (it.setPosition(it.getPosition() + 1)) {\n+            size++;\n+        }\n+        assertEquals(\n+            \"ITERATIONS: Individual, relativePropertyIndex=\"\n+                + relativePropertyIndex\n+                + \", offset=\"\n+                + offset\n+                + \", useStartLocation=\"\n+                + useStartLocation\n+                + \", reverse=\"\n+                + reverse,\n+            expected,\n+            size);\n     }\n \n     /**\n     }\n \n     public void testIteratePropertyArrayWithHasNext(){\n-\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n-\t\tIterator it = context.iteratePointers(\"/integers\");\n-\t\tList actual = new ArrayList();\n-\t\twhile (it.hasNext()) {\n-\t\t\tactual.add(((Pointer) it.next()).asPath());\n-\t\t}\n-\t\tassertEquals(\n-\t\t\t\"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n-\t\t\tlist(\n-\t\t\t\t\"/integers[1]\",\n-\t\t\t\t\"/integers[2]\",\n-\t\t\t\t\"/integers[3]\",\n-\t\t\t\t\"/integers[4]\"),\n-\t\t\tactual);\n-    }\n-\n-\tpublic void testIteratePropertyArrayWithoutHasNext() {\n-\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n-\t\tIterator it = context.iteratePointers(\"/integers\");\n-\t\tList actual = new ArrayList();\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tactual.add(it.next().toString());\n-\t\t}\n-\t\tassertEquals(\n-\t\t\t\"Iterating 'next'<\" + \"/integers\" + \">\",\n-\t\t\tlist(\n-\t\t\t\t\"/integers[1]\",\n-\t\t\t\t\"/integers[2]\",\n-\t\t\t\t\"/integers[3]\",\n-\t\t\t\t\"/integers[4]\"),\n-\t\t\tactual);\n-\t}\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()) {\n+            actual.add(((Pointer) it.next()).asPath());\n+        }\n+        assertEquals(\n+            \"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n+            list(\n+                \"/integers[1]\",\n+                \"/integers[2]\",\n+                \"/integers[3]\",\n+                \"/integers[4]\"),\n+            actual);\n+    }\n+\n+    public void testIteratePropertyArrayWithoutHasNext() {\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        for (int i = 0; i < 4; i++) {\n+            actual.add(it.next().toString());\n+        }\n+        assertEquals(\n+            \"Iterating 'next'<\" + \"/integers\" + \">\",\n+            list(\n+                \"/integers[1]\",\n+                \"/integers[2]\",\n+                \"/integers[3]\",\n+                \"/integers[4]\"),\n+            actual);\n+    }\n \n     public void testIterateAndSet(){\n         JXPathContext context = JXPathContext.newContext(createContextBean());\n     /**\n      * Test contributed by Kate Dvortsova\n      */\n-\tpublic void testIteratePointerSetValue() {\n-\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n-\n-\t\tassertXPathValue(context, \"/beans[1]/name\", \"Name 1\");\n-\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n-\n-\t\t// Test setting via context\n-\t\tcontext.setValue(\"/beans[2]/name\", \"Name 2 set\");\n-\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2 set\");\n-\n-\t\t// Restore original value\n-\t\tcontext.setValue(\"/beans[2]/name\", \"Name 2\");\n-\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n-\n-\t\tint iter_count = 0;\n-\t\tIterator iter = context.iteratePointers(\"/beans/name\");\n-\t\twhile (iter.hasNext()) {\n-\t\t\titer_count++;\n-\t\t\tPointer pointer = (Pointer) iter.next();\n-\t\t\tString s = (String) pointer.getValue();\n-\t\t\ts = s + \"suffix\";\n-\t\t\tpointer.setValue(s);\n-\t\t\tassertEquals(\"pointer.getValue\", s, pointer.getValue());\n-\t\t\t// fails right here, the value isn't getting set in the bean.\n-\t\t\tassertEquals(\n-\t\t\t\t\"context.getValue\",\n-\t\t\t\ts,\n-\t\t\t\tcontext.getValue(pointer.asPath()));\n-\t\t}\n-\t\tassertEquals(\"Iteration count\", 2, iter_count);\n-\n-\t\tassertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n-\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n-\t}\n+    public void testIteratePointerSetValue() {\n+        JXPathContext context = JXPathContext.newContext(createContextBean());\n+\n+        assertXPathValue(context, \"/beans[1]/name\", \"Name 1\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+        // Test setting via context\n+        context.setValue(\"/beans[2]/name\", \"Name 2 set\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2 set\");\n+\n+        // Restore original value\n+        context.setValue(\"/beans[2]/name\", \"Name 2\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+        int iter_count = 0;\n+        Iterator iter = context.iteratePointers(\"/beans/name\");\n+        while (iter.hasNext()) {\n+            iter_count++;\n+            Pointer pointer = (Pointer) iter.next();\n+            String s = (String) pointer.getValue();\n+            s = s + \"suffix\";\n+            pointer.setValue(s);\n+            assertEquals(\"pointer.getValue\", s, pointer.getValue());\n+            // fails right here, the value isn't getting set in the bean.\n+            assertEquals(\n+                \"context.getValue\",\n+                s,\n+                context.getValue(pointer.asPath()));\n+        }\n+        assertEquals(\"Iteration count\", 2, iter_count);\n+\n+        assertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n+        assertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n+    }\n \n     public void testRoot(){\n         assertXPathValueAndPointer(context,\n                 \"/nestedBean/int\");\n     }\n \n-\tpublic void testAttributeLang() {\n-\n-\t\tassertXPathValue(context, \n+    public void testAttributeLang() {\n+\n+        assertXPathValue(context, \n             \"@xml:lang\", \n             \"en-US\");\n \n-\t\tassertXPathValue(context, \n+        assertXPathValue(context, \n             \"count(@xml:*)\", \n             new Double(1));\n \n-\t\tassertXPathValue(context, \n+        assertXPathValue(context, \n             \"lang('en')\", \n             Boolean.TRUE);\n             \n-\t\tassertXPathValue(context, \n+        assertXPathValue(context, \n             \"lang('fr')\", \n             Boolean.FALSE);\n             \n-\t\tassertXPathValueIterator(\n-\t\t\tcontext,\n-\t\t\t\"beans[1]/strings[string-length() = 8]\",\n-\t\t\tlist(\"String 1\", \"String 2\", \"String 3\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[1]/strings[string-length() = 8]\",\n+            list(\"String 1\", \"String 2\", \"String 3\"));\n             \n-\t\tassertXPathValue(context, \n+        assertXPathValue(context, \n             \"boolean(boolean)\", \n             Boolean.FALSE);\n             \n-\t\tassertXPathValue(\n-\t\t\tcontext,\n-\t\t\t\"boolean(integers[position() < 3])\",\n-\t\t\tBoolean.TRUE);\n+        assertXPathValue(\n+            context,\n+            \"boolean(integers[position() < 3])\",\n+            Boolean.TRUE);\n             \n-\t\tassertXPathValue(\n-\t\t\tcontext,\n-\t\t\t\"boolean(integers[position() > 4])\",\n-\t\t\tBoolean.FALSE);\n+        assertXPathValue(\n+            context,\n+            \"boolean(integers[position() > 4])\",\n+            Boolean.FALSE);\n             \n-\t\tassertXPathValue(context, \n+        assertXPathValue(context, \n             \"sum(integers)\", \n             new Double(10));\n-\t}\n+    }\n \n     public void testBooleanPredicate(){\n         // use child axis\n--- a/src/test/org/apache/commons/jxpath/ri/model/TestDynamicPropertyFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestDynamicPropertyFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/Attic/TestDynamicPropertyFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/Attic/TestDynamicPropertyFactory.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n  */\n public class TestDynamicPropertyFactory extends AbstractFactory {\n \n      * Create a new instance and put it in the collection on the parent object.\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-\tpublic boolean createObject(\n-    \t\tJXPathContext context,\n-    \t\tPointer pointer,\n-    \t\tObject parent,\n-    \t\tString name,\n-    \t\tint index) \n+    public boolean createObject(\n+            JXPathContext context,\n+            Pointer pointer,\n+            Object parent,\n+            String name,\n+            int index) \n     {\n-\t\tif (name.equals(\"map\")) {\n-\t\t\t((TestBean) parent).setMap(new HashMap());\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"TestKey1\")) {\n-\t\t\t((Map) parent).put(name, \"\");\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"TestKey2\")) {\n-\t\t\t((Map) parent).put(name, new NestedTestBean(\"newName\"));\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"TestKey3\")) {\n-\t\t\tVector v = new Vector();\n-\t\t\tfor (int i = 0; i <= index; i++) {\n-\t\t\t\tv.add(null);\n-\t\t\t}\n-\t\t\t((Map) parent).put(name, v);\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"TestKey4\")) {\n-\t\t\t((Map) parent).put(name, new Object[] { new TestBean()});\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n+        if (name.equals(\"map\")) {\n+            ((TestBean) parent).setMap(new HashMap());\n+            return true;\n+        } else if (name.equals(\"TestKey1\")) {\n+            ((Map) parent).put(name, \"\");\n+            return true;\n+        } else if (name.equals(\"TestKey2\")) {\n+            ((Map) parent).put(name, new NestedTestBean(\"newName\"));\n+            return true;\n+        } else if (name.equals(\"TestKey3\")) {\n+            Vector v = new Vector();\n+            for (int i = 0; i <= index; i++) {\n+                v.add(null);\n+            }\n+            ((Map) parent).put(name, v);\n+            return true;\n+        } else if (name.equals(\"TestKey4\")) {\n+            ((Map) parent).put(name, new Object[] { new TestBean()});\n+            return true;\n+        }\n+        return false;\n+    }\n \n     public boolean declareVariable(JXPathContext context, String name){\n         return false;\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.3 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.4 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:35 $\n  */\n \n public abstract class XMLModelTestCase extends JXPathTestCase\n         return context;\n     }\n \n-\t/**\n-\t * An XML signature is used to determine if we have the right result\n-\t * after a modification of XML by JXPath.  It is basically a piece\n-\t * of simplified XML.\n-\t */    \n+    /**\n+     * An XML signature is used to determine if we have the right result\n+     * after a modification of XML by JXPath.  It is basically a piece\n+     * of simplified XML.\n+     */    \n     protected abstract String getXMLSignature(Object node, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi);\n-\n-\tprotected void assertXMLSignature(JXPathContext context,\n-\t\t\tString path, String signature,\n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n-\t{\n-\t\tObject node = context.getPointer(path).getNode();\n-\t\tString sig = getXMLSignature(node, elements, attributes, text, pi);\n-\t\tassertEquals(\"XML Signature mismatch: \", signature, sig);\n-\t}\n-\t\n+            boolean elements, boolean attributes, boolean text, boolean pi);\n+\n+    protected void assertXMLSignature(JXPathContext context,\n+            String path, String signature,\n+            boolean elements, boolean attributes, boolean text, boolean pi)\n+    {\n+        Object node = context.getPointer(path).getNode();\n+        String sig = getXMLSignature(node, elements, attributes, text, pi);\n+        assertEquals(\"XML Signature mismatch: \", signature, sig);\n+    }\n+    \n     // ------------------------------------------------ Individual Test Methods\n \n     public void testDocumentOrder(){\n                 1);\n     }\n \n-\tpublic void testSetValue(){\n-\t\tassertXPathSetValue(context,\n-\t\t\t\t\"vendor/location[@id = '100']\",\n-\t\t\t\t\"New Text\");\n-\t\t\n-\t\tassertXMLSignature(context,\n-\t\t\t\t\"vendor/location[@id = '100']\",\n-\t\t\t\t\"<E>New Text</E>\",\n-\t\t\t\tfalse, false, true, false);\n-\t\t\t\t\n-\t\tassertXPathSetValue(context,\n-\t\t\t\t\"vendor/location[@id = '101']\",\n-\t\t\t\t\"Replacement Text\");\n-\n-\t\tassertXMLSignature(context,\n-\t\t\t\t\"vendor/location[@id = '101']\",\n-\t\t\t\t\"<E>Replacement Text</E>\",\n-\t\t\t\tfalse, false, true, false);\t\t\t\t\n-\t}\n-\t\n+    public void testSetValue(){\n+        assertXPathSetValue(context,\n+                \"vendor/location[@id = '100']\",\n+                \"New Text\");\n+        \n+        assertXMLSignature(context,\n+                \"vendor/location[@id = '100']\",\n+                \"<E>New Text</E>\",\n+                false, false, true, false);\n+                \n+        assertXPathSetValue(context,\n+                \"vendor/location[@id = '101']\",\n+                \"Replacement Text\");\n+\n+        assertXMLSignature(context,\n+                \"vendor/location[@id = '101']\",\n+                \"<E>Replacement Text</E>\",\n+                false, false, true, false);                \n+    }\n+    \n     /**\n      * Test JXPathContext.createPath() with various arguments\n      */\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n  */\n public class TestBeanFactory extends AbstractFactory {\n \n     public boolean createObject(JXPathContext context, \n                 Pointer pointer, Object parent, String name, int index)\n     {\n-\t\tif (name.equals(\"nestedBean\")) {\n-\t\t\t((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"beans\")) {\n-\t\t\tTestBean bean = (TestBean) parent;\n-\t\t\tif (bean.getBeans() == null || index >= bean.getBeans().length) {\n-\t\t\t\tbean.setBeans(new NestedTestBean[index + 1]);\n-\t\t\t}\n-\t\t\t((TestBean) parent).getBeans()[index] =\n-\t\t\t\tnew NestedTestBean(\"newName\");\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;   }\n+        if (name.equals(\"nestedBean\")) {\n+            ((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n+            return true;\n+        } else if (name.equals(\"beans\")) {\n+            TestBean bean = (TestBean) parent;\n+            if (bean.getBeans() == null || index >= bean.getBeans().length) {\n+                bean.setBeans(new NestedTestBean[index + 1]);\n+            }\n+            ((TestBean) parent).getBeans()[index] =\n+                new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        return false;   }\n \n     /**\n      * Create a new object and set it on the specified variable\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.4 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.5 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with DOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.5 $ $Date: 2002/11/26 01:33:35 $\n  */\n \n public class DOMModelTest extends XMLModelTestCase\n     }\n     \n     protected String getXMLSignature(Object node, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n-    \tStringBuffer buffer = new StringBuffer();\n-    \tappendXMLSignature(buffer, node, elements, attributes, text, pi);\n-    \treturn buffer.toString();\n+            boolean elements, boolean attributes, boolean text, boolean pi){\n+        StringBuffer buffer = new StringBuffer();\n+        appendXMLSignature(buffer, node, elements, attributes, text, pi);\n+        return buffer.toString();\n     }\n     \n     private void appendXMLSignature(StringBuffer buffer, Object object, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n-    \tNode node = (Node)object;\n-    \tint type = node.getNodeType();\n-    \tswitch (type){\n-    \t\tcase Node.DOCUMENT_NODE:\n-    \t\t\tbuffer.append(\"<D>\");\n-    \t\t\tappendXMLSignature(buffer, node.getChildNodes(), \n-    \t\t\t\t\telements, attributes, text, pi);\n-    \t\t\tbuffer.append(\"</D\");\n-    \t\t\tbreak;\n-    \t\t\t\n-    \t\tcase Node.ELEMENT_NODE:\n-    \t\t\tString tag = elements ? ((Element)node).getTagName() : \"E\";\n-\t\t\t\tbuffer.append(\"<\");\n-\t\t\t\tbuffer.append(tag);\n-\t\t\t\tbuffer.append(\">\");\n-    \t\t\tappendXMLSignature(buffer, node.getChildNodes(), \n-    \t\t\t\t\telements, attributes, text, pi);\n-\t\t\t\tbuffer.append(\"</\");\n-\t\t\t\tbuffer.append(tag);\n-\t\t\t\tbuffer.append(\">\");    \t\t\t\t\n-\t\t\t\tbreak;\n-\t\t\t\t\n-    \t\tcase Node.TEXT_NODE:\n-    \t\tcase Node.CDATA_SECTION_NODE:\n-    \t\t\tif (text){\n-    \t\t\t\tString string = node.getNodeValue();\n-    \t\t\t\tstring = string.replace('\\n', '=');\n-    \t\t\t\tbuffer.append(string);\n-    \t\t\t}\n-\t\t\t\tbreak;\n-    \t}\n-\t}\n-\t\n+            boolean elements, boolean attributes, boolean text, boolean pi){\n+        Node node = (Node)object;\n+        int type = node.getNodeType();\n+        switch (type){\n+            case Node.DOCUMENT_NODE:\n+                buffer.append(\"<D>\");\n+                appendXMLSignature(buffer, node.getChildNodes(), \n+                        elements, attributes, text, pi);\n+                buffer.append(\"</D\");\n+                break;\n+                \n+            case Node.ELEMENT_NODE:\n+                String tag = elements ? ((Element)node).getTagName() : \"E\";\n+                buffer.append(\"<\");\n+                buffer.append(tag);\n+                buffer.append(\">\");\n+                appendXMLSignature(buffer, node.getChildNodes(), \n+                        elements, attributes, text, pi);\n+                buffer.append(\"</\");\n+                buffer.append(tag);\n+                buffer.append(\">\");                    \n+                break;\n+                \n+            case Node.TEXT_NODE:\n+            case Node.CDATA_SECTION_NODE:\n+                if (text){\n+                    String string = node.getNodeValue();\n+                    string = string.replace('\\n', '=');\n+                    buffer.append(string);\n+                }\n+                break;\n+        }\n+    }\n+    \n     private void appendXMLSignature(StringBuffer buffer, NodeList children, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n+            boolean elements, boolean attributes, boolean text, boolean pi)\n     {\n-    \tfor (int i = 0; i < children.getLength(); i++){\n-\t\t\tappendXMLSignature(buffer, children.item(i), \n-\t\t\t\t\telements, attributes, text, pi);\n-    \t}\n-\t}\n+        for (int i = 0; i < children.getLength(); i++){\n+            appendXMLSignature(buffer, children.item(i), \n+                    elements, attributes, text, pi);\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n  */\n public class TestDynaBeanFactory extends AbstractFactory {\n \n     /**\n      */\n-\tpublic boolean createObject(\n-    \t\tJXPathContext context,\n-    \t\tPointer pointer,\n-    \t\tObject parent,\n-    \t\tString name,\n-    \t\tint index) \n+    public boolean createObject(\n+            JXPathContext context,\n+            Pointer pointer,\n+            Object parent,\n+            String name,\n+            int index) \n     {\n-\t\tif (name.equals(\"nestedBean\")) {\n-\t\t\t((DynaBean) parent).set(\n-\t\t\t\t\"nestedBean\",\n-\t\t\t\tnew NestedTestBean(\"newName\"));\n-\t\t\treturn true;\n-\t\t} else if (name.equals(\"beans\")) {\n-\t\t\tDynaBean bean = (DynaBean) parent;\n-\t\t\tObject beans[] = (Object[]) bean.get(\"beans\");\n-\t\t\tif (beans == null || index >= beans.length) {\n-\t\t\t\tbeans = new NestedTestBean[index + 1];\n-\t\t\t\tbean.set(\"beans\", beans);\n-\t\t\t}\n-\t\t\tbeans[index] = new NestedTestBean(\"newName\");\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n+        if (name.equals(\"nestedBean\")) {\n+            ((DynaBean) parent).set(\n+                \"nestedBean\",\n+                new NestedTestBean(\"newName\"));\n+            return true;\n+        } else if (name.equals(\"beans\")) {\n+            DynaBean bean = (DynaBean) parent;\n+            Object beans[] = (Object[]) bean.get(\"beans\");\n+            if (beans == null || index >= beans.length) {\n+                beans = new NestedTestBean[index + 1];\n+                bean.set(\"beans\", beans);\n+            }\n+            beans[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        return false;\n+    }\n \n \n     /**\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.4 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.5 2002/11/26 01:33:35 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/11/26 01:33:35 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with JDOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.5 $ $Date: 2002/11/26 01:33:35 $\n  */\n \n public class JDOMModelTest extends XMLModelTestCase\n     }\n     \n     protected String getXMLSignature(Object node, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n-    \tStringBuffer buffer = new StringBuffer();\n-    \tappendXMLSignature(buffer, node, elements, attributes, text, pi);\n-    \treturn buffer.toString();\n+            boolean elements, boolean attributes, boolean text, boolean pi){\n+        StringBuffer buffer = new StringBuffer();\n+        appendXMLSignature(buffer, node, elements, attributes, text, pi);\n+        return buffer.toString();\n     }\n     \n     private void appendXMLSignature(StringBuffer buffer, Object object, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi){\n-    \tif (object instanceof Document){\n-\t\t\tbuffer.append(\"<D>\");\n-\t\t\tappendXMLSignature(buffer, ((Document)object).getContent(), \n-\t\t\t\t\telements, attributes, text, pi);\n-\t\t\tbuffer.append(\"</D\");\n-    \t}\n-    \telse if (object instanceof Element){\n-\t\t\tString tag = elements ? ((Element)object).getName() : \"E\";\n-\t\t\tbuffer.append(\"<\");\n-\t\t\tbuffer.append(tag);\n-\t\t\tbuffer.append(\">\");\n-\t\t\tappendXMLSignature(buffer, ((Element)object).getContent(), \n-\t\t\t\t\telements, attributes, text, pi);\n-\t\t\tbuffer.append(\"</\");\n-\t\t\tbuffer.append(tag);\n-\t\t\tbuffer.append(\">\");    \t\t\t\t\n-    \t}\n-    \telse if (object instanceof Text || object instanceof CDATA){\n-\t\t\tif (text){\n-\t\t\t\tString string = ((Text)object).getText();\n-\t\t\t\tstring = string.replace('\\n', '=');\n-\t\t\t\tbuffer.append(string);\n-\t\t\t}\n-    \t}\n-\t}\n-\t\n+            boolean elements, boolean attributes, boolean text, boolean pi){\n+        if (object instanceof Document){\n+            buffer.append(\"<D>\");\n+            appendXMLSignature(buffer, ((Document)object).getContent(), \n+                    elements, attributes, text, pi);\n+            buffer.append(\"</D\");\n+        }\n+        else if (object instanceof Element){\n+            String tag = elements ? ((Element)object).getName() : \"E\";\n+            buffer.append(\"<\");\n+            buffer.append(tag);\n+            buffer.append(\">\");\n+            appendXMLSignature(buffer, ((Element)object).getContent(), \n+                    elements, attributes, text, pi);\n+            buffer.append(\"</\");\n+            buffer.append(tag);\n+            buffer.append(\">\");                 \n+        }\n+        else if (object instanceof Text || object instanceof CDATA){\n+            if (text){\n+                String string = ((Text)object).getText();\n+                string = string.replace('\\n', '=');\n+                buffer.append(string);\n+            }\n+        }\n+    }\n+    \n     private void appendXMLSignature(StringBuffer buffer, List children, \n-    \t\tboolean elements, boolean attributes, boolean text, boolean pi)\n+            boolean elements, boolean attributes, boolean text, boolean pi)\n     {\n-    \tfor (int i = 0; i < children.size(); i++){\n-\t\t\tappendXMLSignature(buffer, children.get(i), \n-\t\t\t\t\telements, attributes, text, pi);\n-    \t}\n-\t}  \n+        for (int i = 0; i < children.size(); i++){\n+            appendXMLSignature(buffer, children.get(i), \n+                    elements, attributes, text, pi);\n+        }\n+    }  \n }", "timestamp": 1038274415, "metainfo": ""}