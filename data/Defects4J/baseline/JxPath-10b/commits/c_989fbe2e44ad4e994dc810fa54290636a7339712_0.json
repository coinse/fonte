{"sha": "989fbe2e44ad4e994dc810fa54290636a7339712", "log": "Simplified ExpressionContext implementation   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.8 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.9 2002/04/24 03:32:48 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/04/24 03:32:48 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.9 $ $Date: 2002/04/24 03:32:48 $\n  */\n-public abstract class EvalContext {\n+public abstract class EvalContext implements ExpressionContext {\n     protected EvalContext parentContext;\n     protected RootContext rootContext;\n     protected int position = 0;\n     private boolean startedSetIteration = false;\n-    private EvalExpressionContext expressionContext;\n \n     public EvalContext(EvalContext parentContext){\n         this.parentContext = parentContext;\n     }\n \n-    public class EvalExpressionContext implements ExpressionContext {\n-        public Pointer getContextNodePointer(){\n-            return getCurrentNodePointer();\n-        }\n-\n-        public JXPathContext getJXPathContext(){\n-            return getRootContext().getJXPathContext();\n-        }\n-\n-        public int getPosition(){\n-            return position;\n-        }\n-\n-        public List getContextNodeList(){\n-            int pos = position;\n-            if (pos != 0){\n-                reset();\n-            }\n-            List list = new ArrayList();\n-            while(next()){\n-                list.add(getCurrentNodePointer());\n-            }\n-            if (pos != 0){\n-                setPosition(pos);\n-            }\n-            else {\n-                reset();\n-            }\n-            return list;\n-        }\n-\n-        public String toString(){\n-            Pointer ptr = getContextNodePointer();\n-            if (ptr == null){\n-                return \"Empty expression context\";\n-            }\n-            else {\n-                return \"Expression context [\" + getPosition() + \"] \" + ptr.asPath();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Produces an ExpressionContext that when it needs to pass one to\n-     * an extenstion function.\n-     */\n-    public ExpressionContext getExpressionContext(){\n-        if (expressionContext == null){\n-            expressionContext = new EvalExpressionContext();\n-        }\n-        return expressionContext;\n-    }\n-\n+    public Pointer getContextNodePointer(){\n+        return getCurrentNodePointer();\n+    }\n+\n+    public JXPathContext getJXPathContext(){\n+        return getRootContext().getJXPathContext();\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    /**\n+     * Returns the list of all Pointers in this context\n+     */\n+    public List getContextNodeList() {\n+        int pos = position;\n+        if (pos != 0) {\n+            reset();\n+        }\n+        List list = new ArrayList();\n+        while (next()) {\n+            list.add(getCurrentNodePointer());\n+        }\n+        if (pos != 0) {\n+            setPosition(pos);\n+        }\n+        else {\n+            reset();\n+        }\n+        return list;\n+    }\n+\n+    public String toString() {\n+        Pointer ptr = getContextNodePointer();\n+        if (ptr == null) {\n+            return \"Empty expression context\";\n+        }\n+        else {\n+            return \"Expression context [\" + getPosition() + \"] \" + ptr.asPath();\n+        }\n+    }\n     /**\n      * Returns the root context of the path, which provides easy\n      * access to variables and functions.\n      * returns the first encountered Pointer that matches the current\n      * step's criteria.  Otherwise, returns the current pointer.\n      */\n-    public Pointer getContextNodePointer(){\n+    public Pointer getSingleNodePointer(){\n         reset();\n         while(nextSet()){\n             if (next()){\n     }\n \n     /**\n-     * Iterates through the current context collecting\n-     * pointers to all elements.\n-     */\n-    public List getContextNodeList(){\n-        List list = new ArrayList();\n-        while(nextSet()){\n-            while(next()){\n-                list.add(getCurrentNodePointer());\n-            }\n-        }\n-        return list;\n-    }\n-\n-    /**\n      * Returns the current context node. Undefined before the beginning\n      * of the iteration.\n      */\n      * Returns true if there is another sets of objects to interate over.\n      * Resets the current position and node.\n      */\n-    public boolean nextSet(){\n-        reset();     // Restart iteration within the set\n+    public boolean nextSet() {\n+        reset(); // Restart iteration within the set\n \n         // Most of the time you have one set per parent node\n         // First time this method is called, we should look for\n         // the first parent set that contains at least one node.\n-        if (!startedSetIteration){\n+        if (!startedSetIteration) {\n             startedSetIteration = true;\n-            while (parentContext.nextSet()){\n-                if (parentContext.next()){\n+            while (parentContext.nextSet()) {\n+                if (parentContext.next()) {\n                     return true;\n                 }\n             }\n \n         // In subsequent calls, we see if the parent context\n         // has any nodes left in the current set\n-        if (parentContext.next()){\n+        if (parentContext.next()) {\n             return true;\n         }\n \n         // If not, we look for the next set that contains\n         // at least one node\n-        while (parentContext.nextSet()){\n-            if (parentContext.next()){\n+        while (parentContext.nextSet()) {\n+            if (parentContext.next()) {\n                 return true;\n             }\n         }\n         return false;\n     }\n-\n     /**\n      * Returns true if there is another object in the current set.\n      * Switches the current position and node to the next object.\n         }\n \n         if (l instanceof EvalContext){\n-            l = ((EvalContext)l).getContextNodePointer();\n+            l = ((EvalContext)l).getSingleNodePointer();\n         }\n         if (r instanceof EvalContext){\n-            r = ((EvalContext)r).getContextNodePointer();\n+            r = ((EvalContext)r).getSingleNodePointer();\n         }\n \n         if (l instanceof Pointer && r instanceof Pointer){\n         }\n         else if (object instanceof EvalContext){\n             EvalContext ctx = (EvalContext)object;\n-            Pointer ptr = ctx.getContextNodePointer();\n+            Pointer ptr = ctx.getSingleNodePointer();\n             if (ptr != null){\n                 return stringValue(ptr);\n             }\n     private int indexFromPredicate(Expression predicate){\n         Object value = eval(predicate, true);\n         if (value instanceof EvalContext){\n-            value = ((EvalContext)value).getContextNodePointer();\n+            value = ((EvalContext)value).getSingleNodePointer();\n         }\n         if (value instanceof NodePointer){\n             value = ((NodePointer)value).getCanonicalValue();\n                 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) &&\n                 !(context instanceof UnionContext)){\n             EvalContext ctx = context;\n-            NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n+            NodePointer ptr = (NodePointer)ctx.getSingleNodePointer();\n             if (ptr != null &&\n                     (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n                      predicates == null || predicates.length == 0)){\n         if (firstMatch && steps.length != 0){\n             boolean basic = path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE);\n             if (basic){\n-                NodePointer ptr = (NodePointer)context.getContextNodePointer();\n+                NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n                 return interpretBasicPath(ptr, steps);\n             }\n         }\n         }\n \n         if (firstMatch){\n-            Pointer ptr = context.getContextNodePointer();\n+            Pointer ptr = context.getSingleNodePointer();\n //            System.err.println(\"GETTING CTX POINTER: \" + context + \" \" + ptr);\n             return ptr;\n         }\n             parameters = new Object[arguments.length];\n             for (int i = 0; i < arguments.length; i++){\n                 Object param = eval(arguments[i], false);\n-                if (param instanceof EvalContext){\n-                    param = ((EvalContext)param).getExpressionContext();\n-                }\n                 parameters[i] = param;\n             }\n         }\n                  Arrays.asList(parameters));\n         }\n \n-        return function.invoke(getExpressionContext(), parameters);\n+        return function.invoke(this, parameters);\n     }\n \n     /**\n     protected Object functionLang(CoreFunction function){\n         assertArgCount(function, 1);\n         String lang = stringValue(eval(function.getArg1()));\n-        NodePointer pointer = (NodePointer)getContextNodePointer();\n+        NodePointer pointer = (NodePointer)getSingleNodePointer();\n         if (pointer == null){\n             return Boolean.FALSE;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.9 2002/04/21 21:52:32 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/04/21 21:52:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.10 2002/04/24 03:32:48 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/04/24 03:32:48 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/04/21 21:52:32 $\n+ * @version $Revision: 1.10 $ $Date: 2002/04/24 03:32:48 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n         }\n     }\n \n-    private static void createNodeFactoryArray(){\n-        if (nodeFactoryArray == null){\n-            nodeFactoryArray = (NodePointerFactory[])nodeFactories.toArray(new NodePointerFactory[0]);\n-            Arrays.sort(nodeFactoryArray, new Comparator(){\n-                public int compare(Object a, Object b){\n-                    int orderA = ((NodePointerFactory)a).getOrder();\n-                    int orderB = ((NodePointerFactory)b).getOrder();\n+    private static void createNodeFactoryArray() {\n+        if (nodeFactoryArray == null) {\n+            nodeFactoryArray =\n+                (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[0]);\n+            Arrays.sort(nodeFactoryArray, new Comparator() {\n+                public int compare(Object a, Object b) {\n+                    int orderA = ((NodePointerFactory) a).getOrder();\n+                    int orderB = ((NodePointerFactory) b).getOrder();\n                     return orderA - orderB;\n                 }\n             });\n \n         if (result instanceof EvalContext){\n             EvalContext ctx = (EvalContext)result;\n-            result = ctx.getContextNodePointer();\n+            result = ctx.getSingleNodePointer();\n         }\n         if (result instanceof NodePointer){\n             result = ((NodePointer)result).getCanonicalValue();\n //        System.err.println(\"XPATH: \" + xpath);\n         Object result = eval(xpath, true);\n         if (result instanceof EvalContext){\n-            result = ((EvalContext)result).getContextNodePointer();\n+            result = ((EvalContext)result).getSingleNodePointer();\n         }\n         if (result instanceof Pointer){\n             return (Pointer)result;\n         }\n         else if (result instanceof EvalContext){\n             EvalContext ctx = (EvalContext)result;\n-            pointer = ctx.getContextNodePointer();\n+            pointer = ctx.getSingleNodePointer();\n         }\n         else {\n             // This should never happen\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/04/21 21:52:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.6 2002/04/24 03:32:48 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/04/24 03:32:48 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n+ * @version $Revision: 1.6 $ $Date: 2002/04/24 03:32:48 $\n  */\n public class ChildContext extends EvalContext {\n     private NodeTest nodeTest;\n      * of the collection.  For example, \"books\" will return the collection\n      * of books rather than the first book from that collection.\n      */\n-    public Pointer getContextNodePointer(){\n+    public Pointer getSingleNodePointer(){\n         if (position == 0){\n             while(nextSet()){\n                 prepare();\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/21 21:52:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.5 2002/04/24 03:32:48 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/24 03:32:48 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * on to the parent context.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/24 03:32:48 $\n  */\n public class InitialContext extends EvalContext {\n     private boolean startedSet = false;\n         }\n     }\n \n-    public Pointer getContextNodePointer(){\n+    public Pointer getSingleNodePointer(){\n         return nodePointer;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/21 21:52:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.5 2002/04/24 03:32:48 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/24 03:32:48 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that returns the current node from the parent context if the test succeeds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/24 03:32:48 $\n  */\n public class SelfContext extends EvalContext {\n     private NodeTest nodeTest;\n         this.nodeTest = nodeTest;\n     }\n \n-    public ExpressionContext getExpressionContext(){\n-        return parentContext.getExpressionContext();\n-    }\n-\n-    public Pointer getContextNodePointer(){\n-        return parentContext.getContextNodePointer();\n+    public Pointer getSingleNodePointer(){\n+        return parentContext.getSingleNodePointer();\n     }\n \n     public NodePointer getCurrentNodePointer(){", "timestamp": 1019619168, "metainfo": ""}