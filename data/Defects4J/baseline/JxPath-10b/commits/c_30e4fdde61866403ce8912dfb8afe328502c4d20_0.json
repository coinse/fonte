{"sha": "30e4fdde61866403ce8912dfb8afe328502c4d20", "log": "bulled through JXPath codebase to get a little better familiarity; tiny refactorings and removals of unnecessary elses, etc. along the way  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n                 name,\n                 parameters);\n         }\n-        else if (candidates instanceof List) {\n+        if (candidates instanceof List) {\n             List list = (List) candidates;\n             int count = list.size();\n             for (int i = 0; i < count; i++) {\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n      * affected by the locale.  By default, JXPath uses\n      * <code>Locale.getDefault()</code>\n      */\n-    public void setLocale(Locale locale) {\n+    public synchronized void setLocale(Locale locale) {\n         this.locale = locale;\n     }\n \n      * the context has a parent, returns the parent's locale.\n      * Otherwise, returns Locale.getDefault().\n      */\n-    public Locale getLocale() {\n+    public synchronized Locale getLocale() {\n         if (locale == null) {\n             if (parentContext != null) {\n                 return parentContext.getLocale();\n             }\n-            else {\n-                locale = Locale.getDefault();\n-            }\n+            locale = Locale.getDefault();\n         }\n         return locale;\n     }\n      * \n      * @param name the format name or null for default format.\n      */\n-    public void setDecimalFormatSymbols(\n+    public synchronized void setDecimalFormatSymbols(\n         String name,\n         DecimalFormatSymbols symbols) \n     {\n     /**\n      * @see #setDecimalFormatSymbols(String, DecimalFormatSymbols)\n      */\n-    public DecimalFormatSymbols getDecimalFormatSymbols(String name) {\n+    public synchronized DecimalFormatSymbols getDecimalFormatSymbols(String name) {\n         if (decimalFormats == null) {\n-            if (parentContext != null) {\n-                return parentContext.getDecimalFormatSymbols(name);\n-            }\n-            return null;\n+            return parentContext == null ? null : parentContext.getDecimalFormatSymbols(name);\n         }\n         return (DecimalFormatSymbols) decimalFormats.get(name);\n     }\n      * <p>\n      * By default, lenient = false\n      */\n-    public void setLenient(boolean lenient) {\n+    public synchronized void setLenient(boolean lenient) {\n         this.lenient = lenient;\n         lenientSet = true;\n     }\n     /**\n      * @see #setLenient(boolean)\n      */\n-    public boolean isLenient() {\n+    public synchronized boolean isLenient() {\n         if (!lenientSet && parentContext != null) {\n             return parentContext.isLenient();\n         }\n \t */\n     public Object selectSingleNode(String xpath) {\n     \tPointer pointer = getPointer(xpath);\n-    \tif (pointer == null) {\n-    \t\treturn null;\n-    \t}\n-\t\treturn pointer.getNode();\n+        return pointer == null ? null : pointer.getNode();\n     }\n     \n     /**\n         if (manager != null) {\n             return manager.getPointerByID(this, id);\n         }\n-        else {\n-            throw new JXPathException(\n-                \"Cannot find an element by ID - \"\n-                    + \"no IdentityManager has been specified\");\n-        }\n+        throw new JXPathException(\n+            \"Cannot find an element by ID - \"\n+                + \"no IdentityManager has been specified\");\n     }\n \n     /**\n         if (manager != null) {\n             return manager.getPointerByKey(this, key, value);\n         }\n-        else {\n-            throw new JXPathException(\n-                \"Cannot find an element by key - \"\n-                    + \"no KeyManager has been specified\");\n-        }\n+        throw new JXPathException(\n+            \"Cannot find an element by key - \"\n+                + \"no KeyManager has been specified\");\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n      */\n \n     public String getMessage () {\n-        String message = super.getMessage ();\n-\n+        String message = super.getMessage();\n         if (message == null && exception != null) {\n             return exception.getMessage();\n         }\n-\n         return message;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/JXPathException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathException.java\n      */\n     public String getMessage() {\n         String message = super.getMessage();\n-\n-        if (exception != null) {\n-            if (message == null) {\n-                if (exception.getMessage() != null) {\n-                    return exception.getMessage();\n-                }\n-                else {\n-                    return exception.getClass().getName();\n-                }\n-            }\n-            else {\n-                if (exception.getMessage() != null) {\n-                    return message + \"; \" + exception.getMessage();\n-                }\n-                else {\n-                    return message + \"; \" + exception.getClass().getName();\n-                }\n-            }\n+        if (exception == null) {\n+            return message;\n         }\n-\n-        return message;\n+        StringBuffer buf = new StringBuffer();\n+        if (message == null) {\n+            buf.append(message).append(\"; \");\n+        }\n+        String eMsg = exception.getMessage();\n+        buf.append(eMsg == null ? exception.getClass().getName() : eMsg);\n+        return buf.toString();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n      *  0 - does not require ordering\n      */\n     public int getDocumentOrder() {\n-        if (parentContext != null && parentContext.isChildOrderingRequired()) {\n-            return 1;\n-        }\n-        return 0;\n+        return parentContext != null && parentContext.isChildOrderingRequired() ? 1 : 0;\n     }\n     \n     /**\n     public boolean isChildOrderingRequired() {\n         // Default behavior: if this context needs to be ordered,\n         // the children need to be ordered too\n-        if (getDocumentOrder() != 0) {\n-            return true;\n-        }\n-        return false;\n+        return getDocumentOrder() != 0;\n     }\n \n     /**\n         if (pointerIterator != null) {\n             return pointerIterator.hasNext();\n         }\n-\n         if (getDocumentOrder() != 0) {\n             return constructIterator();\n         }\n-        else {\n-            if (!done && !hasPerformedIteratorStep) {\n-                performIteratorStep();\n-            }\n-            return !done;\n-        }\n+        if (!done && !hasPerformedIteratorStep) {\n+            performIteratorStep();\n+        }\n+        return !done;\n     }\n \n     /**\n             }\n             return pointerIterator.next();\n         }\n-        else {\n-            if (!done && !hasPerformedIteratorStep) {\n-                performIteratorStep();\n-            }\n-            if (done) {\n-                throw new NoSuchElementException();\n-            }\n-            hasPerformedIteratorStep = false;\n-            return getCurrentNodePointer();\n-        }\n+        if (!done && !hasPerformedIteratorStep) {\n+            performIteratorStep();\n+        }\n+        if (done) {\n+            throw new NoSuchElementException();\n+        }\n+        hasPerformedIteratorStep = false;\n+        return getCurrentNodePointer();\n     }\n \n     /**\n             while (nextNode()) {\n                 NodePointer pointer = getCurrentNodePointer();\n                 if (!set.contains(pointer)) {\n-//                    Pointer cln = (Pointer) pointer.clone();\n                     set.add(pointer);\n                     list.add(pointer);\n                 }\n \n     public String toString() {\n         Pointer ptr = getContextNodePointer();\n-        if (ptr == null) {\n-            return \"Empty expression context\";\n-        }\n-        else {\n-            return \"Expression context [\" + getPosition() + \"] \" + ptr.asPath();\n-        }\n+        return ptr == null ? \"Empty expression context\" : \"Expression context [\" + getPosition()\n+                + \"] \" + ptr.asPath();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n         if (object instanceof String) {\n             return (String) object;\n         }\n-        else if (object instanceof Number) {\n+        if (object instanceof Number) {\n             double d = ((Number) object).doubleValue();\n             long l = ((Number) object).longValue();\n-            if (d == l) {\n-                return String.valueOf(l);\n-            }\n-            return String.valueOf(d);\n+            return d == l ? String.valueOf(l) : String.valueOf(d);\n         }\n-        else if (object instanceof Boolean) {\n+        if (object instanceof Boolean) {\n             return ((Boolean) object).booleanValue() ? \"true\" : \"false\";\n         }\n-        else if (object == null) {\n+        if (object == null) {\n             return \"\";\n         }\n-        else if (object instanceof NodePointer) {\n+        if (object instanceof NodePointer) {\n             return stringValue(((NodePointer) object).getValue());\n         }\n-        else if (object instanceof EvalContext) {\n+        if (object instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) object;\n             Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr != null) {\n-                return stringValue(ptr);\n-            }\n-            return \"\";\n+            return ptr == null ? \"\" : stringValue(ptr);\n         }\n         return String.valueOf(object);\n     }\n         if (object instanceof Number) {\n             return (Number) object;\n         }\n-        else if (object instanceof Boolean) {\n+        if (object instanceof Boolean) {\n             return ((Boolean) object).booleanValue() ? ONE : ZERO;\n         }\n-        else if (object instanceof String) {\n-            Double value;\n+        if (object instanceof String) {\n             try {\n-                value = new Double((String) object);\n+                return new Double((String) object);\n             }\n             catch (NumberFormatException ex) {\n-                value = NOT_A_NUMBER;\n+                return NOT_A_NUMBER;\n             }\n-            return value;\n         }\n-        else if (object instanceof EvalContext) {\n+        if (object instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) object;\n             Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr != null) {\n-                return number(ptr);\n-            }\n-            return NOT_A_NUMBER;\n+            return ptr == null ? NOT_A_NUMBER : number(ptr);\n         }\n-        else if (object instanceof NodePointer) {\n+        if (object instanceof NodePointer) {\n             return number(((NodePointer) object).getValue());\n         }\n         return number(stringValue(object));\n         if (object instanceof Number) {\n             return ((Number) object).doubleValue();\n         }\n-        else if (object instanceof Boolean) {\n+        if (object instanceof Boolean) {\n             return ((Boolean) object).booleanValue() ? 0.0 : 1.0;\n         }\n-        else if (object instanceof String) {\n+        if (object instanceof String) {\n             if (object.equals(\"\")) {\n                 return 0.0;\n             }\n-\n-            double value;\n             try {\n-                value = Double.parseDouble((String) object);\n+                return Double.parseDouble((String) object);\n             }\n             catch (NumberFormatException ex) {\n-                value = Double.NaN;\n+                return Double.NaN;\n             }\n-            return value;\n         }\n-        else if (object instanceof NodePointer) {\n+        if (object instanceof NodePointer) {\n             return doubleValue(((NodePointer) object).getValue());\n         }\n-        else if (object instanceof EvalContext) {\n+        if (object instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) object;\n             Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr != null) {\n-                return doubleValue(ptr);\n-            }\n-            return Double.NaN;\n+            return ptr == null ? Double.NaN : doubleValue(ptr);\n         }\n         return doubleValue(stringValue(object));\n     }\n             double value = ((Number) object).doubleValue();\n             return value != 0 && value != -0 && !Double.isNaN(value);\n         }\n-        else if (object instanceof Boolean) {\n+        if (object instanceof Boolean) {\n             return ((Boolean) object).booleanValue();\n         }\n-        else if (object instanceof EvalContext) {\n+        if (object instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) object;\n             Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr == null) {\n-                return false;\n-            }\n-            return booleanValue(ptr);\n+            return ptr == null ? false : booleanValue(ptr);\n         }\n-        else if (object instanceof String) {\n+        if (object instanceof String) {\n             return ((String) object).length() != 0;\n         }\n-        else if (object instanceof NodePointer) {\n+        if (object instanceof NodePointer) {\n             NodePointer pointer = (NodePointer) object;\n             if (pointer instanceof VariablePointer) {\n                 return booleanValue(pointer.getNode());\n             pointer = pointer.getValuePointer();\n             return pointer.isActual();\n         }\n-        else if (object == null) {\n-            return false;\n-        }\n-        return true;\n+        return object != null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n             }\n             return (Pointer) result;\n         }\n-        else {\n-            return NodePointer.newNodePointer(null, result, getLocale());\n-        }\n+        return NodePointer.newNodePointer(null, result, getLocale());\n     }\n \n     public void setValue(String xpath, Object value) {\n         setValue(xpath, compileExpression(xpath), value);\n     }\n-\n \n     public void setValue(String xpath, Expression expr, Object value) {\n         try {\n         if (parentContext != null) {\n             return parentContext.getDefaultNamespaceURI();\n         }\n-        \n         return null;\n     }\n \n             catch (ClassNotFoundException ex) {\n                 return null;\n             }\n-\n             Class cls = Class.forName(className);\n             return cls.newInstance();\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n         if (uri == null && parent != null) {\n             return parent.getNamespaceURI(prefix);\n         }\n-//        System.err.println(\"For prefix \" + prefix + \" URI=\" + uri);\n         return uri;\n     }\n     \n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n         if (position <= 0) {\n             return \"at the beginning of the expression\";\n         }\n-        else if (position >= expression.length()) {\n+        if (position >= expression.length()) {\n             return \"- expression incomplete\";\n         }\n-        else {\n-            return \"after: '\"\n-                + addEscapes(expression.substring(0, position)) + \"'\";\n-        }\n+        return \"after: '\"\n+            + addEscapes(expression.substring(0, position)) + \"'\";\n     }\n \n     private static String addEscapes(String string) {\n--- a/src/java/org/apache/commons/jxpath/ri/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n public class QName {\n     private String prefix;\n     private String name;\n+    private String qualifiedName;\n \n     public QName(String qualifiedName) {\n+        this.qualifiedName = qualifiedName;\n         int index = qualifiedName.indexOf(':');\n-        if (index == -1) {\n-            prefix = null;\n-            name = qualifiedName;\n-        }\n-        else {\n-            prefix = qualifiedName.substring(0, index);\n-            name = qualifiedName.substring(index + 1);\n-        }\n+        prefix = index < 0 ? null : qualifiedName.substring(0, index);\n+        name = index < 0 ? qualifiedName : qualifiedName.substring(index + 1);\n     }\n \n     public QName(String prefix, String localName) {\n         this.prefix = prefix;\n         this.name = localName;\n+        this.qualifiedName = prefix == null ? localName : prefix + ':' + localName;\n     }\n \n     public String getPrefix() {\n     }\n \n     public String toString() {\n-        if (prefix != null) {\n-            return prefix + ':' + name;\n-        }\n-        return name;\n+        return qualifiedName;\n     }\n \n     public int hashCode() {\n     }\n \n     public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n         if (!(object instanceof QName)) {\n             return false;\n         }\n-        if (this == object) {\n-            return true;\n-        }\n-        QName that = (QName) object;\n-        if (!this.name.equals(that.name)) {\n-            return false;\n-        }\n-\n-        if ((this.prefix == null && that.prefix != null)\n-            || (this.prefix != null && !this.prefix.equals(that.prefix))) {\n-            return false;\n-        }\n-\n-        return true;\n+        return qualifiedName.equals(((QName) object).qualifiedName);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n                 return null;\n             }\n         }\n-        if (iterator != null) {\n-            return iterator.getNodePointer();\n-        }\n-        else {\n-            return null;\n-        }\n+        return iterator == null ? null : iterator.getNodePointer();\n     }\n \n     /**\n         if (oldPosition == 0) {\n             prepare();\n         }\n-        if (iterator == null) {\n-            return false;\n-        }\n-        return iterator.setPosition(position);\n+        return iterator == null ? false : iterator.setPosition(position);\n     }\n \n     /**\n         if (parent == null) {\n             return;\n         }\n-        if (startFromParentLocation) {\n-            NodePointer pointer = parent.getParent();\n-            iterator = pointer.childIterator(nodeTest, reverse, parent);\n-        }\n-        else {\n-            iterator = parent.childIterator(nodeTest, reverse, null);\n-        }\n+        iterator = (startFromParentLocation ? parent.getParent() : parent).childIterator(nodeTest,\n+                reverse, startFromParentLocation ? parent : null);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n             }\n             return false;\n         }\n-        else {\n-            return position == 1;\n-        }\n+        return position == 1;\n     }\n \n     public boolean nextSet() {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n                     done = true;\n                     return parentContext.setPosition(pos);\n                 }\n-                else if (InfoSetUtil.booleanValue(pred)) {\n+                if (InfoSetUtil.booleanValue(pred)) {\n                     position++;\n                     return true;\n                 }\n         if (dynamicPropertyPointer != null) {\n             return dynamicPropertyPointer.getValuePointer();\n         }\n-        else {\n-            return parentContext.getCurrentNodePointer();\n-        }\n+        return parentContext.getCurrentNodePointer();\n     }\n \n     public void reset() {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n                     steps,\n                     currentStep);\n             }\n-            else {\n-                return doStepPredicatesPropertyOwner(\n-                    context,\n-                    (PropertyOwnerPointer) parent,\n-                    steps,\n-                    currentStep);\n-            }\n-        }\n-        else {\n-            if (predicates == null || predicates.length == 0) {\n-                return doStepNoPredicatesStandard(\n-                    context,\n-                    parent,\n-                    steps,\n-                    currentStep);\n-            }\n-            else {\n-                return doStepPredicatesStandard(\n-                    context,\n-                    parent,\n-                    steps,\n-                    currentStep);\n-            }\n-        }\n+            return doStepPredicatesPropertyOwner(\n+                context,\n+                (PropertyOwnerPointer) parent,\n+                steps,\n+                currentStep);\n+        }\n+        if (predicates == null || predicates.length == 0) {\n+            return doStepNoPredicatesStandard(\n+                context,\n+                parent,\n+                steps,\n+                currentStep);\n+        }\n+        return doStepPredicatesStandard(\n+            context,\n+            parent,\n+            steps,\n+            currentStep);\n     }\n \n     /**\n                 steps,\n                 currentStep);\n         }\n-        else if (currentStep == steps.length - 1) {\n+        if (currentStep == steps.length - 1) {\n             // If this is the last step - we are done, we found it\n             return childPointer;\n         }\n-        else if (childPointer.isCollection()) {\n+        if (childPointer.isCollection()) {\n             // Iterate over all values and\n             // execute remaining steps for each node,\n             // looking for the best quality match\n             // This step did not find anything - return a null pointer\n             return createNullPointer(context, childPointer, steps, currentStep);\n         }\n-        else {\n-            // Evaluate subsequent steps\n-            return doStep(context, childPointer, steps, currentStep + 1);\n-        }\n+        // Evaluate subsequent steps\n+        return doStep(context, childPointer, steps, currentStep + 1);\n     }\n \n     /**\n                 if (quality == PERFECT_MATCH) {\n                     return pointer;\n                 }\n-                else if (quality > bestQuality) {\n+                if (quality > bestQuality) {\n                     bestQuality = quality;\n                     bestMatch = (NodePointer) pointer.clone();\n                 }\n             }\n         }\n-\n-        if (bestMatch != null) {\n-            return bestMatch;\n-        }\n-\n-        return createNullPointer(\n-                context, parentPointer, steps, currentStep);\n+        return bestMatch != null ? bestMatch\n+                : createNullPointer(context, parentPointer, steps, currentStep);\n     }\n \n     /**\n             }\n             return childPointer;\n         }\n-        else {\n-            return parentPointer;\n-        }\n+        return parentPointer;\n     }\n \n     /**\n                 predicates,\n                 currentPredicate);\n         }\n-        else { // [index]\n-            return doPredicateIndex(\n-                context,\n-                parent,\n-                steps,\n-                currentStep,\n-                predicates,\n-                currentPredicate);\n-        }\n+        // else [index]\n+        return doPredicateIndex(\n+            context,\n+            parent,\n+            steps,\n+            currentStep,\n+            predicates,\n+            currentPredicate);\n     }\n \n     private static NodePointer doPredicateName(\n         if (value instanceof Number) {\n             return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1;\n         }\n-        else if (InfoSetUtil.booleanValue(value)) {\n-            return 0;\n-        }\n-\n-        return -1;\n+        return InfoSetUtil.booleanValue(value) ? 0 : -1;\n     }\n \n     /**\n             }\n             return pointer.childIterator(nodeTest, false, null);\n         }\n-        else { // Compiler.AXIS_ATTRIBUTE\n-            if (!(step.getNodeTest() instanceof NodeNameTest)) {\n-                throw new UnsupportedOperationException(\n-                    \"Not supported node test for attributes: \"\n-                        + step.getNodeTest());\n-            }\n-            return pointer.attributeIterator(\n-                ((NodeNameTest) step.getNodeTest()).getNodeName());\n-        }\n+        // else Compiler.AXIS_ATTRIBUTE\n+        if (!(step.getNodeTest() instanceof NodeNameTest)) {\n+            throw new UnsupportedOperationException(\n+                \"Not supported node test for attributes: \"\n+                    + step.getNodeTest());\n+        }\n+        return pointer.attributeIterator(\n+            ((NodeNameTest) step.getNodeTest()).getNodeName());\n     }\n \n     private static boolean isLangAttribute(QName name) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n  */\n public class UnionContext extends NodeSetContext {\n     private EvalContext contexts[];\n-    private boolean prepared = false;\n+    private boolean prepared;\n \n     public UnionContext(EvalContext parentContext, EvalContext contexts[]) {\n         super(parentContext, new BasicNodeSet());\n     }\n \n     public int getDocumentOrder() {\n-        if (contexts.length > 1) {\n-            return 1;\n-        }\n-        return super.getDocumentOrder();\n+        return contexts.length > 1 ? 1 : super.getDocumentOrder();\n     }\n \n     public boolean setPosition(int position) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n package org.apache.commons.jxpath.ri.compiler;\n \n import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n  * A compile tree element containing a constant number or string.\n \n     public String toString() {\n         if (value instanceof Number) {\n-            double doubleValue = ((Number) value).doubleValue();\n-            long longValue = ((Number) value).longValue();\n-            if (doubleValue == longValue) {\n-                return String.valueOf(longValue);\n-            }\n-            else {\n-                return String.valueOf(doubleValue);\n-            }\n+            return InfoSetUtil.stringValue(value);\n         }\n-        else {\n-            return \"'\" + value + \"'\";\n-        }\n+        return \"'\" + value + \"'\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n             }\n             return s1.substring((int) from - 1);\n         }\n-        else {\n-            double length =\n-                InfoSetUtil.doubleValue(getArg3().computeValue(context));\n-            length = Math.round(length);\n-            if (length < 0) {\n-                return \"\";\n-            }\n-\n-            double to = from + length;\n-            if (to < 1) {\n-                return \"\";\n-            }\n-\n-            if (to > s1.length() + 1) {\n-                if (from < 1) {\n-                    from = 1;\n-                }\n-                return s1.substring((int) from - 1);\n-            }\n-\n+        double length =\n+            InfoSetUtil.doubleValue(getArg3().computeValue(context));\n+        length = Math.round(length);\n+        if (length < 0) {\n+            return \"\";\n+        }\n+\n+        double to = from + length;\n+        if (to < 1) {\n+            return \"\";\n+        }\n+\n+        if (to > s1.length() + 1) {\n             if (from < 1) {\n                 from = 1;\n             }\n-            return s1.substring((int) from - 1, (int) (to - 1));\n-        }\n+            return s1.substring((int) from - 1);\n+        }\n+\n+        if (from < 1) {\n+            from = 1;\n+        }\n+        return s1.substring((int) from - 1, (int) (to - 1));\n     }\n \n     protected Object functionStringLength(EvalContext context) {\n         if (v == null) {\n             return ZERO;\n         }\n-        else if (v instanceof EvalContext) {\n+        if (v instanceof EvalContext) {\n             double sum = 0.0;\n             EvalContext ctx = (EvalContext) v;\n             while (ctx.hasNext()) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n         if (args.length == 1) {\n             return getSymbol() + parenthesize(args[0], false);\n         }\n-        else {\n-            StringBuffer buffer = new StringBuffer();\n-            for (int i = 0; i < args.length; i++) {\n-                if (i > 0) {\n-                    buffer.append(' ');\n-                    buffer.append(getSymbol());\n-                    buffer.append(' ');\n-                }\n-                buffer.append(parenthesize(args[i], i == 0));\n+        StringBuffer buffer = new StringBuffer();\n+        for (int i = 0; i < args.length; i++) {\n+            if (i > 0) {\n+                buffer.append(' ');\n+                buffer.append(getSymbol());\n+                buffer.append(' ');\n             }\n-            return buffer.toString();\n+            buffer.append(parenthesize(args[i], i == 0));\n         }\n+        return buffer.toString();\n     }\n     \n     private String parenthesize(Expression expression, boolean left) {\n+        String s = expression.toString();\n         if (!(expression instanceof CoreOperation)) {\n-            return expression.toString();\n+            return s;\n         }\n-        CoreOperation op = (CoreOperation) expression;\n-        int myPrecedence = getPrecedence();\n-        int thePrecedence = op.getPrecedence();\n+        int compared = getPrecedence() - ((CoreOperation) expression).getPrecedence();\n \n-        boolean needParens = true;\n-        if (myPrecedence < thePrecedence) {\n-            needParens = false;\n+        if (compared < 0) {\n+            return s;\n         }\n-        else if (myPrecedence == thePrecedence) {\n-            if (isSymmetric()) {\n-                needParens = false;\n-            }\n-            else {\n-                needParens = !left;\n-            }\n+        if (compared == 0 && (isSymmetric() || left)) {\n+            return s;\n         }\n-\n-        if (needParens) {\n-            return \"(\" + expression.toString() + \")\";\n-        }\n-        else {\n-            return expression.toString();\n-        }\n+        return '(' + s + ')';\n     }    \n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n         if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n             return contains((Iterator) l, r);\n         }\n-        else if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n+        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n             return contains((Iterator) r, l);\n         }\n-        else if (l instanceof Iterator && r instanceof Iterator) {\n+        if (l instanceof Iterator && r instanceof Iterator) {\n             return findMatch((Iterator) l, (Iterator) r);\n         }\n-\n         return equal(l, r);\n     }\n \n         if (l instanceof Boolean || r instanceof Boolean) {\n             return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n         }\n-        else if (l instanceof Number || r instanceof Number) {\n+        if (l instanceof Number || r instanceof Number) {\n             return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n         }\n-        else if (l instanceof String || r instanceof String) {\n+        if (l instanceof String || r instanceof String) {\n             return (\n                 InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n         }\n-        else if (l == null) {\n-            return r == null;\n-        }\n-        return l.equals(r);\n+        return l != null && l.equals(r);\n     }\n \n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n \n         public Object next() {\n             Object o = iterator.next();\n-            if (o instanceof Pointer) {\n-                return ((Pointer) o).getValue();\n-            }\n-            return o;\n+            return o instanceof Pointer ? ((Pointer) o).getValue() : o;\n         }\n \n         public void remove() {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n                 context = new PredicateContext(context, predicates[j]);\n             }\n         }\n-        if (firstMatch) {\n-            return getSingleNodePointerForSteps(context);\n-        }\n-        else {\n-            return evalSteps(context);\n-        }\n+        return firstMatch ? getSingleNodePointerForSteps(context) : evalSteps(context);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n import org.apache.commons.jxpath.ri.QName;\n \n /**\n- * Represents  an element of the parse tree representing an extension function\n+ * Represents an element of the parse tree representing an extension function\n  * call.\n  *\n  * @author Dmitri Plotnikov\n     }\n     \n     private Object convert(Object object) {\n-        if (object instanceof EvalContext) {\n-            return ((EvalContext) object).getValue();\n-        }\n-        return object;\n+        return object instanceof EvalContext ? ((EvalContext) object).getValue() : object;\n     }  \n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n     }\n \n     public boolean computeContextDependent() {\n-        if (!absolute) {\n-            return true;\n-        }\n-\n-        return super.computeContextDependent();\n+        return !absolute || super.computeContextDependent();\n     }\n \n     public String toString() {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n                 }\n             }\n         }\n-\n         return false;\n     }\n \n             }\n             return areBasicPredicates(step.getPredicates());\n         }\n-        else if (step.getAxis() == Compiler.AXIS_CHILD\n+        if (step.getAxis() == Compiler.AXIS_CHILD\n                 || step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n             NodeTest nodeTest = step.getNodeTest();\n             if (!(nodeTest instanceof NodeNameTest)){\n                 return false;\n             }\n-            \n             if (((NodeNameTest) nodeTest).isWildcard()) {\n                 return false;\n             }\n                 ptr,\n                 steps);\n         }\n-        else {\n-            return searchForPath(context);\n-        }\n+        return searchForPath(context);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n     }\n \n     public Object equal(Object left, Object right) {\n-        if (isNameAttributeTest((Expression) left)) {\n-            return new NameAttributeTest((Expression) left, (Expression) right);\n-        }\n-        else {\n-            return new CoreOperationEqual(\n-                (Expression) left,\n-                (Expression) right);\n-        }\n+        return isNameAttributeTest((Expression) left)\n+                ? new NameAttributeTest((Expression) left, (Expression) right)\n+                : new CoreOperationEqual((Expression) left, (Expression) right);\n     }\n \n     public Object notEqual(Object left, Object right) {\n-        return new CoreOperationNotEqual(\n-            (Expression) left,\n-            (Expression) right);\n+        return new CoreOperationNotEqual((Expression) left, (Expression) right);\n     }\n \n     public Object minus(Object argument) {\n     }\n \n     public Object and(Object arguments[]) {\n-        return new CoreOperationAnd(\n-            toExpressionArray(arguments));\n+        return new CoreOperationAnd(toExpressionArray(arguments));\n     }\n \n     public Object or(Object arguments[]) {\n-        return new CoreOperationOr(\n-            toExpressionArray(arguments));\n+        return new CoreOperationOr(toExpressionArray(arguments));\n     }\n \n     public Object union(Object[] arguments) {\n-        return new CoreOperationUnion(\n-            toExpressionArray(arguments));\n+        return new CoreOperationUnion(toExpressionArray(arguments));\n     }\n \n     public Object locationPath(boolean absolute, Object[] steps) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n      */\n     public NodePointer getValuePointer() {\n         NodePointer ivp = getImmediateValuePointer();\n-        if (ivp != this) {\n-            return ivp.getValuePointer();\n-        }\n-        return this;\n+        return ivp == this ? this : ivp.getValuePointer();\n     }\n \n     /**\n      * a Pointer for this path cannot be obtained at all - actual or otherwise.\n      */\n     public boolean isActual() {\n-        if (index == WHOLE_COLLECTION) {\n-            return true;\n-        }\n-        else {\n-            return index >= 0 && index < getLength();\n-        }\n+        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n     }\n \n     /**\n     \n     public Object getRootNode() {\n         if (rootNode == null) {\n-            if (parent != null) {\n-                rootNode = parent.getRootNode();\n-            }\n-            else {\n-                rootNode = getImmediateNode();\n-            }\n+            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n         }\n         return rootNode;\n     }\n         if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest) {\n+        if (test instanceof NodeNameTest) {\n             if (isContainer()) {\n                 return false;\n             }\n             }\n             return testName.getName().equals(nodeName.getName());\n         }\n-        else if (test instanceof NodeTypeTest) {\n-            if (((NodeTypeTest) test).getNodeType()\n-                == Compiler.NODE_TYPE_NODE) {\n-                return isNode();\n-            }\n-        }\n-        return false;\n+        return test instanceof NodeTypeTest\n+                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n     }\n \n     private static boolean equalStrings(String s1, String s2) {\n-        if (s1 == null && s2 != null) {\n-            return false;\n-        }\n-        if (s1 != null && !s1.equals(s2)) {\n-            return false;\n-        }\n-        return true;\n+        return s1 == s2 || s1 != null && s1.equals(s2);\n     }\n \n     /**\n         NodePointer startWith) \n     {\n         NodePointer valuePointer = getValuePointer();\n-        if (valuePointer != null && valuePointer != this) {\n-            return valuePointer.childIterator(test, reverse, startWith);\n-        }\n-        return null;\n+        return valuePointer == null || valuePointer == this ? null\n+                : valuePointer.childIterator(test, reverse, startWith);\n     }\n \n     /**\n      */\n     public NodeIterator attributeIterator(QName qname) {\n         NodePointer valuePointer = getValuePointer();\n-        if (valuePointer != null && valuePointer != this) {\n-            return valuePointer.attributeIterator(qname);\n-        }\n-        return null;\n+        return valuePointer == null || valuePointer == this ? null\n+                : valuePointer.attributeIterator(qname);\n     }\n \n     /**\n         }\n \n         String namespace = getNamespaceURI(prefix);\n-        if (namespace == null) {\n-            return false; // undefined namespace\n-        }\n-\n-        return namespace.equals(getDefaultNamespaceURI());\n+        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n     }\n \n     protected String getDefaultNamespaceURI() {\n         // Let it throw a ClassCastException\n         NodePointer pointer = (NodePointer) object;\n         if (parent == pointer.parent) {\n-            if (parent == null) {\n-                return 0;\n-            }\n-            return parent.compareChildNodePointers(this, pointer);\n+            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n         }\n \n         // Task 1: find the common parent\n     {\n         if (depth1 < depth2) {\n             int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n-            if (r != 0) {\n-                return r;\n-            }\n-            return -1;\n-        }\n-        else if (depth1 > depth2) {\n+            return r == 0 ? -1 : r;\n+        }\n+        if (depth1 > depth2) {\n             int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n-            if (r != 0) {\n-                return r;\n-            }\n-            return 1;\n+            return r == 0 ? 1 : r;\n         }\n         if (p1 == null && p2 == null) {\n             return 0;\n                     \"Cannot compare pointers that do not belong to the same tree: '\"\n                             + p1 + \"' and '\" + p2 + \"'\");\n         }\n-        int r =\n-            compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n+        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n     \n     public boolean isLeaf() {\n         Object value = getNode();\n-        return value == null\n-            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n     \n     public boolean isCollection() {\n \n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n-        if (index != WHOLE_COLLECTION) {\n-            return ValueUtils.getValue(value, index);\n-        }\n-        else {\n-            return ValueUtils.getValue(value);\n-        }\n+        return index == WHOLE_COLLECTION ? ValueUtils.getValue(value)\n+                : ValueUtils.getValue(value, index);\n     }\n \n     public void setValue(Object value) {\n     public int getLength() {\n         if (actual) {\n             Object value = getBaseValue();\n-            if (value == null) {\n-                return 1;\n-            }\n-            return ValueUtils.getLength(value);\n+            return value == null ? 1 : ValueUtils.getLength(value);\n         }\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n     }\n \n     public NodePointer getNodePointer() {\n-        if (includeXmlLang && position == 1) {\n-            return new LangAttributePointer(parent);\n-        }\n-        else {\n-            return super.getNodePointer();\n-        }\n+        return includeXmlLang && position == 1 ? new LangAttributePointer(parent) : super.getNodePointer();\n     }\n \n     public int getPosition() {\n     public boolean setPosition(int position) {\n         this.position = position;\n         if (includeXmlLang) {\n-            if (position == 1) {\n-                return true;\n-            }\n-            else {\n-                return super.setPosition(position - 1);\n-            }\n+            return position == 1 || super.setPosition(position - 1);\n         }\n-        else {\n-            this.position = position;\n-            return super.setPosition(position);\n-        }\n+        return super.setPosition(position);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n         if (parent != null) {\n             return super.asPath();\n         }\n-        else if (bean == null) {\n+        if (bean == null) {\n             return \"null()\";\n         }\n-        else if (bean instanceof Number) {\n+        if (bean instanceof Number) {\n             String string = bean.toString();\n             if (string.endsWith(\".0\")) {\n                 string = string.substring(0, string.length() - 2);\n             }\n             return string;\n         }\n-        else if (bean instanceof Boolean) {\n+        if (bean instanceof Boolean) {\n             return ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n         }\n-        else if (bean instanceof String) {\n+        if (bean instanceof String) {\n             return \"'\" + bean + \"'\";\n         }\n         return \"/\";\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n \n     public boolean isLeaf() {\n         Object value = getNode();\n-        return value == null\n-            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n     public boolean isContainer() {\n     }\n \n     public Object getImmediateNode() {\n-        if (index != WHOLE_COLLECTION) {\n-            return ValueUtils.getValue(collection, index);\n-        }\n-        else {\n-            return ValueUtils.getValue(collection);\n-        }\n+        return index == WHOLE_COLLECTION ? ValueUtils.getValue(collection)\n+                : ValueUtils.getValue(collection, index);\n     }\n \n     public void setValue(Object value) {\n                 reverse,\n                 startWith);\n         }\n-        else {\n-            return getValuePointer().childIterator(test, reverse, startWith);\n-        }\n+        return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n     public NodeIterator attributeIterator(QName name) {\n-        if (index == WHOLE_COLLECTION) {\n-            return new CollectionAttributeNodeIterator(this, name);\n-        }\n-        return getValuePointer().attributeIterator(name);\n+        return index == WHOLE_COLLECTION ? new CollectionAttributeNodeIterator(this, name)\n+                : getValuePointer().attributeIterator(name);\n     }\n \n     public NodeIterator namespaceIterator() {\n-        if (index == WHOLE_COLLECTION) {\n-            return null;\n-        }\n-        return getValuePointer().namespaceIterator();\n+        return index == WHOLE_COLLECTION ? null : getValuePointer().namespaceIterator();\n     }\n \n     public NodePointer namespacePointer(String namespace) {\n-        if (index == WHOLE_COLLECTION) {\n-            return null;\n-        }\n-        return getValuePointer().namespacePointer(namespace);\n+        return index == WHOLE_COLLECTION ? null : getValuePointer().namespacePointer(namespace);\n     }\n \n     public boolean testNode(NodeTest test) {\n             if (test == null) {\n                 return true;\n             }\n-            else if (test instanceof NodeNameTest) {\n+            if (test instanceof NodeNameTest) {\n                 return false;\n             }\n-            else if (test instanceof NodeTypeTest) {\n-                if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return test instanceof NodeTypeTest && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE;\n         }\n         return getValuePointer().testNode(test);\n     }\n                 buffer.append(\"/\");\n             }\n         }\n-        \n         return buffer.toString();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n         Object bean,\n         Locale locale) \n     {\n-        if (ValueUtils.isCollection(bean)) {\n-            return new CollectionPointer(bean, locale);\n-        }\n-        return null;\n+        return ValueUtils.isCollection(bean) ? new CollectionPointer(bean, locale) : null;\n     }\n \n     public NodePointer createNodePointer(\n         QName name,\n         Object bean) \n     {\n-        if (ValueUtils.isCollection(bean)) {\n-            return new CollectionPointer(parent, bean);\n-        }\n-        return null;\n+        return ValueUtils.isCollection(bean) ? new CollectionPointer(parent, bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-\n-        if (!(object instanceof LangAttributePointer)) {\n-            return false;\n-        }\n-\n-        return true;\n+        return object instanceof LangAttributePointer;\n     }\n \n     public boolean testNode(NodeTest test) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n         if (parent != null) {\n             return parent.createPath(context, value).getValuePointer();\n         }\n-        else {\n-            throw new UnsupportedOperationException(\n-                \"Cannot create the root object: \" + asPath());\n-        }\n+        throw new UnsupportedOperationException(\n+            \"Cannot create the root object: \" + asPath());\n     }\n \n     public NodePointer createPath(JXPathContext context) {\n         if (parent != null) {\n             return parent.createPath(context).getValuePointer();\n         }\n-        else {\n-            throw new UnsupportedOperationException(\n-                \"Cannot create the root object: \" + asPath());\n-        }\n+        throw new UnsupportedOperationException(\n+            \"Cannot create the root object: \" + asPath());\n     }\n \n     public NodePointer createChild(\n         }\n \n         NullPointer other = (NullPointer) object;\n-        return (name == null && other.name == null)\n-            || (name != null && name.equals(other.name));\n+        return name == other.name || name != null && name.equals(other.name);\n     }\n \n     public String asPath() {\n         if (id != null) {\n             return \"id(\" + id + \")\";\n         }\n-\n-        if (parent != null) {\n-            return super.asPath();\n-        }\n-        return \"null()\";\n+        return parent == null ? \"null()\" : super.asPath();\n     }\n \n     public int getLength() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n                     + asPath()\n                     + \", the target object is null\");\n         }\n-        else if (parent instanceof PropertyOwnerPointer &&\n+        if (parent instanceof PropertyOwnerPointer &&\n                 ((PropertyOwnerPointer) parent).\n                     isDynamicPropertyDeclarationSupported()){\n             // If the parent property owner can create\n         if (isAttribute()) {\n             return newParent.createAttribute(context, getName());\n         }\n-        else {\n-            if (parent instanceof NullPointer && parent.equals(newParent)) {\n-                throw createBadFactoryException(context.getFactory());\n-            }\n-            // Consider these two use cases:\n-            // 1. The parent pointer of NullPropertyPointer is \n-            //    a PropertyOwnerPointer other than NullPointer. When we call \n-            //    createPath on it, it most likely returns itself. We then\n-            //    take a PropertyPointer from it and get the PropertyPointer\n-            //    to expand the collection for the corresponding property.\n-            //\n-            // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n-            //    When we call createPath, it may return a PropertyOwnerPointer\n-            //    or it may return anything else, like a DOMNodePointer.\n-            //    In the former case we need to do exactly what we did in use \n-            //    case 1.  In the latter case, we simply request that the \n-            //    non-property pointer expand the collection by itself.\n-            if (newParent instanceof PropertyOwnerPointer) {\n-                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n-                newParent = pop.getPropertyPointer();\n-            }\n-            return newParent.createChild(context, getName(), getIndex());\n-        }\n+        if (parent instanceof NullPointer && parent.equals(newParent)) {\n+            throw createBadFactoryException(context.getFactory());\n+        }\n+        // Consider these two use cases:\n+        // 1. The parent pointer of NullPropertyPointer is \n+        //    a PropertyOwnerPointer other than NullPointer. When we call \n+        //    createPath on it, it most likely returns itself. We then\n+        //    take a PropertyPointer from it and get the PropertyPointer\n+        //    to expand the collection for the corresponding property.\n+        //\n+        // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n+        //    When we call createPath, it may return a PropertyOwnerPointer\n+        //    or it may return anything else, like a DOMNodePointer.\n+        //    In the former case we need to do exactly what we did in use \n+        //    case 1.  In the latter case, we simply request that the \n+        //    non-property pointer expand the collection by itself.\n+        if (newParent instanceof PropertyOwnerPointer) {\n+            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n+            newParent = pop.getPropertyPointer();\n+        }\n+        return newParent.createChild(context, getName(), getIndex());\n     }\n \n     public NodePointer createPath(JXPathContext context, Object value) {\n             pointer.setValue(value);\n             return pointer;\n         }\n-        else {\n-            if (parent instanceof NullPointer && parent.equals(newParent)) {\n-                throw createBadFactoryException(context.getFactory());\n-            }\n-            if (newParent instanceof PropertyOwnerPointer) {\n-                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n-                newParent = pop.getPropertyPointer();\n-            }\n-            return newParent.createChild(context, getName(), index, value);\n-        }\n+        if (parent instanceof NullPointer && parent.equals(newParent)) {\n+            throw createBadFactoryException(context.getFactory());\n+        }\n+        if (newParent instanceof PropertyOwnerPointer) {\n+            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n+            newParent = pop.getPropertyPointer();\n+        }\n+        return newParent.createChild(context, getName(), index, value);\n     }\n     \n     public NodePointer createChild(\n         if (!byNameAttribute) {\n             return super.asPath();\n         }\n-        else {\n-            StringBuffer buffer = new StringBuffer();\n-            buffer.append(getImmediateParentPointer().asPath());\n-            buffer.append(\"[@name='\");\n-            buffer.append(escape(getPropertyName()));\n-            buffer.append(\"']\");\n-            if (index != WHOLE_COLLECTION) {\n-                buffer.append('[').append(index + 1).append(']');\n-            }\n-            return buffer.toString();\n-        }\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getImmediateParentPointer().asPath());\n+        buffer.append(\"[@name='\");\n+        buffer.append(escape(getPropertyName()));\n+        buffer.append(\"']\");\n+        if (index != WHOLE_COLLECTION) {\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n     }\n \n     private String escape(String string) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n     }\n \n     public boolean setPosition(int position) {\n-        if (name != null) {\n-            return setPositionIndividualProperty(position);\n-        }\n-        else {\n-            return setPositionAllProperties(position);\n-        }\n+        return name == null ? setPositionAllProperties(position) : setPositionIndividualProperty(position);\n     }\n \n     private boolean setPositionIndividualProperty(int position) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n         if (test == null) {\n             return createNodeIterator(null, reverse, startWith);\n         }\n-        else if (test instanceof NodeNameTest) {\n+        if (test instanceof NodeNameTest) {\n             NodeNameTest nodeNameTest = (NodeNameTest) test;\n             QName testName = nodeNameTest.getNodeName();\n-            String property;\n             if (!isDefaultNamespace(testName.getPrefix())) {\n                 return null;\n             }\n-            else if (nodeNameTest.isWildcard()) {\n-                property = null;\n-            }\n-            else {\n-                property = testName.getName();\n-            }\n+            String property = nodeNameTest.isWildcard() ? null : testName.getName();\n             return createNodeIterator(property, reverse, startWith);\n         }\n-        else if (test instanceof NodeTypeTest) {\n-            if (((NodeTypeTest) test).getNodeType()\n-                == Compiler.NODE_TYPE_NODE) {\n-                return createNodeIterator(null, reverse, startWith);\n-            }\n-        }\n-        return null;\n+        return test instanceof NodeTypeTest && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE\n+                ? createNodeIterator(null, reverse, startWith) : null;\n     }\n \n     public NodeIterator createNodeIterator(\n     private Object value = UNINITIALIZED;\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n-            if (index == WHOLE_COLLECTION) {\n-                value = ValueUtils.getValue(getBaseValue());\n-            }\n-            else {\n-                value = ValueUtils.getValue(getBaseValue(), index);\n-            }\n+            value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n+                    : ValueUtils.getValue(getBaseValue(), index);\n         }\n         return value;\n     }\n                     \"Cannot setValue of an object that is not \"\n                         + \"some other object's property\");\n             }\n-            else {\n-                throw new JXPathInvalidAccessException(\n-                    \"The specified collection element does not exist: \" + this);\n-            }\n+            throw new JXPathInvalidAccessException(\n+                \"The specified collection element does not exist: \" + this);\n         }\n         else {\n             throw new UnsupportedOperationException(\n         NodePointer pointer1,\n         NodePointer pointer2) \n     {\n-        int r =\n-            pointer1.getName().toString().compareTo(\n-                pointer2.getName().toString());\n-        if (r != 0) {\n-            return r;\n-        }\n-        return pointer1.getIndex() - pointer2.getIndex();\n+        int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n+        return r == 0 ? pointer1.getIndex() - pointer2.getIndex() : r;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n     private Object value = UNINITIALIZED;\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n-            if (index == WHOLE_COLLECTION) {\n-                value = ValueUtils.getValue(getBaseValue());\n-            }\n-            else {\n-                value = ValueUtils.getValue(getBaseValue(), index);\n-            }\n+            value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n+                    : ValueUtils.getValue(getBaseValue(), index);\n         }\n         return value;\n     }\n     \n     public boolean isLeaf() {\n         Object value = getNode();\n-        return value == null\n-            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n-    }    \n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+    }\n \n     /**\n      * If the property contains a collection, then the length of that\n         }\n \n         PropertyPointer other = (PropertyPointer) object;\n-        if (parent != other.parent) {\n-            if (parent == null || !parent.equals(other.parent)) {\n-                return false;\n-            }\n+        if (parent != other.parent && (parent == null || !parent.equals(other.parent))) {\n+            return false;\n         }\n \n         if (getPropertyIndex() != other.getPropertyIndex()\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n     \n     public int getLength() {\n         Object value = getBaseValue();\n-        if (value == null) {\n-            return 1;\n-        }\n-        return ValueUtils.getLength(value);\n-    }    \n+        return value == null ? 1 : ValueUtils.getLength(value);\n+    }\n \n     public boolean isLeaf() {\n         return getValuePointer().isLeaf();\n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION) {\n-            if (index >= 0 && index < getLength()) {\n-                return ValueUtils.getValue(value, index);\n-            }\n-            else {\n-                return null;\n-            }\n+            return index >= 0 && index < getLength() ? ValueUtils.getValue(value, index) : null;\n         }\n-        else {\n-            return ValueUtils.getValue(value);\n-        }\n+        return ValueUtils.getValue(value);\n     }\n \n     public void setValue(Object value) {\n     public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = getImmediateNode();\n-            valuePointer =\n-                NodePointer.newChildNodePointer(this, getName(), value);\n+            valuePointer = NodePointer.newChildNodePointer(this, getName(), value);\n         }\n         return valuePointer;\n     }\n     }\n     \n     public String asPath() {\n-        if (parent != null) {\n-            return parent.asPath();\n-        }\n-        return \"/\";\n+        return parent == null ? \"/\" : parent.asPath();\n     }\n  }\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n         Object bean,\n         Locale locale) \n     {\n-        if (bean instanceof Container) {\n-            return new ContainerPointer((Container) bean, locale);\n-        }\n-        return null;\n+        return bean instanceof Container ? new ContainerPointer((Container) bean, locale) : null;\n     }\n \n     public NodePointer createNodePointer(\n         QName name,\n         Object bean) \n     {\n-        if (bean instanceof Container) {\n-            return new ContainerPointer(parent, (Container) bean);\n-        }\n-        return null;\n+        return bean instanceof Container ? new ContainerPointer(parent, (Container) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n     }\n \n     private static boolean equalStrings(String s1, String s2) {\n-        if (s1 == null && s2 != null) {\n-            return false;\n-        }\n-        if (s1 != null && !s1.equals(s2)) {\n-            return false;\n-        }\n-        return true;\n+        return s1 == s2 || s1 != null && s1.equals(s2);\n     }\n \n     private Attr getAttribute(Element element, QName name) {\n             }\n             return null;\n         }\n-        else {\n-            return element.getAttributeNode(name.getName());\n-        }\n+        return element.getAttributeNode(name.getName());\n     }\n \n     public NodePointer getNodePointer() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n \n     public String getNamespaceURI() {\n         String prefix = DOMNodePointer.getPrefix(attr);\n-        if (prefix == null) {\n-            return null;\n-        }\n-        return parent.getNamespaceURI(prefix);\n+        return prefix == null ? null : parent.getNamespaceURI(prefix);\n     }\n \n     public Object getValue() {\n         String value = attr.getValue();\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value.equals(\"\") && !attr.getSpecified()) {\n+        if (value == null || (value.equals(\"\") && !attr.getSpecified())) {\n             return null;\n         }\n         return value;\n     }\n-    \n+\n     public Object getBaseValue() {\n         return attr;\n     }\n     public boolean testNode(NodeTest nodeTest) {\n         return nodeTest == null\n             || ((nodeTest instanceof NodeTypeTest)\n-                && ((NodeTypeTest) nodeTest).getNodeType()\n-                    == Compiler.NODE_TYPE_NODE);\n+                && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n     }\n \n     /**\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-\n-        if (!(object instanceof DOMAttributePointer)) {\n-            return false;\n-        }\n-\n-        DOMAttributePointer other = (DOMAttributePointer) object;\n-        return attr == other.attr;\n+        return object == this || object instanceof DOMAttributePointer\n+                && attr == ((DOMAttributePointer) object).attr;\n     }\n \n     public int compareChildNodePointers(\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n         if (position == 0) {\n             setPosition(1);\n         }\n-        if (child == null) {\n-            return null;\n-        }\n-        return new DOMNodePointer(parent, child);\n+        return child == null ? null : new DOMNodePointer(parent, child);\n     }\n \n     public int getPosition() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n         if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest) {\n+        if (test instanceof NodeNameTest) {\n             if (node.getNodeType() != Node.ELEMENT_NODE) {\n                 return false;\n             }\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                 return equalStrings(namespaceURI, nodeNS);\n             }\n-        }\n-        else if (test instanceof NodeTypeTest) {\n+            return false;\n+        }\n+        if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n             }\n             return false;\n         }\n-        else if (test instanceof ProcessingInstructionTest) {\n+        if (test instanceof ProcessingInstructionTest) {\n             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                 String testPI = ((ProcessingInstructionTest) test).getTarget();\n                 String nodePI = ((ProcessingInstruction) node).getTarget();\n     }\n \n     private static boolean equalStrings(String s1, String s2) {\n-        if (s1 == null) {\n-            return s2 == null || s2.trim().length() == 0;\n-        }\n-        \n-        if (s2 == null) {\n-            return s1 == null || s1.trim().length() == 0;\n-        }\n-\n-        if (s1 != null && !s1.trim().equals(s2.trim())) {\n-            return false;\n-        }\n-\n-        return true;\n+        if (s1 == s2) {\n+            return true;\n+        }\n+        s1 = s1 == null ? \"\" : s1.trim();\n+        s2 = s2 == null ? \"\" : s2.trim();\n+        return s1.equals(s2);\n     }\n \n     public QName getName() {\n      */\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n-        if (current == null) {\n-            return super.isLanguage(lang);\n-        }\n-        return current.toUpperCase().startsWith(lang.toUpperCase());\n+        return current == null ? super.isLanguage(lang)\n+                : current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n     protected String getLanguage() {\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-\n-        if (!(object instanceof DOMNodePointer)) {\n-            return false;\n-        }\n-\n-        DOMNodePointer other = (DOMNodePointer) object;\n-        return node == other.node;\n+        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n     }\n \n     public static String getPrefix(Node node) {\n \n         String name = node.getNodeName();\n         int index = name.lastIndexOf(':');\n-        if (index == -1) {\n-            return null;\n-        }\n-\n-        return name.substring(0, index);\n+        return index < 0 ? null : name.substring(0, index);\n     }\n \n     public static String getLocalName(Node node) {\n \n         String name = node.getNodeName();\n         int index = name.lastIndexOf(':');\n-        if (index == -1) {\n-            return name;\n-        }\n-\n-        return name.substring(index + 1);\n+        return index < 0 ? name : name.substring(index + 1);\n     }\n     \n     public static String getNamespaceURI(Node node) {\n             return uri;\n         }\n \n-        String qname;\n         String prefix = getPrefix(node);\n-        if (prefix == null) {\n-            qname = \"xmlns\";\n-        }\n-        else {\n-            qname = \"xmlns:\" + prefix;\n-        }\n+        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n \n         Node aNode = node;\n         while (aNode != null) {\n             String text = ((Comment) node).getData();\n             return text == null ? \"\" : text.trim();\n         }\n-        else if (\n+        if (\n             nodeType == Node.TEXT_NODE\n                 || nodeType == Node.CDATA_SECTION_NODE) {\n             String text = node.getNodeValue();\n             return text == null ? \"\" : text.trim();\n         }\n-        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n+        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n             String text = ((ProcessingInstruction) node).getData();\n             return text == null ? \"\" : text.trim();\n         }\n-        else {\n-            NodeList list = node.getChildNodes();\n-            StringBuffer buf = new StringBuffer(16);\n-            for (int i = 0; i < list.getLength(); i++) {\n-                Node child = list.item(i);\n-                if (child.getNodeType() == Node.TEXT_NODE) {\n-                    buf.append(child.getNodeValue());\n-                }\n-                else {\n-                    buf.append(stringValue(child));\n-                }\n-            }\n-            return buf.toString().trim();\n-        }\n+        NodeList list = node.getChildNodes();\n+        StringBuffer buf = new StringBuffer(16);\n+        for (int i = 0; i < list.getLength(); i++) {\n+            Node child = list.item(i);\n+            if (child.getNodeType() == Node.TEXT_NODE) {\n+                buf.append(child.getNodeValue());\n+            }\n+            else {\n+                buf.append(stringValue(child));\n+            }\n+        }\n+        return buf.toString().trim();\n     }\n \n     /**\n      * Locates a node by ID.\n      */\n     public Pointer getPointerByID(JXPathContext context, String id) {\n-        Document document;\n-        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n-            document = (Document) node;\n-        }\n-        else {\n-            document = node.getOwnerDocument();\n-        }\n+        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n+                : node.getOwnerDocument();\n         Element element = document.getElementById(id);\n-        if (element != null) {\n-            return new DOMNodePointer(element, getLocale(), id);\n-        }\n-        else {\n-            return new NullPointer(getLocale(), id);\n-        }\n+        return element == null ? new NullPointer(getLocale(), id)\n+                : new DOMNodePointer(element, getLocale(), id);\n     }\n \n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n             return -1;\n         }\n-        else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n+        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n             return 1;\n         }\n-        else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n+        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n             NamedNodeMap map = ((Node) getNode()).getAttributes();\n             int length = map.getLength();\n             for (int i = 0; i < length; i++) {\n                 if (n == node1) {\n                     return -1;\n                 }\n-                else if (n == node2) {\n+                if (n == node2) {\n                     return 1;\n                 }\n             }\n             if (current == node1) {\n                 return -1;\n             }\n-            else if (current == node2) {\n+            if (current == node2) {\n                 return 1;\n             }\n             current = current.getNextSibling();\n         }\n-\n         return 0;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n         Object bean,\n         Locale locale) \n     {\n-        if (bean instanceof Node) {\n-            return new DOMNodePointer((Node) bean, locale);\n-        }\n-        return null;\n+        return bean instanceof Node ? new DOMNodePointer((Node) bean, locale) : null;\n     }\n \n     public NodePointer createNodePointer(\n         QName name,\n         Object bean) \n     {\n-        if (bean instanceof Node) {\n-            return new DOMNodePointer(parent, (Node) bean);\n-        }\n-        return null;\n+        return bean instanceof Node ? new DOMNodePointer(parent, (Node) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n         }\n \n         DynaBeanPointer other = (DynaBeanPointer) object;\n-        if (parent != other.parent) {\n-            if (parent == null || !parent.equals(other.parent)) {\n-                return false;\n-            }\n-        }\n-\n-        if ((name == null && other.name != null)\n-            || (name != null && !name.equals(other.name))) {\n+        if (!(equalObjects(parent, other.parent) && equalObjects(name, other.name))) {\n             return false;\n         }\n \n         int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n         int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-        if (iThis != iOther) {\n-            return false;\n-        }\n-\n-        return dynaBean == other.dynaBean;\n+        return iThis == iOther && dynaBean == other.dynaBean;\n     }\n \n     /**\n      * If there's a parent - parent's path, otherwise \"/\".\n      */\n     public String asPath() {\n-        if (parent != null) {\n-            return super.asPath();\n-        }\n-        return \"/\";\n+        return parent == null ? \"/\" : super.asPath();\n+    }\n+\n+    private static boolean equalObjects(Object o1, Object o2) {\n+        return o1 == o2 || o1 != null && o1.equals(o2);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n     public NodePointer createNodePointer(\n             QName name, Object bean, Locale locale)\n     {\n-        if (bean instanceof DynaBean) {\n-            return new DynaBeanPointer(name, (DynaBean) bean, locale);\n-        }\n-        return null;\n+        return bean instanceof DynaBean ? new DynaBeanPointer(name, (DynaBean) bean, locale) : null;\n     }\n \n     public NodePointer createNodePointer(\n             NodePointer parent, QName name, Object bean)\n     {\n-        if (bean instanceof DynaBean) {\n-            return new DynaBeanPointer(parent, name, (DynaBean) bean);\n-        }\n-        return null;\n+        return bean instanceof DynaBean ? new DynaBeanPointer(parent, name, (DynaBean) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n     public String getPropertyName() {\n         if (name == null) {\n             String names[] = getPropertyNames();\n-            if (propertyIndex >= 0 && propertyIndex < names.length) {\n-                name = names[propertyIndex];\n-            }\n-            else {\n-                name = \"*\";\n-            }\n+            name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : \"*\";\n         }\n         return name;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n     \n     public boolean isLeaf() {\n         Object value = getNode();\n-        return value == null\n-            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }    \n     \n     public boolean isCollection() {\n     }\n \n     public String asPath() {\n-        if (parent != null) {\n-            return super.asPath();\n-        }\n-        return \"/\";\n+        return parent == null ? \"/\" : super.asPath();\n     }\n \n     public int hashCode() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n     public String getPropertyName() {\n         if (name == null) {\n             String names[] = getPropertyNames();\n-            if (propertyIndex >= 0 && propertyIndex < names.length) {\n-                name = names[propertyIndex];\n-            }\n-            else {\n-                name = \"*\";\n-            }\n+            name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : \"*\";\n         }\n         return name;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n  */\n public class JDOMAttributeIterator implements NodeIterator {\n     private NodePointer parent;\n-//    private QName name;\n     private List attributes;\n     private int position = 0;\n \n     public JDOMAttributeIterator(NodePointer parent, QName name) {\n         this.parent = parent;\n-//        this.name = name;\n         if (parent.getNode() instanceof Element) {\n             Element element = (Element) parent.getNode();\n             String prefix = name.getPrefix();\n         }\n     }\n \n-    /*\n-    private boolean testAttr(Attr attr, QName testName) {\n-        String nodePrefix = DOMNodePointer.getPrefix(attr);\n-        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n-\n-        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n-            return false;\n-        }\n-\n-        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n-            return false;\n-        }\n-\n-        String testLocalName = name.getName();\n-        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n-            String testPrefix = testName.getPrefix();\n-\n-            if (equalStrings(testPrefix, nodePrefix)) {\n-                return true;\n-            }\n-\n-            String testNS = null;\n-            if (testPrefix != null) {\n-                testNS = parent.getNamespaceURI(testPrefix);\n-            }\n-\n-            String nodeNS = null;\n-            if (nodePrefix != null) {\n-                nodeNS = parent.getNamespaceURI(nodePrefix);\n-            }\n-            return equalStrings(testNS, nodeNS);\n-        }\n-        return false;\n-    }\n-\n-    private static boolean equalStrings(String s1, String s2) {\n-        if (s1 == null && s2 != null) {\n-            return false;\n-        }\n-        if (s1 != null && !s1.equals(s2)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private Attr getAttribute(Element element, QName name) {\n-        String testPrefix = name.getPrefix();\n-        String testNS = null;\n-\n-        if (testPrefix != null) {\n-            testNS = parent.getNamespaceURI(testPrefix);\n-        }\n-\n-        if (testNS != null) {\n-            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n-            if (attr == null) {\n-                // This may mean that the parser does not support NS for\n-                // attributes, example - the version of Crimson bundled\n-                // with JDK 1.4.0\n-                NamedNodeMap nnm = element.getAttributes();\n-                for (int i = 0; i < nnm.getLength(); i++) {\n-                    attr = (Attr)nnm.item(i);\n-                    if (testAttr(attr, name)) {\n-                        return attr;\n-                    }\n-                }\n-            }\n-            return attr;\n-        }\n-        else {\n-            return element.getAttributeNode(name.getName());\n-        }\n-    }\n-*/\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-\n-        if (!(object instanceof JDOMAttributePointer)) {\n-            return false;\n-        }\n-\n-        JDOMAttributePointer other = (JDOMAttributePointer) object;\n-        return attr == other.attr;\n+        return object == this || object instanceof JDOMAttributePointer\n+                && ((JDOMAttributePointer) object).attr == attr;\n     }\n \n     public int compareChildNodePointers(\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-\n-        if (!(object instanceof JDOMNamespacePointer)) {\n-            return false;\n-        }\n-\n-        JDOMNamespacePointer other = (JDOMNamespacePointer) object;\n-        return prefix.equals(other.prefix);\n+        return object == this || object instanceof JDOMNamespacePointer && prefix.equals(((JDOMNamespacePointer) object).prefix);\n     }\n \n     public int compareChildNodePointers(\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n         if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n             return -1;\n         }\n-        else if (\n+        if (\n             !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n             return 1;\n         }\n-        else if (\n+        if (\n             (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n             List list = ((Element) getNode()).getAttributes();\n             int length = list.size();\n             if (n == node1) {\n                 return -1;\n             }\n-            else if (n == node2) {\n+            if (n == node2) {\n                 return 1;\n             }\n         }\n         if (node instanceof Element) {\n             return ((Element) node).getContent().size() == 0;\n         }\n-        else if (node instanceof Document) {\n+        if (node instanceof Document) {\n             return ((Document) node).getContent().size() == 0;\n         }\n         return true;\n         if (node instanceof Element) {\n             return ((Element) node).getTextTrim();\n         }\n-        else if (node instanceof Comment) {\n+        if (node instanceof Comment) {\n             String text = ((Comment) node).getText();\n             if (text != null) {\n                 text = text.trim();\n             }\n             return text;\n         }\n-        else if (node instanceof Text) {\n+        if (node instanceof Text) {\n             return ((Text) node).getTextTrim();\n         }\n-        else if (node instanceof CDATA) {\n+        if (node instanceof CDATA) {\n             return ((CDATA) node).getTextTrim();\n         }\n-        else if (node instanceof ProcessingInstruction) {\n+        if (node instanceof ProcessingInstruction) {\n             String text = ((ProcessingInstruction) node).getData();\n             if (text != null) {\n                 text = text.trim();\n         if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest) {\n+        if (test instanceof NodeNameTest) {\n             if (!(node instanceof Element)) {\n                 return false;\n             }\n                 String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                 return equalStrings(namespaceURI, nodeNS);\n             }\n-\n-        }\n-        else if (test instanceof NodeTypeTest) {\n+            return false;\n+        }\n+        if (test instanceof NodeTypeTest) {\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n                     return (node instanceof Element) || (node instanceof Document);\n             }\n             return false;\n         }\n-        else if (test instanceof ProcessingInstructionTest) {\n-            if (node instanceof ProcessingInstruction) {\n-                String testPI = ((ProcessingInstructionTest) test).getTarget();\n-                String nodePI = ((ProcessingInstruction) node).getTarget();\n-                return testPI.equals(nodePI);\n-            }\n-        }\n-\n+        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n+            String testPI = ((ProcessingInstructionTest) test).getTarget();\n+            String nodePI = ((ProcessingInstruction) node).getTarget();\n+            return testPI.equals(nodePI);\n+        }\n         return false;\n     }\n \n     private static boolean equalStrings(String s1, String s2) {\n-        if (s1 == null && s2 != null) {\n-            return false;\n-        }\n-        if (s1 != null && s2 == null) {\n-            return false;\n-        }\n-\n-        if (s1 != null && !s1.trim().equals(s2.trim())) {\n-            return false;\n-        }\n-\n-        return true;\n+        if (s1 == s2) {\n+            return true;\n+        }\n+        s1 = s1 == null ? \"\" : s1.trim();\n+        s2 = s2 == null ? \"\" : s2.trim();\n+        return s1.equals(s2);\n     }\n \n     public static String getPrefix(Object node) {\n             String prefix = ((Element) node).getNamespacePrefix();\n             return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n         }\n-        else if (node instanceof Attribute) {\n+        if (node instanceof Attribute) {\n             String prefix = ((Attribute) node).getNamespacePrefix();\n             return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n         }\n         if (node instanceof Element) {\n             return ((Element) node).getName();\n         }\n-        else if (node instanceof Attribute) {\n+        if (node instanceof Attribute) {\n             return ((Attribute) node).getName();\n         }\n         return null;\n      */\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n-        if (current == null) {\n-            return super.isLanguage(lang);\n-        }\n-        return current.toUpperCase().startsWith(lang.toUpperCase());\n+        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n     protected String getLanguage() {\n     private Element nodeParent(Object node) {\n         if (node instanceof Element) {\n             Object parent = ((Element) node).getParent();\n-            if (parent instanceof Element) {\n-                return (Element) parent;\n-            }\n-        }\n-        else if (node instanceof Text) {\n+            return parent instanceof Element ? (Element) parent : null;\n+        }\n+        if (node instanceof Text) {\n             return (Element) ((Text) node).getParent();\n         }\n-        else if (node instanceof CDATA) {\n+        if (node instanceof CDATA) {\n             return (Element) ((CDATA) node).getParent();\n         }\n-        else if (node instanceof ProcessingInstruction) {\n+        if (node instanceof ProcessingInstruction) {\n             return (Element) ((ProcessingInstruction) node).getParent();\n         }\n-        else if (node instanceof Comment) {\n+        if (node instanceof Comment) {\n             return (Element) ((Comment) node).getParent();\n         }\n         return null;\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n         if (bean instanceof Document) {\n             return new JDOMNodePointer(bean, locale);\n         }\n-        else if (bean instanceof Element) {\n+        if (bean instanceof Element) {\n             return new JDOMNodePointer(bean, locale);\n         }\n         return null;\n         if (bean instanceof Document) {\n             return new JDOMNodePointer(parent, bean);\n         }\n-        else if (bean instanceof Element) {\n+        if (bean instanceof Element) {\n             return new JDOMNodePointer(parent, bean);\n         }\n         return null;\n--- a/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n     }\n \n     public Object getVariable(String variable) {\n-        if (variable.equals(keyword)) {\n-            return object;\n-        }\n-        return null;\n+        return isDeclaredVariable(variable) ? object : null;\n     }\n \n     public void declareVariable(String variable, Object value) {\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n         this.request = request;\n     }\n \n-    \n     public HttpSession getSession() {\n-        if (request instanceof HttpServletRequest) {\n-            return ((HttpServletRequest)request).getSession(false);\n-        }\n-        return null;\n+        return request instanceof HttpServletRequest\n+                ? ((HttpServletRequest) request).getSession(false) : null;\n     }\n-    \n+\n     public ServletRequest getServletRequest() {\n         return request;\n     }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n+import java.util.SortedSet;\n \n import org.apache.commons.beanutils.ConvertUtils;\n import org.apache.commons.beanutils.Converter;\n                 return true;\n             }\n         }\n-        else if (object instanceof Number) {\n+        if (object instanceof Number) {\n             if (toType.isPrimitive()\n                 || Number.class.isAssignableFrom(toType)) {\n                 return true;\n             }\n         }\n-        else if (object instanceof Character) {\n+        if (object instanceof Character) {\n             if (toType == char.class) {\n                 return true;\n             }\n         }\n-        else if (object instanceof String) {\n+        if (object instanceof String) {\n             if (toType.isPrimitive()) {\n                 return true;\n             }\n                 return true;\n             }\n         }\n-        else if (fromType.isArray()) {\n+        if (fromType.isArray()) {\n             // Collection -> array\n             if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n                 }\n                 return true;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n                 return canCreateCollection(toType);\n             }\n-            else {\n-                if (Array.getLength(object) > 0) {\n-                    Object value = Array.get(object, 0);\n-                    return canConvert(value, toType);\n-                }\n-                else {\n-                    return canConvert(\"\", toType);\n-                }\n-            }\n-        }\n-        else if (object instanceof Collection) {\n+            if (Array.getLength(object) > 0) {\n+                Object value = Array.get(object, 0);\n+                return canConvert(value, toType);\n+            }\n+            return canConvert(\"\", toType);\n+        }\n+        if (object instanceof Collection) {\n             // Collection -> array\n             if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n                 }\n                 return true;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n                 return canCreateCollection(toType);\n             }\n-            else {\n-                if (((Collection) object).size() > 0) {\n-                    Object value;\n-                    if (object instanceof List) {\n-                        value = ((List) object).get(0);\n-                    }\n-                    else {\n-                        Iterator it = ((Collection) object).iterator();\n-                        value = it.next();\n-                    }\n-                    return canConvert(value, toType);\n+            if (((Collection) object).size() > 0) {\n+                Object value;\n+                if (object instanceof List) {\n+                    value = ((List) object).get(0);\n                 }\n                 else {\n-                    return canConvert(\"\", toType);\n-                }\n-            }\n-        }\n-        else if (object instanceof NodeSet) {\n+                    Iterator it = ((Collection) object).iterator();\n+                    value = it.next();\n+                }\n+                return canConvert(value, toType);\n+            }\n+            return canConvert(\"\", toType);\n+        }\n+        if (object instanceof NodeSet) {\n             return canConvert(((NodeSet) object).getValues(), toType);\n         }\n-        else if (object instanceof Pointer) {\n+        if (object instanceof Pointer) {\n             return canConvert(((Pointer) object).getValue(), toType);\n         }\n         return ConvertUtils.lookup(toType) != null;\n      */\n     public Object convert(Object object, Class toType) {\n         if (object == null) {\n-            if (toType.isPrimitive()) {\n-                return convertNullToPrimitive(toType);\n-            }\n-            return null;\n+            return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n         }\n \n         if (toType == Object.class) {\n             if (object instanceof NodeSet) {\n                 return convert(((NodeSet) object).getValues(), toType);\n             }\n-            else if (object instanceof Pointer) {\n+            if (object instanceof Pointer) {\n                 return convert(((Pointer) object).getValue(), toType);\n             }\n             return object;\n                 }\n                 return array;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n                 Collection collection = allocateCollection(toType);\n                 for (int i = 0; i < length; i++) {\n                     collection.add(Array.get(object, i));\n                 }\n                 return unmodifiableCollection(collection);\n             }\n-            else {\n-                if (length > 0) { \n-                    Object value = Array.get(object, 0);\n-                    return convert(value, toType);\n-                }\n-                else {\n-                    return convert(\"\", toType);\n-                }\n-            }\n-        }\n-        else if (object instanceof Collection) {\n+            if (length > 0) { \n+                Object value = Array.get(object, 0);\n+                return convert(value, toType);\n+            }\n+            return convert(\"\", toType);\n+        }\n+        if (object instanceof Collection) {\n             int length = ((Collection) object).size();\n             if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n                 }\n                 return array;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n                 Collection collection = allocateCollection(toType);\n                 collection.addAll((Collection) object);\n                 return unmodifiableCollection(collection);\n             }\n-            else {\n-                if (length > 0) {\n-                    Object value;\n-                    if (object instanceof List) {\n-                        value = ((List) object).get(0);\n-                    }\n-                    else {\n-                        Iterator it = ((Collection) object).iterator();\n-                        value = it.next();\n-                    }\n-                    return convert(value, toType);\n+            if (length > 0) {\n+                Object value;\n+                if (object instanceof List) {\n+                    value = ((List) object).get(0);\n                 }\n                 else {\n-                    return convert(\"\", toType);\n-                }\n-            }\n-        }\n-        else if (object instanceof NodeSet) {\n+                    Iterator it = ((Collection) object).iterator();\n+                    value = it.next();\n+                }\n+                return convert(value, toType);\n+            }\n+            return convert(\"\", toType);\n+        }\n+        if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         }\n-        else if (object instanceof Pointer) {\n+        if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n-        else if (toType == String.class) {\n+        if (toType == String.class) {\n             return object.toString();\n         }\n-        else if (object instanceof Boolean) {\n+        if (object instanceof Boolean) {\n             if (toType == boolean.class) {\n                 return object;\n             }\n-            boolean value = ((Boolean) object).booleanValue();\n-            return allocateNumber(toType, value ? 1 : 0);\n-        }\n-        else if (object instanceof Number) {\n+            if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n+                boolean value = ((Boolean) object).booleanValue();\n+                return allocateNumber(toType, value ? 1 : 0);\n+            }\n+        }\n+        if (object instanceof Number) {\n             double value = ((Number) object).doubleValue();\n             if (toType == boolean.class || toType == Boolean.class) {\n                 return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n             }\n-            if (toType.isPrimitive()\n-                || Number.class.isAssignableFrom(toType)) {\n+            if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n                 return allocateNumber(toType, value);\n             }\n         }\n-        else if (object instanceof Character) {\n+        if (object instanceof Character) {\n             if (toType == char.class) {\n                 return object;\n             }\n         }\n-        else if (object instanceof String) {\n+        if (object instanceof String) {\n             Object value = convertStringToPrimitive(object, toType);\n             if (value != null) {\n                 return value;\n             }\n         }\n-        \n+\n         Converter converter = ConvertUtils.lookup(toType);\n         if (converter != null) {\n             return converter.convert(toType, object);\n             }\n         }\n \n-        if (type == List.class) {\n+        if (type == List.class || type == Collection.class) {\n             return new ArrayList();\n         }\n         if (type == Set.class) {\n         throw new JXPathInvalidAccessException(\n                 \"Cannot create collection of type: \" + type);\n     }\n-    \n+\n     protected Collection unmodifiableCollection(Collection collection) {\n         if (collection instanceof List) {\n             return Collections.unmodifiableList((List) collection);\n         }\n-        else if (collection instanceof Set) {\n+        if (collection instanceof SortedSet) {\n+            return Collections.unmodifiableSortedSet((SortedSet) collection);\n+        }\n+        if (collection instanceof Set) {\n             return Collections.unmodifiableSet((Set) collection);\n         }\n-        // Cannot wrap it into a proper unmodifiable collection, \n-        // so we just return the original collection itself\n-        return collection;\n-    }\n-    \n+        return Collections.unmodifiableCollection(collection);\n+    }\n+\n     static final class ValueNodeSet implements NodeSet {\n         private List values;\n         private List pointers;\n             if (bean == null) {\n                 return \"null()\";\n             }\n-            else if (bean instanceof Number) {\n+            if (bean instanceof Number) {\n                 String string = bean.toString();\n                 if (string.endsWith(\".0\")) {\n                     string = string.substring(0, string.length() - 2);\n                 }\n                 return string;\n             }\n-            else if (bean instanceof Boolean) {\n+            if (bean instanceof Boolean) {\n                 return ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n             }\n-            else if (bean instanceof String) {\n+            if (bean instanceof String) {\n                 return \"'\" + bean + \"'\";\n             }\n             return \"{object of type \" + bean.getClass().getName() + \"}\";\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n         if (value.getClass().isArray()) {\n             return true;\n         }\n-        else if (value instanceof Collection) {\n+        if (value instanceof Collection) {\n             return true;\n         }\n         return false;\n         if (collection.getClass().isArray()) {\n             return Array.getLength(collection);\n         }\n-        else if (collection instanceof Collection) {\n+        if (collection instanceof Collection) {\n             return ((Collection) collection).size();\n         }\n-        else {\n-            return 1;\n-        }\n+        return 1;\n     }\n \n     /**\n             }\n             return list.iterator();\n         }\n-        else if (collection instanceof Collection) {\n+        if (collection instanceof Collection) {\n             return ((Collection) collection).iterator();\n         }\n-        else {\n-            return Collections.singletonList(collection).iterator();\n-        }\n+        return Collections.singletonList(collection).iterator();\n     }\n \n     /**\n         if (collection == null) {\n             return null;\n         }\n-        else if (collection.getClass().isArray()) {\n+        if (collection.getClass().isArray()) {\n             Object bigger =\n                 Array.newInstance(\n                     collection.getClass().getComponentType(),\n                 Array.getLength(collection));\n             return bigger;\n         }\n-        else if (collection instanceof Collection) {\n+        if (collection instanceof Collection) {\n             while (((Collection) collection).size() < size) {\n                 ((Collection) collection).add(null);\n             }\n             return collection;\n         }\n-        else {\n-            throw new JXPathException(\n-                \"Cannot turn \"\n-                    + collection.getClass().getName()\n-                    + \" into a collection of size \"\n-                    + size);\n-        }\n+        throw new JXPathException(\n+            \"Cannot turn \"\n+                + collection.getClass().getName()\n+                + \" into a collection of size \"\n+                + size);\n     }\n \n     /**\n         if (collection == null) {\n             return null;\n         }\n-        else if (collection.getClass().isArray()) {\n+        if (collection.getClass().isArray()) {\n             int length = Array.getLength(collection);\n             Object smaller =\n                 Array.newInstance(\n             }\n             return smaller;\n         }\n-        else if (collection instanceof List) {\n+        if (collection instanceof List) {\n             int size = ((List) collection).size();\n             if (index < size) {\n                 ((List) collection).remove(index);\n             }\n             return collection;\n         }\n-        else if (collection instanceof Collection) {\n+        if (collection instanceof Collection) {\n             Iterator it = ((Collection) collection).iterator();\n             for (int i = 0; i < index; i++) {\n                 if (!it.hasNext()) {\n             }\n             return collection;\n         }\n-        else {\n-            throw new JXPathException(\n-                \"Cannot remove \"\n-                    + collection.getClass().getName()\n-                    + \"[\"\n-                    + index\n-                    + \"]\");\n-        }\n+        throw new JXPathException(\n+            \"Cannot remove \"\n+                + collection.getClass().getName()\n+                + \"[\"\n+                + index\n+                + \"]\");\n     }\n \n     /**", "timestamp": 1171927483, "metainfo": ""}