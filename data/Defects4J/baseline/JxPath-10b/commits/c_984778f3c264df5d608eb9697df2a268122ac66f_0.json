{"sha": "984778f3c264df5d608eb9697df2a268122ac66f", "log": "[JXPATH-68] Throw meaningful exception when imminent stack overflow is detected   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n  */\n package org.apache.commons.jxpath.ri.model.beans;\n \n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.QName;\n             return newParent.createAttribute(context, getName());\n         }\n         else {\n+            if (parent instanceof NullPointer && parent.equals(newParent)) {\n+                throw createBadFactoryException(context.getFactory());\n+            }\n             // Consider these two use cases:\n             // 1. The parent pointer of NullPropertyPointer is \n             //    a PropertyOwnerPointer other than NullPointer. When we call \n             //    createPath on it, it most likely returns itself. We then\n             //    take a PropertyPointer from it and get the PropertyPointer\n-            //    to expand the collection for the corresponsing property.\n+            //    to expand the collection for the corresponding property.\n             //\n             // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n             //    When we call createPath, it may return a PropertyOwnerPointer\n             return pointer;\n         }\n         else {\n+            if (parent instanceof NullPointer && parent.equals(newParent)) {\n+                throw createBadFactoryException(context.getFactory());\n+            }\n             if (newParent instanceof PropertyOwnerPointer) {\n                 PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                 newParent = pop.getPropertyPointer();\n         }\n         return string;\n     }\n+\n+    private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) {\n+        return new JXPathAbstractFactoryException(\"Factory \" + factory\n+                + \" reported success creating object for path: \" + asPath()\n+                + \" but object was null.  Terminating to avoid stack recursion.\");\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BadlyImplementedFactoryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.Pointer;\n+\n+/**\n+ * Badly-implemented Factory test.  From JIRA JXPATH-68.\n+ *\n+ * @author Matt Benson\n+ * @version $Revision:$ $Date:$\n+ */\n+public class BadlyImplementedFactoryTest extends TestCase {\n+\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public BadlyImplementedFactoryTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        context = JXPathContext.newContext(new HashMap());\n+        context.setFactory(new AbstractFactory() {\n+            public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index) {\n+                ((Map) parent).put(name, null);\n+                return true;\n+            }\n+        });\n+    }\n+\n+    public void testBadFactoryImplementation() {\n+        try {\n+            context.createPath(\"foo/bar\");\n+            fail(\"should fail with JXPathException caused by JXPathAbstractFactoryException\");\n+        } catch (JXPathException e) {\n+            assertTrue(e.getCause() instanceof JXPathAbstractFactoryException);\n+        }\n+    }\n+\n+}", "timestamp": 1168469699, "metainfo": ""}