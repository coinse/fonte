{"sha": "b8780b1aa2eff978c3612fa43b58efb5b9ca50a0", "log": "Added pointer comparison to ensure document order   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.10 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.11 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.11 $ $Date: 2002/04/26 01:00:38 $\n  */\n public abstract class EvalContext implements ExpressionContext {\n     protected EvalContext parentContext;\n         List list = new ArrayList();\n         while (next()) {\n             list.add(getCurrentNodePointer());\n+        }\n+        if (pos != 0) {\n+            setPosition(pos);\n+        }\n+        else {\n+            reset();\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns the list of all node values in this context\n+     */\n+    public List getPointerList() {\n+        int pos = position;\n+        if (pos != 0) {\n+            reset();\n+        }\n+        List list = new ArrayList();\n+        while (nextSet()){\n+            while (next()) {\n+                list.add(getCurrentNodePointer());\n+            }\n+        }\n+        if (pos != 0) {\n+            setPosition(pos);\n+        }\n+        else {\n+            reset();\n+        }\n+        return list;\n+    }\n+    \n+    /**\n+     * Returns the list of all node values in this context\n+     */\n+    public List getValueList() {\n+        int pos = position;\n+        if (pos != 0) {\n+            reset();\n+        }\n+        List list = new ArrayList();\n+        while (nextSet()){\n+            while (next()) {\n+                list.add(getCurrentNodePointer().getValue());\n+            }\n         }\n         if (pos != 0) {\n             setPosition(pos);\n         }\n \n         if (l instanceof NodePointer){\n-            l = ((NodePointer)l).getCanonicalValue();\n+            l = ((NodePointer)l).getValue();\n         }\n         if (r instanceof NodePointer){\n-            r = ((NodePointer)r).getCanonicalValue();\n+            r = ((NodePointer)r).getValue();\n         }\n \n         if (l instanceof Boolean || r instanceof Boolean){\n         while(nextSet()){\n             while(next()){\n                 NodePointer pointer = getCurrentNodePointer();\n-                set.add(pointer.getCanonicalValue());\n+                set.add(pointer.getValue());\n             }\n         }\n         return set;\n             return \"\";\n         }\n         else if (object instanceof NodePointer){\n-            return stringValue(((NodePointer)object).getCanonicalValue());\n+            return stringValue(((NodePointer)object).getValue());\n         }\n         else if (object instanceof EvalContext){\n             EvalContext ctx = (EvalContext)object;\n             return number(stringValue(object));\n         }\n         else if (object instanceof NodePointer){\n-            return number(((NodePointer)object).getCanonicalValue());\n+            return number(((NodePointer)object).getValue());\n         }\n //        else if (object instanceof Node){\n //            System.err.println(\"HERE\");\n             return value;\n         }\n         else if (object instanceof NodePointer){\n-            return doubleValue(((NodePointer)object).getCanonicalValue());\n+            return doubleValue(((NodePointer)object).getValue());\n         }\n         else if (object instanceof EvalContext){\n             return doubleValue(stringValue(object));\n             return ((String)object).length() != 0;\n         }\n         else if (object instanceof NodePointer){\n-            return booleanValue(((NodePointer)object).getCanonicalValue());\n+            return booleanValue(((NodePointer)object).getValue());\n         }\n         return false;\n     }\n             rootContext = this;\n         }\n         return evalSteps(new InitialContext(rootContext), path, firstMatch);\n-    }\n-\n-    /**\n-     * Walks a location path in a highly simplified fashion: from pointer to\n-     * pointer, no contexts.  This is only possible if the path consists of\n-     * simple steps like \"/foo[3]\" and is context-independent.\n-     */\n-    private NodePointer interpretBasicPath(NodePointer parentPointer, Step steps[]){\n-        if (parentPointer == null){\n-            return null;\n-        }\n-\n-        NodePointer pointer = (NodePointer)parentPointer.clone();\n-        while (pointer != null && !pointer.isNode()){\n-            pointer = pointer.getValuePointer();\n-        }\n-\n-        for (int i = 0; i < steps.length; i++){\n-            Step step = steps[i];\n-            int defaultIndex = (i == steps.length - 1 ? -1 : 0);\n-            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n-            Expression predicates[] = step.getPredicates();\n-\n-            // The following complicated logic is designed to translate\n-            // an xpath like \"foo[@name='x'][@name='y'][3]/bar/baz[4]\" into\n-            // a sequence of \"single steps\", each of which takes a node pointer,\n-            // a name and an optional index and gets you another node pointer.\n-\n-            // Note: if the last step is not indexed, the default index used\n-            // for that very last step is \"-1\", that is \"do not index at all\",\n-            // not \"0\" as in all preceeding steps.\n-\n-            int count = (predicates == null ? 0 : predicates.length);\n-            if (count == 0){\n-                pointer = singleStep(pointer, name, defaultIndex, false);\n-            }\n-            else {\n-                Expression lastIndexPredicate = null;\n-                if (predicates[count - 1].\n-                            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n-                    lastIndexPredicate = predicates[count - 1];\n-                }\n-\n-                if (lastIndexPredicate != null){\n-                    int index = indexFromPredicate(lastIndexPredicate);\n-                    if (count == 1){\n-                        pointer = singleStep(pointer, name, index, false);\n-                    }\n-                    else {\n-                        pointer = singleStep(pointer, name, -1, false);\n-                        for (int j = 0; j < count - 1; j++){\n-                            String key = keyFromPredicate(predicates[j]);\n-                            if (j < count - 2){\n-                                pointer = singleStep(pointer, key, -1, true);\n-                            }\n-                            else {\n-                                pointer = singleStep(pointer, key, index, true);\n-                            }\n-                        }\n-                    }\n-                }\n-                else {\n-                    pointer = singleStep(pointer, name, -1, false);\n-                    for (int j = 0; j < count; j++){\n-                        String key = keyFromPredicate(predicates[j]);\n-                        if (j < count - 1){\n-                            pointer = singleStep(pointer, key, -1, true);\n-                        }\n-                        else {\n-                            pointer = singleStep(pointer, key, defaultIndex, true);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return pointer;\n-    }\n-\n-    /**\n-     * Interprets predicates for the root expression of an Expression Path without creating\n-     * any intermediate contexts.  This is an option used for optimization when the path\n-     * has a simple structure and predicates are context-independent.\n-     */\n-    private NodePointer interpretBasicPredicates(NodePointer pointer, Expression predicates[]){\n-        if (predicates == null || predicates.length == 0 || pointer == null){\n-            return pointer;\n-        }\n-\n-        // The following complicated logic is designed to translate\n-        // an xpath like \"$foo[@name='x'][@name='y'][3]\" into\n-        // a sequence of \"single steps\", each of which takes a node pointer,\n-        // a name and an optional index and gets you another node pointer.\n-\n-        int count = predicates.length;\n-        Expression lastIndexPredicate = null;\n-        if (predicates[count - 1].\n-                    getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n-            lastIndexPredicate = predicates[count - 1];\n-        }\n-\n-        if (lastIndexPredicate != null){\n-            int index = indexFromPredicate(lastIndexPredicate);\n-            if (count == 1){\n-                if (index >= 0 && index < pointer.getLength()){\n-                    pointer.setIndex(index);\n-                }\n-                else {\n-                    pointer = new NullElementPointer(pointer, index);\n-                }\n-            }\n-            else {\n-                for (int j = 0; j < count - 1; j++){\n-                    String key = keyFromPredicate(predicates[j]);\n-                    if (j < count - 2){\n-                        pointer = singleStep(pointer, key, -1, true);\n-                    }\n-                    else {\n-                        pointer = singleStep(pointer, key, index, true);\n-                    }\n-                }\n-            }\n-        }\n-        else {\n-            for (int j = 0; j < count; j++){\n-                String key = keyFromPredicate(predicates[j]);\n-                if (j < count - 1){\n-                    pointer = singleStep(pointer, key, -1, true);\n-                }\n-                else {\n-                    pointer = singleStep(pointer, key, -1, true);\n-                }\n-            }\n-        }\n-        return pointer;\n-    }\n-\n-    /**\n-     * @param property can be either a name or a QName\n-     */\n-    private NodePointer singleStep(NodePointer parent, Object property, int index, boolean dynamic){\n-        if (parent instanceof PropertyOwnerPointer){\n-            PropertyPointer pointer = ((PropertyOwnerPointer)parent).getPropertyPointer();\n-            String name;\n-            if (property instanceof QName){\n-                name = ((QName)property).getName();\n-            }\n-            else {\n-                name = (String)property;\n-            }\n-            pointer.setPropertyName(name);\n-            if (pointer instanceof NullPropertyPointer && dynamic){\n-                ((NullPropertyPointer)pointer).setDynamic(true);\n-            }\n-            if (index != -1){\n-                if (index >= 0 && index < pointer.getLength()){\n-                    pointer.setIndex(index);\n-                    return pointer.getValuePointer();\n-                }\n-                else {\n-                    return new NullElementPointer(pointer, index).getValuePointer();\n-                }\n-            }\n-            else {\n-                return pointer.getValuePointer();\n-            }\n-        }\n-        else {\n-            QName name;\n-            if (property instanceof QName){\n-                name = (QName)property;\n-            }\n-            else {\n-                name = new QName(null, (String)property);\n-            }\n-            NodeIterator it = parent.childIterator(new NodeNameTest(name), false, null);\n-            if (it != null && it.setPosition(index == -1 ? 1 : index + 1)){\n-                return it.getNodePointer();\n-            }\n-            else {\n-                PropertyPointer pointer = new NullPropertyPointer(parent);\n-                pointer.setPropertyName(name.toString());\n-                pointer.setIndex(index);\n-                return pointer.getValuePointer();\n-            }\n-        }\n-    }\n-\n-    private int indexFromPredicate(Expression predicate){\n-        Object value = eval(predicate, true);\n-        if (value instanceof EvalContext){\n-            value = ((EvalContext)value).getSingleNodePointer();\n-        }\n-        if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getCanonicalValue();\n-        }\n-        if (value == null){\n-            throw new RuntimeException(\"Predicate is null: \" + value);\n-        }\n-\n-        if (value instanceof Number){\n-            return (int)(doubleValue(value) + 0.5) - 1;\n-        }\n-        else if (booleanValue(value)){\n-            return 0;\n-        }\n-\n-        return -1;\n-    }\n-\n-    private String keyFromPredicate(Expression predicate){\n-        Expression expr = (Expression)predicate.\n-                getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-        return stringValue(eval(expr));\n     }\n \n     /**\n             if (ptr != null &&\n                     (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n                      predicates == null || predicates.length == 0)){\n-                NodePointer pointer = interpretBasicPredicates(ptr, predicates);\n-                return interpretBasicPath(pointer, path.getSteps());\n+                NodePointer pointer = SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n+                return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n             }\n         }\n \n             boolean basic = path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE);\n             if (basic){\n                 NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n-                return interpretBasicPath(ptr, steps);\n+                return SimplePathInterpreter.interpretPath(this, ptr, steps);\n             }\n         }\n \n         int count = 0;\n         Object value = eval(arg1, false);\n         if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getCanonicalValue();\n+            value = ((NodePointer)value).getValue();\n         }\n         if (value instanceof EvalContext){\n             EvalContext ctx = (EvalContext)value;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.11 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.12 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.12 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n             result = ctx.getSingleNodePointer();\n         }\n         if (result instanceof NodePointer){\n-            result = ((NodePointer)result).getCanonicalValue();\n+            result = ((NodePointer)result).getValue();\n         }\n         return result;\n     }\n     public List eval(String xpath){\n //        System.err.println(\"XPATH: \" + xpath);\n         Object result = eval(xpath, false);\n-        List list = new ArrayList();\n         if (result instanceof EvalContext){\n-            EvalContext context = (EvalContext)result;\n-            while (context.nextSet()){\n-                while (context.next()){\n-                    Pointer pointer = context.getCurrentNodePointer();\n-                    list.add(pointer.getValue());\n-                }\n-            }\n+            return ((EvalContext)result).getValueList();\n         }\n         else if (result instanceof Pointer){\n-            list.add(((Pointer)result).getValue());\n-        }\n-        else {\n-            list.add(result);\n-        }\n-        return list;\n+            return Collections.singletonList(((Pointer)result).getValue());\n+        }\n+        else {\n+            return Collections.singletonList(result);\n+        }\n     }\n \n     public Pointer locateValue(String xpath){\n \n     public List locate(String xpath){\n         Object result = eval(xpath, false);\n-        List list = new ArrayList();\n         if (result instanceof EvalContext){\n-            EvalContext context = (EvalContext)result;\n-            while (context.nextSet()){\n-                while (context.next()){\n-                    Pointer pointer = context.getCurrentNodePointer();\n-                    list.add(pointer);\n-                }\n-            }\n+            return ((EvalContext)result).getPointerList();\n         }\n         else if (result instanceof Pointer){\n-            list.add((Pointer)result);\n-        }\n-        else {\n-            list.add(NodePointer.newNodePointer(null, result, getLocale()));\n-        }\n-        return list;\n+            return Collections.singletonList((Pointer)result);\n+        }\n+        else {\n+            return Collections.singletonList(NodePointer.newNodePointer(null, result, getLocale()));\n+        }\n     }\n \n     private Object eval(String xpath, boolean firstMatchLookup) {\n         for (int i = 0; i < list.size(); i++){\n             Object element = list.get(i);\n             if (element instanceof NodePointer){\n-                element = ((NodePointer)element).getValue();\n+                element = ((NodePointer)element).getNodeValue();\n             }\n             result.add(element);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.6 2002/04/24 04:05:39 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/04/24 04:05:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.7 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.7 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n             if (setupDynamicPropertyPointer()){\n                 Object pred = parentContext.eval(dynamicPropertyNameExpression);\n                 if (pred instanceof NodePointer){\n-                    pred = ((NodePointer)pred).getCanonicalValue();\n+                    pred = ((NodePointer)pred).getValue();\n                 }\n                 dynamicPropertyPointer.setPropertyName(stringValue(pred));\n                 done = true;\n             else {\n                 Object pred = parentContext.eval(expression);\n                 if (pred instanceof NodePointer){\n-                    pred = ((NodePointer)pred).getValue();\n+                    pred = ((NodePointer)pred).getNodeValue();\n                 }\n                 if (pred instanceof Number){\n                     int pos = (int)doubleValue(pred);\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons/jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.10 2002/04/24 04:05:40 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/04/24 04:05:40 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+\n+/**\n+ * An simple XPath evaluation mechanism, which works only for some xpaths\n+ * but is much faster than the usual process. It is only used for\n+ * xpaths which have no context-dependent parts, consist entirely of\n+ * child:: steps with predicates that either integer or have the form\n+ * <code>[@name = ...]</code>.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.10 $ $Date: 2002/04/24 04:05:40 $\n+ */\n+public class SimplePathInterpreter {\n+\n+    /**\n+     * Walks a location path in a highly simplified fashion: from pointer to\n+     * pointer, no contexts.  This is only possible if the path consists of\n+     * simple steps like \"/foo[3]\" and is context-independent.\n+     */\n+    public static NodePointer interpretPath(EvalContext context, NodePointer parentPointer, Step steps[]){\n+        if (parentPointer == null){\n+            return null;\n+        }\n+\n+        NodePointer pointer = (NodePointer)parentPointer.clone();\n+        while (pointer != null && !pointer.isNode()){\n+            pointer = pointer.getValuePointer();\n+        }\n+\n+        for (int i = 0; i < steps.length; i++){\n+            Step step = steps[i];\n+            int defaultIndex = (i == steps.length - 1 ? -1 : 0);\n+            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            Expression predicates[] = step.getPredicates();\n+\n+            // The following complicated logic is designed to translate\n+            // an xpath like \"foo[@name='x'][@name='y'][3]/bar/baz[4]\" into\n+            // a sequence of \"single steps\", each of which takes a node pointer,\n+            // a name and an optional index and gets you another node pointer.\n+\n+            // Note: if the last step is not indexed, the default index used\n+            // for that very last step is \"-1\", that is \"do not index at all\",\n+            // not \"0\" as in all preceeding steps.\n+\n+            int count = (predicates == null ? 0 : predicates.length);\n+            if (count == 0){\n+                pointer = singleStep(context, pointer, name, defaultIndex, false);\n+            }\n+            else {\n+                Expression lastIndexPredicate = null;\n+                if (predicates[count - 1].\n+                            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+                    lastIndexPredicate = predicates[count - 1];\n+                }\n+\n+                if (lastIndexPredicate != null){\n+                    int index = indexFromPredicate(context, lastIndexPredicate);\n+                    if (count == 1){\n+                        pointer = singleStep(context, pointer, name, index, false);\n+                    }\n+                    else {\n+                        pointer = singleStep(context, pointer, name, -1, false);\n+                        for (int j = 0; j < count - 1; j++){\n+                            String key = keyFromPredicate(context, predicates[j]);\n+                            if (j < count - 2){\n+                                pointer = singleStep(context, pointer, key, -1, true);\n+                            }\n+                            else {\n+                                pointer = singleStep(context, pointer, key, index, true);\n+                            }\n+                        }\n+                    }\n+                }\n+                else {\n+                    pointer = singleStep(context, pointer, name, -1, false);\n+                    for (int j = 0; j < count; j++){\n+                        String key = keyFromPredicate(context, predicates[j]);\n+                        if (j < count - 1){\n+                            pointer = singleStep(context, pointer, key, -1, true);\n+                        }\n+                        else {\n+                            pointer = singleStep(context, pointer, key, defaultIndex, true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * Interprets predicates for the root expression of an Expression Path without creating\n+     * any intermediate contexts.  This is an option used for optimization when the path\n+     * has a simple structure and predicates are context-independent.\n+     */\n+    public static NodePointer interpretPredicates(EvalContext context, NodePointer pointer, Expression predicates[]){\n+        if (predicates == null || predicates.length == 0 || pointer == null){\n+            return pointer;\n+        }\n+\n+        // The following complicated logic is designed to translate\n+        // an xpath like \"$foo[@name='x'][@name='y'][3]\" into\n+        // a sequence of \"single steps\", each of which takes a node pointer,\n+        // a name and an optional index and gets you another node pointer.\n+\n+        int count = predicates.length;\n+        Expression lastIndexPredicate = null;\n+        if (predicates[count - 1].\n+                    getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+            lastIndexPredicate = predicates[count - 1];\n+        }\n+\n+        if (lastIndexPredicate != null){\n+            int index = indexFromPredicate(context, lastIndexPredicate);\n+            if (count == 1){\n+                if (index >= 0 && index < pointer.getLength()){\n+                    pointer.setIndex(index);\n+                }\n+                else {\n+                    pointer = new NullElementPointer(pointer, index);\n+                }\n+            }\n+            else {\n+                for (int j = 0; j < count - 1; j++){\n+                    String key = keyFromPredicate(context, predicates[j]);\n+                    if (j < count - 2){\n+                        pointer = singleStep(context, pointer, key, -1, true);\n+                    }\n+                    else {\n+                        pointer = singleStep(context, pointer, key, index, true);\n+                    }\n+                }\n+            }\n+        }\n+        else {\n+            for (int j = 0; j < count; j++){\n+                String key = keyFromPredicate(context, predicates[j]);\n+                if (j < count - 1){\n+                    pointer = singleStep(context, pointer, key, -1, true);\n+                }\n+                else {\n+                    pointer = singleStep(context, pointer, key, -1, true);\n+                }\n+            }\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * @param property can be either a name or a QName\n+     */\n+    private static NodePointer singleStep(EvalContext context, NodePointer parent, Object property, int index, boolean dynamic){\n+        if (parent instanceof PropertyOwnerPointer){\n+            PropertyPointer pointer = ((PropertyOwnerPointer)parent).getPropertyPointer();\n+            String name;\n+            if (property instanceof QName){\n+                name = ((QName)property).getName();\n+            }\n+            else {\n+                name = (String)property;\n+            }\n+            pointer.setPropertyName(name);\n+            if (pointer instanceof NullPropertyPointer && dynamic){\n+                ((NullPropertyPointer)pointer).setDynamic(true);\n+            }\n+            if (index != -1){\n+                if (index >= 0 && index < pointer.getLength()){\n+                    pointer.setIndex(index);\n+                    return pointer.getValuePointer();\n+                }\n+                else {\n+                    return new NullElementPointer(pointer, index).getValuePointer();\n+                }\n+            }\n+            else {\n+                return pointer.getValuePointer();\n+            }\n+        }\n+        else {\n+            QName name;\n+            if (property instanceof QName){\n+                name = (QName)property;\n+            }\n+            else {\n+                name = new QName(null, (String)property);\n+            }\n+            NodeIterator it = parent.childIterator(new NodeNameTest(name), false, null);\n+            if (it != null && it.setPosition(index == -1 ? 1 : index + 1)){\n+                return it.getNodePointer();\n+            }\n+            else {\n+                PropertyPointer pointer = new NullPropertyPointer(parent);\n+                pointer.setPropertyName(name.toString());\n+                pointer.setIndex(index);\n+                return pointer.getValuePointer();\n+            }\n+        }\n+    }\n+\n+    private static int indexFromPredicate(EvalContext context, Expression predicate){\n+        Object value = context.eval(predicate, true);\n+        if (value instanceof EvalContext){\n+            value = ((EvalContext)value).getSingleNodePointer();\n+        }\n+        if (value instanceof NodePointer){\n+            value = ((NodePointer)value).getValue();\n+        }\n+        if (value == null){\n+            throw new RuntimeException(\"Predicate is null: \" + value);\n+        }\n+\n+        if (value instanceof Number){\n+            return (int)(context.doubleValue(value) + 0.5) - 1;\n+        }\n+        else if (context.booleanValue(value)){\n+            return 0;\n+        }\n+\n+        return -1;\n+    }\n+\n+    private static String keyFromPredicate(EvalContext context, Expression predicate){\n+        Expression expr = (Expression)predicate.\n+                getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+        return context.stringValue(context.eval(expr));\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.2 2002/04/24 03:31:59 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 03:31:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 03:31:59 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n-public abstract class NodePointer implements Pointer, Cloneable {\n+public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n \n     public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n     protected int index = WHOLE_COLLECTION;\n      * If true, this node does not have children\n      */\n     public boolean isLeaf() {\n-        Object value = getValue();\n+        Object value = getNodeValue();\n         return value == null\n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n     }\n \n     /**\n-     * By default, returns <code>getValue()</code>, can be overridden to\n+     * By default, returns <code>getNodeValue()</code>, can be overridden to\n      * return a \"canonical\" value, like for instance a DOM element should\n      * return its string value.\n      */\n-    public Object getCanonicalValue() {\n-        return getValue();\n+    public Object getValue() {\n+        return getNodeValue();\n     }\n \n     /**\n      */\n     public abstract Object getBaseValue();\n \n+    /**\n+     * Returns the object the pointer points to; does not convert it\n+     * to a \"canonical\" type.\n+     */\n+    public abstract Object getNodeValue();\n+    \n+    /**\n+     * Converts the value to the required type and changes the corresponding\n+     * object to that value.\n+     */\n     public abstract void setValue(Object value);\n+\n+    /**\n+     * Compares two child NodePointers and returns a positive number,\n+     * zero or a positive number according to the order of the pointers.\n+     */\n+    public abstract int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2);\n \n     /**\n      * Checks if this Pointer matches the supplied NodeTest.\n     public String toString() {\n         return asPath();\n     }\n+\n+    public int compareTo(Object object){\n+        NodePointer pointer = (NodePointer) object;         // Let it throw a ClassCastException\n+        if (parent == pointer.parent){\n+            if (parent == null){\n+                return 0;\n+            }\n+            return parent.compareChildNodePointers(this, pointer);\n+        }\n+\n+        // Task 1: find the common parent\n+        int depth1 = 0;\n+        NodePointer p1 = this;\n+        while (p1 != null){\n+            depth1 ++;\n+            p1 = p1.parent;\n+        }\n+        int depth2 = 0;\n+        NodePointer p2 = pointer;\n+        while (p2 != null){\n+            depth2 ++;\n+            p2 = p2.parent;\n+        }\n+        return compareNodePointers(this, depth1, pointer, depth2);\n+    }\n+\n+    private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2){\n+//        System.err.println(\"Comparing \" + p1.asPath() + \" (\" + depth1 + \") ~ \" +\n+//                p2.asPath() + \" (\" + depth2 + \")\");\n+        if (depth1 < depth2){\n+            int r = compareNodePointers(p1, depth1, p2.parent, depth2-1);\n+            if (r != 0){\n+                return r;\n+            }\n+            return -1;\n+        }\n+        else if (depth1 > depth2){\n+            int r = compareNodePointers(p1.parent, depth1-1, p2, depth2);\n+            if (r != 0){\n+                return r;\n+            }\n+            return 1;\n+        }\n+        if (p1 == null && p2 == null){\n+            return 0;\n+        }\n+\n+        if (p1 != null && p1.equals(p2)){\n+            return 0;\n+        }\n+\n+        if (depth1 == 1){\n+            throw new RuntimeException(\n+                \"Cannot compare pointers that do not belong to the same tree\");\n+        }\n+        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n+        if (r != 0){\n+            return r;\n+        }\n+\n+        return p1.parent.compareChildNodePointers(p1, p2);\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.2 2002/04/24 04:05:39 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n         return variables.getVariable(name.getName());\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION){\n             return ValueUtils.getValue(value, index);\n         if (valuePointer == null){\n             Object value = null;\n             if (actual){\n-                value = getValue();\n+                value = getNodeValue();\n             }\n             valuePointer = NodePointer.newChildNodePointer(this, null, value);\n         }\n                 buffer.append('[').append(index + 1).append(']');\n             }\n         }\n-        else if (index != WHOLE_COLLECTION && (getValue() == null || isCollection())){\n+        else if (index != WHOLE_COLLECTION && (getNodeValue() == null || isCollection())){\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n         }\n         return factory;\n     }\n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        return pointer1.getIndex() - pointer2.getIndex();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.2 2002/04/24 04:06:46 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:06:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:06:46 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private String propertyName;\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getValue(){\n+    public Object getNodeValue(){\n         if (value == UNINITIALIZED){\n             PropertyDescriptor pd = getPropertyDescriptor();\n             if (pd == null){\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-        if (getValue() == null){\n+        if (getNodeValue() == null){\n             AbstractFactory factory = getAbstractFactory(context);\n             int inx = (index == WHOLE_COLLECTION ? 0 : index);\n             if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n         return collection;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         if (index != WHOLE_COLLECTION){\n             return ValueUtils.getValue(collection, index);\n         }\n \n     public NodePointer getValuePointer(){\n         if (valuePointer == null){\n-            Object value = getValue();\n+            Object value = getNodeValue();\n             valuePointer = NodePointer.newChildNodePointer(this, getName(), value);\n         }\n         return valuePointer;\n         else {\n             Object collection = getBaseValue();\n             if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getValue(), index + 1);\n+                ValueUtils.expandCollection(getNodeValue(), index + 1);\n             }\n             ValueUtils.setValue(collection, index, value);\n         }\n         else {\n             Object collection = getBaseValue();\n             if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getValue(), index + 1);\n+                ValueUtils.expandCollection(getNodeValue(), index + 1);\n             }\n             return this;\n         }\n         else {\n             Object collection = getBaseValue();\n             if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getValue(), index + 1);\n+                ValueUtils.expandCollection(getNodeValue(), index + 1);\n             }\n             return this;\n         }\n     public boolean testNode(NodeTest nodeTest){\n         return getValuePointer().testNode(nodeTest);\n     }\n+    \n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){        \n+        return pointer1.getIndex() - pointer2.getIndex();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n      * collection, otherwise - 1.\n      */\n     public int getLength(){\n-        return ValueUtils.getLength(getValue());\n+        return ValueUtils.getLength(getNodeValue());\n     }\n \n     /**\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getValue(){\n+    public Object getNodeValue(){\n         Object value;\n         if (index == WHOLE_COLLECTION){\n             value = handler.getProperty(getBean(), getPropertyName());\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-        if (getValue() == null){\n+        if (getNodeValue() == null){\n             AbstractFactory factory = getAbstractFactory(context);\n             int inx = (index == WHOLE_COLLECTION ? 0 : index);\n             if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of the attribute is based on the locale supplied to it in the constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class LangAttributePointer extends NodePointer {\n     public LangAttributePointer(NodePointer parent){\n         return parent.getLocale().toString().replace('_', '-');\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         return getBaseValue();\n     }\n \n     public boolean testNode(NodeTest test){\n         return false;\n     }\n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        // Won't happen - lang attributes don't have children\n+        return 0;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * as the parent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class NullElementPointer extends PropertyOwnerPointer {\n \n         return null;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         return null;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n         return null;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         return null;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getValue(){\n+    public Object getNodeValue(){\n         if (value == UNINITIALIZED){\n             if (index == WHOLE_COLLECTION){\n                 value = getBaseValue();\n      * otherwise returns the pointer itself.\n      */\n     public NodePointer getValuePointer() {\n-        return NodePointer.newChildNodePointer(this, getName(), getValue());\n+        return NodePointer.newChildNodePointer(this, getName(), getNodeValue());\n     }\n \n     public void createChild(JXPathContext context, QName name, int index, Object value){\n         prop.setIndex(index);\n         return prop.createPath(context);\n     }\n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n+        if (r != 0){\n+            return r;\n+        }\n+        return pointer1.getIndex() - pointer2.getIndex();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:37 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a property of the parent object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n  */\n public abstract class PropertyPointer extends NodePointer {\n     public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n \n     public Object getBean(){\n         if (bean == null){\n-            bean = getParent().getValue();\n+            bean = getParent().getNodeValue();\n         }\n         return bean;\n     }\n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getValue(){\n+    public Object getNodeValue(){\n         if (value == UNINITIALIZED){\n             if (index == WHOLE_COLLECTION){\n                 value = getBaseValue();\n      * selected property value.\n      */\n     public NodePointer getValuePointer(){\n-        return NodePointer.newChildNodePointer(this, getName(), getValue());\n+        return NodePointer.newChildNodePointer(this, getName(), getNodeValue());\n     }\n \n     public int hashCode(){\n                 index == other.index;\n     }\n \n-    public String toString(){\n-        StringBuffer buffer = new StringBuffer();\n-        if (getBean() == null){\n-            buffer.append(\"null\");\n-        }\n-        else {\n-            buffer.append(getBean().getClass().getName());\n-        }\n-        buffer.append('@');\n-        buffer.append(System.identityHashCode(getBean()));\n-        buffer.append('.');\n-        buffer.append(getPropertyName());\n-        if (index != WHOLE_COLLECTION){\n-            buffer.append('[').append(index).append(']');\n-        }\n-        buffer.append(\" = \").append(getValue());\n-        return buffer.toString();\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/21 21:52:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.2 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n         return container.getValue();\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION){\n             return ValueUtils.getValue(value, index);\n \n     public NodePointer getValuePointer(){\n         if (valuePointer == null){\n-            Object value = getValue();\n+            Object value = getNodeValue();\n             valuePointer = NodePointer.newChildNodePointer(this, getName(), value).getValuePointer();\n         }\n         return valuePointer;\n     public boolean testNode(NodeTest nodeTest){\n         return getValuePointer().testNode(nodeTest);\n     }\n-}\n+ \n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        return pointer1.getIndex() - pointer2.getIndex();\n+    }\n+ }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of attributes of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class DOMAttributeIterator implements NodeIterator {\n     private NodePointer parent;\n         this.parent = parent;\n         this.name = name;\n         attributes = new ArrayList();\n-        Node node = (Node)parent.getValue();\n+        Node node = (Node)parent.getNodeValue();\n         if (node.getNodeType() == Node.ELEMENT_NODE){\n             String lname = name.getName();\n             if (!lname.equals(\"*\")){\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n         return attr;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         String value = attr.getValue();\n         if (value == null){\n             return null;\n         DOMAttributePointer other = (DOMAttributePointer)object;\n         return attr == other.attr;\n     }\n+    \n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        // Won't happen - attributes don't have children\n+        return 0;\n+    }    \n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class DOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n     public DOMNamespaceIterator(NodePointer parent){\n         this.parent = parent;\n         attributes = new ArrayList();\n-        collectNamespaces(attributes, (Node)parent.getValue());\n+        collectNamespaces(attributes, (Node)parent.getNodeValue());\n     }\n \n     private void collectNamespaces(List attributes, Node node){\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of children of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class DOMNodeIterator implements NodeIterator {\n     private NodePointer parent;\n \n     public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith){\n         this.parent = parent;\n-        this.node = (Node)parent.getValue();\n+        this.node = (Node)parent.getNodeValue();\n         if (startWith != null){\n-            this.child = (Node)startWith.getValue();\n+            this.child = (Node)startWith.getNodeValue();\n         }\n         this.nodeTest = nodeTest;\n         this.reverse = reverse;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n         return node;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         return node;\n     }\n \n         return name.substring(index + 1);\n     }\n \n-    public Object getCanonicalValue(){\n+    public Object getValue(){\n         return stringValue(node);\n     }\n \n         }\n         return factory;\n     }\n+    \n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        Node node1 = (Node)pointer1.getNodeValue();\n+        Node node2 = (Node)pointer2.getNodeValue();\n+        if (node1 == node2){\n+            return 0;\n+        }\n+        \n+        Node current = node.getFirstChild();\n+        while (current != null){\n+            if (current == node1){\n+                return -1;\n+            }\n+            else if (current == node2){\n+                return 1;\n+            }\n+            current = current.getNextSibling();\n+        }\n+\n+        return 0;\n+    }    \n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n  */\n public class NamespacePointer extends NodePointer {\n     private String prefix;\n         return null;\n     }\n \n-    public Object getValue(){\n+    public Object getNodeValue(){\n         return getNamespaceURI();\n     }\n \n         return (nsURI == null && otherNSURI == null) ||\n                (nsURI != null && nsURI.endsWith(otherNSURI));\n     }\n-}\n+ \n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        // Won't happen - namespaces don't have children\n+        return 0;\n+    }\n+ }\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.12 2002/04/21 21:52:34 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/04/21 21:52:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.13 2002/04/26 01:00:38 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/04/26 01:00:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2002/04/21 21:52:34 $\n+ * @version $Revision: 1.13 $ $Date: 2002/04/26 01:00:38 $\n  */\n \n public class JXPathTestCase extends TestCase\n         testGetValue(context, \"integers[1]\",            new Double(1), Double.class);\n         testGetValue(context, \"2 + 3\",                  \"5.0\", String.class);\n         testGetValue(context, \"2 + 3\",                  Boolean.TRUE, boolean.class);\n+        testGetValue(context, \"'true'\",                 Boolean.TRUE, Boolean.class);\n         boolean exception = false;\n         try {\n-            testGetValue(context, \"'foo'\",                  null, Date.class);\n+            testGetValue(context, \"'foo'\",              null, Date.class);\n         }\n         catch(Exception ex){\n             exception = true;\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, expr.isContextDependent());\n     }\n \n+    public void testDocumentOrder(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = JXPathContext.newContext(createTestBeanWithDOM());\n+        testDocumentOrder(context, \"boolean\", \"int\", -1);\n+        testDocumentOrder(context, \"integers[1]\", \"integers[2]\", -1);\n+        testDocumentOrder(context, \"integers[1]\", \"integers[1]\", 0);\n+        testDocumentOrder(context, \"nestedBean/int\", \"nestedBean\", 1);\n+        testDocumentOrder(context, \"nestedBean/int\", \"nestedBean/strings\", -1);\n+        testDocumentOrder(context, \"nestedBean/int\", \"object/int\", -1);\n+        testDocumentOrder(context, \"vendor/location\", \"vendor/location/address/street\", -1);\n+        testDocumentOrder(context, \"vendor/location[@id = '100']\", \"vendor/location[@id = '101']\", -1);\n+        testDocumentOrder(context, \"vendor//price:amount\", \"vendor/location\", 1);\n+//        testDocumentOrder(context, \"nonexistent//foo\", \"vendor/location\", 1);     // Will throw an exception\n+    }\n+\n+    private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n+        NodePointer np1 = (NodePointer)context.locateValue(path1);\n+        NodePointer np2 = (NodePointer)context.locateValue(path2);\n+        int res = np1.compareTo(np2);\n+        if (res < 0){\n+            res = -1;\n+        }\n+        else if (res > 0){\n+            res = 1;\n+        }\n+        assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n+    }\n+\n     /**\n      * Test JXPath.setValue() with various arguments\n      */\n         }\n     }\n \n-    public void testParserReferenceImpl(){\n+    public void testParserReferenceImpl() throws Exception {\n         if (!enabled){\n             return;\n         }\n         testParser(JXPathContextFactory.newInstance().newContext(null, bean), false);\n     }\n \n-    public void testParser(JXPathContext ctx, boolean ignorePath){\n+    public void testParser(JXPathContext ctx, boolean ignorePath) throws Exception {\n         ctx.setLocale(Locale.US);\n         ctx.getVariables().declareVariable(\"a\", new Double(1));\n         ctx.getVariables().declareVariable(\"b\", new Double(1));\n         testXPaths(ctx, xpath_tests, ignorePath);\n     }\n \n-    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath){\n+    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath) throws Exception{\n+        Exception exception = null;\n         for  (int i=0; i < xpath_tests.length; i++) {\n             try {\n                 Object actual;\n             catch (Exception ex){\n                 System.err.println(\"Exception during <\" + xpath_tests[i].xpath + \">\");\n                 ex.printStackTrace();\n+                exception = ex;\n+            }\n+            if (exception != null){\n+                throw exception;\n             }\n         }\n ", "timestamp": 1019782838, "metainfo": ""}