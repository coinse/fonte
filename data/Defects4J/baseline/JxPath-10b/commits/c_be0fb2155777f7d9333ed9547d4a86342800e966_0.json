{"sha": "be0fb2155777f7d9333ed9547d4a86342800e966", "log": "Encapsulated dynamic properties into a package of their own   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n+\n+/**\n+ * <code>DynamicAttributeIterator</code> is different from a regular\n+ * <code>BeanAttributeIterator</code> in that given a property name it\n+ * will always find that property (albeit with a null value).\n+ *  \n+ * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n+ * @version $Id: DynamicAttributeIterator.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ */\n+public class DynamicAttributeIterator extends BeanAttributeIterator {\n+\n+    public DynamicAttributeIterator(PropertyOwnerPointer parent, QName name) {\n+        super(parent, name);\n+    }\n+\n+     protected void prepareForIndividualProperty(String name){\n+         ((DynamicPropertyPointer)getPropertyPointer()).setPropertyName(name);\n+         super.prepareForIndividualProperty(name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/11/28 01:01:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.DynamicPropertyHandler;\n+import org.apache.commons.jxpath.JXPathIntrospector;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n+\n+/**\n+ * A Pointer that points to an object with Dynamic Properties. It is used\n+ * for the first element of a path; following elements will by of type PropertyPointer.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ */\n+public class DynamicPointer extends PropertyOwnerPointer {\n+    private QName name;\n+    private Object bean;\n+    private DynamicPropertyHandler handler;\n+    private String[] names;\n+\n+    public DynamicPointer(QName name, Object bean,\n+            DynamicPropertyHandler handler, Locale locale)\n+    {\n+        super(null, locale);\n+        this.name = name;\n+        this.bean = bean;\n+        this.handler = handler;\n+    }\n+\n+    public DynamicPointer(NodePointer parent, QName name,\n+            Object bean, DynamicPropertyHandler handler)\n+    {\n+        super(parent);\n+        this.name = name;\n+        this.bean = bean;\n+        this.handler = handler;\n+    }\n+\n+    public PropertyPointer getPropertyPointer(){\n+        return new DynamicPropertyPointer(this, handler);\n+    }\n+\n+    public NodeIterator createNodeIterator(\n+                String property, boolean reverse, NodePointer startWith)\n+    {\n+        return new DynamicPropertyIterator(this, property, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return new DynamicAttributeIterator(this, name);\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the DP object iself.\n+     */\n+    public Object getBaseValue(){\n+        return bean;\n+    }\n+    \n+    public boolean isLeaf() {\n+        Object value = getNode();\n+        return value == null\n+            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+    }    \n+    \n+    public boolean isCollection(){\n+        return false;\n+    }\n+\n+    /**\n+     * Returns 1.\n+     */\n+    public int getLength(){\n+        return 1;\n+    }\n+\n+    public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n+        return \"/\";\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(bean) + name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DynamicPointer)){\n+            return false;\n+        }\n+\n+        DynamicPointer other = (DynamicPointer)object;\n+        return bean == other.bean && name.equals(other.name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/11/28 01:01:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.DynamicPropertyHandler;\n+import org.apache.commons.jxpath.JXPathBeanInfo;\n+import org.apache.commons.jxpath.JXPathIntrospector;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n+import org.apache.commons.jxpath.util.ValueUtils;\n+\n+/**\n+ * Implements NodePointerFactory for Dynamic classes like Map.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ */\n+public class DynamicPointerFactory implements NodePointerFactory {\n+\n+    public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n+\n+    public int getOrder(){\n+        return DYNAMIC_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(name, bean, handler, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean == null){\n+            return new NullPointer(parent, name);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(parent, name, bean, handler);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyIterator;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n+\n+/**\n+ * <code>DynamicPropertyIterator</code> is different from a regular\n+ * <code>PropertyIterator</code> in that given a property name it\n+ * will always find that property (albeit with a null value).\n+ * \n+ * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n+ * @version $Id: DynamicPropertyIterator.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ */\n+public class DynamicPropertyIterator extends PropertyIterator {\n+\n+    public DynamicPropertyIterator(\n+            PropertyOwnerPointer pointer,\n+            String name,\n+            boolean reverse,\n+            NodePointer startWith) \n+    {\n+        super(pointer, name, reverse, startWith);\n+    }\n+\n+    protected void prepareForIndividualProperty(String name){\n+        ((DynamicPropertyPointer)getPropertyPointer()).setPropertyName(name);\n+        super.prepareForIndividualProperty(name);\n+   }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/11/28 01:01:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n+import org.apache.commons.jxpath.util.ValueUtils;\n+\n+/**\n+ * Pointer pointing to a property of an object with dynamic properties.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ */\n+public class DynamicPropertyPointer extends PropertyPointer {\n+    private DynamicPropertyHandler handler;\n+    private String name;\n+    private String[] names;\n+    private String requiredPropertyName;\n+\n+    public DynamicPropertyPointer(\n+            NodePointer parent,\n+            DynamicPropertyHandler handler) \n+    {\n+        super(parent);\n+        this.handler = handler;\n+    }\n+    /**\n+     * This type of node is auxiliary.\n+     */\n+    public boolean isContainer(){\n+        return true;\n+    }\n+\n+    /**\n+     * Number of the DP object's properties.\n+     */\n+    public int getPropertyCount(){\n+        return getPropertyNames().length;\n+    }\n+\n+    /**\n+     * Names of all properties, sorted alphabetically\n+     */\n+    public String[] getPropertyNames(){\n+        if (names == null){\n+            String allNames[] = handler.getPropertyNames(getBean());\n+            names = new String[allNames.length];\n+            for (int i = 0; i < names.length; i++){\n+                names[i] = allNames[i];\n+            }\n+            Arrays.sort(names);\n+            if (requiredPropertyName != null){\n+                int inx = Arrays.binarySearch(names, requiredPropertyName);\n+                if (inx < 0){\n+                    allNames = names;\n+                    names = new String[allNames.length + 1];\n+                    names[0] = requiredPropertyName;\n+                    System.arraycopy(allNames, 0, names, 1, allNames.length);\n+                    Arrays.sort(names);\n+                }\n+            }\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Returns the name of the currently selected property or \"*\"\n+     * if none has been selected.\n+     */\n+    public String getPropertyName(){\n+        if (name == null){\n+            String names[] = getPropertyNames();\n+            if (propertyIndex >=0 && propertyIndex < names.length){\n+                name = names[propertyIndex];\n+            }\n+            else {\n+                name = \"*\";\n+            }\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Select a property by name.  If the supplied name is\n+     * not one of the object's existing properties, it implicitly\n+     * adds this name to the object's property name list. It does not\n+     * set the property value though. In order to set the property\n+     * value, call setValue().\n+     */\n+    public void setPropertyName(String propertyName){\n+        setPropertyIndex(UNSPECIFIED_PROPERTY);\n+        this.name = propertyName;\n+        requiredPropertyName = propertyName;\n+        if (names != null && Arrays.binarySearch(names, propertyName) < 0){\n+            names = null;\n+        }\n+    }\n+\n+    /**\n+     * Index of the currently selected property in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public int getPropertyIndex(){\n+        if (propertyIndex == UNSPECIFIED_PROPERTY){\n+            String names[] = getPropertyNames();\n+            for (int i = 0; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    setPropertyIndex(i);\n+                    break;\n+                }\n+            }\n+        }\n+        return super.getPropertyIndex();\n+    }\n+\n+    /**\n+     * Index a property by its index in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public void setPropertyIndex(int index){\n+        if (propertyIndex != index){\n+            super.setPropertyIndex(index);\n+            name = null;\n+        }\n+    }\n+\n+    /**\n+     * Returns the value of the property, not an element of the collection\n+     * represented by the property, if any.\n+     */\n+    public Object getBaseValue(){\n+        return handler.getProperty(getBean(), getPropertyName());\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, the value of the property, otherwise\n+     * the value of the index'th element of the collection represented by the\n+     * property. If the property is not a collection, index should be zero\n+     * and the value will be the property itself.\n+     */\n+    public Object getImmediateNode(){\n+        Object value;\n+        if (index == WHOLE_COLLECTION) {\n+            value = handler.getProperty(getBean(), getPropertyName());\n+        }\n+        else {\n+            value =\n+                ValueUtils.getValue(\n+                    handler.getProperty(getBean(), getPropertyName()),\n+                    index);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * A dynamic property is always considered actual - all keys are apparently\n+     * existing with possibly the value of null.\n+     */\n+    protected boolean isActualProperty(){\n+        return true;\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n+     * change the value of the index'th element of the collection\n+     * represented by the property.\n+     */\n+    public void setValue(Object value){\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            ValueUtils.setValue(\n+                handler.getProperty(getBean(), getPropertyName()),\n+                index,\n+                value);\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, Object value){\n+        return createChild(context, getName(), index, value);\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n+        // Ignore the name passed to us, use our own data\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (collection == null) {\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory\n+                    .createObject(\n+                        context,\n+                        this,\n+                        getBean(),\n+                        getPropertyName(),\n+                        0)) {\n+                    throw new JXPathException(\n+                        \"Factory could not create an object for path: \"\n+                            + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0) {\n+                throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()) {\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                handler.setProperty(getBean(), getPropertyName(), collection);\n+            }\n+\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+        NodePointer ptr = (NodePointer) clone();\n+        ptr.setIndex(index);\n+        return ptr;\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        // Ignore the name passed to us, use our own data\n+        Object collection = getBaseValue();\n+        if (collection == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory\n+                .createObject(context, this, getBean(), getPropertyName(), 0)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+            collection = getBaseValue();\n+        }\n+\n+        if (index < 0) {\n+            throw new JXPathException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()) {\n+            collection = ValueUtils.expandCollection(collection, index + 1);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+\n+        DynamicPropertyPointer pointer = (DynamicPropertyPointer) this.clone();\n+        pointer.setIndex(index);\n+        return pointer;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (getNode() == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory\n+                .createObject(\n+                    context,\n+                    this,\n+                    getBean(),\n+                    getPropertyName(),\n+                    inx)) {\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public void remove(){\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n+        else if (isCollection()) {\n+            Object collection = ValueUtils.remove(getBaseValue(), index);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+        else if (index == 0) {\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getParent().asPath());\n+        if (buffer.length() == 0) {\n+            buffer.append(\"/.\");\n+        }\n+        else if (buffer.charAt(buffer.length() - 1) == '/') {\n+            buffer.append('.');\n+        }\n+        buffer.append(\"[@name='\");\n+        buffer.append(escape(getPropertyName()));\n+        buffer.append(\"']\");\n+        if (index != WHOLE_COLLECTION && isCollection()) {\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new JXPathException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/11/28 01:01:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model.dynamic;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.TestBean;\n+\n+/**\n+ * @todo more iterator testing with maps\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ */\n+\n+public class DynamicPropertiesModelTest extends JXPathTestCase\n+{\n+    private static boolean enabled = true;\n+    private JXPathContext context;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public DynamicPropertiesModelTest(String name){\n+        super(name);\n+    }\n+\n+    public void setUp(){\n+        if (context == null){\n+            context = JXPathContext.newContext(new TestBean());\n+            context.setFactory(new TestDynamicPropertyFactory());\n+        }\n+    }\n+\n+    public void testAxisChild(){\n+        assertXPathValue(context,\n+                \"map/Key1\",\n+                \"Value 1\");\n+\n+        assertXPathPointer(context,\n+                \"map/Key1\",\n+                \"/map[@name='Key1']\");\n+\n+        assertXPathValue(context,\n+                \"map/Key2/name\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"map/Key2/name\",\n+                \"/map[@name='Key2']/name\");\n+    }\n+\n+    public void testAxisDescendant(){\n+        assertXPathValue(context,\n+                \"//Key1\",\n+                \"Value 1\");\n+    }\n+\n+    /**\n+     * Testing the pseudo-attribute \"name\" that dynamic property\n+     * objects appear to have.\n+     */\n+    public void testAttributeName(){\n+        assertXPathValue(context,\n+                \"map[@name = 'Key1']\",\n+                \"Value 1\");\n+\n+        assertXPathPointer(context,\n+                \"map[@name = 'Key1']\",\n+                \"/map[@name='Key1']\");\n+\n+        assertXPathPointerLenient(context,\n+                \"map[@name = 'Key&quot;&apos;&quot;&apos;1']\",\n+                \"/map[@name='Key&quot;&apos;&quot;&apos;1']\");\n+\n+        assertXPathValue(context,\n+                \"/.[@name='map']/Key2/name\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/.[@name='map']/Key2/name\",\n+                \"/map[@name='Key2']/name\");\n+\n+        // Bean in a map\n+        assertXPathValue(context,\n+                \"/map[@name='Key2'][@name='name']\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/map[@name='Key2'][@name='name']\",\n+                \"/map[@name='Key2']/name\");\n+\n+        // Map in a bean in a map\n+        assertXPathValue(context,\n+                \"/.[@name='map'][@name='Key2'][@name='name']\",\n+                \"Name 6\");\n+\n+        assertXPathPointer(context,\n+                \"/.[@name='map'][@name='Key2'][@name='name']\",\n+                \"/map[@name='Key2']/name\");\n+    }\n+    \n+    public void testSetPrimitiveValue(){\n+        assertXPathSetValue(context, \n+                \"map/Key1\",\n+                new Integer(6));\n+    }\n+    \n+    public void testSetCollection(){\n+        // See if we can assign a whole collection        \n+        context.setValue(\n+                \"map/Key1\", \n+                new Integer[]{new Integer(7), new Integer(8)});\n+        \n+        // And then an element in that collection\n+        assertXPathSetValue(context,\n+                \"map/Key1[1]\", \n+                new Integer(9));\n+    }\n+    \n+    public void testSetNewKey(){\n+        assertXPathSetValue(context,\n+                \"map/Key4\", \n+                new Integer(7));\n+    }\n+    \n+    public void testCreatePath(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey1']\", \n+                \"\", \n+                \"/map[@name='TestKey1']\");\n+    }\n+    \n+    public void testCreatePathAndSetValue(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey1']\", \n+                \"Test\", \n+                \"/map[@name='TestKey1']\");\n+    }\n+    \n+    public void testCreatePathCreateBean(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey2']/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey2']/int\");\n+    }\n+    \n+    public void testCreatePathAndSetValueCreateBean(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey2']/int\", \n+                new Integer(4),\n+                \"/map[@name='TestKey2']/int\");\n+    }\n+    \n+    public void testCreatePathCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey3[2]\", \n+                null,\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePath(context, \n+                \"/map[@name='TestKey3'][3]\", \n+                null,\n+                \"/map[@name='TestKey3'][3]\");\n+    }\n+    \n+    public void testCreatePathAndSetValueCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey3[2]\", \n+                \"Test1\",\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map[@name='TestKey3'][3]\", \n+                \"Test2\",\n+                \"/map[@name='TestKey3'][3]\");\n+    }\n+    \n+    public void testCreatePathNewCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Create an element of a dynamic map element, which is a collection\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        bean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePath(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+    }\n+    \n+    public void testCreatePathAndSetValueNewCollectionElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.setMap(null);\n+        \n+        // Create an element of a dynamic map element, which is a collection\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(2),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        bean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        assertXPathCreatePathAndSetValue(context, \n+                \"/map/TestKey4[1]/int\", \n+                new Integer(3),\n+                \"/map[@name='TestKey4'][1]/int\");\n+    }\n+    \n+    public void testRemovePath(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+        bean.getMap().put(\"TestKey1\", \"test\");\n+\n+        // Remove dynamic property\n+        context.removePath(\"map[@name = 'TestKey1']\");\n+        assertEquals(\"Remove dynamic property value\", null,\n+                    context.getValue(\"map[@name = 'TestKey1']\"));\n+    }\n+    \n+    public void testRemovePathArrayElement(){\n+        TestBean bean = (TestBean)context.getContextBean();\n+\n+        bean.getMap().put(\"TestKey2\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"map[@name = 'TestKey2'][1]\");\n+        assertEquals(\"Remove dynamic property collection element\", \"temp2\",\n+                    context.getValue(\"map[@name = 'TestKey2'][1]\"));\n+    }\n+}", "timestamp": 1038445290, "metainfo": ""}