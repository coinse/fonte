{"sha": "907ab1054dc2a2c9c5e248aae74996d7a4ab1f6e", "log": "Improved formatting   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.2 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.3 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-\n /**\n- * The {@link JXPathContext#createPath JXPathContext.createPath()} method of JXPathContext can create\n- * missing objects as it traverses an XPath; it utilizes an AbstractFactory for that purpose.\n+ * The {@link JXPathContext#createPath JXPathContext.createPath()} method of JXPathContext can \n+ * create missing objects as it traverses an XPath; it utilizes an AbstractFactory for that purpose.\n  * Install a factory on JXPathContext by calling {@link JXPathContext#setFactory\n  * JXPathContext.setFactory()}.\n  * <p>\n  * return true to indicate that the factory has successfully created the described object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/24 03:29:33 $\n  */\n public abstract class AbstractFactory {\n \n      * the collection. Then it should create the index'th element of the collection\n      * and return true.\n      * <p>\n-     * If the parameters describe an individual object, the factory should only\n-     * create an object if index == 0.\n-     * <p>\n-     * Return the created object or <b>null</b> if this factory cannot create\n-     * the requested object.\n+     * \n+     * @param context can be used to evaluate other XPaths, get to variables etc.\n+     * @param pointer describes the location of the node to be created\n+     * @param parent is the object that will server as a parent of the new object\n+     * @param name is the name of the child of the parent that needs to be created. \n+     *        In the case of DOM may be qualified.\n+     * @param index is used if the pointer represents a collection element. You may\n+     *        need to expand or even create the collection to accomodate the new element.\n+     * \n+     * @return true if the object was successfully created\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+    public boolean createObject(JXPathContext context, Pointer pointer, \n+                                Object parent, String name, int index){\n         return false;\n     }\n \n     /**\n      * Create a new object and set it on the specified variable\n+     * \n+     * @param context hosts variable pools. See {@link JXPathContext#getVariables() \n+     *        JXPathContext.getVariables()}\n+     * @param name is the name of the variable without the \"$\" sign\n+     * \n+     * @return true if the variable was successfully defined\n      */\n     public boolean declareVariable(JXPathContext context, String name){\n         return false;\n--- a/src/java/org/apache/commons/jxpath/BasicVariables.java\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/BasicVariables.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/BasicVariables.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.HashMap;\n \n /**\n  * A basic implementation of the Variables interface that uses a HashMap.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n  */\n public class BasicVariables implements Variables {\n \n+    /**\n+     * Contains the values of declared variables\n+     */\n     private HashMap vars = new HashMap();\n \n     /**\n      * Returns true if the variable has been defined, even if the\n      * value of the variable is null.\n+     * \n+     * @param varName is a variable name without the \"$\" sign\n+     * \n+     * @return true if the variable is declared\n      */\n     public boolean isDeclaredVariable(String varName){\n         return vars.containsKey(varName);\n     /**\n      * Returns the value of the variable if it is defined,\n      * otherwise, throws IllegalArgumentException\n+     * \n+     * @param varName is a variable name without the \"$\" sign\n+     * \n+     * @return the value of the variable\n      */\n     public Object getVariable(String varName){\n         // Note that a variable may be defined with a null value\n     /**\n      * Defines a new variable with the specified value or modifies\n      * the value of an existing variable.\n+     * \n+     * @param varName is a variable name without the \"$\" sign\n+     * @param value is the new value for the variable, which can be null\n      */\n     public void declareVariable(String varName, Object value){\n         vars.put(varName, value);\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.4 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.functions.*;\n-import org.apache.commons.jxpath.util.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.commons.jxpath.functions.ConstructorFunction;\n+import org.apache.commons.jxpath.functions.MethodFunction;\n+import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n  * Extension functions provided by a Java class.\n  * the method.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/24 03:29:33 $\n  */\n public class ClassFunctions implements Functions {\n     private Class functionClass;\n         this.namespace = namespace;\n     }\n \n+    /**\n+     * Returns a set of one namespace - the one specified in the constructor.\n+     * \n+     * @returns a singleton\n+     */\n     public Set getUsedNamespaces(){\n         return Collections.singleton(namespace);\n     }\n     /**\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n+     * \n+     * @param namespace if it is not the namespace specified in the constructor,\n+     *     the method returns null\n+     * @param name is a function name or \"new\" for a constructor.\n+     * \n+     * @return a MethodFunction, a ConstructorFunction or null if there is no\n+     *      such function.\n      */\n-    public Function getFunction(String namespace, String name, Object[] parameters){\n-        if (!namespace.equals(this.namespace)){\n+    public Function getFunction(String namespace, String name, Object[] parameters) {\n+        if (!namespace.equals(this.namespace)) {\n             return null;\n         }\n \n-        if (parameters == null){\n+        if (parameters == null) {\n             parameters = EMPTY_ARRAY;\n         }\n \n-        if (name.equals(\"new\")){\n-            Constructor constructor = TypeUtils.lookupConstructor(functionClass, parameters);\n-            if (constructor != null){\n+        if (name.equals(\"new\")) {\n+            Constructor constructor =\n+                TypeUtils.lookupConstructor(functionClass, parameters);\n+            if (constructor != null) {\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n             Method method = TypeUtils.lookupStaticMethod(functionClass, name, parameters);\n-            if (method != null){\n+            if (method != null) {\n                 return new MethodFunction(method);\n             }\n \n             method = TypeUtils.lookupMethod(functionClass, name, parameters);\n-            if (method != null){\n+            if (method != null) {\n                 return new MethodFunction(method);\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactory.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactory.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * @see JXPathContext#newContext(JXPathContext,Object)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n  */\n public abstract class JXPathContextFactory {\n \n         method is called the second time ( cache the result of\n         finding the default impl )\n     */\n-    private static String foundFactory=null;\n+    private static String foundFactory = null;\n \n     /** Temp debug code - this will be removed after we test everything\n      */\n-    private static boolean debug=false;\n+    private static boolean debug = false;\n     static {\n-    try {\n-        debug=System.getProperty( \"jxpath.debug\" ) != null;\n-    } catch(SecurityException se ) {}\n+        try {\n+            debug = System.getProperty(\"jxpath.debug\") != null;\n+        }\n+        catch (SecurityException se) {\n+        }\n     }\n \n     /** Private implementation method - will find the implementation\n         class in the specified order.\n         @param property    Property name\n-        @param factoryId   Qualified property name\n         @param defaultFactory Default implementation, if nothing else is found\n+        \n+        @return class name of the JXPathContextFactory\n     */\n-    private static String findFactory(String property, String defaultFactory)\n-    {\n+    private static String findFactory(String property, String defaultFactory) {\n         // Use the system property first\n         try {\n-            String systemProp = System.getProperty( property );\n-            if( systemProp!=null) {\n-                if( debug )\n-                    System.err.println(\"JXPath: found system property\" +\n-                                       systemProp );\n+            String systemProp = System.getProperty(property);\n+            if (systemProp != null) {\n+                if (debug){\n+                    System.err.println(\"JXPath: found system property\" + systemProp);\n+                }\n                 return systemProp;\n             }\n \n-        }catch (SecurityException se) {\n-        }\n-\n-        if( foundFactory!=null)\n+        }\n+        catch (SecurityException se) {\n+        }\n+\n+        if (foundFactory != null){\n             return foundFactory;\n+        }\n \n         // Use the factory ID system property first\n         try {\n-            String systemProp =\n-                System.getProperty( property );\n-            if( systemProp!=null) {\n-                if( debug )\n-                    System.err.println(\"JXPath: found system property\" +\n-                                       systemProp );\n+            String systemProp = System.getProperty(property);\n+            if (systemProp != null) {\n+                if (debug){\n+                    System.err.println(\"JXPath: found system property\" + systemProp);\n+                }\n                 return systemProp;\n             }\n \n-        }catch (SecurityException se) {\n+        }\n+        catch (SecurityException se) {\n         }\n \n         // try to read from $java.home/lib/xml.properties\n         try {\n-            String javah=System.getProperty( \"java.home\" );\n-            String configFile = javah + File.separator +\n-                \"lib\" + File.separator + \"jxpath.properties\";\n-            File f=new File( configFile );\n-            if( f.exists()) {\n-                Properties props=new Properties();\n-                props.load( new FileInputStream(f));\n-                foundFactory=props.getProperty( property );\n-                if( debug )\n-                    System.err.println(\"JXPath: found java.home property \" +\n-                                       foundFactory );\n-                if(foundFactory!=null )\n+            String javah = System.getProperty(\"java.home\");\n+            String configFile =\n+                javah + File.separator + \"lib\" + File.separator + \"jxpath.properties\";\n+            File f = new File(configFile);\n+            if (f.exists()) {\n+                Properties props = new Properties();\n+                props.load(new FileInputStream(f));\n+                foundFactory = props.getProperty(property);\n+                if (debug){\n+                    System.err.println(\"JXPath: found java.home property \" + foundFactory);\n+                }\n+                if (foundFactory != null){\n                     return foundFactory;\n-            }\n-        } catch(Exception ex ) {\n-            if( debug ) ex.printStackTrace();\n+                }\n+            }\n+        }\n+        catch (Exception ex) {\n+            if (debug){\n+                ex.printStackTrace();\n+            }\n         }\n \n         String serviceId = \"META-INF/services/\" + property;\n         // try to find services in CLASSPATH\n         try {\n-            ClassLoader cl=JXPathContextFactory.class.getClassLoader();\n-            InputStream is=null;\n-            if( cl == null ) {\n-                is=ClassLoader.getSystemResourceAsStream( serviceId );\n-            } else {\n-                is=cl.getResourceAsStream( serviceId );\n-            }\n-\n-            if( is!=null ) {\n-                if( debug )\n-                    System.err.println(\"JXPath: found  \" +\n-                                       serviceId);\n-                BufferedReader rd=new BufferedReader( new\n-                    InputStreamReader(is));\n-\n-                foundFactory=rd.readLine();\n+            ClassLoader cl = JXPathContextFactory.class.getClassLoader();\n+            InputStream is = null;\n+            if (cl == null) {\n+                is = ClassLoader.getSystemResourceAsStream(serviceId);\n+            }\n+            else {\n+                is = cl.getResourceAsStream(serviceId);\n+            }\n+\n+            if (is != null) {\n+                if (debug){\n+                    System.err.println(\"JXPath: found  \" + serviceId);\n+                }\n+                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n+\n+                foundFactory = rd.readLine();\n                 rd.close();\n \n-                if( debug )\n-                    System.err.println(\"JXPath: loaded from services: \" +\n-                                       foundFactory );\n-                if( foundFactory != null &&\n-                    !  \"\".equals( foundFactory) ) {\n+                if (debug){\n+                    System.err.println(\"JXPath: loaded from services: \" + foundFactory);\n+                }\n+                if (foundFactory != null && !\"\".equals(foundFactory)) {\n                     return foundFactory;\n                 }\n             }\n-        } catch( Exception ex ) {\n-            if( debug ) ex.printStackTrace();\n+        }\n+        catch (Exception ex) {\n+            if (debug){\n+                ex.printStackTrace();\n+            }\n         }\n \n         return defaultFactory;\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-\n /**\n  * Thrown when a problem with configuration with the JXPathContextFactories\n  * exists. This error will typically be thrown when the class of a\n  * or instantiated.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n  */\n \n public class JXPathContextFactoryConfigurationError extends Error {\n      * @param e The exception to be encapsulated in a\n      * JXPathContextFactoryConfigurationError\n      * @param msg The detail message.\n-     * @param e The exception to be wrapped in a JXPathContextFactoryConfigurationError\n      */\n \n     public JXPathContextFactoryConfigurationError(Exception e, String msg) {\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathIntrospector.java,v 1.2 2001/09/11 23:34:26 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/11 23:34:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathIntrospector.java,v 1.3 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-import org.apache.commons.jxpath.MapDynamicPropertyHandler;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import java.util.WeakHashMap;\n \n /**\n  * JXPathIntrospector maintains a registry of {@link JXPathBeanInfo JXPathBeanInfo} objects\n  * for Java classes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/11 23:34:26 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/24 03:29:33 $\n  */\n public class JXPathIntrospector {\n \n      * </ul>\n      */\n     public static JXPathBeanInfo getBeanInfo(Class beanClass) {\n-        JXPathBeanInfo beanInfo = (JXPathBeanInfo)byClass.get(beanClass);\n-        if (beanInfo == null){\n+        JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass);\n+        if (beanInfo == null) {\n             beanInfo = findInformant(beanClass);\n-            if (beanInfo == null){\n+            if (beanInfo == null) {\n                 beanInfo = new JXPathBasicBeanInfo(beanClass);\n             }\n             byClass.put(beanClass, beanInfo);\n     private static synchronized JXPathBeanInfo findInformant(Class beanClass) {\n         String name = beanClass.getName() + \"XBeanInfo\";\n         try {\n-            return (JXPathBeanInfo)instantiate(beanClass, name);\n-        } catch (Exception ex) {\n+            return (JXPathBeanInfo) instantiate(beanClass, name);\n+        }\n+        catch (Exception ex) {\n             // Just drop through\n         }\n \n         // Now try checking if the bean is its own JXPathBeanInfo.\n         try {\n             if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) {\n-                return (JXPathBeanInfo)beanClass.newInstance();\n+                return (JXPathBeanInfo) beanClass.newInstance();\n             }\n-        } catch (Exception ex) {\n+        }\n+        catch (Exception ex) {\n             // Just drop through\n         }\n \n      * classloader.\n      */\n     private static Object instantiate(Class sibling, String className)\n-                 throws Exception {\n+        throws Exception {\n \n         // First check with sibling's classloader (if any).\n         ClassLoader cl = sibling.getClassLoader();\n             try {\n                 Class cls = cl.loadClass(className);\n                 return cls.newInstance();\n-            } catch (Exception ex) {\n+            }\n+            catch (Exception ex) {\n                 // Just drop through and try the system classloader.\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java,v 1.1 2001/09/11 23:34:26 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/11 23:34:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.Iterator;\n+import java.util.Map;\n \n /**\n  * Implements the DynamicPropertyHandler interface for java.util.Map.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/11 23:34:26 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n  */\n public class MapDynamicPropertyHandler implements DynamicPropertyHandler {\n \n      * Returns string representations of all keys in the map.\n      */\n     public String[] getPropertyNames(Object object){\n-        Map map = (Map)object;\n+        Map map = (Map) object;\n         String names[] = new String[map.size()];\n         Iterator it = map.keySet().iterator();\n         for (int i = 0; i < names.length; i++){\n     /**\n      * Returns the value for the specified key.\n      */\n-    public Object getProperty(Object object, String propertyName){\n-        return ((Map)object).get(propertyName);\n+    public Object getProperty(Object object, String propertyName) {\n+        return ((Map) object).get(propertyName);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.4 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.functions.*;\n-import org.apache.commons.jxpath.util.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.commons.jxpath.functions.ConstructorFunction;\n+import org.apache.commons.jxpath.functions.MethodFunction;\n+import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n  * Extension functions provided by Java classes.  The class prefix specified\n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/24 03:29:33 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n     private String namespace;\n     private static final Object[] EMPTY_ARRAY = new Object[0];\n \n-    public PackageFunctions(String classPrefix, String namespace){\n+    public PackageFunctions(String classPrefix, String namespace) {\n         this.classPrefix = classPrefix;\n         this.namespace = namespace;\n     }\n \n-    public Set getUsedNamespaces(){\n+    /**\n+     * Returns the namespace specified in the constructor\n+     */\n+    public Set getUsedNamespaces() {\n         return Collections.singleton(namespace);\n     }\n \n     /**\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n+     * <p>\n+     * @param namespace - if it is not the same as specified in the construction,\n+     *      this method returns null\n+     * @param name - name of the method, which can one these forms:\n+     * <ul>\n+     * <li><b>methodname</b>, if invoking a method on an object passed as the first parameter</li>\n+     * <li><b>Classname.new</b>, if looking for a constructor</li>\n+     * <li><b>subpackage.subpackage.Classname.new</b>, if looking for a constructor in\n+     *      a subpackage</li>\n+     * <li><b>Classname.methodname</b>, if looking for a static method</li>\n+     * <li><b>subpackage.subpackage.Classname.methodname</b>, if looking for a \n+     *      static method of a class in a subpackage</li>\n+     * </ul>\n+     * \n+     * @return a MethodFunction, a ConstructorFunction or null if no function is found\n      */\n-    public Function getFunction(String namespace, String name, Object[] parameters){\n-        if ((namespace == null && this.namespace != null) ||\n-                (namespace != null && !namespace.equals(this.namespace))){\n+    public Function getFunction(String namespace, String name, Object[] parameters) {\n+        if ((namespace == null && this.namespace != null)\n+            || (namespace != null && !namespace.equals(this.namespace))) {\n             return null;\n         }\n \n-        if (parameters == null){\n+        if (parameters == null) {\n             parameters = EMPTY_ARRAY;\n         }\n \n-        if (parameters.length >= 1){\n+        if (parameters.length >= 1) {\n             Object target = parameters[0];\n-            if (target != null){\n-                if (target instanceof ExpressionContext){\n-                    Pointer pointer = ((ExpressionContext)target).getContextNodePointer();\n-                    if (pointer != null){\n+            if (target != null) {\n+                if (target instanceof ExpressionContext) {\n+                    Pointer pointer = ((ExpressionContext) target).getContextNodePointer();\n+                    if (pointer != null) {\n                         target = pointer.getValue();\n                     }\n                     else {\n                     }\n                 }\n             }\n-            if (target != null){\n+            if (target != null) {\n                 Method method = TypeUtils.lookupMethod(target.getClass(), name, parameters);\n-                if (method != null){\n+                if (method != null) {\n                     return new MethodFunction(method);\n                 }\n             }\n \n         String fullName = classPrefix + name;\n         int inx = fullName.lastIndexOf('.');\n-        if (inx == -1){\n+        if (inx == -1) {\n             return null;\n         }\n \n         try {\n             functionClass = Class.forName(className);\n         }\n-        catch (ClassNotFoundException ex){\n+        catch (ClassNotFoundException ex) {\n             throw new RuntimeException(\"Class not found: \" + ex);\n         }\n \n-        if (methodName.endsWith(\"new\")){\n-            Constructor constructor = TypeUtils.lookupConstructor(functionClass, parameters);\n-            if (constructor != null){\n+        if (methodName.endsWith(\"new\")) {\n+            Constructor constructor =\n+                TypeUtils.lookupConstructor(functionClass, parameters);\n+            if (constructor != null) {\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n-            Method method = TypeUtils.lookupStaticMethod(functionClass, methodName, parameters);\n-            if (method != null){\n+            Method method =\n+                TypeUtils.lookupStaticMethod(functionClass, methodName, parameters);\n+            if (method != null) {\n                 return new MethodFunction(method);\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:29:33 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-\n /**\n  * Pointers represent locations of objects and their properties\n  * in Java object graphs. JXPathContext has methods\n  * the map, which is the value of the property \"aMap\" of the root object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n  */\n public interface Pointer {\n \n--- a/src/java/org/apache/commons/jxpath/Variables.java\n+++ b/src/java/org/apache/commons/jxpath/Variables.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Variables.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Variables.java,v 1.2 2002/04/24 03:30:17 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:30:17 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-\n /**\n  * Variables provide access to a global set of values accessible via XPath.\n  * XPath can reference variables using the \"$varname\" syntax. To use a custom\n  * @see JXPathContext#setVariables\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:30:17 $\n  */\n public interface Variables {\n \n--- a/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.2 2002/04/11 03:00:11 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/11 03:00:11 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.3 2002/04/24 03:30:17 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/24 03:30:17 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.io.InputStream;\n+import java.net.URL;\n+\n import javax.xml.transform.Source;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n import javax.xml.transform.stream.StreamSource;\n-import javax.xml.transform.dom.DOMResult;\n-import java.net.URL;\n-import org.w3c.dom.*;\n-import java.io.InputStream;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n \n /**\n  * An XML document container reads and parses XML only when it is\n  * read at all.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/11 03:00:11 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/24 03:30:17 $\n  */\n public class XMLDocumentContainer implements Container {\n \n     private URL xmlURL;\n     private Source source;\n \n+    /**\n+     * @param URL is a URL for an XML file. Use getClass().getResource(resourceName)\n+     * to load XML from a resource file.\n+     */\n     public XMLDocumentContainer(URL xmlURL){\n         this.xmlURL = xmlURL;\n         if (xmlURL == null){\n         }\n     }\n \n+    /**\n+     * Reads XML, caches it internally and returns the Document.\n+     */\n     public Object getValue(){\n         if (document == null){\n             try {\n                     DOMResult result = new DOMResult();\n                     Transformer trans = TransformerFactory.newInstance().newTransformer();\n                     trans.transform(source, result);\n-                    document = (Document)result.getNode();\n+                    document = (Document) result.getNode();\n                 }\n                 finally {\n                     if (stream != null){\n         return document;\n     }\n \n+    /**\n+     * Throws an UnsupportedOperationException\n+     */\n     public void setValue(Object value){\n         throw new UnsupportedOperationException();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/21 21:52:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.2 2002/04/24 03:31:59 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/24 03:31:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model;\n \n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathIntrospector;\n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.util.*;\n-\n-import java.util.*;\n+import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n+import org.apache.commons.jxpath.ri.model.beans.NullElementPointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n+import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * Common superclass for Pointers of all kinds.  A NodePointer maps to\n  * context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/24 03:31:59 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable {\n \n      * Allocates an entirely new NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n-    public static NodePointer newNodePointer(QName name, Object bean, Locale locale){\n-        if (bean == null){\n+    public static NodePointer newNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale) {\n+        if (bean == null) {\n             return new NullPointer(name, locale);\n         }\n-        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n-        for (int i = 0; i < factories.length; i++){\n+        NodePointerFactory[] factories =\n+            JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++) {\n             NodePointer pointer = factories[i].createNodePointer(name, bean, locale);\n-            if (pointer != null){\n+            if (pointer != null) {\n                 return pointer;\n             }\n         }\n-        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n+        throw new RuntimeException(\n+            \"Could not allocate a NodePointer for object of \" + bean.getClass());\n     }\n \n     /**\n      * Allocates an new child NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n-    public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean){\n-        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n-        for (int i = 0; i < factories.length; i++){\n+    public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean) {\n+        NodePointerFactory[] factories =\n+            JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++) {\n             NodePointer pointer = factories[i].createNodePointer(parent, name, bean);\n-            if (pointer != null){\n+            if (pointer != null) {\n                 return pointer;\n             }\n         }\n-        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n+        throw new RuntimeException(\n+            \"Could not allocate a NodePointer for object of \" + bean.getClass());\n     }\n \n     protected NodePointer parent;\n     protected Locale locale;\n \n-    protected NodePointer(NodePointer parent){\n+    protected NodePointer(NodePointer parent) {\n         this.parent = parent;\n     }\n \n-    protected NodePointer(NodePointer parent, Locale locale){\n+    protected NodePointer(NodePointer parent, Locale locale) {\n         this.parent = parent;\n         this.locale = locale;\n     }\n \n-    public NodePointer getParent(){\n+    public NodePointer getParent() {\n         return parent;\n     }\n \n     /**\n      * Returns true if this Pointer has no parent.\n      */\n-    public boolean isRoot(){\n+    public boolean isRoot() {\n         return parent == null;\n     }\n \n     /**\n      * If true, this node does not have children\n      */\n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         Object value = getValue();\n-        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+        return value == null\n+            || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n     /**\n      * If false, this node is axiliary and can only be used as an intermediate\n      * in the chain of pointers.\n      */\n-    public boolean isNode(){\n+    public boolean isNode() {\n         return true;\n     }\n \n      * is not indexed at all.\n      * Note: the index on NodePointer starts with 0, not 1.\n      */\n-    public int getIndex(){\n+    public int getIndex() {\n         return index;\n     }\n \n-    public void setIndex(int index){\n+    public void setIndex(int index) {\n         this.index = index;\n     }\n \n      * Returns <code>true</code> if the value of the pointer is an array or\n      * a Collection.\n      */\n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n      * If the pointer represents a collection (or collection element),\n      * returns the length of the collection. Otherwise returns 1 (even if the value is null).\n      */\n-    public int getLength(){\n+    public int getLength() {\n         Object value = getBaseValue();\n-        if (value == null){\n+        if (value == null) {\n             return 1;\n         }\n         return ValueUtils.getLength(value);\n      * return a \"canonical\" value, like for instance a DOM element should\n      * return its string value.\n      */\n-    public Object getCanonicalValue(){\n+    public Object getCanonicalValue() {\n         return getValue();\n     }\n \n      * Only an auxiliary (non-node) pointer can (and should) return a\n      * value pointer other than itself.\n      */\n-    public NodePointer getValuePointer(){\n+    public NodePointer getValuePointer() {\n         return this;\n     }\n \n      * (In JavaBeans) if <em>address</em> is not a property of the root bean, a Pointer\n      * for this path cannot be obtained at all - actual or otherwise.\n      */\n-    public boolean isActual(){\n-        if (index == WHOLE_COLLECTION){\n+    public boolean isActual() {\n+        if (index == WHOLE_COLLECTION) {\n             return true;\n         }\n         else {\n     /**\n      * Checks if this Pointer matches the supplied NodeTest.\n      */\n-    public boolean testNode(NodeTest test){\n-        if (test == null){\n+    public boolean testNode(NodeTest test) {\n+        if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest){\n-            if (!isNode()){\n+        else if (test instanceof NodeNameTest) {\n+            if (!isNode()) {\n                 return false;\n             }\n-            QName testName = ((NodeNameTest)test).getNodeName();\n+            QName testName = ((NodeNameTest) test).getNodeName();\n             QName nodeName = getName();\n             String testPrefix = testName.getPrefix();\n             String nodePrefix = nodeName.getPrefix();\n-            if (!equalStrings(testPrefix, nodePrefix)){\n+            if (!equalStrings(testPrefix, nodePrefix)) {\n                 String testNS = getNamespaceURI(testPrefix);\n                 String nodeNS = getNamespaceURI(nodePrefix);\n-                if (!equalStrings(testNS, nodeNS)){\n+                if (!equalStrings(testNS, nodeNS)) {\n                     return false;\n                 }\n             }\n             String testLocalName = testName.getName();\n-            if (testLocalName.equals(\"*\")){\n+            if (testLocalName.equals(\"*\")) {\n                 return true;\n             }\n             return testLocalName.equals(nodeName.getName());\n         }\n-        else if (test instanceof NodeTypeTest){\n-            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+        else if (test instanceof NodeTypeTest) {\n+            if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) {\n                 return isNode();\n             }\n         }\n         return false;\n     }\n \n-    private static boolean equalStrings(String s1, String s2){\n-        if (s1 == null && s2 != null){\n+    private static boolean equalStrings(String s1, String s2) {\n+        if (s1 == null && s2 != null) {\n             return false;\n         }\n-        if (s1 != null && !s1.equals(s2)){\n+        if (s1 != null && !s1.equals(s2)) {\n             return false;\n         }\n         return true;\n      *  Called directly by JXPathContext. Must create path and\n      *  set value.\n      */\n-    public void createPath(JXPathContext context, Object value){\n+    public void createPath(JXPathContext context, Object value) {\n         setValue(value);\n     }\n \n      * Must create an object described by this pointer and return\n      * a new pointer that properly describes the new object.\n      */\n-    public NodePointer createPath(JXPathContext context){\n+    public NodePointer createPath(JXPathContext context) {\n         return this;\n     }\n \n      * node. This method must may have to expand the collection in order to\n      * assign the element.\n      */\n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n-        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n-                \", operation is not allowed for this type of node\");\n+    public void createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index,\n+        Object value) {\n+        throw new RuntimeException(\n+            \"Cannot create an object for path \"\n+                + asPath()\n+                + \", operation is not allowed for this type of node\");\n     }\n \n     /**\n      * then create an element object and return a new pointer describing the\n      * newly created element.\n      */\n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n-        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n-                \", operation is not allowed for this type of node\");\n+    public NodePointer createChild(JXPathContext context, QName name, int index) {\n+        throw new RuntimeException(\n+            \"Cannot create an object for path \"\n+                + asPath()\n+                + \", operation is not allowed for this type of node\");\n     }\n \n     /**\n      * otherwise returns the locale specified when this Pointer\n      * was created.\n      */\n-    public Locale getLocale(){\n-        if (locale == null){\n-            if (parent != null){\n+    public Locale getLocale() {\n+        if (locale == null) {\n+            if (parent != null) {\n                 locale = parent.getLocale();\n             }\n         }\n      * Returns true if the selected locale name starts\n      * with the specified prefix <i>lang</i>, case-insensitive.\n      */\n-    public boolean isLanguage(String lang){\n+    public boolean isLanguage(String lang) {\n         Locale loc = getLocale();\n         String name = loc.toString().replace('_', '-');\n         return name.toUpperCase().startsWith(lang.toUpperCase());\n      * Returns a NodeIterator that iterates over all children or all children\n      * that match the given NodeTest, starting with the specified one.\n      */\n-    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) {\n         return null;\n     }\n \n      * matching the supplied node name (could have a wildcard).\n      * May return null if the object does not support the attributes.\n      */\n-    public NodeIterator attributeIterator(QName qname){\n+    public NodeIterator attributeIterator(QName qname) {\n         return null;\n     }\n \n      * currently pointed at.\n      * May return null if the object does not support the namespaces.\n      */\n-    public NodeIterator namespaceIterator(){\n+    public NodeIterator namespaceIterator() {\n         return null;\n     }\n \n      * Returns a NodePointer for the specified namespace. Will return null\n      * if namespaces are not supported. Will return UNKNOWN_NAMESPACE if there is no such namespace.\n      */\n-    public NodePointer namespacePointer(String namespace){\n+    public NodePointer namespacePointer(String namespace) {\n         return null;\n     }\n \n     /**\n      * Decodes a namespace prefix to the corresponding URI.\n      */\n-    public String getNamespaceURI(String prefix){\n+    public String getNamespaceURI(String prefix) {\n         return null;\n     }\n \n     /**\n      * Returns the namespace URI associated with this Pointer.\n      */\n-    public String getNamespaceURI(){\n+    public String getNamespaceURI() {\n         return null;\n     }\n \n      * Returns true if the supplied prefix represents the\n      * default namespace in the context of the current node.\n      */\n-    protected boolean isDefaultNamespace(String prefix){\n-        if (prefix == null){\n+    protected boolean isDefaultNamespace(String prefix) {\n+        if (prefix == null) {\n             return true;\n         }\n \n         String namespace = getNamespaceURI(prefix);\n-        if (namespace == null){\n-            return false;       // undefined namespace\n+        if (namespace == null) {\n+            return false; // undefined namespace\n         }\n \n         return namespace.equals(getDefaultNamespaceURI());\n     }\n \n-    protected String getDefaultNamespaceURI(){\n+    protected String getDefaultNamespaceURI() {\n         return null;\n     }\n \n      * Returns a name that consists of the namespaceURI and the local name\n      * of the node.  For non-XML pointers, returns the Pointer's qualified name.\n      */\n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return getName();\n     }\n \n     /**\n      * Returns an XPath that maps to this Pointer.\n      */\n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (getParent() != null){\n+        if (getParent() != null) {\n             buffer.append(getParent().asPath());\n             // TBD: the following needs to be redesigned.  What this condition says is\n             // \"if the parent of this node has already appended this node's name,\n             // don't do it again\".  However, I would hate to add an ugly API like\n             // \"isResponsibleForAppendingChildName()\".\n-            if (getParent().isNode() || (parent instanceof NullElementPointer)){\n+            if (getParent().isNode() || (parent instanceof NullElementPointer)) {\n                 QName name = getName();\n-                if (name != null){\n+                if (name != null) {\n                     buffer.append('/');\n                     buffer.append(name);\n                 }\n             QName name = getName();\n             buffer.append(name);\n         }\n-        if (index != WHOLE_COLLECTION && isCollection()){\n+        if (index != WHOLE_COLLECTION && isCollection()) {\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n     }\n \n-    public Object clone(){\n+    public Object clone() {\n         try {\n             return super.clone();\n         }\n-        catch (CloneNotSupportedException ex){\n+        catch (CloneNotSupportedException ex) {\n             // Of course it is supported\n             ex.printStackTrace();\n         }\n         return null;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return asPath();\n     }\n }", "timestamp": 1019619119, "metainfo": ""}