{"sha": "af69a899246ea9aaf87a8ab581fb9cdb87e444d9", "log": "Updated test cases to the latest changes   ", "commit": "\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.25 2002/07/03 21:12:36 dmitri Exp $\n- * $Revision: 1.25 $\n- * $Date: 2002/07/03 21:12:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.26 2002/08/10 01:50:38 dmitri Exp $\n+ * $Revision: 1.26 $\n+ * $Date: 2002/08/10 01:50:38 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.axes.*;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n import java.beans.*;\n \n /**\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.25 $ $Date: 2002/07/03 21:12:36 $\n+ * @version $Revision: 1.26 $ $Date: 2002/08/10 01:50:38 $\n  */\n \n public class JXPathTestCase extends TestCase\n         testGetValue(context, \"2 + 3\",                  Boolean.TRUE, boolean.class);\n         testGetValue(context, \"'true'\",                 Boolean.TRUE, Boolean.class);\n \n-        Map tm = new HashMap();\n+        Map tm = new Hashtable();\n         tm.put(\"bar\", \"zz\");\n         bean.getMap().put(\"foo\", new Map[]{tm, tm});\n         bean.getMap().put(\"biz\", tm);\n      * Test JXPath.getValue() with variables\n      */\n     public void testVariables(){\n-        if (enabled){\n-            JXPathContext context = JXPathContext.newContext(bean.getBeans());\n-            context.getVariables().declareVariable(\"x\", new Double(7.0));\n-            context.getVariables().declareVariable(\"y\", null);\n-            context.getVariables().declareVariable(\"z\", bean);\n-            context.getVariables().declareVariable(\"t\", new String[]{\"a\", \"b\"});\n-            context.getVariables().declareVariable(\"m\", bean.getMap());\n-\n-            testGetValue(context, \"$x + 3\",  new Double(10.0));\n-            testGetValue(context, \"$y\",  null);\n-            testGetValue(context, \"$y + 1\",  new Double(1.0));\n-            boolean exception = false;\n-            try {\n-                testGetValue(context, \"$none\",  null);\n-            }\n-            catch (Exception ex){\n-                exception = true;\n-            }\n-            assertTrue(\"Evaluating '$none', expected exception - did not get it\", exception);\n-\n-            testGetValue(context, \"$z/int\",  new Integer(1));\n-            testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n-            testGetValue(context, \".\",  bean.getBeans());\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean.getBeans());\n+        context.getVariables().declareVariable(\"x\", new Double(7.0));\n+        context.getVariables().declareVariable(\"y\", null);\n+        context.getVariables().declareVariable(\"z\", bean);\n+        context.getVariables().declareVariable(\"t\", new String[]{\"a\", \"b\"});\n+        context.getVariables().declareVariable(\"m\", bean.getMap());\n+\n+        testGetValue(context, \"$x + 3\",  new Double(10.0));\n+        testGetValue(context, \"$y\",  null);\n+        testGetValue(context, \"$y + 1\",  new Double(1.0));\n+        boolean exception = false;\n+        try {\n+            testGetValue(context, \"$none\",  null);\n+        }\n+        catch (Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Evaluating '$none', expected exception - did not get it\", exception);\n+\n+        testGetValue(context, \"$z/int\",  new Integer(1));\n+        testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n+        testGetValue(context, \".\",  bean.getBeans());\n //            testGetValue(context, \".[2]/name\",  \"Name 2\");        // TBD: is this even legal?\n-            testGetValue(context, \"$t[2]\",  \"b\");\n-            testGetValue(context, \"$m/Key1\",  \"Value 1\");\n-        }\n+        testGetValue(context, \"$t[2]\",  \"b\");\n+        testGetValue(context, \"$m/Key1\",  \"Value 1\");\n     }\n \n     private void testGetValue(JXPathContext context, String xpath, Object expected) {\n             return;\n         }\n \n-        JXPathContext context = JXPathContext.newContext(createTestBeanWithDOM());\n+        JXPathContext context = JXPathContext.newContext(bean);\n \n         testDocumentOrder(context, \"boolean\", \"int\", -1);\n         testDocumentOrder(context, \"integers[1]\", \"integers[2]\", -1);\n         testDocumentOrder(context, \"nestedBean/int\", \"nestedBean\", 1);\n         testDocumentOrder(context, \"nestedBean/int\", \"nestedBean/strings\", -1);\n         testDocumentOrder(context, \"nestedBean/int\", \"object/int\", -1);\n+\n+        context = JXPathContext.newContext(createTestBeanWithDOM());\n         testDocumentOrder(context, \"vendor/location\", \"vendor/location/address/street\", -1);\n         testDocumentOrder(context, \"vendor/location[@id = '100']\", \"vendor/location[@id = '101']\", -1);\n         testDocumentOrder(context, \"vendor//price:amount\", \"vendor/location\", 1);\n     private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n         NodePointer np1 = (NodePointer)context.getPointer(path1);\n         NodePointer np2 = (NodePointer)context.getPointer(path2);\n-        int res = np1.compareTo(np2);\n-        if (res < 0){\n-            res = -1;\n-        }\n-        else if (res > 0){\n-            res = 1;\n-        }\n-        assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n+        try {\n+            int res = np1.compareTo(np2);\n+            if (res < 0){\n+                res = -1;\n+            }\n+            else if (res > 0){\n+                res = 1;\n+            }\n+            assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n+        }\n+        catch (Exception ex){\n+            System.err.println(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\");\n+            ex.printStackTrace();\n+        }\n     }\n \n     /**\n         if (!enabled){\n             return;\n         }\n-        TestBeanWithDOM tBean = createTestBeanWithDOM();\n+        TestBeanWithNode tBean = createTestBeanWithDOM();\n         tBean.setNestedBean(null);\n         tBean.setBeans(null);\n         tBean.setMap(null);\n         testCreatePath(context, \"/map[@name='TestKey5']/nestedBean/int\", new Integer(1));\n         tBean.setMap(null);\n         testCreatePath(context, \"/map[@name='TestKey5']/beans[2]/int\", new Integer(1));\n+\n     }\n \n     private void testCreatePath(JXPathContext context, String path, Object value){\n \n     private void testCreatePath(JXPathContext context, String path,\n                 Object value, String expectedPath){\n-        Pointer ptr = context.createPath(path);\n+        Pointer ptr = null;\n+        try {\n+            ptr = context.createPath(path);\n+        }\n+        catch(JXPathException ex){\n+            ex.getException().printStackTrace();\n+        }\n+\n         assertEquals(\"Pointer <\" + path + \">\", expectedPath, ptr.asPath());\n         assertEquals(\"Created <\" + path + \">\", value, ptr.getValue());\n     }\n         testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(6));\n         tBean.setMap(null);\n         testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(7));\n+\n+        context = JXPathContext.newContext(new HashMap());\n+        context.setFactory(new TestFactory());\n+        testCreatePathAndSetValue(context, \"/testKey1/testKey2/testKey3\", new Integer(8));\n+        context.setValue(\"/testKey1\", new HashMap());\n     }\n \n     private void testCreatePathAndSetValue(JXPathContext context, String path, Object value){\n         if (!enabled){\n             return;\n         }\n-        TestBeanWithDOM tBean = createTestBeanWithDOM();\n+        TestBeanWithNode tBean = createTestBeanWithDOM();\n         JXPathContext context = JXPathContext.newContext(tBean);\n \n         // Undeclare variable\n             context.getValue(\"id(101)//street\"));\n         assertEquals(\"Test ID Path\", \"id('101')/address[1]/street[1]\",\n             context.getPointer(\"id(101)//street\").asPath());\n-        assertEquals(\"Test ID Path Null\", \"id(105)/address[1]/street\",\n-            context.getPointer(\"id(105)/address/street\").asPath());\n+\n         assertEquals(\"Test key\", \"42\",\n             context.getValue(\"key('a', 'b')\"));\n+\n+        context.setLenient(true);\n+        assertEquals(\"Test ID Path Null\", \"id(105)/address/street\",\n+            context.getPointer(\"id(105)/address/street\").asPath());\n     }\n \n     public void testNull(){\n                             actual = paths;\n                         }\n                         else {\n+                            ctx.setLenient(xpath_tests[i].lenient);\n                             actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n                         }\n                     }\n     }\n \n     private static XP testPath(String xpath, Object expected){\n-        return new XP(xpath, expected, false, true, false);\n+        return new XP(xpath, expected, false, true, true);\n     }\n \n     private static XP testEvalPath(String xpath, Object expected){\n         }\n         System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n                 \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n-        XMLDocumentContainer docCtr = new XMLDocumentContainer(getClass().getResource(\"Vendor.xml\"));\n+        DocumentContainer docCtr = new DocumentContainer(getClass().getResource(\"Vendor.xml\"));\n         Document doc = (Document)docCtr.getValue();\n         JXPathContext ctx = JXPathContextFactory.newInstance().newContext(null, doc);\n         ctx.setLocale(Locale.US);\n         ctx.getVariables().declareVariable(\"dom\", doc);\n         ctx.getVariables().declareVariable(\"object\", docCtr);\n         ctx.getVariables().declareVariable(\"null\", null);\n-        TestBeanWithDOM tbwdom = createTestBeanWithDOM();\n+        TestBeanWithNode tbwdom = createTestBeanWithDOM();\n         ctx.getVariables().declareVariable(\"test\", tbwdom);\n         testXPaths(ctx, dom_tests, false);\n     }\n-\n-    private TestBeanWithDOM createTestBeanWithDOM(){\n-        XMLDocumentContainer docCtr = new XMLDocumentContainer(getClass().getResource(\"Vendor.xml\"));\n+/*\n+    public void testJDOM() throws Exception {\n+        if (true){\n+            return;\n+        }\n+        DocumentContainer docCtr =\n+            new DocumentContainer(getClass().getResource(\"Vendor.xml\"),\n+                DocumentContainer.MODEL_JDOM);\n+        org.jdom.Document doc = (org.jdom.Document)docCtr.getValue();\n+        JXPathContext ctx = JXPathContextFactory.newInstance().newContext(null, doc);\n+        ctx.setLocale(Locale.US);\n+        ctx.getVariables().declareVariable(\"dom\", doc);\n+        ctx.getVariables().declareVariable(\"object\", docCtr);\n+        ctx.getVariables().declareVariable(\"null\", null);\n+        TestBeanWithNode tbwdom = createTestBeanWithDOM();\n+        ctx.getVariables().declareVariable(\"test\", tbwdom);\n+        testXPaths(ctx, dom_tests, false);\n+    }\n+*/\n+    private TestBeanWithNode createTestBeanWithDOM(){\n+        DocumentContainer docCtr = new DocumentContainer(getClass().getResource(\"Vendor.xml\"));\n         Document doc = (Document)docCtr.getValue();\n-        TestBeanWithDOM tbwdom = new TestBeanWithDOM();\n+        TestBeanWithNode tbwdom = new TestBeanWithNode();\n         tbwdom.setVendor(doc.getDocumentElement());\n         tbwdom.setObject(docCtr);\n         return tbwdom;\n     }\n-\n+/*\n+    private TestBeanWithNode createTestBeanWithJDOM(){\n+        DocumentContainer docCtr = new DocumentContainer(\n+            getClass().getResource(\"Vendor.xml\"),\n+            DocumentContainer.MODEL_JDOM);\n+        org.jdom.Document doc = (org.jdom.Document)docCtr.getValue();\n+        TestBeanWithNode tbwdom = new TestBeanWithNode();\n+        tbwdom.setVendor(doc.getRootElement());\n+        tbwdom.setObject(docCtr);\n+        return tbwdom;\n+    }\n+*/\n     static final XP[] dom_tests = new XP[]{\n         test(\"vendor/location/address/street\", \"Orchard Road\"),\n         test(\"vendor/location[2]/address/street\", \"Tangerine Drive\"),\n+        test(\"vendor/location/address/city\", \"Fruit Market\"),\n         test(\"//street\", \"Orchard Road\"),\n         test(\"local-name(//street/..)\", \"address\"),\n         test(\"number(vendor/location/employeeCount)\", new Double(10)),\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestBeanWithNode.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestBeanWithNode.java,v 1.1 2002/08/10 01:50:39 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/10 01:50:39 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n+import org.w3c.dom.Document;\n+\n+/**\n+ * General purpose test bean for JUnit tests for the \"jxpath\" component.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/08/10 01:50:39 $\n+ */\n+public class TestBeanWithNode extends TestBean {\n+    private Object node;\n+    private Object object;\n+\n+    public Object getVendor(){\n+        return node;\n+    }\n+\n+    public Object[] getVendors(){\n+        return new Object[]{node};\n+    }\n+\n+    public void setVendor(Object node){\n+        this.node = node;\n+    }\n+\n+    public Object getObject(){\n+        return object;\n+    }\n+\n+    public void setObject(Object object){\n+        this.object = object;\n+    }\n+\n+    public static TestBeanWithNode createTestBeanWithDOM(){\n+        DocumentContainer docCtr = new DocumentContainer(\n+                TestBeanWithNode.class.getResource(\"Vendor.xml\"));\n+        Document doc = (Document)docCtr.getValue();\n+        TestBeanWithNode tbwdom = new TestBeanWithNode();\n+        tbwdom.setVendor(doc.getDocumentElement());\n+        tbwdom.setObject(docCtr);\n+        return tbwdom;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/jxpath/TestFactory.java\n+++ b/src/test/org/apache/commons/jxpath/TestFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.3 2002/05/08 23:05:05 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/05/08 23:05:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.4 2002/08/10 01:50:39 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/08/10 01:50:39 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 23:05:05 $\n+ * @version $Revision: 1.4 $ $Date: 2002/08/10 01:50:39 $\n  */\n public class TestFactory extends AbstractFactory {\n \n             addElement((Node)parent, index, name);\n             return true;\n         }\n+        else if (name.startsWith(\"testKey\")){\n+            ((Map)parent).put(name, new HashMap());\n+            return true;\n+        }\n         return false;\n     }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBeanWithNode;\n+import org.apache.commons.jxpath.TestNull;\n+import org.apache.commons.jxpath.TestFactory;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.model.dom.*;\n+import java.util.*;\n+\n+public class SimplePathInterpreterTest extends TestCase {\n+\n+    private TestBeanWithNode bean;\n+    private JXPathContext context;\n+\n+    /**\n+     * Constructor for SimplePathInterpreterTest.\n+     */\n+    public SimplePathInterpreterTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(SimplePathInterpreterTest.class);\n+    }\n+\n+    /**\n+     * @see TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        bean = TestBeanWithNode.createTestBeanWithDOM();\n+        HashMap submap = new HashMap();\n+        submap.put(\"key\", new NestedTestBean(\"Name 9\"));\n+        submap.put(\"strings\", bean.getNestedBean().getStrings());\n+        bean.getList().add(new int[]{1, 2});\n+        bean.getList().add(bean.getVendor());\n+        bean.getMap().put(\"Key3\",\n+            new Object[]{\n+                new NestedTestBean(\"some\"),\n+                new Integer(2),\n+                bean.getVendor(),\n+                submap\n+            }\n+        );\n+        bean.getMap().put(\"Key4\", bean.getVendor());\n+        bean.getMap().put(\"Key5\", submap);\n+        bean.getMap().put(\"Key6\", new Object[0]);\n+        context = JXPathContext.newContext(null, bean);\n+        context.setLenient(true);\n+        context.setFactory(new TestFactory());\n+    }\n+\n+    public void test_doStep_noPredicates_propertyOwner(){\n+        // Existing scalar property\n+        testValueAndPointer(\"/int\",\n+                new Integer(1),\n+                \"/int\",\n+                \"BbB\");\n+\n+        // self::\n+        testValueAndPointer(\"/./int\",\n+                new Integer(1),\n+                \"/int\",\n+                \"BbB\");\n+\n+        // Missing property\n+        testNullPointer(\"/foo\",\n+                \"/foo\",\n+                \"BnN\");\n+\n+        // existingProperty/existingScalarProperty\n+        testValueAndPointer(\"/nestedBean/int\",\n+                new Integer(1),\n+                \"/nestedBean/int\",\n+                \"BbBbB\");\n+\n+        // existingProperty/collectionProperty\n+        testValueAndPointer(\"/nestedBean/strings\",\n+                bean.getNestedBean().getStrings(),\n+                \"/nestedBean/strings\",\n+                \"BbBbC\");\n+\n+        // existingProperty/missingProperty\n+        testNullPointer(\"/nestedBean/foo\",\n+                \"/nestedBean/foo\",\n+                \"BbBnN\");\n+\n+        // map/missingProperty\n+        testNullPointer(\"/map/foo\",\n+                \"/map[@name='foo']\",\n+                \"BbDdN\");\n+\n+        // Existing property by search in collection\n+        testValueAndPointer(\"/list/int\",\n+                new Integer(1),\n+                \"/list[3]/int\",\n+                \"BbBbB\");\n+\n+        // Missing property by search in collection\n+        testNullPointer(\"/list/foo\",\n+                \"/list[1]/foo\",\n+                \"BbBnN\");\n+\n+        // existingProperty/missingProperty/missingProperty\n+        testNullPointer(\"/nestedBean/foo/bar\",\n+                \"/nestedBean/foo/bar\",\n+                \"BbBnNnN\");\n+\n+        // collection/existingProperty/missingProperty\n+        testNullPointer(\"/list/int/bar\",\n+                \"/list[3]/int/bar\",\n+                \"BbBbBnN\");\n+\n+        // collectionProperty/missingProperty/missingProperty\n+        testNullPointer(\"/list/foo/bar\",\n+                \"/list[1]/foo/bar\",\n+                \"BbBnNnN\");\n+\n+        // map/missingProperty/anotherStep\n+        testNullPointer(\"/map/foo/bar\",\n+                \"/map[@name='foo']/bar\",\n+                \"BbDdNnN\");\n+\n+        // Existing dynamic property\n+        testValueAndPointer(\"/map/Key1\",\n+                \"Value 1\",\n+                \"/map[@name='Key1']\",\n+                \"BbDdB\");\n+\n+        // collectionProperty\n+        testValueAndPointer(\"/integers\",\n+                bean.getIntegers(),\n+                \"/integers\",\n+                \"BbC\");\n+    }\n+\n+    public void test_doStep_noPredicates_standard(){\n+        // Existing DOM node\n+        testValueAndPointer(\"/vendor/location/address/city\",\n+                \"Fruit Market\",\n+                \"/vendor/location[2]/address[1]/city[1]\",\n+                \"BbMMMM\");\n+\n+        // Missing DOM node\n+        testNullPointer(\"/vendor/location/address/pity\",\n+                \"/vendor/location[1]/address[1]/pity\",\n+                \"BbMMMnN\");\n+\n+        // Missing DOM node inside a missing element\n+        testNullPointer(\"/vendor/location/address/itty/bitty\",\n+                \"/vendor/location[1]/address[1]/itty/bitty\",\n+                \"BbMMMnNnN\");\n+\n+        // Missing DOM node by search for the best match\n+        testNullPointer(\"/vendor/location/address/city/pretty\",\n+                \"/vendor/location[2]/address[1]/city[1]/pretty\",\n+                \"BbMMMMnN\");\n+    }\n+\n+    public void test_doStep_predicates_propertyOwner(){\n+        // missingProperty[@name=foo]\n+        testNullPointer(\"/foo[@name='foo']\",\n+                \"/foo[@name='foo']\",\n+                \"BnNnN\");\n+\n+        // missingProperty[index]\n+        testNullPointer(\"/foo[3]\",\n+                \"/foo[3]\",\n+                \"BnN\");\n+    }\n+\n+    public void test_doStep_predicates_standard(){\n+        // Looking for an actual XML attribute called \"name\"\n+        // nodeProperty/name[@name=value]\n+        testValueAndPointer(\"/vendor/contact[@name='jack']\",\n+                \"Jack\",\n+                \"/vendor/contact[2]\",\n+                \"BbMM\");\n+\n+        // Indexing in XML\n+        testValueAndPointer(\"/vendor/contact[2]\",\n+                \"Jack\",\n+                \"/vendor/contact[2]\",\n+                \"BbMM\");\n+\n+        // Indexing in XML, no result\n+        testNullPointer(\"/vendor/contact[5]\",\n+                \"/vendor/contact[5]\",\n+                \"BbMnN\");\n+\n+        // Combination of search by name and indexing in XML\n+        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+                \"Jack Black\",\n+                \"/vendor/contact[4]\",\n+                \"BbMM\");\n+\n+        // Combination of search by name and indexing in XML\n+        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+                \"Jack Black\",\n+                \"/vendor/contact[4]\",\n+                \"BbMM\");\n+    }\n+\n+    public void test_doPredicate_name(){\n+        // existingProperty[@name=existingProperty]\n+        testValueAndPointer(\"/nestedBean[@name='int']\",\n+                new Integer(1),\n+                \"/nestedBean/int\",\n+                \"BbBbB\");\n+\n+        // /self::node()[@name=existingProperty]\n+        testValueAndPointer(\"/.[@name='int']\",\n+                new Integer(1),\n+                \"/int\",\n+                \"BbB\");\n+\n+        // dynamicProperty[@name=existingProperty]\n+        testValueAndPointer(\"/map[@name='Key1']\",\n+                \"Value 1\",\n+                \"/map[@name='Key1']\",\n+                \"BbDdB\");\n+\n+        // existingProperty[@name=collectionProperty]\n+        testValueAndPointer(\"/nestedBean[@name='strings']\",\n+                bean.getNestedBean().getStrings(),\n+                \"/nestedBean/strings\",\n+                \"BbBbC\");\n+\n+        // existingProperty[@name=missingProperty]\n+        testNullPointer(\"/nestedBean[@name='foo']\",\n+                \"/nestedBean[@name='foo']\",\n+                \"BbBnN\");\n+\n+        // map[@name=collectionProperty]\n+        testValueAndPointer(\"/map[@name='Key3']\",\n+                bean.getMap().get(\"Key3\"),\n+                \"/map[@name='Key3']\",\n+                \"BbDdC\");\n+\n+        // map[@name=missingProperty]\n+        testNullPointer(\"/map[@name='foo']\",\n+                \"/map[@name='foo']\",\n+                \"BbDdN\");\n+\n+        // collectionProperty[@name=...] (find node)\n+        testValueAndPointer(\"/list[@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/list[5]\",\n+                \"BbCM\");\n+\n+        // collectionProperty[@name=...] (find map entry)\n+        testValueAndPointer(\"/map/Key3[@name='key']/name\",\n+                \"Name 9\",\n+                \"/map[@name='Key3'][4][@name='key']/name\",\n+                \"BbDdCDdBbB\");\n+\n+        // map/collectionProperty[@name...]\n+        testValueAndPointer(\"map/Key3[@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/map[@name='Key3'][3]\",\n+                \"BbDdCM\");\n+\n+        // Bean property -> DOM Node, name match\n+        testValueAndPointer(\"/vendor[@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/vendor\",\n+                \"BbM\");\n+\n+        // Bean property -> DOM Node, name mismatch\n+        testNullPointer(\"/vendor[@name='foo']\",\n+                \"/vendor[@name='foo']\",\n+                \"BbMnN\");\n+\n+        testNullPointer(\"/vendor[@name='foo'][3]\",\n+                \"/vendor[@name='foo'][3]\",\n+                \"BbMnN\");\n+\n+        // existingProperty(bean)[@name=missingProperty]/anotherStep\n+        testNullPointer(\"/nestedBean[@name='foo']/bar\",\n+                \"/nestedBean[@name='foo']/bar\",\n+                \"BbBnNnN\");\n+\n+        // map[@name=missingProperty]/anotherStep\n+        testNullPointer(\"/map[@name='foo']/bar\",\n+                \"/map[@name='foo']/bar\",\n+                \"BbDdNnN\");\n+\n+        // existingProperty(node)[@name=missingProperty]/anotherStep\n+        testNullPointer(\"/vendor[@name='foo']/bar\",\n+                \"/vendor[@name='foo']/bar\",\n+                \"BbMnNnN\");\n+\n+        // existingProperty(node)[@name=missingProperty][index]/anotherStep\n+        testNullPointer(\"/vendor[@name='foo'][3]/bar\",\n+                \"/vendor[@name='foo'][3]/bar\",\n+                \"BbMnNnN\");\n+\n+        // Existing dynamic property + existing property\n+        testValueAndPointer(\"/map[@name='Key2'][@name='name']\",\n+                \"Name 6\",\n+                \"/map[@name='Key2']/name\",\n+                \"BbDdBbB\");\n+\n+        // Existing dynamic property + existing property + index\n+        testValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n+                \"String 2\",\n+                \"/map[@name='Key2']/strings[2]\",\n+                \"BbDdBbB\");\n+\n+        // bean/map/map/property\n+        testValueAndPointer(\"map[@name='Key5'][@name='key']/name\",\n+                \"Name 9\",\n+                \"/map[@name='Key5'][@name='key']/name\",\n+                \"BbDdDdBbB\");\n+\n+        testNullPointer(\"map[@name='Key2'][@name='foo']\",\n+                \"/map[@name='Key2'][@name='foo']\",\n+                \"BbDdBnN\");\n+\n+        testNullPointer(\"map[@name='Key2'][@name='foo'][@name='bar']\",\n+                \"/map[@name='Key2'][@name='foo'][@name='bar']\",\n+                \"BbDdBnNnN\");\n+\n+        // bean/map/node\n+        testValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/map[@name='Key4']\",\n+                \"BbDdM\");\n+    }\n+\n+    public void test_doPredicates_standard(){\n+        // bean/map/collection/node\n+        testValueAndPointer(\"map[@name='Key3'][@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/map[@name='Key3'][3]\",\n+                \"BbDdCM\");\n+\n+        // bean/map/collection/missingNode\n+        testNullPointer(\"map[@name='Key3'][@name='foo']\",\n+                \"/map[@name='Key3'][4][@name='foo']\",\n+                \"BbDdCDdN\");\n+\n+        // bean/map/node\n+        testValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n+                context.getValue(\"/vendor\"),\n+                \"/map[@name='Key4']\",\n+                \"BbDdM\");\n+\n+        // bean/map/emptyCollection[@name=foo]\n+        testNullPointer(\"map[@name='Key6'][@name='fruitco']\",\n+                \"/map[@name='Key6'][@name='fruitco']\",\n+                \"BbDdCnN\");\n+\n+        // bean/node[@name=foo][index]\n+        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+                \"Jack Black\",\n+                \"/vendor/contact[4]\",\n+                \"BbMM\");\n+\n+        // bean/node[@name=foo][missingIndex]\n+        testNullPointer(\"/vendor/contact[@name='jack'][5]\",\n+                \"/vendor/contact[@name='jack'][5]\",\n+                \"BbMnNnN\");\n+\n+        // bean/node/.[@name=foo][index]\n+        testValueAndPointer(\"/vendor/contact/.[@name='jack']\",\n+                \"Jack\",\n+                \"/vendor/contact[2]\",\n+                \"BbMM\");\n+    }\n+\n+    public void test_doPredicate_index(){\n+        // Existing dynamic property + existing property + index\n+        testValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n+                \"String 2\",\n+                \"/map[@name='Key2']/strings[2]\",\n+                \"BbDdBbB\");\n+\n+        // existingProperty[@name=collectionProperty][index]\n+        testValueAndPointer(\"/nestedBean[@name='strings'][2]\",\n+                bean.getNestedBean().getStrings()[1],\n+                \"/nestedBean/strings[2]\",\n+                \"BbBbB\");\n+\n+        // existingProperty[@name=missingProperty][index]\n+        testNullPointer(\"/nestedBean[@name='foo'][3]\",\n+                \"/nestedBean[@name='foo'][3]\",\n+                \"BbBnN\");\n+\n+        // existingProperty[@name=collectionProperty][missingIndex]\n+        testNullPointer(\"/nestedBean[@name='strings'][5]\",\n+                \"/nestedBean/strings[5]\",\n+                \"BbBbEN\");\n+\n+        // map[@name=collectionProperty][index]\n+        testValueAndPointer(\"/map[@name='Key3'][2]\",\n+                new Integer(2),\n+                \"/map[@name='Key3'][2]\",\n+                \"BbDdB\");\n+\n+        // map[@name=collectionProperty][missingIndex]\n+        testNullPointer(\"/map[@name='Key3'][5]\",\n+                \"/map[@name='Key3'][5]\",\n+                \"BbDdEN\");\n+\n+        // map[@name=collectionProperty][missingIndex]/property\n+        testNullPointer(\"/map[@name='Key3'][5]/foo\",\n+                \"/map[@name='Key3'][5]/foo\",\n+                \"BbDdENnN\");\n+\n+        // map[@name=map][@name=collection][index]\n+        testValueAndPointer(\"/map[@name='Key5'][@name='strings'][2]\",\n+                \"String 2\",\n+                \"/map[@name='Key5'][@name='strings'][2]\",\n+                \"BbDdDdB\");\n+\n+        // map[@name=map][@name=collection][missingIndex]\n+        testNullPointer(\"/map[@name='Key5'][@name='strings'][5]\",\n+                \"/map[@name='Key5'][@name='strings'][5]\",\n+                \"BbDdDdEN\");\n+\n+        // Existing dynamic property + indexing\n+        testValueAndPointer(\"/map[@name='Key3'][2]\",\n+                new Integer(2),\n+                \"/map[@name='Key3'][2]\",\n+                \"BbDdB\");\n+\n+        // Existing dynamic property + indexing\n+        testValueAndPointer(\"/map[@name='Key3'][1]/name\",\n+                \"some\",\n+                \"/map[@name='Key3'][1]/name\",\n+                \"BbDdBbB\");\n+\n+        // map[@name=missingProperty][index]\n+        testNullPointer(\"/map[@name='foo'][3]\",\n+                \"/map[@name='foo'][3]\",\n+                \"BbDdEN\");\n+\n+        // collectionProperty[index]\n+        testValueAndPointer(\"/integers[2]\",\n+                new Integer(2),\n+                \"/integers[2]\",\n+                \"BbB\");\n+\n+        // existingProperty/collectionProperty[index]\n+        testValueAndPointer(\"/nestedBean/strings[2]\",\n+                bean.getNestedBean().getStrings()[1],\n+                \"/nestedBean/strings[2]\",\n+                \"BbBbB\");\n+\n+        // existingProperty[index]/existingProperty\n+        testValueAndPointer(\"/list[3]/int\",\n+                new Integer(1),\n+                \"/list[3]/int\",\n+                \"BbBbB\");\n+\n+        // existingProperty[missingIndex]\n+        testNullPointer(\"/list[6]\",\n+                \"/list[6]\",\n+                \"BbEN\");\n+\n+        // existingProperty/missingProperty[index]\n+        testNullPointer(\"/nestedBean/foo[3]\",\n+                \"/nestedBean/foo[3]\",\n+                \"BbBnN\");\n+\n+        // map[@name=missingProperty][index]\n+        testNullPointer(\"/map/foo[3]\",\n+                \"/map[@name='foo'][3]\",\n+                \"BbDdEN\");\n+\n+        // existingProperty/collectionProperty[missingIndex]\n+        testNullPointer(\"/nestedBean/strings[5]\",\n+                \"/nestedBean/strings[5]\",\n+                \"BbBbEN\");\n+\n+        // map/collectionProperty[missingIndex]/property\n+        testNullPointer(\"/map/Key3[5]/foo\",\n+                \"/map[@name='Key3'][5]/foo\",\n+                \"BbDdENnN\");\n+\n+        // map[@name=map]/collection[index]\n+        testValueAndPointer(\"/map[@name='Key5']/strings[2]\",\n+                \"String 2\",\n+                \"/map[@name='Key5'][@name='strings'][2]\",\n+                \"BbDdDdB\");\n+\n+        // map[@name=map]/collection[missingIndex]\n+        testNullPointer(\"/map[@name='Key5']/strings[5]\",\n+                \"/map[@name='Key5'][@name='strings'][5]\",\n+                \"BbDdDdEN\");\n+\n+        // scalarPropertyAsCollection[index]\n+        testValueAndPointer(\"/int[1]\",\n+                new Integer(1),\n+                \"/int\",\n+                \"BbB\");\n+\n+        // scalarPropertyAsCollection[index]\n+        testValueAndPointer(\".[1]/int\",\n+                new Integer(1),\n+                \"/int\",\n+                \"BbB\");\n+    }\n+\n+    public void testInterpretExpressionPath(){\n+        context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+        context.getVariables().declareVariable(\"testnull\", new TestNull());\n+\n+        testNullPointer(\"$testnull/nothing[2]\",\n+                \"$testnull/nothing[2]\",\n+                \"VBbEN\");\n+    }\n+\n+    private void testValueAndPointer(\n+            String path, Object expectedValue, String expectedPath,\n+            String expectedSignature)\n+    {\n+        Object value = context.getValue(path);\n+        assertEquals(\"Checking value: \" + path, expectedValue, value);\n+\n+        Pointer pointer = context.getPointer(path);\n+        assertEquals(\"Checking pointer: \" + path,\n+                expectedPath, pointer.toString());\n+\n+        assertEquals(\"Checking signature: \" + path,\n+                expectedSignature, pointerSignature(pointer));\n+    }\n+\n+\n+    private void testNullPointer(String path, String expectedPath,\n+            String expectedSignature)\n+    {\n+        Pointer pointer = context.getPointer(path);\n+        assertNotNull(\"Null path exists: \" + path,\n+                    pointer);\n+        assertTrue(\"Null path is null: \" + path,\n+                    !((NodePointer)pointer).isActual());\n+        assertEquals(\"Null path as path: \" + path,\n+                    expectedPath, pointer.asPath());\n+        assertEquals(\"Checking Signature: \" + path,\n+                expectedSignature, pointerSignature(pointer));\n+    }\n+\n+    /**\n+     * Since we need to test the internal Signature of a pointer,\n+     * we will get a signature which will contain a single character\n+     * per pointer in the chain, representing that pointer's type.\n+     */\n+    private String pointerSignature(Pointer pointer){\n+        if (pointer == null){\n+            return \"\";\n+        }\n+\n+        char type = '?';\n+        if (pointer instanceof NullPointer){                 type = 'N'; }\n+        else if (pointer instanceof NullPropertyPointer){    type = 'n'; }\n+        else if (pointer instanceof NullElementPointer){     type = 'E'; }\n+        else if (pointer instanceof VariablePointer){        type = 'V'; }\n+        else if (pointer instanceof CollectionPointer){      type = 'C'; }\n+        else if (pointer instanceof BeanPointer){            type = 'B'; }\n+        else if (pointer instanceof BeanPropertyPointer){    type = 'b'; }\n+        else if (pointer instanceof DynamicPointer){         type = 'D'; }\n+        else if (pointer instanceof DynamicPropertyPointer){ type = 'd'; }\n+        else if (pointer instanceof DOMNodePointer){         type = 'M'; }\n+        else {\n+            System.err.println(\"UNKNOWN TYPE: \" + pointer.getClass());\n+        }\n+        return pointerSignature(((NodePointer)pointer).getParent()) + type;\n+    }\n+}\n+", "timestamp": 1028944239, "metainfo": ""}