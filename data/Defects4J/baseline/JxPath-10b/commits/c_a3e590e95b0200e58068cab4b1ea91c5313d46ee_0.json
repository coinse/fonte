{"sha": "a3e590e95b0200e58068cab4b1ea91c5313d46ee", "log": "Changed to new SimplePathInterpreter APIs   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.5 2002/08/10 01:39:29 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/08/10 01:39:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a path that starts with an expression like a function call: <code>getFoo(.)/bar</code>.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.5 $ $Date: 2002/08/10 01:39:29 $\n  */\n public class ExpressionPath extends Path {\n-\n-    public static final String BASIC_PREDICATES_HINT = \"basicPredicatesHint\";\n \n     private Expression expression;\n     private Expression predicates[];\n             context = evalContext.getRootContext().getConstantContext(value);\n         }\n \n+\n         if (firstMatch && isSimpleExpressionPath() &&\n                 !(context instanceof UnionContext)){\n             EvalContext ctx = context;\n             if (ptr != null &&\n                     (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n                      predicates == null || predicates.length == 0)){\n-                NodePointer pointer = SimplePathInterpreter.\n-                    interpretPredicates(evalContext, ptr, predicates);\n-                return SimplePathInterpreter.interpretPath(evalContext,\n-                    pointer, getSteps());\n-            }\n-        }\n-\n+                return SimplePathInterpreter.\n+                    interpretSimpleExpressionPath(\n+                            evalContext, ptr, predicates, getSteps());\n+            }\n+        }\n         if (predicates != null){\n             for (int j = 0; j < predicates.length; j++){\n-//                System.err.println(\"PREDICATE: \" + predicates[j]);\n                 context = new PredicateContext(context, predicates[j]);\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.5 2002/08/10 01:39:29 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/08/10 01:39:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.5 $ $Date: 2002/08/10 01:39:29 $\n  */\n public abstract class Path extends Expression {\n \n     private Step[] steps;\n-    public static final String BASIC_PATH_HINT = \"basicPathHint\";\n     private boolean basicKnown = false;\n     private boolean basic;\n \n             basic = true;\n             Step[] steps = getSteps();\n             for (int i = 0; i < steps.length; i++){\n-                if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n-                        !(steps[i].getNodeTest() instanceof NodeNameTest) ||\n-                        ((NodeNameTest)steps[i].getNodeTest()).\n+                boolean accepted = false;\n+                if (steps[i].getAxis() == Compiler.AXIS_SELF &&\n+                        (steps[i].getNodeTest() instanceof NodeTypeTest) &&\n+                        ((NodeTypeTest)steps[i].getNodeTest()).getNodeType() ==\n+                                Compiler.NODE_TYPE_NODE){\n+                    accepted = true;\n+                }\n+                else if (steps[i].getAxis() == Compiler.AXIS_CHILD &&\n+                        (steps[i].getNodeTest() instanceof NodeNameTest) &&\n+                        !((NodeNameTest)steps[i].getNodeTest()).\n                                     getNodeName().getName().equals(\"*\")){\n+                    accepted = true;\n+                }\n+                if (accepted){\n+                    accepted = areBasicPredicates(steps[i].getPredicates());\n+                }\n+                if (!accepted){\n                     basic = false;\n                     break;\n-                }\n-                if (basic){\n-                    basic = areBasicPredicates(steps[i].getPredicates());\n                 }\n             }\n         }\n \n         if (isSimplePath()){\n             NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n-            return SimplePathInterpreter.interpretPath(context, ptr, steps);\n+            return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps);\n         }\n         else {\n-            for (int i = 0; i < steps.length; i++){\n-                context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n-                Expression predicates[] = steps[i].getPredicates();\n-                if (predicates != null){\n-                    for (int j = 0; j < predicates.length; j++){\n-                        context = new PredicateContext(context, predicates[j]);\n-                    }\n-                }\n-            }\n-\n-            return context.getSingleNodePointer();\n-        }\n+            return searchForPath(context);\n+        }\n+    }\n+\n+    private Pointer searchForPath(EvalContext context) {\n+        for (int i = 0; i < steps.length; i++){\n+            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+            Expression predicates[] = steps[i].getPredicates();\n+            if (predicates != null){\n+                for (int j = 0; j < predicates.length; j++){\n+                    context = new PredicateContext(context, predicates[j]);\n+                }\n+            }\n+        }\n+\n+        return context.getSingleNodePointer();\n     }\n \n     /**", "timestamp": 1028943569, "metainfo": ""}