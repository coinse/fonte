{"sha": "e7e9416133d270304cdbb567af88c62166a0be9a", "log": "Added tests for the new functionalities and bug fixes Renamed classes for uniformity   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/JXPathTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/JXPathTest.java,v 1.1 2002/10/13 03:01:03 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/13 03:01:03 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.util.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n+import java.beans.*;\n+\n+/**\n+ * <p>\n+ *  Test Case for the JXPath class.  The majority of these tests use\n+ *  instances of the TestBean class, so be sure to update the tests if you\n+ *  change the characteristics of that class.\n+ * </p>\n+ *\n+ * <p>\n+ *   Note that the tests are dependant upon the static aspects\n+ *   (such as array sizes...) of the TestBean.java class, so ensure\n+ *   that all changes to TestBean are reflected here.\n+ * </p>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/13 03:01:03 $\n+ */\n+\n+public class JXPathTest extends TestCase\n+{\n+    private static boolean combineTests = false;\n+    private static boolean enabled = true;\n+\n+    /**\n+     * Exercises this test case only\n+     */\n+    public static void main(String args[]) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    // ---------------------------------------------------- Instance Variables\n+\n+    /**\n+     * The test bean for each test.\n+     */\n+    protected TestBean bean = null;\n+\n+\n+    // ---------------------------------------------------------- Constructors\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public JXPathTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+\n+    // -------------------------------------------------- Overall Test Methods\n+\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+        bean = new TestBean();\n+    }\n+\n+\n+    /**\n+     * Return the tests included in this test suite.\n+     */\n+    public static Test suite()\n+    {\n+        TestSuite suite = new TestSuite();\n+        suite.addTestSuite(JXPathTest.class);\n+        if (combineTests && enabled){\n+            suite.addTestSuite(org.apache.commons.jxpath.ri.axes.SimplePathInterpreterTest.class);\n+            suite.addTestSuite(org.apache.commons.jxpath.ri.model.dom.DOMModelTest.class);\n+            suite.addTestSuite(org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest.class);\n+        }\n+        return suite;\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+        bean = null;\n+    }\n+\n+\n+    // ------------------------------------------------ Individual Test Methods\n+\n+    /**\n+     * Test property iterators, the core of the graph traversal engine\n+     */\n+    public void testIndividualIterators(){\n+        if (!enabled){\n+            return;\n+        }\n+//        testIndividual(0, 0, true, false, 3);\n+            testIndividual(+1, 0, true, false, 0);\n+            testIndividual(-1, 0, true, false, 4);\n+\n+            testIndividual(0, -1, true, true, 4);\n+            testIndividual(+1, -1, true, true, 4);\n+            testIndividual(-1, -1, true, true, 0);\n+\n+            testIndividual(0, 1, true, false, 2);\n+            testIndividual(0, 1, true, true, 1);\n+\n+            testIndividual(0, 0, false, false, 4);\n+            testIndividual(0, 0, false, true, 4);\n+    }\n+\n+    private void testIndividual(int relativePropertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.newNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n+        NodeIterator it;\n+\n+        if (useStartLocation){\n+            PropertyPointer holder = root.getPropertyPointer();\n+            holder.setPropertyIndex(relativeProperty(holder, relativePropertyIndex));\n+            holder.setIndex(offset);\n+            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse, holder);\n+        }\n+        else {\n+            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse, null);\n+        }\n+\n+        int size = 0;\n+        while(it.setPosition(it.getPosition() + 1)){\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Individual, relativePropertyIndex=\" + relativePropertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    public void testMultipleIterators(){\n+        if (!enabled){\n+            return;\n+        }\n+            testMultiple(0, 0, true, false, 20);\n+\n+            testMultiple(3, 0, true, false, 16);\n+            testMultiple(3, -1, true, true, 8);\n+            testMultiple(3, 0, true, true, 4);\n+            testMultiple(0, 0, false, false, 21);\n+            testMultiple(0, 0, false, true, 21);\n+\n+            testMultiple(3, 1, true, false, 15);\n+            testMultiple(3, 3, true, false, 13);\n+    }\n+\n+    private void testMultiple(int propertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.newNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n+        NodeIterator it;\n+\n+        if (useStartLocation){\n+            PropertyPointer holder = root.getPropertyPointer();\n+            holder.setPropertyIndex(propertyIndex);\n+            holder.setIndex(offset);\n+            it = root.childIterator(null, reverse, holder);\n+        }\n+        else {\n+            it = root.childIterator(null, reverse, null);\n+        }\n+\n+        int size = 0;\n+        while(it.setPosition(it.getPosition() + 1)){\n+//            System.err.println(\"LOC: \" + it.getCurrentNodePointer());\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Multiple, propertyIndex=\" + propertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    private int relativeProperty(PropertyPointer holder, int offset){\n+        String[] names = holder.getPropertyNames();\n+        for (int i = 0; i < names.length; i++){\n+            if (names[i].equals(\"integers\")){\n+                return i + offset;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with various arguments\n+     */\n+    public void testGetValue(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean);\n+        testGetValue(context, \"2+2\",                     new Double(4.0));\n+        testGetValue(context, \"boolean\",                 Boolean.FALSE);\n+        testGetValue(context, \"substring(boolean, 1,2)\", \"fa\"); // 'fa'lse\n+        testGetValue(context, \"int*2\",                   new Double(2.0));\n+        testGetValue(context, \"integers[1]\",             new Integer(1));\n+        testGetValue(context, \"nestedBean\",              bean.getNestedBean());\n+        testGetValue(context, \"nestedBean/boolean\",      Boolean.FALSE);\n+        testGetValue(context, \"object/name\",             \"Name 5\");\n+        testGetValue(context, \"objects[1]\",              new Integer(1));\n+        testGetValue(context, \"map/Key1\",                \"Value 1\");\n+        testGetValue(context, \"beans[name = 'Name 1']\",  bean.getBeans()[0]);\n+        testGetValue(context, \".[1]/int\",                new Integer(1));\n+//        testGetValue(context, \"id('foo')\",               new Integer(1));\n+//        testGetValue(context, \"key('foo', 'bar')\",               new Integer(1));\n+        testGetValue(context, \"integers[1]\",            new Double(1), Double.class);\n+        testGetValue(context, \"2 + 3\",                  \"5.0\", String.class);\n+        testGetValue(context, \"2 + 3\",                  Boolean.TRUE, boolean.class);\n+        testGetValue(context, \"'true'\",                 Boolean.TRUE, Boolean.class);\n+\n+        Map tm = new Hashtable();\n+        tm.put(\"bar\", \"zz\");\n+        bean.getMap().put(\"foo\", new Map[]{tm, tm});\n+        bean.getMap().put(\"biz\", tm);\n+\n+        testGetValue(context, \"map/foo[2]/bar/../bar\", \"zz\");\n+        testGetValue(context, \"map[@name='biz'][@name='bar']\", \"zz\");\n+\n+        boolean exception = false;\n+        try {\n+            testGetValue(context, \"'foo'\",              null, Date.class);\n+        }\n+        catch(Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Type conversion exception\", exception);\n+    }\n+\n+    public void testGetPointer(){\n+//        if (!enabled){\n+//            return;\n+//        }\n+\n+        JXPathContext context = JXPathContext.newContext(createTestBeanWithDOM());\n+\n+        NodePointer pointer = (NodePointer)context.getPointer(\"@int\");\n+        assertEquals(\"GetPointer <\" + \"@int\" + \">\", \"/@int\", pointer.toString());\n+\n+        pointer = (NodePointer)context.getPointer(\"vendor/location/@id\");\n+        assertEquals(\"GetPointer <\" + \"vendor/location/@id\" + \">\",\n+                \"/vendor/location[1]/@id\", pointer.toString());\n+    }\n+\n+    /**\n+     * Test JXPath.iterate() with various arguments\n+     */\n+    public void testIterateArray(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+\n+        Iterator it = context.iterate(\"foo\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n+        assertEquals(\"Iterating <\" + \"foo\" + \">\", list(\"a\", \"b\", \"c\"), actual);\n+    }\n+\n+    public void testIteratePointersArray(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+\n+        Iterator it = context.iteratePointers(\"foo\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            Pointer ptr = (Pointer)it.next();\n+            actual.add(context.getValue(ptr.asPath()));\n+        }\n+        assertEquals(\"Iterating pointers <\" + \"foo\" + \">\", list(\"a\", \"b\", \"c\"), actual);\n+    }\n+\n+    public void testIteratePointersArrayElementWithVariable(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+\n+        JXPathContext context = JXPathContext.newContext(map);\n+        context.getVariables().declareVariable(\"x\", new Integer(2));\n+        Iterator it = context.iteratePointers(\"foo[$x]\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            Pointer ptr = (Pointer)it.next();\n+            actual.add(context.getValue(ptr.asPath()));\n+        }\n+        assertEquals(\"Iterating pointers <\" + \"foo\" + \">\", list(\"b\"), actual);\n+    }\n+\n+    public void testIteratePropertyArrayWithHasNext(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean);\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        while(it.hasNext()){\n+            actual.add(((Pointer)it.next()).asPath());\n+        }\n+        assertEquals(\"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n+            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n+            actual);\n+    }\n+\n+    public void testIteratePropertyArrayWithoutHasNext(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean);\n+        Iterator it = context.iteratePointers(\"/integers\");\n+        List actual = new ArrayList();\n+        for (int i = 0; i < 4; i++){\n+            actual.add(it.next().toString());\n+        }\n+        assertEquals(\"Iterating 'next'<\" + \"/integers\" + \">\",\n+            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n+            actual);\n+    }\n+\n+    public void testIterateVector(){\n+        if (!enabled){\n+            return;\n+        }\n+        Map map = new HashMap();\n+        Vector vec = new Vector();\n+        vec.add(new HashMap());\n+        vec.add(new HashMap());\n+\n+        map.put(\"vec\", vec);\n+        JXPathContext context = JXPathContext.newContext(map);\n+        Iterator it = context.iteratePointers(\"/vec\");\n+        List actual = new ArrayList();\n+        while(it.hasNext()){\n+            actual.add(((Pointer)it.next()).asPath());\n+        }\n+\n+        assertEquals(\"Iterating 'hasNext'/'next'<\" + \"/vec\" + \">\",\n+            list(\"/.[@name='vec'][1]\", \"/.[@name='vec'][2]\"),\n+            actual);\n+    }\n+\n+    public void testIterateAndSet(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = JXPathContext.newContext(new TestBean());\n+\n+        Iterator it = context.iteratePointers(\"beans/int\");\n+        int i = 5;\n+        while (it.hasNext()){\n+            NodePointer pointer = (NodePointer)it.next();\n+            pointer.setValue(new Integer(i++));\n+        }\n+\n+        it = context.iteratePointers(\"beans/int\");\n+        List actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(((Pointer)it.next()).getValue());\n+        }\n+        assertEquals(\"Iterating <\" + \"beans/int\" + \">\", list(new Integer(5), new Integer(6)), actual);\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with variables\n+     */\n+    public void testVariables(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean.getBeans());\n+        context.getVariables().declareVariable(\"x\", new Double(7.0));\n+        context.getVariables().declareVariable(\"y\", null);\n+        context.getVariables().declareVariable(\"z\", bean);\n+        context.getVariables().declareVariable(\"t\", new String[]{\"a\", \"b\"});\n+        context.getVariables().declareVariable(\"m\", bean.getMap());\n+\n+        testGetValue(context, \"$x + 3\",  new Double(10.0));\n+        testGetValue(context, \"$y\",  null);\n+        testGetValue(context, \"$y + 1\",  new Double(1.0));\n+        boolean exception = false;\n+        try {\n+            testGetValue(context, \"$none\",  null);\n+        }\n+        catch (Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Evaluating '$none', expected exception - did not get it\", exception);\n+\n+        testGetValue(context, \"$z/int\",  new Integer(1));\n+        testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n+        testGetValue(context, \".\",  bean.getBeans());\n+//            testGetValue(context, \".[2]/name\",  \"Name 2\");        // TBD: is this even legal?\n+        testGetValue(context, \"$t[2]\",  \"b\");\n+        testGetValue(context, \"$m/Key1\",  \"Value 1\");\n+    }\n+\n+    private void testGetValue(JXPathContext context, String xpath, Object expected) {\n+        Object actual = context.getValue(xpath);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+\n+        CompiledExpression expr = context.compile(xpath);\n+        actual = expr.getValue(context);\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    private void testGetValue(JXPathContext context, String xpath, Object expected, Class requiredType) {\n+        Object actual = context.getValue(xpath, requiredType);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+\n+        CompiledExpression expr = context.compile(xpath);\n+        actual = expr.getValue(context, requiredType);\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n+     }\n+\n+    /**\n+     * Test JXPath.eval() with various arguments\n+     */\n+    public void testEval(){\n+        if (enabled){\n+            JXPathContext context = JXPathContext.newContext(bean);\n+            testEval(context, \"integers[position()<3]\",\n+                    Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}));\n+        }\n+    }\n+\n+    private void testEval(JXPathContext context, String xpath, Object expected) {\n+        Iterator it = context.iterate(xpath);\n+        ArrayList actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+\n+        CompiledExpression expr = context.compile(xpath);\n+        it = expr.iterate(context);\n+        actual = new ArrayList();\n+        while (it.hasNext()){\n+            actual.add(it.next());\n+        }\n+        assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    public void testContextDependency(){\n+        if (enabled){\n+            testContextDependency(\"1\", false);\n+            testContextDependency(\"$x\", false);\n+            testContextDependency(\"/foo\", false);\n+            testContextDependency(\"foo\", true);\n+            testContextDependency(\"/foo[3]\", false);\n+            testContextDependency(\"/foo[$x]\", false);\n+            testContextDependency(\"/foo[bar]\", true);\n+            testContextDependency(\"3 + 5\", false);\n+            testContextDependency(\"test:func(3, 5)\", true);\n+            testContextDependency(\"test:func(3, foo)\", true);\n+        }\n+    }\n+\n+    public void testContextDependency(String xpath, boolean expected){\n+        Expression expr = (Expression)Parser.parseExpression(xpath, new TreeCompiler());\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, expr.isContextDependent());\n+    }\n+\n+    public void testDocumentOrder(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = JXPathContext.newContext(bean);\n+\n+        testDocumentOrder(context, \"boolean\", \"int\", -1);\n+        testDocumentOrder(context, \"integers[1]\", \"integers[2]\", -1);\n+        testDocumentOrder(context, \"integers[1]\", \"integers[1]\", 0);\n+        testDocumentOrder(context, \"nestedBean/int\", \"nestedBean\", 1);\n+        testDocumentOrder(context, \"nestedBean/int\", \"nestedBean/strings\", -1);\n+        testDocumentOrder(context, \"nestedBean/int\", \"object/int\", -1);\n+\n+        context = JXPathContext.newContext(createTestBeanWithDOM());\n+        testDocumentOrder(context, \"vendor/location\", \"vendor/location/address/street\", -1);\n+        testDocumentOrder(context, \"vendor/location[@id = '100']\", \"vendor/location[@id = '101']\", -1);\n+        testDocumentOrder(context, \"vendor//price:amount\", \"vendor/location\", 1);\n+//        testDocumentOrder(context, \"nonexistent//foo\", \"vendor/location\", 1);     // Will throw an exception\n+    }\n+\n+    private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n+        NodePointer np1 = (NodePointer)context.getPointer(path1);\n+        NodePointer np2 = (NodePointer)context.getPointer(path2);\n+        try {\n+            int res = np1.compareTo(np2);\n+            if (res < 0){\n+                res = -1;\n+            }\n+            else if (res > 0){\n+                res = 1;\n+            }\n+            assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n+        }\n+        catch (Exception ex){\n+            System.err.println(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\");\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Test JXPath.setValue() with various arguments\n+     */\n+    public void testSetValue(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBean tBean = new TestBean();\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+        context.getVariables().declareVariable(\"x\", null);\n+\n+        context.setValue(\"$x\", new Integer(1));\n+        assertEquals(\"Modified <\" + \"$x\" + \">\", new Integer(1), context.getValue(\"$x\"));\n+\n+        boolean exception = false;\n+        try {\n+            context.setValue(\"$y\", new Integer(1));\n+        }\n+        catch (Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Setting '$y = 1', expected exception - did not get it\", exception);\n+\n+        context.setValue(\"int\", new Integer(3));\n+        assertEquals(\"Modified <\" + \"int\" + \">\", new Integer(3), context.getValue(\"int\"));\n+\n+        context.setValue(\"int\", new int[]{4});\n+        assertEquals(\"Modified <\" + \"int\" + \">\", new Integer(4), context.getValue(\"int\"));\n+\n+        context.setValue(\"integers[2]\", new Integer(5));\n+        assertEquals(\"Modified <\" + \"integers[2]\" + \">\", new Integer(5), context.getValue(\"integers[2]\"));\n+\n+        context.setValue(\"integers[2]\", new int[]{6});\n+        assertEquals(\"Modified <\" + \"integers[2]\" + \">\", new Integer(6), context.getValue(\"integers[2]\"));\n+\n+        NestedTestBean nBean = new NestedTestBean(\"Name 9\");\n+        tBean.getBeans()[1] = null;\n+        context.setValue(\"beans[2]\", nBean);\n+        assertEquals(\"Modified <\" + \"beans[2]\" + \">\", nBean, context.getValue(\"beans[2]\"));\n+\n+        context.setValue(\"map/Key1\", new Integer(6));\n+        assertEquals(\"Modified <\" + \"map/Key1\" + \">\", new Integer(6), context.getValue(\"map/Key1\"));\n+\n+        context.setValue(\"map/Key1\", new Integer[]{new Integer(7), new Integer(8)});\n+        context.setValue(\"map/Key1[1]\", new Integer(9));\n+        assertEquals(\"Modified <\" + \"map/Key1[1]\" + \">\", new Integer(9), context.getValue(\"map/Key1[1]\"));\n+\n+        context.setValue(\"map/Key4\", new Integer(7));\n+        assertEquals(\"Modified <\" + \"map/Key4\" + \">\", new Integer(7), context.getValue(\"map/Key4\"));\n+\n+        context.setValue(\"integers[. = 6]\", new Integer(8));\n+        assertEquals(\"Modified <\" + \"integers[. = 6]\" + \">\", new Integer(8), context.getValue(\"integers[2]\"));\n+\n+        context.setValue(\"beans[name = 'Name 9']/int\", new Integer(9));\n+        assertEquals(\"Modified <\" + \"beans[name = 'Name 9']/int\" + \">\", new Integer(9), context.getValue(\"beans[name = 'Name 9']/int\"));\n+\n+        context.setValue(\"@int\", new Integer(10));\n+        assertEquals(\"Modified <\" + \"@int\" + \">\", new Integer(10),\n+                context.getValue(\"@int\"));\n+    }\n+\n+    /**\n+     * Test JXPathContext.createPath() with various arguments\n+     */\n+    public void testCreatePath(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBeanWithNode tBean = createTestBeanWithDOM();\n+        tBean.setNestedBean(null);\n+        tBean.setBeans(null);\n+        tBean.setMap(null);\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+        context.setFactory(new TestFactory());\n+\n+        // Calls factory.declareVariable(\"string\")\n+        testCreatePath(context, \"$string\", null);    // Declare and set to null\n+\n+        assertTrue(\"Variable created\",\n+                context.getVariables().isDeclaredVariable(\"string\"));\n+\n+        // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n+        testCreatePath(context, \"$stringArray[2]\", \"\");\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n+\n+        context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        testCreatePath(context, \"$array[2]\", \"\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n+\n+        // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n+        testCreatePath(context, \"$test/boolean\", Boolean.FALSE);\n+\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and put it in the collection\n+        // at index 1.\n+        testCreatePath(context, \"$testArray[2]/boolean\", Boolean.FALSE);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        testCreatePath(context, \"/nestedBean/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        testCreatePath(context, \"/beans[2]/int\", new Integer(1));\n+\n+        // Another, but the collection already exists\n+        testCreatePath(context, \"/beans[3]/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // sets the value\n+        testCreatePath(context, \"/nestedBean/strings[2]\", \"String 2\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        testCreatePath(context, \"/map[@name='TestKey1']\", \"\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        testCreatePath(context, \"/map[@name='TestKey2']/int\", new Integer(1));\n+\n+        testCreatePath(context, \"/map/TestKey3[2]\", null,\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"/map[@name='TestKey3'][3]\", null);\n+\n+        // Create an element of a dynamic map element, which is a collection\n+        testCreatePath(context, \"/map/TestKey4[1]/int\", new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        tBean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"/map[@name='TestKey4'][1]/int\", new Integer(1));\n+\n+        // Create a DOM element\n+        testCreatePath(context, \"/vendor/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePath(context, \"/vendor/location[3]/address/street\", \"\",\n+                \"/vendor/location[3]/address[1]/street[1]\");\n+\n+        // Comprehensive tests: map & bean\n+        tBean.setMap(null);\n+        testCreatePath(context, \"/map[@name='TestKey5']/nestedBean/int\", new Integer(1));\n+        tBean.setMap(null);\n+        testCreatePath(context, \"/map[@name='TestKey5']/beans[2]/int\", new Integer(1));\n+\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path, Object value){\n+        testCreatePath(context, path, value, path);\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path,\n+                Object value, String expectedPath){\n+        Pointer ptr = null;\n+        try {\n+            ptr = context.createPath(path);\n+        }\n+        catch(JXPathException ex){\n+            ex.getException().printStackTrace();\n+        }\n+\n+        assertEquals(\"Pointer <\" + path + \">\", expectedPath, ptr.asPath());\n+        assertEquals(\"Created <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+\n+    /**\n+     * Test JXPath.createPathAndSetValue() with various arguments\n+     */\n+    public void testCreatePathAndSetValue(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBean tBean = createTestBeanWithDOM();\n+        tBean.setNestedBean(null);\n+        tBean.setBeans(null);\n+        tBean.setMap(null);\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+        context.setFactory(new TestFactory());\n+\n+        // Calls factory.declareVariable(\"string\")\n+        testCreatePathAndSetValue(context, \"$string\", \"Value\");\n+\n+        // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n+        testCreatePathAndSetValue(context, \"$stringArray[2]\", \"Value2\");\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n+\n+        context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        testCreatePathAndSetValue(context, \"$array[2]\", \"Value2\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n+\n+        // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n+        testCreatePathAndSetValue(context, \"$test/boolean\", Boolean.TRUE);\n+\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and put it in the collection\n+        // at index 1.\n+        testCreatePathAndSetValue(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        testCreatePathAndSetValue(context, \"nestedBean/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        testCreatePathAndSetValue(context, \"beans[2]/int\", new Integer(2));\n+\n+        // Another, but the collection already exists\n+        testCreatePathAndSetValue(context, \"beans[3]/int\", new Integer(3));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // sets the value\n+        testCreatePathAndSetValue(context, \"nestedBean/strings[2]\", \"Test\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey1']\", \"Test\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n+\n+        // Calls factory.expandCollection(..., map, \"TestKey3\", 2)\n+        testCreatePathAndSetValue(context, \"map/TestKey3[2]\", \"Test\");\n+\n+        // Should be the same as the one before\n+        testCreatePathAndSetValue(context, \"map[@name='TestKey3'][3]\", \"Test\");\n+\n+        // Create an element of a dynamic map element, which is a collection\n+        testCreatePathAndSetValue(context, \"map/TestKey4[1]/int\", new Integer(5));\n+\n+        tBean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey4'][1]/int\", new Integer(5));\n+\n+        // Create a DOM element\n+        testCreatePathAndSetValue(context, \"vendor/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePathAndSetValue(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n+\n+        // Comprehensive tests: map & bean\n+        tBean.setMap(null);\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(6));\n+        tBean.setMap(null);\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(7));\n+\n+        context = JXPathContext.newContext(new HashMap());\n+        context.setFactory(new TestFactory());\n+        testCreatePathAndSetValue(context, \"/testKey1/testKey2/testKey3\", new Integer(8));\n+        context.setValue(\"/testKey1\", new HashMap());\n+    }\n+\n+    private void testCreatePathAndSetValue(JXPathContext context, String path, Object value){\n+        Pointer ptr = context.createPathAndSetValue(path, value);\n+        assertTrue(\"Pointer <\" + path + \">\", ptr != null);\n+        assertEquals(\"Created <\" + path + \">\", value, context.getValue(path));\n+        assertEquals(\"Pointer value <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+    /**\n+     * Test JXPathContext.removePath() with various arguments\n+     */\n+    public void testRemovePath(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBeanWithNode tBean = createTestBeanWithDOM();\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+\n+        // Undeclare variable\n+        context.getVariables().declareVariable(\"temp\", \"temp\");\n+        context.removePath(\"$temp\");\n+        assertTrue(\"Undeclare variable\",\n+                !context.getVariables().isDeclaredVariable(\"temp\"));\n+\n+        // Remove array element\n+        context.getVariables().\n+                declareVariable(\"temp\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove array element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+\n+        // Remove list element\n+        context.getVariables().\n+                declareVariable(\"temp\", list(\"temp1\", \"temp2\"));\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove collection element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+\n+        // Remove property value\n+        context.removePath(\"nestedBean/int\");\n+        assertEquals(\"Remove property value\", new Integer(0),\n+                    context.getValue(\"nestedBean/int\"));\n+\n+        // Remove property value\n+        context.removePath(\"nestedBean/strings[1]\");\n+        assertEquals(\"Remove property value\", \"String 2\",\n+                    context.getValue(\"nestedBean/strings[1]\"));\n+\n+        context.removePath(\"nestedBean\");\n+        context.setLenient(true);\n+        assertEquals(\"Remove property value\", null,\n+                    context.getValue(\"nestedBean\"));\n+\n+        tBean.getMap().put(\"TestKey1\", \"test\");\n+\n+        // Remove dynamic property\n+        context.removePath(\"map[@name = 'TestKey1']\");\n+        assertEquals(\"Remove dynamic property value\", null,\n+                    context.getValue(\"map[@name = 'TestKey1']\"));\n+\n+        tBean.getMap().put(\"TestKey2\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"map[@name = 'TestKey2'][1]\");\n+        assertEquals(\"Remove dynamic property collection element\", \"temp2\",\n+                    context.getValue(\"map[@name = 'TestKey2'][1]\"));\n+\n+        // Remove DOM nodes\n+        context.removePath(\"vendor/location[@id = '101']//street/text()\");\n+        assertEquals(\"Remove DOM text\", \"\",\n+                    context.getValue(\"vendor/location[@id = '101']//street\"));\n+\n+        context.removePath(\"vendor/location[@id = '101']//street\");\n+        assertEquals(\"Remove DOM element\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '101']//street)\"));\n+\n+        context.removePath(\"vendor/location[@id = '100']/@name\");\n+        assertEquals(\"Remove DOM attribute\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '100']/@name)\"));\n+    }\n+\n+    public void testIDAndKey(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(createTestBeanWithDOM());\n+        context.setIdentityManager(new IdentityManager(){\n+            public Pointer getPointerByID(JXPathContext context, String id){\n+                NodePointer ptr = (NodePointer)context.getPointer(\"/vendor\");\n+                return ptr.getPointerByID(context, id);\n+            }\n+        });\n+        context.setKeyManager(new KeyManager(){\n+            public Pointer getPointerByKey(JXPathContext context,\n+                                            String key, String value){\n+                return NodePointer.newNodePointer(null, \"42\", null);\n+            }\n+        });\n+        assertEquals(\"Test ID\", \"Tangerine Drive\",\n+            context.getValue(\"id(101)//street\"));\n+        assertEquals(\"Test ID Path\", \"id('101')/address[1]/street[1]\",\n+            context.getPointer(\"id(101)//street\").asPath());\n+\n+        assertEquals(\"Test key\", \"42\",\n+            context.getValue(\"key('a', 'b')\"));\n+\n+        context.setLenient(true);\n+        assertEquals(\"Test ID Path Null\", \"id(105)/address/street\",\n+            context.getPointer(\"id(105)/address/street\").asPath());\n+    }\n+\n+    public void testNull(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(new TestNull());\n+        testGetValue(context, \"nothing\", null);\n+        testGetValue(context, \"child/nothing\", null);\n+        testGetValue(context, \"array[2]\", null);\n+        context.setLenient(true);\n+        testGetValue(context, \"nothing/something\", null);\n+        testGetValue(context, \"array[2]/something\", null);\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with nested contexts\n+     */\n+    public void testNestedContext(){\n+        if (enabled){\n+            JXPathContext pcontext = JXPathContext.newContext(null);\n+            pcontext.getVariables().declareVariable(\"x\", bean);\n+\n+            JXPathContext context = JXPathContext.newContext(pcontext, bean);\n+\n+            testGetValue(context, \"integers[$x/int]\",  new Integer(1));\n+        }\n+    }\n+\n+    private static class Context implements ExpressionContext {\n+        private Object object;\n+\n+        public Context(Object object){\n+            this.object = object;\n+        }\n+\n+        public Pointer getContextNodePointer(){\n+            return NodePointer.newNodePointer(null, object, Locale.getDefault());\n+        }\n+\n+        public List getContextNodeList(){\n+            return null;\n+        }\n+\n+        public JXPathContext getJXPathContext(){\n+            return null;\n+        }\n+\n+        public int getPosition(){\n+            return 0;\n+        }\n+    }\n+\n+    public void testFunctions(){\n+        if (enabled){\n+            Object[] args;\n+            Function func;\n+\n+            TestFunctions test = new TestFunctions();\n+            Functions funcs = new ClassFunctions(TestFunctions.class, \"test\");\n+\n+            args = new Object[]{new Integer(1), \"x\"};\n+            func = funcs.getFunction(\"test\", \"new\", args);\n+            assertEquals(\"test:new(1, x)\", func.invoke(new Context(null), args).toString(), \"foo=1; bar=x\");\n+\n+            args = new Object[]{\"baz\"};\n+            func = funcs.getFunction(\"test\", \"new\", args);\n+            assertEquals(\"test:new('baz')\", func.invoke(new Context(new Integer(1)), args).toString(), \"foo=1; bar=baz\");\n+\n+            args = new Object[]{new Integer(1), \"x\"};\n+            func = funcs.getFunction(\"test\", \"build\", args);\n+            assertEquals(\"test:build(1, x)\", func.invoke(new Context(null), args).toString(), \"foo=1; bar=x\");\n+\n+            args = new Object[]{\"7\", new Integer(1)};\n+            func = funcs.getFunction(\"test\", \"build\", args);\n+            assertEquals(\"test:build('7', 1)\", func.invoke(new Context(null), args).toString(), \"foo=7; bar=1\");\n+\n+            args = new Object[]{test};\n+            func = funcs.getFunction(\"test\", \"getFoo\", args);\n+            assertEquals(\"test:getFoo($test, 1, x)\", func.invoke(new Context(null), args).toString(), \"0\");\n+\n+            args = new Object[0];\n+            func = funcs.getFunction(\"test\", \"path\", args);\n+            assertEquals(\"test:path()\", func.invoke(new Context(new Integer(1)), args), \"1\");\n+\n+            args = new Object[]{test};\n+            func = funcs.getFunction(\"test\", \"instancePath\", args);\n+            assertEquals(\"test:instancePath()\", func.invoke(new Context(new Integer(1)), args), \"1\");\n+\n+            args = new Object[]{test, \"*\"};\n+            func = funcs.getFunction(\"test\", \"pathWithSuffix\", args);\n+            assertEquals(\"test:pathWithSuffix('*')\", func.invoke(new Context(new Integer(1)), args), \"1*\");\n+        }\n+    }\n+\n+    public void testParserReferenceImpl() throws Exception {\n+        if (!enabled){\n+            return;\n+        }\n+        System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n+                \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n+        testParser(JXPathContextFactory.newInstance().newContext(null, bean), false);\n+    }\n+\n+    public void testParser(JXPathContext ctx, boolean ignorePath) throws Exception {\n+        bean.getBeans()[1].setInt(3);\n+        ctx.setLocale(Locale.US);\n+        ctx.getVariables().declareVariable(\"a\", new Double(1));\n+        ctx.getVariables().declareVariable(\"b\", new Double(1));\n+        ctx.getVariables().declareVariable(\"nan\", new Double(Double.NaN));\n+        ctx.getVariables().declareVariable(\"test\", new TestFunctions(4, \"test\"));\n+        ctx.getVariables().declareVariable(\"testnull\", new TestNull());\n+        FunctionLibrary lib = new FunctionLibrary();\n+        lib.addFunctions(new ClassFunctions(TestFunctions.class, \"test\"));\n+        lib.addFunctions(new ClassFunctions(TestFunctions2.class, \"test\"));\n+        lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n+        lib.addFunctions(new PackageFunctions(\"org.apache.commons.jxpath.\", \"jxpathtest\"));\n+        ctx.setFunctions(lib);\n+        testXPaths(ctx, xpath_tests, ignorePath);\n+    }\n+\n+    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath) throws Exception{\n+        Exception exception = null;\n+        for  (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                Object actual;\n+//                System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n+                if (xpath_tests[i].path){\n+                    if (ignorePath){\n+                        actual = xpath_tests[i].expected;\n+                    }\n+                    else {\n+                        if (xpath_tests[i].eval){\n+                            Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n+                            List paths = new ArrayList();\n+                            while (it.hasNext()){\n+                                paths.add(((Pointer)it.next()).asPath());\n+                            }\n+                            actual = paths;\n+                        }\n+                        else {\n+                            ctx.setLenient(xpath_tests[i].lenient);\n+                            actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n+                        }\n+                    }\n+                }\n+                else {\n+                    if (xpath_tests[i].eval){\n+                        ArrayList list = new ArrayList();\n+                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n+                        while (it.hasNext()){\n+                            list.add(it.next());\n+                        }\n+                        actual = list;\n+                    }\n+                    else {\n+                        ctx.setLenient(xpath_tests[i].lenient);\n+                        actual = ctx.getValue(xpath_tests[i].xpath);\n+                        ctx.setLenient(false);\n+                    }\n+                }\n+                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\", xpath_tests[i].expected, actual);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+                exception = ex;\n+            }\n+            if (exception != null){\n+                throw exception;\n+            }\n+        }\n+\n+        // Make sure that location paths are properly constructed\n+        for (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n+                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n+                    Pointer test = ctx.getPointer(ptr.asPath());\n+                    assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n+                }\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during pointer test <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    private static class XP {\n+        public String xpath;\n+        public Object expected;\n+        public boolean eval;\n+        public boolean path;\n+        public boolean lenient;\n+\n+        public XP(String xpath,  Object expected, boolean eval, boolean path, boolean lenient){\n+            this.xpath = xpath;\n+            this.expected = expected;\n+            this.eval = eval;\n+            this.path = path;\n+            this.lenient = lenient;\n+        }\n+    }\n+\n+    private static XP test(String xpath, Object expected){\n+        return new XP(xpath, expected, false, false, false);\n+    }\n+\n+    private static XP testLenient(String xpath, Object expected){\n+        return new XP(xpath, expected, false, false, true);\n+    }\n+\n+    private static XP testEval(String xpath, Object expected){\n+        return new XP(xpath, expected, true, false, false);\n+    }\n+\n+    private static XP testPath(String xpath, Object expected){\n+        return new XP(xpath, expected, false, true, true);\n+    }\n+\n+    private static XP testEvalPath(String xpath, Object expected){\n+        return new XP(xpath, expected, true, true, false);\n+    }\n+\n+    static final XP[] xpath_tests = new XP[]{\n+\n+        // Numbers\n+        test(\"1\", new Double(1.0)),\n+        testEval(\"1\", list(new Double(1.0))),\n+        test(\"-1\", new Double(-1.0)),\n+        test(\"2 + 2\", new Double(4.0)),\n+        test(\"3 - 2\", new Double(1.0)),\n+        test(\"1 + 2 + 3 - 4 + 5\", new Double(7.0)),\n+        test(\"3 * 2\", new Double(3.0*2.0)),\n+        test(\"3 div 2\", new Double(3.0/2.0)),\n+        test(\"5 mod 2\", new Double(1.0)),\n+        test(\"5.9 mod 2.1\", new Double(1.0)),     // Error in Xalan?\n+        test(\"5 mod -2\", new Double(1.0)),\n+        test(\"-5 mod 2\", new Double(-1.0)),\n+        test(\"-5 mod -2\", new Double(-1.0)),\n+        test(\"1 < 2\", Boolean.TRUE),\n+        test(\"1 > 2\", Boolean.FALSE),\n+        test(\"1 <= 1\", Boolean.TRUE),\n+        test(\"1 >= 2\", Boolean.FALSE),\n+        test(\"3 > 2 > 1\", Boolean.FALSE),\n+        test(\"3 > 2 and 2 > 1\", Boolean.TRUE),\n+        test(\"3 > 2 and 2 < 1\", Boolean.FALSE),\n+        test(\"3 < 2 or 2 > 1\", Boolean.TRUE),\n+        test(\"3 < 2 or 2 < 1\", Boolean.FALSE),\n+        test(\"1 = 1\", Boolean.TRUE),\n+        test(\"1 = '1'\", Boolean.TRUE),\n+        test(\"1 > 2 = 2 > 3\", Boolean.TRUE),\n+        test(\"1 > 2 = 0\", Boolean.TRUE),\n+        test(\"1 = 2\", Boolean.FALSE),\n+\n+        // Variables\n+        test(\"$a\", new Double(1)),\n+        testPath(\"$a\", \"$a\"),\n+\n+        test(\"$a = $b\", Boolean.TRUE),\n+        test(\"$a = $test\", Boolean.FALSE),\n+\n+        // Traversal\n+        // ancestor::\n+        test(\"int/ancestor::root = /\", Boolean.TRUE),\n+        test(\"count(beans/name/ancestor-or-self::node())\", new Double(5)),\n+        test(\"beans/name/ancestor-or-self::node()[3] = /\", Boolean.TRUE),\n+\n+        // child::\n+        test(\"count(set)\", new Double(3)),\n+        test(\"boolean\", Boolean.FALSE),\n+//        test(\"boolean/class/name\", \"java.lang.Boolean\"),\n+        testEval(\"foo:boolean\", list()),\n+        test(\"count(*)\", new Double(21.0)),\n+        test(\"count(@*)\", new Double(21.0)),\n+        testPath(\"boolean\", \"/boolean\"),\n+        testEvalPath(\"boolean\", list(\"/boolean\")),\n+        test(\"nestedBean/name\", \"Name 0\"),\n+        testPath(\"nestedBean/name\", \"/nestedBean/name\"),\n+        testEvalPath(\"nestedBean/name\", list(\"/nestedBean/name\")),\n+\n+        testEval(\"integers\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n+        testPath(\"integers\", \"/integers\"),\n+        testEvalPath(\"integers\", list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\")),\n+        test(\"integers[2]\", new Integer(2)),\n+        testPath(\"integers[2]\", \"/integers[2]\"),\n+        testEvalPath(\"integers[2]\", list(\"/integers[2]\")),\n+        test(\"beans[1]/name\", \"Name 1\"),\n+        testPath(\"beans[1]/name\", \"/beans[1]/name\"),\n+        testEval(\"beans[1]/strings\", list(\"String 1\", \"String 2\", \"String 3\")),\n+        testEval(\"beans/strings[2]\", list(\"String 2\", \"String 2\")),\n+        test(\"beans/strings[2]\", \"String 2\"),\n+        test(\"beans[int > 2]/name\", \"Name 2\"),\n+\n+        test(\"beans/strings[name(.)='strings'][2]\", \"String 2\"),\n+        test(\"(beans/strings[2])[1]\", \"String 2\"),\n+        test(\"count(*)\", new Double(21)),\n+        test(\"count(child::node())\", new Double(21)),\n+\n+        // descendant::\n+        test(\"count(descendant::node())\", new Double(65)),\n+        test(\"count(descendant::root)\", new Double(0)),\n+        test(\"count(descendant::name)\", new Double(7)),\n+\n+        // descendant-or-self::\n+        testEval(\"//name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"//Key1\", \"Value 1\"),\n+\n+        testEval(\"//self::node()[name = 'Name 0']/name\", list(\"Name 0\")),\n+        testEval(\"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n+                list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"count(//self::beans)\", new Double(2)),\n+        test(\"count(nestedBean//.)\", new Double(7)),\n+        testEval(\"descendant-or-self::name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"count(descendant-or-self::root)\", new Double(1)),\n+        test(\"count(descendant-or-self::node())\", new Double(66)),\n+\n+        // following::\n+        test(\"count(nestedBean/strings[2]/following::node())\", new Double(21)),\n+        test(\"count(nestedBean/strings[2]/following::strings)\", new Double(7)),\n+\n+        // following-sibling::\n+        test(\"count(/nestedBean/following-sibling::node())\", new Double(8)),\n+        test(\"count(/nestedBean/following-sibling::object)\", new Double(1)),\n+        test(\"count(/nestedBean/boolean/../following-sibling::node())\", new Double(8)),\n+        test(\"count(/nestedBean/boolean/../following-sibling::object)\", new Double(1)),\n+        test(\"count(/descendant::boolean/following-sibling::node())\", new Double(53)),\n+        test(\"count(/descendant::boolean/following-sibling::name)\", new Double(7)),\n+\n+\n+        // parent::\n+        test(\"count(/beans/..)\", new Double(1)),\n+        test(\"count(//..)\", new Double(9)),\n+        test(\"count(//../..)\", new Double(2)),\n+        testEval(\"//parent::beans/name\", list(\"Name 1\", \"Name 2\")),\n+\n+        // preceding::\n+        test(\"count(beans[2]/int/preceding::node())\", new Double(8)),\n+        test(\"count(beans[2]/int/preceding::boolean)\", new Double(2)),\n+\n+        // preceding-sibling::\n+        test(\"count(/boolean/preceding-sibling::node())\", new Double(2)),\n+        test(\"count(/nestedBean/int/../preceding-sibling::node())\", new Double(12)),\n+        test(\"count(/descendant::int/preceding-sibling::node())\", new Double(10)),\n+\n+        // self::\n+        test(\"self::node() = /\", Boolean.TRUE),\n+        test(\"self::root = /\", Boolean.TRUE),\n+\n+        // Union - note corrected document order\n+        testEval(\"integers | beans[1]/strings\",\n+            list(\"String 1\", \"String 2\", \"String 3\",\n+              new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n+\n+        test(\"count((integers | beans[1]/strings)[contains(., '1')])\", new Double(2)),\n+        test(\"count((integers | beans[1]/strings)[name(.) = 'strings'])\", new Double(3)),\n+\n+        // Note that the following is different from \"integer[2]\" - it is a filter expression\n+        test(\"(integers)[2]\", new Integer(2)),        // TBD\n+\n+        // Core functions\n+        test(\"integers[last()]\", new Integer(4)),\n+        test(\"integers[position() = last() - 1]\", new Integer(3)),\n+        testEval(\"integers[position() < 3]\", list(new Integer(1), new Integer(2))),\n+        test(\"count(beans/strings)\", new Double(6)),\n+        test(\"integers[string() = '2']\", new Integer(2)),\n+\n+        test(\"name(integers)\", \"integers\"),\n+        testEval(\"*[name(.) = 'integers']\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n+\n+        // Dynamic properties\n+        test(\"nestedBean[@name = 'int']\", new Integer(1)),    // Not implemented in Xalan\n+        testPath(\"nestedBean[@name = 'int']\", \"/nestedBean/int\"),\n+        test(\"map[@name = 'Key1']\", \"Value 1\"),               // Not implemented in Xalan\n+        testPath(\"map[@name = 'Key1']\", \"/map[@name='Key1']\"),\n+        test(\"map/Key1\", \"Value 1\"),\n+        testPath(\"map/Key1\", \"/map[@name='Key1']\"),\n+        testPath(\"map[@name = 'Key&quot;&apos;&quot;&apos;1']\", \"/map[@name='Key&quot;&apos;&quot;&apos;1']\"),\n+        test(\"map/Key2/name\", \"Name 6\"),\n+        testPath(\"map/Key2/name\", \"/map[@name='Key2']/name\"),\n+        test(\"/.[@name='map']/Key2/name\", \"Name 6\"),\n+        testPath(\"/.[@name='map']/Key2/name\", \"/map[@name='Key2']/name\"),\n+        test(\"/map[@name='Key2'][@name='name']\", \"Name 6\"),\n+        testPath(\"/map[@name='Key2'][@name='name']\", \"/map[@name='Key2']/name\"),\n+        test(\"/.[@name='map'][@name='Key2'][@name='name']\", \"Name 6\"),\n+        testPath(\"/.[@name='map'][@name='Key2'][@name='name']\", \"/map[@name='Key2']/name\"),\n+\n+        // Standard functions\n+        test(\"string(2)\", \"2\"),\n+        test(\"string($nan)\", \"NaN\"),\n+        test(\"string(-$nan)\", \"NaN\"),\n+        test(\"string(-2 div 0)\", \"-Infinity\"),\n+        test(\"string(2 div 0)\", \"Infinity\"),\n+        test(\"concat('a', 'b', 'c')\", \"abc\"),\n+        test(\"starts-with('abc', 'ab')\", Boolean.TRUE),\n+        test(\"starts-with('xabc', 'ab')\", Boolean.FALSE),\n+        test(\"contains('xabc', 'ab')\", Boolean.TRUE),\n+        test(\"contains('xabc', 'ba')\", Boolean.FALSE),\n+        test(\"substring-before('1999/04/01', '/')\", \"1999\"),\n+        test(\"substring-after('1999/04/01', '/')\", \"04/01\"),\n+        test(\"substring('12345', 2, 3)\", \"234\"),\n+        test(\"substring('12345', 2)\", \"2345\"),\n+        test(\"substring('12345', 1.5, 2.6)\", \"234\"),\n+        test(\"substring('12345', 0, 3)\", \"12\"),\n+        test(\"substring('12345', 0 div 0, 3)\", \"\"),\n+        test(\"substring('12345', 1, 0 div 0)\", \"\"),\n+        test(\"substring('12345', -42, 1 div 0)\", \"12345\"),\n+        test(\"substring('12345', -1 div 0, 1 div 0)\", \"\"),\n+        test(\"string-length('12345')\", new Double(5)),\n+        testEval(\"beans[1]/strings[string-length() = 8]\", list(\"String 1\", \"String 2\", \"String 3\")),\n+        test(\"normalize-space(' abc  def  ')\", \"abc def\"),\n+        test(\"normalize-space('abc def')\", \"abc def\"),\n+        test(\"normalize-space('   ')\", \"\"),\n+        test(\"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\"),\n+        test(\"boolean(1)\", Boolean.TRUE),\n+        test(\"boolean(0)\", Boolean.FALSE),\n+        test(\"boolean('x')\", Boolean.TRUE),\n+        test(\"boolean('')\", Boolean.FALSE),\n+        test(\"boolean(boolean)\", Boolean.FALSE),\n+        test(\"boolean(integers[position() < 3])\", Boolean.TRUE),\n+        test(\"boolean(integers[position() > 4])\", Boolean.FALSE),\n+        test(\"true()\", Boolean.TRUE),\n+        test(\"false()\", Boolean.FALSE),\n+        test(\"not(false())\", Boolean.TRUE),\n+        test(\"not(true())\", Boolean.FALSE),\n+        test(\"number('1')\", new Double(1)),\n+        test(\"sum(integers)\", new Double(10)),\n+        test(\"floor(1.5)\", new Double(1)),\n+        test(\"floor(-1.5)\", new Double(-2)),\n+        test(\"ceiling(1.5)\", new Double(2)),\n+        test(\"ceiling(-1.5)\", new Double(-1)),\n+        test(\"round(1.5)\", new Double(2)),\n+        test(\"round(-1.5)\", new Double(-1)),\n+        test(\"null()\", null),\n+        test(\"@xml:lang\", \"en-US\"),\n+        test(\"count(@xml:*)\", new Double(1)),\n+        testLenient(\"@foo\", null),\n+        test(\"lang('en')\", Boolean.TRUE),\n+        test(\"lang('fr')\", Boolean.FALSE),\n+\n+\n+        // Extension functions\n+        test(\"string(test:new())\", \"foo=0; bar=null\"),\n+        test(\"string(jxpathtest:TestFunctions.new())\", \"foo=0; bar=null\"),\n+        test(\"string(\" + TestFunctions.class.getName() + \".new())\", \"foo=0; bar=null\"),\n+        test(\"string(test:new(3, 'baz'))\", \"foo=3; bar=baz\"),\n+        test(\"string(test:new('3', 4))\", \"foo=3; bar=4.0\"),\n+        test(\"string(test:getFoo($test))\", \"4\"),\n+        test(\"string(call:getFoo($test))\", \"4\"),\n+        test(\"string(getFoo($test))\", \"4\"),\n+        test(\"string(test:setFooAndBar($test, 7, 'biz'))\", \"foo=7; bar=biz\"),\n+        test(\"string(test:build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(jxpathtest:TestFunctions.build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(\" + TestFunctions.class.getName() + \".build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(test:increment(8))\", \"9\"),\n+        test(\"length('foo')\", new Integer(3)),\n+        test(\"call:substring('foo', 1, 2)\", \"o\"),\n+        test(\"//.[test:isMap()]/Key1\", \"Value 1\"),\n+        test(\"count(//.[test:count(strings) = 3])\", new Double(7)),\n+\n+        test(\"/beans[contains(test:path(), '[2]')]/name\", \"Name 2\"),\n+\n+        // null\n+        testPath(\"$null\", \"$null\"),\n+        testPath(\"$null[3]\", \"$null[3]\"),\n+        testPath(\"$testnull/nothing\", \"$testnull/nothing\"),\n+        testPath(\"$testnull/nothing[2]\", \"$testnull/nothing[2]\"),\n+        testPath(\"beans[8]/int\", \"/beans[8]/int\"),\n+        testEval(\"$testnull/nothing[1]\", Collections.EMPTY_LIST),\n+    };\n+\n+    private static List list(){\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    private static List list(Object o1){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6, Object o7){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        list.add(o7);\n+        return list;\n+    }\n+\n+    public void testDOM() throws Exception {\n+        if (!enabled){\n+            return;\n+        }\n+        System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n+                \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n+        DocumentContainer docCtr = new DocumentContainer(\n+                getClass().getResource(\"Vendor.xml\"),\n+                DocumentContainer.MODEL_DOM);\n+        Document doc = (Document)docCtr.getValue();\n+        JXPathContext ctx = JXPathContextFactory.newInstance().newContext(null, doc);\n+        ctx.setLocale(Locale.US);\n+        ctx.getVariables().declareVariable(\"dom\", doc);\n+        ctx.getVariables().declareVariable(\"object\", docCtr);\n+        ctx.getVariables().declareVariable(\"null\", null);\n+        TestBeanWithNode tbwdom = createTestBeanWithDOM();\n+        ctx.getVariables().declareVariable(\"test\", tbwdom);\n+        testXPaths(ctx, dom_tests, false);\n+    }\n+\n+    private TestBeanWithNode createTestBeanWithDOM(){\n+        DocumentContainer docCtr =\n+            new DocumentContainer(getClass().getResource(\"Vendor.xml\"),\n+            DocumentContainer.MODEL_DOM);\n+        Document doc = (Document)docCtr.getValue();\n+        TestBeanWithNode tbwdom = new TestBeanWithNode();\n+        tbwdom.setVendor(doc.getDocumentElement());\n+        tbwdom.setObject(docCtr);\n+        return tbwdom;\n+    }\n+\n+    static final XP[] dom_tests = new XP[]{\n+        test(\"vendor/location/address/street\", \"Orchard Road\"),\n+        test(\"vendor/location[2]/address/street\", \"Tangerine Drive\"),\n+        test(\"vendor/location/address/city\", \"Fruit Market\"),\n+        test(\"//street\", \"Orchard Road\"),\n+        test(\"local-name(//street/..)\", \"address\"),\n+        test(\"number(vendor/location/employeeCount)\", new Double(10)),\n+        test(\"vendor/location/employeeCount + 1\", new Double(11)),\n+        test(\"vendor/location/employeeCount and true()\", Boolean.TRUE),\n+        test(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\", \"Tangerine Drive\"),\n+        testPath(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\",\n+                \"/vendor[1]/location[2]/address[1]/street[1]\"),\n+        testPath(\"//location[2]/preceding-sibling::location//street\",\n+                \"/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"vendor/location/@id\", \"100\"),\n+        testPath(\"vendor/location/@id\", \"/vendor[1]/location[1]/@id\"),\n+        testEval(\"vendor/location/@id\", list(\"100\", \"101\")),\n+        test(\"vendor/product/price:amount\", \"45.95\"),\n+        test(\"namespace-uri(vendor/product/price:amount)\", \"priceNS\"),\n+        test(\"local-name(vendor/product/price:amount)\", \"amount\"),\n+        test(\"name(vendor/product/price:amount)\", \"priceNS:amount\"),\n+        test(\"vendor/product/prix\", \"934.99\"),\n+        test(\"vendor/product/prix/namespace::price\", \"priceNS\"),\n+        testPath(\"vendor/product/prix/namespace::price\", \"/vendor[1]/product[1]/prix[1]/namespace::price\"),\n+        test(\"count(vendor/product/namespace::*)\", new Double(3)),\n+        test(\"name(vendor/product/prix/namespace::price)\", \"priceNS:price\"),\n+        test(\"local-name(vendor/product/prix/namespace::price)\", \"price\"),\n+        test(\"vendor/product/price:amount/@price:discount\", \"10%\"),\n+        test(\"vendor/product/value:amount/@value:discount\", \"10%\"),\n+        test(\"namespace-uri(vendor/product/price:amount/@price:discount)\", \"priceNS\"),\n+        test(\"local-name(vendor/product/price:amount/@price:discount)\", \"discount\"),\n+        test(\"name(vendor/product/price:amount/@price:discount)\", \"priceNS:discount\"),\n+        test(\"vendor/product/price:amount/@discount\", \"20%\"),\n+        test(\"namespace-uri(vendor/product/price:amount/@discount)\", \"\"),\n+        test(\"local-name(vendor/product/price:amount/@discount)\", \"discount\"),\n+        test(\"name(vendor/product/price:amount/@discount)\", \"discount\"),\n+        test(\"vendor/product/price:sale/saleEnds/ancestor::price:sale/saleEnds\", \"never\"),\n+        test(\"vendor/product/price:sale/ancestor-or-self::price:sale/saleEnds\", \"never\"),\n+        test(\"vendor/product/price:sale/saleEnds/ancestor::price:*\" + \"/saleEnds\", \"never\"),\n+        test(\"count(vendor/product/price:*)\", new Double(2)),\n+        test(\"count(vendor/product/value:*)\", new Double(2)),\n+        test(\"count(vendor/product/*)\", new Double(2)),\n+        testEval(\"vendor/product/price:amount/@price:*\", list(\"10%\")),\n+        testEval(\"vendor/product/price:amount/@*\", list(\"20%\")),\n+        test(\"count(//price:*)\", new Double(2)),\n+        test(\"vendor/product/price:sale/saleEnds/parent::price:*\" + \"/saleEnds\", \"never\"),\n+        test(\"//location/following::price:sale/saleEnds\", \"never\"),\n+        test(\"//price:sale/self::price:sale/saleEnds\", \"never\"),\n+        testLenient(\"//price:sale/self::x/saleEnds\", null),\n+\n+        test(\"//product/comment()\", \"We are not buying this product, ever\"),\n+        //  This test was incorrect\n+        //  test(\"//product/text()[. != '']\", \"We love this product.\"),\n+        testPath(\"//product/text()\", \"/vendor[1]/product[1]/text()[1]\"),\n+        test(\"//product/processing-instruction()\", \"do not show anybody\"),\n+        test(\"//product/processing-instruction('report')\", \"average only\"),\n+        testPath(\"//product/processing-instruction('report')\", \"/vendor[1]/product[1]/processing-instruction('report')[1]\"),\n+        test(\"name(//product/processing-instruction()[1])\", \"security\"),\n+\n+        test(\"//product/prix/@xml:lang\", \"fr\"),\n+        test(\"//product/prix[lang('fr')]\", \"934.99\"),\n+        test(\"//product/price:sale[lang('en')]/saleEnds\", \"never\"),\n+        test(\"vendor/location/@manager\", \"\"),\n+        testLenient(\"vendor/location/@missing\", null),\n+        test(\"count(vendor/location[1]/@*)\", new Double(3)),\n+        test(\"vendor/location[@id='101']//street\", \"Tangerine Drive\"),\n+        test(\"$test/int\", new Integer(1)),\n+        test(\"$test/vendor/location[1]//street\", \"Orchard Road\"),\n+        testPath(\"$test/vendor/location[1]//street\", \"$test/vendor/location[1]/address[1]/street[1]\"),\n+        test(\"$dom/vendor//street\", \"Orchard Road\"),\n+        test(\"$test/object/vendor/location[1]//street\", \"Orchard Road\"),\n+        testPath(\"$test/object/vendor/location[1]//street\", \"$test/object/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"$object//street\", \"Orchard Road\"),\n+        testPath(\"$object//street\", \"$object/vendor[1]/location[1]/address[1]/street[1]\"),\n+\n+        testEval(\"vendor/contact/following::location//street\",\n+            list(\"Orchard Road\", \"Tangerine Drive\")),\n+\n+//        test(\"id('101')//street\", \"Tangerine Drive\"),\n+//        testPath(\"id('101')//street\", \"id('101')/address[1]/street[1]\"),\n+   };\n+\n+    public void testTypeConversions(){\n+        for (int i=0; i < typeConversionTests.length; i++) {\n+            TypeConversionTest test = typeConversionTests[i];\n+            try {\n+                boolean can = TypeUtils.canConvert(test.from, test.toType);\n+                assertTrue(\"Can convert: \" + test, can);\n+                Object result = TypeUtils.convert(test.from, test.toType);\n+                if (result.getClass().isArray()){\n+                    ArrayList list = new ArrayList();\n+                    for (int j = 0; j < Array.getLength(result); j++){\n+                        list.add(Array.get(result, j));\n+                    }\n+                    result = list;\n+                }\n+                assertEquals(\"Convert: \" + test, test.expected, result);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during conversion test <\" + test + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    private static class TypeConversionTest {\n+        public Object from;\n+        public Class toType;\n+        public Object expected;\n+\n+        public TypeConversionTest(Object from, Class toType, Object expected){\n+            this.from = from;\n+            this.toType = toType;\n+            this.expected = expected;\n+        }\n+        public String toString(){\n+            return from.getClass() + \" to \" + toType;\n+        }\n+    }\n+\n+    private TypeConversionTest[] typeConversionTests = new TypeConversionTest[]{\n+        new TypeConversionTest(new Integer(1), String.class, \"1\"),\n+\n+        new TypeConversionTest(new int[]{1, 2}, List.class,\n+                Arrays.asList(new Object[]{new Integer(1), new Integer(2)})),\n+\n+        new TypeConversionTest(new int[]{1, 2}, String[].class,\n+                list(\"1\", \"2\")),\n+\n+        new TypeConversionTest(list(new Integer(1), new Integer(2)), String[].class,\n+                list(\"1\", \"2\")),\n+\n+//        new TypeConversionTest(new Object(){\n+//              public String toString(){\n+//                  return \"42\";\n+//              }\n+//          }, Integer.class, new Integer(42)),\n+    };\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.1 2002/10/13 03:01:03 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/10/13 03:01:03 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri.model;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.xml.*;\n+import java.beans.*;\n+\n+/**\n+ * Abstract superclass for pure XPath 1.0.  Subclasses\n+ * apply the same XPaths to contexts using different models:\n+ * DOM, JDOM etc.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/10/13 03:01:03 $\n+ */\n+\n+public abstract class XMLModelTestCase extends TestCase\n+{\n+    private boolean enabled = true;\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public XMLModelTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+\n+    protected abstract String getModel();\n+\n+    protected DocumentContainer createDocumentContainer(){\n+        return new DocumentContainer(\n+                getClass().getClassLoader().\n+                        getResource(\"org/apache/commons/jxpath/Vendor.xml\"),\n+                getModel());\n+    }\n+\n+    protected JXPathContext createContext(){\n+        JXPathContext context =\n+                JXPathContext.newContext(createDocumentContainer());\n+        context.setFactory(new TestFactory());\n+        return context;\n+    }\n+\n+    // ------------------------------------------------ Individual Test Methods\n+\n+    public void testDocumentOrder(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = createContext();\n+        testDocumentOrder(context, \"vendor/location\", \"vendor/location/address/street\", -1);\n+        testDocumentOrder(context, \"vendor/location[@id = '100']\", \"vendor/location[@id = '101']\", -1);\n+        testDocumentOrder(context, \"vendor//price:amount\", \"vendor/location\", 1);\n+    }\n+\n+    private void testDocumentOrder(JXPathContext context, String path1, String path2, int expected){\n+        NodePointer np1 = (NodePointer)context.getPointer(path1);\n+        NodePointer np2 = (NodePointer)context.getPointer(path2);\n+        try {\n+            int res = np1.compareTo(np2);\n+            if (res < 0){\n+                res = -1;\n+            }\n+            else if (res > 0){\n+                res = 1;\n+            }\n+            assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", expected, res);\n+        }\n+        catch (Exception ex){\n+            System.err.println(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\");\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Test JXPathContext.createPath() with various arguments\n+     */\n+    public void testCreatePath(){\n+        if (!enabled){\n+            return;\n+        }\n+\n+        JXPathContext context = createContext();\n+\n+        // Create a DOM element\n+        testCreatePath(context, \"/vendor[1]/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePath(context, \"/vendor[1]/location[3]/address/street\", \"\",\n+                \"/vendor[1]/location[3]/address[1]/street[1]\");\n+\n+        // Create a DOM attribute\n+        testCreatePath(context, \"/vendor[1]/location[2]/@manager\", \"\");\n+        testCreatePath(context, \"/vendor[1]/location[1]/@name\", \"local\");\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path, Object value){\n+        testCreatePath(context, path, value, path);\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path,\n+                Object value, String expectedPath){\n+        Pointer ptr = null;\n+        try {\n+            ptr = context.createPath(path);\n+        }\n+        catch(JXPathException ex){\n+            ex.getException().printStackTrace();\n+        }\n+\n+        assertEquals(\"Pointer <\" + path + \">\", expectedPath, ptr.asPath());\n+        assertEquals(\"Created <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+\n+    /**\n+     * Test JXPath.createPathAndSetValue() with various arguments\n+     */\n+    public void testCreatePathAndSetValue(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = createContext();\n+\n+        // Create a XML element\n+        testCreatePathAndSetValue(context, \"vendor/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePathAndSetValue(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n+\n+        // Create an attribute\n+        testCreatePathAndSetValue(context, \"vendor/location[2]/@manager\", \"John Doe\");\n+        testCreatePathAndSetValue(context, \"vendor/location[1]/@manager\", \"John Doe\");\n+\n+        testCreatePathAndSetValue(context, \"vendor/product/name/attribute::price:language\", \"English\");\n+    }\n+\n+    private void testCreatePathAndSetValue(JXPathContext context, String path, Object value){\n+        Pointer ptr = context.createPathAndSetValue(path, value);\n+        assertTrue(\"Pointer <\" + path + \">\", ptr != null);\n+        assertEquals(\"Created <\" + path + \">\", value, context.getValue(path));\n+        assertEquals(\"Pointer value <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+    /**\n+     * Test JXPathContext.removePath() with various arguments\n+     */\n+    public void testRemovePath(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = createContext();\n+\n+        // Remove XML nodes\n+        context.removePath(\"vendor/location[@id = '101']//street/text()\");\n+        assertEquals(\"Remove DOM text\", \"\",\n+                    context.getValue(\"vendor/location[@id = '101']//street\"));\n+\n+        context.removePath(\"vendor/location[@id = '101']//street\");\n+        assertEquals(\"Remove DOM element\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '101']//street)\"));\n+\n+        context.removePath(\"vendor/location[@id = '100']/@name\");\n+        assertEquals(\"Remove DOM attribute\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '100']/@name)\"));\n+    }\n+\n+    public void testID(){\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = createContext();\n+        context.setIdentityManager(new IdentityManager(){\n+            public Pointer getPointerByID(JXPathContext context, String id){\n+                NodePointer ptr = (NodePointer)context.getPointer(\"/\");\n+                ptr = ptr.getValuePointer();        // Unwrap the container\n+                return ptr.getPointerByID(context, id);\n+            }\n+        });\n+        context.setKeyManager(new KeyManager(){\n+            public Pointer getPointerByKey(JXPathContext context,\n+                                            String key, String value){\n+                return NodePointer.newNodePointer(null, \"42\", null);\n+            }\n+        });\n+        assertEquals(\"Test ID\", \"Tangerine Drive\",\n+            context.getValue(\"id(101)//street\"));\n+        assertEquals(\"Test ID Path\", \"id('101')/address[1]/street[1]\",\n+            context.getPointer(\"id(101)//street\").asPath());\n+\n+        context.setLenient(true);\n+        assertEquals(\"Test ID Path Null\", \"id(105)/address/street\",\n+            context.getPointer(\"id(105)/address/street\").asPath());\n+    }\n+\n+    public void testModel() throws Exception {\n+        if (!enabled){\n+            return;\n+        }\n+\n+        DocumentContainer docCtr = createDocumentContainer();\n+        JXPathContext context = createContext();\n+        context.getVariables().declareVariable(\"document\", docCtr.getValue());\n+        context.getVariables().declareVariable(\"container\", docCtr);\n+        testXPaths(context, dom_tests, false);\n+    }\n+\n+    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath) throws Exception{\n+        Exception exception = null;\n+        for  (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                Object actual;\n+                // System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n+                if (xpath_tests[i].path){\n+                    if (ignorePath){\n+                        actual = xpath_tests[i].expected;\n+                    }\n+                    else {\n+                        if (xpath_tests[i].eval){\n+                            Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n+                            List paths = new ArrayList();\n+                            while (it.hasNext()){\n+                                paths.add(((Pointer)it.next()).asPath());\n+                            }\n+                            actual = paths;\n+                        }\n+                        else {\n+                            ctx.setLenient(xpath_tests[i].lenient);\n+                            actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n+                        }\n+                    }\n+                }\n+                else {\n+                    if (xpath_tests[i].eval){\n+                        ArrayList list = new ArrayList();\n+                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n+                        while (it.hasNext()){\n+                            list.add(it.next());\n+                        }\n+                        actual = list;\n+                    }\n+                    else {\n+                        ctx.setLenient(xpath_tests[i].lenient);\n+                        actual = ctx.getValue(xpath_tests[i].xpath);\n+                        ctx.setLenient(false);\n+                    }\n+                }\n+                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\", xpath_tests[i].expected, actual);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+                exception = ex;\n+            }\n+            if (exception != null){\n+                throw exception;\n+            }\n+        }\n+\n+        // Make sure that location paths are properly constructed\n+        for (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n+                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n+                    Pointer test = ctx.getPointer(ptr.asPath());\n+                    assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n+                }\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during pointer test <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    private static class XP {\n+        public String xpath;\n+        public Object expected;\n+        public boolean eval;\n+        public boolean path;\n+        public boolean lenient;\n+\n+        public XP(String xpath,  Object expected, boolean eval, boolean path, boolean lenient){\n+            this.xpath = xpath;\n+            this.expected = expected;\n+            this.eval = eval;\n+            this.path = path;\n+            this.lenient = lenient;\n+        }\n+    }\n+\n+    private static XP test(String xpath, Object expected){\n+        return new XP(xpath, expected, false, false, false);\n+    }\n+\n+    private static XP testLenient(String xpath, Object expected){\n+        return new XP(xpath, expected, false, false, true);\n+    }\n+\n+    private static XP testEval(String xpath, Object expected){\n+        return new XP(xpath, expected, true, false, false);\n+    }\n+\n+    private static XP testPath(String xpath, Object expected){\n+        return new XP(xpath, expected, false, true, true);\n+    }\n+\n+    private static XP testEvalPath(String xpath, Object expected){\n+        return new XP(xpath, expected, true, true, false);\n+    }\n+\n+    private static List list(Object o1){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        return list;\n+    }\n+\n+\n+    static final XP[] dom_tests = new XP[]{\n+        test(\"vendor/location/address/street\", \"Orchard Road\"),\n+        test(\"vendor/location[2]/address/street\", \"Tangerine Drive\"),\n+        test(\"vendor/location/address/city\", \"Fruit Market\"),\n+        test(\"//street\", \"Orchard Road\"),\n+        test(\"local-name(//street/..)\", \"address\"),\n+        test(\"number(vendor/location/employeeCount)\", new Double(10)),\n+        test(\"vendor/location/employeeCount + 1\", new Double(11)),\n+        test(\"vendor/location/employeeCount and true()\", Boolean.TRUE),\n+        test(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\", \"Tangerine Drive\"),\n+        testPath(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\",\n+                \"/vendor[1]/location[2]/address[1]/street[1]\"),\n+        testPath(\"//location[2]/preceding-sibling::location//street\",\n+                \"/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"vendor/location/@id\", \"100\"),\n+        testPath(\"vendor/location/@id\", \"/vendor[1]/location[1]/@id\"),\n+        testEval(\"vendor/location/@id\", list(\"100\", \"101\")),\n+        test(\"vendor/product/price:amount\", \"45.95\"),\n+        test(\"namespace-uri(vendor/product/price:amount)\", \"priceNS\"),\n+        test(\"local-name(vendor/product/price:amount)\", \"amount\"),\n+        test(\"name(vendor/product/price:amount)\", \"priceNS:amount\"),\n+        test(\"vendor/product/prix\", \"934.99\"),\n+        test(\"vendor/product/prix/namespace::price\", \"priceNS\"),\n+        testPath(\"vendor/product/prix/namespace::price\", \"/vendor[1]/product[1]/prix[1]/namespace::price\"),\n+        test(\"count(vendor/product/namespace::*)\", new Double(3)),\n+        test(\"name(vendor/product/prix/namespace::price)\", \"priceNS:price\"),\n+        test(\"local-name(vendor/product/prix/namespace::price)\", \"price\"),\n+        test(\"vendor/product/price:amount/@price:discount\", \"10%\"),\n+        test(\"vendor/product/value:amount/@value:discount\", \"10%\"),\n+        test(\"namespace-uri(vendor/product/price:amount/@price:discount)\", \"priceNS\"),\n+        test(\"local-name(vendor/product/price:amount/@price:discount)\", \"discount\"),\n+        test(\"name(vendor/product/price:amount/@price:discount)\", \"priceNS:discount\"),\n+        test(\"vendor/product/price:amount/@discount\", \"20%\"),\n+        test(\"namespace-uri(vendor/product/price:amount/@discount)\", \"\"),\n+        test(\"local-name(vendor/product/price:amount/@discount)\", \"discount\"),\n+        test(\"name(vendor/product/price:amount/@discount)\", \"discount\"),\n+        test(\"vendor/product/price:sale/saleEnds/ancestor::price:sale/saleEnds\", \"never\"),\n+        test(\"vendor/product/price:sale/ancestor-or-self::price:sale/saleEnds\", \"never\"),\n+        test(\"vendor/product/price:sale/saleEnds/ancestor::price:*\" + \"/saleEnds\", \"never\"),\n+        test(\"count(vendor/product/price:*)\", new Double(2)),\n+        test(\"count(vendor/product/value:*)\", new Double(2)),\n+        test(\"count(vendor/product/*)\", new Double(2)),\n+        testEval(\"vendor/product/price:amount/@price:*\", list(\"10%\")),\n+        testEval(\"vendor/product/price:amount/@*\", list(\"20%\")),\n+        test(\"count(//price:*)\", new Double(2)),\n+        test(\"vendor/product/price:sale/saleEnds/parent::price:*\" + \"/saleEnds\", \"never\"),\n+        test(\"//location/following::price:sale/saleEnds\", \"never\"),\n+        test(\"//price:sale/self::price:sale/saleEnds\", \"never\"),\n+        testLenient(\"//price:sale/self::x/saleEnds\", null),\n+\n+        test(\"//product/comment()\", \"We are not buying this product, ever\"),\n+        test(\"//product/text()[. != '']\", \"We love this product.\"),\n+        testPath(\"//product/text()\", \"/vendor[1]/product[1]/text()[1]\"),\n+        test(\"//product/processing-instruction()\", \"do not show anybody\"),\n+        test(\"//product/processing-instruction('report')\", \"average only\"),\n+        testPath(\"//product/processing-instruction('report')\",\n+            \"/vendor[1]/product[1]/processing-instruction('report')[1]\"),\n+        test(\"name(//product/processing-instruction()[1])\", \"security\"),\n+\n+        test(\"//product/prix/@xml:lang\", \"fr\"),\n+        test(\"//product/prix[lang('fr')]\", \"934.99\"),\n+        test(\"//product/price:sale[lang('en')]/saleEnds\", \"never\"),\n+        test(\"vendor/location/@manager\", \"\"),\n+        testLenient(\"vendor/location/@missing\", null),\n+        test(\"count(vendor/location[1]/@*)\", new Double(3)),\n+        test(\"vendor/location[@id='101']//street\", \"Tangerine Drive\"),\n+\n+        test(\"$document/vendor/location[1]//street\", \"Orchard Road\"),\n+        testPath(\"$document/vendor/location[1]//street\",\n+            \"$document/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"$document/vendor//street\", \"Orchard Road\"),\n+        test(\"$container/vendor//street\", \"Orchard Road\"),\n+        test(\"$container//street\", \"Orchard Road\"),\n+        testPath(\"$container//street\", \"$container/vendor[1]/location[1]/address[1]/street[1]\"),\n+\n+        testEval(\"vendor/contact/following::location//street\",\n+            list(\"Orchard Road\", \"Tangerine Drive\")),\n+   };\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.1 2002/08/26 22:33:10 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:33:10 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.2 2002/10/13 03:01:03 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/10/13 03:01:03 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.w3c.dom.*;\n import java.util.*;\n import java.lang.reflect.*;\n-import org.apache.commons.jxpath.ri.model.XMLModelTest;\n+import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.util.*;\n import org.apache.commons.jxpath.ri.*;\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:33:10 $\n+ * @version $Revision: 1.2 $ $Date: 2002/10/13 03:01:03 $\n  */\n \n-public class DOMModelTest extends XMLModelTest\n+public class DOMModelTest extends XMLModelTestCase\n {\n     /**\n      * Exercises this test case only\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.1 2002/08/26 22:33:10 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:33:10 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.2 2002/10/13 03:01:03 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/10/13 03:01:03 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.w3c.dom.*;\n import java.util.*;\n import java.lang.reflect.*;\n-import org.apache.commons.jxpath.ri.model.XMLModelTest;\n+import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.util.*;\n import org.apache.commons.jxpath.ri.*;\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:33:10 $\n+ * @version $Revision: 1.2 $ $Date: 2002/10/13 03:01:03 $\n  */\n \n-public class JDOMModelTest extends XMLModelTest\n+public class JDOMModelTest extends XMLModelTestCase\n {\n     /**\n      * Exercises this test case only", "timestamp": 1034478063, "metainfo": ""}