{"sha": "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac", "log": "Made type converter configurable   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.1 2002/06/12 21:02:05 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/06/12 21:02:05 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.Pointer;\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ * The default delegate of JXPathContext that is used for type conversion.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/06/12 21:02:05 $\n+ */\n+public class BasicTypeConverter implements TypeConverter {\n+\n+    /**\n+     * Returns true if it can convert the supplied\n+     * object to the specified class.\n+     */\n+    public boolean canConvert(Object object, Class toType){\n+        if (object == null){\n+            return true;\n+        }\n+\n+        if (toType == Object.class){\n+            return true;\n+        }\n+\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType)){\n+            return true;\n+        }\n+\n+        if (toType.isAssignableFrom(fromType)){\n+            return true;\n+        }\n+\n+        if (toType == String.class){\n+            return true;\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Number){\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType.isPrimitive()){\n+                return true;\n+            }\n+            if (toType == Boolean.class ||\n+                    toType == Character.class ||\n+                    toType == Byte.class ||\n+                    toType == Short.class ||\n+                    toType == Integer.class ||\n+                    toType == Long.class ||\n+                    toType == Float.class ||\n+                    toType == Double.class){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+            Pointer pointer = ((ExpressionContext)object).getContextNodePointer();\n+            if (pointer != null){\n+                Object value = pointer.getValue();\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (fromType.isArray()){\n+            // Collection -> array\n+            if (toType.isArray()){\n+                Class cType = toType.getComponentType();\n+                int length = Array.getLength(object);\n+                for (int i = 0; i < length; i++){\n+                    Object value = Array.get(object, i);\n+                    if (!canConvert(value, cType)){\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+            else if (Collection.class.isAssignableFrom(toType)){\n+                return canCreateCollection(toType);\n+            }\n+            else if (Array.getLength(object) == 1){\n+                Object value = Array.get(object, 0);\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (object instanceof Collection){\n+            // Collection -> array\n+            if (toType.isArray()){\n+                Class cType = toType.getComponentType();\n+                Iterator it = ((Collection)object).iterator();\n+                while (it.hasNext()){\n+                    Object value = it.next();\n+                    if (!canConvert(value, cType)){\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+            else if (Collection.class.isAssignableFrom(toType)){\n+                return canCreateCollection(toType);\n+            }\n+            else if (((Collection)object).size() == 1){\n+                Object value;\n+                if (object instanceof List){\n+                    value = ((List)object).get(0);\n+                }\n+                else {\n+                    Iterator it = ((Collection)object).iterator();\n+                    value = it.next();\n+                }\n+                return canConvert(value, toType);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Converts the supplied object to the specified\n+     * type. Throws a runtime exception if the conversion is\n+     * not possible.\n+     */\n+    public Object convert(Object object, Class toType){\n+        if (object == null){\n+            if (toType.isPrimitive()){\n+                if (toType == boolean.class){\n+                    return Boolean.FALSE;\n+                }\n+                if (toType == char.class){\n+                    return new Character('\\0');\n+                }\n+                if (toType == byte.class){\n+                    return new Byte((byte)0);\n+                }\n+                if (toType == short.class){\n+                    return new Short((short)0);\n+                }\n+                if (toType == int.class){\n+                    return new Integer(0);\n+                }\n+                if (toType == long.class){\n+                    return new Long(0l);\n+                }\n+                if (toType == float.class){\n+                    return new Float(0.0f);\n+                }\n+                if (toType == double.class){\n+                    return new Double(0.0);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        if (toType == Object.class){\n+            return object;\n+        }\n+\n+        if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                List list = ((ExpressionContext)object).getContextNodeList();\n+                Collection result = new ArrayList();\n+                if (toType == List.class || toType == ArrayList.class){\n+                    result = new ArrayList();\n+                }\n+                else if (toType == Vector.class){\n+                    result = new Vector();\n+                }\n+                else if (toType == Set.class || toType == HashSet.class){\n+                    result = new HashSet();\n+                }\n+                int count = list.size();\n+                for (int i = 0; i < count; i++){\n+                    Pointer ptr = (Pointer)list.get(i);\n+                    result.add(ptr.getValue());\n+                }\n+                return result;\n+            }\n+            else {\n+                Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n+                return convert(value, toType);\n+            }\n+        }\n+\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)){\n+            return object;\n+        }\n+\n+        if (toType == String.class){\n+            return object.toString();\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class){\n+                return object;\n+            }\n+            boolean value = ((Boolean)object).booleanValue();\n+            return allocateNumber(toType, value ? 1 : 0);\n+        }\n+        else if (object instanceof Number){\n+            double value = ((Number)object).doubleValue();\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n+            }\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return allocateNumber(toType, value);\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return object;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return Boolean.valueOf((String)object);\n+            }\n+            if (toType == char.class || toType == Character.class){\n+                return new Character(((String)object).charAt(0));\n+            }\n+            if (toType == byte.class || toType == Byte.class){\n+                return new Byte((String)object);\n+            }\n+            if (toType == short.class || toType == Short.class){\n+                return new Short((String)object);\n+            }\n+            if (toType == int.class || toType == Integer.class){\n+                return new Integer((String)object);\n+            }\n+            if (toType == long.class || toType == Long.class){\n+                return new Long((String)object);\n+            }\n+            if (toType == float.class || toType == Float.class){\n+                return new Float((String)object);\n+            }\n+            if (toType == double.class || toType == Double.class){\n+                return new Double((String)object);\n+            }\n+        }\n+        else if (fromType.isArray()){\n+            int length = Array.getLength(object);\n+            if (toType.isArray()){\n+                Class cType = toType.getComponentType();\n+\n+                Object array = Array.newInstance(cType, length);\n+                for (int i = 0; i < length; i++){\n+                    Object value = Array.get(object, i);\n+                    Array.set(array, i, convert(value, cType));\n+                }\n+                return array;\n+            }\n+            else if (Collection.class.isAssignableFrom(toType)){\n+                Collection collection = allocateCollection(toType);\n+                for (int i = 0; i < length; i++){\n+                    collection.add(Array.get(object, i));\n+                }\n+                return collection;\n+            }\n+            else if (length == 1){\n+                Object value = Array.get(object, 0);\n+                return convert(value, toType);\n+            }\n+        }\n+        else if (object instanceof Collection){\n+            int length = ((Collection) object).size();\n+            if (toType.isArray()){\n+                Class cType = toType.getComponentType();\n+                Object array = Array.newInstance(cType, length);\n+                Iterator it = ((Collection) object).iterator();\n+                for (int i = 0; i < length; i++){\n+                    Object value = it.next();\n+                    Array.set(array, i, convert(value, cType));\n+                }\n+                return array;\n+            }\n+            else if (Collection.class.isAssignableFrom(toType)){\n+                Collection collection = allocateCollection(toType);\n+                collection.addAll((Collection) object);\n+                return collection;\n+            }\n+            else if (length == 1){\n+                Object value;\n+                if (object instanceof List){\n+                    value = ((List)object).get(0);\n+                }\n+                else {\n+                    Iterator it = ((Collection)object).iterator();\n+                    value = it.next();\n+                }\n+                return convert(value, toType);\n+            }\n+        }\n+        throw new RuntimeException(\"Cannot convert \" + object.getClass() +\n+                \" to \" + toType);\n+    }\n+\n+    private static Number allocateNumber(Class type, double value){\n+        if (type == Byte.class || type == byte.class){\n+            return new Byte((byte)value);\n+        }\n+        if (type == Short.class || type == short.class){\n+            return new Short((short)value);\n+        }\n+        if (type == Integer.class || type == int.class){\n+            return new Integer((int)value);\n+        }\n+        if (type == Long.class || type == long.class){\n+            return new Long((long)value);\n+        }\n+        if (type == Float.class || type == float.class){\n+            return new Float((float)value);\n+        }\n+        if (type == Double.class || type == double.class){\n+            return new Double(value);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean canCreateCollection(Class type){\n+        if (!type.isInterface() && ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n+            return true;\n+        }\n+\n+        if (type == List.class){\n+            return true;\n+        }\n+\n+        if (type == Set.class){\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static Collection allocateCollection(Class type){\n+        if (!type.isInterface() &&\n+                ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n+            try {\n+                return (Collection)type.newInstance();\n+            }\n+            catch(Exception ex){\n+                throw new JXPathException(\"Cannot create collection of type: \"\n+                        + type, ex);\n+            }\n+        }\n+\n+        if (type == List.class){\n+            return new ArrayList();\n+        }\n+        if (type == Set.class){\n+            return new HashSet();\n+        }\n+        throw new RuntimeException(\"Cannot create collection of type: \" + type);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java,v 1.1 2002/06/12 21:02:05 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/06/12 21:02:05 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.Pointer;\n+\n+/**\n+ * Method lookup utilities, which find static and non-static methods as well\n+ * as constructors based on a name and list of parameters.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/06/12 21:02:05 $\n+ */\n+public class MethodLookupUtils {\n+\n+    private static final int NO_MATCH = 0;\n+    private static final int APPROXIMATE_MATCH = 1;\n+    private static final int EXACT_MATCH = 2;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Constructor constructor = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                constructor = targetClass.getConstructor(types);\n+                if (constructor != null){\n+                    return constructor;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Constructor[] constructors = targetClass.getConstructors();\n+        for (int i = 0; i < constructors.length; i++){\n+            int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters);\n+            if (match != NO_MATCH){\n+                if (match > currentMatch){\n+                    constructor = constructors[i];\n+                    currentMatch = match;\n+                    ambiguous = false;\n+                }\n+                else if (match == currentMatch){\n+                    ambiguous = true;\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new JXPathException(\"Ambigous constructor \" + Arrays.asList(parameters));\n+        }\n+        return constructor;\n+    }\n+\n+    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = matchParameterTypes(methods[i].getParameterTypes(), parameters);\n+                if (match != NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new JXPathException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+    }\n+\n+    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n+        if (parameters.length < 1 || parameters[0] == null){\n+            return null;\n+        }\n+\n+        if (matchType(targetClass, parameters[0]) == NO_MATCH){\n+            return null;\n+        }\n+\n+        targetClass = TypeUtils.convert(parameters[0], targetClass).getClass();\n+\n+        boolean tryExact = true;\n+        int count = parameters.length - 1;\n+        Class types[] = new Class[count];\n+        Object arguments[] = new Object[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i+1];\n+            arguments[i] = param;\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && !Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (!Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = matchParameterTypes(methods[i].getParameterTypes(), arguments);\n+                if (match != NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new JXPathException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+    }\n+\n+    private static int matchParameterTypes(Class types[], Object parameters[]){\n+        int pi = 0;\n+        if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+            pi++;\n+        }\n+        if (types.length != parameters.length + pi){\n+            return NO_MATCH;\n+        }\n+        int totalMatch = EXACT_MATCH;\n+        for (int i = 0; i < parameters.length; i++){\n+            int match = matchType(types[i + pi], parameters[i]);\n+            if (match == NO_MATCH){\n+                return NO_MATCH;\n+            }\n+            if (match < totalMatch){\n+                totalMatch = match;\n+            }\n+        }\n+        return totalMatch;\n+    }\n+\n+    private static int matchType(Class expected, Object object){\n+        if (object == null){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        Class actual = object.getClass();\n+\n+        if (expected.equals(actual)){\n+            return EXACT_MATCH;\n+        }\n+        if (expected.isAssignableFrom(actual)){\n+            return EXACT_MATCH;\n+        }\n+\n+        if (TypeUtils.canConvert(object, expected)){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        return NO_MATCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/TypeConverter.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeConverter.java,v 1.1 2002/06/12 21:02:05 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/06/12 21:02:05 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+/**\n+ * A type converter can be installed on TypeUtils to introduce\n+ * additional type conversions for JXPath. Most of\n+ * the time BasicTypeConverter should be used as the superclass.\n+ *\n+ * @see TypeUtils#setTypeConverter\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/06/12 21:02:05 $\n+ */\n+public interface TypeConverter {\n+\n+    /**\n+     * Returns true if it can convert the supplied\n+     * object to the specified class.\n+     */\n+    boolean canConvert(Object object, Class toType);\n+\n+    /**\n+     * Converts the supplied object to the specified\n+     * type. Throws a runtime exception if the conversion is\n+     * not possible.\n+     */\n+    Object convert(Object object, Class toType);\n+}\n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.6 2002/05/08 23:03:43 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/05/08 23:03:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.7 2002/06/12 21:02:05 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/06/12 21:02:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Pointer;\n \n /**\n+ * Global type conversion utilities.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/05/08 23:03:43 $\n+ * @version $Revision: 1.7 $ $Date: 2002/06/12 21:02:05 $\n  */\n public class TypeUtils {\n+    private static TypeConverter typeConverter = new BasicTypeConverter();\n \n-    private static final int NO_MATCH = 0;\n-    private static final int APPROXIMATE_MATCH = 1;\n-    private static final int EXACT_MATCH = 2;\n-    private static final Object[] EMPTY_ARRAY = new Object[0];\n-\n-    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n-        boolean tryExact = true;\n-        int count = parameters.length;\n-        Class types[] = new Class[count];\n-        for (int i = 0; i < count; i++){\n-            Object param = parameters[i];\n-            if (param != null){\n-                types[i] = param.getClass();\n-            }\n-            else {\n-                types[i] = null;\n-                tryExact = false;\n-            }\n-        }\n-\n-        Constructor constructor = null;\n-\n-        if (tryExact){\n-            // First - without type conversion\n-            try {\n-                constructor = targetClass.getConstructor(types);\n-                if (constructor != null){\n-                    return constructor;\n-                }\n-            }\n-            catch (NoSuchMethodException ex){\n-            }\n-        }\n-\n-        int currentMatch = 0;\n-        boolean ambiguous = false;\n-\n-        // Then - with type conversion\n-        Constructor[] constructors = targetClass.getConstructors();\n-        for (int i = 0; i < constructors.length; i++){\n-            int match = TypeUtils.matchParameterTypes(constructors[i].getParameterTypes(), parameters);\n-            if (match != TypeUtils.NO_MATCH){\n-                if (match > currentMatch){\n-                    constructor = constructors[i];\n-                    currentMatch = match;\n-                    ambiguous = false;\n-                }\n-                else if (match == currentMatch){\n-                    ambiguous = true;\n-                }\n-            }\n-        }\n-        if (ambiguous){\n-            throw new JXPathException(\"Ambigous constructor \" + Arrays.asList(parameters));\n-        }\n-        return constructor;\n+    /**\n+     * Install an alternative type converter.\n+     */\n+    public static synchronized void setTypeConverter(TypeConverter converter){\n+        typeConverter = converter;\n     }\n \n-    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n-        boolean tryExact = true;\n-        int count = parameters.length;\n-        Class types[] = new Class[count];\n-        for (int i = 0; i < count; i++){\n-            Object param = parameters[i];\n-            if (param != null){\n-                types[i] = param.getClass();\n-            }\n-            else {\n-                types[i] = null;\n-                tryExact = false;\n-            }\n-        }\n-\n-        Method method = null;\n-\n-        if (tryExact){\n-            // First - without type conversion\n-            try {\n-                method = targetClass.getMethod(name, types);\n-                if (method != null && Modifier.isStatic(method.getModifiers())){\n-                    return method;\n-                }\n-            }\n-            catch (NoSuchMethodException ex){\n-            }\n-        }\n-\n-        int currentMatch = 0;\n-        boolean ambiguous = false;\n-\n-        // Then - with type conversion\n-        Method[] methods = targetClass.getMethods();\n-        for (int i = 0; i < methods.length; i++){\n-            if (Modifier.isStatic(methods[i].getModifiers()) &&\n-                    methods[i].getName().equals(name)){\n-                int match = TypeUtils.matchParameterTypes(methods[i].getParameterTypes(), parameters);\n-                if (match != TypeUtils.NO_MATCH){\n-                    if (match > currentMatch){\n-                        method = methods[i];\n-                        currentMatch = match;\n-                        ambiguous = false;\n-                    }\n-                    else if (match == currentMatch){\n-                        ambiguous = true;\n-                    }\n-                }\n-            }\n-        }\n-        if (ambiguous){\n-            throw new JXPathException(\"Ambigous method call: \" + name);\n-        }\n-        return method;\n+    /**\n+     * Returns the current type converter.\n+     */\n+    public static TypeConverter getTypeConverter(){\n+        return typeConverter;\n     }\n \n-    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n-        if (parameters.length < 1 || parameters[0] == null){\n-            return null;\n-        }\n-\n-        if (TypeUtils.matchType(targetClass, parameters[0]) == TypeUtils.NO_MATCH){\n-            return null;\n-        }\n-\n-        targetClass = convert(parameters[0], targetClass).getClass();\n-\n-        boolean tryExact = true;\n-        int count = parameters.length - 1;\n-        Class types[] = new Class[count];\n-        Object arguments[] = new Object[count];\n-        for (int i = 0; i < count; i++){\n-            Object param = parameters[i+1];\n-            arguments[i] = param;\n-            if (param != null){\n-                types[i] = param.getClass();\n-            }\n-            else {\n-                types[i] = null;\n-                tryExact = false;\n-            }\n-        }\n-\n-        Method method = null;\n-\n-        if (tryExact){\n-            // First - without type conversion\n-            try {\n-                method = targetClass.getMethod(name, types);\n-                if (method != null && !Modifier.isStatic(method.getModifiers())){\n-                    return method;\n-                }\n-            }\n-            catch (NoSuchMethodException ex){\n-            }\n-        }\n-\n-        int currentMatch = 0;\n-        boolean ambiguous = false;\n-\n-        // Then - with type conversion\n-        Method[] methods = targetClass.getMethods();\n-        for (int i = 0; i < methods.length; i++){\n-            if (!Modifier.isStatic(methods[i].getModifiers()) &&\n-                    methods[i].getName().equals(name)){\n-                int match = TypeUtils.matchParameterTypes(methods[i].getParameterTypes(), arguments);\n-                if (match != TypeUtils.NO_MATCH){\n-                    if (match > currentMatch){\n-                        method = methods[i];\n-                        currentMatch = match;\n-                        ambiguous = false;\n-                    }\n-                    else if (match == currentMatch){\n-                        ambiguous = true;\n-                    }\n-                }\n-            }\n-        }\n-        if (ambiguous){\n-            throw new JXPathException(\"Ambigous method call: \" + name);\n-        }\n-        return method;\n+    /**\n+     * @deprecated Use MethodLookupUtils\n+     */\n+    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n+        return MethodLookupUtils.lookupConstructor(targetClass, parameters);\n     }\n \n-    public static int matchParameterTypes(Class types[], Object parameters[]){\n-        int pi = 0;\n-        if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n-            pi++;\n-        }\n-        if (types.length != parameters.length + pi){\n-            return NO_MATCH;\n-        }\n-        int totalMatch = EXACT_MATCH;\n-        for (int i = 0; i < parameters.length; i++){\n-            int match = matchType(types[i + pi], parameters[i]);\n-            if (match == NO_MATCH){\n-                return NO_MATCH;\n-            }\n-            if (match < totalMatch){\n-                totalMatch = match;\n-            }\n-        }\n-        return totalMatch;\n+    /**\n+     * @deprecated Use MethodLookupUtils\n+     */\n+    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n+        return MethodLookupUtils.lookupStaticMethod(targetClass, name, parameters);\n     }\n \n-    public static int matchType(Class expected, Object object){\n-        if (object == null){\n-            return APPROXIMATE_MATCH;\n-        }\n-\n-        Class actual = object.getClass();\n-\n-        if (expected.equals(actual)){\n-            return EXACT_MATCH;\n-        }\n-        if (expected.isAssignableFrom(actual)){\n-            return EXACT_MATCH;\n-        }\n-\n-        if (canConvert(object, expected)){\n-            return APPROXIMATE_MATCH;\n-        }\n-\n-        return NO_MATCH;\n+    /**\n+     * @deprecated Use MethodLookupUtils\n+     */\n+    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n+        return MethodLookupUtils.lookupMethod(targetClass, name, parameters);\n     }\n \n     public static boolean canConvert(Object object, Class toType){\n-        if (object == null){\n-            return true;\n-        }\n-\n-        if (toType == Object.class){\n-            return true;\n-        }\n-\n-        Class fromType = object.getClass();\n-        if (fromType.equals(toType)){\n-            return true;\n-        }\n-\n-        if (toType.isAssignableFrom(fromType)){\n-            return true;\n-        }\n-\n-        if (toType == String.class){\n-            return true;\n-        }\n-\n-        if (object instanceof Boolean){\n-            if (toType == boolean.class ||\n-                    Number.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof Number){\n-            if (toType.isPrimitive() ||\n-                    Number.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof Character){\n-            if (toType == char.class){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof String){\n-            if (toType.isPrimitive()){\n-                return true;\n-            }\n-            if (toType == Boolean.class ||\n-                    toType == Character.class ||\n-                    toType == Byte.class ||\n-                    toType == Short.class ||\n-                    toType == Integer.class ||\n-                    toType == Long.class ||\n-                    toType == Float.class ||\n-                    toType == Double.class){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof ExpressionContext){\n-            if (Collection.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-            Pointer pointer = ((ExpressionContext)object).getContextNodePointer();\n-            if (pointer != null){\n-                Object value = pointer.getValue();\n-                return canConvert(value, toType);\n-            }\n-        }\n-        else if (fromType.isArray()){\n-            // Collection -> array\n-            if (toType.isArray()){\n-                Class cType = toType.getComponentType();\n-                int length = Array.getLength(object);\n-                for (int i = 0; i < length; i++){\n-                    Object value = Array.get(object, i);\n-                    if (!canConvert(value, cType)){\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-            else if (Collection.class.isAssignableFrom(toType)){\n-                return canCreateCollection(toType);\n-            }\n-            else if (Array.getLength(object) == 1){\n-                Object value = Array.get(object, 0);\n-                return canConvert(value, toType);\n-            }\n-        }\n-        else if (object instanceof Collection){\n-            // Collection -> array\n-            if (toType.isArray()){\n-                Class cType = toType.getComponentType();\n-                Iterator it = ((Collection)object).iterator();\n-                while (it.hasNext()){\n-                    Object value = it.next();\n-                    if (!canConvert(value, cType)){\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-            else if (Collection.class.isAssignableFrom(toType)){\n-                return canCreateCollection(toType);\n-            }\n-            else if (((Collection)object).size() == 1){\n-                Object value;\n-                if (object instanceof List){\n-                    value = ((List)object).get(0);\n-                }\n-                else {\n-                    Iterator it = ((Collection)object).iterator();\n-                    value = it.next();\n-                }\n-                return canConvert(value, toType);\n-            }\n-        }\n-\n-        // TBD: date conversion to/from string\n-        return false;\n+        return typeConverter.canConvert(object, toType);\n     }\n \n     public static Object convert(Object object, Class toType){\n-        if (object == null){\n-            if (toType.isPrimitive()){\n-                if (toType == boolean.class){\n-                    return Boolean.FALSE;\n-                }\n-                if (toType == char.class){\n-                    return new Character('\\0');\n-                }\n-                if (toType == byte.class){\n-                    return new Byte((byte)0);\n-                }\n-                if (toType == short.class){\n-                    return new Short((short)0);\n-                }\n-                if (toType == int.class){\n-                    return new Integer(0);\n-                }\n-                if (toType == long.class){\n-                    return new Long(0l);\n-                }\n-                if (toType == float.class){\n-                    return new Float(0.0f);\n-                }\n-                if (toType == double.class){\n-                    return new Double(0.0);\n-                }\n-            }\n-            return null;\n-        }\n-\n-        if (toType == Object.class){\n-            return object;\n-        }\n-\n-        if (object instanceof ExpressionContext){\n-            if (Collection.class.isAssignableFrom(toType)){\n-                List list = ((ExpressionContext)object).getContextNodeList();\n-                Collection result = new ArrayList();\n-                if (toType == List.class || toType == ArrayList.class){\n-                    result = new ArrayList();\n-                }\n-                else if (toType == Vector.class){\n-                    result = new Vector();\n-                }\n-                else if (toType == Set.class || toType == HashSet.class){\n-                    result = new HashSet();\n-                }\n-                int count = list.size();\n-                for (int i = 0; i < count; i++){\n-                    Pointer ptr = (Pointer)list.get(i);\n-                    result.add(ptr.getValue());\n-                }\n-                return result;\n-            }\n-            else {\n-                Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n-                return convert(value, toType);\n-            }\n-        }\n-\n-        Class fromType = object.getClass();\n-        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)){\n-            return object;\n-        }\n-\n-        if (toType == String.class){\n-            return object.toString();\n-        }\n-\n-        if (object instanceof Boolean){\n-            if (toType == boolean.class){\n-                return object;\n-            }\n-            boolean value = ((Boolean)object).booleanValue();\n-            return allocateNumber(toType, value ? 1 : 0);\n-        }\n-        else if (object instanceof Number){\n-            double value = ((Number)object).doubleValue();\n-            if (toType == boolean.class || toType == Boolean.class){\n-                return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n-            }\n-            if (toType.isPrimitive() ||\n-                    Number.class.isAssignableFrom(toType)){\n-                return allocateNumber(toType, value);\n-            }\n-        }\n-        else if (object instanceof Character){\n-            if (toType == char.class){\n-                return object;\n-            }\n-        }\n-        else if (object instanceof String){\n-            if (toType == boolean.class || toType == Boolean.class){\n-                return Boolean.valueOf((String)object);\n-            }\n-            if (toType == char.class || toType == Character.class){\n-                return new Character(((String)object).charAt(0));\n-            }\n-            if (toType == byte.class || toType == Byte.class){\n-                return new Byte((String)object);\n-            }\n-            if (toType == short.class || toType == Short.class){\n-                return new Short((String)object);\n-            }\n-            if (toType == int.class || toType == Integer.class){\n-                return new Integer((String)object);\n-            }\n-            if (toType == long.class || toType == Long.class){\n-                return new Long((String)object);\n-            }\n-            if (toType == float.class || toType == Float.class){\n-                return new Float((String)object);\n-            }\n-            if (toType == double.class || toType == Double.class){\n-                return new Double((String)object);\n-            }\n-        }\n-        else if (fromType.isArray()){\n-            int length = Array.getLength(object);\n-            if (toType.isArray()){\n-                Class cType = toType.getComponentType();\n-\n-                Object array = Array.newInstance(cType, length);\n-                for (int i = 0; i < length; i++){\n-                    Object value = Array.get(object, i);\n-                    Array.set(array, i, convert(value, cType));\n-                }\n-                return array;\n-            }\n-            else if (Collection.class.isAssignableFrom(toType)){\n-                Collection collection = allocateCollection(toType);\n-                for (int i = 0; i < length; i++){\n-                    collection.add(Array.get(object, i));\n-                }\n-                return collection;\n-            }\n-            else if (length == 1){\n-                Object value = Array.get(object, 0);\n-                return convert(value, toType);\n-            }\n-        }\n-        else if (object instanceof Collection){\n-            int length = ((Collection) object).size();\n-            if (toType.isArray()){\n-                Class cType = toType.getComponentType();\n-                Object array = Array.newInstance(cType, length);\n-                Iterator it = ((Collection) object).iterator();\n-                for (int i = 0; i < length; i++){\n-                    Object value = it.next();\n-                    Array.set(array, i, convert(value, cType));\n-                }\n-                return array;\n-            }\n-            else if (Collection.class.isAssignableFrom(toType)){\n-                Collection collection = allocateCollection(toType);\n-                collection.addAll((Collection) object);\n-                return collection;\n-            }\n-            else if (length == 1){\n-                Object value;\n-                if (object instanceof List){\n-                    value = ((List)object).get(0);\n-                }\n-                else {\n-                    Iterator it = ((Collection)object).iterator();\n-                    value = it.next();\n-                }\n-                return convert(value, toType);\n-            }\n-        }\n-        throw new RuntimeException(\"Cannot convert \" + object.getClass() +\n-                \" to \" + toType);\n-    }\n-\n-    private static Number allocateNumber(Class type, double value){\n-        if (type == Byte.class || type == byte.class){\n-            return new Byte((byte)value);\n-        }\n-        if (type == Short.class || type == short.class){\n-            return new Short((short)value);\n-        }\n-        if (type == Integer.class || type == int.class){\n-            return new Integer((int)value);\n-        }\n-        if (type == Long.class || type == long.class){\n-            return new Long((long)value);\n-        }\n-        if (type == Float.class || type == float.class){\n-            return new Float((float)value);\n-        }\n-        if (type == Double.class || type == double.class){\n-            return new Double(value);\n-        }\n-        return null;\n-    }\n-\n-    private static boolean canCreateCollection(Class type){\n-        if (!type.isInterface() && ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n-            return true;\n-        }\n-\n-        if (type == List.class){\n-            return true;\n-        }\n-\n-        if (type == Set.class){\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Collection allocateCollection(Class type){\n-        if (!type.isInterface() &&\n-                ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n-            try {\n-                return (Collection)type.newInstance();\n-            }\n-            catch(Exception ex){\n-                throw new JXPathException(\"Cannot create collection of type: \"\n-                        + type, ex);\n-            }\n-        }\n-\n-        if (type == List.class){\n-            return new ArrayList();\n-        }\n-        if (type == Set.class){\n-            return new HashSet();\n-        }\n-        throw new RuntimeException(\"Cannot create collection of type: \" + type);\n+        return typeConverter.convert(object, toType);\n     }\n }", "timestamp": 1023915725, "metainfo": ""}