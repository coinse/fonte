{"sha": "70ab293fdef89769c64d994f901fb4167e0959a4", "log": "[MATH-891] SpearmansCorrelation now works correctly when provided with a NaturalRanking with NaNStrategy.REMOVED.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n \n package org.apache.commons.math3.stat.correlation;\n \n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.ranking.NaNStrategy;\n import org.apache.commons.math3.stat.ranking.NaturalRanking;\n import org.apache.commons.math3.stat.ranking.RankingAlgorithm;\n \n /**\n- * <p>Spearman's rank correlation. This implementation performs a rank\n+ * Spearman's rank correlation. This implementation performs a rank\n  * transformation on the input data and then computes {@link PearsonsCorrelation}\n- * on the ranked data.</p>\n- *\n- * <p>By default, ranks are computed using {@link NaturalRanking} with default\n+ * on the ranked data.\n+ * <p>\n+ * By default, ranks are computed using {@link NaturalRanking} with default\n  * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n- * The ranking algorithm can be set using a constructor argument.</p>\n+ * The ranking algorithm can be set using a constructor argument.\n  *\n  * @since 2.0\n  * @version $Id$\n  */\n-\n public class SpearmansCorrelation {\n \n     /** Input data */\n \n     /**\n      * Create a SpearmansCorrelation with the given ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param rankingAlgorithm ranking algorithm\n      * @since 3.1\n     /**\n      * Create a SpearmansCorrelation with the given input data matrix\n      * and ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      * @param rankingAlgorithm ranking algorithm\n      */\n     public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n-        this.data = dataMatrix.copy();\n         this.rankingAlgorithm = rankingAlgorithm;\n-        rankTransform(data);\n+        this.data = rankTransform(dataMatrix);\n         rankCorrelation = new PearsonsCorrelation(data);\n     }\n \n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n-        RealMatrix matrixCopy = matrix.copy();\n-        rankTransform(matrixCopy);\n+    public RealMatrix computeCorrelationMatrix(final RealMatrix matrix) {\n+        final RealMatrix matrixCopy = rankTransform(matrix);\n         return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n     }\n \n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n+    public RealMatrix computeCorrelationMatrix(final double[][] matrix) {\n        return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n \n             throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                                    xArray.length, 2);\n         } else {\n-            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n-                    rankingAlgorithm.rank(yArray));\n+            double[] x = xArray;\n+            double[] y = yArray;\n+            if (rankingAlgorithm instanceof NaturalRanking &&\n+                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n+                final Set<Integer> nanPositions = new HashSet<Integer>();\n+\n+                nanPositions.addAll(getNaNPositions(xArray));\n+                nanPositions.addAll(getNaNPositions(yArray));\n+\n+                x = removeValues(xArray, nanPositions);\n+                y = removeValues(yArray, nanPositions);\n+            }\n+            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n         }\n     }\n \n     /**\n      * Applies rank transform to each of the columns of <code>matrix</code>\n-     * using the current <code>rankingAlgorithm</code>\n+     * using the current <code>rankingAlgorithm</code>.\n      *\n      * @param matrix matrix to transform\n-     */\n-    private void rankTransform(RealMatrix matrix) {\n-        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n-            matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\n-        }\n+     * @return a rank-transformed matrix\n+     */\n+    private RealMatrix rankTransform(final RealMatrix matrix) {\n+        RealMatrix transformed = null;\n+\n+        if (rankingAlgorithm instanceof NaturalRanking &&\n+                ((NaturalRanking) rankingAlgorithm).getNanStrategy() == NaNStrategy.REMOVED) {\n+            final Set<Integer> nanPositions = new HashSet<Integer>();\n+            for (int i = 0; i < matrix.getColumnDimension(); i++) {\n+                nanPositions.addAll(getNaNPositions(matrix.getColumn(i)));\n+            }\n+\n+            // if we have found NaN values, we have to update the matrix size\n+            if (!nanPositions.isEmpty()) {\n+                transformed = new BlockRealMatrix(matrix.getRowDimension() - nanPositions.size(),\n+                                                  matrix.getColumnDimension());\n+                for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+                    transformed.setColumn(i, removeValues(matrix.getColumn(i), nanPositions));\n+                }\n+            }\n+        }\n+\n+        if (transformed == null) {\n+            transformed = matrix.copy();\n+        }\n+\n+        for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+            transformed.setColumn(i, rankingAlgorithm.rank(transformed.getColumn(i)));\n+        }\n+\n+        return transformed;\n+    }\n+\n+    /**\n+     * Returns a list containing the indices of NaN values in the input array.\n+     *\n+     * @param input the input array\n+     * @return a list of NaN positions in the input array\n+     */\n+    private List<Integer> getNaNPositions(final double[] input) {\n+        final List<Integer> positions = new ArrayList<Integer>();\n+        for (int i = 0; i < input.length; i++) {\n+            if (Double.isNaN(input[i])) {\n+                positions.add(i);\n+            }\n+        }\n+        return positions;\n+    }\n+\n+    /**\n+     * Removes all values from the input array at the specified indices.\n+     *\n+     * @param input the input array\n+     * @param indices a set containing the indices to be removed\n+     * @return the input array without the values at the specified indices\n+     */\n+    private double[] removeValues(final double[] input, final Set<Integer> indices) {\n+        if (indices.isEmpty()) {\n+            return input;\n+        }\n+        final double[] result = new double[input.length - indices.size()];\n+        for (int i = 0, j = 0; i < input.length; i++) {\n+            if (!indices.contains(i)) {\n+                result[j++] = input[i];\n+            }\n+        }\n+        return result;\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/stat/correlation/SpearmansRankCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math3/stat/correlation/SpearmansRankCorrelationTest.java\n \n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n+import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.ranking.NaNStrategy;\n+import org.apache.commons.math3.stat.ranking.NaturalRanking;\n import org.junit.Assert;\n import org.junit.Test;\n \n                 new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n     }\n \n+    @Test\n+    public void testMath891Array() {\n+        final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 };\n+        final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 };\n+\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED);\n+        SpearmansCorrelation spearman = new SpearmansCorrelation(ranking);\n+        \n+        Assert.assertEquals(0.5, spearman.correlation(xArray, yArray), Double.MIN_VALUE);\n+    }\n+\n+    @Test\n+    public void testMath891Matrix() {\n+        final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 };\n+        final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 };\n+\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(xArray.length, 2);\n+        for (int i = 0; i < xArray.length; i++) {\n+            matrix.addToEntry(i, 0, xArray[i]);\n+            matrix.addToEntry(i, 1, yArray[i]);\n+        }\n+\n+        // compute correlation\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED);\n+        SpearmansCorrelation spearman = new SpearmansCorrelation(matrix, ranking);\n+        \n+        Assert.assertEquals(0.5, spearman.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n+    }\n+\n     // Not relevant here\n     @Override\n     @Test", "timestamp": 1364413462, "metainfo": ""}