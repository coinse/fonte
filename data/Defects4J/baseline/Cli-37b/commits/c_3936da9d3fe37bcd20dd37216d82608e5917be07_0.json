{"sha": "3936da9d3fe37bcd20dd37216d82608e5917be07", "log": "Minor syntax changes  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/main/java/org/apache/commons/cli/GnuParser.java\n      */\n     protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n     {\n-        List tokens = new ArrayList();\n+        List<String> tokens = new ArrayList<String>();\n \n         boolean eatTheRest = false;\n \n             }\n         }\n \n-        return (String[]) tokens.toArray(new String[tokens.size()]);\n+        return tokens.toArray(new String[tokens.size()]);\n     }\n }\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n             Collections.sort(optList, getOptionComparator());\n         }\n         // iterate over the options\n-        for (Iterator i = optList.iterator(); i.hasNext();)\n+        for (Iterator<Option> it = optList.iterator(); it.hasNext();)\n         {\n             // get the next Option\n-            Option option = (Option) i.next();\n+            Option option = it.next();\n \n             // check if the option is part of an OptionGroup\n             OptionGroup group = options.getOptionGroup(option);\n                 appendOption(buff, option, option.isRequired());\n             }\n \n-            if (i.hasNext())\n+            if (it.hasNext())\n             {\n                 buff.append(\" \");\n             }\n             Collections.sort(optList, getOptionComparator());\n         }\n         // for each option in the OptionGroup\n-        for (Iterator i = optList.iterator(); i.hasNext();)\n+        for (Iterator<Option> it = optList.iterator(); it.hasNext();)\n         {\n             // whether the option is required or not is handled at group level\n-            appendOption(buff, (Option) i.next(), true);\n-\n-            if (i.hasNext())\n+            appendOption(buff, it.next(), true);\n+\n+            if (it.hasNext())\n             {\n                 buff.append(\" | \");\n             }\n \n         int x = 0;\n \n-        for (Iterator i = optList.iterator(); i.hasNext();)\n-        {\n-            Option option = (Option) i.next();\n+        for (Iterator<Option> it = optList.iterator(); it.hasNext();)\n+        {\n+            Option option = it.next();\n             StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n \n             if (optBuf.length() < max)\n \n             renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n \n-            if (i.hasNext())\n+            if (it.hasNext())\n             {\n                 sb.append(getNewLine());\n             }\n--- a/src/main/java/org/apache/commons/cli/Parser.java\n+++ b/src/main/java/org/apache/commons/cli/Parser.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Enumeration;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n import java.util.Properties;\n      *\n      * @since 1.1\n      */\n-    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n-            throws ParseException\n+    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n     {\n         // clear out the data in options in case it's been used before (CLI-71)\n-        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n-        {\n-            Option opt = (Option) it.next();\n+        for (Option opt : options.helpOptions()) {\n             opt.clearValues();\n         }\n         \n         // clear the data from the groups\n-        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n-        {\n-            OptionGroup group = (OptionGroup) it.next();\n+        for (OptionGroup group : options.getOptionGroups()) {\n             group.setSelected(null);\n         }        \n \n             arguments = new String[0];\n         }\n \n-        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n-\n-        ListIterator iterator = tokenList.listIterator();\n+        List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n+\n+        ListIterator<String> iterator = tokenList.listIterator();\n \n         // process each flattened token\n         while (iterator.hasNext())\n         {\n-            String t = (String) iterator.next();\n+            String t = iterator.next();\n \n             // the value is the double-dash\n             if (\"--\".equals(t))\n             {\n                 while (iterator.hasNext())\n                 {\n-                    String str = (String) iterator.next();\n+                    String str = iterator.next();\n \n                     // ensure only one double-dash is added\n                     if (!\"--\".equals(str))\n      * Throws a {@link MissingOptionException} if all of the required options\n      * are not present.\n      *\n-     * @throws MissingOptionException if any of the required Options\n-     * are not present.\n+     * @throws MissingOptionException if any of the required Options are not present.\n      */\n     protected void checkRequiredOptions() throws MissingOptionException\n     {\n     }\n \n     /**\n-     * <p>Process the argument values for the specified Option\n+     * Process the argument values for the specified Option\n      * <code>opt</code> using the values retrieved from the\n      * specified iterator <code>iter</code>.\n      *\n      * @param opt The current Option\n-     * @param iter The iterator over the flattened command line\n-     * Options.\n+     * @param iter The iterator over the flattened command line Options.\n      *\n      * @throws ParseException if an argument value is required\n      * and it is has not been found.\n      */\n-    public void processArgs(Option opt, ListIterator iter) throws ParseException\n+    public void processArgs(Option opt, ListIterator<String> iter) throws ParseException\n     {\n         // loop until an option is found\n         while (iter.hasNext())\n         {\n-            String str = (String) iter.next();\n-\n+            String str = iter.next();\n+            \n             // found an Option, not an argument\n             if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n             {\n      *\n      * @throws ParseException if <code>arg</code> does not represent an Option\n      */\n-    protected void processOption(String arg, ListIterator iter) throws ParseException\n+    protected void processOption(String arg, ListIterator<String> iter) throws ParseException\n     {\n         boolean hasOption = getOptions().hasOption(arg);\n \n         }\n \n         // get the option represented by arg\n-        Option opt = (Option) getOptions().getOption(arg).clone();\n+        Option opt = getOptions().getOption(arg).clone();\n         \n         // update the required options and groups\n         updateRequiredOptions(opt);\n--- a/src/main/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/main/java/org/apache/commons/cli/PosixParser.java\n public class PosixParser extends Parser\n {\n     /** holder for flattened tokens */\n-    private List tokens = new ArrayList();\n+    private List<String> tokens = new ArrayList<String>();\n \n     /** specifies if bursting should continue */\n     private boolean eatTheRest;\n         this.options = options;\n \n         // an iterator for the command line tokens\n-        Iterator iter = Arrays.asList(arguments).iterator();\n+        Iterator<String> iter = Arrays.asList(arguments).iterator();\n \n         // process each command line token\n         while (iter.hasNext())\n         {\n             // get the next command line token\n-            String token = (String) iter.next();\n+            String token = iter.next();\n \n             // single or double hyphen\n             if (\"-\".equals(token) || \"--\".equals(token))\n                 int pos = token.indexOf('=');\n                 String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n                 \n-                List matchingOpts = options.getMatchingOptions(opt);\n+                List<String> matchingOpts = options.getMatchingOptions(opt);\n \n                 if (matchingOpts.isEmpty())\n                 {\n                 }\n                 else\n                 {\n-                    currentOption = options.getOption((String) matchingOpts.get(0));\n+                    currentOption = options.getOption(matchingOpts.get(0));\n                     \n                     tokens.add(\"--\" + currentOption.getLongOpt());\n                     if (pos != -1)\n                 }\n                 else if (!options.getMatchingOptions(token).isEmpty())\n                 {\n-                    List matchingOpts = options.getMatchingOptions(token);\n+                    List<String> matchingOpts = options.getMatchingOptions(token);\n                     if (matchingOpts.size() > 1)\n                     {\n                         throw new AmbiguousOptionException(token, matchingOpts);\n                     }\n                     else\n                     {\n-                        Option opt = options.getOption((String) matchingOpts.get(0));\n+                        Option opt = options.getOption(matchingOpts.get(0));\n                         processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                     }\n                 }\n             gobble(iter);\n         }\n \n-        return (String[]) tokens.toArray(new String[tokens.size()]);\n+        return tokens.toArray(new String[tokens.size()]);\n     }\n \n     /**\n      *\n      * @param iter An iterator over the remaining tokens\n      */\n-    private void gobble(Iterator iter)\n+    private void gobble(Iterator<String> iter)\n     {\n         if (eatTheRest)\n         {\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n       */\n     public static Object createObject(String classname) throws ParseException\n     {\n-        Class cl = null;\n+        Class cl;\n \n         try\n         {\n         {\n             throw new ParseException(\"Unable to find the class: \" + classname);\n         }\n-\n-        Object instance = null;\n-\n-        try\n-        {\n-            instance = cl.newInstance();\n+        \n+        try\n+        {\n+            return cl.newInstance();\n         }\n         catch (Exception e)\n         {\n             throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n         }\n-\n-        return instance;\n     }\n \n     /**", "timestamp": 1351617860, "metainfo": ""}