{"sha": "a955324468d45eb845e05107d5b0013285c3bc0a", "log": "HelpFormatter now accepts a null comparator to preserve the declaration order of the options (CLI-212)  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n \n     /**\n      * Set the comparator used to sort the options when they output in help text.\n-     * Passing in a null parameter will set the ordering to the default mode.\n+     * Passing in a null comparator will keep the options in the order they were declared.\n      * \n      * @since 1.2\n      */\n     public void setOptionComparator(Comparator<Option> comparator)\n     {\n-        if (comparator == null)\n-        {\n-            this.optionComparator = new OptionComparator();\n-        }\n-        else\n-        {\n-            this.optionComparator = comparator;\n-        }\n+        this.optionComparator = comparator;\n     }\n \n     /**\n         // create a list for processed option groups\n         final Collection<OptionGroup> processedGroups = new ArrayList<OptionGroup>();\n \n-        // temp variable\n-        Option option;\n-\n         List<Option> optList = new ArrayList<Option>(options.getOptions());\n-        Collections.sort(optList, getOptionComparator());\n+        if (getOptionComparator() != null)\n+        {\n+            Collections.sort(optList, getOptionComparator());\n+        }\n         // iterate over the options\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n             // get the next Option\n-            option = (Option) i.next();\n-\n+            Option option = (Option) i.next();\n+            \n             // check if the option is part of an OptionGroup\n             OptionGroup group = options.getOptionGroup(option);\n \n         }\n \n         List<Option> optList = new ArrayList<Option>(group.getOptions());\n-        Collections.sort(optList, getOptionComparator());\n+        if (getOptionComparator() != null)\n+        {\n+            Collections.sort(optList, getOptionComparator());\n+        }\n         // for each option in the OptionGroup\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n         // the longest opt string this list will be then used to \n         // sort options ascending\n         int max = 0;\n-        StringBuffer optBuf;\n         List<StringBuffer> prefixList = new ArrayList<StringBuffer>();\n         \n         List<Option> optList = options.helpOptions();\n         \n-        Collections.sort(optList, getOptionComparator());\n+        if (getOptionComparator() != null)\n+        {\n+            Collections.sort(optList, getOptionComparator());\n+        }\n         \n         for (Option option : optList)\n         {\n-            optBuf = new StringBuffer();\n+            StringBuffer optBuf = new StringBuffer();\n             \n             if (option.getOpt() == null)\n             {\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n             Option option = (Option) i.next();\n-            optBuf = new StringBuffer(prefixList.get(x++).toString());\n+            StringBuffer optBuf = new StringBuffer(prefixList.get(x++).toString());\n \n             if (optBuf.length() < max)\n             {\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n \n     private static final long serialVersionUID = 1L;\n \n     /** a map of the options with the character key */\n-    private Map<String, Option> shortOpts = new HashMap<String, Option>();\n+    private Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n \n     /** a map of the options with the long key */\n-    private Map<String, Option> longOpts = new HashMap<String, Option>();\n+    private Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n \n     /** a map of the required options */\n     private List<Object> requiredOpts = new ArrayList<Object>();\n--- a/src/test/java/org/apache/commons/cli/HelpFormatterTest.java\n+++ b/src/test/java/org/apache/commons/cli/HelpFormatterTest.java\n         opts.addOption(new Option(\"c\", \"third\"));\n \n         HelpFormatter helpFormatter = new HelpFormatter();\n-        helpFormatter.setOptionComparator(new Comparator()\n+        helpFormatter.setOptionComparator(new Comparator<Option>()\n         {\n-            public int compare(Object o1, Object o2)\n+            public int compare(Option opt1, Option opt2)\n             {\n                 // reverses the fuctionality of the default comparator\n-                Option opt1 = (Option) o1;\n-                Option opt2 = (Option) o2;\n                 return opt2.getKey().compareToIgnoreCase(opt1.getKey());\n             }\n         });\n     public void testPrintSortedUsageWithNullComparator()\n     {\n         Options opts = new Options();\n-        opts.addOption(new Option(\"a\", \"first\"));\n+        opts.addOption(new Option(\"c\", \"first\"));\n         opts.addOption(new Option(\"b\", \"second\"));\n-        opts.addOption(new Option(\"c\", \"third\"));\n+        opts.addOption(new Option(\"a\", \"third\"));\n \n         HelpFormatter helpFormatter = new HelpFormatter();\n         helpFormatter.setOptionComparator(null);\n         StringWriter out = new StringWriter();\n         helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n \n-        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, out.toString());\n+        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n     }\n \n     public void testPrintOptionGroupUsage()", "timestamp": 1302643072, "metainfo": ""}