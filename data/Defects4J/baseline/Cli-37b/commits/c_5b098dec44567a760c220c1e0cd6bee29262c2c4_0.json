{"sha": "5b098dec44567a760c220c1e0cd6bee29262c2c4", "log": "trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n  * @since 1.3\n  */\n public class DefaultParser implements CommandLineParser\n-{    \n+{\n     protected CommandLine cmd;\n     protected Options options;\n \n-    /** \n+    /**\n      * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n      * the parsing and add the remaining tokens to the args list.\n      * <tt>false</tt> to throw an exception. \n \n     /** The token currently processed. */\n     protected String currentToken;\n-    \n+ \n     /** The last option parsed. */\n     protected Option currentOption;\n-    \n+ \n     /** Flag indicating if tokens should no longer be analysed and simply added as arguments of the command line. */\n     protected boolean skipParsing;\n-    \n+ \n     /** The required options and groups expected to be found when parsing the command line. */\n     protected List expectedOpts;\n-    \n+ \n     public CommandLine parse(Options options, String[] arguments) throws ParseException\n     {\n         return parse(options, arguments, null);\n         skipParsing = false;\n         currentOption = null;\n         expectedOpts = new ArrayList(options.getRequiredOptions());\n-        \n+\n         // clear the data from the groups\n         for (OptionGroup group : options.getOptionGroups())\n         {\n             group.setSelected(null);\n         }\n-        \n+\n         cmd = new CommandLine();\n \n         if (arguments != null)\n                 handleToken(argument);\n             }\n         }\n-        \n+\n         // check the arguments of the last option\n         checkRequiredArgs();\n-        \n+\n         // add the default options\n         handleProperties(properties);\n-        \n+\n         checkRequiredOptions();\n-        \n+\n         return cmd;\n     }\n \n         {\n             return;\n         }\n-        \n+\n         for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n         {\n             String option = e.nextElement().toString();\n-            \n+\n             Option opt = options.getOption(option);\n             if (opt == null)\n             {\n                 throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n             }\n-            \n+\n             // if the option is part of a group, check if another option of the group has been selected\n             OptionGroup group = options.getOptionGroup(opt);\n             boolean selected = group != null && group.getSelected() != null;\n-            \n+\n             if (!cmd.hasOption(option) && !selected)\n             {\n                 // get the value from the properties\n                 String value = properties.getProperty(option);\n-                \n+\n                 if (opt.hasArg())\n                 {\n                     if (opt.getValues() == null || opt.getValues().length == 0)\n                     // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                     continue;\n                 }\n-                \n+\n                 handleOption(opt);\n                 currentOption = null;\n             }\n      * are not present.\n      */\n     private void checkRequiredOptions() throws MissingOptionException\n-    {       \n+    {\n         // if there are required options that have not been processsed\n         if (!expectedOpts.isEmpty())\n         {\n \n     /**\n      * Handle any command line token.\n-     * \n+     *\n      * @param token the command line token to handle\n      * @throws ParseException\n      */\n     private void handleToken(String token) throws ParseException\n     {\n         currentToken = token;\n-        \n+\n         if (skipParsing)\n         {\n             cmd.addArg(token);\n         {\n             handleUnknownToken(token);\n         }\n-        \n+\n         if (currentOption != null && !currentOption.acceptsArg())\n         {\n             currentOption = null;\n \n     /**\n      * Returns true is the token is a valid argument.\n-     * \n+     *\n      * @param token\n      */\n     private boolean isArgument(String token)\n \n     /**\n      * Check if the token is a negative number.\n-     * \n+     *\n      * @param token\n      */\n     private boolean isNegativeNumber(String token)\n \n     /**\n      * Tells if the token looks like an option.\n-     * \n+     *\n      * @param token\n      */\n     private boolean isOption(String token)\n \n     /**\n      * Tells if the token looks like a long option.\n-     * \n+     *\n      * @param token\n      */\n     private boolean isLongOption(String token)\n \n         int pos = token.indexOf(\"=\");\n         String t = pos == -1 ? token : token.substring(0, pos);\n-        \n+\n         if (!options.getMatchingOptions(t).isEmpty())\n         {\n             // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n      * to the arguments of the command line. If the stopAtNonOption flag \n      * is set, this stops the parsing and the remaining tokens are added \n      * as-is in the arguments of the command line.\n-     * \n+     *\n      * @param token the command line token to handle\n      */\n     private void handleUnknownToken(String token) throws ParseException\n         {\n             throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n         }\n-        \n+\n         cmd.addArg(token);\n         if (stopAtNonOption)\n         {\n \n     /**\n      * Handles the following tokens:\n-     * \n+     *\n      * --L\n      * --L=V\n      * --L V\n      * --l\n-     * \n+     *\n      * @param token the command line token to handle\n      */\n     private void handleLongOption(String token) throws ParseException\n         }\n         else\n         {\n-            handleLongOptionWithEqual(token);                                   \n+            handleLongOptionWithEqual(token);\n         }\n     }\n \n     /**\n      * Handles the following tokens:\n-     * \n+     *\n      * --L\n      * -L\n      * --l\n \n     /**\n      * Handles the following tokens:\n-     * \n+     *\n      * --L=V\n      * -L=V\n      * --l=V\n      * -l=V\n-     * \n+     *\n      * @param token the command line token to handle\n      */\n     private void handleLongOptionWithEqual(String token) throws ParseException\n         int pos = token.indexOf('=');\n \n         String value = token.substring(pos + 1);\n-        \n+\n         String opt = token.substring(0, pos);\n-        \n+\n         List<String> matchingOpts = options.getMatchingOptions(opt);\n         if (matchingOpts.isEmpty())\n         {\n         else\n         {\n             Option option = options.getOption(matchingOpts.get(0));\n-            \n+\n             if (option.acceptsArg())\n             {\n                 handleOption(option);\n \n     /**\n      * Handles the following tokens:\n-     * \n+     *\n      * -S\n      * -SV\n      * -S V\n      * -S1S2\n      * -S1S2 V\n      * -SV1=V2\n-     * \n+     *\n      * -L\n      * -LV\n      * -L V\n      * -L=V\n      * -l\n-     * \n+     *\n      * @param token the command line token to handle\n      */\n     private void handleShortAndLongOption(String token) throws ParseException\n     {\n         String t = Util.stripLeadingHyphens(token);\n-        \n+\n         int pos = t.indexOf('=');\n-        \n+\n         if (t.length() == 1)\n         {\n             // -S\n             {\n                 // look for a long prefix (-Xmx512m)\n                 String opt = getLongPrefix(t);\n-                \n+\n                 if (opt != null && options.getOption(opt).acceptsArg())\n                 {\n                     handleOption(options.getOption(opt));\n             // equal sign found (-xxx=yyy)\n             String opt = t.substring(0, pos);\n             String value = t.substring(pos + 1);\n-            \n+\n             if (opt.length() == 1)\n             {\n                 // -S=V\n \n     /**\n      * Search for a prefix that is the long name of an option (-Xmx512m)\n-     * \n+     *\n      * @param token\n      */\n     private String getLongPrefix(String token)\n     {\n         String t = Util.stripLeadingHyphens(token);\n-        \n+\n         int i;\n         String opt = null;\n         for (i = t.length() - 2; i > 1; i--)\n     {\n         String opt = token.substring(0, 1);\n         Option option = options.getOption(opt);\n-        \n+\n         return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n     }\n \n     {\n         // check the previous option before handling the next one\n         checkRequiredArgs();\n-        \n+\n         option = option.clone();\n-        \n+\n         updateRequiredOptions(option);\n-        \n+\n         cmd.addOption(option);\n-        \n+\n         if (option.hasArg())\n         {\n-            currentOption = option;            \n+            currentOption = option;\n         }\n         else\n         {\n \n     /**\n      * Removes the option or its group from the list of expected elements.\n-     * \n+     *\n      * @param option\n      */\n     private void updateRequiredOptions(Option option) throws AlreadySelectedException\n             if (options.hasOption(ch))\n             {\n                 handleOption(options.getOption(ch));\n-                \n+\n                 if (currentOption != null && (token.length() != (i + 1)))\n                 {\n                     // add the trail as an argument of the option\n                 }\n             }\n             else\n-            {                \n+            {\n                 handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                 break;\n             }", "timestamp": 1303384398, "metainfo": ""}