{"sha": "1596f3bbe57986361da4ac1a23634dd5b00d10df", "log": "Switched to the Maven 2 default directory layout (part 3)  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/AlreadySelectedException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Thrown when more than one option in an option group\n+ * has been provided.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class AlreadySelectedException extends ParseException\n+{\n+    /** The option group selected. */\n+    private OptionGroup group;\n+\n+    /** The option that triggered the exception. */\n+    private Option option;\n+\n+    /**\n+     * Construct a new <code>AlreadySelectedException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public AlreadySelectedException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>AlreadySelectedException</code>\n+     * for the specified option group.\n+     *\n+     * @param group  the option group already selected\n+     * @param option the option that triggered the exception\n+     * @since 1.2\n+     */\n+    public AlreadySelectedException(OptionGroup group, Option option)\n+    {\n+        this(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+                + \"has already been selected: '\" + group.getSelected() + \"'\");\n+        this.group = group;\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Returns the option group where another option has been selected.\n+     *\n+     * @return the related option group\n+     * @since 1.2\n+     */\n+    public OptionGroup getOptionGroup()\n+    {\n+        return group;\n+    }\n+\n+    /**\n+     * Returns the option that was added to the group and triggered the exception.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public Option getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Exception thrown when an option can't be identified from a partial name.\n+ * \n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ * @since 1.3\n+ */\n+public class AmbiguousOptionException extends UnrecognizedOptionException\n+{\n+    /** The list of options matching the partial name specified */\n+    private Collection matchingOptions;\n+\n+    /**\n+     * Constructs a new AmbiguousOptionException.\n+     *\n+     * @param option          the partial option name\n+     * @param matchingOptions the options matching the name\n+     */\n+    public AmbiguousOptionException(String option, Collection matchingOptions)\n+    {\n+        super(createMessage(option, matchingOptions), option);\n+        this.matchingOptions = matchingOptions;\n+    }\n+\n+    /**\n+     * Returns the options matching the partial name.\n+     */\n+    public Collection getMatchingOptions()\n+    {\n+        return matchingOptions;\n+    }\n+\n+    /**\n+     * Build the exception message from the specified list of options.\n+     * \n+     * @param option\n+     * @param matchingOptions\n+     * @return\n+     */\n+    private static String createMessage(String option, Collection matchingOptions)\n+    {\n+        StringBuffer buff = new StringBuffer(\"Ambiguous option: '\");\n+        buff.append(option);\n+        buff.append(\"'  (could be: \");\n+\n+        Iterator it = matchingOptions.iterator();\n+        while (it.hasNext())\n+        {\n+            buff.append(\"'\");\n+            buff.append(it.next());\n+            buff.append(\"'\");\n+            if (it.hasNext())\n+            {\n+                buff.append(\", \");\n+            }\n+        }\n+        buff.append(\")\");\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/BasicParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * The class BasicParser provides a very simple implementation of\n+ * the {@link Parser#flatten(Options,String[],boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @deprecated Use the {@link DefaultParser} instead\n+ */\n+public class BasicParser extends Parser\n+{\n+    /**\n+     * <p>A simple implementation of {@link Parser}'s abstract\n+     * {@link Parser#flatten(Options, String[], boolean) flatten} method.</p>\n+     *\n+     * <p><b>Note:</b> <code>options</code> and <code>stopAtNonOption</code>\n+     * are not used in this <code>flatten</code> method.</p>\n+     *\n+     * @param options The command line {@link Options}\n+     * @param arguments The command line arguments to be parsed\n+     * @param stopAtNonOption Specifies whether to stop flattening\n+     * when an non option is found.\n+     * @return The <code>arguments</code> String array.\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n+    {\n+        // just echo the arguments\n+        return arguments;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/CommandLine.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Properties;\n+\n+/**\n+ * Represents list of arguments parsed against a {@link Options} descriptor.\n+ *\n+ * <p>It allows querying of a boolean {@link #hasOption(String opt)},\n+ * in addition to retrieving the {@link #getOptionValue(String opt)}\n+ * for options requiring arguments.</p>\n+ *\n+ * <p>Additionally, any left-over or unrecognized arguments,\n+ * are available for further processing.</p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class CommandLine implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** the unrecognised options/arguments */\n+    private List args = new LinkedList();\n+\n+    /** the processed options */\n+    private List options = new ArrayList();\n+\n+    /**\n+     * Creates a command line.\n+     */\n+    CommandLine()\n+    {\n+        // nothing to do\n+    }\n+\n+    /** \n+     * Query to see if an option has been set.\n+     *\n+     * @param opt Short name of the option\n+     * @return true if set, false if not\n+     */\n+    public boolean hasOption(String opt)\n+    {\n+        return options.contains(resolveOption(opt));\n+    }\n+\n+    /** \n+     * Query to see if an option has been set.\n+     *\n+     * @param opt character name of the option\n+     * @return true if set, false if not\n+     */\n+    public boolean hasOption(char opt)\n+    {\n+        return hasOption(String.valueOf(opt));\n+    }\n+\n+    /**\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n+     *\n+     * @param opt the name of the option\n+     * @return the type of this <code>Option</code>\n+     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n+     */\n+    public Object getOptionObject(String opt)\n+    {\n+        try {\n+            return getParsedOptionValue(opt);\n+        } catch(ParseException pe) {\n+            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + \n+                pe.getMessage() );\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Return a version of this <code>Option</code> converted to a particular type. \n+     *\n+     * @param opt the name of the option\n+     * @return the value parsed into a particular object\n+     * @throws ParseException if there are problems turning the option value into the desired type\n+     * @see PatternOptionBuilder\n+     * @since 1.2\n+     */\n+    public Object getParsedOptionValue(String opt) throws ParseException\n+    {\n+        String res = getOptionValue(opt);\n+\n+        Option option = resolveOption(opt);\n+        if (option == null)\n+        {\n+            return null;\n+        }\n+\n+        Object type = option.getType();\n+\n+        return (res == null) ? null : TypeHandler.createValue(res, type);\n+    }\n+\n+    /**\n+     * Return the <code>Object</code> type of this <code>Option</code>.\n+     *\n+     * @param opt the name of the option\n+     * @return the type of opt\n+     */\n+    public Object getOptionObject(char opt)\n+    {\n+        return getOptionObject(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of this option.\n+     *\n+     * @param opt the name of the option\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String getOptionValue(String opt)\n+    {\n+        String[] values = getOptionValues(opt);\n+\n+        return (values == null) ? null : values[0];\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of this option.\n+     *\n+     * @param opt the character name of the option\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String getOptionValue(char opt)\n+    {\n+        return getOptionValue(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieves the array of values, if any, of an option.\n+     *\n+     * @param opt string name of the option\n+     * @return Values of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String[] getOptionValues(String opt)\n+    {\n+        List values = new ArrayList();\n+\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n+            {\n+                values.addAll(option.getValuesList());\n+            }\n+        }\n+\n+        return values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n+    }\n+\n+    /**\n+     * Retrieves the option object given the long or short option as a String\n+     * \n+     * @param opt short or long name of the option\n+     * @return Canonicalized option\n+     */\n+    private Option resolveOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+            if (opt.equals(option.getOpt()))\n+            {\n+                return option;\n+            }\n+\n+            if (opt.equals(option.getLongOpt()))\n+            {\n+                return option;\n+            }\n+\n+        }\n+        return null;\n+    }\n+\n+    /** \n+     * Retrieves the array of values, if any, of an option.\n+     *\n+     * @param opt character name of the option\n+     * @return Values of the argument if option is set, and has an argument,\n+     * otherwise null.\n+     */\n+    public String[] getOptionValues(char opt)\n+    {\n+        return getOptionValues(String.valueOf(opt));\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of an option.\n+     *\n+     * @param opt name of the option\n+     * @param defaultValue is the default value to be returned if the option\n+     * is not specified\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise <code>defaultValue</code>.\n+     */\n+    public String getOptionValue(String opt, String defaultValue)\n+    {\n+        String answer = getOptionValue(opt);\n+\n+        return (answer != null) ? answer : defaultValue;\n+    }\n+\n+    /** \n+     * Retrieve the argument, if any, of an option.\n+     *\n+     * @param opt character name of the option\n+     * @param defaultValue is the default value to be returned if the option\n+     * is not specified\n+     * @return Value of the argument if option is set, and has an argument,\n+     * otherwise <code>defaultValue</code>.\n+     */\n+    public String getOptionValue(char opt, String defaultValue)\n+    {\n+        return getOptionValue(String.valueOf(opt), defaultValue);\n+    }\n+\n+    /**\n+     * Retrieve the map of values associated to the option. This is convenient\n+     * for options specifying Java properties like <tt>-Dparam1=value1\n+     * -Dparam2=value2</tt>. The first argument of the option is the key, and\n+     * the 2nd argument is the value. If the option has only one argument\n+     * (<tt>-Dfoo</tt>) it is considered as a boolean flag and the value is\n+     * <tt>\"true\"</tt>.\n+     *\n+     * @param opt name of the option\n+     * @return The Properties mapped by the option, never <tt>null</tt>\n+     *         even if the option doesn't exists\n+     * @since 1.2\n+     */\n+    public Properties getOptionProperties(String opt)\n+    {\n+        Properties props = new Properties();\n+\n+        for (Iterator it = options.iterator(); it.hasNext();)\n+        {\n+            Option option = (Option) it.next();\n+\n+            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n+            {\n+                List values = option.getValuesList();\n+                if (values.size() >= 2)\n+                {\n+                    // use the first 2 arguments as the key/value pair\n+                    props.put(values.get(0), values.get(1));\n+                }\n+                else if (values.size() == 1)\n+                {\n+                    // no explicit value, handle it as a boolean\n+                    props.put(values.get(0), \"true\");\n+                }\n+            }\n+        }\n+\n+        return props;\n+    }\n+\n+    /** \n+     * Retrieve any left-over non-recognized options and arguments\n+     *\n+     * @return remaining items passed in but not parsed as an array\n+     */\n+    public String[] getArgs()\n+    {\n+        String[] answer = new String[args.size()];\n+\n+        args.toArray(answer);\n+\n+        return answer;\n+    }\n+\n+    /** \n+     * Retrieve any left-over non-recognized options and arguments\n+     *\n+     * @return remaining items passed in but not parsed as a <code>List</code>.\n+     */\n+    public List getArgList()\n+    {\n+        return args;\n+    }\n+\n+    /** \n+     * jkeyes\n+     * - commented out until it is implemented properly\n+     * <p>Dump state, suitable for debugging.</p>\n+     *\n+     * @return Stringified form of this object\n+     */\n+\n+    /*\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+            \n+        buf.append(\"[ CommandLine: [ options: \");\n+        buf.append(options.toString());\n+        buf.append(\" ] [ args: \");\n+        buf.append(args.toString());\n+        buf.append(\" ] ]\");\n+            \n+        return buf.toString();\n+    }\n+    */\n+\n+    /**\n+     * Add left-over unrecognized option/argument.\n+     *\n+     * @param arg the unrecognised option/argument.\n+     */\n+    void addArg(String arg)\n+    {\n+        args.add(arg);\n+    }\n+\n+    /**\n+     * Add an option to the command line.  The values of the option are stored.\n+     *\n+     * @param opt the processed option\n+     */\n+    void addOption(Option opt)\n+    {\n+        options.add(opt);\n+    }\n+\n+    /**\n+     * Returns an iterator over the Option members of CommandLine.\n+     *\n+     * @return an <code>Iterator</code> over the processed {@link Option}\n+     * members of this {@link CommandLine}\n+     */\n+    public Iterator iterator()\n+    {\n+        return options.iterator();\n+    }\n+\n+    /**\n+     * Returns an array of the processed {@link Option}s.\n+     *\n+     * @return an array of the processed {@link Option}s.\n+     */\n+    public Option[] getOptions()\n+    {\n+        Collection processed = options;\n+\n+        // reinitialise array\n+        Option[] optionsArray = new Option[processed.size()];\n+\n+        // return the array\n+        return (Option[]) processed.toArray(optionsArray);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/CommandLineParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * A class that implements the <code>CommandLineParser</code> interface\n+ * can parse a String array according to the {@link Options} specified\n+ * and return a {@link CommandLine}.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public interface CommandLineParser\n+{\n+    /**\n+     * Parse the arguments according to the specified options.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    CommandLine parse(Options options, String[] arguments) throws ParseException;\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties)\n+               throws ParseException;\n+     */\n+\n+    /**\n+     * Parse the arguments according to the specified options.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n+     *     the parsing and the remaining arguments are added to the \n+     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n+     *     argument triggers a ParseException.\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n+     *     the parsing and the remaining arguments are added to the \n+     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n+     *     argument triggers a ParseException.\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException;\n+     */\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+\n+/**\n+ * Default parser.\n+ * \n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ * @since 1.3\n+ */\n+public class DefaultParser implements CommandLineParser\n+{    \n+    protected CommandLine cmd;\n+    protected Options options;\n+\n+    /** \n+     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n+     * the parsing and add the remaining tokens to the args list.\n+     * <tt>false</tt> to throw an exception. \n+     */\n+    protected boolean stopAtNonOption;\n+\n+    /** The token currently processed. */\n+    protected String currentToken;\n+    \n+    /** The last option parsed. */\n+    protected Option currentOption;\n+    \n+    /** Flag indicating if tokens should no longer be analysed and simply added as arguments of the command line. */\n+    protected boolean skipParsing;\n+    \n+    /** The required options expected to be found when parsing the command line. */\n+    protected List expectedOpts;\n+    \n+    public CommandLine parse(Options options, String[] arguments) throws ParseException\n+    {\n+        return parse(options, arguments, null);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param options    the specified Options\n+     * @param arguments  the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n+    {\n+        return parse(options, arguments, properties, false);\n+    }\n+\n+    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n+    {\n+        return parse(options, arguments, null, stopAtNonOption);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param options         the specified Options\n+     * @param arguments       the command line arguments\n+     * @param properties      command line option name-value pairs\n+     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n+     *     the parsing and the remaining arguments are added to the \n+     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n+     *     argument triggers a ParseException.\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n+    {\n+        this.options = options;\n+        this.stopAtNonOption = stopAtNonOption;\n+        skipParsing = false;\n+        currentOption = null;\n+        expectedOpts = new ArrayList(options.getRequiredOptions());\n+        \n+        // clear the data from the groups\n+        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n+        {\n+            OptionGroup group = (OptionGroup) it.next();\n+            group.setSelected(null);\n+        }\n+        \n+        cmd = new CommandLine();\n+\n+        if (arguments != null)\n+        {\n+            for (int i = 0; i < arguments.length; i++)\n+            {\n+                handleToken(arguments[i]);\n+            }\n+        }\n+        \n+        // check the arguments of the last option\n+        checkRequiredArgs();\n+        \n+        // add the default options\n+        handleProperties(properties);\n+        \n+        checkRequiredOptions();\n+        \n+        return cmd;\n+    }\n+\n+    /**\n+     * Sets the values of Options using the values in <code>properties</code>.\n+     *\n+     * @param properties The value properties to be processed.\n+     */\n+    private void handleProperties(Properties properties)\n+    {\n+        if (properties == null)\n+        {\n+            return;\n+        }\n+        \n+        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n+        {\n+            String option = e.nextElement().toString();\n+            \n+            if (!cmd.hasOption(option))\n+            {\n+                Option opt = options.getOption(option);\n+                \n+                // get the value from the properties\n+                String value = properties.getProperty(option);\n+                \n+                if (opt.hasArg())\n+                {\n+                    if (opt.getValues() == null || opt.getValues().length == 0)\n+                    {\n+                        opt.addValueForProcessing(value);\n+                    }\n+                }\n+                else if (!(\"yes\".equalsIgnoreCase(value)\n+                        || \"true\".equalsIgnoreCase(value)\n+                        || \"1\".equalsIgnoreCase(value)))\n+                {\n+                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n+                    continue;\n+                }\n+                \n+                cmd.addOption(opt);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throws a {@link MissingOptionException} if all of the required options\n+     * are not present.\n+     *\n+     * @throws MissingOptionException if any of the required Options\n+     * are not present.\n+     */\n+    private void checkRequiredOptions() throws MissingOptionException\n+    {       \n+        // if there are required options that have not been processsed\n+        if (!expectedOpts.isEmpty())\n+        {\n+            throw new MissingOptionException(expectedOpts);\n+        }\n+    }\n+\n+    /**\n+     * Throw a {@link MissingArgumentException} if the current option\n+     * didn't receive the number of arguments expected.\n+     */\n+    private void checkRequiredArgs() throws ParseException\n+    {\n+        if (currentOption != null && currentOption.requiresArg())\n+        {\n+            throw new MissingArgumentException(currentOption);\n+        }\n+    }\n+\n+    /**\n+     * Handle any command line token.\n+     * \n+     * @param token the command line token to handle\n+     * @throws ParseException\n+     */\n+    private void handleToken(String token) throws ParseException\n+    {\n+        currentToken = token;\n+        \n+        if (skipParsing)\n+        {\n+            cmd.addArg(token);\n+        }\n+        else if (\"--\".equals(token))\n+        {\n+            skipParsing = true;\n+        }\n+        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n+        {\n+            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n+        }\n+        else if (token.startsWith(\"--\"))\n+        {\n+            handleLongOption(token);\n+        }\n+        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n+        {\n+            handleShortAndLongOption(token);\n+        }\n+        else\n+        {\n+            handleUnknownToken(token);\n+        }\n+        \n+        if (currentOption != null && !currentOption.acceptsArg())\n+        {\n+            currentOption = null;\n+        }\n+    }\n+\n+    /**\n+     * Returns true is the token is a valid argument.\n+     * \n+     * @param token\n+     */\n+    private boolean isArgument(String token)\n+    {\n+        return !isOption(token) || isNegativeNumber(token);\n+    }\n+\n+    /**\n+     * Check if the token is a negative number.\n+     * \n+     * @param token\n+     */\n+    private boolean isNegativeNumber(String token)\n+    {\n+        try\n+        {\n+            Double.parseDouble(token);\n+            return true;\n+        }\n+        catch (NumberFormatException e)\n+        {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tells if the token looks like an option.\n+     * \n+     * @param token\n+     */\n+    private boolean isOption(String token)\n+    {\n+        return isLongOption(token) || isShortOption(token);\n+    }\n+\n+    /**\n+     * Tells if the token looks like a short option.\n+     * \n+     * @param token\n+     */\n+    private boolean isShortOption(String token)\n+    {\n+        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n+        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+    }\n+\n+    /**\n+     * Tells if the token looks like a long option.\n+     * \n+     * @param token\n+     */\n+    private boolean isLongOption(String token)\n+    {\n+        if (!token.startsWith(\"-\") || token.length() == 1)\n+        {\n+            return false;\n+        }\n+\n+        int pos = token.indexOf(\"=\");\n+        String t = pos == -1 ? token : token.substring(0, pos);\n+        \n+        if (!options.getMatchingOptions(t).isEmpty())\n+        {\n+            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n+            return true;\n+        }\n+        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n+        {\n+            // -LV\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Handles an unknown token. If the token starts with a dash an \n+     * UnrecognizedOptionException is thrown. Otherwise the token is added \n+     * to the arguments of the command line. If the stopAtNonOption flag \n+     * is set, this stops the parsing and the remaining tokens are added \n+     * as-is in the arguments of the command line.\n+     * \n+     * @param token the command line token to handle\n+     */\n+    private void handleUnknownToken(String token) throws ParseException\n+    {\n+        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n+        {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n+        }\n+        \n+        cmd.addArg(token);\n+        if (stopAtNonOption)\n+        {\n+            skipParsing = true;\n+        }\n+    }\n+\n+    /**\n+     * Handles the following tokens:\n+     * \n+     * --L\n+     * --L=V\n+     * --L V\n+     * --l\n+     * \n+     * @param token the command line token to handle\n+     */\n+    private void handleLongOption(String token) throws ParseException\n+    {\n+        if (token.indexOf('=') == -1)\n+        {\n+            handleLongOptionWithoutEqual(token);\n+        }\n+        else\n+        {\n+            handleLongOptionWithEqual(token);                                   \n+        }\n+    }\n+\n+    /**\n+     * Handles the following tokens:\n+     * \n+     * --L\n+     * -L\n+     * --l\n+     * -l\n+     * \n+     * @param token the command line token to handle\n+     */\n+    private void handleLongOptionWithoutEqual(String token) throws ParseException\n+    {\n+        List matchingOpts = options.getMatchingOptions(token);\n+        if (matchingOpts.isEmpty())\n+        {\n+            handleUnknownToken(currentToken);\n+        }\n+        else if (matchingOpts.size() > 1)\n+        {\n+            throw new AmbiguousOptionException(token, matchingOpts);\n+        }\n+        else\n+        {\n+            handleOption(options.getOption((String) matchingOpts.get(0)));\n+        }\n+    }\n+\n+    /**\n+     * Handles the following tokens:\n+     * \n+     * --L=V\n+     * -L=V\n+     * --l=V\n+     * -l=V\n+     * \n+     * @param token the command line token to handle\n+     */\n+    private void handleLongOptionWithEqual(String token) throws ParseException\n+    {\n+        int pos = token.indexOf('=');\n+\n+        String value = token.substring(pos + 1);\n+        \n+        String opt = token.substring(0, pos);\n+        \n+        List matchingOpts = options.getMatchingOptions(opt);\n+        if (matchingOpts.isEmpty())\n+        {\n+            handleUnknownToken(currentToken);\n+        }\n+        else if (matchingOpts.size() > 1)\n+        {\n+            throw new AmbiguousOptionException(opt, matchingOpts);\n+        }\n+        else\n+        {\n+            Option option = options.getOption((String) matchingOpts.get(0));\n+            \n+            if (option.acceptsArg())\n+            {\n+                handleOption(option);\n+                currentOption.addValueForProcessing(value);\n+                currentOption = null;\n+            }\n+            else\n+            {\n+                handleUnknownToken(currentToken);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles the following tokens:\n+     * \n+     * -S\n+     * -SV\n+     * -S V\n+     * -S=V\n+     * -S1S2\n+     * -S1S2 V\n+     * -SV1=V2\n+     * \n+     * -L\n+     * -LV\n+     * -L V\n+     * -L=V\n+     * -l\n+     * \n+     * @param token the command line token to handle\n+     */\n+    private void handleShortAndLongOption(String token) throws ParseException\n+    {\n+        String t = Util.stripLeadingHyphens(token);\n+        \n+        int pos = t.indexOf('=');\n+        \n+        if (t.length() == 1)\n+        {\n+            // -S\n+            if (options.hasShortOption(t))\n+            {\n+                handleOption(options.getOption(t));\n+            }\n+            else\n+            {\n+                handleUnknownToken(token);\n+            }\n+        }\n+        else if (pos == -1)\n+        {\n+            if (options.hasShortOption(t))\n+            {\n+                handleOption(options.getOption(t));\n+            }\n+            else if (!options.getMatchingOptions(t).isEmpty())\n+            {\n+                // -L or -l\n+                handleLongOptionWithoutEqual(token);\n+            }\n+            else\n+            {\n+                // look for a long prefix (-Xmx512m)\n+                String opt = getLongPrefix(t);\n+                \n+                if (opt != null && options.getOption(opt).acceptsArg())\n+                {\n+                    handleOption(options.getOption(opt));\n+                    currentOption.addValueForProcessing(t.substring(opt.length()));\n+                    currentOption = null;\n+                }\n+                else if (isJavaProperty(t))\n+                {\n+                    // -SV1 (-Dflag)\n+                    handleOption(options.getOption(t.substring(0, 1)));\n+                    currentOption.addValueForProcessing(t.substring(1));\n+                    currentOption = null;\n+                }\n+                else\n+                {\n+                    // -S1S2S3 or -S1S2V\n+                    handleConcatenatedOptions(token);\n+                }\n+            }\n+        }\n+        else\n+        {\n+            String opt = t.substring(0, pos);\n+            String value = t.substring(pos + 1);\n+            \n+            if (opt.length() == 1)\n+            {\n+                // -S=V\n+                Option option = options.getOption(opt);\n+                if (option != null && option.acceptsArg())\n+                {\n+                    handleOption(option);\n+                    currentOption.addValueForProcessing(value);\n+                    currentOption = null;\n+                }\n+                else\n+                {\n+                    handleUnknownToken(token);\n+                }\n+            }\n+            else if (isJavaProperty(opt))\n+            {\n+                // -SV1=V2 (-Dkey=value)\n+                handleOption(options.getOption(opt.substring(0, 1)));\n+                currentOption.addValueForProcessing(opt.substring(1));\n+                currentOption.addValueForProcessing(value);\n+                currentOption = null;\n+            }\n+            else\n+            {\n+                // -L=V or -l=V\n+                handleLongOptionWithEqual(token);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Search for a prefix that is the long name of an option (-Xmx512m)\n+     * \n+     * @param token\n+     */\n+    private String getLongPrefix(String token)\n+    {\n+        String t = Util.stripLeadingHyphens(token);\n+        \n+        int i;\n+        String opt = null;\n+        for (i = t.length() - 2; i > 1; i--)\n+        {\n+            String prefix = t.substring(0, i);\n+            if (options.hasLongOption(prefix))\n+            {\n+                opt = prefix;\n+                break;\n+            }\n+        }\n+        \n+        return opt;\n+    }\n+\n+    /**\n+     * Check if the specified token is a Java-like property (-Dkey=value).\n+     */\n+    private boolean isJavaProperty(String token)\n+    {\n+        String opt = token.substring(0, 1);\n+        Option option = options.getOption(opt);\n+        \n+        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n+    }\n+\n+    private void handleOption(Option option) throws ParseException\n+    {\n+        // check the previous option before handling the next one\n+        checkRequiredArgs();\n+        \n+        option = (Option) option.clone();\n+        \n+        updateRequiredOptions(option);\n+        \n+        cmd.addOption(option);\n+        \n+        if (option.hasArg())\n+        {\n+            currentOption = option;            \n+        }\n+        else\n+        {\n+            currentOption = null;\n+        }\n+    }\n+\n+    /**\n+     * Removes the option or its group from the list of expected elements.\n+     * \n+     * @param option\n+     */\n+    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n+    {\n+        if (option.isRequired())\n+        {\n+            expectedOpts.remove(option.getKey());\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected option of the group\n+        if (options.getOptionGroup(option) != null)\n+        {\n+            OptionGroup group = options.getOptionGroup(option);\n+\n+            if (group.isRequired())\n+            {\n+                expectedOpts.remove(group);\n+            }\n+\n+            group.setSelected(option);\n+        }\n+    }\n+\n+    /**\n+     * Breaks <code>token</code> into its constituent parts\n+     * using the following algorithm.\n+     *\n+     * <ul>\n+     *  <li>ignore the first character (\"<b>-</b>\")</li>\n+     *  <li>foreach remaining character check if an {@link Option}\n+     *  exists with that id.</li>\n+     *  <li>if an {@link Option} does exist then add that character\n+     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n+     *  <li>if the {@link Option} can have an argument value and there\n+     *  are remaining characters in the token then add the remaining\n+     *  characters as a token to the list of processed tokens.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n+     *  \"<b>--</b>\" followed by the remaining characters and also\n+     *  the remaining tokens directly to the processed tokens list.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n+     *  character prepended with \"<b>-</b>\".</li>\n+     * </ul>\n+     *\n+     * @param token The current token to be <b>burst</b>\n+     * at the first non-Option encountered.\n+     */\n+    protected void handleConcatenatedOptions(String token) throws ParseException\n+    {\n+        for (int i = 1; i < token.length(); i++)\n+        {\n+            String ch = String.valueOf(token.charAt(i));\n+\n+            if (options.hasOption(ch))\n+            {\n+                handleOption(options.getOption(ch));\n+                \n+                if (currentOption != null && (token.length() != (i + 1)))\n+                {\n+                    // add the trail as an argument of the option\n+                    currentOption.addValueForProcessing(token.substring(i + 1));\n+                    break;\n+                }\n+            }\n+            else\n+            {                \n+                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n+                break;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/GnuParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The class GnuParser provides an implementation of the\n+ * {@link Parser#flatten(Options, String[], boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @deprecated Use the {@link DefaultParser} instead\n+ */\n+public class GnuParser extends Parser\n+{\n+    /**\n+     * This flatten method does so using the following rules:\n+     * <ol>\n+     *   <li>If an {@link Option} exists for the first character of\n+     *   the <code>arguments</code> entry <b>AND</b> an {@link Option}\n+     *   does not exist for the whole <code>argument</code> then\n+     *   add the first character as an option to the processed tokens\n+     *   list e.g. \"-D\" and add the rest of the entry to the also.</li>\n+     *   <li>Otherwise just add the token to the processed tokens list.</li>\n+     * </ol>\n+     *\n+     * @param options         The Options to parse the arguments by.\n+     * @param arguments       The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop flattening when\n+     *                        a non option has been encountered\n+     * @return a String array of the flattened arguments\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n+    {\n+        List tokens = new ArrayList();\n+\n+        boolean eatTheRest = false;\n+\n+        for (int i = 0; i < arguments.length; i++)\n+        {\n+            String arg = arguments[i];\n+\n+            if (\"--\".equals(arg))\n+            {\n+                eatTheRest = true;\n+                tokens.add(\"--\");\n+            }\n+            else if (\"-\".equals(arg))\n+            {\n+                tokens.add(\"-\");\n+            }\n+            else if (arg.startsWith(\"-\"))\n+            {\n+                String opt = Util.stripLeadingHyphens(arg);\n+\n+                if (options.hasOption(opt))\n+                {\n+                    tokens.add(arg);\n+                }\n+                else\n+                {\n+                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n+                    {\n+                        // the format is --foo=value or -foo=value\n+                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n+                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n+                    }\n+                    else if (options.hasOption(arg.substring(0, 2)))\n+                    {\n+                        // the format is a special properties option (-Dproperty=value)\n+                        tokens.add(arg.substring(0, 2)); // -D\n+                        tokens.add(arg.substring(2)); // property=value\n+                    }\n+                    else\n+                    {\n+                        eatTheRest = stopAtNonOption;\n+                        tokens.add(arg);\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                tokens.add(arg);\n+            }\n+\n+            if (eatTheRest)\n+            {\n+                for (i++; i < arguments.length; i++)\n+                {\n+                    tokens.add(arguments[i]);\n+                }\n+            }\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/** \n+ * A formatter of help messages for the current command line options\n+ *\n+ * @author Slawek Zachcial\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class HelpFormatter\n+{\n+    // --------------------------------------------------------------- Constants\n+\n+    /** default number of characters per line */\n+    public static final int DEFAULT_WIDTH = 74;\n+\n+    /** default padding to the left of each line */\n+    public static final int DEFAULT_LEFT_PAD = 1;\n+\n+    /**\n+     * the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public static final int DEFAULT_DESC_PAD = 3;\n+\n+    /** the string to display at the beginning of the usage statement */\n+    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n+\n+    /** default prefix for shortOpts */\n+    public static final String DEFAULT_OPT_PREFIX = \"-\";\n+\n+    /** default prefix for long Option */\n+    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n+\n+    /** default separator displayed between a long Option and its value */\n+    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n+\n+    /** default name for an argument */\n+    public static final String DEFAULT_ARG_NAME = \"arg\";\n+\n+    // -------------------------------------------------------------- Attributes\n+\n+    /**\n+     * number of characters per line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setWidth methods instead.\n+     */\n+    public int defaultWidth = DEFAULT_WIDTH;\n+\n+    /**\n+     * amount of padding to the left of each line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setLeftPadding methods instead.\n+     */\n+    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n+\n+    /**\n+     * the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setDescPadding methods instead.\n+     */\n+    public int defaultDescPad = DEFAULT_DESC_PAD;\n+\n+    /**\n+     * the string to display at the begining of the usage statement\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setSyntaxPrefix methods instead.\n+     */\n+    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n+\n+    /**\n+     * the new line string\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setNewLine methods instead.\n+     */\n+    public String defaultNewLine = System.getProperty(\"line.separator\");\n+\n+    /**\n+     * the shortOpt prefix\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setOptPrefix methods instead.\n+     */\n+    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n+\n+    /**\n+     * the long Opt prefix\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setLongOptPrefix methods instead.\n+     */\n+    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n+\n+    /** The separator displayed between the long option and its value. */\n+    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n+\n+    /**\n+     * the name of the argument\n+     *\n+     * @deprecated Scope will be made private for next major version\n+     * - use get/setArgName methods instead.\n+     */\n+    public String defaultArgName = DEFAULT_ARG_NAME;\n+\n+    /**\n+     * Comparator used to sort the options when they output in help text\n+     * \n+     * Defaults to case-insensitive alphabetical sorting by option key\n+     */\n+    protected Comparator optionComparator = new OptionComparator();\n+    \n+    /**\n+     * Sets the 'width'.\n+     *\n+     * @param width the new value of 'width'\n+     */\n+    public void setWidth(int width)\n+    {\n+        this.defaultWidth = width;\n+    }\n+\n+    /**\n+     * Returns the 'width'.\n+     *\n+     * @return the 'width'\n+     */\n+    public int getWidth()\n+    {\n+        return defaultWidth;\n+    }\n+\n+    /**\n+     * Sets the 'leftPadding'.\n+     *\n+     * @param padding the new value of 'leftPadding'\n+     */\n+    public void setLeftPadding(int padding)\n+    {\n+        this.defaultLeftPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'leftPadding'.\n+     *\n+     * @return the 'leftPadding'\n+     */\n+    public int getLeftPadding()\n+    {\n+        return defaultLeftPad;\n+    }\n+\n+    /**\n+     * Sets the 'descPadding'.\n+     *\n+     * @param padding the new value of 'descPadding'\n+     */\n+    public void setDescPadding(int padding)\n+    {\n+        this.defaultDescPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'descPadding'.\n+     *\n+     * @return the 'descPadding'\n+     */\n+    public int getDescPadding()\n+    {\n+        return defaultDescPad;\n+    }\n+\n+    /**\n+     * Sets the 'syntaxPrefix'.\n+     *\n+     * @param prefix the new value of 'syntaxPrefix'\n+     */\n+    public void setSyntaxPrefix(String prefix)\n+    {\n+        this.defaultSyntaxPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'syntaxPrefix'.\n+     *\n+     * @return the 'syntaxPrefix'\n+     */\n+    public String getSyntaxPrefix()\n+    {\n+        return defaultSyntaxPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'newLine'.\n+     *\n+     * @param newline the new value of 'newLine'\n+     */\n+    public void setNewLine(String newline)\n+    {\n+        this.defaultNewLine = newline;\n+    }\n+\n+    /**\n+     * Returns the 'newLine'.\n+     *\n+     * @return the 'newLine'\n+     */\n+    public String getNewLine()\n+    {\n+        return defaultNewLine;\n+    }\n+\n+    /**\n+     * Sets the 'optPrefix'.\n+     *\n+     * @param prefix the new value of 'optPrefix'\n+     */\n+    public void setOptPrefix(String prefix)\n+    {\n+        this.defaultOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'optPrefix'.\n+     *\n+     * @return the 'optPrefix'\n+     */\n+    public String getOptPrefix()\n+    {\n+        return defaultOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'longOptPrefix'.\n+     *\n+     * @param prefix the new value of 'longOptPrefix'\n+     */\n+    public void setLongOptPrefix(String prefix)\n+    {\n+        this.defaultLongOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'longOptPrefix'.\n+     *\n+     * @return the 'longOptPrefix'\n+     */\n+    public String getLongOptPrefix()\n+    {\n+        return defaultLongOptPrefix;\n+    }\n+\n+    /**\n+     * Set the separator displayed between a long option and its value.\n+     * Ensure that the separator specified is supported by the parser used,\n+     * typically ' ' or '='.\n+     * \n+     * @param longOptSeparator the separator, typically ' ' or '='.\n+     * @since 1.3\n+     */\n+    public void setLongOptSeparator(String longOptSeparator)\n+    {\n+        this.longOptSeparator = longOptSeparator;\n+    }\n+\n+    /**\n+     * Returns the separator displayed between a long option and its value.\n+     * \n+     * @return the separator\n+     * @since 1.3\n+     */\n+    public String getLongOptSeparator()\n+    {\n+        return longOptSeparator;\n+    }\n+\n+    /**\n+     * Sets the 'argName'.\n+     *\n+     * @param name the new value of 'argName'\n+     */\n+    public void setArgName(String name)\n+    {\n+        this.defaultArgName = name;\n+    }\n+\n+    /**\n+     * Returns the 'argName'.\n+     *\n+     * @return the 'argName'\n+     */\n+    public String getArgName()\n+    {\n+        return defaultArgName;\n+    }\n+\n+    /**\n+     * Comparator used to sort the options when they output in help text.\n+     * Defaults to case-insensitive alphabetical sorting by option key.\n+     * \n+     * @since 1.2\n+     */\n+    public Comparator getOptionComparator()\n+    {\n+        return optionComparator;\n+    }\n+\n+    /**\n+     * Set the comparator used to sort the options when they output in help text.\n+     * Passing in a null parameter will set the ordering to the default mode.\n+     * \n+     * @since 1.2\n+     */\n+    public void setOptionComparator(Comparator comparator)\n+    {\n+        if (comparator == null)\n+        {\n+            this.optionComparator = new OptionComparator();\n+        }\n+        else\n+        {\n+            this.optionComparator = comparator;\n+        }\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to \n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n+    {\n+        printHelp(cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to \n+     * System.out.\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the beginning of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n+    {\n+        printHelp(width, cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.  This method prints help information to\n+     * System.out.\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header,\n+                          Options options, String footer, boolean autoUsage)\n+    {\n+        PrintWriter pw = new PrintWriter(System.out);\n+\n+        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n+        pw.flush();\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     *\n+     * @throws IllegalStateException if there is no room to print a line\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer)\n+    {\n+        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n+    }\n+\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated\n+     * usage statement\n+     *\n+     * @throws IllegalStateException if there is no room to print a line\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n+                          String header, Options options, int leftPad,\n+                          int descPad, String footer, boolean autoUsage)\n+    {\n+        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n+        {\n+            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n+        }\n+\n+        if (autoUsage)\n+        {\n+            printUsage(pw, width, cmdLineSyntax, options);\n+        }\n+        else\n+        {\n+            printUsage(pw, width, cmdLineSyntax);\n+        }\n+\n+        if ((header != null) && (header.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, header);\n+        }\n+\n+        printOptions(pw, width, options, leftPad, descPad);\n+\n+        if ((footer != null) && (footer.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, footer);\n+        }\n+    }\n+\n+    /**\n+     * Prints the usage statement for the specified application.\n+     *\n+     * @param pw The PrintWriter to print the usage statement \n+     * @param width The number of characters to display per line\n+     * @param app The application name\n+     * @param options The command line Options\n+     */\n+    public void printUsage(PrintWriter pw, int width, String app, Options options)\n+    {\n+        // initialise the string buffer\n+        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n+\n+        // create a list for processed option groups\n+        final Collection processedGroups = new ArrayList();\n+\n+        // temp variable\n+        Option option;\n+\n+        List optList = new ArrayList(options.getOptions());\n+        Collections.sort(optList, getOptionComparator());\n+        // iterate over the options\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            // get the next Option\n+            option = (Option) i.next();\n+\n+            // check if the option is part of an OptionGroup\n+            OptionGroup group = options.getOptionGroup(option);\n+\n+            // if the option is part of a group \n+            if (group != null)\n+            {\n+                // and if the group has not already been processed\n+                if (!processedGroups.contains(group))\n+                {\n+                    // add the group to the processed list\n+                    processedGroups.add(group);\n+\n+\n+                    // add the usage clause\n+                    appendOptionGroup(buff, group);\n+                }\n+\n+                // otherwise the option was displayed in the group\n+                // previously so ignore it.\n+            }\n+\n+            // if the Option is not part of an OptionGroup\n+            else\n+            {\n+                appendOption(buff, option, option.isRequired());\n+            }\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" \");\n+            }\n+        }\n+\n+\n+        // call printWrapped\n+        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n+    }\n+\n+    /**\n+     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n+     * The clause is wrapped in square brackets if the group is required.\n+     * The display of the options is handled by appendOption\n+     * @param buff the StringBuffer to append to\n+     * @param group the group to append\n+     * @see #appendOption(StringBuffer,Option,boolean)\n+     */\n+    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n+    {\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        List optList = new ArrayList(group.getOptions());\n+        Collections.sort(optList, getOptionComparator());\n+        // for each option in the OptionGroup\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            // whether the option is required or not is handled at group level\n+            appendOption(buff, (Option) i.next(), true);\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" | \");\n+            }\n+        }\n+\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * Appends the usage clause for an Option to a StringBuffer.  \n+     *\n+     * @param buff the StringBuffer to append to\n+     * @param option the Option to append\n+     * @param required whether the Option is required or not\n+     */\n+    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n+    {\n+        if (!required)\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        if (option.getOpt() != null)\n+        {\n+            buff.append(\"-\").append(option.getOpt());\n+        }\n+        else\n+        {\n+            buff.append(\"--\").append(option.getLongOpt());\n+        }\n+\n+        // if the Option has a value\n+        if (option.hasArg() && option.hasArgName())\n+        {\n+            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n+            buff.append(\"<\").append(option.getArgName()).append(\">\");\n+        }\n+\n+        // if the Option is not a required option\n+        if (!required)\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+    \n+    /**\n+     * Print the cmdLineSyntax to the specified writer, using the\n+     * specified width.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters per line for the usage statement.\n+     * @param cmdLineSyntax The usage statement.\n+     */\n+    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n+    {\n+        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n+\n+        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n+    }\n+\n+    /**\n+     * Print the help for the specified Options to the specified writer, \n+     * using the specified width, left padding and description padding.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public void printOptions(PrintWriter pw, int width, Options options, \n+                             int leftPad, int descPad)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+\n+        renderOptions(sb, width, options, leftPad, descPad);\n+        pw.println(sb.toString());\n+    }\n+\n+    /**\n+     * Print the specified text to the specified PrintWriter.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, String text)\n+    {\n+        printWrapped(pw, width, 0, text);\n+    }\n+\n+    /**\n+     * Print the specified text to the specified PrintWriter.\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n+    {\n+        StringBuffer sb = new StringBuffer(text.length());\n+\n+        renderWrappedText(sb, width, nextLineTabStop, text);\n+        pw.println(sb.toString());\n+    }\n+\n+    // --------------------------------------------------------------- Protected\n+\n+    /**\n+     * Render the specified Options and return the rendered Options\n+     * in a StringBuffer.\n+     *\n+     * @param sb The StringBuffer to place the rendered Options into.\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n+    {\n+        final String lpad = createPadding(leftPad);\n+        final String dpad = createPadding(descPad);\n+\n+        // first create list containing only <lpad>-a,--aaa where \n+        // -a is opt and --aaa is long opt; in parallel look for \n+        // the longest opt string this list will be then used to \n+        // sort options ascending\n+        int max = 0;\n+        StringBuffer optBuf;\n+        List prefixList = new ArrayList();\n+\n+        List optList = options.helpOptions();\n+\n+        Collections.sort(optList, getOptionComparator());\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            Option option = (Option) i.next();\n+            optBuf = new StringBuffer(8);\n+\n+            if (option.getOpt() == null)\n+            {\n+                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n+            }\n+            else\n+            {\n+                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n+\n+                if (option.hasLongOpt())\n+                {\n+                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n+                }\n+            }\n+\n+            if (option.hasArg())\n+            {\n+                if (option.hasArgName())\n+                {\n+                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n+                    optBuf.append(\"<\").append(option.getArgName()).append(\">\");\n+                }\n+                else\n+                {\n+                    optBuf.append(' ');\n+                }\n+            }\n+\n+            prefixList.add(optBuf);\n+            max = (optBuf.length() > max) ? optBuf.length() : max;\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            Option option = (Option) i.next();\n+            optBuf = new StringBuffer(prefixList.get(x++).toString());\n+\n+            if (optBuf.length() < max)\n+            {\n+                optBuf.append(createPadding(max - optBuf.length()));\n+            }\n+\n+            optBuf.append(dpad);\n+\n+            int nextLineTabStop = max + descPad;\n+\n+            if (option.getDescription() != null)\n+            {\n+                optBuf.append(option.getDescription());\n+            }\n+\n+            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n+\n+            if (i.hasNext())\n+            {\n+                sb.append(defaultNewLine);\n+            }\n+        }\n+\n+        return sb;\n+    }\n+\n+    /**\n+     * Render the specified text and return the rendered Options\n+     * in a StringBuffer.\n+     *\n+     * @param sb The StringBuffer to place the rendered text into.\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be rendered.\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n+                                             int nextLineTabStop, String text)\n+    {\n+        int pos = findWrapPos(text, width, 0);\n+\n+        if (pos == -1)\n+        {\n+            sb.append(rtrim(text));\n+\n+            return sb;\n+        }\n+        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+\n+        if (nextLineTabStop >= width)\n+        {\n+            // stops infinite loop happening\n+            nextLineTabStop = 1;\n+        }\n+\n+        // all following lines must be padded with nextLineTabStop space \n+        // characters\n+        final String padding = createPadding(nextLineTabStop);\n+\n+        while (true)\n+        {\n+            text = padding + text.substring(pos).trim();\n+            pos = findWrapPos(text, width, 0);\n+\n+            if (pos == -1)\n+            {\n+                sb.append(text);\n+\n+                return sb;\n+            }\n+            \n+            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n+            {\n+                pos = width;\n+            }\n+\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next text wrap position after <code>startPos</code> for the\n+     * text in <code>text</code> with the column width <code>width</code>.\n+     * The wrap point is the last postion before startPos+width having a \n+     * whitespace character (space, \\n, \\r).\n+     *\n+     * @param text The text being searched for the wrap position\n+     * @param width width of the wrapped text\n+     * @param startPos position from which to start the lookup whitespace\n+     * character\n+     * @return postion on which the text must be wrapped or -1 if the wrap\n+     * position is at the end of the text\n+     */\n+    protected int findWrapPos(String text, int width, int startPos)\n+    {\n+        int pos = -1;\n+\n+        // the line ends before the max wrap pos or a new line char found\n+        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n+                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n+        {\n+            return pos + 1;\n+        }\n+        else if (startPos + width >= text.length())\n+        {\n+            return -1;\n+        }\n+\n+\n+        // look for the last whitespace character before startPos+width\n+        pos = startPos + width;\n+\n+        char c;\n+\n+        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n+                && (c != '\\n') && (c != '\\r'))\n+        {\n+            --pos;\n+        }\n+\n+        // if we found it - just return\n+        if (pos > startPos)\n+        {\n+            return pos;\n+        }\n+        \n+        // must look for the first whitespace chearacter after startPos \n+        // + width\n+        pos = startPos + width;\n+\n+        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n+               && (c != '\\n') && (c != '\\r'))\n+        {\n+            ++pos;\n+        }\n+\n+        return (pos == text.length()) ? (-1) : pos;\n+    }\n+\n+    /**\n+     * Return a String of padding of length <code>len</code>.\n+     *\n+     * @param len The length of the String of padding to create.\n+     *\n+     * @return The String of padding\n+     */\n+    protected String createPadding(int len)\n+    {\n+        StringBuffer sb = new StringBuffer(len);\n+\n+        for (int i = 0; i < len; ++i)\n+        {\n+            sb.append(' ');\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Remove the trailing whitespace from the specified String.\n+     *\n+     * @param s The String to remove the trailing padding from.\n+     *\n+     * @return The String of without the trailing padding\n+     */\n+    protected String rtrim(String s)\n+    {\n+        if ((s == null) || (s.length() == 0))\n+        {\n+            return s;\n+        }\n+\n+        int pos = s.length();\n+\n+        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n+        {\n+            --pos;\n+        }\n+\n+        return s.substring(0, pos);\n+    }\n+\n+    // ------------------------------------------------------ Package protected\n+    // ---------------------------------------------------------------- Private\n+    // ---------------------------------------------------------- Inner classes\n+    /**\n+     * This class implements the <code>Comparator</code> interface\n+     * for comparing Options.\n+     */\n+    private static class OptionComparator implements Comparator\n+    {\n+\n+        /**\n+         * Compares its two arguments for order. Returns a negative\n+         * integer, zero, or a positive integer as the first argument\n+         * is less than, equal to, or greater than the second.\n+         *\n+         * @param o1 The first Option to be compared.\n+         * @param o2 The second Option to be compared.\n+         * @return a negative integer, zero, or a positive integer as\n+         *         the first argument is less than, equal to, or greater than the\n+         *         second.\n+         */\n+        public int compare(Object o1, Object o2)\n+        {\n+            Option opt1 = (Option) o1;\n+            Option opt2 = (Option) o2;\n+\n+            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/MissingArgumentException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Thrown when an option requiring an argument\n+ * is not provided with an argument.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class MissingArgumentException extends ParseException\n+{\n+    /** The option requiring additional arguments */\n+    private Option option;\n+\n+    /**\n+     * Construct a new <code>MissingArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public MissingArgumentException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>MissingArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param option the option requiring an argument\n+     * @since 1.2\n+     */\n+    public MissingArgumentException(Option option)\n+    {\n+        this(\"Missing argument for option: \" + option.getKey());\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Return the option requiring an argument that wasn't provided\n+     * on the command line.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public Option getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/MissingOptionException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.List;\n+import java.util.Iterator;\n+\n+/**\n+ * Thrown when a required option has not been provided.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class MissingOptionException extends ParseException\n+{\n+    /** The list of missing options */\n+    private List missingOptions;\n+\n+    /**\n+     * Construct a new <code>MissingSelectedException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public MissingOptionException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MissingSelectedException</code> with the\n+     * specified list of missing options.\n+     *\n+     * @param missingOptions the list of missing options\n+     * @since 1.2\n+     */\n+    public MissingOptionException(List missingOptions)\n+    {\n+        this(createMessage(missingOptions));\n+        this.missingOptions = missingOptions;\n+    }\n+\n+    /**\n+     * Return the list of options (as strings) missing in the command line parsed.\n+     *\n+     * @return the missing options\n+     * @since 1.2\n+     */\n+    public List getMissingOptions()\n+    {\n+        return missingOptions;\n+    }\n+\n+    /**\n+     * Build the exception message from the specified list of options.\n+     *\n+     * @param missingOptions\n+     * @since 1.2\n+     */\n+    private static String createMessage(List missingOptions)\n+    {\n+        StringBuffer buff = new StringBuffer(\"Missing required option\");\n+        buff.append(missingOptions.size() == 1 ? \"\" : \"s\");\n+        buff.append(\": \");\n+\n+        Iterator it = missingOptions.iterator();\n+        while (it.hasNext())\n+        {\n+            buff.append(it.next());\n+            if (it.hasNext())\n+            {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** <p>Describes a single command-line option.  It maintains\n+ * information regarding the short-name of the option, the long-name,\n+ * if any exists, a flag indicating if an argument is required for\n+ * this option, and a self-documenting description of the option.</p>\n+ *\n+ * <p>An Option is not created independantly, but is create through\n+ * an instance of {@link Options}.<p>\n+ *\n+ * @see org.apache.commons.cli.Options\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision$, $Date$\n+ */\n+public class Option implements Cloneable, Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** constant that specifies the number of argument values has not been specified */\n+    public static final int UNINITIALIZED = -1;\n+\n+    /** constant that specifies the number of argument values is infinite */\n+    public static final int UNLIMITED_VALUES = -2;\n+\n+    /** the name of the option */\n+    private String opt;\n+\n+    /** the long representation of the option */\n+    private String longOpt;\n+\n+    /** the name of the argument for this option */\n+    private String argName = \"arg\";\n+\n+    /** description of the option */\n+    private String description;\n+\n+    /** specifies whether this option is required to be present */\n+    private boolean required;\n+\n+    /** specifies whether the argument value of this Option is optional */\n+    private boolean optionalArg;\n+\n+    /** the number of argument values this option can have */\n+    private int numberOfArgs = UNINITIALIZED;\n+\n+    /** the type of this Option */\n+    private Object type;\n+\n+    /** the list of argument values **/\n+    private List values = new ArrayList();\n+\n+    /** the character that is the value separator */\n+    private char valuesep;\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String description) throws IllegalArgumentException\n+    {\n+        this(opt, null, false, description);\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n+    {\n+        this(opt, null, hasArg, description);\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param longOpt the long representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String longOpt, boolean hasArg, String description)\n+           throws IllegalArgumentException\n+    {\n+        // ensure that the option is valid\n+        OptionValidator.validateOption(opt);\n+\n+        this.opt = opt;\n+        this.longOpt = longOpt;\n+\n+        // if hasArg is set then the number of arguments is 1\n+        if (hasArg)\n+        {\n+            this.numberOfArgs = 1;\n+        }\n+\n+        this.description = description;\n+    }\n+\n+    /**\n+     * Returns the id of this Option.  This is only set when the\n+     * Option shortOpt is a single character.  This is used for switch\n+     * statements.\n+     *\n+     * @return the id of this Option\n+     */\n+    public int getId()\n+    {\n+        return getKey().charAt(0);\n+    }\n+\n+    /**\n+     * Returns the 'unique' Option identifier.\n+     * \n+     * @return the 'unique' Option identifier\n+     */\n+    String getKey()\n+    {\n+        // if 'opt' is null, then it is a 'long' option\n+        if (opt == null)\n+        {\n+            return longOpt;\n+        }\n+\n+        return opt;\n+    }\n+\n+    /** \n+     * Retrieve the name of this Option.\n+     *\n+     * It is this String which can be used with\n+     * {@link CommandLine#hasOption(String opt)} and\n+     * {@link CommandLine#getOptionValue(String opt)} to check\n+     * for existence and argument.\n+     *\n+     * @return The name of this option\n+     */\n+    public String getOpt()\n+    {\n+        return opt;\n+    }\n+\n+    /**\n+     * Retrieve the type of this Option.\n+     * \n+     * @return The type of this option\n+     */\n+    public Object getType()\n+    {\n+        return type;\n+    }\n+\n+    /**\n+     * Sets the type of this Option.\n+     *\n+     * @param type the type of this Option\n+     */\n+    public void setType(Object type)\n+    {\n+        this.type = type;\n+    }\n+\n+    /** \n+     * Retrieve the long name of this Option.\n+     *\n+     * @return Long name of this option, or null, if there is no long name\n+     */\n+    public String getLongOpt()\n+    {\n+        return longOpt;\n+    }\n+\n+    /**\n+     * Sets the long name of this Option.\n+     *\n+     * @param longOpt the long name of this Option\n+     */\n+    public void setLongOpt(String longOpt)\n+    {\n+        this.longOpt = longOpt;\n+    }\n+\n+    /**\n+     * Sets whether this Option can have an optional argument.\n+     *\n+     * @param optionalArg specifies whether the Option can have\n+     * an optional argument.\n+     */\n+    public void setOptionalArg(boolean optionalArg)\n+    {\n+        this.optionalArg = optionalArg;\n+    }\n+\n+    /**\n+     * @return whether this Option can have an optional argument\n+     */\n+    public boolean hasOptionalArg()\n+    {\n+        return optionalArg;\n+    }\n+\n+    /** \n+     * Query to see if this Option has a long name\n+     *\n+     * @return boolean flag indicating existence of a long name\n+     */\n+    public boolean hasLongOpt()\n+    {\n+        return longOpt != null;\n+    }\n+\n+    /** \n+     * Query to see if this Option requires an argument\n+     *\n+     * @return boolean flag indicating if an argument is required\n+     */\n+    public boolean hasArg()\n+    {\n+        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n+    }\n+\n+    /** \n+     * Retrieve the self-documenting description of this Option\n+     *\n+     * @return The string description of this option\n+     */\n+    public String getDescription()\n+    {\n+        return description;\n+    }\n+\n+    /**\n+     * Sets the self-documenting description of this Option\n+     *\n+     * @param description The description of this option\n+     * @since 1.1\n+     */\n+    public void setDescription(String description)\n+    {\n+        this.description = description;\n+    }\n+\n+    /** \n+     * Query to see if this Option requires an argument\n+     *\n+     * @return boolean flag indicating if an argument is required\n+     */\n+    public boolean isRequired()\n+    {\n+        return required;\n+    }\n+\n+    /**\n+     * Sets whether this Option is mandatory.\n+     *\n+     * @param required specifies whether this Option is mandatory\n+     */\n+    public void setRequired(boolean required)\n+    {\n+        this.required = required;\n+    }\n+\n+    /**\n+     * Sets the display name for the argument value.\n+     *\n+     * @param argName the display name for the argument value.\n+     */\n+    public void setArgName(String argName)\n+    {\n+        this.argName = argName;\n+    }\n+\n+    /**\n+     * Gets the display name for the argument value.\n+     *\n+     * @return the display name for the argument value.\n+     */\n+    public String getArgName()\n+    {\n+        return argName;\n+    }\n+\n+    /**\n+     * Returns whether the display name for the argument value\n+     * has been set.\n+     *\n+     * @return if the display name for the argument value has been\n+     * set.\n+     */\n+    public boolean hasArgName()\n+    {\n+        return argName != null && argName.length() > 0;\n+    }\n+\n+    /** \n+     * Query to see if this Option can take many values.\n+     *\n+     * @return boolean flag indicating if multiple values are allowed\n+     */\n+    public boolean hasArgs()\n+    {\n+        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n+    }\n+\n+    /** \n+     * Sets the number of argument values this Option can take.\n+     *\n+     * @param num the number of argument values\n+     */\n+    public void setArgs(int num)\n+    {\n+        this.numberOfArgs = num;\n+    }\n+\n+    /**\n+     * Sets the value separator.  For example if the argument value\n+     * was a Java property, the value separator would be '='.\n+     *\n+     * @param sep The value separator.\n+     */\n+    public void setValueSeparator(char sep)\n+    {\n+        this.valuesep = sep;\n+    }\n+\n+    /**\n+     * Returns the value separator character.\n+     *\n+     * @return the value separator character.\n+     */\n+    public char getValueSeparator()\n+    {\n+        return valuesep;\n+    }\n+\n+    /**\n+     * Return whether this Option has specified a value separator.\n+     * \n+     * @return whether this Option has specified a value separator.\n+     * @since 1.1\n+     */\n+    public boolean hasValueSeparator()\n+    {\n+        return valuesep > 0;\n+    }\n+\n+    /** \n+     * Returns the number of argument values this Option can take.\n+     *\n+     * @return num the number of argument values\n+     */\n+    public int getArgs()\n+    {\n+        return numberOfArgs;\n+    }\n+\n+    /**\n+     * Adds the specified value to this Option.\n+     * \n+     * @param value is a/the value of this Option\n+     */\n+    void addValueForProcessing(String value)\n+    {\n+        switch (numberOfArgs)\n+        {\n+            case UNINITIALIZED:\n+                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n+\n+            default:\n+                processValue(value);\n+        }\n+    }\n+\n+    /**\n+     * Processes the value.  If this Option has a value separator\n+     * the value will have to be parsed into individual tokens.  When\n+     * n-1 tokens have been processed and there are more value separators\n+     * in the value, parsing is ceased and the remaining characters are\n+     * added as a single token.\n+     *\n+     * @param value The String to be processed.\n+     *\n+     * @since 1.0.1\n+     */\n+    private void processValue(String value)\n+    {\n+        // this Option has a separator character\n+        if (hasValueSeparator())\n+        {\n+            // get the separator character\n+            char sep = getValueSeparator();\n+\n+            // store the index for the value separator\n+            int index = value.indexOf(sep);\n+\n+            // while there are more value separators\n+            while (index != -1)\n+            {\n+                // next value to be added \n+                if (values.size() == (numberOfArgs - 1))\n+                {\n+                    break;\n+                }\n+\n+                // store\n+                add(value.substring(0, index));\n+\n+                // parse\n+                value = value.substring(index + 1);\n+\n+                // get new index\n+                index = value.indexOf(sep);\n+            }\n+        }\n+\n+        // store the actual value or the last value that has been parsed\n+        add(value);\n+    }\n+\n+    /**\n+     * Add the value to this Option.  If the number of arguments\n+     * is greater than zero and there is enough space in the list then\n+     * add the value.  Otherwise, throw a runtime exception.\n+     *\n+     * @param value The value to be added to this Option\n+     *\n+     * @since 1.0.1\n+     */\n+    private void add(String value)\n+    {\n+        if (!acceptsArg())\n+        {\n+            throw new RuntimeException(\"Cannot add value, list full.\");\n+        }\n+\n+        // store value\n+        values.add(value);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @return the value/first value of this Option or \n+     * <code>null</code> if there is no value.\n+     */\n+    public String getValue()\n+    {\n+        return hasNoValues() ? null : (String) values.get(0);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @param index The index of the value to be returned.\n+     *\n+     * @return the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @throws IndexOutOfBoundsException if index is less than 1\n+     * or greater than the number of the values for this Option.\n+     */\n+    public String getValue(int index) throws IndexOutOfBoundsException\n+    {\n+        return hasNoValues() ? null : (String) values.get(index);\n+    }\n+\n+    /**\n+     * Returns the value/first value of this Option or the \n+     * <code>defaultValue</code> if there is no value.\n+     *\n+     * @param defaultValue The value to be returned if ther\n+     * is no value.\n+     *\n+     * @return the value/first value of this Option or the \n+     * <code>defaultValue</code> if there are no values.\n+     */\n+    public String getValue(String defaultValue)\n+    {\n+        String value = getValue();\n+\n+        return (value != null) ? value : defaultValue;\n+    }\n+\n+    /**\n+     * Return the values of this Option as a String array \n+     * or null if there are no values\n+     *\n+     * @return the values of this Option as a String array \n+     * or null if there are no values\n+     */\n+    public String[] getValues()\n+    {\n+        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n+    }\n+\n+    /**\n+     * @return the values of this Option as a List\n+     * or null if there are no values\n+     */\n+    public List getValuesList()\n+    {\n+        return values;\n+    }\n+\n+    /** \n+     * Dump state, suitable for debugging.\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n+\n+        buf.append(opt);\n+\n+        if (longOpt != null)\n+        {\n+            buf.append(\" \").append(longOpt);\n+        }\n+\n+        buf.append(\" \");\n+\n+        if (hasArgs())\n+        {\n+            buf.append(\"[ARG...]\");\n+        }\n+        else if (hasArg())\n+        {\n+            buf.append(\" [ARG]\");\n+        }\n+\n+        buf.append(\" :: \").append(description);\n+\n+        if (type != null)\n+        {\n+            buf.append(\" :: \").append(type);\n+        }\n+\n+        buf.append(\" ]\");\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns whether this Option has any values.\n+     *\n+     * @return whether this Option has any values.\n+     */\n+    private boolean hasNoValues()\n+    {\n+        return values.isEmpty();\n+    }\n+\n+    public boolean equals(Object o)\n+    {\n+        if (this == o)\n+        {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass())\n+        {\n+            return false;\n+        }\n+\n+        Option option = (Option) o;\n+\n+\n+        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n+        {\n+            return false;\n+        }\n+        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public int hashCode()\n+    {\n+        int result;\n+        result = (opt != null ? opt.hashCode() : 0);\n+        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n+        return result;\n+    }\n+\n+    /**\n+     * A rather odd clone method - due to incorrect code in 1.0 it is public \n+     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n+     * a RuntimeException so as to maintain backwards compat at the API level. \n+     *\n+     * After calling this method, it is very likely you will want to call \n+     * clearValues(). \n+     *\n+     * @throws RuntimeException\n+     */\n+    public Object clone()\n+    {\n+        try\n+        {\n+            Option option = (Option) super.clone();\n+            option.values = new ArrayList(values);\n+            return option;\n+        }\n+        catch (CloneNotSupportedException cnse)\n+        {\n+            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Clear the Option values. After a parse is complete, these are left with\n+     * data in them and they need clearing if another parse is done.\n+     *\n+     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n+     */\n+    void clearValues()\n+    {\n+        values.clear();\n+    }\n+\n+    /**\n+     * This method is not intended to be used. It was a piece of internal \n+     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n+     * @deprecated\n+     * @throws UnsupportedOperationException\n+     */\n+    public boolean addValue(String value)\n+    {\n+        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n+                + \"Subclasses should use the addValueForProcessing method instead. \");\n+    }\n+\n+    /**\n+     * Tells if the option can accept more arguments.\n+     * \n+     * @return false if the maximum number of arguments is reached\n+     * @since 1.3\n+     */\n+    boolean acceptsArg()\n+    {\n+        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n+    }\n+\n+    /**\n+     * Tells if the option requires more arguments to be valid.\n+     * \n+     * @return false if the option doesn't require more arguments\n+     * @since 1.3\n+     */\n+    boolean requiresArg()\n+    {\n+        if (optionalArg)\n+        {\n+            return false;\n+        }\n+        if (numberOfArgs == UNLIMITED_VALUES)\n+        {\n+            return values.size() < 1;\n+        }\n+        else\n+        {\n+            return acceptsArg();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/OptionBuilder.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * OptionBuilder allows the user to create Options using descriptive methods.\n+ *\n+ * <p>Details on the Builder pattern can be found at\n+ * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n+ * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @since 1.0\n+ */\n+public final class OptionBuilder\n+{\n+    /** long option */\n+    private static String longopt;\n+\n+    /** option description */\n+    private static String description;\n+\n+    /** argument name */\n+    private static String argName;\n+\n+    /** is required? */\n+    private static boolean required;\n+\n+    /** the number of arguments */\n+    private static int numberOfArgs = Option.UNINITIALIZED;\n+\n+    /** option type */\n+    private static Object type;\n+\n+    /** option can have an optional argument value */\n+    private static boolean optionalArg;\n+\n+    /** value separator for argument value */\n+    private static char valuesep;\n+\n+    /** option builder instance */\n+    private static OptionBuilder instance = new OptionBuilder();\n+\n+    /**\n+     * private constructor to prevent instances being created\n+     */\n+    private OptionBuilder()\n+    {\n+        // hide the constructor\n+    }\n+\n+    /**\n+     * Resets the member variables to their default values.\n+     */\n+    private static void reset()\n+    {\n+        description = null;\n+        argName = \"arg\";\n+        longopt = null;\n+        type = null;\n+        required = false;\n+        numberOfArgs = Option.UNINITIALIZED;\n+\n+\n+        // PMM 9/6/02 - these were missing\n+        optionalArg = false;\n+        valuesep = (char) 0;\n+    }\n+\n+    /**\n+     * The next Option created will have the following long option value.\n+     *\n+     * @param newLongopt the long option value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withLongOpt(String newLongopt)\n+    {\n+        OptionBuilder.longopt = newLongopt;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will require an argument value.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArg()\n+    {\n+        OptionBuilder.numberOfArgs = 1;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will require an argument value if\n+     * <code>hasArg</code> is true.\n+     *\n+     * @param hasArg if true then the Option has an argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArg(boolean hasArg)\n+    {\n+        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have the specified argument value name.\n+     *\n+     * @param name the name for the argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withArgName(String name)\n+    {\n+        OptionBuilder.argName = name;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will be required.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder isRequired()\n+    {\n+        OptionBuilder.required = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created uses <code>sep</code> as a means to\n+     * separate argument values.\n+     *\n+     * <b>Example:</b>\n+     * <pre>\n+     * Option opt = OptionBuilder.withValueSeparator(':')\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n+     * </pre>\n+     *\n+     * @param sep The value separator to be used for the argument values.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withValueSeparator(char sep)\n+    {\n+        OptionBuilder.valuesep = sep;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created uses '<code>=</code>' as a means to\n+     * separate argument values.\n+     *\n+     * <b>Example:</b>\n+     * <pre>\n+     * Option opt = OptionBuilder.withValueSeparator()\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n+     * </pre>\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withValueSeparator()\n+    {\n+        OptionBuilder.valuesep = '=';\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will be required if <code>required</code>\n+     * is true.\n+     *\n+     * @param newRequired if true then the Option is required\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder isRequired(boolean newRequired)\n+    {\n+        OptionBuilder.required = newRequired;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created can have unlimited argument values.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArgs()\n+    {\n+        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created can have <code>num</code> argument values.\n+     *\n+     * @param num the number of args that the option can have\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasArgs(int num)\n+    {\n+        OptionBuilder.numberOfArgs = num;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have an optional argument.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArg()\n+    {\n+        OptionBuilder.numberOfArgs = 1;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have an unlimited number of optional arguments.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArgs()\n+    {\n+        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option can have the specified number of optional arguments.\n+     *\n+     * @param numArgs - the maximum number of optional arguments\n+     * the next Option created can have.\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder hasOptionalArgs(int numArgs)\n+    {\n+        OptionBuilder.numberOfArgs = numArgs;\n+        OptionBuilder.optionalArg = true;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have a value that will be an instance\n+     * of <code>type</code>.\n+     *\n+     * @param newType the type of the Options argument value\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withType(Object newType)\n+    {\n+        OptionBuilder.type = newType;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have the specified description\n+     *\n+     * @param newDescription a description of the Option's purpose\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withDescription(String newDescription)\n+    {\n+        OptionBuilder.description = newDescription;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * Create an Option using the current settings and with\n+     * the specified Option <code>char</code>.\n+     *\n+     * @param opt the character representation of the Option\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>opt</code> is not\n+     * a valid character.  See Option.\n+     */\n+    public static Option create(char opt) throws IllegalArgumentException\n+    {\n+        return create(String.valueOf(opt));\n+    }\n+\n+    /**\n+     * Create an Option using the current settings\n+     *\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n+     */\n+    public static Option create() throws IllegalArgumentException\n+    {\n+        if (longopt == null)\n+        {\n+            OptionBuilder.reset();\n+            throw new IllegalArgumentException(\"must specify longopt\");\n+        }\n+\n+        return create(null);\n+    }\n+\n+    /**\n+     * Create an Option using the current settings and with\n+     * the specified Option <code>char</code>.\n+     *\n+     * @param opt the <code>java.lang.String</code> representation\n+     * of the Option\n+     * @return the Option instance\n+     * @throws IllegalArgumentException if <code>opt</code> is not\n+     * a valid character.  See Option.\n+     */\n+    public static Option create(String opt) throws IllegalArgumentException\n+    {\n+        Option option = null;\n+        try {\n+            // create the option\n+            option = new Option(opt, description);\n+\n+            // set the option properties\n+            option.setLongOpt(longopt);\n+            option.setRequired(required);\n+            option.setOptionalArg(optionalArg);\n+            option.setArgs(numberOfArgs);\n+            option.setType(type);\n+            option.setValueSeparator(valuesep);\n+            option.setArgName(argName);\n+        } finally {\n+            // reset the OptionBuilder properties\n+            OptionBuilder.reset();\n+        }\n+\n+        // return the Option instance\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/OptionGroup.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * A group of mutually exclusive options.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ */\n+public class OptionGroup implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+    \n+    /** hold the options */\n+    private Map optionMap = new HashMap();\n+\n+    /** the name of the selected option */\n+    private String selected;\n+\n+    /** specified whether this group is required */\n+    private boolean required;\n+\n+    /**\n+     * Add the specified <code>Option</code> to this group.\n+     *\n+     * @param option the option to add to this group\n+     * @return this option group with the option added\n+     */\n+    public OptionGroup addOption(Option option)\n+    {\n+        // key   - option name\n+        // value - the option\n+        optionMap.put(option.getKey(), option);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * @return the names of the options in this group as a \n+     * <code>Collection</code>\n+     */\n+    public Collection getNames()\n+    {\n+        // the key set is the collection of names\n+        return optionMap.keySet();\n+    }\n+\n+    /**\n+     * @return the options in this group as a <code>Collection</code>\n+     */\n+    public Collection getOptions()\n+    {\n+        // the values are the collection of options\n+        return optionMap.values();\n+    }\n+\n+    /**\n+     * Set the selected option of this group to <code>name</code>.\n+     *\n+     * @param option the option that is selected\n+     * @throws AlreadySelectedException if an option from this group has \n+     * already been selected.\n+     */\n+    public void setSelected(Option option) throws AlreadySelectedException\n+    {\n+        if (option == null)\n+        {\n+            // reset the option previously selected\n+            selected = null;\n+            return;\n+        }\n+        \n+        // if no option has already been selected or the \n+        // same option is being reselected then set the\n+        // selected member variable\n+        if (selected == null || selected.equals(option.getKey()))\n+        {\n+            selected = option.getKey();\n+        }\n+        else\n+        {\n+            throw new AlreadySelectedException(this, option);\n+        }\n+    }\n+\n+    /**\n+     * @return the selected option name\n+     */\n+    public String getSelected()\n+    {\n+        return selected;\n+    }\n+\n+    /**\n+     * @param required specifies if this group is required\n+     */\n+    public void setRequired(boolean required)\n+    {\n+        this.required = required;\n+    }\n+\n+    /**\n+     * Returns whether this option group is required.\n+     *\n+     * @return whether this option group is required\n+     */\n+    public boolean isRequired()\n+    {\n+        return required;\n+    }\n+\n+    /**\n+     * Returns the stringified version of this OptionGroup.\n+     * \n+     * @return the stringified representation of this group\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buff = new StringBuffer();\n+\n+        Iterator iter = getOptions().iterator();\n+\n+        buff.append(\"[\");\n+\n+        while (iter.hasNext())\n+        {\n+            Option option = (Option) iter.next();\n+\n+            if (option.getOpt() != null)\n+            {\n+                buff.append(\"-\");\n+                buff.append(option.getOpt());\n+            }\n+            else\n+            {\n+                buff.append(\"--\");\n+                buff.append(option.getLongOpt());\n+            }\n+\n+            buff.append(\" \");\n+            buff.append(option.getDescription());\n+\n+            if (iter.hasNext())\n+            {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        buff.append(\"]\");\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/OptionValidator.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Validates an Option string.\n+ *\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n+ * @since 1.1\n+ */\n+class OptionValidator\n+{\n+    /**\n+     * Validates whether <code>opt</code> is a permissable Option\n+     * shortOpt.  The rules that specify if the <code>opt</code>\n+     * is valid are:\n+     *\n+     * <ul>\n+     *  <li><code>opt</code> is not NULL</li>\n+     *  <li>a single character <code>opt</code> that is either\n+     *  ' '(special case), '?', '@' or a letter</li>\n+     *  <li>a multi character <code>opt</code> that only contains\n+     *  letters.</li>\n+     * </ul>\n+     *\n+     * @param opt The option string to validate\n+     * @throws IllegalArgumentException if the Option is not valid.\n+     */\n+    static void validateOption(String opt) throws IllegalArgumentException\n+    {\n+        // check that opt is not NULL\n+        if (opt == null)\n+        {\n+            return;\n+        }\n+\n+        // handle the single character opt\n+        else if (opt.length() == 1)\n+        {\n+            char ch = opt.charAt(0);\n+\n+            if (!isValidOpt(ch))\n+            {\n+                throw new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n+            }\n+        }\n+\n+        // handle the multi character opt\n+        else\n+        {\n+            char[] chars = opt.toCharArray();\n+\n+            for (int i = 0; i < chars.length; i++)\n+            {\n+                if (!isValidChar(chars[i]))\n+                {\n+                    throw new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the specified character is a valid Option.\n+     *\n+     * @param c the option to validate\n+     * @return true if <code>c</code> is a letter, ' ', '?' or '@',\n+     *         otherwise false.\n+     */\n+    private static boolean isValidOpt(char c)\n+    {\n+        return isValidChar(c) || c == ' ' || c == '?' || c == '@';\n+    }\n+\n+    /**\n+     * Returns whether the specified character is a valid character.\n+     *\n+     * @param c the character to validate\n+     * @return true if <code>c</code> is a letter.\n+     */\n+    private static boolean isValidChar(char c)\n+    {\n+        return Character.isJavaIdentifierPart(c);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Main entry-point into the library.</p>\n+ *\n+ * <p>Options represents a collection of {@link Option} objects, which\n+ * describe the possible options for a command-line.<p>\n+ *\n+ * <p>It may flexibly parse long and short options, with or without\n+ * values.  Additionally, it may parse only a portion of a commandline,\n+ * allowing for flexible multi-stage parsing.<p>\n+ *\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision$, $Date$\n+ */\n+public class Options implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /** a map of the options with the character key */\n+    private Map shortOpts = new HashMap();\n+\n+    /** a map of the options with the long key */\n+    private Map longOpts = new HashMap();\n+\n+    /** a map of the required options */\n+    private List requiredOpts = new ArrayList();\n+\n+    /** a map of the option groups */\n+    private Map optionGroups = new HashMap();\n+\n+    /**\n+     * Add the specified option group.\n+     *\n+     * @param group the OptionGroup that is to be added\n+     * @return the resulting Options instance\n+     */\n+    public Options addOptionGroup(OptionGroup group)\n+    {\n+        Iterator options = group.getOptions().iterator();\n+\n+        if (group.isRequired())\n+        {\n+            requiredOpts.add(group);\n+        }\n+\n+        while (options.hasNext())\n+        {\n+            Option option = (Option) options.next();\n+\n+            // an Option cannot be required if it is in an\n+            // OptionGroup, either the group is required or\n+            // nothing is required\n+            option.setRequired(false);\n+            addOption(option);\n+\n+            optionGroups.put(option.getKey(), group);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Lists the OptionGroups that are members of this Options instance.\n+     *\n+     * @return a Collection of OptionGroup instances.\n+     */\n+    Collection getOptionGroups()\n+    {\n+        return new HashSet(optionGroups.values());\n+    }\n+\n+    /**\n+     * Add an option that only contains a short-name.\n+     * It may be specified as requiring an argument.\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(String opt, boolean hasArg, String description)\n+    {\n+        addOption(opt, null, hasArg, description);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Add an option that contains a short-name and a long-name.\n+     * It may be specified as requiring an argument.\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param longOpt Long multi-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n+    {\n+        addOption(new Option(opt, longOpt, hasArg, description));\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an option instance\n+     *\n+     * @param opt the option that is to be added\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(Option opt)\n+    {\n+        String key = opt.getKey();\n+\n+        // add it to the long option list\n+        if (opt.hasLongOpt())\n+        {\n+            longOpts.put(opt.getLongOpt(), opt);\n+        }\n+\n+        // if the option is required add it to the required list\n+        if (opt.isRequired())\n+        {\n+            if (requiredOpts.contains(key))\n+            {\n+                requiredOpts.remove(requiredOpts.indexOf(key));\n+            }\n+            requiredOpts.add(key);\n+        }\n+\n+        shortOpts.put(key, opt);\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieve a read-only list of options in this set\n+     *\n+     * @return read-only Collection of {@link Option} objects in this descriptor\n+     */\n+    public Collection getOptions()\n+    {\n+        return Collections.unmodifiableCollection(helpOptions());\n+    }\n+\n+    /**\n+     * Returns the Options for use by the HelpFormatter.\n+     *\n+     * @return the List of Options\n+     */\n+    List helpOptions()\n+    {\n+        return new ArrayList(shortOpts.values());\n+    }\n+\n+    /**\n+     * Returns the required options.\n+     *\n+     * @return List of required options\n+     */\n+    public List getRequiredOptions()\n+    {\n+        return requiredOpts;\n+    }\n+\n+    /**\n+     * Retrieve the {@link Option} matching the long or short name specified.\n+     * The leading hyphens in the name are ignored (up to 2).\n+     *\n+     * @param opt short or long name of the {@link Option}\n+     * @return the option represented by opt\n+     */\n+    public Option getOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        if (shortOpts.containsKey(opt))\n+        {\n+            return (Option) shortOpts.get(opt);\n+        }\n+\n+        return (Option) longOpts.get(opt);\n+    }\n+\n+    /**\n+     * Returns the options with a long name starting with the name specified.\n+     * \n+     * @param opt the partial name of the option\n+     * @return the options matching the partial name specified, or an empty list if none matches\n+     * @since 1.3\n+     */\n+    public List getMatchingOptions(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+        \n+        List matchingOpts = new ArrayList();\n+        \n+        Iterator it = longOpts.keySet().iterator();\n+        while (it.hasNext())\n+        {\n+            String longOpt = (String) it.next();\n+            if (longOpt.startsWith(opt))\n+            {\n+                matchingOpts.add(longOpt);\n+            }\n+        }        \n+        \n+        return matchingOpts;\n+    }\n+\n+    /**\n+     * Returns whether the named {@link Option} is a member of this {@link Options}.\n+     *\n+     * @param opt short or long name of the {@link Option}\n+     * @return true if the named {@link Option} is a member of this {@link Options}\n+     */\n+    public boolean hasOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n+    }\n+\n+    /**\n+     * Returns whether the named {@link Option} is a member of this {@link Options}.\n+     *\n+     * @param opt long name of the {@link Option}\n+     * @return true if the named {@link Option} is a member of this {@link Options}\n+     * @since 1.3\n+     */\n+    public boolean hasLongOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        return longOpts.containsKey(opt);\n+    }\n+\n+    /**\n+     * Returns whether the named {@link Option} is a member of this {@link Options}.\n+     *\n+     * @param opt short name of the {@link Option}\n+     * @return true if the named {@link Option} is a member of this {@link Options}\n+     * @since 1.3\n+     */\n+    public boolean hasShortOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        return shortOpts.containsKey(opt);\n+    }\n+\n+    /**\n+     * Returns the OptionGroup the <code>opt</code> belongs to.\n+     * @param opt the option whose OptionGroup is being queried.\n+     *\n+     * @return the OptionGroup if <code>opt</code> is part\n+     * of an OptionGroup, otherwise return null\n+     */\n+    public OptionGroup getOptionGroup(Option opt)\n+    {\n+        return (OptionGroup) optionGroups.get(opt.getKey());\n+    }\n+\n+    /**\n+     * Dump state, suitable for debugging.\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString()\n+    {\n+        StringBuffer buf = new StringBuffer();\n+\n+        buf.append(\"[ Options: [ short \");\n+        buf.append(shortOpts.toString());\n+        buf.append(\" ] [ long \");\n+        buf.append(longOpts);\n+        buf.append(\" ]\");\n+\n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/ParseException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Base for Exceptions thrown during parsing of a command-line.\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class ParseException extends Exception\n+{\n+    /**\n+     * Construct a new <code>ParseException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public ParseException(String message)\n+    {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/Parser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Properties;\n+\n+/**\n+ * <code>Parser</code> creates {@link CommandLine}s.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n+ */\n+public abstract class Parser implements CommandLineParser\n+{\n+    /** commandline instance */\n+    protected CommandLine cmd;\n+\n+    /** current Options */\n+    private Options options;\n+\n+    /** list of required options strings */\n+    private List requiredOptions;\n+\n+    protected void setOptions(final Options options)\n+    {\n+        this.options = options;\n+        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n+    }\n+\n+    protected Options getOptions()\n+    {\n+        return options;\n+    }\n+\n+    protected List getRequiredOptions()\n+    {\n+        return requiredOptions;\n+    }\n+\n+    /**\n+     * Subclasses must implement this method to reduce\n+     * the <code>arguments</code> that have been passed to the parse method.\n+     *\n+     * @param opts The Options to parse the arguments by.\n+     * @param arguments The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop\n+     * flattening when a non option has been encountered\n+     * @return a String array of the flattened arguments\n+     */\n+    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n+\n+    /**\n+     * Parses the specified <code>arguments</code> based\n+     * on the specifed {@link Options}.\n+     *\n+     * @param options the <code>Options</code>\n+     * @param arguments the <code>arguments</code>\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the\n+     * arguments.\n+     */\n+    public CommandLine parse(Options options, String[] arguments) throws ParseException\n+    {\n+        return parse(options, arguments, null, false);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param options    the specified Options\n+     * @param arguments  the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @return the list of atomic option and value tokens\n+     * @throws ParseException if there are any problems encountered\n+     *                        while parsing the command line tokens.\n+     *\n+     * @since 1.1\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n+    {\n+        return parse(options, arguments, properties, false);\n+    }\n+\n+    /**\n+     * Parses the specified <code>arguments</code>\n+     * based on the specifed {@link Options}.\n+     *\n+     * @param options         the <code>Options</code>\n+     * @param arguments       the <code>arguments</code>\n+     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n+     *     the parsing and the remaining arguments are added to the \n+     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n+     *     argument triggers a ParseException.\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the arguments.\n+     */\n+    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n+    {\n+        return parse(options, arguments, null, stopAtNonOption);\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and\n+     * properties.\n+     *\n+     * @param options the specified Options\n+     * @param arguments the command line arguments\n+     * @param properties command line option name-value pairs\n+     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n+     *     the parsing and the remaining arguments are added to the \n+     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n+     *     argument triggers a ParseException.\n+     *\n+     * @return the list of atomic option and value tokens\n+     *\n+     * @throws ParseException if there are any problems encountered\n+     * while parsing the command line tokens.\n+     *\n+     * @since 1.1\n+     */\n+    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException\n+    {\n+        // clear out the data in options in case it's been used before (CLI-71)\n+        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n+        {\n+            Option opt = (Option) it.next();\n+            opt.clearValues();\n+        }\n+        \n+        // clear the data from the groups\n+        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n+        {\n+            OptionGroup group = (OptionGroup) it.next();\n+            group.setSelected(null);\n+        }        \n+\n+        // initialise members\n+        setOptions(options);\n+\n+        cmd = new CommandLine();\n+\n+        boolean eatTheRest = false;\n+\n+        if (arguments == null)\n+        {\n+            arguments = new String[0];\n+        }\n+\n+        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n+\n+        ListIterator iterator = tokenList.listIterator();\n+\n+        // process each flattened token\n+        while (iterator.hasNext())\n+        {\n+            String t = (String) iterator.next();\n+\n+            // the value is the double-dash\n+            if (\"--\".equals(t))\n+            {\n+                eatTheRest = true;\n+            }\n+\n+            // the value is a single dash\n+            else if (\"-\".equals(t))\n+            {\n+                if (stopAtNonOption)\n+                {\n+                    eatTheRest = true;\n+                }\n+                else\n+                {\n+                    cmd.addArg(t);\n+                }\n+            }\n+\n+            // the value is an option\n+            else if (t.startsWith(\"-\"))\n+            {\n+                if (stopAtNonOption && !getOptions().hasOption(t))\n+                {\n+                    eatTheRest = true;\n+                    cmd.addArg(t);\n+                }\n+                else\n+                {\n+                    processOption(t, iterator);\n+                }\n+            }\n+\n+            // the value is an argument\n+            else\n+            {\n+                cmd.addArg(t);\n+\n+                if (stopAtNonOption)\n+                {\n+                    eatTheRest = true;\n+                }\n+            }\n+\n+            // eat the remaining tokens\n+            if (eatTheRest)\n+            {\n+                while (iterator.hasNext())\n+                {\n+                    String str = (String) iterator.next();\n+\n+                    // ensure only one double-dash is added\n+                    if (!\"--\".equals(str))\n+                    {\n+                        cmd.addArg(str);\n+                    }\n+                }\n+            }\n+        }\n+\n+        processProperties(properties);\n+        checkRequiredOptions();\n+\n+        return cmd;\n+    }\n+\n+    /**\n+     * Sets the values of Options using the values in <code>properties</code>.\n+     *\n+     * @param properties The value properties to be processed.\n+     */\n+    protected void processProperties(Properties properties)\n+    {\n+        if (properties == null)\n+        {\n+            return;\n+        }\n+\n+        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n+        {\n+            String option = e.nextElement().toString();\n+\n+            if (!cmd.hasOption(option))\n+            {\n+                Option opt = getOptions().getOption(option);\n+\n+                // get the value from the properties instance\n+                String value = properties.getProperty(option);\n+\n+                if (opt.hasArg())\n+                {\n+                    if (opt.getValues() == null || opt.getValues().length == 0)\n+                    {\n+                        try\n+                        {\n+                            opt.addValueForProcessing(value);\n+                        }\n+                        catch (RuntimeException exp)\n+                        {\n+                            // if we cannot add the value don't worry about it\n+                        }\n+                    }\n+                }\n+                else if (!(\"yes\".equalsIgnoreCase(value)\n+                        || \"true\".equalsIgnoreCase(value)\n+                        || \"1\".equalsIgnoreCase(value)))\n+                {\n+                    // if the value is not yes, true or 1 then don't add the\n+                    // option to the CommandLine\n+                    continue;\n+                }\n+\n+                cmd.addOption(opt);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throws a {@link MissingOptionException} if all of the required options\n+     * are not present.\n+     *\n+     * @throws MissingOptionException if any of the required Options\n+     * are not present.\n+     */\n+    protected void checkRequiredOptions() throws MissingOptionException\n+    {\n+        // if there are required options that have not been processsed\n+        if (!getRequiredOptions().isEmpty())\n+        {\n+            throw new MissingOptionException(getRequiredOptions());\n+        }\n+    }\n+\n+    /**\n+     * <p>Process the argument values for the specified Option\n+     * <code>opt</code> using the values retrieved from the\n+     * specified iterator <code>iter</code>.\n+     *\n+     * @param opt The current Option\n+     * @param iter The iterator over the flattened command line\n+     * Options.\n+     *\n+     * @throws ParseException if an argument value is required\n+     * and it is has not been found.\n+     */\n+    public void processArgs(Option opt, ListIterator iter) throws ParseException\n+    {\n+        // loop until an option is found\n+        while (iter.hasNext())\n+        {\n+            String str = (String) iter.next();\n+\n+            // found an Option, not an argument\n+            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n+            {\n+                iter.previous();\n+                break;\n+            }\n+\n+            // found a value\n+            try\n+            {\n+                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n+            }\n+            catch (RuntimeException exp)\n+            {\n+                iter.previous();\n+                break;\n+            }\n+        }\n+\n+        if (opt.getValues() == null && !opt.hasOptionalArg())\n+        {\n+            throw new MissingArgumentException(opt);\n+        }\n+    }\n+\n+    /**\n+     * Process the Option specified by <code>arg</code> using the values\n+     * retrieved from the specfied iterator <code>iter</code>.\n+     *\n+     * @param arg The String value representing an Option\n+     * @param iter The iterator over the flattened command line arguments.\n+     *\n+     * @throws ParseException if <code>arg</code> does not represent an Option\n+     */\n+    protected void processOption(String arg, ListIterator iter) throws ParseException\n+    {\n+        boolean hasOption = getOptions().hasOption(arg);\n+\n+        // if there is no option throw an UnrecognisedOptionException\n+        if (!hasOption)\n+        {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n+        }\n+\n+        // get the option represented by arg\n+        Option opt = (Option) getOptions().getOption(arg).clone();\n+\n+        // if the option is a required option remove the option from\n+        // the requiredOptions list\n+        if (opt.isRequired())\n+        {\n+            getRequiredOptions().remove(opt.getKey());\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected\n+        // option of the group\n+        if (getOptions().getOptionGroup(opt) != null)\n+        {\n+            OptionGroup group = getOptions().getOptionGroup(opt);\n+\n+            if (group.isRequired())\n+            {\n+                getRequiredOptions().remove(group);\n+            }\n+\n+            group.setSelected(opt);\n+        }\n+\n+        // if the option takes an argument value\n+        if (opt.hasArg())\n+        {\n+            processArgs(opt, iter);\n+        }\n+\n+        // set the option on the command line\n+        cmd.addOption(opt);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.net.URL;\n+import java.util.Date;\n+\n+/**\n+ * <p>\n+ * Allows Options to be created from a single String.\n+ * The pattern contains various single character flags and via\n+ * an optional punctuation character, their expected type.\n+ * </p>\n+ *\n+ * <table border=\"1\">\n+ * <tr><td>a</td><td>-a flag</td></tr>\n+ * <tr><td>b@</td><td>-b [classname]</td></tr>\n+ * <tr><td>c&gt;</td><td>-c [filename]</td></tr>\n+ * <tr><td>d+</td><td>-d [classname] (creates object via empty contructor)</td></tr>\n+ * <tr><td>e%</td><td>-e [number] (creates Double/Long instance depeding on existing of a '.')</td></tr>\n+ * <tr><td>f/</td><td>-f [url]</td></tr>\n+ * <tr><td>g:</td><td>-g [string]</td></tr>\n+ * </table>\n+ *\n+ * <p>\n+ * For example, the following allows command line flags of '-v -p string-value -f /dir/file'.\n+ * The exclamation mark precede a mandatory option.\n+ * </p>\n+ * <code>Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");</code>\n+ *\n+ * <p>\n+ * TODO These need to break out to OptionType and also\n+ * to be pluggable.\n+ * </p>\n+ *\n+ * @version $Revision$, $Date$\n+ */\n+public class PatternOptionBuilder\n+{\n+    /** String class */\n+    public static final Class STRING_VALUE = String.class;\n+\n+    /** Object class */\n+    public static final Class OBJECT_VALUE = Object.class;\n+\n+    /** Number class */\n+    public static final Class NUMBER_VALUE = Number.class;\n+\n+    /** Date class */\n+    public static final Class DATE_VALUE = Date.class;\n+\n+    /** Class class */\n+    public static final Class CLASS_VALUE = Class.class;\n+\n+    /// can we do this one??\n+    // is meant to check that the file exists, else it errors.\n+    // ie) it's for reading not writing.\n+\n+    /** FileInputStream class */\n+    public static final Class EXISTING_FILE_VALUE = FileInputStream.class;\n+\n+    /** File class */\n+    public static final Class FILE_VALUE = File.class;\n+\n+    /** File array class */\n+    public static final Class FILES_VALUE = File[].class;\n+\n+    /** URL class */\n+    public static final Class URL_VALUE = URL.class;\n+\n+    /**\n+     * Retrieve the class that <code>ch</code> represents.\n+     *\n+     * @param ch the specified character\n+     * @return The class that <code>ch</code> represents\n+     */\n+    public static Object getValueClass(char ch)\n+    {\n+        switch (ch)\n+        {\n+            case '@':\n+                return PatternOptionBuilder.OBJECT_VALUE;\n+            case ':':\n+                return PatternOptionBuilder.STRING_VALUE;\n+            case '%':\n+                return PatternOptionBuilder.NUMBER_VALUE;\n+            case '+':\n+                return PatternOptionBuilder.CLASS_VALUE;\n+            case '#':\n+                return PatternOptionBuilder.DATE_VALUE;\n+            case '<':\n+                return PatternOptionBuilder.EXISTING_FILE_VALUE;\n+            case '>':\n+                return PatternOptionBuilder.FILE_VALUE;\n+            case '*':\n+                return PatternOptionBuilder.FILES_VALUE;\n+            case '/':\n+                return PatternOptionBuilder.URL_VALUE;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Returns whether <code>ch</code> is a value code, i.e.\n+     * whether it represents a class in a pattern.\n+     *\n+     * @param ch the specified character\n+     * @return true if <code>ch</code> is a value code, otherwise false.\n+     */\n+    public static boolean isValueCode(char ch)\n+    {\n+        return ch == '@'\n+                || ch == ':'\n+                || ch == '%'\n+                || ch == '+'\n+                || ch == '#'\n+                || ch == '<'\n+                || ch == '>'\n+                || ch == '*'\n+                || ch == '/'\n+                || ch == '!';\n+    }\n+\n+    /**\n+     * Returns the {@link Options} instance represented by <code>pattern</code>.\n+     *\n+     * @param pattern the pattern string\n+     * @return The {@link Options} instance\n+     */\n+    public static Options parsePattern(String pattern)\n+    {\n+        char opt = ' ';\n+        boolean required = false;\n+        Object type = null;\n+\n+        Options options = new Options();\n+\n+        for (int i = 0; i < pattern.length(); i++)\n+        {\n+            char ch = pattern.charAt(i);\n+\n+            // a value code comes after an option and specifies\n+            // details about it\n+            if (!isValueCode(ch))\n+            {\n+                if (opt != ' ')\n+                {\n+                    OptionBuilder.hasArg(type != null);\n+                    OptionBuilder.isRequired(required);\n+                    OptionBuilder.withType(type);\n+\n+                    // we have a previous one to deal with\n+                    options.addOption(OptionBuilder.create(opt));\n+                    required = false;\n+                    type = null;\n+                    opt = ' ';\n+                }\n+\n+                opt = ch;\n+            }\n+            else if (ch == '!')\n+            {\n+                required = true;\n+            }\n+            else\n+            {\n+                type = getValueClass(ch);\n+            }\n+        }\n+\n+        if (opt != ' ')\n+        {\n+            OptionBuilder.hasArg(type != null);\n+            OptionBuilder.isRequired(required);\n+            OptionBuilder.withType(type);\n+\n+            // we have a final one to deal with\n+            options.addOption(OptionBuilder.create(opt));\n+        }\n+\n+        return options;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/PosixParser.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * The class PosixParser provides an implementation of the\n+ * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ * @deprecated Use the {@link DefaultParser} instead\n+ */\n+public class PosixParser extends Parser\n+{\n+    /** holder for flattened tokens */\n+    private List tokens = new ArrayList();\n+\n+    /** specifies if bursting should continue */\n+    private boolean eatTheRest;\n+\n+    /** holder for the current option */\n+    private Option currentOption;\n+\n+    /** the command line Options */\n+    private Options options;\n+\n+    /**\n+     * Resets the members to their original state i.e. remove\n+     * all of <code>tokens</code> entries and set <code>eatTheRest</code>\n+     * to false.\n+     */\n+    private void init()\n+    {\n+        eatTheRest = false;\n+        tokens.clear();\n+    }\n+\n+    /**\n+     * <p>An implementation of {@link Parser}'s abstract\n+     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n+     *\n+     * <p>The following are the rules used by this flatten method.\n+     * <ol>\n+     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n+     *  burst anymore of <code>arguments</code> entries, just add each\n+     *  successive entry without further processing.  Otherwise, ignore\n+     *  <code>stopAtNonOption</code>.</li>\n+     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n+     *  just add the entry to the list of processed tokens</li>\n+     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n+     *  just add the entry to the list of processed tokens</li>\n+     *  <li>if the current <code>arguments</code> entry is two characters\n+     *  in length and the first character is \"<b>-</b>\" then check if this\n+     *  is a valid {@link Option} id.  If it is a valid id, then add the\n+     *  entry to the list of processed tokens and set the current {@link Option}\n+     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n+     *  is true, then the remaining entries are copied to the list of\n+     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n+     *  <li>if the current <code>arguments</code> entry is more than two\n+     *  characters in length and the first character is \"<b>-</b>\" then\n+     *  we need to burst the entry to determine its constituents.  For more\n+     *  information on the bursting algorithm see\n+     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n+     *  <li>if the current <code>arguments</code> entry is not handled\n+     *  by any of the previous rules, then the entry is added to the list\n+     *  of processed tokens.</li>\n+     * </ol>\n+     * </p>\n+     *\n+     * @param options The command line {@link Options}\n+     * @param arguments The command line arguments to be parsed\n+     * @param stopAtNonOption Specifies whether to stop flattening\n+     * when an non option is found.\n+     * @return The flattened <code>arguments</code> String array.\n+     */\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n+    {\n+        init();\n+        this.options = options;\n+\n+        // an iterator for the command line tokens\n+        Iterator iter = Arrays.asList(arguments).iterator();\n+\n+        // process each command line token\n+        while (iter.hasNext())\n+        {\n+            // get the next command line token\n+            String token = (String) iter.next();\n+\n+            // single or double hyphen\n+            if (\"-\".equals(token) || \"--\".equals(token))\n+            {\n+                tokens.add(token);\n+            }\n+            \n+            // handle long option --foo or --foo=bar\n+            else if (token.startsWith(\"--\"))\n+            {\n+                int pos = token.indexOf('=');\n+                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n+                \n+                List matchingOpts = options.getMatchingOptions(opt);\n+\n+                if (matchingOpts.isEmpty())\n+                {\n+                    processNonOptionToken(token, stopAtNonOption);\n+                }\n+                else if (matchingOpts.size() > 1)\n+                {\n+                    throw new AmbiguousOptionException(opt, matchingOpts);\n+                }\n+                else\n+                {\n+                    currentOption = options.getOption((String) matchingOpts.get(0));\n+                    \n+                    tokens.add(\"--\" + currentOption.getLongOpt());\n+                    if (pos != -1)\n+                    {\n+                        tokens.add(token.substring(pos + 1));\n+                    }\n+                }\n+            }\n+\n+            else if (token.startsWith(\"-\"))\n+            {\n+                if (token.length() == 2 || options.hasOption(token))\n+                {\n+                    processOptionToken(token, stopAtNonOption);\n+                }\n+                else if (!options.getMatchingOptions(token).isEmpty())\n+                {\n+                    List matchingOpts = options.getMatchingOptions(token);\n+                    if (matchingOpts.size() > 1)\n+                    {\n+                        throw new AmbiguousOptionException(token, matchingOpts);\n+                    }\n+                    else\n+                    {\n+                        Option opt = options.getOption((String) matchingOpts.get(0));\n+                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n+                    }\n+                }\n+                // requires bursting\n+                else\n+                {\n+                    burstToken(token, stopAtNonOption);\n+                }\n+            }\n+            else\n+            {\n+                processNonOptionToken(token, stopAtNonOption);\n+            }\n+\n+            gobble(iter);\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+\n+    /**\n+     * Adds the remaining tokens to the processed tokens list.\n+     *\n+     * @param iter An iterator over the remaining tokens\n+     */\n+    private void gobble(Iterator iter)\n+    {\n+        if (eatTheRest)\n+        {\n+            while (iter.hasNext())\n+            {\n+                tokens.add(iter.next());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add the special token \"<b>--</b>\" and the current <code>value</code>\n+     * to the processed tokens list. Then add all the remaining\n+     * <code>argument</code> values to the processed tokens list.\n+     *\n+     * @param value The current token\n+     */\n+    private void processNonOptionToken(String value, boolean stopAtNonOption)\n+    {\n+        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n+        {\n+            eatTheRest = true;\n+            tokens.add(\"--\");\n+        }\n+\n+        tokens.add(value);\n+    }\n+\n+    /**\n+     * <p>If an {@link Option} exists for <code>token</code> then\n+     * add the token to the processed list.</p>\n+     *\n+     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n+     * is set then add the remaining tokens to the processed tokens list\n+     * directly.</p>\n+     *\n+     * @param token The current option token\n+     * @param stopAtNonOption Specifies whether flattening should halt\n+     * at the first non option.\n+     */\n+    private void processOptionToken(String token, boolean stopAtNonOption)\n+    {\n+        if (stopAtNonOption && !options.hasOption(token))\n+        {\n+            eatTheRest = true;\n+        }\n+\n+        if (options.hasOption(token))\n+        {\n+            currentOption = options.getOption(token);\n+        }\n+\n+        tokens.add(token);\n+    }\n+\n+    /**\n+     * Breaks <code>token</code> into its constituent parts\n+     * using the following algorithm.\n+     *\n+     * <ul>\n+     *  <li>ignore the first character (\"<b>-</b>\")</li>\n+     *  <li>foreach remaining character check if an {@link Option}\n+     *  exists with that id.</li>\n+     *  <li>if an {@link Option} does exist then add that character\n+     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n+     *  <li>if the {@link Option} can have an argument value and there\n+     *  are remaining characters in the token then add the remaining\n+     *  characters as a token to the list of processed tokens.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n+     *  \"<b>--</b>\" followed by the remaining characters and also\n+     *  the remaining tokens directly to the processed tokens list.</li>\n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n+     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n+     *  character prepended with \"<b>-</b>\".</li>\n+     * </ul>\n+     *\n+     * @param token The current token to be <b>burst</b>\n+     * @param stopAtNonOption Specifies whether to stop processing\n+     * at the first non-Option encountered.\n+     */\n+    protected void burstToken(String token, boolean stopAtNonOption)\n+    {\n+        for (int i = 1; i < token.length(); i++)\n+        {\n+            String ch = String.valueOf(token.charAt(i));\n+\n+            if (options.hasOption(ch))\n+            {\n+                tokens.add(\"-\" + ch);\n+                currentOption = options.getOption(ch);\n+\n+                if (currentOption.hasArg() && (token.length() != (i + 1)))\n+                {\n+                    tokens.add(token.substring(i + 1));\n+\n+                    break;\n+                }\n+            }\n+            else if (stopAtNonOption)\n+            {\n+                processNonOptionToken(token.substring(i), true);\n+                break;\n+            }\n+            else\n+            {\n+                tokens.add(token);\n+                break;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import java.util.Date;\n+\n+/**\n+  * This is a temporary implementation. TypeHandler will handle the\n+  * pluggableness of OptionTypes and it will direct all of these types\n+  * of conversion functionalities to ConvertUtils component in Commons\n+  * already. BeanUtils I think.\n+  *\n+  * @version $Revision$, $Date$\n+  */\n+public class TypeHandler\n+{\n+    /**\n+     * Returns the <code>Object</code> of type <code>obj</code>\n+     * with the value of <code>str</code>.\n+     *\n+     * @param str the command line value\n+     * @param obj the type of argument\n+     * @return The instance of <code>obj</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Object obj) throws ParseException\n+    {\n+        return createValue(str, (Class) obj);\n+    }\n+\n+    /**\n+     * Returns the <code>Object</code> of type <code>clazz</code>\n+     * with the value of <code>str</code>.\n+     *\n+     * @param str the command line value\n+     * @param clazz the type of argument\n+     * @return The instance of <code>clazz</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Class clazz) throws ParseException\n+    {\n+        if (PatternOptionBuilder.STRING_VALUE == clazz)\n+        {\n+            return str;\n+        }\n+        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n+        {\n+            return createObject(str);\n+        }\n+        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n+        {\n+            return createNumber(str);\n+        }\n+        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n+        {\n+            return createDate(str);\n+        }\n+        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n+        {\n+            return createClass(str);\n+        }\n+        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n+        {\n+            return createFile(str);\n+        }\n+        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n+        {\n+            return createFile(str);\n+        }\n+        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n+        {\n+            return createFiles(str);\n+        }\n+        else if (PatternOptionBuilder.URL_VALUE == clazz)\n+        {\n+            return createURL(str);\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+      * Create an Object from the classname and empty constructor.\n+      *\n+      * @param classname the argument value\n+      * @return the initialised object, or null if it couldn't create\n+      * the Object.\n+      */\n+    public static Object createObject(String classname) throws ParseException\n+    {\n+        Class cl = null;\n+\n+        try\n+        {\n+            cl = Class.forName(classname);\n+        }\n+        catch (ClassNotFoundException cnfe)\n+        {\n+            throw new ParseException(\"Unable to find the class: \" + classname);\n+        }\n+\n+        Object instance = null;\n+\n+        try\n+        {\n+            instance = cl.newInstance();\n+        }\n+        catch (Exception e)\n+        {\n+            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n+        }\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * Create a number from a String. If a . is present, it creates a\n+     * Double, otherwise a Long.\n+     *\n+     * @param str the value\n+     * @return the number represented by <code>str</code>, if <code>str</code>\n+     * is not a number, null is returned.\n+     */\n+    public static Number createNumber(String str) throws ParseException\n+    {\n+        try\n+        {\n+            if (str.indexOf('.') != -1)\n+            {\n+                return Double.valueOf(str);\n+            }\n+            else\n+            {\n+                return Long.valueOf(str);\n+            }\n+        }\n+        catch (NumberFormatException e)\n+        {\n+            throw new ParseException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Returns the class whose name is <code>classname</code>.\n+     *\n+     * @param classname the class name\n+     * @return The class if it is found, otherwise return null\n+     */\n+    public static Class createClass(String classname) throws ParseException\n+    {\n+        try\n+        {\n+            return Class.forName(classname);\n+        }\n+        catch (ClassNotFoundException e)\n+        {\n+            throw new ParseException(\"Unable to find the class: \" + classname);\n+        }\n+    }\n+\n+    /**\n+     * Returns the date represented by <code>str</code>.\n+     *\n+     * @param str the date string\n+     * @return The date if <code>str</code> is a valid date string,\n+     * otherwise return null.\n+     */\n+    public static Date createDate(String str) throws ParseException\n+    {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n+    }\n+\n+    /**\n+     * Returns the URL represented by <code>str</code>.\n+     *\n+     * @param str the URL string\n+     * @return The URL is <code>str</code> is well-formed, otherwise\n+     * return null.\n+     */\n+    public static URL createURL(String str) throws ParseException\n+    {\n+        try\n+        {\n+            return new URL(str);\n+        }\n+        catch (MalformedURLException e)\n+        {\n+            throw new ParseException(\"Unable to parse the URL: \" + str);\n+        }\n+    }\n+\n+    /**\n+     * Returns the File represented by <code>str</code>.\n+     *\n+     * @param str the File location\n+     * @return The file represented by <code>str</code>.\n+     */\n+    public static File createFile(String str) throws ParseException\n+    {\n+        return new File(str);\n+    }\n+\n+    /**\n+     * Returns the File[] represented by <code>str</code>.\n+     *\n+     * @param str the paths to the files\n+     * @return The File[] represented by <code>str</code>.\n+     */\n+    public static File[] createFiles(String str) throws ParseException\n+    {\n+        // to implement/port:\n+        //        return FileW.findFiles(str);\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Exception thrown during parsing signalling an unrecognized\n+ * option was seen.\n+ *\n+ * @author bob mcwhiter (bob @ werken.com)\n+ * @version $Revision$, $Date$\n+ */\n+public class UnrecognizedOptionException extends ParseException\n+{\n+    /** The  unrecognized option */\n+    private String option;\n+\n+    /**\n+     * Construct a new <code>UnrecognizedArgumentException</code>\n+     * with the specified detail message.\n+     *\n+     * @param message the detail message\n+     */\n+    public UnrecognizedOptionException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new <code>UnrecognizedArgumentException</code>\n+     * with the specified option and detail message.\n+     *\n+     * @param message the detail message\n+     * @param option  the unrecognized option\n+     * @since 1.2\n+     */\n+    public UnrecognizedOptionException(String message, String option)\n+    {\n+        this(message);\n+        this.option = option;\n+    }\n+\n+    /**\n+     * Returns the unrecognized option.\n+     *\n+     * @return the related option\n+     * @since 1.2\n+     */\n+    public String getOption()\n+    {\n+        return option;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/cli/Util.java\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/**\n+ * Contains useful helper methods for classes within this package.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n+ */\n+class Util\n+{\n+    /**\n+     * Remove the hyphens from the begining of <code>str</code> and\n+     * return the new String.\n+     *\n+     * @param str The string from which the hyphens should be removed.\n+     *\n+     * @return the new String.\n+     */\n+    static String stripLeadingHyphens(String str)\n+    {\n+        if (str == null)\n+        {\n+            return null;\n+        }\n+        if (str.startsWith(\"--\"))\n+        {\n+            return str.substring(2, str.length());\n+        }\n+        else if (str.startsWith(\"-\"))\n+        {\n+            return str.substring(1, str.length());\n+        }\n+\n+        return str;\n+    }\n+\n+    /**\n+     * Remove the leading and trailing quotes from <code>str</code>.\n+     * E.g. if str is '\"one two\"', then 'one two' is returned.\n+     *\n+     * @param str The string from which the leading and trailing quotes\n+     * should be removed.\n+     *\n+     * @return The string without the leading and trailing quotes.\n+     */\n+    static String stripLeadingAndTrailingQuotes(String str)\n+    {\n+        int length = str.length();\n+        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n+        {\n+            str = str.substring(1, length - 1);\n+        }\n+        \n+        return str;\n+    }\n+}", "timestamp": 1276681500, "metainfo": ""}