{"sha": "777cb81088d47472df21a452edd5ba568d4b3fdf", "log": "Ensure the wrap width is never exceeded and cut the words longer that the width if necessary (CLI-193)  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n      * Finds the next text wrap position after <code>startPos</code> for the\n      * text in <code>text</code> with the column width <code>width</code>.\n      * The wrap point is the last position before startPos+width having a \n-     * whitespace character (space, \\n, \\r).\n+     * whitespace character (space, \\n, \\r). If there is no whitespace character\n+     * before startPos+width, it will return startPos+width.\n      *\n      * @param text The text being searched for the wrap position\n      * @param width width of the wrapped text\n      */\n     protected int findWrapPos(String text, int width, int startPos)\n     {\n-        int pos = -1;\n-\n+        int pos;\n+        \n         // the line ends before the max wrap pos or a new line char found\n         if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                 || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n             return pos;\n         }\n         \n-        // must look for the first whitespace chearacter after startPos \n-        // + width\n+        // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }\n-\n-        return (pos == text.length()) ? (-1) : pos;\n+        \n+        return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/cli/HelpFormatterTest.java\n+++ b/src/test/java/org/apache/commons/cli/HelpFormatterTest.java\n         // starting from 8 must give -1 - the wrap pos is after end\n         assertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n         \n-        // if there is no a good position before width to make a wrapping look for the next one\n+        // words longer than the width are cut\n         text = \"aaaa aa\";\n-        assertEquals(\"wrap position 3\", 4, hf.findWrapPos(text, 3, 0));\n+        assertEquals(\"wrap position 3\", 3, hf.findWrapPos(text, 3, 0));\n+        \n+        // last word length is equal to the width\n+        text = \"aaaaaa aaaaaa\";\n+        assertEquals(\"wrap position 4\", 6, hf.findWrapPos(text, 6, 0));\n+        assertEquals(\"wrap position 4\", -1, hf.findWrapPos(text, 6, 7));\n+    }\n+\n+    public void testRenderWrappedTextWordCut()\n+    {\n+        int width = 7;\n+        int padding = 0;\n+        String text = \"Thisisatest.\";\n+        String expected = \"Thisisa\" + EOL + \n+                          \"test.\";\n+        \n+        StringBuffer sb = new StringBuffer();\n+        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n+        assertEquals(\"cut and wrap\", expected, sb.toString());\n     }\n \n     public void testRenderWrappedTextSingleLine()", "timestamp": 1278510492, "metainfo": ""}