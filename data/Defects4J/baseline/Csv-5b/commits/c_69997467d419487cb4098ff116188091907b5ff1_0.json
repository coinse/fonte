{"sha": "69997467d419487cb4098ff116188091907b5ff1", "log": "Refactor to only have minimal CSVParser constructors in favor of CSVParser factory methods for String, resource path, URL, and File. Update some tests to use the APIs.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \t/**\n \t * Parses the specified content.\n \t * \n+\t * <p>\n+\t * See also the various static parse methods on {@link CSVParser}.\n+\t * </p>\n+\t * \n \t * @param in\n \t *            the input stream\n \t * @return a parser over a stream of {@link #CSVRecord}s.\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import static org.apache.commons.csv.Token.Type.TOKEN;\n \n import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.io.Reader;\n import java.io.StringReader;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n \n /**\n  * Parses CSV files according to the specified configuration.\n- *\n+ * \n  * Because CSV appears in many different dialects, the parser supports many configuration settings by allowing the\n  * specification of a {@link CSVFormat}.\n- *\n- * <p>\n- * To parse a CSV input with tabs as separators, '\"' (double-quote) as an optional value encapsulator,\n- * and comments starting with '#', you write:\n- * </p>\n- *\n+ * \n+ * <p>\n+ * To parse a CSV input with tabs as separators, '\"' (double-quote) as an optional value encapsulator, and comments\n+ * starting with '#', you write:\n+ * </p>\n+ * \n  * <pre>\n  * Reader in = new StringReader(&quot;a\\tb\\nc\\td&quot;);\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.DEFAULT\n  *     ...\n  *  }\n  * </pre>\n- *\n+ * \n  * <p>\n  * To parse CSV input in a given format like Excel, you write:\n  * </p>\n- *\n+ * \n  * <pre>\n  * Reader in = new StringReader(\"a;b\\nc;d\");\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.EXCEL.parse(in);\n  * <p>\n  * You may also get a List of records:\n  * </p>\n+ * \n  * <pre>\n- * Reader in = new StringReader(\"a;b\\nc;d\");\n+ * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n  * List&lt;CSVRecord&gt; list = parser.getRecords();\n  * </pre>\n  * <p>\n+ * See also the various static parse methods on this class.\n+ * </p>\n+ * <p>\n  * Internal parser state is completely covered by the format and the reader-state.\n  * </p>\n- *\n+ * \n  * <p>\n  * see <a href=\"package-summary.html\">package documentation</a> for more details\n  * </p>\n- *\n+ * \n  * @version $Id$\n  */\n public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n+    /**\n+     * Creates a parser for the given resource.\n+     * \n+     * <p>\n+     * If you do not read all records from the given source, you should call {@link #close()} on the parser.\n+     * </p>\n+     * \n+     * @param resource\n+     *            a resource path\n+     * @param charset\n+     *            the charset for the resource\n+     * @param classLoader\n+     *            the class loader to load the resource.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseResource(String resource, Charset charset, ClassLoader classLoader,\n+            final CSVFormat format) throws IOException {\n+        return parseURL(classLoader.getResource(resource), charset, format);\n+    }\n+    \n+    /**\n+     * Creates a parser for the given {@link String} using the default format {@link CSVFormat#DEFAULT}.\n+     * \n+     * @param string\n+     *            a CSV string\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseString(String string) throws IOException {\n+        return parseString(string, CSVFormat.DEFAULT);\n+    }\n+    \n+    /**\n+     * Creates a parser for the given {@link String}.\n+     * \n+     * @param string\n+     *            a CSV string\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseString(String string, final CSVFormat format) throws IOException {\n+        return new CSVParser(new StringReader(string), format);\n+    }\n+\n+    /**\n+     * Creates a parser for the given {@link File}.\n+     * \n+     * @param file\n+     *            a CSV file\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseFile(File file, final CSVFormat format) throws IOException {\n+        return new CSVParser(new FileReader(file), format);\n+    }\n+\n+    /**\n+     * Creates a parser for the given URL.\n+     * \n+     * <p>\n+     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n+     * you close the {@code url}.\n+     * </p>\n+     * \n+     * @param url\n+     *            a URL\n+     * @param charset\n+     *            the charset for the resource, if {@code null}, uses {@code UTF-8}. UTF-8 is one of the encodings\n+     *            required by the Java specification.\n+     * @param classLoader\n+     *            the class loader to load the resource.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseURL(URL url, Charset charset, final CSVFormat format) throws IOException {\n+        return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName(\"UTF-8\")\n+                : charset), format);\n+    }\n+\n+    // the following objects are shared to reduce garbage\n+\n     private final CSVFormat format;\n     private final Map<String, Integer> headerMap;\n+\n     private final Lexer lexer;\n+\n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n \n-    // the following objects are shared to reduce garbage\n-\n     private long recordNumber;\n+\n     private final Token reusableToken = new Token();\n \n     /**\n-     * CSV parser using the default {@link CSVFormat}.\n-     *\n+     * CSV parser using the default format {@link CSVFormat#DEFAULT}.\n+     *\n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     * \n      * @param input\n      *            a Reader containing \"csv-formatted\" input\n      * @throws IllegalArgumentException\n \n     /**\n      * Customized CSV parser using the given {@link CSVFormat}\n-     *\n-     * @param input\n+     * \n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     * \n+     * @param reader\n      *            a Reader containing CSV-formatted input\n      * @param format\n      *            the CSVFormat used for CSV parsing\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n+    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n         format.validate();\n         this.format = format;\n-        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n-        this.headerMap = initializeHeader();\n-    }\n-\n-    /**\n-     * Customized CSV parser using the given {@link CSVFormat}\n-     *\n-     * @param input\n-     *            a String containing \"csv-formatted\" input\n-     * @param format\n-     *            the CSVFormat used for CSV parsing\n-     * @throws IllegalArgumentException\n-     *             thrown if the parameters of the format are inconsistent\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public CSVParser(final String input, final CSVFormat format) throws IOException {\n-        this(new StringReader(input), format);\n+        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(reader));\n+        this.headerMap = this.initializeHeader();\n     }\n \n     private void addRecordValue() {\n-        final String input = reusableToken.content.toString();\n+        final String input = this.reusableToken.content.toString();\n         final String nullString = this.format.getNullString();\n         if (nullString == null) {\n-            record.add(input);\n+            this.record.add(input);\n         } else {\n-            record.add(input.equalsIgnoreCase(nullString) ? null : input);\n+            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n         }}\n \n     /**\n \t *             If an I/O error occurs\n      */\n \tpublic void close() throws IOException {\n-\t\tif (lexer != null) {\n-\t\t\tlexer.close();\n+\t\tif (this.lexer != null) {\n+\t\t\tthis.lexer.close();\n \t\t}\t\t\n \t}\n \n      * @return current line number\n      */\n     public long getCurrentLineNumber() {\n-        return lexer.getCurrentLineNumber();\n+        return this.lexer.getCurrentLineNumber();\n     }\n \n     /**\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(headerMap);\n+        return new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * @return current line number\n      */\n     public long getRecordNumber() {\n-        return recordNumber;\n+        return this.recordNumber;\n     }\n \n     /**\n     public List<CSVRecord> getRecords() throws IOException {\n         final List<CSVRecord> records = new ArrayList<CSVRecord>();\n         CSVRecord rec;\n-        while ((rec = nextRecord()) != null) {\n+        while ((rec = this.nextRecord()) != null) {\n             records.add(rec);\n         }\n         return records;\n      */\n     private Map<String, Integer> initializeHeader() throws IOException {\n         Map<String, Integer> hdrMap = null;\n-        if (format.getHeader() != null) {\n+        if (this.format.getHeader() != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n \n             String[] header = null;\n-            if (format.getHeader().length == 0) {\n+            if (this.format.getHeader().length == 0) {\n                 // read the header from the first line of the file\n-                final CSVRecord record = nextRecord();\n+                final CSVRecord record = this.nextRecord();\n                 if (record != null) {\n                     header = record.values();\n                 }\n             } else {\n-                header = format.getHeader();\n+                header = this.format.getHeader();\n             }\n \n             // build the name to index mappings\n     }\n \n     public boolean isClosed() {\n-\t\treturn lexer.isClosed();\n+\t\treturn this.lexer.isClosed();\n \t}\n \n-    /**\n+\t/**\n      * Returns an iterator on the records. IOExceptions occurring during the iteration are wrapped in a\n      * RuntimeException.\n      */\n \n             private CSVRecord getNextRecord() {\n                 try {\n-                    return nextRecord();\n+                    return CSVParser.this.nextRecord();\n                 } catch (final IOException e) {\n                     // TODO: This is not great, throw an ISE instead?\n                     throw new RuntimeException(e);\n             }\n \n             public boolean hasNext() {\n-            \tif (isClosed()) {\n+            \tif (CSVParser.this.isClosed()) {\n             \t\treturn false;\n             \t}\n-                if (current == null) {\n-                    current = getNextRecord();\n-                }\n-\n-                return current != null;\n+                if (this.current == null) {\n+                    this.current = this.getNextRecord();\n+                }\n+\n+                return this.current != null;\n             }\n \n             public CSVRecord next() {\n-            \tif (isClosed()) {\n+            \tif (CSVParser.this.isClosed()) {\n             \t\treturn null;\n             \t}\n-                CSVRecord next = current;\n-                current = null;\n+                CSVRecord next = this.current;\n+                this.current = null;\n \n                 if (next == null) {\n                     // hasNext() wasn't called before\n-                    next = getNextRecord();\n+                    next = this.getNextRecord();\n                     if (next == null) {\n                         throw new NoSuchElementException(\"No more CSV records available\");\n                     }\n         };\n     }\n \n-\t/**\n+    /**\n      * Parses the next record from the current point in the stream.\n      *\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n      */\n     CSVRecord nextRecord() throws IOException {\n         CSVRecord result = null;\n-        record.clear();\n+        this.record.clear();\n         StringBuilder sb = null;\n         do {\n-            reusableToken.reset();\n-            lexer.nextToken(reusableToken);\n-            switch (reusableToken.type) {\n+            this.reusableToken.reset();\n+            this.lexer.nextToken(this.reusableToken);\n+            switch (this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n                 this.addRecordValue();\n                 break;\n             case EOF:\n-                if (reusableToken.isReady) {\n+                if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n-                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n+                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT: // Ignored currently\n                 if (sb == null) { // first comment for this record\n                     sb = new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n-                sb.append(reusableToken.content);\n-                reusableToken.type = TOKEN; // Read another token\n+                sb.append(this.reusableToken.content);\n+                this.reusableToken.type = TOKEN; // Read another token\n                 break;\n             }\n-        } while (reusableToken.type == TOKEN);\n-\n-        if (!record.isEmpty()) {\n-            recordNumber++;\n+        } while (this.reusableToken.type == TOKEN);\n+\n+        if (!this.record.isEmpty()) {\n+            this.recordNumber++;\n             final String comment = sb == null ? null : sb.toString();\n-            result = new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n+            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n         }\n         return result;\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n import java.io.FileReader;\n import java.io.FilenameFilter;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n         final String[] split = line.split(\" \");\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n-        final BufferedReader csvFileReader = new BufferedReader(new FileReader(new File(BASE, split[0])));\n         CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\"');\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n         assertEquals(testName+\" Expected format \", line, format.toString());\n \n         // Now parse the file and compare against the expected results\n-        for(final CSVRecord record : format.parse(csvFileReader)) {\n+        // We use a buffered reader internally so no need to create one here.\n+        CSVParser parser = CSVParser.parseFile(new File(BASE, split[0]), format);\n+        for(final CSVRecord record : parser) {\n             String parsed = record.toString();\n             if (checkComments) {\n                 final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n             assertEquals(testName, readTestData(), count+\":\"+parsed);\n         }\n     }\n+\n+    @Test\n+    public void testCSVResource() throws Exception {\n+        String line = readTestData();\n+        assertNotNull(\"file must contain config line\", line);\n+        final String[] split = line.split(\" \");\n+        assertTrue(testName + \" require 1 param\", split.length >= 1);\n+        // first line starts with csv data file name\n+        CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\"');\n+        boolean checkComments = false;\n+        for (int i = 1; i < split.length; i++) {\n+            final String option = split[i];\n+            final String[] option_parts = option.split(\"=\", 2);\n+            if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])) {\n+                format = format.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n+            } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n+                format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n+            } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n+                format = format.withCommentStart(option_parts[1].charAt(0));\n+            } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n+                checkComments = true;\n+            } else {\n+                fail(testName + \" unexpected option: \" + option);\n+            }\n+        }\n+        line = readTestData(); // get string version of format\n+        assertEquals(testName + \" Expected format \", line, format.toString());\n+\n+        // Now parse the file and compare against the expected results\n+        CSVParser parser = CSVParser.parseResource(\"CSVFileParser/\" + split[0], Charset.forName(\"UTF-8\"),\n+                this.getClass().getClassLoader(), format);\n+        for (final CSVRecord record : parser) {\n+            String parsed = record.toString();\n+            if (checkComments) {\n+                final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n+                if (comment != null) {\n+                    parsed += \"#\" + comment;\n+                }\n+            }\n+            final int count = record.size();\n+            assertEquals(testName, readTestData(), count + \":\" + parsed);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n                 {\"\"},\n                 {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n         };\n-        final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+        final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n                 {\"\"},\n                 {\"world\", \"\"}\n         };\n-        final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+        final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n         for (final String code : codes) {\n-            final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+            final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"world\", \"\"}\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = new CSVParser(new StringReader(code));\n+            final CSVParser parser = CSVParser.parseString(code);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"\"}\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+            final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"hello\", \"\"}  // CSV format ignores empty lines\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = new CSVParser(new StringReader(code));\n+            final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n \n     @Test\n     public void testEmptyFile() throws Exception {\n-        final CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parseString(\"\", CSVFormat.DEFAULT);\n         assertNull(parser.nextRecord());\n     }\n \n     @Test\n     public void testCSV57() throws Exception {\n-        final CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parseString(\"\", CSVFormat.DEFAULT);\n         final List<CSVRecord> list = parser.getRecords();\n         assertNotNull(list);\n         assertEquals(0, list.size());\n                 {\"a\\\\\", \"b\"},  // a backslash must be returnd\n                 {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n         };\n-        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final CSVParser parser = CSVParser.parseString(code);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n                                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n-        final CSVParser parser = new CSVParser(code, format);\n+        final CSVParser parser = CSVParser.parseString(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         final CSVFormat format = CSVFormat.newFormat(',')\n                 .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n-        final CSVParser parser = new CSVParser(code, format);\n+        final CSVParser parser = CSVParser.parseString(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isCommentingEnabled());\n \n-        CSVParser parser = new CSVParser(code, format);\n+        CSVParser parser = CSVParser.parseString(code, format);\n         List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         };\n \n         format = CSVFormat.DEFAULT.withCommentStart('#');\n-        parser = new CSVParser(code, format);\n+        parser = CSVParser.parseString(code, format);\n         records = parser.getRecords();\n \n         Utils.compare(\"Failed to parse with comments\", res_comments, records);\n     @Test\n     public void testCarriageReturnLineFeedEndings() throws IOException {\n         final String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n     @Test\n     public void testCarriageReturnEndings() throws IOException {\n         final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final CSVParser parser = CSVParser.parseString(code);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n     @Test\n     public void testLineFeedEndings() throws IOException {\n         final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final CSVParser parser = CSVParser.parseString(code);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n         final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n         //String code = \"world\\r\\n\\n\";\n         //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final CSVParser parser = CSVParser.parseString(code);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(3, records.size());\n     }\n         final StringWriter out = new StringWriter();\n         final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n         final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n-        for (final CSVRecord record : CSVFormat.DEFAULT.parse(new StringReader(input))) {\n+        for (final CSVRecord record : CSVParser.parseString(input, CSVFormat.DEFAULT)) {\n             printer.printRecord(record);\n         }\n         assertEquals(input, out.toString());\n \n     @Test\n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n+        final CSVParser parser = CSVParser.parseString(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n         final Map<String, Integer> headerMap = parser.getHeaderMap();\n         final Iterator<String> columnNames = headerMap.keySet().iterator();\n         // Headers are iterated in column order.\n \n     @Test\n     public void testGetRecordWithMultiiLineValues() throws Exception {\n-        final CSVParser parser = new CSVParser(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n+        final CSVParser parser = CSVParser.parseString(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n                 CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n     }\n \n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parseString(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n     }\n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parseString(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getCurrentLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n         final String result = sw.toString();\n         // System.out.println(\"### :\" + printable(result));\n \n-        final CSVParser parser = new CSVParser(result, format);\n+        final CSVParser parser = CSVParser.parseString(result, format);\n         final List<CSVRecord> parseResult = parser.getRecords();\n \n         Utils.compare(\"Printer output :\" + printable(result), lines, parseResult);", "timestamp": 1375205794, "metainfo": ""}