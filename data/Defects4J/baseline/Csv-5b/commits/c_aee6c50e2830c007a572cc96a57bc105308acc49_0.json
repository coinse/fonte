{"sha": "aee6c50e2830c007a572cc96a57bc105308acc49", "log": "Header support (CSV-65)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n     /** According to RFC 4180, line breaks are delimited by CRLF */\n     private static final String CRLF = \"\\r\\n\";\n+    \n     private final char delimiter;\n     private final char encapsulator;\n     private final char commentStart;\n     private final boolean trailingSpacesIgnored;\n     private final boolean unicodeEscapesInterpreted;\n     private final boolean emptyLinesIgnored;\n-    private final String lineSeparator; // for output\n+    private final String lineSeparator; // for outputs\n+    private final String[] header;\n \n \n     /**\n     static final char DISABLED = '\\ufffe';\n \n     /** Standard comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>. */\n-    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true, CRLF);\n+    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true, CRLF, null);\n \n     /**\n      * Excel file format (using a comma as the value delimiter).\n      * \n      * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>\n      */\n-    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, false, CRLF);\n+    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, false, CRLF, null);\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n-    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, false, true, CRLF);\n+    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, false, true, CRLF, null);\n \n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and\n      * \n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n-    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, false, \"\\n\");\n+    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, false, \"\\n\", null);\n \n \n     /**\n      * @param unicodeEscapesInterpreted <tt>true</tt> when unicode escapes should be interpreted\n      * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines\n      * @param lineSeparator             the line separator to use for output\n+     * @param header                    the header\n      */\n     CSVFormat(\n             char delimiter,\n             boolean trailingSpacesIgnored,\n             boolean unicodeEscapesInterpreted,\n             boolean emptyLinesIgnored,\n-            String lineSeparator) {\n+            String lineSeparator,\n+            String[] header) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n         this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n         this.emptyLinesIgnored = emptyLinesIgnored;\n         this.lineSeparator = lineSeparator;\n+        this.header = header;\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEncapsulating() {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEscaping() {\n      * @return A copy of this format with the specified left trimming behavior.\n      */\n     public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format with the specified right trimming behavior.\n      */\n     public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format with the specified unicode escaping behavior.\n      */\n     public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format  with the specified empty line skipping behavior.\n      */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+    }\n+\n+    String[] getHeader() {\n+        return header;\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified header. The header can\n+     * either be parsed automatically from the input file with:\n+     *\n+     * <pre>CSVFormat format = CSVFormat.DEFAULT.withHeader();</pre>\n+     *\n+     * or specified manually with:\n+     *\n+     * <pre>CSVFormat format = CSVFormat.DEFAULT.withHeader(\"name\", \"email\", \"phone\");</pre>\n+     *\n+     * @param header the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n+     *\n+     * @return A copy of this format using the specified header\n+     */\n+    public CSVFormat withHeader(String... header) {\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * \n      * @param in the input stream\n      */\n-    public Iterable<String[]> parse(Reader in) {\n+    public Iterable<CSVRecord> parse(Reader in) throws IOException {\n         return new CSVParser(in, this);\n     }\n \n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import java.io.Reader;\n import java.io.StringReader;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n import java.util.NoSuchElementException;\n \n import org.apache.commons.csv.CSVLexer.Token;\n  * <pre>\n  * CSVFormat format = new CSVFormat('\\t', '\"', '#');\n  * Reader in = new StringReader(\"a\\tb\\nc\\td\");\n- * String[][] records = new CSVParser(in, format).getRecords();\n+ * List&lt;CSVRecord> records = new CSVParser(in, format).getRecords();\n  * </pre>\n  *\n  * <p>Parsing of a csv-string in Excel CSV format, using a for-each loop:</p>\n  * <pre>\n  * Reader in = new StringReader(\"a;b\\nc;d\");\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n- * for (String[] record : parser) {\n+ * for (CSVRecord record : parser) {\n  *     ...\n  * }\n  * </pre>\n  * <p>see <a href=\"package-summary.html\">package documentation</a>\n  * for more details</p>\n  */\n-public class CSVParser implements Iterable<String[]> {\n-\n-    /** Immutable empty String array. */\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+public class CSVParser implements Iterable<CSVRecord> {\n \n     private final CSVLexer lexer;\n-    \n+    private Map<String, Integer> headerMapping;\n+\n     // the following objects are shared to reduce garbage\n     \n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n      * @param input a Reader containing \"csv-formatted\" input\n      * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(Reader input) {\n+    public CSVParser(Reader input) throws IOException {\n         this(input, CSVFormat.DEFAULT);\n     }\n \n      * @param format the CSVFormat used for CSV parsing\n      * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(Reader input, CSVFormat format) {\n+    public CSVParser(Reader input, CSVFormat format) throws IOException {\n         format.validate();\n         \n         if (format.isUnicodeEscapesInterpreted()) {\n         }\n         \n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n+        \n+        initializeHeader(format);\n     }\n \n     /**\n      * @param format the CSVFormat used for CSV parsing\n      * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(String input, CSVFormat format) {\n+    public CSVParser(String input, CSVFormat format) throws IOException{\n         this(new StringReader(input), format);\n     }\n \n      * @return matrix of records x values ('null' when end of file)\n      * @throws IOException on parse error or input read-failure\n      */\n-    public String[][] getRecords() throws IOException {\n-        List<String[]> records = new ArrayList<String[]>();\n-        String[] record;\n+    public List<CSVRecord> getRecords() throws IOException {\n+        List<CSVRecord> records = new ArrayList<CSVRecord>();\n+        CSVRecord record;\n         while ((record = getRecord()) != null) {\n             records.add(record);\n         }\n         \n         if (!records.isEmpty()) {\n-            return records.toArray(new String[records.size()][]);\n+            return records;\n         } else {\n             return null;\n         }\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n      * @throws IOException on parse error or input read-failure\n      */\n-    String[] getRecord() throws IOException {\n-        String[] result = EMPTY_STRING_ARRAY;\n+    CSVRecord getRecord() throws IOException {\n+        CSVRecord result = new CSVRecord(null, headerMapping);\n         record.clear();\n         do {\n             reusableToken.reset();\n                     }\n                     break;\n                 case INVALID:\n-                    // error: throw IOException\n                     throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n-                    // unreachable: break;\n             }\n         } while (reusableToken.type == TOKEN);\n         \n         if (!record.isEmpty()) {\n-            result = record.toArray(new String[record.size()]);\n+            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n         }\n         return result;\n+    }\n+\n+    /**\n+     * Initializes the name to index mapping if the format defines a header.\n+     */\n+    private void initializeHeader(CSVFormat format) throws IOException {\n+        if (format.getHeader() != null) {\n+            headerMapping = new HashMap<String, Integer>();\n+\n+            String[] header = null;\n+            if (format.getHeader().length == 0) {\n+                // read the header from the first line of the file\n+                CSVRecord record = getRecord();\n+                if (record != null) {\n+                    header = record.values();\n+                }\n+            } else {\n+                header = format.getHeader();\n+            }\n+\n+            // build the name to index mappings\n+            if (header != null) {\n+                for (int i = 0; i < header.length; i++) {\n+                    headerMapping.put(header[i], i);\n+                }\n+            }\n+        }\n     }\n \n     /**\n      * Returns an iterator on the records. IOExceptions occuring\n      * during the iteration are wrapped in a RuntimeException.\n      */\n-    public Iterator<String[]> iterator() {\n-        return new Iterator<String[]>() {\n-            private String[] current;\n+    public Iterator<CSVRecord> iterator() {\n+        return new Iterator<CSVRecord>() {\n+            private CSVRecord current;\n             \n             public boolean hasNext() {\n                 if (current == null) {\n                 return current != null;\n             }\n \n-            public String[] next() {\n-                String[] next = current;\n+            public CSVRecord next() {\n+                CSVRecord next = current;\n                 current = null;\n \n                 if (next == null) {\n                 return next;\n             }\n             \n-            private String[] getNextRecord() {\n+            private CSVRecord getNextRecord() {\n                 try {\n                     return getRecord();\n                 } catch (IOException e) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * A CSV record\n+ *\n+ * @author Emmanuel Bourg\n+ */\n+public class CSVRecord implements Serializable, Iterable<String> {\n+    \n+    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    \n+    /** The values of the record */\n+    private final String[] values;\n+\n+    /** The column name to index mapping. */\n+    private final Map<String, Integer> mapping;\n+\n+    CSVRecord(String[] values, Map<String, Integer> mapping) {\n+        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n+        this.mapping = mapping;\n+    }\n+\n+    /**\n+     * Returns a value by index.\n+     *\n+     * @param i the index of the column retrieved\n+     */\n+    public String get(int i) {\n+        return values[i];\n+    }\n+\n+    /**\n+     * Returns a value by name.\n+     *\n+     * @param name the name of the column retrieved\n+     */\n+    public String get(String name) {\n+        if (mapping == null) {\n+            throw new IllegalStateException(\"No header was specified, the record values can't be accessed by name\");\n+        }\n+\n+        Integer index = mapping.get(name);\n+\n+        return index != null ? values[index] : null;\n+    }\n+\n+    public Iterator<String> iterator() {\n+        return Arrays.asList(values).iterator();\n+    }\n+\n+    String[] values() {\n+        return values;\n+    }\n+\n+    /**\n+     * Returns the number of values in this record.\n+     */\n+    public int size() {\n+        return values.length;\n+    }\n+\n+    public String toString() {\n+        return Arrays.toString(values);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testImmutalibity() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\");\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\", null);\n         \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n \n     @Test\n     public void testMutators() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\");\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\", null);\n         \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     public void testGetLine() throws IOException {\n         CSVParser parser = new CSVParser(new StringReader(code));\n         for (String[] re : res) {\n-            assertTrue(Arrays.equals(re, parser.getRecord()));\n+            assertTrue(Arrays.equals(re, parser.getRecord().values()));\n         }\n         \n         assertTrue(parser.getRecord() == null);\n     @Test\n     public void testGetRecords() throws IOException {\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] tmp = parser.getRecords();\n-        assertEquals(res.length, tmp.length);\n-        assertTrue(tmp.length > 0);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n-            assertTrue(Arrays.equals(res[i], tmp[i]));\n+            assertTrue(Arrays.equals(res[i], records.get(i).values()));\n         }\n     }\n \n                 {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n         };\n         CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-        String[][] tmp = parser.getRecords();\n-        assertEquals(res.length, tmp.length);\n-        assertTrue(tmp.length > 0);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n-            assertTrue(Arrays.equals(res[i], tmp[i]));\n+            assertTrue(Arrays.equals(res[i], records.get(i).values()));\n         }\n     }\n \n                 {\"world\", \"\"}\n         };\n         CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-        String[][] tmp = parser.getRecords();\n-        assertEquals(res.length, tmp.length);\n-        assertTrue(tmp.length > 0);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n-            assertTrue(Arrays.equals(res[i], tmp[i]));\n+            assertTrue(Arrays.equals(res[i], records.get(i).values()));\n         }\n     }\n \n         \n         for (String code : codes) {\n             CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-            String[][] tmp = parser.getRecords();\n-            assertEquals(res.length, tmp.length);\n-            assertTrue(tmp.length > 0);\n+            List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n-                assertTrue(Arrays.equals(res[i], tmp[i]));\n+                assertTrue(Arrays.equals(res[i], records.get(i).values()));\n             }\n         }\n     }\n         };\n         for (String code : codes) {\n             CSVParser parser = new CSVParser(new StringReader(code));\n-            String[][] tmp = parser.getRecords();\n-            assertEquals(res.length, tmp.length);\n-            assertTrue(tmp.length > 0);\n+            List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n-                assertTrue(Arrays.equals(res[i], tmp[i]));\n+                assertTrue(Arrays.equals(res[i], records.get(i).values()));\n             }\n         }\n     }\n         };\n         for (String code : codes) {\n             CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-            String[][] tmp = parser.getRecords();\n-            assertEquals(res.length, tmp.length);\n-            assertTrue(tmp.length > 0);\n+            List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n-                assertTrue(Arrays.equals(res[i], tmp[i]));\n+                assertTrue(Arrays.equals(res[i], records.get(i).values()));\n             }\n         }\n     }\n         };\n         for (String code : codes) {\n             CSVParser parser = new CSVParser(new StringReader(code));\n-            String[][] tmp = parser.getRecords();\n-            assertEquals(res.length, tmp.length);\n-            assertTrue(tmp.length > 0);\n+            List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n-                assertTrue(Arrays.equals(res[i], tmp[i]));\n+                assertTrue(Arrays.equals(res[i], records.get(i).values()));\n             }\n         }\n     }\n                 {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n         };\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] tmp = parser.getRecords();\n-        assertEquals(res.length, tmp.length);\n-        assertTrue(tmp.length > 0);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n-            assertTrue(Arrays.equals(res[i], tmp[i]));\n+            assertTrue(Arrays.equals(res[i], records.get(i).values()));\n         }\n     }\n \n         };\n \n \n-        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\");\n+        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n-        String[][] tmp = parser.getRecords();\n-        assertTrue(tmp.length > 0);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n-            assertTrue(Arrays.equals(res[i], tmp[i]));\n+            assertTrue(Arrays.equals(res[i], records.get(i).values()));\n         }\n     }\n \n         };\n \n \n-        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\");\n+        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n-        String[][] tmp = parser.getRecords();\n-        assertTrue(tmp.length > 0);\n-\n-        if (!CSVPrinterTest.equals(res, tmp)) {\n-            assertTrue(false);\n-        }\n+        List<CSVRecord> records = parser.getRecords();\n+        assertTrue(records.size() > 0);\n+\n+        assertTrue(CSVPrinterTest.equals(res, records));\n     }\n \n     @Test\n     public void testDefaultFormat() throws IOException {\n-\n         String code = \"\"\n                 + \"a,b\\n\"            // 1)\n                 + \"\\\"\\n\\\",\\\" \\\"\\n\"   // 2)\n         assertEquals(CSVFormat.DISABLED, format.getCommentStart());\n \n         CSVParser parser = new CSVParser(code, format);\n-        String[][] tmp = parser.getRecords();\n-        assertTrue(tmp.length > 0);\n-\n-        if (!CSVPrinterTest.equals(res, tmp)) {\n-            assertTrue(false);\n-        }\n+        List<CSVRecord> records = parser.getRecords();\n+        assertTrue(records.size() > 0);\n+\n+        assertTrue(CSVPrinterTest.equals(res, records));\n \n         String[][] res_comments = {\n                 {\"a\", \"b\"},\n \n         format = CSVFormat.DEFAULT.withCommentStart('#');\n         parser = new CSVParser(code, format);\n-        tmp = parser.getRecords();\n-\n-        if (!CSVPrinterTest.equals(res_comments, tmp)) {\n-            assertTrue(false);\n-        }\n+        records = parser.getRecords();\n+        \n+        assertTrue(CSVPrinterTest.equals(res_comments, records));\n     }\n \n     @Test\n     public void testUnicodeEscape() throws Exception {\n         String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n         CSVParser parser = new CSVParser(code, CSVFormat.DEFAULT.withUnicodeEscapesInterpreted(true));\n-        final Iterator<String[]> iterator = parser.iterator();\n-        String[] data = iterator.next();\n-        assertEquals(2, data.length);\n-        assertEquals(\"abc\", data[0]);\n-        assertEquals(\"public\", data[1]);\n+        final Iterator<CSVRecord> iterator = parser.iterator();\n+        CSVRecord record = iterator.next();\n+        assertEquals(2, record.size());\n+        assertEquals(\"abc\", record.get(0));\n+        assertEquals(\"public\", record.get(1));\n         assertFalse(\"Should not have any more records\", iterator.hasNext());\n     }\n \n     public void testUnicodeEscapeMySQL() throws Exception {\n         String code = \"abc\\t\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n         CSVParser parser = new CSVParser(code, CSVFormat.MYSQL.withUnicodeEscapesInterpreted(true));\n-        final Iterator<String[]> iterator = parser.iterator();\n-        String[] data = iterator.next();\n-        assertEquals(2, data.length);\n-        assertEquals(\"abc\", data[0]);\n-        assertEquals(\"public\", data[1]);\n+        final Iterator<CSVRecord> iterator = parser.iterator();\n+        CSVRecord record = iterator.next();\n+        assertEquals(2, record.size());\n+        assertEquals(\"abc\", record.get(0));\n+        assertEquals(\"public\", record.get(1));\n         assertFalse(\"Should not have any more records\", iterator.hasNext());\n     }\n \n     public void testCarriageReturnLineFeedEndings() throws IOException {\n         String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] data = parser.getRecords();\n-        assertEquals(4, data.length);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(4, records.size());\n     }\n \n     @Test\n     public void testCarriageReturnEndings() throws IOException {\n         String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] data = parser.getRecords();\n-        assertEquals(4, data.length);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(4, records.size());\n     }\n \n     @Test\n     public void testLineFeedEndings() throws IOException {\n         String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] data = parser.getRecords();\n-        assertEquals(4, data.length);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(4, records.size());\n     }\n \n     @Test\n         //String code = \"world\\r\\n\\n\";\n         //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[][] data = parser.getRecords();\n-        assertEquals(3, data.length);\n-    }\n-\n-    @Test\n-    public void testForEach() {\n-        List<String[]> records = new ArrayList<String[]>();\n+        List<CSVRecord> records = parser.getRecords();\n+        assertEquals(3, records.size());\n+    }\n+\n+    @Test\n+    public void testForEach() throws Exception {\n+        List<CSVRecord> records = new ArrayList<CSVRecord>();\n         \n         Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n         \n-        for (String[] record : CSVFormat.DEFAULT.parse(in)) {\n+        for (CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n             records.add(record);\n         }\n         \n         assertEquals(3, records.size());\n-        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\"}, records.get(0)));\n-        assertTrue(Arrays.equals(new String[]{\"1\", \"2\", \"3\"}, records.get(1)));\n-        assertTrue(Arrays.equals(new String[]{\"x\", \"y\", \"z\"}, records.get(2)));\n-    }\n-\n-    @Test\n-    public void testIterator() {\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\"}, records.get(0).values()));\n+        assertTrue(Arrays.equals(new String[]{\"1\", \"2\", \"3\"}, records.get(1).values()));\n+        assertTrue(Arrays.equals(new String[]{\"x\", \"y\", \"z\"}, records.get(2).values()));\n+    }\n+\n+    @Test\n+    public void testIterator() throws Exception {\n         Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n         \n-        Iterator<String[]> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n+        Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n         \n         assertTrue(iterator.hasNext());\n         try {\n             fail(\"expected UnsupportedOperationException\");\n         } catch (UnsupportedOperationException expected) {\n         }\n-        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\"}, iterator.next()));\n-        assertTrue(Arrays.equals(new String[]{\"1\", \"2\", \"3\"}, iterator.next()));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values()));\n+        assertTrue(Arrays.equals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values()));\n         assertTrue(iterator.hasNext());\n         assertTrue(iterator.hasNext());\n         assertTrue(iterator.hasNext());\n-        assertTrue(Arrays.equals(new String[]{\"x\", \"y\", \"z\"}, iterator.next()));\n+        assertTrue(Arrays.equals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values()));\n         assertFalse(iterator.hasNext());\n         \n         try {\n             // expected\n         }\n     }\n+    \n+    @Test\n+    public void testHeader() throws Exception {\n+        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+        \n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(records.hasNext());\n+            CSVRecord record = records.next();\n+            assertEquals(record.get(0), record.get(\"a\"));\n+            assertEquals(record.get(1), record.get(\"b\"));\n+            assertEquals(record.get(2), record.get(\"c\"));\n+        }\n+        \n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test\n+    public void testProvidedHeader() throws Exception {\n+        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+\n+        for (int i = 0; i < 3; i++) {\n+            assertTrue(records.hasNext());\n+            CSVRecord record = records.next();\n+            assertEquals(record.get(0), record.get(\"A\"));\n+            assertEquals(record.get(1), record.get(\"B\"));\n+            assertEquals(record.get(2), record.get(\"C\"));\n+        }\n+\n+        assertFalse(records.hasNext());\n+    }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n \n import java.io.IOException;\n import java.io.StringWriter;\n+import java.util.List;\n import java.util.Random;\n \n import org.junit.Test;\n         // System.out.println(\"### :\" + printable(result));\n \n         CSVParser parser = new CSVParser(result, format);\n-        String[][] parseResult = parser.getRecords();\n+        List<CSVRecord> parseResult = parser.getRecords();\n \n         if (!equals(lines, parseResult)) {\n             System.out.println(\"Printer output :\" + printable(result));\n         }\n     }\n \n-    public static boolean equals(String[][] a, String[][] b) {\n-        if (a.length != b.length) {\n+    public static boolean equals(String[][] a, List<CSVRecord> b) {\n+        if (a.length != b.size()) {\n             return false;\n         }\n         for (int i = 0; i < a.length; i++) {\n             String[] linea = a[i];\n-            String[] lineb = b[i];\n+            String[] lineb = b.get(i).values();\n             if (linea.length != lineb.length) {\n                 return false;\n             }", "timestamp": 1331948344, "metainfo": ""}