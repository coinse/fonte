{"sha": "2c6120826245f89fedf2f936ab4a0c3edd8717f3", "log": "CSV-58 Unescape handling needs rethinking Fixed up most issues. TODO should TAB, FF and BACKSPACE be un/escaped?  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n                 tkn.type = TOKEN;\n                 break;\n             } else if (isEscape(c)) {\n-                tkn.content.append((char) readEscape());\n+                final int unescaped = readEscape();\n+                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n+                    tkn.content.append((char) c).append((char) in.getLastChar());\n+                } else {\n+                    tkn.content.append((char) unescaped);\n+                }\n                 c = in.read(); // continue\n             } else {\n                 tkn.content.append((char) c);\n             c = in.read();\n \n             if (isEscape(c)) {\n-                tkn.content.append((char) readEscape());\n+                final int unescaped = readEscape();\n+                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n+                    tkn.content.append((char) c).append((char) in.getLastChar());\n+                } else {\n+                    tkn.content.append((char) unescaped);\n+                }\n             } else if (isQuoteChar(c)) {\n                 if (isQuoteChar(in.lookAhead())) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     }\n \n     // TODO escape handling needs more work\n+    /**\n+     * Handle an escape sequence.\n+     * The current character must be the escape character.\n+     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n+     * on the input stream.\n+     * \n+     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n+     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n+     * the escape character is not allowed at end of strem\n+     */\n     int readEscape() throws IOException {\n-        // assume c is the escape char (normally a backslash)\n+        // the escape char has just been read (normally a backslash)\n         final int c = in.read();\n         switch (c) {\n         case 'r':\n             return BACKSPACE;\n         case 'f':\n             return FF;\n+        case CR:\n+        case LF:\n+        case FF: // TODO is this correct?\n+        case TAB: // TODO is this correct? Do tabs need to be escaped?\n+        case BACKSPACE: // TODO is this correct?\n+            return c;\n         case END_OF_STREAM:\n             throw new IOException(\"EOF whilst processing escape sequence\");\n         default:\n-            return c;\n+            // Now check for meta-characters\n+            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n+                return c;\n+            }\n+            // indicate unexpected char - available from in.getLastChar()\n+            return END_OF_STREAM;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n import java.io.StringReader;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n     }\n \n-    @Test\n+    @Test // TODO is this correct? Do we expect TAB to be un/escaped?\n     public void testEscapedTab() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n     }\n \n-    @Test\n+    @Test // TODO is this correct? Do we expect BACKSPACE to be un/escaped?\n     public void testEscapeBackspace() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n     }\n \n-    @Test\n+    @Test // TODO is this correct? Do we expect FF to be un/escaped?\n     public void testEscapeFF() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n     }\n \n-    // FIXME this should work after CSV-58 is resolved. Currently the result will be \"charactera\\NEscaped\"\n-    @Test\n-    @Ignore\n+    @Test\n     public void testEscapedMySqlNullValue() throws Exception {\n         // MySQL uses \\N to symbolize null values. We have to restore this\n         final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n     }\n \n-    // FIXME this should work after CSV-58 is resolved. Currently the result will be \"characteraEscaped\"\n-    @Test\n-    @Ignore\n+    @Test\n     public void testEscapedCharacter() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n     }\n \n-    // FIXME this should work after CSV-58 is resolved. Currently the result will be \"characterCREscaped\"\n-    @Test\n-    @Ignore\n+    @Test\n     public void testEscapedControlCharacter() throws Exception {\n-        // we are explicitly using an escape different from \\ here, because \\r is the character sequence for CR\n+        // we are explicitly using an escape different from \\ here\n         final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.newBuilder().withEscape('!').build());\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character!rEscaped\"));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test", "timestamp": 1367543434, "metainfo": ""}