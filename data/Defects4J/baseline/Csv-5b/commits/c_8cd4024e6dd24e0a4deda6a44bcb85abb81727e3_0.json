{"sha": "8cd4024e6dd24e0a4deda6a44bcb85abb81727e3", "log": "Add experimental state-driven lexer  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer3.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+\n+import static org.apache.commons.csv.Token.Type.*;\n+\n+/**\n+ * Experimental Lexer using enums to keep track of state and character type.\n+ * Unfortunately it is twice as slow.\n+ * For reference purpose only.\n+ *  \n+ */\n+class CSVLexer3 extends Lexer {\n+\n+    private final char escape;\n+    \n+    // ctor needs to be public so can be called dynamically by PerformanceTest class\n+    public CSVLexer3(CSVFormat format, ExtendedBufferedReader in) {\n+        super(format, in);\n+        this.escape = format.getEscape();\n+    }\n+    \n+    /**\n+     * Classify the character types\n+     */\n+    private static enum CharType {\n+        DELIM,\n+        ESCAPE,\n+        ENCAP,\n+        EOL,\n+        COMMENT_START,\n+        WHITESPACE,\n+        OTHER,\n+        EOFCHAR\n+    }\n+\n+    private CharType classify(int intch) {\n+        if (isDelimiter(intch)) {\n+            return CharType.DELIM;\n+        }\n+        if (isCommentStart(intch)) {\n+            return CharType.COMMENT_START;\n+        }\n+        if (isEncapsulator(intch)) {\n+            return CharType.ENCAP;\n+        }\n+        if (isEscape(intch)) {\n+            return CharType.ESCAPE;\n+        }\n+        if (intch == '\\r' || intch == '\\n') {\n+            return CharType.EOL;\n+        }\n+        if (isWhitespace(intch)) { // Must be after EOL check\n+            return CharType.WHITESPACE;\n+        }\n+        if (intch == ExtendedBufferedReader.END_OF_STREAM) {\n+            return CharType.EOFCHAR;\n+        }\n+        return CharType.OTHER;\n+    }\n+\n+    /**\n+     * Parsing states\n+     */\n+    private static enum State {\n+        BEGIN, PLAIN, INQUOTE, QUOTEQUOTE, ESCAPE_PLAIN, ESCAPE_QUOTE,\n+    }\n+\n+    /**\n+     * Returns the next token.\n+     * <p/>\n+     * A token corresponds to a term, a record change or an end-of-file indicator.\n+     *\n+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the Token.\n+     * @return the next token found\n+     * @throws java.io.IOException on stream access error\n+     */\n+    @Override\n+    Token nextToken(Token tkn) throws IOException {\n+\n+        State state = State.BEGIN;\n+        int intch;\n+        boolean trimTrailingSpaces = false;\n+        while(tkn.type == INVALID) {\n+            intch = in.read();\n+            CharType type = classify(intch);\n+            switch(state) {\n+                case BEGIN:\n+                    switch(type){\n+                        case COMMENT_START:\n+                            in.readLine();\n+                            tkn.type = COMMENT;\n+                            break;\n+                        case ENCAP:\n+                            state = State.INQUOTE;\n+                            break;\n+                        case DELIM:\n+                            tkn.type = TOKEN;\n+                            break;\n+                        case EOL:\n+                            tkn.type = EORECORD;\n+                            break;\n+                        case EOFCHAR:\n+                            tkn.type = EOF;\n+                            break;\n+                        case ESCAPE:\n+                            state = State.ESCAPE_PLAIN;\n+                            break;\n+                        case OTHER:\n+                            tkn.content.append((char) intch);\n+                            state = State.PLAIN;\n+                            break;\n+                        case WHITESPACE:\n+                            if (!surroundingSpacesIgnored){\n+                                tkn.content.append((char) intch);\n+                                state = State.PLAIN;                                \n+                            }\n+                            break;\n+                    }\n+                    break;\n+                case PLAIN:\n+                    switch(type){\n+                        case DELIM:\n+                            tkn.type = TOKEN;\n+                            break;\n+                        case EOL:\n+                            tkn.type = EORECORD;\n+                            break;\n+                        case EOFCHAR:\n+                            tkn.type = EOF;\n+                            break;\n+                        case ESCAPE:\n+                            state = State.ESCAPE_PLAIN;\n+                            break;\n+                        default:\n+                            trimTrailingSpaces = surroundingSpacesIgnored; // we have a plain token\n+                            tkn.content.append((char) intch);\n+                            break;\n+                    }\n+                    break;\n+                case INQUOTE: // Started a quoted string\n+                    switch(type){\n+                        case ENCAP:\n+                            state = State.QUOTEQUOTE;\n+                            break;\n+                        case ESCAPE:\n+                            state = State.ESCAPE_QUOTE;\n+                            break;\n+                        case EOFCHAR:\n+                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in quoted string\");\n+                        default:    \n+                            tkn.content.append((char) intch);\n+                            break;\n+                    }\n+                    break;\n+                case QUOTEQUOTE: // \"...\" seen, expecting end of token or \"\n+                    switch(type){\n+                        case DELIM:\n+                            tkn.type = TOKEN;\n+                            break;\n+                        case EOL:\n+                            tkn.type = EORECORD;\n+                            break;\n+                        case EOFCHAR:\n+                            tkn.type = EOF;\n+                            break;\n+                        case ENCAP: // \"...\"\" seen, append it\n+                            tkn.content.append((char) intch);\n+                            state = State.INQUOTE;\n+                            break;\n+                        case WHITESPACE: // trailing whitespace may be allowed\n+                            if (!surroundingSpacesIgnored) {\n+                                // error invalid char between token and next delimiter\n+                                throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            }\n+                            break;\n+                        // Everything else is invalid\n+                        case ESCAPE:\n+                        case OTHER:\n+                        case COMMENT_START:\n+                            // error invalid char between token and next delimiter\n+                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                    }\n+                    break;\n+                case ESCAPE_PLAIN:\n+                    switch(type){\n+                        case DELIM:\n+                        case ESCAPE:\n+                        case EOL:\n+                            tkn.content.append((char) intch);\n+                            state = State.PLAIN;\n+                            break;\n+                        case COMMENT_START: // TODO should comment be escaped?\n+                        case ENCAP: // TODO is this correct?\n+                        case OTHER: // TODO may need to escape further \n+                        case WHITESPACE:\n+                            tkn.content.append(escape);\n+                            tkn.content.append((char) intch);\n+                            break;\n+                        case EOFCHAR:\n+                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in escape sequence\");\n+                    }\n+                    break;\n+                case ESCAPE_QUOTE:\n+                    switch(type){\n+                        case ESCAPE:\n+                        case ENCAP: // this is the only required escape\n+                            tkn.content.append((char) intch);\n+                            break;\n+                        case COMMENT_START:\n+                        case DELIM:\n+                        case EOL:\n+                        case OTHER:\n+                        case WHITESPACE:\n+                            tkn.content.append(escape);\n+                            tkn.content.append((char) intch);\n+                            break;\n+                        case EOFCHAR:\n+                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in escape sequence\");\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        if (trimTrailingSpaces) {\n+            trimTrailingSpaces(tkn.content);\n+        }\n+        return tkn;\n+    }\n+}", "timestamp": 1332958328, "metainfo": ""}