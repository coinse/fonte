{"sha": "e1d8adbff1b6eb0be7099cf18623f5f8f51d48a9", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n \n     // // // Reuse mapper to keep tests bit faster\n \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     /*\n     /**********************************************************\n     public void testPrefixedUnwrappingSerialize() throws Exception\n     {\n         assertEquals(\"{\\\"name\\\":\\\"Tatu\\\",\\\"_x\\\":1,\\\"_y\\\":2}\",\n-                mapper.writeValueAsString(new PrefixUnwrap(\"Tatu\", 1, 2)));\n+                MAPPER.writeValueAsString(new PrefixUnwrap(\"Tatu\", 1, 2)));\n     }\n \n     public void testDeepPrefixedUnwrappingSerialize() throws Exception\n     {\n-        String json = mapper.writeValueAsString(new DeepPrefixUnwrap(\"Bubba\", 1, 1));\n+        String json = MAPPER.writeValueAsString(new DeepPrefixUnwrap(\"Bubba\", 1, 1));\n         assertEquals(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":1,\\\"u._y\\\":1}\", json);\n     }\n \n     public void testHierarchicConfigSerialize() throws Exception\n     {\n-        String json = mapper.writeValueAsString(new ConfigRoot(\"Fred\", 25));\n+        String json = MAPPER.writeValueAsString(new ConfigRoot(\"Fred\", 25));\n         assertEquals(\"{\\\"general.names.name\\\":\\\"Fred\\\",\\\"misc.value\\\":25}\", json);\n     }\n \n \n     public void testPrefixedUnwrapping() throws Exception\n     {\n-        PrefixUnwrap bean = mapper.readValue(\"{\\\"name\\\":\\\"Axel\\\",\\\"_x\\\":4,\\\"_y\\\":7}\", PrefixUnwrap.class);\n+        PrefixUnwrap bean = MAPPER.readValue(\"{\\\"name\\\":\\\"Axel\\\",\\\"_x\\\":4,\\\"_y\\\":7}\", PrefixUnwrap.class);\n         assertNotNull(bean);\n         assertEquals(\"Axel\", bean.name);\n         assertNotNull(bean.location);\n     \n     public void testDeepPrefixedUnwrappingDeserialize() throws Exception\n     {\n-        DeepPrefixUnwrap bean = mapper.readValue(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":2,\\\"u._y\\\":3}\",\n+        DeepPrefixUnwrap bean = MAPPER.readValue(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":2,\\\"u._y\\\":3}\",\n                 DeepPrefixUnwrap.class);\n         assertNotNull(bean.unwrapped);\n         assertNotNull(bean.unwrapped.location);\n     \n     public void testHierarchicConfigDeserialize() throws Exception\n     {\n-        ConfigRoot root = mapper.readValue(\"{\\\"general.names.name\\\":\\\"Bob\\\",\\\"misc.value\\\":3}\",\n+        ConfigRoot root = MAPPER.readValue(\"{\\\"general.names.name\\\":\\\"Bob\\\",\\\"misc.value\\\":3}\",\n                 ConfigRoot.class);\n         assertNotNull(root.general);\n         assertNotNull(root.general.names);\n \n     /*\n     /**********************************************************\n-    /* Tests, deserialization\n+    /* Tests, round-trip\n     /**********************************************************\n      */\n-    \n+\n     public void testHierarchicConfigRoundTrip() throws Exception\n     {\n         ConfigAlternate input = new ConfigAlternate(123, \"Joe\", 42);\n-        String json = mapper.writeValueAsString(input);\n-\n-        ConfigAlternate root = mapper.readValue(json, ConfigAlternate.class);\n+        String json = MAPPER.writeValueAsString(input);\n+\n+        ConfigAlternate root = MAPPER.readValue(json, ConfigAlternate.class);\n         assertEquals(123, root.id);\n         assertNotNull(root.general);\n         assertNotNull(root.general.names);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithPrefix.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithPrefix.java\n         public Map<String, Object> map;\n     }\n \n+    static class Parent {\n+        @JsonUnwrapped(prefix=\"c1\")\n+        public Child c1;\n+        @JsonUnwrapped(prefix=\"c2\")\n+        public Child c2;\n+      }\n+\n+    static class Child {\n+        @JsonUnwrapped(prefix=\"sc2\")\n+        public SubChild sc1;\n+      }\n+\n+    static class SubChild {\n+        public String value;\n+    }\n+    \n     // // // Reuse mapper to keep tests bit faster\n \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     /*\n     /**********************************************************\n \n     public void testMapUnwrapSerialize() throws Exception\n     {\n-        String json = mapper.writeValueAsString(new MapUnwrap(\"test\", 6));\n+        String json = MAPPER.writeValueAsString(new MapUnwrap(\"test\", 6));\n         assertEquals(\"{\\\"map.test\\\": 6}\", json);\n     }\n \n \n     public void testMapUnwrapDeserialize() throws Exception\n     {\n-        MapUnwrap root = mapper.readValue(\"{\\\"map.test\\\": 6}\", MapUnwrap.class);\n+        MapUnwrap root = MAPPER.readValue(\"{\\\"map.test\\\": 6}\", MapUnwrap.class);\n \n         assertEquals(1, root.map.size());\n         assertEquals(6, ((Number)root.map.get(\"test\")).intValue());\n     }\n+\n+    public void testIssue226() throws Exception\n+    {\n+        Parent input = new Parent();\n+        input.c1 = new Child();\n+        input.c1.sc1 = new SubChild();\n+        input.c1.sc1.value = \"a\";\n+        input.c2 = new Child();\n+        input.c2.sc1 = new SubChild();\n+        input.c2.sc1.value = \"b\";\n+\n+        String json = MAPPER.writeValueAsString(input);\n+//System.out.println(\"JSON -> \"+json);\n+\n+        Parent output = MAPPER.readValue(json, Parent.class);\n+        assertNotNull(output.c1);\n+        assertNotNull(output.c2);\n+\n+        assertNotNull(output.c1.sc1);\n+        assertNotNull(output.c2.sc1);\n+        \n+        assertEquals(\"a\", output.c1.sc1.value);\n+        assertEquals(\"b\", output.c2.sc1.value);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n      * Feature that determines whether {@link java.math.BigDecimal} entries are\n      * serialized using {@link java.math.BigDecimal#toPlainString()} to prevent\n      * values to be written using scientific notation.\n-     * <p>\n+     *<p>\n+     * NOTE: since this feature typically requires use of\n+     * {@link com.fasterxml.jackson.core.JsonGenerator#writeNumber(String)}\n+     * ot may cause compatibility problems since not all {@link com.fasterxml.jackson.core.JsonGenerator}\n+     * implementations support such mode of output: usually only text-based formats\n+     * support it.\n+     *<p>\n      * Feature is disabled by default.\n      */\n     WRITE_BIGDECIMAL_AS_PLAIN(false),\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             @SuppressWarnings(\"unchecked\")\n                 Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n             _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (Throwable e) { // is this possible?\n+        } catch (Throwable e) { // some class loading problems are Errors, others Exceptions\n             System.err.println(\"Problems with (optional) types: \"+e);\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n             // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n             if (value instanceof BigDecimal) {\n                 if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-                    jgen.writeNumber(((BigDecimal) value).toPlainString());\n-                } else {\n-                    jgen.writeNumber((BigDecimal) value);\n+                    // [Issue#232]: Ok, rather clumsy, but let's try to work around the problem with:\n+                    if (!(jgen instanceof TokenBuffer)) {\n+                        jgen.writeNumber(((BigDecimal) value).toPlainString());\n+                        return;\n+                    }\n                 }\n+                jgen.writeNumber((BigDecimal) value);\n             } else if (value instanceof BigInteger) {\n                 jgen.writeNumber((BigInteger) value);\n                 \n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n         @Override\n         public final Number getNumberValue() throws IOException, JsonParseException {\n             _checkIsNumber();\n-            return (Number) _currentObject();\n+            Object value = _currentObject();\n+            if (value instanceof Number) {\n+                return (Number) value;\n+            }\n+            // Difficult to really support numbers-as-Strings; but let's try.\n+            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n+            // try to determine Double/BigDecimal preference...\n+            if (value instanceof String) {\n+                String str = (String) value;\n+                if (str.indexOf('.') >= 0) {\n+                    return Double.parseDouble(str);\n+                }\n+                return Long.parseLong(str);\n+            }\n+            if (value == null) {\n+                return null;\n+            }\n+            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n+                    +value.getClass().getName());\n         }\n         \n         /*\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n package com.fasterxml.jackson.databind.node;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.*;\n \n import static org.junit.Assert.*;\n \n         assertTrue(n.isPojo());\n         assertSame(MARKER, ((POJONode) n).getPojo());\n     }\n+\n+    // [Issue#232]\n+    public void testBigDecimalAsPlainStringTreeConversion()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        String PI_STR = \"3.00000000\";\n+        map.put(\"pi\", new BigDecimal(PI_STR));\n+        JsonNode tree = mapper.valueToTree(map);\n+        assertNotNull(tree);\n+        assertEquals(1, tree.size());\n+        assertTrue(tree.has(\"pi\"));\n+    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n import java.io.*;\n import java.text.*;\n import java.util.*;\n-\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;", "timestamp": 1369526573, "metainfo": ""}