{"sha": "ed617abbaaaa2bc8c6f930aaa34812faaa17dc4d", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.NoClassDefFoundDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.type.*;\n         if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n             type = factory.mapAbstractType(config, type);\n         }\n-        BeanDescription beanDesc = config.introspect(type);\n+        BeanDescription beanDesc;\n+        try {\n+            beanDesc = config.introspect(type);\n+        } catch (NoClassDefFoundError error) {\n+            return new NoClassDefFoundDeserializer<Object>(error);\n+        }\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                 beanDesc.getClassInfo());\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * A deserializer that stores a {@link NoClassDefFoundError} error\n+ * and throws the stored exception when attempting to deserialize\n+ * a value. Null and empty values can be deserialized without error.\n+ */\n+public class NoClassDefFoundDeserializer<T> extends JsonDeserializer<T>\n+{\n+    private final NoClassDefFoundError _cause;\n+\n+    public NoClassDefFoundDeserializer(NoClassDefFoundError cause)\n+    {\n+        _cause = cause;\n+    }\n+\n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        throw _cause;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import javax.measure.Measure;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestNoClassDefFoundDeserializer extends BaseMapTest {\n+\n+    public static class Parent {\n+        public List<Child> child;\n+    }\n+\n+    public static class Child {\n+        public Measure measure;\n+    }\n+\n+    public void testClassIsMissing()\n+    {\n+        boolean missing = false;\n+        try {\n+            Class.forName(\"javax.measure.Measure\");\n+        } catch (ClassNotFoundException ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"javax.measure.Measure is not in classpath\", missing);\n+    }\n+\n+    public void testDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Parent result = m.readValue(\" { } \", Parent.class);\n+        assertNotNull(result);\n+    }\n+\n+    public void testUseMissingClass() throws Exception\n+    {\n+        boolean missing = false;\n+        try {\n+            ObjectMapper m = new ObjectMapper();\n+            m.readValue(\" { \\\"child\\\" : [{}] } \", Parent.class);\n+        } catch (NoClassDefFoundError ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"cannot instantiate a missing class\", missing);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+\n+/**\n+ * Annotation that may be used to add \"virtual\" properties to be written\n+ * after regular properties (although ordering may be changed using\n+ * both standard <code>@JsonPropertyOrder</code> annotation, and\n+ * properties of this annotation).\n+ * \n+ * @since 2.5\n+ */\n+public @interface JsonAppend\n+{\n+    public String[] attrs() default { };\n+\n+    public @interface Prop\n+    {\n+        public Class<? extends VirtualBeanPropertyWriter> value();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n import java.util.HashSet;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n             _accessorMethod = (Method) member.getMember();\n             _field = null;\n         } else {\n-            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n+            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed\n+            _accessorMethod = null;\n+            _field = null;\n         }\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n         // this will be resolved later on, unless nulls are to be suppressed\n         _nullSerializer = null;\n     }\n-\n+    \n     /**\n      * \"Copy constructor\" to be used by filtering sub-classes\n      */\n         if (_accessorMethod != null) {\n             return _accessorMethod.getGenericReturnType();\n         }\n-        return _field.getGenericType();\n+        if (_field != null) {\n+            return _field.getGenericType();\n+        }\n+        return null;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n         sb.append(\"property '\").append(getName()).append(\"' (\");\n         if (_accessorMethod != null) {\n             sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n+        } else if (_field != null) {\n+            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n         } else {\n-            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n+            sb.append(\"virtual\");\n         }\n         if (_serializer == null) {\n             sb.append(\", no static serializer\");\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link BeanPropertyWriter} implementation used with\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend}\n+ * to add \"virtual\" properties in addition to regular ones.\n+ * \n+ * @since 2.5\n+ */\n+public abstract class VirtualBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /*\n+    protected VirtualBeanPropertyWriter() {\n+        \n+    }\n+    */\n+\n+    /**\n+     * Pass-through constructor that may be used by sub-classes that\n+     * want full control over implementation.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            AnnotatedMember member, Annotations contextAnnotations,\n+            JavaType declaredType,\n+            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n+            boolean suppressNulls, Object suppressableValue)\n+    {\n+        super(propDef, member, contextAnnotations, declaredType,\n+                ser, typeSer, serType, suppressNulls, suppressableValue);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyWriter serialization method overrides\n+    /**********************************************************\n+     */\n+\n+    protected abstract Object value(Object bean) throws Exception;\n+    \n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                jgen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, jgen, prov);\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap m = _dynamicSerializers;\n+            ser = m.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(m, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        if (value == bean) { // simple check for direct cycles\n+            // three choices: exception; handled by call; or pass-through\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    \n+    @Override\n+    public void serializeAsElement(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, jgen, prov);\n+            } else {\n+                jgen.writeNull();\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    serializeAsPlaceholder(bean, jgen, prov);\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                serializeAsPlaceholder(bean, jgen, prov);\n+                return;\n+            }\n+        }\n+        if (value == bean) {\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+}", "timestamp": 1417500520, "metainfo": ""}