{"sha": "d1f58c6dc5ee84afd2818a45e25ed08937e999a7", "log": "Implement #522, give annotation access through PropertyWriter (similar to what BeanPropertyWriter had)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     @Override public PropertyName getWrapperName() { return _wrapperName; }\n     @Override public boolean isRequired() { return _metadata.isRequired(); }\n     @Override public PropertyMetadata getMetadata() { return _metadata; }\n-    \n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _member.getAnnotation(acls);\n     }\n \n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         return _contextAnnotations.get(acls);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.lang.annotation.Annotation;\n+\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n     public abstract String getName();\n \n     public abstract PropertyName getFullName();\n+\n+    /**\n+     * Convenience method for accessing annotation that may be associated\n+     * either directly on property, or, if not, via enclosing class (context).\n+     * This allows adding baseline contextual annotations, for example, by adding\n+     * an annotation for a given class and making that apply to all properties\n+     * unless overridden by per-property annotations.\n+     *<p>\n+     * This method is functionally equivalent to:\n+     *<pre>\n+     *  MyAnnotation ann = propWriter.getAnnotation(MyAnnotation.class);\n+     *  if (ann == null) {\n+     *    ann = propWriter.getContextAnnotation(MyAnnotation.class);\n+     *  }\n+     *</pre>\n+     * that is, tries to find a property annotation first, but if one is not\n+     * found, tries to find context-annotation (from enclosing class) of\n+     * same type.\n+     * \n+     * @since 2.5\n+     */\n+    public <A extends Annotation> A findAnnotation(Class<A> acls) {\n+        A ann = getAnnotation(acls);\n+        if (ann == null) {\n+            ann = getContextAnnotation(acls);\n+        }\n+        return ann;\n+    }\n     \n+    /**\n+     * Method for accessing annotations directly declared for property that this\n+     * writer is associated with.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for accessing annotations declared in context of the property that this\n+     * writer is associated with; usually this means annotations on enclosing class\n+     * for property.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getContextAnnotation(Class<A> acls);\n+\n     /*\n     /**********************************************************\n     /* Serialization methods, regular output\n     /**\n      * The main serialization method called by filter when property is to be written normally.\n      */\n-    public abstract void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * filtered, but the underlying data format requires a placeholder of some kind.\n      * This is usually the case for tabular (positional) data formats such as CSV.\n      */\n-    public abstract void serializeAsOmittedField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsOmittedField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n      * data format; so it is typically NOT called for fully tabular formats such as CSV,\n      * where logical output is still as form of POJOs.\n      */\n-    public abstract void serializeAsElement(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsElement(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * but then value is to be omitted. This requires output of a placeholder value\n      * of some sort; often similar to {@link #serializeAsOmittedField}.\n      */\n-    public abstract void serializeAsPlaceholder(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsPlaceholder(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.PropertyName;\n  */\n public class MapProperty extends PropertyWriter\n {\n-    protected TypeSerializer _typeSerializer;\n-    \n-    protected Object _key, _value;\n+    protected final TypeSerializer _typeSerializer;\n+\n+    protected final BeanProperty _property;\n+\n+    protected Object _key;\n \n     protected JsonSerializer<Object> _keySerializer, _valueSerializer;\n \n-    public MapProperty(TypeSerializer typeSer)\n+    /**\n+     * @deprecated since 2.4\n+     */\n+    @Deprecated // since 2.4\n+    public MapProperty(TypeSerializer typeSer) {\n+        this(typeSer, null);\n+    }\n+    \n+    public MapProperty(TypeSerializer typeSer, BeanProperty prop)\n     {\n         _typeSerializer = typeSer;\n+        _property = prop;\n+    }\n+\n+    /**\n+     * Deprecated method with wrong signature; value should not be assigned\n+     * to property, should be passed via proper call-through methods.\n+     * \n+     * @deprecated Since 2.5, remove in 2.6\n+     */\n+    @Deprecated // since 2.5\n+    public void reset(Object key, Object value,\n+            JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {\n+        reset(key, keySer, valueSer);\n     }\n     \n     /**\n      * Initialization method that needs to be called before passing\n      * property to filter.\n      */\n-    public void reset(Object key, Object value,\n+    public void reset(Object key,\n             JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer)\n     {\n         _key = key;\n-        _value = value;\n         _keySerializer = keySer;\n         _valueSerializer = valueSer;\n     }\n     }\n \n     @Override\n-    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getContextAnnotation(acls);\n+    }\n+    \n+    @Override\n+    public void serializeAsField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws IOException\n     {\n         _keySerializer.serialize(_key, jgen, provider);\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n \n     @Override\n-    public void serializeAsOmittedField(Object pojo, JsonGenerator jgen,\n+    public void serializeAsOmittedField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (!jgen.canOmitFields()) {\n     }\n \n     @Override\n-    public void serializeAsElement(Object pojo, JsonGenerator jgen,\n+    public void serializeAsElement(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n     \n     @Override\n-    public void serializeAsPlaceholder(Object pojo, JsonGenerator jgen,\n+    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         jgen.writeNull();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n-        final MapProperty prop = new MapProperty(_valueTypeSerializer);\n+        final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             // First, serialize key\n                     serializers = _dynamicValueSerializers;\n                 }\n             }\n-            prop.reset(keyElem, valueElem, keySer, valueSer);\n+            prop.reset(keyElem, keySer, valueSer);\n             try {\n-                filter.serializeAsField(value, jgen, provider, prop);\n+                filter.serializeAsField(valueElem, jgen, provider, prop);\n             } catch (Exception e) {\n                 // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n package com.fasterxml.jackson.databind.filter;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.PropertyWriter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n \n public class TestMapFiltering extends BaseMapTest\n {\n+    @Target({ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomOffset\n+    {\n+        public int value();\n+    }\n+\n     @SuppressWarnings(\"serial\")\n     @JsonFilter(\"filterForMaps\")\n     static class FilteredBean extends LinkedHashMap<String,Integer> { }\n     \n     static class MapBean {\n         @JsonFilter(\"filterX\")\n+        @CustomOffset(1)\n         public Map<String,Integer> values;\n         \n         public MapBean() {\n             values.put(\"c\", 9);\n         }\n     }\n-    \n+\n+    static class MyMapFilter implements PropertyFilter\n+    {\n+        @Override\n+        public void serializeAsField(Object value, JsonGenerator jgen,\n+                SerializerProvider provider, PropertyWriter writer)\n+            throws Exception\n+        {\n+            String name = writer.getName();\n+            if (!\"a\".equals(name)) {\n+                return;\n+            }\n+            CustomOffset n = writer.findAnnotation(CustomOffset.class);\n+            int offset = (n == null) ? 0 : n.value();\n+            Integer I = offset + ((Integer) value).intValue();\n+\n+            writer.serializeAsField(I, jgen, provider);\n+        }\n+\n+        @Override\n+        public void serializeAsElement(Object elementValue, JsonGenerator jgen,\n+                SerializerProvider prov, PropertyWriter writer)\n+                throws Exception {\n+            // not needed for testing\n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+                throws JsonMappingException {\n+            \n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor,\n+                SerializerProvider provider) throws JsonMappingException {\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(aposToQuotes(\"{'b':3}\"), json);\n     }\n     \n+    // [Issue#522]\n+    public void testMapFilteringWithAnnotations() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n+                new MyMapFilter());\n+        String json = MAPPER.writer(prov).writeValueAsString(new MapBean());\n+        // a=1 should become a=2\n+        assertEquals(aposToQuotes(\"{'values':{'a':2}}\"), json);\n+    }\n }", "timestamp": 1408684665, "metainfo": ""}