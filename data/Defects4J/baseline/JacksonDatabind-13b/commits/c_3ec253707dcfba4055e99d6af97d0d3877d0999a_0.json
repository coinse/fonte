{"sha": "3ec253707dcfba4055e99d6af97d0d3877d0999a", "log": "keep bundle annotations and prevent simple cycles  I don't see any downsides and this makes it easier to manipulate custom annotations, introspectors, serializers, and other parts that interact with annotated objects. The cycle detection is a bonus.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = result.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    result.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = target.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    target.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n      * annotation masking or overriding an annotation 'real' constructor\n      * has.\n      */\n-    public final void addOrOverride(Annotation a) {\n-        _annotations.add(a);\n+    public final boolean addOrOverride(Annotation a) {\n+        return _annotations.add(a);\n     }\n \n     /**\n      * annotation if and only if it is not yet present in the\n      * annotation map we have.\n      */\n-    public final void addIfNotPresent(Annotation a) {\n-        _annotations.addIfNotPresent(a);\n+    public final boolean addIfNotPresent(Annotation a) {\n+        return _annotations.addIfNotPresent(a);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n      * Method called to add specified annotation in the Map, but\n      * only if it didn't yet exist.\n      */\n-    public void addIfNotPresent(Annotation ann)\n+    public boolean addIfNotPresent(Annotation ann)\n     {\n         if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n             _add(ann);\n+            return true;\n         }\n+        return false;\n     }\n \n     /**\n      * Method called to add specified annotation in the Map.\n      */\n-    public void add(Annotation ann) {\n-        _add(ann);\n+    public boolean add(Annotation ann) {\n+        return _add(ann);\n     }\n \n     @Override\n     /**********************************************************\n      */\n \n-    protected final void _add(Annotation ann) {\n+    protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n-        _annotations.put(ann.annotationType(), ann);\n+        Annotation previous = _annotations.put(ann.annotationType(), ann);\n+        return (previous != null) && previous.equals(ann);\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n-import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyName;\n \n /* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n  */\n     public class Bean92 {\n         @Bundle92\n         protected String id = \"abc\";\n-    }    \n+    }\n+\n+    @HolderB\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderA {}\n+\n+    @HolderA\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderB {}\n+\n+    static class HolderHolder {\n+        @HolderA\n+        @InformativeHolder\n+        public int unimportant = 42;\n+    }\n+\n+    @JsonProperty\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface InformativeHolder {\n+        // doesn't really contribute to the test, but would be impossible without this feature\n+        boolean important() default true;\n+    }\n+\n+    static class BundleAnnotationIntrospector extends JacksonAnnotationIntrospector {\n+        @Override\n+        public PropertyName findNameForSerialization(Annotated a)\n+        {\n+            InformativeHolder informativeHolder = a.getAnnotation(InformativeHolder.class);\n+            if ((informativeHolder != null) && informativeHolder.important()) {\n+                return new PropertyName(\"important\");\n+            }\n+            return super.findNameForSerialization(a);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectMapper MAPPER = new ObjectMapper();\n-    \n+\n+    public void testKeepAnnotationBundle() throws Exception\n+    {\n+        MAPPER.setAnnotationIntrospector(new BundleAnnotationIntrospector());\n+        assertEquals(\"{\\\"important\\\":42}\", MAPPER.writeValueAsString(new HolderHolder()));\n+    }\n+\n+    public void testRecursiveBundles() throws Exception\n+    {\n+        assertEquals(\"{\\\"unimportant\\\":42}\", MAPPER.writeValueAsString(new HolderHolder()));\n+    }\n+\n     public void testBundledIgnore() throws Exception\n     {\n         assertEquals(\"{\\\"foobar\\\":13}\", MAPPER.writeValueAsString(new Bean()));", "timestamp": 1408145331, "metainfo": ""}