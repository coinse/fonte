{"sha": "26b2e1b3d7c8662092079a7ba6e997dafd87c47e", "log": "...", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n import java.util.*;\n \n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n \n public class TestDateDeserialization\n     extends BaseMapTest\n {\n+    // Test for [JACKSON-435]\n+    static class DateAsStringBean\n+    {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"/yyyy/MM/dd/\")\n+        public Date date;\n+    }\n+\n+    static class CalendarAsStringBean\n+    {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\";yyyy/MM/dd;\")\n+        public Calendar cal;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testDateUtil() throws Exception\n     {\n         long now = 123456789L;\n         java.util.Date value = new java.util.Date(now);\n \n         // First from long\n-        assertEquals(value, new ObjectMapper().readValue(\"\"+now, java.util.Date.class));\n+        assertEquals(value, MAPPER.readValue(\"\"+now, java.util.Date.class));\n \n         String dateStr = serializeDateAsString(value);\n-        java.util.Date result = new ObjectMapper().readValue(\"\\\"\"+dateStr+\"\\\"\", java.util.Date.class);\n+        java.util.Date result = MAPPER.readValue(\"\\\"\"+dateStr+\"\\\"\", java.util.Date.class);\n \n         assertEquals(\"Date: expect \"+value+\" (\"+value.getTime()+\"), got \"+result+\" (\"+result.getTime()+\")\", value.getTime(), result.getTime());\n     }\n          * as it is plain timestamp (all numbers, 64-bit)\n          */\n         String json = quote(String.valueOf(now));\n-        java.util.Date value = new ObjectMapper().readValue(json, java.util.Date.class);\n+        java.util.Date value = MAPPER.readValue(json, java.util.Date.class);\n         assertEquals(now, value.getTime());\n     }\n \n         // let's use an arbitrary value...\n         String inputStr = \"Sat, 17 Jan 2009 06:13:58 +0000\";\n         java.util.Date inputDate = fmt.parse(inputStr);\n-        assertEquals(inputDate, new ObjectMapper().readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class));\n+        assertEquals(inputDate, MAPPER.readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class));\n     }\n \n     /**\n         /* let's use simple baseline value, arbitrary date in GMT,\n          * using the standard notation\n          */\n-        ObjectMapper mapper = new ObjectMapper();\n         String inputStr = \"1972-12-28T00:00:00.000+0000\";\n-        Date inputDate = mapper.readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class);\n+        Date inputDate = MAPPER.readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class);\n         Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n         c.setTime(inputDate);\n         assertEquals(1972, c.get(Calendar.YEAR));\n \n         // And then the same, but using 'Z' as alias for +0000 (very common)\n         inputStr = \"1972-12-28T00:00:00.000Z\";\n-        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n         c.setTime(inputDate);\n         assertEquals(1972, c.get(Calendar.YEAR));\n         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n \n         // Same but using colon in timezone\n         inputStr = \"1972-12-28T00:00:00.000+00:00\";\n-        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n         c.setTime(inputDate);\n         assertEquals(1972, c.get(Calendar.YEAR));\n         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n \n         // Same but only passing hour difference as timezone\n         inputStr = \"1972-12-28T00:00:00.000+00\";\n-        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n         c.setTime(inputDate);\n         assertEquals(1972, c.get(Calendar.YEAR));\n         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n \n         inputStr = \"1984-11-30T00:00:00.000Z\";\n-        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n         c.setTime(inputDate);\n         assertEquals(1984, c.get(Calendar.YEAR));\n         assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));\n \n     public void testDateUtilISO8601NoTimezone() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // Timezone itself is optional as well... \n         String inputStr = \"1984-11-13T00:00:09\";\n-        Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n         Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n         c.setTime(inputDate);\n         assertEquals(1984, c.get(Calendar.YEAR));\n \n     public void testDateUtilISO8601JustDate() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // Plain date (no time)\n         String inputStr = \"1972-12-28\";\n-        Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n-        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n-        c.setTime(inputDate);\n-        assertEquals(1972, c.get(Calendar.YEAR));\n-        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n-        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n-\n-    }\n-\n+        Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+    }\n \n     @SuppressWarnings(\"deprecation\")\n     public void testDateSql() throws Exception\n         long now = value.getTime();\n \n         // First from long\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(value, mapper.readValue(String.valueOf(now), java.sql.Date.class));\n+        assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class));\n \n         // then from default java.sql.Date String serialization:\n         \n-        java.sql.Date result = mapper.readValue(quote(value.toString()), java.sql.Date.class);\n-        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n-        c.setTimeInMillis(result.getTime());\n+        java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class);\n+        Calendar c = gmtCalendar(result.getTime());\n         assertEquals(1999, c.get(Calendar.YEAR));\n         assertEquals(Calendar.APRIL, c.get(Calendar.MONTH));\n         assertEquals(19, c.get(Calendar.DAY_OF_MONTH));\n          *   formats as well\n          */\n         String expStr = \"1981-07-13\";\n-        result = mapper.readValue(quote(expStr), java.sql.Date.class);\n+        result = MAPPER.readValue(quote(expStr), java.sql.Date.class);\n         c.setTimeInMillis(result.getTime());\n         assertEquals(1981, c.get(Calendar.YEAR));\n         assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n          *   that something is funky with timezones (i.e. somewhere local TZ is\n          *   being used), but just can't resolve it. Hence, need to comment this:\n          */\n-        //assertEquals(expStr, result.toString());\n+//        assertEquals(expStr, result.toString());\n     }\n \n     public void testCalendar() throws Exception\n     {\n         // not ideal, to use (ever-changing) current date, but...\n-        java.util.Date now = new Date();\n         java.util.Calendar value = Calendar.getInstance();\n-        value.setTime(now);\n+        value.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        long l = 12345678L;\n+        value.setTimeInMillis(l);\n \n         // First from long\n-        assertEquals(value, new ObjectMapper().readValue(\"\"+now.getTime(), Calendar.class));\n-\n-        String dateStr = serializeDateAsString(now);\n-        Calendar result = new ObjectMapper().readValue(\"\\\"\"+dateStr+\"\\\"\", Calendar.class);\n+        Calendar result = MAPPER.readValue(\"\"+l, Calendar.class);\n+        assertEquals(l, result.getTimeInMillis());\n+\n+        String dateStr = serializeDateAsString(new Date(l));\n+        result = MAPPER.readValue(quote(dateStr), Calendar.class);\n \n         assertEquals(value, result);\n     }\n \n     public void testCustom() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n+        final ObjectMapper mapper = new ObjectMapper();\n         DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\");\n         df.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n         mapper.setDateFormat(df);\n      */\n     public void testDatesWithEmptyStrings() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n-        assertNull(mapper.readValue(quote(\"\"), java.util.Date.class));\n-        assertNull(mapper.readValue(quote(\"\"), java.util.Calendar.class));\n-        assertNull(mapper.readValue(quote(\"\"), java.sql.Date.class));\n+        assertNull(MAPPER.readValue(quote(\"\"), java.util.Date.class));\n+        assertNull(MAPPER.readValue(quote(\"\"), java.util.Calendar.class));\n+        assertNull(MAPPER.readValue(quote(\"\"), java.sql.Date.class));\n     }\n \n     // for [JACKSON-334]\n     public void test8601DateTimeNoMilliSecs() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // ok, Zebra, no milliseconds\n         for (String inputStr : new String[] {\n                \"2010-06-28T23:34:22Z\",\n                \"2010-06-28T23:34:22+0000\",\n                \"2010-06-28T23:34:22+00\",\n         }) {\n-            Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+            Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n             Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n             c.setTime(inputDate);\n             assertEquals(2010, c.get(Calendar.YEAR));\n \n     public void testTimeZone() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        TimeZone result = mapper.readValue(quote(\"PST\"), TimeZone.class);\n+        TimeZone result = MAPPER.readValue(quote(\"PST\"), TimeZone.class);\n         assertEquals(\"PST\", result.getID());\n+    }\n+\n+    public void testCustomDateWithAnnotation() throws Exception\n+    {\n+        DateAsStringBean result = MAPPER.readValue(\"{\\\"date\\\":\\\"/2005/05/25/\\\"}\", DateAsStringBean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.date);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        long l = result.date.getTime();\n+        if (l == 0L) {\n+            fail(\"Should not get null date\");\n+        }\n+        c.setTimeInMillis(l);\n+        assertEquals(2005, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));\n+        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    public void testCustomCalendarWithAnnotation() throws Exception\n+    {\n+        CalendarAsStringBean cbean = MAPPER.readValue(\"{\\\"cal\\\":\\\";2007/07/13;\\\"}\", CalendarAsStringBean.class);\n+        assertNotNull(cbean);\n+        assertNotNull(cbean.cal);\n+        // not sure why this is actually needed but...\n+        Calendar c = cbean.cal;\n+//        Calendar c = gmtCalendar(cbean.cal.getTimeInMillis());\n+        assertEquals(2007, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n+        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));\n     }\n     \n     /*\n     /**********************************************************\n      */\n \n-    String serializeDateAsString(java.util.Date value)\n+    private String serializeDateAsString(java.util.Date value)\n     {\n         /* Then from String. This is bit tricky, since JDK does not really\n          * suggest a 'standard' format. So let's try using something...\n         DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n         return df.format(value);\n     }\n+\n+    private static Calendar gmtCalendar(long time)\n+    {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTimeInMillis(time);\n+        return c;\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public void testCalendarMap() throws Exception\n     {\n     \t Calendar c = Calendar.getInstance();\n+    \t c.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n          c.setTimeInMillis(123456000L);\n          DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     \t String JSON = \"{ \\\"\"+fmt.format(c.getTime())+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";", "timestamp": 1329979821, "metainfo": ""}