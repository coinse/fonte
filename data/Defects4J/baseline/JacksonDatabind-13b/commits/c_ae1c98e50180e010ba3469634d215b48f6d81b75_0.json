{"sha": "ae1c98e50180e010ba3469634d215b48f6d81b75", "log": "Fix [JACKSON-746] for 2.0", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         return _findTypeResolver(config, ac, baseType);\n     }\n \n-    /**\n-     * Since 1.7, it is possible to use {@link JsonTypeInfo} from a property too.\n-     */\n     @Override\n     public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n             AnnotatedMember am, JavaType baseType)\n                 return cls;\n             }\n         }\n-        /* 30-Jun-2011, tatu: Here we used to have support for @JsonClass;\n-         *    removed in 1.9\n-         */\n         return null;\n     }\n \n                 return cls;\n             }\n         }\n-        /* 30-Jun-2011, tatu: Here we used to have support for @JsonKeyClass;\n-         *    removed in 1.9\n-         */\n         return null;\n     }\n \n         TypeResolverBuilder<?> b;\n         JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class);\n         JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class);\n+        \n         if (resAnn != null) {\n             /* 14-Aug-2010, tatu: not sure if this can ever happen normally, but unit\n              *    tests were able to trigger this... so let's check:\n              */\n             b = config.typeResolverBuilderInstance(ann, resAnn.value());\n         } else { // if not, use standard one, if indicated by annotations\n-            if (info == null || info.use() == JsonTypeInfo.Id.NONE) {\n+            if (info == null) {\n                 return null;\n+            }\n+            // bit special; must return 'marker' to block use of default typing:\n+            if (info.use() == JsonTypeInfo.Id.NONE) {\n+                return _constructNoTypeResolverBuilder();\n             }\n             b = _constructStdTypeResolverBuilder();\n         }\n     /**\n      * Helper method for constructing standard {@link TypeResolverBuilder}\n      * implementation.\n-     * \n-     * @since 1.7\n-     */\n-    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n-    {\n+     */\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n         return new StdTypeResolverBuilder();\n     }\n \n+    /**\n+     * Helper method for dealing with \"no type info\" marker; can't be null\n+     * (as it'd be replaced by default typing)\n+     */\n+    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n+        return StdTypeResolverBuilder.noTypeInfoBuilder();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n     protected String _typeProperty;\n \n     /**\n-     * @since 1.9\n+     * Default class to use in case type information is not available\n+     * or is broken.\n      */\n     protected Class<?> _defaultImpl;\n     \n      */\n \n     public StdTypeResolverBuilder() { }\n+\n+    public static StdTypeResolverBuilder noTypeInfoBuilder() {\n+        return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);\n+    }\n     \n     @Override\n     public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n     {\n+        if (_idType == JsonTypeInfo.Id.NONE) {\n+            return null;\n+        }\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n     {\n+        if (_idType == JsonTypeInfo.Id.NONE) {\n+            return null;\n+        }\n+\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n         \n         // First, method for converting type info to type id:\n             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());\n         case NAME:\n             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);\n-\n+        case NONE: // hmmh. should never get this far with 'none'\n+            return null;\n         case CUSTOM: // need custom resolver...\n-        case NONE: // hmmh. should never get this far with 'none'\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType);\n     }", "timestamp": 1326409048, "metainfo": ""}