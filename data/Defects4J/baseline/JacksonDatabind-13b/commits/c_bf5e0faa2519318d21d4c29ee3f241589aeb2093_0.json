{"sha": "bf5e0faa2519318d21d4c29ee3f241589aeb2093", "log": "Implement [JACKSON-802]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     /**\n      * Convenience method, functionally equivalent to:\n      *<pre>\n-     *  getConfig().constructType(cls);\n-     * </pre>\n-     */\n-    public final JavaType constructType(Class<?> cls) {\n-        return _config.constructType(cls);\n-    }\n-\n-    /**\n-     * Convenience method, functionally equivalent to:\n-     *<pre>\n      *  getConfig().getTypeFactory();\n      * </pre>\n      */\n      */\n     public abstract ReadableObjectId findObjectId(Object id,\n             ObjectIdGenerator<?> generator);\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, type handling\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Convenience method, functionally equivalent to:\n+     *<pre>\n+     *  getConfig().constructType(cls);\n+     * </pre>\n+     */\n+    public final JavaType constructType(Class<?> cls) {\n+        return _config.constructType(cls);\n+    }\n+\n+    /**\n+     * Helper method to use for locating Class for given name. Should be used\n+     * instead of basic <code>Class.forName(className);</code> as it can\n+     * try using contextual class loader, or use platform-specific workarounds\n+     * (like on Android, GAE).\n+     */\n+    public Class<?> findClass(String className) throws ClassNotFoundException\n+    {\n+        // By default, delegate to ClassUtil: can be overridden with custom handling\n+        return ClassUtil.findClass(className);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n @JacksonStdImpl\n public class ClassDeserializer\n         JsonToken curr = jp.getCurrentToken();\n         // Currently will only accept if given simple class name\n         if (curr == JsonToken.VALUE_STRING) {\n-            String className = jp.getText();\n-            // [JACKSON-597]: support primitive types (and void)\n-            if (className.indexOf('.') < 0) {\n-                if (\"int\".equals(className)) return Integer.TYPE;\n-                if (\"long\".equals(className)) return Long.TYPE;\n-                if (\"float\".equals(className)) return Float.TYPE;\n-                if (\"double\".equals(className)) return Double.TYPE;\n-                if (\"boolean\".equals(className)) return Boolean.TYPE;\n-                if (\"byte\".equals(className)) return Byte.TYPE;\n-                if (\"char\".equals(className)) return Character.TYPE;\n-                if (\"short\".equals(className)) return Short.TYPE;\n-                if (\"void\".equals(className)) return Void.TYPE;\n-            }\n+            String className = jp.getText().trim();\n             try {\n-                return Class.forName(jp.getText());\n-            } catch (ClassNotFoundException e) {\n-                throw ctxt.instantiationException(_valueClass, e);\n+                return ctxt.findClass(className);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n             }\n         }\n         throw ctxt.mappingException(_valueClass, curr);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n             return t;\n         }\n         try {\n-            /* [JACKSON-350]: Default Class.forName() won't work too well; context class loader\n-             *    seems like slightly better choice\n-             */\n-//          Class<?> cls = Class.forName(id);\n-            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-            Class<?> cls = Class.forName(id, true, loader);\n+            Class<?> cls =  ClassUtil.findClass(id);\n             return _typeFactory.constructSpecializedType(_baseType, cls);\n         } catch (ClassNotFoundException e) {\n             throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): no such class found\");\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Simple recursive-descent parser for parsing canonical {@link JavaType}\n     protected Class<?> findClass(String className, MyTokenizer tokens)\n     {\n         try {\n-            /* [JACKSON-350]: Default Class.forName() won't work too well; context class loader\n-             *    seems like slightly better choice\n-             */\n-//          return Class.forName(className);\n-            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-            return Class.forName(className, true, loader);\n+            return ClassUtil.findClass(className);\n         } catch (Exception e) {\n             if (e instanceof RuntimeException) {\n                 throw (RuntimeException) e;\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n         Class<?> cls = (classOrInstance instanceof Class<?>) ?\n             (Class<?>) classOrInstance : classOrInstance.getClass();\n         return cls.getName();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Class loading\n+    /**********************************************************\n+     */\n+\n+    public static Class<?> findClass(String className) throws ClassNotFoundException\n+    {\n+        // [JACKSON-597]: support primitive types (and void)\n+        if (className.indexOf('.') < 0) {\n+            if (\"int\".equals(className)) return Integer.TYPE;\n+            if (\"long\".equals(className)) return Long.TYPE;\n+            if (\"float\".equals(className)) return Float.TYPE;\n+            if (\"double\".equals(className)) return Double.TYPE;\n+            if (\"boolean\".equals(className)) return Boolean.TYPE;\n+            if (\"byte\".equals(className)) return Byte.TYPE;\n+            if (\"char\".equals(className)) return Character.TYPE;\n+            if (\"short\".equals(className)) return Short.TYPE;\n+            if (\"void\".equals(className)) return Void.TYPE;\n+        }\n+        // Two-phase lookup: first using context ClassLoader; then default\n+        Throwable prob = null;\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        \n+        if (loader != null) {\n+            try {\n+                return Class.forName(className, true, loader);\n+            } catch (Exception e) {\n+                prob = getRootCause(e);\n+            }\n+        }\n+        try {\n+            return Class.forName(className);\n+        } catch (Exception e) {\n+            if (prob == null) {\n+                prob = getRootCause(e);\n+            }\n+        }\n+        if (prob instanceof RuntimeException) {\n+            throw (RuntimeException) prob;\n+        }\n+        throw new ClassNotFoundException(prob.getMessage(), prob);\n     }\n     \n     /*", "timestamp": 1331271930, "metainfo": ""}