{"sha": "f6f0c9b90606b66cf788fe6f887a8941f5db0b92", "log": "Add test for #340 under failing; trying to resolve it, but without success yet.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n             } else {\n                 referencedType = params[0];\n             }\n-            return new AtomicReferenceDeserializer(referencedType);\n+            TypeDeserializer valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), referencedType);\n+            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n+            deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n+            return new AtomicReferenceDeserializer(referencedType, valueTypeDeser, deser);\n         }\n         return findOptionalStdDeserializer(ctxt, type, beanDesc);\n     }\n          * value (no need to check if explicit deser was specified):\n          */\n         type = modifyTypeByAnnotation(ctxt, setter, type);\n+        if (deser == null) {\n+            deser = type.getValueHandler();\n+        }\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         return new SettableAnyProperty(property, setter, type,\n                 deser, typeDeser);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n \n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n public class AtomicReferenceDeserializer\n-    extends StdScalarDeserializer<AtomicReference<?>>\n+    extends StdDeserializer<AtomicReference<?>>\n     implements ContextualDeserializer\n {\n     private static final long serialVersionUID = 1L;\n      */\n     protected final JavaType _referencedType;\n     \n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n     protected final JsonDeserializer<?> _valueDeserializer;\n     \n     /**\n      * @param referencedType Parameterization of this reference\n      */\n     public AtomicReferenceDeserializer(JavaType referencedType) {\n-        this(referencedType, null);\n+        this(referencedType, null, null);\n     }\n     \n     public AtomicReferenceDeserializer(JavaType referencedType,\n-            JsonDeserializer<?> deser)\n+            TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super(AtomicReference.class);\n         _referencedType = referencedType;\n         _valueDeserializer = deser;\n+        _valueTypeDeserializer = typeDeser;\n+    }\n+\n+    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser,\n+            JsonDeserializer<?> valueDeser)\n+    {\n+        return new AtomicReferenceDeserializer(_referencedType,\n+                typeDeser, valueDeser);\n     }\n     \n+    // Added in 2.3\n+    @Override\n+    public AtomicReference<?> getNullValue() {\n+        return new AtomicReference<Object>();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonDeserializer<?> deser = _valueDeserializer;\n+        TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        if (deser == null) {\n+            deser = ctxt.findContextualValueDeserializer(_referencedType, property);\n+        }\n+        if (typeDeser != null) {\n+            typeDeser = typeDeser.forProperty(property);\n+        }\n+        if (deser == _valueDeserializer && typeDeser == _valueTypeDeserializer) {\n+            return this;\n+        }\n+        return withResolved(typeDeser, deser);\n+    }\n+\n     @Override\n     public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-            BeanProperty property) throws JsonMappingException\n+    public AtomicReference<?> deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n     {\n-        JsonDeserializer<?> deser = _valueDeserializer;\n-        if (deser != null) {\n-            return this;\n+        final JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NULL) {\n+            return getNullValue();\n         }\n-        return new AtomicReferenceDeserializer(_referencedType,\n-                ctxt.findContextualValueDeserializer(_referencedType, property));\n+        /* 03-Nov-2013, tatu: This gets rather tricky with \"natural\" types\n+         *   (String, Integer, Boolean), which do NOT include type information.\n+         *   These might actually be handled ok except that nominal type here\n+         *   is `Optional`, so special handling is not invoked; instead, need\n+         *   to do a work-around here.\n+         */\n+        if (t != null && t.isScalarValue()) {\n+            return deserialize(jp, ctxt);\n+        }\n+        Object refd = _valueTypeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+        return new AtomicReference<Object>(refd);\n     }\n-}\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n-import com.fasterxml.jackson.databind.util.ISO8601Utils;\n \n public class TestDateDeserialization\n     extends BaseMapTest\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleAtomicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleAtomicTypes.java\n \n import java.util.concurrent.atomic.*;\n \n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n public class TestSimpleAtomicTypes\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n+    private final ObjectMapper MAPPER = objectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n     public void testAtomicBoolean() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        AtomicBoolean b = mapper.readValue(\"true\", AtomicBoolean.class);\n+        AtomicBoolean b = MAPPER.readValue(\"true\", AtomicBoolean.class);\n         assertTrue(b.get());\n     }\n \n     public void testAtomicInt() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        AtomicInteger value = mapper.readValue(\"13\", AtomicInteger.class);\n+        AtomicInteger value = MAPPER.readValue(\"13\", AtomicInteger.class);\n         assertEquals(13, value.get());\n     }\n \n     public void testAtomicLong() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        AtomicLong value = mapper.readValue(\"12345678901\", AtomicLong.class);\n+        AtomicLong value = MAPPER.readValue(\"12345678901\", AtomicLong.class);\n         assertEquals(12345678901L, value.get());\n     }\n \n     public void testAtomicReference() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        AtomicReference<long[]> value = mapper.readValue(\"[1,2]\",\n+        AtomicReference<long[]> value = MAPPER.readValue(\"[1,2]\",\n                 new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { });\n         Object ob = value.get();\n         assertNotNull(ob);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n public class TestCollectionSerialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     enum Key { A, B, C };\n \n     // Field-based simple bean with a single property, \"values\"\n     final static class CollectionBean\n     {\n         @JsonProperty // not required\n-            public Collection<Object> values;\n+        public Collection<Object> values;\n \n         public CollectionBean(Collection<Object> c) { values = c; }\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestSimpleAtomicTypes.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.concurrent.atomic.*;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/* Looks like AtomicReference has issues with polymorphic\n+ * types.\n+ */\n+public class TestSimpleAtomicTypes\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    private final ObjectMapper MAPPER = objectMapper();\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n+    @JsonSubTypes({ @JsonSubTypes.Type(Impl.class) })\n+    static abstract class Base { }\n+\n+    @JsonTypeName(\"I\")\n+    static class Impl extends Base {\n+        public int value;\n+\n+        public Impl() { }\n+        public Impl(int v) { value = v; }\n+    }\n+\n+    static class RefWrapper\n+    {\n+        public AtomicReference<Base> w;\n+\n+        public RefWrapper() { }\n+        public RefWrapper(Base b) {\n+            w = new AtomicReference<Base>(b);\n+        }\n+        public RefWrapper(int i) {\n+            w = new AtomicReference<Base>(new Impl(i));\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#340]\n+    public void testPolymorphicAtomicReference() throws Exception\n+    {\n+        RefWrapper input = new RefWrapper(13);\n+        String json = MAPPER.writeValueAsString(input);\n+        \n+        RefWrapper result = MAPPER.readValue(json, RefWrapper.class);\n+        assertNotNull(result.w);\n+        Object ob = result.w.get();\n+        assertEquals(Impl.class, ob);\n+        assertEquals(13, ((Impl) ob).value);\n+    }\n+}", "timestamp": 1383543063, "metainfo": ""}