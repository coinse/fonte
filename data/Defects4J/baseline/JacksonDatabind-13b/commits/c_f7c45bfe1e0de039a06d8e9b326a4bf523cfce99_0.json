{"sha": "f7c45bfe1e0de039a06d8e9b326a4bf523cfce99", "log": "Implemented [JACKSON-754]: Support for annotation bundles with @JacksonAnnotationsInside", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n      * is handled by this introspector.\n      */\n     public abstract boolean isHandled(Annotation ann);\n+\n+    /**\n+     * Method for checking whether given annotation is considered an\n+     * annotation bundle: if so, all meta-annotations it has will\n+     * be used instead of annotation (\"bundle\") itself.\n+     * \n+     * @since 2.0\n+     */\n+    public boolean isAnnotationBundle(Annotation ann) {\n+        return false;\n+    }\n     \n     /*\n     /**********************************************************\n         // // // Generic annotation properties, lookup\n         \n         @Override\n-        public boolean isHandled(Annotation ann)\n-        {\n+        public boolean isHandled(Annotation ann) {\n             return _primary.isHandled(ann) || _secondary.isHandled(ann);\n         }\n \n+        @Override\n+        public boolean isAnnotationBundle(Annotation ann) {\n+            return _primary.isAnnotationBundle(ann) || _secondary.isAnnotationBundle(ann);\n+        }\n+        \n         /*\n         /******************************************************\n         /* General class annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JacksonStdImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JacksonStdImpl.java\n  * added in cases where certain optimizations can be made if\n  * default instances are uses; for example when handling conversions\n  * of \"natural\" JSON types like Strings, booleans and numbers.\n- * \n- * @since 1.6\n  */\n @Target({ElementType.TYPE})\n @Retention(RetentionPolicy.RUNTIME)\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonDeserialize.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonDeserialize.java\n  *  )\n  *</pre>\n  *<p>\n- * NOTE: since version 1.2, annotation has also been applicable\n- * to (constructor) parameters\n- *\n- * @since 1.1\n  */\n-@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonDeserialize\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonSerialize.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonSerialize.java\n  * specifically, 'using' has precedence over 'as', which has precedence\n  * over 'typing' setting)\n  */\n-@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonSerialize\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n  * for converting between java types and type id included in JSON content.\n  * In simplest cases this can be a simple class with static mapping between\n  * type names and matching classes.\n- * \n- * @author tatu\n- * @since 1.5\n  */\n-@Target({ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n @Retention(RetentionPolicy.RUNTIME)\n @JacksonAnnotation\n public @interface JsonTypeIdResolver\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n  * needed for handling of polymorphic types (or sometimes just for linking\n  * abstract types to concrete types)\n  */\n-@Target({ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonTypeResolver\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonValueInstantiator.java\n /**\n  * Annotation that can be used to indicate a {@link ValueInstantiator} to use\n  * for creating instances of specified type.\n- * \n- * @since 1.9\n  */\n-@Target(ElementType.TYPE)\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonValueInstantiator\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n import java.lang.reflect.*;\n import java.util.*;\n \n-import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\n import com.fasterxml.jackson.databind.util.Annotations;\n      * Initialization method that will recursively collect Jackson\n      * annotations for this class and all super classes and\n      * interfaces.\n-     *<p>\n-     * Starting with 1.2, it will also apply mix-in annotations,\n-     * as per [JACKSON-76]\n      */\n     public void resolveClassAnnotations()\n     {\n         // first, mixIns, since they have higher priority then class methods\n         if (mixInCls != null) {\n             _addMethodMixIns(methodFilter, methods, mixInCls, mixIns);\n-        }\n-\n+        }        \n         if (cls == null) { // just so caller need not check when passing super-class\n             return;\n         }\n+\n         // then methods from the class itself\n         for (Method m : cls.getDeclaredMethods()) {\n             if (!_isIncludableMethod(m, methodFilter)) {\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                if (_isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n-                _addAnnotationsIfNotPresent(result, bundles.toArray(new Annotation[bundles.size()]));\n+                for (Annotation[] annotations : bundles) {\n+                    _addAnnotationsIfNotPresent(result, annotations);\n+                }\n             }\n         }\n     }\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                if (_isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n-                _addAnnotationsIfNotPresent(target, bundles.toArray(new Annotation[bundles.size()]));\n+                for (Annotation[] annotations : bundles) {\n+                    _addAnnotationsIfNotPresent(target, annotations);\n+                }\n             }\n         }\n     }\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                if (_isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                 }\n             }\n             if (bundles != null) { // and then bundles, if any: important for precedence\n-                _addOrOverrideAnnotations(target, bundles.toArray(new Annotation[bundles.size()]));\n+                for (Annotation[] annotations : bundles) {\n+                    _addOrOverrideAnnotations(target, annotations);\n+                }\n             }\n         }\n     }\n         _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n     }\n \n+   private final boolean _isAnnotationBundle(Annotation ann)\n+   {\n+       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n+   }\n+    \n     /*\n     /**********************************************************\n     /* Other methods\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         return acls.getAnnotation(JacksonAnnotation.class) != null;\n     }\n \n+    /**\n+     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n+     * are considered bundles.\n+     */\n+    @Override\n+    public boolean isAnnotationBundle(Annotation ann)\n+    {\n+        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* General annotations\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n+ */\n+public class TestAnnotionBundles extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @JacksonAnnotationsInside\n+    @JsonIgnore\n+    private @interface MyIgnoral { }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @JacksonAnnotationsInside\n+    @JsonProperty(\"foobar\")\n+    private @interface MyRename { }\n+\n+    protected final static class Bean {\n+        @MyIgnoral\n+        public String getIgnored() { return \"foo\"; }\n+ \n+        @MyRename\n+        public int renamed = 13;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n+    public void testBundledIgnore() throws Exception\n+    {\n+        assertEquals(\"{\\\"foobar\\\":13}\", mapper.writeValueAsString(new Bean()));\n+    }\n+}", "timestamp": 1326767207, "metainfo": ""}