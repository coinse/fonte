{"sha": "b8f2c0236e09a88ead4f11c568e06020d53f7102", "log": "Refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n  * Abstract class that defines API used by {@link ObjectMapper} (and\n  * other chained {@link JsonDeserializer}s too) to deserialize Objects of\n  * arbitrary types from JSON, using provided {@link JsonParser}.\n+ *<p>\n+ * Custom deserializers should usually not directly extend this class,\n+ * but instead extend {@link com.fasterxml.jackson.databind.deser.std.StdDeserializer}\n+ * (or its subtypes like {@link com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer}).\n+ *<p>\n+ * If deserializer is an aggregate one -- meaning it delegates handling of some\n+ * of its contents by using other deserializer(s) -- it typically also needs\n+ * to implement {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer},\n+ * which can locate dependant deserializers. This is important to allow dynamic\n+ * overrides of deserializers; separate call interface is needed to separate\n+ * resolution of dependant deserializers (which may have cyclic link back\n+ * to deserializer itself, directly or indirectly).\n+ *<p>\n+ * In addition, to support per-property annotations (to configure aspects\n+ * of deserialization on per-property basis), deserializers may want\n+ * to implement \n+ * {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer},\n+ * which allows specialization of deserializers: call to\n+ * {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer#createContextual}\n+ * is passed information on property, and can create a newly configured\n+ * deserializer for handling that particular property.\n+ *<p>\n+ * If both\n+ * {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer} and\n+ * {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}\n+ * are implemented, resolution of deserializers occurs before\n+ * contextualization.\n  */\n public abstract class JsonDeserializer<T>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n  * arbitrary types into JSON, using provided {@link JsonGenerator}.\n  *<p>\n  * NOTE: it is recommended that custom serializers extend\n- * {@link com.fasterxml.jackson.databind.ser.std.SerializerBase} instead\n+ * {@link com.fasterxml.jackson.databind.ser.std.StdSerializer} instead\n  * of this class, since it will implement many of optional\n  * methods of this class.\n+ *<p>\n+ * If serializer is an aggregate one -- meaning it delegates handling of some\n+ * of its contents by using other serializer(s) -- it typically also needs\n+ * to implement {@link com.fasterxml.jackson.databind.ser.ResolvableSerializer},\n+ * which can locate secondary serializers needed. This is important to allow dynamic\n+ * overrides of serializers; separate call interface is needed to separate\n+ * resolution of secondary serializers (which may have cyclic link back\n+ * to serializer itself, directly or indirectly).\n+ *<p>\n+ * In addition, to support per-property annotations (to configure aspects\n+ * of serialization on per-property basis), serializers may want\n+ * to implement \n+ * {@link com.fasterxml.jackson.databind.ser.ContextualSerializer},\n+ * which allows specialization of serializers: call to\n+ * {@link com.fasterxml.jackson.databind.ser.ContextualSerializer#createContextual}\n+ * is passed information on property, and can create a newly configured\n+ * serializer for handling that particular property.\n+ *<p>\n+ * If both\n+ * {@link com.fasterxml.jackson.databind.ser.ResolvableSerializer} and\n+ * {@link com.fasterxml.jackson.databind.ser.ContextualSerializer}\n+ * are implemented, resolution of serializers occurs before\n+ * contextualization.\n  */\n public abstract class JsonSerializer<T>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n  * but before being used. This is typically used to resolve references\n  * to other contained types; for example, bean deserializers use this\n  * to eagerly find deserializers for contained field types.\n+ *<p>\n+ * Note that {@link #resolve} method does NOT allow returning anything \n+ * (specifically, a new deserializer instance): reason for this is that\n+ * allowing this would not work with proper handling of cyclic dependencies,\n+ * which are resolved by two-phase processing, where initially constructed\n+ * deserializer is added as known deserializer, and only after this\n+ * resolution is done. Resolution is the part that results in lookups for\n+ * dependant deserializers, which may include handling references to\n+ * deserializer itself.\n  *<p>\n  * Note that in cases where deserializer needs both contextualization and\n  * resolution -- that is, implements both this interface and {@link ContextualDeserializer}\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n         return _serializers.entrySet();\n     }\n \n-    public static class XMLGregorianCalendarSerializer extends SerializerBase<XMLGregorianCalendar>\n+    public static class XMLGregorianCalendarSerializer extends StdSerializer<XMLGregorianCalendar>\n     {\n         public XMLGregorianCalendarSerializer() {\n             super(XMLGregorianCalendar.class);\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n public class DOMSerializer\n-    extends SerializerBase<Node>\n+    extends StdSerializer<Node>\n {\n     protected final DOMImplementationLS _domImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n     /**********************************************************\n      */\n \n-    protected abstract static class JodaSerializer<T> extends SerializerBase<T>\n+    protected abstract static class JodaSerializer<T> extends StdSerializer<T>\n     {\n         final static DateTimeFormatter _localDateTimeFormat = ISODateTimeFormat.dateTime();\n         final static DateTimeFormatter _localDateFormat = ISODateTimeFormat.date();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n /**\n  * Intermediate base class for serializers used for serializing\n  * ({@link java.util.Iterator}s).\n  */\n public abstract class ContainerSerializer<T>\n-    extends SerializerBase<T>\n+    extends StdSerializer<T>\n {\n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.std.NonTypedScalarSerializerBase;\n-import com.fasterxml.jackson.databind.ser.std.ScalarSerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n \n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n      */\n     @JacksonStdImpl\n     public final static class IntLikeSerializer\n-        extends ScalarSerializerBase<Number>\n+        extends StdScalarSerializer<Number>\n     {\n         final static IntLikeSerializer instance = new IntLikeSerializer();\n     \n \n     @JacksonStdImpl\n     public final static class LongSerializer\n-        extends ScalarSerializerBase<Long>\n+        extends StdScalarSerializer<Long>\n     {\n         final static LongSerializer instance = new LongSerializer();\n     \n     \n     @JacksonStdImpl\n     public final static class FloatSerializer\n-        extends ScalarSerializerBase<Float>\n+        extends StdScalarSerializer<Float>\n     {\n         final static FloatSerializer instance = new FloatSerializer();\n     \n      */\n     @JacksonStdImpl\n     public final static class NumberSerializer\n-        extends ScalarSerializerBase<Number>\n+        extends StdScalarSerializer<Number>\n     {\n         public final static NumberSerializer instance = new NumberSerializer();\n     \n      */\n     @JacksonStdImpl\n     public final static class SqlDateSerializer\n-        extends ScalarSerializerBase<java.sql.Date>\n+        extends StdScalarSerializer<java.sql.Date>\n     {\n         public SqlDateSerializer() { super(java.sql.Date.class); }\n \n \n     @JacksonStdImpl\n     public final static class SqlTimeSerializer\n-        extends ScalarSerializerBase<java.sql.Time>\n+        extends StdScalarSerializer<java.sql.Time>\n     {\n         public SqlTimeSerializer() { super(java.sql.Time.class); }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n \n /**\n  * as Map/Object key).\n  */\n public final class FailingSerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n {\n     final String _msg;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n public class UnknownSerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n {\n     public UnknownSerializer() {\n         super(Object.class);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n  * is not the primary design goal.\n  */\n public abstract class BeanSerializerBase\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n     implements ResolvableSerializer, SchemaAware\n {\n     final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n  */\n @JacksonStdImpl\n public class CalendarSerializer\n-    extends ScalarSerializerBase<Calendar>\n+    extends StdScalarSerializer<Calendar>\n {\n     public static CalendarSerializer instance = new CalendarSerializer();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n  */\n @JacksonStdImpl\n public class DateSerializer\n-    extends ScalarSerializerBase<Date>\n+    extends StdScalarSerializer<Date>\n {\n     public static DateSerializer instance = new DateSerializer();\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n                  * default serializer tho -- so ideally code should be rewritten)\n                  */\n                 // ... and lovely two-step casting process too...\n-                SerializerBase<?> ser = (SerializerBase<?>) provider.findValueSerializer(\n+                StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(\n                         key.getDeclaringClass(), _property);\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 // clumsy, but has to do for now:\n-                SerializerBase<?> ser = (SerializerBase<?>) provider.findValueSerializer(key.getDeclaringClass(),\n+                StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(),\n                         _property);\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n /**\n  * Standard serializer used for {@link java.lang.Enum} types.\n  *<p>\n- * Based on {@link ScalarSerializerBase} since the JSON value is\n+ * Based on {@link StdScalarSerializer} since the JSON value is\n  * scalar (String).\n  * \n  * @author tatu\n  */\n @JacksonStdImpl\n public class EnumSerializer\n-    extends ScalarSerializerBase<Enum<?>>\n+    extends StdScalarSerializer<Enum<?>>\n {\n     /**\n      * This map contains pre-resolved values (since there are ways\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n  * with registration, since same serializer is to be used for sub-classes.\n  */\n public class InetAddressSerializer\n-    extends ScalarSerializerBase<InetAddress>\n+    extends StdScalarSerializer<InetAddress>\n {\n     public final static InetAddressSerializer instance = new InetAddressSerializer();\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n  */\n @JacksonStdImpl\n public class JsonValueSerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n     implements ResolvableSerializer, SchemaAware\n {\n     protected final Method _accessorMethod;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n  * {@link java.lang.Double} and {@link java.lang.Boolean}.\n  */\n public abstract class NonTypedScalarSerializerBase<T>\n-    extends ScalarSerializerBase<T>\n+    extends StdScalarSerializer<T>\n {\n     protected NonTypedScalarSerializerBase(Class<T> t) {\n         super(t);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n  */\n @JacksonStdImpl\n public class NullSerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n {\n     public final static NullSerializer instance = new NullSerializer();\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n  */\n @JacksonStdImpl\n public class RawSerializer<T>\n-    extends SerializerBase<T>\n+    extends StdSerializer<T>\n {\n     /**\n      * Constructor takes in expected type of values; but since caller\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n  */\n @JacksonStdImpl\n public class SerializableSerializer\n-    extends SerializerBase<JsonSerializable>\n+    extends StdSerializer<JsonSerializable>\n {\n     public final static SerializableSerializer instance = new SerializableSerializer();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n  * that contain static (non-dynamic) value types.\n  */\n public abstract class StaticListSerializerBase<T extends Collection<?>>\n-    extends SerializerBase<T>\n+    extends StdSerializer<T>\n {\n     /**\n      * Property that contains String List to serialize, if known.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n      */\n     @JacksonStdImpl\n     public final static class ByteArraySerializer\n-        extends SerializerBase<byte[]>\n+        extends StdSerializer<byte[]>\n     {\n         public ByteArraySerializer() {\n             super(byte[].class);\n      */\n     @JacksonStdImpl\n     public final static class CharArraySerializer\n-        extends SerializerBase<char[]>\n+        extends StdSerializer<char[]>\n     {\n         public CharArraySerializer() { super(char[].class); }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n      */\n \n     public final static class AtomicBooleanSerializer\n-        extends ScalarSerializerBase<AtomicBoolean>\n+        extends StdScalarSerializer<AtomicBoolean>\n     {\n         public AtomicBooleanSerializer() { super(AtomicBoolean.class, false); }\n     \n     }\n     \n     public final static class AtomicIntegerSerializer\n-        extends ScalarSerializerBase<AtomicInteger>\n+        extends StdScalarSerializer<AtomicInteger>\n     {\n         public AtomicIntegerSerializer() { super(AtomicInteger.class, false); }\n     \n     }\n \n     public final static class AtomicLongSerializer\n-        extends ScalarSerializerBase<AtomicLong>\n+        extends StdScalarSerializer<AtomicLong>\n     {\n         public AtomicLongSerializer() { super(AtomicLong.class, false); }\n     \n     }\n     \n     public final static class AtomicReferenceSerializer\n-        extends SerializerBase<AtomicReference<?>>\n+        extends StdSerializer<AtomicReference<?>>\n     {\n         public AtomicReferenceSerializer() { super(AtomicReference.class, false); }\n \n      * absolute (but not canonical) name as String value\n      */\n     public final static class FileSerializer\n-        extends ScalarSerializerBase<File>\n+        extends StdScalarSerializer<File>\n     {\n         public FileSerializer() { super(File.class); }\n \n      * we can just serialize the class name and that should be enough.\n      */\n     public final static class ClassSerializer\n-        extends ScalarSerializerBase<Class<?>>\n+        extends StdScalarSerializer<Class<?>>\n     {\n         public ClassSerializer() { super(Class.class, false); }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n /**\n  * Specialized serializer that can be used as the generic key\n  * Objects.\n  */\n public class StdKeySerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n {\n     final static StdKeySerializer instace = new StdKeySerializer();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n      */\n \n     public static class StringKeySerializer\n-        extends SerializerBase<String>\n+        extends StdSerializer<String>\n     {\n         public StringKeySerializer() { super(String.class); }\n         \n     }\n \n     public static class DateKeySerializer\n-        extends SerializerBase<Date>\n+        extends StdSerializer<Date>\n     {\n         protected final static JsonSerializer<?> instance = new DateKeySerializer();\n \n     }\n \n     public static class CalendarKeySerializer\n-        extends SerializerBase<Calendar>\n+        extends StdSerializer<Calendar>\n     {\n         protected final static JsonSerializer<?> instance = new CalendarKeySerializer();\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+public abstract class StdScalarSerializer<T>\n+    extends StdSerializer<T>\n+{\n+    protected StdScalarSerializer(Class<T> t) {\n+        super(t);\n+    }\n+\n+    /**\n+     * Alternate constructor that is (alas!) needed to work\n+     * around kinks of generic type handling\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected StdScalarSerializer(Class<?> t, boolean dummy) {\n+        super((Class<T>) t);\n+    }\n+    \n+    /**\n+     * Default implementation will write type prefix, call regular serialization\n+     * method (since assumption is that value itself does not need JSON\n+     * Array or Object start/end markers), and then write type suffix.\n+     * This should work for most cases; some sub-classes may want to\n+     * change this behavior.\n+     */\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForScalar(value, jgen);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Base class used by all standard serializers, and can also\n+ * be used for custom serializers (in fact, this is the recommended\n+ * base class to use).\n+ * Provides convenience methods for implementing {@link SchemaAware}\n+ */\n+public abstract class StdSerializer<T>\n+    extends JsonSerializer<T>\n+    implements SchemaAware\n+{\n+    /**\n+     * Nominal type supported, usually declared type of\n+     * property for which serializer is used.\n+     */\n+    protected final Class<T> _handledType;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected StdSerializer(Class<T> t) {\n+        _handledType = t;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected StdSerializer(JavaType type) {\n+        _handledType = (Class<T>) type.getRawClass();\n+    }\n+    \n+    /**\n+     * Alternate constructor that is (alas!) needed to work\n+     * around kinks of generic type handling\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected StdSerializer(Class<?> t, boolean dummy) {\n+        _handledType = (Class<T>) t;\n+    }\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    \n+    @Override\n+    public final Class<T> handledType() { return _handledType; }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for JSON Schema generation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\");\n+    }\n+    \n+    protected ObjectNode createObjectNode() {\n+        return JsonNodeFactory.instance.objectNode();\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type)\n+    {\n+        ObjectNode schema = createObjectNode();\n+        schema.put(\"type\", type);\n+        return schema;\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n+    {\n+        ObjectNode schema = createSchemaNode(type);\n+        // as per [JACKSON-563]. Note that 'required' defaults to false\n+        if (!isOptional) {\n+            schema.put(\"required\", !isOptional);\n+        }\n+        return schema;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods for exception handling\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will modify caught exception (passed in as argument)\n+     * as necessary to include reference information, and to ensure it\n+     * is a subtype of {@link IOException}, or an unchecked exception.\n+     *<p>\n+     * Rules for wrapping and unwrapping are bit complicated; essentially:\n+     *<ul>\n+     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n+     * <li>\"Plain\" IOExceptions (ones that are not of type\n+     *   {@link JsonMappingException} are to be passed as is\n+     *</ul>\n+     */\n+    public void wrapAndThrow(SerializerProvider provider,\n+            Throwable t, Object bean, String fieldName)\n+        throws IOException\n+    {\n+        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+         *   StackOverflow: usually due to infinite loop. But that\n+         *   usually gets hidden within an InvocationTargetException...\n+         */\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // Ditto for IOExceptions... except for mapping exceptions!\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n+    }\n+\n+    public void wrapAndThrow(SerializerProvider provider,\n+            Throwable t, Object bean, int index)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors are to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // Ditto for IOExceptions... except for mapping exceptions!\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, index);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n public class TimeZoneSerializer\n-    extends ScalarSerializerBase<TimeZone>\n+    extends StdScalarSerializer<TimeZone>\n {\n     public final static TimeZoneSerializer instance = new TimeZoneSerializer();\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n  */\n @JacksonStdImpl\n public class ToStringSerializer\n-    extends SerializerBase<Object>\n+    extends StdSerializer<Object>\n {\n     /**\n      * Singleton instance to use.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n  */\n @JacksonStdImpl\n public class TokenBufferSerializer\n-    extends SerializerBase<TokenBuffer>\n+    extends StdSerializer<TokenBuffer>\n {\n     public TokenBufferSerializer() { super(TokenBuffer.class); }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.module.SimpleSerializers;\n-import com.fasterxml.jackson.databind.ser.std.ScalarSerializerBase;\n-import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n public class TestSimpleModule extends BaseMapTest\n {\n     static enum SimpleEnum { A, B; }\n     \n     // Extend SerializerBase to get access to declared handledType\n-    static class CustomBeanSerializer extends SerializerBase<CustomBean>\n+    static class CustomBeanSerializer extends StdSerializer<CustomBean>\n     {\n         public CustomBeanSerializer() { super(CustomBean.class); }\n \n         }\n     }\n \n-    static class SimpleEnumSerializer extends SerializerBase<SimpleEnum>\n+    static class SimpleEnumSerializer extends StdSerializer<SimpleEnum>\n     {\n         public SimpleEnumSerializer() { super(SimpleEnum.class); }\n \n         public String getText() { return \"2\"; }\n     }\n \n-    static class BaseSerializer extends ScalarSerializerBase<Base>\n+    static class BaseSerializer extends StdScalarSerializer<Base>\n     {\n         public BaseSerializer() { super(Base.class); }\n         ", "timestamp": 1327171641, "metainfo": ""}