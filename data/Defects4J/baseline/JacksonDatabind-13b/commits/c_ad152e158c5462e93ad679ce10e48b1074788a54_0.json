{"sha": "ad152e158c5462e93ad679ce10e48b1074788a54", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * Method for enabling automatic inclusion of type information, needed\n      * for proper deserialization of polymorphic types (unless types\n      * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n+     *<P>\n+     * NOTE: use of {@link JsonTypeInfo.As#EXTERNAL_PROPERTY} is <b>NOT SUPPORTED</b>;\n+     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n+     * this limitation explicit.\n      * \n      * @param applicability Defines kinds of types for which additional type information\n      *    is added; see {@link DefaultTyping} for more information.\n      */\n     public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n     {\n+        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n+         *   use \"As.EXTERNAL_PROPERTY\", since that will not work.\n+         */\n+        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n+        }\n+        \n         TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n         // we'll always use full class name, when using defaulting\n         typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n         return _unknownTypeSerializer;\n     }\n \n+    /**\n+     * Helper method called to see if given serializer is considered to be\n+     * something returned by {@link #getUnknownTypeSerializer}, that is, something\n+     * for which no regular serializer was found or constructed.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n+        return (ser == _unknownTypeSerializer) || (ser == null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Methods for creating instances based on annotations\n      * @return Serializer if one can be found, null if not.\n      */\n     protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType)\n-\t\tthrows JsonMappingException\n+        throws JsonMappingException\n     {        \n         // Fast lookup from local lookup thingy works?\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        // If not, maybe shared map already has it?\n-        ser = _serializerCache.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        return _createAndCacheUntypedSerializer(runtimeType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(runtimeType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(runtimeType);\n+                /* 18-Sep-2014, tatu: This is unfortunate patch over related change\n+                 *    that pushes creation of \"unknown type\" serializer deeper down\n+                 *    in BeanSerializerFactory; as a result, we need to \"undo\" creation\n+                 *    here.\n+                 */\n+                if (isUnknownTypeSerializer(ser)) {\n+                    return null;\n+                }\n+            }\n+        }\n+        return ser;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n         for (Linked<?> node = accessors; node != null; node = node.next) {\n             PropertyName name = node.name;\n             if (!node.isNameExplicit || name == null) { // no explicit name -- problem!\n+                // [Issue#541] ... but only as long as it's visible\n+                if (!node.isVisible) {\n+                    continue;\n+                }\n+                \n                 throw new IllegalStateException(\"Conflicting/ambiguous property name definitions (implicit name '\"\n                         +_name+\"'): found multiple explicit names: \"\n                         +newNames+\", but also implicit accessor: \"+node);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                     // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                     if (ser == null) {\n                         ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n+                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n+                        //   post-processed\n+                        if (ser == null) {\n+                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n+                        }\n                     }\n                 }\n             }\n         \n         JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n         \n-        /* However, after all modifications: no properties, no serializer\n-         * (note; as per [JACKSON-670], check was moved later on from an earlier location)\n-         */\n         if (ser == null) {\n-            /* 27-Nov-2009, tatu: Except that as per [JACKSON-201], we are\n-             *   ok with that as long as it has a recognized class annotation\n-             *  (which may come from a mix-in too)\n-             */\n+            // If we get this far, there were no properties found, so no regular BeanSerializer\n+            // would be constructed. But, couple of exceptions.\n+            // First: if there are known annotations, just create 'empty bean' serializer\n             if (beanDesc.hasKnownClassAnnotations()) {\n                 return builder.createDummy();\n             }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n package com.fasterxml.jackson.databind.introspect;\n \n+import com.fasterxml.jackson.annotation.*;\n+\n import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.*;\n \n /**\n         }\n     }\n \n+    // For [Issue#541]\n+    static class Bean541 {\n+        protected String str;\n+\n+        @JsonCreator\n+        public Bean541(@JsonProperty(\"str\") String str) {\n+            this.str = str;\n+        }\n+\n+        @JsonProperty(\"s\")\n+        public String getStr() {\n+            return str;\n+        }\n+     }\n+     \n     /*\n     /**********************************************************\n     /* Test methods\n         Infernal inf = mapper.readValue(aposToQuotes(\"{'stuff':'Bob'}\"), Infernal.class);\n         assertNotNull(inf);\n     }\n+\n+    public void testIssue541() throws Exception {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.disable(\n+                MapperFeature.AUTO_DETECT_CREATORS,\n+                MapperFeature.AUTO_DETECT_FIELDS,\n+                MapperFeature.AUTO_DETECT_GETTERS,\n+                MapperFeature.AUTO_DETECT_IS_GETTERS,\n+                MapperFeature.AUTO_DETECT_SETTERS,\n+                MapperFeature.USE_GETTERS_AS_SETTERS\n+        );\n+        Bean541 data = mapper.readValue(\"{\\\"str\\\":\\\"the string\\\"}\", Bean541.class);\n+        if (data == null) {\n+            throw new IllegalStateException(\"data is null\");\n+        }\n+        if (!\"the string\".equals(data.getStr())) {\n+            throw new IllegalStateException(\"bad value for data.str\");\n+        }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n      * Another enum type, but this time forcing sub-classing\n      */\n     enum ComplexChoice {\n-    \tMAYBE(true), PROBABLY_NOT(false);\n-\n-    \tprivate boolean state;\n+        MAYBE(true), PROBABLY_NOT(false);\n+\n+        private boolean state;\n     \t\n-    \tprivate ComplexChoice(boolean b) { state = b; }\n+        private ComplexChoice(boolean b) { state = b; }\n     \t\n         @Override\n-    \tpublic String toString() { return String.valueOf(state); }\n+        public String toString() { return String.valueOf(state); }\n     }\n \n     // [JACKSON-311]\n         assertEquals(\"abc\", ((StringBean) result[0]).name);\n     }\n \n+    // with 2.5, another test to check that \"as-property\" is valid option\n+    public void testBeanAsObjectUsingAsProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL,\n+                \".hype\");\n+        // note: need to wrap, to get declared as Object\n+        String json = m.writeValueAsString(new StringBean(\"abc\"));\n+\n+        System.err.println(\"JSON == \"+json);\n+        \n+        // Ok: serialization seems to work as expected. Now deserialize:\n+        Object result = m.readValue(json, Object.class);\n+        assertNotNull(result);\n+        assertEquals(StringBean.class, result.getClass());\n+        assertEquals(\"abc\", ((StringBean) result).name);\n+    }\n+    \n     /**\n      * Unit test that verifies that an abstract bean is stored with type information\n      * if default type information is enabled for non-concrete types.\n         String json = mapper.writeValueAsString(new BeanHolder(new StringBean(\"punny\")));\n         assertEquals(\"{\\\"bean\\\":{\\\"*CLASS*\\\":\\\"com.fasterxml.jackson.databind.jsontype.TestDefaultForObject$StringBean\\\",\\\"name\\\":\\\"punny\\\"}}\", json);\n     }\n+\n+    public void testNoGoWithExternalProperty() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT,\n+                    JsonTypeInfo.As.EXTERNAL_PROPERTY);\n+            fail(\"Should not have passed\");\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"Can not use includeAs of EXTERNAL_PROPERTY\");\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n @SuppressWarnings(\"serial\")\n public class TestBeanSerializer extends BaseMapTest\n {\n-    /*\n-    /********************************************************\n-    /* Helper types\n-    /********************************************************\n-     */\n-\n-    static class ModuleImpl extends SimpleModule\n+    static class SerializerModifierModule extends SimpleModule\n     {\n         protected BeanSerializerModifier modifier;\n         \n-        public ModuleImpl(BeanSerializerModifier modifier)\n+        public SerializerModifierModule(BeanSerializerModifier modifier)\n         {\n             super(\"test\", Version.unknownVersion());\n             this.modifier = modifier;\n         }\n     }\n \n+    // [Issue#539]: use post-modifier\n+    static class EmptyBeanModifier539 extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            System.err.println(\"DEBUG: changeProperties!\");\n+            return beanProperties;\n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+                BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+System.err.println(\"DEBUG: modifySer!\");            \n+            return new BogusBeanSerializer(42);\n+        }\n+    }\n     // [Issue#120], arrays, collections, maps\n     \n     static class ArraySerializerModifier extends BeanSerializerModifier {\n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        mapper.registerModule(new SerializerModifierModule(new RemovingModifier(\"a\")));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testPropertyReorder() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReorderingModifier()));\n+        mapper.registerModule(new SerializerModifierModule(new ReorderingModifier()));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testBuilderReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));\n+        mapper.registerModule(new SerializerModifierModule(new BuilderModifier(new BogusBeanSerializer(17))));\n         Bean bean = new Bean();\n         assertEquals(\"17\", mapper.writeValueAsString(bean));\n     }    \n     public void testSerializerReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));\n+        mapper.registerModule(new SerializerModifierModule(new ReplacingModifier(new BogusBeanSerializer(123))));\n         Bean bean = new Bean();\n         assertEquals(\"123\", mapper.writeValueAsString(bean));\n     }\n         assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n     }\n \n+    // [Issue#539]\n+    public void testEmptyBean539() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\", Version.unknownVersion()) {\n+            @Override\n+            public void setupModule(SetupContext context)\n+            {\n+                super.setupModule(context);\n+                context.addBeanSerializerModifier(new EmptyBeanModifier539());\n+            }\n+        });\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"42\", json);\n+    }\n+    \n     // [Issue#121]\n \n     public void testModifyArraySerializer() throws Exception", "timestamp": 1411255525, "metainfo": ""}