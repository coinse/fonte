{"sha": "d06750f22fb83313d9de3b8cf00f105614645b78", "log": "Added case insensitivity as a DeserializationFeature.  Will close #566 in jackson-databind.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * Feature is disabled by default.\n      */\n     UNWRAP_ROOT_VALUE(false),\n+    \n+    /**\n+     * Feature that will allow for more forgiving deserialization of incoming JSON.\n+     * If enabled, the bean properties will be matched using their lower-case\n+     * equivalents.\n+     * <p>\n+     * Feature is disabled by default.\n+     */\n+    ACCEPT_CASE_INSENSITIVE_PROPERTIES(false),\n \n     /*\n     /******************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n     final protected boolean _defaultViewInclusion;\n     \n+    final protected boolean _caseInsensitivePropertyComparison;\n+    \n     /*\n     /**********************************************************\n     /* Accumulated information about properties\n     { \n         _beanDesc = beanDesc;\n         _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n+        _caseInsensitivePropertyComparison = config.isEnabled(DeserializationFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n     }\n \n     /**\n     {\n         _beanDesc = src._beanDesc;\n         _defaultViewInclusion = src._defaultViewInclusion;\n+        _caseInsensitivePropertyComparison = src._caseInsensitivePropertyComparison;\n \n         // let's make copy of properties\n         _properties.putAll(src._properties);\n     public JsonDeserializer<?> build()\n     {\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         // view processing must be enabled if:\n         }\n         // And if so, we can try building the deserializer\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         boolean anyViews = !_defaultViewInclusion;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n     private final int _hashMask;\n \n     private final int _size;\n+    \n+    private final boolean _caseInsensitivePropertyComparison;\n \n     /**\n      * Counter we use to keep track of insertion order of properties\n      */\n     private int _nextBucketIndex = 0;\n \n-    public BeanPropertyMap(Collection<SettableBeanProperty> properties)\n-    {\n+    public BeanPropertyMap(Collection<SettableBeanProperty> properties, boolean caseInsensitivePropertyComparison)\n+    {\n+        _caseInsensitivePropertyComparison = caseInsensitivePropertyComparison;\n         _size = properties.size();\n         int bucketCount = findSize(_size);\n         _hashMask = bucketCount-1;\n         Bucket[] buckets = new Bucket[bucketCount];\n         for (SettableBeanProperty property : properties) {\n-            String key = property.getName();\n+            String key = getPropertyName(property);\n             int index = key.hashCode() & _hashMask;\n             buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++);\n         }\n         _buckets = buckets;\n     }\n \n-    private BeanPropertyMap(Bucket[] buckets, int size, int index)\n+    private BeanPropertyMap(Bucket[] buckets, int size, int index, boolean caseInsensitivePropertyComparison)\n     {\n         _buckets = buckets;\n         _size = size;\n         _hashMask = buckets.length-1;\n         _nextBucketIndex = index;\n+        _caseInsensitivePropertyComparison = caseInsensitivePropertyComparison;\n     }\n     \n     /**\n         final int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n-        final String propName = newProperty.getName();\n+        final String propName = getPropertyName(newProperty);\n         // and then see if it's add or replace:\n-        SettableBeanProperty oldProp = find(newProperty.getName());\n+        SettableBeanProperty oldProp = find(propName);\n         if (oldProp == null) { // add\n             // first things first: add or replace?\n     \t        // can do a straight copy, since all additions are at the front\n     \t        int index = propName.hashCode() & _hashMask;\n     \t        newBuckets[index] = new Bucket(newBuckets[index],\n     \t                propName, newProperty, _nextBucketIndex++);\n-    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n+    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex, _caseInsensitivePropertyComparison);\n         }\n         // replace: easy, close + replace\n-        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n+        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex, _caseInsensitivePropertyComparison);\n         newMap.replace(newProperty);\n         return newMap;\n     }\n             newProps.add(prop);\n         }\n         // should we try to re-index? Ordering probably changed but called probably doesn't want changes...\n-        return new BeanPropertyMap(newProps);\n+        return new BeanPropertyMap(newProps, _caseInsensitivePropertyComparison);\n     }\n     \n     public BeanPropertyMap assignIndexes()\n         }\n         return result;\n     }\n+    \n+    // Confining this case insensitivity to this function (and the find method) in case we want to\n+    // apply a particular locale to the lower case function.  For now, using the default.\n+    private String getPropertyName(SettableBeanProperty prop) {\n+    \treturn _caseInsensitivePropertyComparison ? prop.getName().toLowerCase() : prop.getName();\n+    }\n \n     /*\n     /**********************************************************\n         if (key == null) {\n             throw new IllegalArgumentException(\"Can not pass null property name\");\n         }\n+        \n+        if (_caseInsensitivePropertyComparison) {\n+        \tkey = key.toLowerCase();\n+        }\n+        \n         int index = key.hashCode() & _hashMask;\n         Bucket bucket = _buckets[index];\n         // Let's unroll first lookup since that is null or match in 90+% cases\n      */\n     public void replace(SettableBeanProperty property)\n     {\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n \n         /* This is bit tricky just because buckets themselves\n     public void remove(SettableBeanProperty property)\n     {\n         // Mostly this is the same as code with 'replace', just bit simpler...\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n         Bucket tail = null;\n         boolean found = false;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n         Bean result = r.readValue(JSON);\n         assertNull(result);\n     }\n+\n+    // [Databind#566]\n+    public void testCaseInsensitiveDeserialization() throws Exception\n+    {\n+    \tfinal String JSON = \"{\\\"Value1\\\" : {\\\"nAme\\\" : \\\"fruit\\\", \\\"vALUe\\\" : \\\"apple\\\"}, \\\"valUE2\\\" : {\\\"NAME\\\" : \\\"color\\\", \\\"value\\\" : \\\"red\\\"}}\";\n+        \n+        // first, verify default settings which do not accept improper case\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(DeserializationFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES));\n+        \n+        try {\n+            mapper.readValue(JSON, Issue476Bean.class);\n+            \n+            fail(\"Should not accept improper case properties by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Unrecognized field\");\n+            assertValidLocation(e.getLocation());\n+        }\n+\n+        // Definitely not OK to enable dynamically - the BeanPropertyMap (which is the consumer of this particular feature) gets cached.\n+        mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+        ObjectReader r = mapper.reader(Issue476Bean.class);\n+        Issue476Bean result = r.readValue(JSON);\n+        assertEquals(result.value1.name, \"fruit\");\n+        assertEquals(result.value1.value, \"apple\");\n+    }\n     \n     // [Issue#120]\n     public void testModifyArrayDeserializer() throws Exception", "timestamp": 1412097891, "metainfo": ""}