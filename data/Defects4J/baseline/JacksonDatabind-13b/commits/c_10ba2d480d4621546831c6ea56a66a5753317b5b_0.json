{"sha": "10ba2d480d4621546831c6ea56a66a5753317b5b", "log": "Minor addition to JavaType (getContainedTypeOrUnknown()); fix a tiny potential problem with JsonValueSerializer contextualization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n import java.lang.reflect.Modifier;\n \n import com.fasterxml.jackson.core.type.ResolvedType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for type token classes used both to contain information\n \n     @Override\n     public JavaType containedType(int index) { return null; }\n-\n+       \n     @Override\n     public String containedTypeName(int index) { return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API beyond ResolvedType\n+    /**********************************************************\n+     */\n+    \n+    // NOTE: not defined in Resolved type\n+    /**\n+     * Convenience method that is functionally same as:\n+     *<code>\n+     * JavaType t = containedType(index);\n+     * if (t == null) {\n+     *    t = TypeFactory.unknownType();\n+     * }\n+     *</code>\n+     * and typically used to eliminate need for null checks for common case\n+     * where we just want to check if containedType is available first; and\n+     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n+     * basically).\n+     *\n+     * @since 2.5\n+     */\n+    public JavaType containedTypeOrUnknown(int index) {\n+        JavaType t = containedType(index);\n+        return (t == null)  ? TypeFactory.unknownType() : t;\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n                  *   to serializer factory at this point... \n                  */\n                 // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-                ser = provider.findPrimaryPropertySerializer(t, _property);\n+                ser = provider.findPrimaryPropertySerializer(t, property);\n                 /* 09-Dec-2010, tatu: Turns out we must add special handling for\n                  *   cases where \"native\" (aka \"natural\") type is being serialized,\n                  *   using standard serializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n         return o;\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException", "timestamp": 1411367479, "metainfo": ""}