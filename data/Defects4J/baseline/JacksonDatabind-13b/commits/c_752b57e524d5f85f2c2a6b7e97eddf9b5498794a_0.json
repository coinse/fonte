{"sha": "752b57e524d5f85f2c2a6b7e97eddf9b5498794a", "log": "Implemented [Issue-22], add ObjectMapper.setAnnotationIntrospectors(...)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     /**\n      * Method that returns the shared default {@link SerializationConfig}\n      * object that defines configuration settings for serialization.\n-     * Returned object is \"live\" meaning that changes will be used\n-     * for future serialization operations for this mapper when using\n-     * mapper's default configuration\n+     *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n      */\n     public SerializationConfig getSerializationConfig() {\n         return _serializationConfig;\n      * Method that returns\n      * the shared default {@link DeserializationConfig} object\n      * that defines configuration settings for deserialization.\n-     * Returned object is \"live\" meaning that changes will be used\n-     * for future deserialization operations for this mapper when using\n-     * mapper's default configuration\n+     *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n      */\n     public DeserializationConfig getDeserializationConfig() {\n         return _deserializationConfig;\n         _deserializationConfig = _deserializationConfig.with(ai);\n         return this;\n     }\n+\n+    /**\n+     * Method for changing {@link AnnotationIntrospector} instances used\n+     * by this mapper instance for serialization and deserialization,\n+     * specifying them separately so that different introspection can be\n+     * used for different aspects\n+     * \n+     * @since 2.1\n+     * \n+     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n+     *    serialization\n+     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n+     *    deserialization\n+     */\n+    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n+            AnnotationIntrospector deserializerAI) {\n+        _serializationConfig = _serializationConfig.with(serializerAI);\n+        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n+        return this;\n+    }\n     \n     /**\n      * Method for setting custom property naming strategy to use.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         if (origType.isContainerType()) {\n             if (!staticTyping) {\n                 staticTyping = usesStaticTyping(config, beanDesc, null, property);\n+                \n+                // [JACKSON-822]: Need to figure out how to force passed parameterization\n+                //  to stick...\n+                /*\n+                if (property == null) {\n+                    JavaType t = origType.getContentType();\n+                    if (t != null && !t.hasRawClass(Object.class)) {\n+                        staticTyping = true;\n+                    }\n+                }\n+                */\n             }\n             return (JsonSerializer<Object>) buildContainerSerializer(prov,\n                     type, beanDesc, property, staticTyping);\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n package com.fasterxml.jackson.databind.util;\n \n import java.io.IOException;\n+import java.io.InputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n         writeObject(copy);\n     }\n \n+    /**\n+     * Although we could support this method, it does not necessarily make\n+     * sense: we can not make good use of streaming because buffer must\n+     * hold all the data. Because of this, currently this will simply\n+     * throw {@link UnsupportedOperationException}\n+     */\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonGenerator implementation; pass-through copy\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n         public void writeUTF8String(byte[] text, int offset, int length) { }\n \n         @Override\n-        public void writeStartArray() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeEndArray() throws IOException, JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeStartObject() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeEndObject() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n+        public void writeStartArray() { }\n+\n+        @Override\n+        public void writeEndArray() throws IOException, JsonGenerationException { }\n+\n+        @Override\n+        public void writeStartObject() { }\n+\n+        @Override\n+        public void writeEndObject() { }\n+\n+        @Override\n+        public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n+            return -1;\n         }\n     }\n     ", "timestamp": 1339222841, "metainfo": ""}