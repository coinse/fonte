{"sha": "60e30f499e9318b2b18c3cbac4edc2bfcf6d6d66", "log": "Implement [JACKSON-792]; can now handle Object Id forward references correctly", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n      * serialization, and if so, should be able to resolve it to actual\n      * Object instance to return as deserialized value.\n      *<p>\n-     * Default implementation returns false, as support can not be implemented\n+     * Default implementation returns null, as support can not be implemented\n      * generically. Some standard deserializers (most notably\n      * {@link com.fasterxml.jackson.databind.deser.BeanDeserializer})\n-     * do implement this feature, and may return true depending on exact\n+     * do implement this feature, and may return reader instance, depending on exact\n      * configuration of instance (which is based on type, and referring property).\n      * \n-     * @return True if this deserializer can be given an Object Identifier\n-     *    instead of full value serialization\n+     * @return ObjectIdReader used for resolving possible Object Identifier\n+     *    value, instead of full value serialization, if deserializer can do that;\n+     *    null if no Object Id is expected.\n      * \n      * @since 2.0\n      */\n-    public boolean canResolveObjectId() { return false; }\n+    public ObjectIdReader getObjectIdReader() { return null; }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             boolean hasViews)\n     {\n         super(builder, beanDesc, properties, backRefs,\n-        \t\tignorableProps, ignoreAllUnknown, hasViews);\n+                ignorableProps, ignoreAllUnknown, hasViews);\n     }\n \n     /**\n             t = jp.nextToken();\n             if (_vanillaProcessing) {\n                 return vanillaDeserialize(jp, ctxt, t);\n+            }\n+            if (_objectIdReader != null) {\n+                return deserializeWithObjectId(jp, ctxt);\n             }\n             return deserializeFromObject(jp, ctxt);\n         }\n             return deserializeFromArray(jp, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n+            if (_vanillaProcessing) {\n+                return vanillaDeserialize(jp, ctxt, t);\n+            }\n+            if (_objectIdReader != null) {\n+                return deserializeWithObjectId(jp, ctxt);\n+            }\n             return deserializeFromObject(jp, ctxt);\n \t}\n         throw ctxt.mappingException(getBeanClass());\n         return bean;\n     }\n \n+    /**\n+     * Alternative deserialization method used when we expect to see Object Id;\n+     * if so, we will need to ensure that the Id is seen before anything\n+     * else, to ensure that it is available for solving references,\n+     * even if JSON itself is not ordered that way. This may require\n+     * buffering in some cases, but usually just a simple lookup to ensure\n+     * that ordering is correct.\n+     */\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        final String idPropName = _objectIdReader.propertyName;\n+        // First, the simple case: we point to the Object Id property\n+        if (idPropName.equals(jp.getCurrentName())) {\n+            return deserializeFromObject(jp, ctxt);\n+        }\n+        // otherwise need to reorder things\n+        TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec());\n+        TokenBuffer mergedBuffer = null;\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // when we match the id property, can start merging\n+            if (mergedBuffer == null) {\n+                if (idPropName.equals(propName)) {\n+                    mergedBuffer = new TokenBuffer(jp.getCodec());\n+                    mergedBuffer.writeFieldName(propName);\n+                    jp.nextToken();\n+                    mergedBuffer.copyCurrentStructure(jp);\n+                    mergedBuffer.append(tmpBuffer);\n+                    tmpBuffer = null;\n+                } else {\n+                    tmpBuffer.writeFieldName(propName);\n+                    jp.nextToken();\n+                    tmpBuffer.copyCurrentStructure(jp);\n+                }\n+            } else {\n+                mergedBuffer.writeFieldName(propName);\n+                jp.nextToken();\n+                mergedBuffer.copyCurrentStructure(jp);\n+            }\n+        }\n+        // note: we really should get merged buffer (and if not, that is likely error), but\n+        // for now let's allow missing case as well. Will be caught be a later stage...\n+        TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer;\n+        buffer.writeEndObject();\n+        // important: need to advance to point to first FIELD_NAME:\n+        JsonParser mergedParser = buffer.asParser();\n+        mergedParser.nextToken();\n+        return deserializeFromObject(mergedParser, ctxt);\n+    }\n+\n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {        \n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeUsingObjectId(jp, ctxt);\n+            return deserializeFromObjectId(jp, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeUsingObjectId(jp, ctxt);\n+            return deserializeFromObjectId(jp, ctxt);\n         }\n \n         switch (jp.getNumberType()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ClassKey;\n-import com.fasterxml.jackson.databind.util.Annotations;\n-import com.fasterxml.jackson.databind.util.ArrayBuilders;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.NameTransformer;\n-import com.fasterxml.jackson.databind.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * Base class for <code>BeanDeserializer</code>.\n         _vanillaProcessing = !_nonStandardCreation\n                 && (_injectables == null)\n                 && !_needViewProcesing\n+                // also, may need to reorder stuff if we expect Object Id:\n+                && (_objectIdReader != null)\n                 ;\n     }\n \n         if (oir == null) {\n             _beanProperties = src._beanProperties;\n         } else {\n-            _beanProperties = src._beanProperties.withProperty(new ObjectIdProperty(oir));\n+            _beanProperties = src._beanProperties.withProperty(new ObjectIdValueProperty(oir));\n         }\n     }\n \n                     extTypes.addExternal(prop, typeDeser.getPropertyName());\n                     // In fact, remove from list of known properties to simplify later handling\n                     _beanProperties.remove(prop);\n+                    continue;\n                 }\n             }\n         }\n                 if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                     String propName = objectIdInfo.getPropertyName();\n                     idProp = findProperty(propName);\n-                \tif (idProp == null) {\n-                \t\tthrow new IllegalArgumentException(\"Invalid Object Id definition for \"\n-                \t\t\t\t+getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n-                \t}\n+                    if (idProp == null) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n+                                +getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n+                    }\n                     idType = idProp.getType();\n                     idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n                 } else { // other types need to be simpler\n      * (either via value type or referring property).\n      */\n     @Override\n-    public boolean canResolveObjectId() {\n-        return _objectIdReader != null;\n+    public ObjectIdReader getObjectIdReader() {\n+        return _objectIdReader;\n     }\n     \n     public boolean hasProperty(String propertyName) {\n             JsonToken t = jp.getCurrentToken();\n             // should be good enough check; we only care about Strings, integral numbers:\n             if (t != null && t.isScalarValue()) {\n-                return deserializeUsingObjectId(jp, ctxt);\n+                return deserializeFromObjectId(jp, ctxt);\n             }\n         }\n         // In future could check current token... for now this should be enough:\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected final Object deserializeUsingObjectId(JsonParser jp, DeserializationContext ctxt)\n+    protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n         Object id = _objectIdReader.deserializer.deserialize(jp, ctxt);\n         // do we have it resolved?\n         Object pojo = roid.item;\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"]\");\n+            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- illegal forward-reference?\");\n         }\n         return pojo;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n-import com.fasterxml.jackson.databind.deser.impl.ObjectIdProperty;\n+import com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n \n         // one more thing: may need to create virtual ObjectId property:\n         if (_objectIdReader != null) {\n-            ObjectIdProperty prop = new ObjectIdProperty(_objectIdReader);\n+            ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader);\n             propertyMap = propertyMap.withProperty(prop);\n         }\n         \n         }\n \n         if (_objectIdReader != null) {\n-            ObjectIdProperty prop = new ObjectIdProperty(_objectIdReader);\n+            ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader);\n             propertyMap = propertyMap.withProperty(prop);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n     \tsuper(builder, beanDesc, properties, backRefs,\n     \t\t\tignorableProps, ignoreAllUnknown, hasViews);\n     \t_buildMethod = builder.getBuildMethod();\n+    \t// 05-Mar-2012, tatu: Can not really make Object Ids work with builders, not yet anyway\n+    \tif (_objectIdReader != null) {\n+    \t    throw new IllegalArgumentException(\"Can not use Object Id with Builder-based deserialization (type \"\n+    \t            +beanDesc.getType()+\")\");\n+    \t}\n     }\n \n     /**\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeUsingObjectId(jp, ctxt);\n+            return deserializeFromObjectId(jp, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeUsingObjectId(jp, ctxt);\n+            return deserializeFromObjectId(jp, ctxt);\n         }\n \n         switch (jp.getNumberType()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n      * Pre-condition is that passed parser must point to the first token\n      * that should be consumed to produce the value (the only value for\n      * scalars, multiple for Objects and Arrays).\n+     *<p> \n+     * Note that this method is final for performance reasons: to override\n+     * functionality you must override other methods that call this method;\n+     * this method should also not be called directly unless you really know\n+     * what you are doing (and probably not even then).\n      */\n     public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n \n     @Override public AnnotatedMember getMember() {  return _delegate.getMember(); }\n \n-    // // //  Overridden methods\n+    /*\n+    /**********************************************************\n+    /* Deserialization methods\n+    /**********************************************************\n+     */\n \n     @Override\n     public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n \n     @Override\n     public Object setAndReturn(Object instance, Object value)\n-   \t\tthrows IOException\n-\t{\n+            throws IOException\n+    {\n     \treturn _delegate.setAndReturn(instance, value);\n-\t}\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+\n+/**\n+ * Specialized {@link SettableBeanProperty} implementation used\n+ * for virtual property that represents Object Id that is used\n+ * for some POJO types (or properties).\n+ */\n+public final class ObjectIdValueProperty\n+\textends SettableBeanProperty\n+{\n+    protected final ObjectIdReader _objectIdReader;\n+    \n+    public ObjectIdValueProperty(ObjectIdReader objectIdReader)\n+    {\n+        super(objectIdReader.propertyName, objectIdReader.idType, null, null);\n+        _objectIdReader = objectIdReader;\n+        _valueDeserializer = objectIdReader.deserializer;\n+    }\n+\n+    protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser)\n+    {\n+        super(src, deser);\n+        _objectIdReader = src._objectIdReader;\n+    }\n+\n+    protected ObjectIdValueProperty(ObjectIdValueProperty src, String newName) {\n+        super(src, newName);\n+        _objectIdReader = src._objectIdReader;\n+    }\n+\n+    @Override\n+    public ObjectIdValueProperty withName(String newName) {\n+        return new ObjectIdValueProperty(this, newName);\n+    }\n+\n+    @Override\n+    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {\n+        return new ObjectIdValueProperty(this, deser);\n+    }\n+    \n+    // // // BeanProperty impl\n+    \n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return null;\n+    }\n+\n+    @Override public AnnotatedMember getMember() {  return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+        Object instance)\n+            throws IOException, JsonProcessingException\n+    {\n+    \tdeserializeSetAndReturn(jp, ctxt, instance);\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        // note: no null checks (unlike usually); deserializer should fail if one found\n+        Object id = _valueDeserializer.deserialize(jp, ctxt);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        roid.bindItem(instance);\n+        // also: may need to set a property value as well\n+        SettableBeanProperty idProp = _objectIdReader.idProperty;\n+        if (idProp != null) {\n+            return idProp.setAndReturn(instance, id);\n+        }\n+        return instance;\n+    }\n+    \n+    \n+    @Override\n+    public void set(Object instance, Object value) throws IOException {\n+    \tsetAndReturn(instance, value);\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+   \t\tthrows IOException\n+    {\n+        SettableBeanProperty idProp = _objectIdReader.idProperty;\n+        if (idProp == null) {\n+        \tthrow new UnsupportedOperationException(\n+        \t        \"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n+        }\n+        return idProp.setAndReturn(instance, value);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n     /**********************************************************\n      */\n \n+    /**\n+     * Helper method that will append contents of given buffer into this\n+     * buffer.\n+     * Not particularly optimized; can be made faster if there is need.\n+     * \n+     * @return This buffer\n+     */\n+    public TokenBuffer append(TokenBuffer other)\n+        throws IOException, JsonGenerationException\n+    {\n+        JsonParser jp = other.asParser();\n+        while (jp.nextToken() != null) {\n+            this.copyCurrentEvent(jp);\n+        }\n+        return this;\n+    }\n+    \n     /**\n      * Helper method that will write all contents of this buffer\n      * using given {@link JsonGenerator}.\n             _appendOffset = 1;\n         }\n     }\n+\n+    protected final void _appendRaw(int rawType, Object value) {\n+        Segment next = _last.appendRaw(_appendOffset, rawType, value);\n+        if (next == null) {\n+            ++_appendOffset;\n+        } else {\n+            _last = next;\n+            _appendOffset = 1;\n+        }\n+    }\n     \n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n             int ix = ((int) l) & 0xF;\n             return TOKEN_TYPES_BY_INDEX[ix];\n         }\n+\n+        public int rawType(int index)\n+        {\n+            long l = _tokenTypes;\n+            if (index > 0) {\n+                l >>= (index << 2);\n+            }\n+            int ix = ((int) l) & 0xF;\n+            return ix;\n+        }\n         \n         public Object get(int index) {\n             return _tokens[index];\n             _next.set(0, tokenType, value);\n             return _next;\n         }\n+\n+        public Segment appendRaw(int index, int rawTokenType, Object value)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, rawTokenType, value);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, rawTokenType, value);\n+            return _next;\n+        }\n         \n         public void set(int index, JsonToken tokenType)\n         {\n+            /* Assumption here is that there are no overwrites, just appends;\n+             * and so no masking is needed (nor explicit setting of null)\n+             */\n             long typeCode = tokenType.ordinal();\n-            /* Assumption here is that there are no overwrites, just appends;\n-             * and so no masking is needed\n-             */\n             if (index > 0) {\n                 typeCode <<= (index << 2);\n             }\n             }\n             _tokenTypes |= typeCode;\n         }\n+\n+        private void set(int index, int rawTokenType, Object value)\n+        {\n+            _tokens[index] = value;\n+            long typeCode = (long) rawTokenType;\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+        }\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n         verifyJsonSpecSampleDoc(tb.asParser(), true);\n     }\n \n+    public void testAppend() throws IOException\n+    {\n+        TokenBuffer buf1 = new TokenBuffer(null);\n+        buf1.writeStartObject();\n+        buf1.writeFieldName(\"a\");\n+        buf1.writeBoolean(true);\n+        \n+        TokenBuffer buf2 = new TokenBuffer(null);\n+        buf2.writeFieldName(\"b\");\n+        buf2.writeNumber(13);\n+        buf2.writeEndObject();\n+        \n+        buf1.append(buf2);\n+        \n+        // and verify that we got it all...\n+        JsonParser jp = buf1.asParser();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"b\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(13, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Tests to verify interaction of TokenBuffer and JsonParserSequence", "timestamp": 1331015660, "metainfo": ""}