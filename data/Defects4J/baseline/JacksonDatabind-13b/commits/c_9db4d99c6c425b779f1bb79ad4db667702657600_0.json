{"sha": "9db4d99c6c425b779f1bb79ad4db667702657600", "log": "Yet more refactoring: making more use of BeanPropertyDefinition", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n \n /**\n  * Concrete deserializer factory class that adds full Bean deserializer\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, \"cause\", am,\n+            SimpleBeanPropertyDefinition propDef = new SimpleBeanPropertyDefinition(am, \"cause\");\n+            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                     am.getGenericParameterType(0));\n             if (prop != null) {\n                 /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n             if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n                 continue;\n             }\n-            /* [JACKSON-700] If property as passed via constructor parameter, we must\n-             *   handle things in special way. Not sure what is the most optimal way...\n-             *   for now, let's just call a (new) method in builder, which does nothing.\n-             */\n             if (property.hasConstructorParameter()) {\n+                /* [JACKSON-700] If property as passed via constructor parameter, we must\n+                 *   handle things in special way. Not sure what is the most optimal way...\n+                 *   for now, let's just call a (new) method in builder, which does nothing.\n+                 */\n                 // but let's call a method just to allow custom builders to be aware...\n                 builder.addCreatorProperty(property);\n                 continue;\n             }\n-            AnnotatedMember accessor;\n             Class<?> rawPropertyType;\n             Type propertyType;\n-            if (property.hasSetter()) {\n-                AnnotatedMethod setter = property.getSetter();\n+            AnnotatedMethod setter = property.getSetter();\n+            if (setter != null) {\n                 rawPropertyType = setter.getRawParameterType(0);\n                 propertyType = setter.getGenericParameterType(0);\n-                accessor = setter;\n-            } else if (property.hasField()) {\n-                accessor = property.getField();\n-                rawPropertyType = accessor.getRawType();\n-                propertyType = accessor.getGenericType();\n             } else {\n-                continue;\n+                AnnotatedField field = property.getField();\n+                if (field != null) {\n+                    rawPropertyType = field.getRawType();\n+                    propertyType = field.getGenericType();\n+                } else {\n+                    continue;\n+                }\n             }\n             \n             // [JACKSON-429] Some types are declared as ignorable as well\n                 builder.addIgnorable(name);\n             } else {\n                 SettableBeanProperty prop = constructSettableProperty(ctxt,\n-                        beanDesc, name, accessor, propertyType);\n+                        beanDesc, property, propertyType);\n                 if (prop != null) {\n                     builder.addProperty(prop);\n                 }\n                 } else {\n                     genericType = m.getRawType();\n                 }\n+                SimpleBeanPropertyDefinition propDef = new SimpleBeanPropertyDefinition(m);\n                 builder.addBackReferenceProperty(name, constructSettableProperty(\n-                        ctxt, beanDesc, m.getName(), m, genericType));\n+                        ctxt, beanDesc, propDef, genericType));\n             }\n         }\n     }\n      *   there should be no property based on given definitions.\n      */\n     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n-            BeanDescription beanDesc, String name,\n-            AnnotatedMember setter, Type jdkType)\n+            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n+            /*\n+            String name,\n+            AnnotatedMember setter,\n+            */\n+            Type jdkType)\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n+        AnnotatedMember mutator = propDef.getMutator();\n         if (ctxt.canOverrideAccessModifiers()) {\n-            setter.fixAccess();\n-        }\n+            mutator.fixAccess();\n+        }\n+        final String name = propDef.getName();\n \n         // note: this works since we know there's exactly one argument for methods\n         JavaType t0 = beanDesc.resolveType(jdkType);\n \n-        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), setter);\n-        JavaType type = resolveType(ctxt, beanDesc, t0, setter, property);\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), mutator);\n+        JavaType type = resolveType(ctxt, beanDesc, t0, mutator, property);\n         // did type change?\n         if (type != t0) {\n             property = property.withType(type);\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n          */\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, setter, property);\n-        type = modifyTypeByAnnotation(ctxt, setter, type, property);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator, property);\n+        type = modifyTypeByAnnotation(ctxt, mutator, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop;\n-        if (setter instanceof AnnotatedMethod) {\n+        if (mutator instanceof AnnotatedMethod) {\n             prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n-                beanDesc.getClassAnnotations(), (AnnotatedMethod) setter);\n+                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n         } else {\n             prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n-                    beanDesc.getClassAnnotations(), (AnnotatedField) setter);\n+                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n         }\n         if (propDeser != null) {\n             prop = prop.withValueDeserializer(propDeser);\n         }\n         // [JACKSON-235]: need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(setter);\n+        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(mutator);\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import com.fasterxml.jackson.databind.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+\n+/**\n+ * Simple immutable {@link BeanPropertyDefinition} implementation that can\n+ * be wrapped around a {@link AnnotatedMember} that is a simple\n+ * accessor (getter) or mutator (setter, constructor parameter)\n+ * (or both, for fields).\n+ */\n+public class SimpleBeanPropertyDefinition\n+    extends BeanPropertyDefinition\n+{\n+    /**\n+     * Member that defines logical property. Assumption is that it\n+     * should be a 'simple' accessor; meaning a zero-argument getter,\n+     * single-argument setter or constructor parameter.\n+     */\n+    protected final AnnotatedMember _member;\n+\n+    protected final String _name;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    public SimpleBeanPropertyDefinition(AnnotatedMember member) {\n+        this(member, member.getName());\n+    }\n+\n+    public SimpleBeanPropertyDefinition(AnnotatedMember member, String name) {\n+        _member = member;\n+        _name = name;\n+    }\n+\n+    /*\n+    /*****************************************************\n+    /* Basic property information, name, type\n+    /*****************************************************\n+     */\n+\n+    @Override\n+    public String getName() { return _name; }\n+\n+    @Override\n+    public String getInternalName() { return getName(); }\n+    \n+    /*\n+    /*****************************************************\n+    /* Access to accessors (fields, methods etc)\n+    /*****************************************************\n+     */\n+\n+    @Override\n+    public boolean hasGetter() {\n+        return (getGetter() != null);\n+    }\n+\n+    @Override\n+    public boolean hasSetter() {\n+        return (getSetter() != null);\n+    }\n+\n+    @Override\n+    public boolean hasField() {\n+        return (_member instanceof AnnotatedField);\n+    }\n+\n+    @Override\n+    public boolean hasConstructorParameter() {\n+        return (_member instanceof AnnotatedParameter);\n+    }\n+    \n+    public AnnotatedMethod getGetter() {\n+        if ((_member instanceof AnnotatedMethod)\n+                && ((AnnotatedMethod) _member).getParameterCount() == 0) {\n+            return (AnnotatedMethod) _member;\n+        }\n+        return null;\n+    }\n+        \n+    public AnnotatedMethod getSetter() {\n+        if ((_member instanceof AnnotatedMethod)\n+                && ((AnnotatedMethod) _member).getParameterCount() == 1) {\n+            return (AnnotatedMethod) _member;\n+        }\n+        return null;\n+    }\n+        \n+    public AnnotatedField getField() {\n+        return (_member instanceof AnnotatedField) ?\n+                (AnnotatedField) _member : null;\n+    }\n+\n+    public AnnotatedParameter getConstructorParameter() {\n+        return (_member instanceof AnnotatedParameter) ?\n+                (AnnotatedParameter) _member : null;\n+    }\n+\n+    /**\n+     * Method used to find accessor (getter, field to access) to use for accessing\n+     * value of the property.\n+     * Null if no such member exists.\n+     */\n+    public AnnotatedMember getAccessor() {\n+        AnnotatedMember acc = getGetter();\n+        if (acc == null) {\n+            acc = getField();\n+        }\n+        return acc;\n+    }\n+\n+    /**\n+     * Method used to find mutator (constructor parameter, setter, field) to use for\n+     * changing value of the property.\n+     * Null if no such member exists.\n+     */\n+    public AnnotatedMember getMutator() {\n+        AnnotatedMember acc = getConstructorParameter();\n+        if (acc == null) {\n+            acc = getSetter();\n+            if (acc == null) {\n+                acc = getField();\n+            }\n+        }\n+        return acc;\n+    }\n+\n+    /*\n+    /*****************************************************\n+    /* More refined access to features\n+    /*****************************************************\n+     */\n+\n+    /* Hmmh. Should we actually consider defining this in future?\n+     * Should either pass views via construction, or pass\n+     * <code>AnnotationIntrospector</code>, call dynamically.\n+     */\n+    public Class<?>[] getViews() {\n+        return null;\n+    }\n+}", "timestamp": 1327612075, "metainfo": ""}