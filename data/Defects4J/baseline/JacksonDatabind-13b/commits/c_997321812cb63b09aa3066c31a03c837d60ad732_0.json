{"sha": "997321812cb63b09aa3066c31a03c837d60ad732", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonNaming\n {\n-    public Class<? extends PropertyNamingStrategy> value();\n+    /**\n+     * @return Type of {@link PropertyNamingStrategy} to use, if any; default value of\n+     *    <code>PropertyNamingStrategy.class</code> means \"no strategy specified\"\n+     *    (and may also be used for overriding to remove otherwise applicable\n+     *    naming strategy)\n+     */\n+    public Class<? extends PropertyNamingStrategy> value() default PropertyNamingStrategy.class;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n         /* Also: must be a recognized factory method, meaning:\n          * (a) marked with @JsonCreator annotation, or\n-         * (a) \"valueOf\" (at this point, need not be public)\n+         * (b) \"valueOf\" (at this point, need not be public)\n          */\n         if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n             return true;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n         //todo: (ryan) add a format for the date in the schema?\n         return createSchemaNode(_asTimestamp(provider) ? \"number\" : \"string\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /**\n      * We will use a separate main-level Map for keeping track\n-     * of root-level deserializers. This is where most succesful\n+     * of root-level deserializers. This is where most successful\n      * cache lookups get resolved.\n      * Map will contain resolvers for all kinds of types, including\n      * container types: this is different from the component cache\n      * Java Beans (based on method names and Jackson-specific annotations),\n      * but does not support JAXB annotations.\n      */\n-    public ObjectMapper()\n-    {\n+    public ObjectMapper() {\n         this(null, null, null);\n     }\n \n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s.\n      */\n-    public ObjectMapper(JsonFactory jf)\n-    {\n+    public ObjectMapper(JsonFactory jf) {\n         this(jf, null, null);\n     }\n \n      * @param n Root node of the tree that resulting parser will read from\n      */\n     @Override\n-    public JsonParser treeAsTokens(TreeNode n)\n-    {\n+    public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n ", "timestamp": 1412353111, "metainfo": ""}