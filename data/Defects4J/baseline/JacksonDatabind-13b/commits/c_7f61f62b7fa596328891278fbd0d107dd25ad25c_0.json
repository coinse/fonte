{"sha": "7f61f62b7fa596328891278fbd0d107dd25ad25c", "log": "Merge pull request #388 from pgelinas/forward-reference  Forward reference handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     public abstract ReadableObjectId findObjectId(Object id,\n             ObjectIdGenerator<?> generator);\n \n+    /**\n+     * Method called to ensure that every object id encounter during processing\n+     * are resolved.\n+     * \n+     * @throws UnresolvedForwardReference\n+     */\n+    public abstract void checkUnresolvedObjectId()\n+        throws UnresolvedForwardReference;\n+\n     /*\n     /**********************************************************\n     /* Public API, type handling\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n                 } else {\n                     result = deser.deserialize(jp, ctxt);\n                 }\n+                ctxt.checkUnresolvedObjectId();\n             }\n             // Need to consume the token too\n             jp.clearCurrentToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n             }\n             // [JACKSON-235]: need to link managed references with matching back references\n             prop = _resolveManagedReferenceProperty(ctxt, prop);\n+\n+            // issue #351: need to wrap properties that require object id resolution.\n+            if (!(prop instanceof ManagedReferenceProperty)) {\n+                prop = _resolvedObjectIdProperty(ctxt, prop);\n+            }\n             // [JACKSON-132]: support unwrapped values (via @JsonUnwrapped)\n             SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n             if (u != null) {\n     }\n \n     /**\n+     * Method that wraps given property with {@link ObjectIdReferenceProperty}\n+     * in case where object id resolution is required.\n+     */\n+    protected SettableBeanProperty _resolvedObjectIdProperty(DeserializationContext ctxt, SettableBeanProperty prop)\n+    {\n+        ObjectIdInfo objectIdInfo = prop.getObjectIdInfo();\n+        JsonDeserializer<Object> valueDeser = prop.getValueDeserializer();\n+        ObjectIdReader objectIdReader = valueDeser.getObjectIdReader();\n+        if (objectIdInfo == null && objectIdReader == null) {\n+            return prop;\n+        }\n+\n+        return new ObjectIdReferenceProperty(prop, objectIdInfo);\n+    }\n+\n+    /**\n      * Helper method called to see if given property might be so-called unwrapped\n      * property: these require special handling.\n      */\n         // do we have it resolved?\n         Object pojo = roid.item;\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] (for \"\n-                    +_beanType+\") -- unresolved forward-reference?\");\n+            throw new UnresolvedForwardReference(\"Could not resolve Object Id [\"+id+\"] (for \"\n+                    +_beanType+\").\", jp.getCurrentLocation(), roid);\n         }\n         return pojo;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n+        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n+        if(objectIdInfo != null){\n+            prop.setObjectIdInfo(objectIdInfo);\n+        }\n         return prop;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n+import java.util.Map.Entry;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n         return entry;\n     }\n     \n+    @Override\n+    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n+    {\n+        if(_objectIds == null){\n+            return;\n+        }\n+\n+        UnresolvedForwardReference exception = null;\n+        for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n+            ReadableObjectId roid = entry.getValue();\n+            if(roid.hasReferringProperties()){\n+                if(exception == null){\n+                    exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n+                }\n+                for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext();) {\n+                    Referring referring = iterator.next();\n+                    exception.addUnresolvedId(roid.id, referring.getBeanType(), referring.getLocation());\n+                }\n+            }\n+        }\n+        if(exception != null){\n+            throw exception;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Abstract methods impls, other factory methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n                                         Object instance, String propName)\n         throws IOException, JsonProcessingException\n     {\n-        set(instance, propName, deserialize(jp, ctxt));\n+        try {\n+            set(instance, propName, deserialize(jp, ctxt));\n+        } catch (UnresolvedForwardReference reference) {\n+            if (!(_valueDeserializer.getObjectIdReader() != null)) {\n+                throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+            }\n+            AnySetterReferring referring = new AnySetterReferring(instance, propName, reference.getUnresolvedId(),\n+                    reference.getLocation());\n+            reference.getRoid().appendReferring(referring);\n+        }\n     }\n \n     public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n \n     @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n \n+    private class AnySetterReferring extends Referring {\n+        private Object _pojo;\n+        private String _propName;\n+        private Object _unresolvedId;\n+\n+        public AnySetterReferring(Object instance, String propName, Object id, JsonLocation location)\n+        {\n+            super(location, _type.getRawClass());\n+            _pojo = instance;\n+            _propName = propName;\n+            _unresolvedId = id;\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            if (!id.equals(_unresolvedId)) {\n+                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id.toString()\n+                        + \"] that wasn't previously registered.\");\n+            }\n+            set(_pojo, _propName, value);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* JDK serialization handling\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n import com.fasterxml.jackson.databind.deser.impl.NullProvider;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.Annotations;\n     protected String _managedReferenceName;\n \n     /**\n+     * This is the information for object identity associated with the property.\n+     * <p>\n+     * TODO: should try to make immutable.\n+     */\n+    protected ObjectIdInfo _objectIdInfo;\n+\n+    /**\n      * Helper object used for checking whether this property is to\n      * be included in the active view, if property is view-specific;\n      * null otherwise.\n      * TODO: should try to make immutable if at all possible\n      */\n     protected int _propertyIndex = -1;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle (construct & configure)\n     public void setManagedReferenceName(String n) {\n         _managedReferenceName = n;\n     }\n-    \n+\n+    public void setObjectIdInfo(ObjectIdInfo objectIdInfo) {\n+        _objectIdInfo = objectIdInfo;\n+    }\n+\n     public void setViews(Class<?>[] views) {\n         if (views == null) {\n             _viewMatcher = null;\n     }\n \n     public String getManagedReferenceName() { return _managedReferenceName; }\n+\n+    public ObjectIdInfo getObjectIdInfo() { return _objectIdInfo; }\n \n     public boolean hasValueDeserializer() {\n         return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n+\n+/**\n+ * Exception thrown during deserialization when there are object id that can't\n+ * be resolved.\n+ * \n+ * @author pgelinas\n+ */\n+public final class UnresolvedForwardReference extends JsonMappingException {\n+\n+    private static final long serialVersionUID = -5097969645059502061L;\n+    private ReadableObjectId _roid;\n+    private List<UnresolvedId> _unresolvedIds;\n+\n+    public UnresolvedForwardReference(String msg, JsonLocation loc, ReadableObjectId roid)\n+    {\n+        super(msg, loc);\n+        _roid = roid;\n+    }\n+\n+    public UnresolvedForwardReference(String msg)\n+    {\n+        super(msg);\n+        _unresolvedIds = new ArrayList<UnresolvedId>();\n+    }\n+\n+    // ******************************\n+    // ****** Accessor methods ******\n+    // ******************************\n+\n+    public ReadableObjectId getRoid()\n+    {\n+        return _roid;\n+    }\n+\n+    public Object getUnresolvedId()\n+    {\n+        return _roid.id;\n+    }\n+\n+    /**\n+     * Helper class\n+     * \n+     * @author pgelinas\n+     */\n+    public static class UnresolvedId {\n+        private Object _id;\n+        private JsonLocation _location;\n+        private Class<?> _type;\n+\n+        public UnresolvedId(Object id, Class<?> type, JsonLocation where)\n+        {\n+            _id = id;\n+            _type = type;\n+            _location = where;\n+        }\n+        \n+        /**\n+         * The id which is unresolved.\n+         */\n+        public Object getId() { return _id; }\n+        /**\n+         * The type of object which was expected.\n+         */\n+        public Class<?> getType() { return _type; }\n+        public JsonLocation getLocation() { return _location; }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return String.format(\"Object id [%s] (for %s) at %s\", _id, _type, _location);\n+        }\n+    }\n+\n+    public void addUnresolvedId(Object id, Class<?> type, JsonLocation where)\n+    {\n+        _unresolvedIds.add(new UnresolvedId(id, type, where));\n+    }\n+\n+    public List<UnresolvedId> getUnresolvedIds(){\n+        return _unresolvedIds;\n+    }\n+    \n+    @Override\n+    public String getMessage()\n+    {\n+        String msg = super.getMessage();\n+        if (_unresolvedIds == null) {\n+            return msg;\n+        }\n+\n+        StringBuilder sb = new StringBuilder(msg);\n+        Iterator<UnresolvedId> iterator = _unresolvedIds.iterator();\n+        while (iterator.hasNext()) {\n+            UnresolvedId unresolvedId = iterator.next();\n+            sb.append(unresolvedId.toString());\n+            if (iterator.hasNext()) {\n+                sb.append(\", \");\n+            }\n+        }\n+        sb.append('.');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n+\n+public class ObjectIdReferenceProperty extends SettableBeanProperty {\n+    private static final long serialVersionUID = 8465266677345565407L;\n+    private SettableBeanProperty _forward;\n+\n+    public ObjectIdReferenceProperty(SettableBeanProperty forward, ObjectIdInfo objectIdInfo)\n+    {\n+        super(forward);\n+        _forward = forward;\n+        _objectIdInfo = objectIdInfo;\n+    }\n+\n+    public ObjectIdReferenceProperty(ObjectIdReferenceProperty src, JsonDeserializer<?> deser)\n+    {\n+        super(src, deser);\n+        _forward = src._forward;\n+        _objectIdInfo = src._objectIdInfo;\n+    }\n+\n+    public ObjectIdReferenceProperty(ObjectIdReferenceProperty src, PropertyName newName)\n+    {\n+        super(src, newName);\n+        _forward = src._forward;\n+        _objectIdInfo = src._objectIdInfo;\n+    }\n+\n+    @Override\n+    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser)\n+    {\n+        return new ObjectIdReferenceProperty(this, deser);\n+    }\n+\n+    @Override\n+    public SettableBeanProperty withName(PropertyName newName)\n+    {\n+        return new ObjectIdReferenceProperty(this, newName);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls)\n+    {\n+        return _forward.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public AnnotatedMember getMember()\n+    {\n+        return _forward.getMember();\n+    }\n+\n+    @Override\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        deserializeSetAndReturn(jp, ctxt, instance);\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        boolean usingIdentityInfo = _objectIdInfo != null || _valueDeserializer.getObjectIdReader() != null;\n+        try {\n+            return setAndReturn(instance, deserialize(jp, ctxt));\n+        } catch (UnresolvedForwardReference reference) {\n+            if (!usingIdentityInfo) {\n+                throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+            }\n+            reference.getRoid().appendReferring(\n+                    new PropertyReferring(instance, reference.getUnresolvedId(), reference.getLocation()));\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void set(Object instance, Object value)\n+        throws IOException\n+    {\n+        _forward.set(instance, value);\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+        throws IOException\n+    {\n+        return _forward.setAndReturn(instance, value);\n+    }\n+\n+    public final class PropertyReferring extends Referring {\n+        public final Object _pojo;\n+        private Object _unresolvedId;\n+\n+        public PropertyReferring(Object ob, Object id, JsonLocation location)\n+        {\n+            super(location, _type.getRawClass());\n+            _pojo = ob;\n+            _unresolvedId = id;\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            if (!id.equals(_unresolvedId)) {\n+                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                        + \"] that wasn't previously seen as unresolved.\");\n+            }\n+            set(_pojo, value);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n \n /**\n- * Simple value container for containing information about single\n- * Object Id during deserialization.\n+ * Simple value container for containing information about single Object Id\n+ * during deserialization\n  */\n public class ReadableObjectId\n {\n     public final Object id;\n-    \n+\n     public Object item;\n-    \n+\n+    private LinkedList<Referring> _referringProperties;\n+\n     public ReadableObjectId(Object id)\n     {\n         this.id = id;\n     }\n \n+    public void appendReferring(Referring currentReferring)\n+    {\n+        if (_referringProperties == null) {\n+            _referringProperties = new LinkedList<Referring>();\n+        }\n+        _referringProperties.add(currentReferring);\n+    }\n+\n     /**\n-     * Method called to assign actual POJO to which ObjectId refers to:\n-     * will also handle referring properties, if any, by assigning POJO.\n+     * Method called to assign actual POJO to which ObjectId refers to: will\n+     * also handle referring properties, if any, by assigning POJO.\n      */\n-    public void bindItem(Object ob) throws IOException\n+    public void bindItem(Object ob)\n+        throws IOException\n     {\n         if (item != null) {\n-            throw new IllegalStateException(\"Already had POJO for id (\"+id.getClass().getName()+\") [\"+id+\"]\");\n+            throw new IllegalStateException(\"Already had POJO for id (\" + id.getClass().getName() + \") [\" + id + \"]\");\n         }\n         item = ob;\n+        if (_referringProperties != null) {\n+            Iterator<Referring> it = _referringProperties.iterator();\n+            _referringProperties = null;\n+            while (it.hasNext()) {\n+                Referring ref = it.next();\n+                ref.handleResolvedForwardReference(id, ob);\n+            }\n+        }\n+    }\n+\n+    public boolean hasReferringProperties()\n+    {\n+        return (_referringProperties != null) && !_referringProperties.isEmpty();\n+    }\n+\n+    public Iterator<Referring> referringProperties()\n+    {\n+        if (_referringProperties == null) {\n+            return Collections.<Referring> emptyList().iterator();\n+        }\n+        return _referringProperties.iterator();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    public static abstract class Referring {\n+        private final JsonLocation _location;\n+        private final Class<?> _beanType;\n+\n+        public Referring(JsonLocation location, Class<?> beanType)\n+        {\n+            _location = location;\n+            _beanType = beanType;\n+        }\n+\n+        public JsonLocation getLocation() { return _location; }\n+        public Class<?> getBeanType() { return _beanType; }\n+\n+        public abstract void handleResolvedForwardReference(Object id, Object value)\n+            throws IOException;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         JsonToken t;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-\n+        CollectionReferringAccumulator referringAccumulator = null;\n+        if(valueDes.getObjectIdReader() != null){\n+            referringAccumulator = new CollectionReferringAccumulator(result);\n+        }\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            result.add(value);\n+            try {\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                if (referringAccumulator != null) {\n+                    referringAccumulator.add(value);\n+                } else {\n+                    result.add(value);\n+                }\n+            } catch (UnresolvedForwardReference reference) {\n+                if (referringAccumulator == null) {\n+                    throw JsonMappingException\n+                            .from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+                }\n+                Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n+                reference.getRoid().appendReferring(ref);\n+            }\n         }\n         return result;\n     }\n         return result;\n     }\n \n+    public final class CollectionReferringAccumulator {\n+        private Collection<Object> _result;\n+        /**\n+         * A list of {@link UnresolvedId} to maintain ordering.\n+         */\n+        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+\n+        public CollectionReferringAccumulator(Collection<Object> result)\n+        {\n+            _result = result;\n+        }\n+\n+        public void add(Object value)\n+        {\n+            if (_accumulator.isEmpty()) {\n+                _result.add(value);\n+            } else {\n+                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                unresolvedId._next.add(value);\n+            }\n+        }\n+\n+        public Referring handleUnresolvedReference(UnresolvedForwardReference reference)\n+        {\n+            UnresolvedId id = new UnresolvedId(reference.getUnresolvedId(), reference.getLocation());\n+            _accumulator.add(id);\n+            return id;\n+        }\n+\n+        public void resolveForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            // Resolve ordering after resolution of an id. This mean either:\n+            // 1- adding to the result collection in case of the first unresolved id.\n+            // 2- merge the content of the resolved id with its previous unresolved id.\n+            Collection<Object> previous = _result;\n+            while (iterator.hasNext()) {\n+                UnresolvedId unresolvedId = iterator.next();\n+                if (unresolvedId._id.equals(id)) {\n+                    iterator.remove();\n+                    previous.add(value);\n+                    previous.addAll(unresolvedId._next);\n+                    return;\n+                }\n+                previous = unresolvedId._next;\n+            }\n+\n+            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                    + \"] that wasn't previously seen as unresolved.\");\n+        }\n+\n+        /**\n+         * Helper class to maintain processing order of value. The resolved\n+         * object associated with {@link #_id} comes before the values in\n+         * {@link _next}.\n+         */\n+        private final class UnresolvedId extends Referring {\n+            private final Object _id;\n+            private final List<Object> _next = new ArrayList<Object>();\n+\n+            private UnresolvedId(Object id, JsonLocation location)\n+            {\n+                super(location, _collectionType.getContentType().getRawClass());\n+                _id = id;\n+            }\n+\n+            @Override\n+            public void handleResolvedForwardReference(Object id, Object value)\n+                throws IOException\n+            {\n+                resolveForwardReference(id, value);\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\n import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n-import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n         final KeyDeserializer keyDes = _keyDeserializer;\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        MapReferringAccumuator referringAccumulator = null;\n+        boolean useObjectId = valueDes.getObjectIdReader() != null;\n+        if (useObjectId) {\n+            referringAccumulator = new MapReferringAccumuator(result);\n+        }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n             String fieldName = jp.getCurrentName();\n                 jp.skipChildren();\n                 continue;\n             }\n-            // Note: must handle null explicitly here; value deserializers won't\n-            Object value;            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            /* !!! 23-Dec-2008, tatu: should there be an option to verify\n-             *   that there are no duplicate field names? (and/or what\n-             *   to do, keep-first or keep-last)\n-             */\n-            result.put(key, value);\n+            try{\n+                // Note: must handle null explicitly here; value deserializers won't\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n+                 *   that there are no duplicate field names? (and/or what\n+                 *   to do, keep-first or keep-last)\n+                 */\n+                if (useObjectId) {\n+                    referringAccumulator.put(key, value);\n+                } else {\n+                    result.put(key, value);\n+                }\n+            } catch(UnresolvedForwardReference reference) {\n+                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n+            }\n         }\n     }\n \n         }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        MapReferringAccumuator referringAccumulator = null;\n+        boolean useObjectId = valueDes.getObjectIdReader() != null;\n+        if (useObjectId) {\n+            referringAccumulator = new MapReferringAccumuator(result);\n+        }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n             String fieldName = jp.getCurrentName();\n                 jp.skipChildren();\n                 continue;\n             }\n-            // Note: must handle null explicitly here; value deserializers won't\n-            Object value;            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            result.put(fieldName, value);\n+            try {\n+                // Note: must handle null explicitly here; value deserializers won't\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                if (useObjectId) {\n+                    referringAccumulator.put(fieldName, value);\n+                } else {\n+                    result.put(fieldName, value);\n+                }\n+            } catch (UnresolvedForwardReference reference) {\n+                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n+            }\n         }\n     }\n     \n         }\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n+\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumuator accumulator, Object key,\n+            UnresolvedForwardReference reference)\n+        throws JsonMappingException\n+    {\n+        if (accumulator == null) {\n+            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+        }\n+        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n+        reference.getRoid().appendReferring(referring);\n+    }\n+\n+    private final class MapReferringAccumuator  {\n+        private Map<Object,Object> _result;\n+        /**\n+         * A list of {@link UnresolvedId} to maintain ordering.\n+         */\n+        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+\n+        public MapReferringAccumuator(Map<Object, Object> result)\n+        {\n+            _result = result;\n+        }\n+\n+        public void put(Object key, Object value)\n+        {\n+            if (_accumulator.isEmpty()) {\n+                _result.put(key, value);\n+            } else {\n+                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                unresolvedId._next.put(key, value);\n+            }\n+        }\n+\n+        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n+        {\n+            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation());\n+            _accumulator.add(id);\n+            return id;\n+        }\n+\n+        public void resolveForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            // Resolve ordering after resolution of an id. This mean either:\n+            // 1- adding to the result map in case of the first unresolved id.\n+            // 2- merge the content of the resolved id with its previous unresolved id.\n+            Map<Object,Object> previous = _result;\n+            while (iterator.hasNext()) {\n+                UnresolvedId unresolvedId = iterator.next();\n+                if (unresolvedId._id.equals(id)) {\n+                    iterator.remove();\n+                    previous.put(unresolvedId._key, value);\n+                    previous.putAll(unresolvedId._next);\n+                    return;\n+                }\n+                previous = unresolvedId._next;\n+            }\n+\n+            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                    + \"] that wasn't previously seen as unresolved.\");\n+        }\n+\n+        /**\n+         * Helper class to maintain processing order of value. The resolved\n+         * object associated with {@link #_id} comes before the values in\n+         * {@link _next}.\n+         */\n+        private final class UnresolvedId extends Referring {\n+            private final Object _id;\n+            private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n+            private final Object _key;\n+\n+            private UnresolvedId(Object key, Object id, JsonLocation location)\n+            {\n+                super(location, _mapType.getContentType().getRawClass());\n+                _key = key;\n+                _id = id;\n+            }\n+\n+            @Override\n+            public void handleResolvedForwardReference(Object id, Object value)\n+                throws IOException\n+            {\n+                resolveForwardReference(id, value);\n+            }\n+        }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n \n     @JsonIdentityInfo(property=\"id\",\n             generator=ObjectIdGenerators.PropertyGenerator.class)\n-    static class Employee {\n+    public static class Employee {\n         public int id;\n      \n         public String name;\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n package com.fasterxml.jackson.databind.struct;\n \n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import com.fasterxml.jackson.annotation.JsonAnySetter;\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference.UnresolvedId;\n+import com.fasterxml.jackson.databind.struct.TestObjectId.Company;\n+import com.fasterxml.jackson.databind.struct.TestObjectId.Employee;\n \n /**\n  * Unit test to verify handling of Object Id deserialization\n         }\n     }\n     \n+    static class MappedCompany {\n+        public Map<Integer, Employee> employees;\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    static class AnySetterObjectId {\n+        private Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n+\n+        @JsonAnySetter\n+        public void anySet(String field, AnySetterObjectId value) {\n+            // Ensure that it is never called with null because of unresolved reference.\n+            assertNotNull(value);\n+            values.put(field, value);\n+        }\n+    }\n+\n     private final ObjectMapper mapper = new ObjectMapper();\n     \n     /*\n         assertEquals(7, result.node.value);\n         assertSame(result.node, result.node.next.node);\n     }\n-    \n+\n+    public void testForwardReference()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\"\n+                      + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":2,\\\"reports\\\":[]},\"\n+                      + \"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":null,\\\"reports\\\":[1]}\"\n+                      + \"]}\";\n+        Company company = mapper.readValue(json, Company.class);\n+        assertEquals(2, company.employees.size());\n+        Employee firstEmployee = company.employees.get(0);\n+        Employee secondEmployee = company.employees.get(1);\n+        assertEquals(1, firstEmployee.id);\n+        assertEquals(2, secondEmployee.id);\n+        assertEquals(secondEmployee, firstEmployee.manager); // Ensure that forward reference was properly resolved.\n+        assertEquals(firstEmployee, secondEmployee.reports.get(0)); // And that back reference is also properly resolved.\n+    }\n+\n+    public void testForwardReferenceInCollection()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\"\n+                      + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"]}\";\n+        Company company = mapper.readValue(json, Company.class);\n+        assertEquals(2, company.employees.size());\n+        Employee firstEmployee = company.employees.get(0);\n+        Employee secondEmployee = company.employees.get(1);\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    public void testForwardReferenceInMap()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":{\"\n+                      + \"\\\"1\\\":{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"\\\"2\\\": 2,\"\n+                      + \"\\\"3\\\":{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"}}\";\n+        MappedCompany company = mapper.readValue(json, MappedCompany.class);\n+        assertEquals(3, company.employees.size());\n+        Employee firstEmployee = company.employees.get(1);\n+        Employee secondEmployee = company.employees.get(3);\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    private void assertEmployees(Employee firstEmployee, Employee secondEmployee)\n+    {\n+        assertEquals(1, firstEmployee.id);\n+        assertEquals(2, secondEmployee.id);\n+        assertEquals(1, firstEmployee.reports.size());\n+        assertSame(secondEmployee, firstEmployee.reports.get(0)); // Ensure that forward reference was properly resolved and in order.\n+        assertSame(firstEmployee, secondEmployee.manager); // And that back reference is also properly resolved.\n+    }\n+\n+    public void testForwardReferenceAnySetterCombo() throws Exception {\n+        String json = \"{\\\"@id\\\":1, \\\"foo\\\":2, \\\"bar\\\":{\\\"@id\\\":2, \\\"foo\\\":1}}\";\n+        AnySetterObjectId value = mapper.readValue(json, AnySetterObjectId.class);\n+        assertSame(value.values.get(\"bar\"), value.values.get(\"foo\"));\n+    }\n+\n+    public void testUnresolvedForwardReference()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\" \n+                      + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[3]},\"\n+                      + \"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":3,\\\"reports\\\":[]}\" \n+                      + \"]}\";\n+        try {\n+            mapper.readValue(json, Company.class);\n+            fail(\"Should have thrown.\");\n+        } catch (UnresolvedForwardReference exception) {\n+            // Expected\n+            List<UnresolvedId> unresolvedIds = exception.getUnresolvedIds();\n+            assertEquals(2, unresolvedIds.size());\n+            UnresolvedId firstUnresolvedId = unresolvedIds.get(0);\n+            assertEquals(3, firstUnresolvedId.getId());\n+            assertEquals(Employee.class, firstUnresolvedId.getType());\n+            UnresolvedId secondUnresolvedId = unresolvedIds.get(1);\n+            assertEquals(firstUnresolvedId.getId(), secondUnresolvedId.getId());\n+            assertEquals(Employee.class, secondUnresolvedId.getType());\n+        }\n+    }\n+\n+    public void testKeepCollectionOrdering()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[2,1,\"\n+                + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                + \"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                + \"]}\";\n+        Company company = mapper.readValue(json, Company.class);\n+        assertEquals(4, company.employees.size());\n+        // Deser must keep object ordering.\n+        Employee firstEmployee = company.employees.get(1);\n+        Employee secondEmployee = company.employees.get(0);\n+        assertSame(firstEmployee, company.employees.get(2));\n+        assertSame(secondEmployee, company.employees.get(3));\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    public void testKeepMapOrdering()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":{\"\n+                      + \"\\\"1\\\":2, \\\"2\\\":1,\"\n+                      + \"\\\"3\\\":{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"\\\"4\\\":{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"}}\";\n+        MappedCompany company = mapper.readValue(json, MappedCompany.class);\n+        assertEquals(4, company.employees.size());\n+        Employee firstEmployee = company.employees.get(2);\n+        Employee secondEmployee = company.employees.get(1);\n+        assertEmployees(firstEmployee, secondEmployee);\n+        // Deser must keep object ordering. Not sure if it's really important for maps,\n+        // but since default map is LinkedHashMap might as well ensure it does...\n+        Iterator<Entry<Integer,Employee>> iterator = company.employees.entrySet().iterator();\n+        assertSame(secondEmployee, iterator.next().getValue());\n+        assertSame(firstEmployee, iterator.next().getValue());\n+        assertSame(firstEmployee, iterator.next().getValue());\n+        assertSame(secondEmployee, iterator.next().getValue());\n+    }\n+\n     /*\n     /*****************************************************\n     /* Unit tests, custom (property-based) id deserialization\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdDeserialization.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.struct.TestObjectId.Employee;\n+import com.fasterxml.jackson.failing.TestObjectIdDeserialization.EnumMapCompany.FooEnum;\n+\n+/**\n+ * Unit test to verify handling of Object Id deserialization\n+ */\n+public class TestObjectIdDeserialization extends BaseMapTest\n+{\n+    static class ArrayCompany {\n+        public Employee[] employees;\n+    }\n+\n+    static class ArrayBlockingQueueCompany {\n+        public ArrayBlockingQueue<Employee> employees;\n+    }\n+\n+    static class EnumMapCompany {\n+        public EnumMap<FooEnum,Employee> employees;\n+\n+        static enum FooEnum {\n+            A, B\n+        }\n+    }\n+\n+    static class DefensiveCompany {\n+        public List<DefensiveEmployee> employees;\n+\n+        static class DefensiveEmployee extends Employee {\n+\n+            public void setReports(List<DefensiveEmployee> reports)\n+            {\n+                this.reports = new ArrayList<Employee>(reports);\n+            }\n+        }\n+    }\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests, external id deserialization\n+    /*****************************************************\n+     */\n+\n+\n+    public void testForwardReferenceInArray()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\"\n+                      + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"2,\"\n+                      +\"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"]}\";\n+        ArrayCompany company = mapper.readValue(json, ArrayCompany.class);\n+        assertEquals(3, company.employees.length);\n+        Employee firstEmployee = company.employees[0];\n+        Employee secondEmployee = company.employees[1];\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    // Do a specific test for ArrayBlockingQueue since it has its own deser.\n+    public void testForwardReferenceInQueue()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\"\n+                      + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"2,\"\n+                      +\"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"]}\";\n+        ArrayBlockingQueueCompany company = mapper.readValue(json, ArrayBlockingQueueCompany.class);\n+        assertEquals(3, company.employees.size());\n+        Employee firstEmployee = company.employees.take();\n+        Employee secondEmployee = company.employees.take();\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    public void testForwardReferenceInEnumMap()\n+        throws Exception\n+   {\n+        String json = \"{\\\"employees\\\":{\"\n+                      + \"\\\"A\\\":{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                      + \"\\\"B\\\": 2,\"\n+                      + \"\\\"C\\\":{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\"\n+                      + \"}}\";\n+        EnumMapCompany company = mapper.readValue(json, EnumMapCompany.class);\n+        assertEquals(3, company.employees.size());\n+        Employee firstEmployee = company.employees.get(FooEnum.A);\n+        Employee secondEmployee = company.employees.get(FooEnum.B);\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    public void testForwardReferenceWithDefensiveCopy()\n+        throws Exception\n+    {\n+        String json = \"{\\\"employees\\\":[\" + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n+                + \"{\\\"id\\\":2,\\\"name\\\":\\\"Second\\\",\\\"manager\\\":1,\\\"reports\\\":[]}\" + \"]}\";\n+        DefensiveCompany company = mapper.readValue(json, DefensiveCompany.class);\n+        assertEquals(2, company.employees.size());\n+        Employee firstEmployee = company.employees.get(0);\n+        Employee secondEmployee = company.employees.get(1);\n+        assertEmployees(firstEmployee, secondEmployee);\n+    }\n+\n+    private void assertEmployees(Employee firstEmployee, Employee secondEmployee)\n+    {\n+        assertEquals(1, firstEmployee.id);\n+        assertEquals(2, secondEmployee.id);\n+        assertEquals(1, firstEmployee.reports.size());\n+        assertSame(secondEmployee, firstEmployee.reports.get(0)); // Ensure that forward reference was properly resolved and in order.\n+        assertSame(firstEmployee, secondEmployee.manager); // And that back reference is also properly resolved.\n+    }\n+}", "timestamp": 1389638275, "metainfo": ""}