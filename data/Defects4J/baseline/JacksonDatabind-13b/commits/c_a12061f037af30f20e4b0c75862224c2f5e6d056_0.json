{"sha": "a12061f037af30f20e4b0c75862224c2f5e6d056", "log": "Implement [Issue-33]: changes to ObjectReader.readValues() to simplify semantics", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n      */\n     protected final T _updatedValue;\n \n+    /**\n+     * @deprecated Since 2.1, to be removed\n+     */\n+    @Deprecated\n     protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n             JsonDeserializer<?> deser)\n     {\n         this(type, jp, ctxt, deser, true, null);\n     }\n-    \n+\n+    /**\n+     * @param managedParser Whether we \"own\" the {@link JsonParser} passed or not:\n+     *   if true, it was created by {@link ObjectReader} and code here needs to\n+     *   close it; if false, it was passed by calling code and should not be\n+     *   closed by iterator.\n+     */\n     @SuppressWarnings(\"unchecked\")\n-    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser,\n-            boolean closeParser, Object valueToUpdate)\n+    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n+            JsonDeserializer<?> deser,\n+            boolean managedParser, Object valueToUpdate)\n     {\n         _type = type;\n         _parser = jp;\n         _context = ctxt;\n         _deserializer = (JsonDeserializer<T>) deser;\n-\n-        /* One more thing: if we are at START_ARRAY (but NOT root-level\n-         * one!), advance to next token (to allow matching END_ARRAY)\n-         */\n-        if (jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) {\n-            JsonStreamContext sc = jp.getParsingContext();\n-            // safest way to skip current token is to clear it (so we'll advance soon)\n-            if (!sc.inRoot()) {\n-                jp.clearCurrentToken();\n-            }\n-        }\n-        _closeParser = closeParser;\n+        _closeParser = managedParser;\n         if (valueToUpdate == null) {\n             _updatedValue = null;\n         } else {\n             _updatedValue = (T) valueToUpdate;\n+        }\n+\n+        /* Ok: one more thing; we may have to skip START_ARRAY, assuming\n+         * \"wrapped\" sequence; but this is ONLY done for 'managed' parsers\n+         * and never if JsonParser was directly passed by caller (if it\n+         * was, caller must have either positioned it over first token of\n+         * the first element, or cleared the START_ARRAY token explicitly).\n+         * Note, however, that we do not try to guess whether this could be\n+         * an unwrapped sequence of arrays/Lists: we just assume it is wrapped;\n+         * and if not, caller needs to hand us JsonParser instead, pointing to\n+         * the first token of the first element.\n+         */\n+        if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            jp.clearCurrentToken();\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt, \n                 _findRootDeserializer(ctxt, _valueType),\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n+        jp.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n public class TestReadValues extends BaseMapTest\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testRootBeans() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        ObjectMapper mapper = new ObjectMapper();\n-        Iterator<Bean> it = mapper.reader(Bean.class).readValues(JSON);\n+        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n \n         assertTrue(it.hasNext());\n         Bean b = it.next();\n     public void testRootMaps() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        ObjectMapper mapper = new ObjectMapper();\n-        Iterator<Map<?,?>> it = mapper.reader(Map.class).readValues(JSON);\n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(JSON);\n \n         assertTrue(it.hasNext());\n         Map<?,?> map = it.next();\n         assertFalse(it.hasNext());\n     }\n \n-    public void testRootArrays() throws Exception\n-    {\n-        final String JSON = \"[1][3]\";\n-        ObjectMapper mapper = new ObjectMapper();\n-        Iterator<int[]> it = mapper.reader(int[].class).readValues(JSON);\n-\n-        assertTrue(it.hasNext());\n-        int[] array = it.next();\n-        assertEquals(1, array.length);\n-        assertEquals(1, array[0]);\n-        assertTrue(it.hasNext());\n-        array = it.next();\n-        assertEquals(1, array.length);\n-        assertEquals(3, array[0]);\n-        assertFalse(it.hasNext());\n-    }\n-\n     /*\n     /**********************************************************\n     /* Unit tests; root-level value sequences via JsonParser\n     public void testRootBeansWithParser() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n         \n         Iterator<Bean> it = jp.readValuesAs(Bean.class);\n \n         assertEquals(27, b.a);\n         assertFalse(it.hasNext());\n     }\n+\n+    public void testRootArraysWithParser() throws Exception\n+    {\n+        final String JSON = \"[1][3]\";\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n+\n+        // NOTE: We must point JsonParser to the first element; if we tried to\n+        // use \"managed\" accessor, it would try to advance past START_ARRAY.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp);\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+    }\n     \n     /*\n     /**********************************************************\n     public void testNonRootBeans() throws Exception\n     {\n         final String JSON = \"{\\\"leaf\\\":[{\\\"a\\\":3},{\\\"a\\\":27}]}\";\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n         assertToken(JsonToken.START_OBJECT, jp.nextToken());\n         assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n-        \n-        Iterator<Bean> it = mapper.reader(Bean.class).readValues(jp);\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        \n+        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(jp);\n \n         assertTrue(it.hasNext());\n         Bean b = it.next();\n         jp.close();\n     }\n \n-    public void testNonRootMaps() throws Exception\n+    public void testNonRootMapsWithParser() throws Exception\n     {\n         final String JSON = \"[{\\\"a\\\":3},{\\\"a\\\":27}]\";\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n-        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n-        Iterator<Map<?,?>> it = mapper.reader(Map.class).readValues(jp);\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        jp.clearCurrentToken();\n+        \n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(jp);\n \n         assertTrue(it.hasNext());\n         Map<?,?> map = it.next();\n         jp.close();\n     }\n \n-    public void testNonRootArrays() throws Exception\n+    public void testNonRootMapsWithObjectReader() throws Exception\n+    {\n+        String JSON = \"[{ \\\"hi\\\": \\\"ho\\\", \\\"neighbor\\\": \\\"Joe\\\" },\\n\"\n+            +\"{\\\"boy\\\": \\\"howdy\\\", \\\"huh\\\": \\\"what\\\"}]\";\n+        final MappingIterator<Map<String, Object>> iterator = MAPPER\n+                .reader()\n+                .withType(new TypeReference<Map<String, Object>>(){})\n+                .readValues(JSON);\n+\n+        Map<String,Object> map;\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertFalse(iterator.hasNext());\n+    }\n+    \n+    public void testNonRootArraysUsingParser() throws Exception\n     {\n         final String JSON = \"[[1],[3]]\";\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n-        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n-        Iterator<int[]> it = mapper.readValues(jp, int[].class);\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        // Important: as of 2.1, START_ARRAY can only be skipped if the\n+        // target type is NOT a Collection or array Java type.\n+        // So we have to explicitly skip it in this particular case.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.readValues(jp, int[].class);\n \n         assertTrue(it.hasNext());\n         int[] array = it.next();\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testSimpleSetter() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SizeClassSetter result = m.readValue\n+        SizeClassSetter result = MAPPER.readValue\n             (\"{ \\\"other\\\":3, \\\"size\\\" : 2, \\\"length\\\" : -999 }\",\n              SizeClassSetter.class);\n                                              \n     // Test for checking [JACKSON-64]\n     public void testSimpleSetter2() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SizeClassSetter2 result = m.readValue\n-            (\"{ \\\"x\\\": -3 }\",\n+        SizeClassSetter2 result = MAPPER.readValue(\"{ \\\"x\\\": -3 }\",\n              SizeClassSetter2.class);\n         assertEquals(-3, result._x);\n     }\n     // Checking parts of [JACKSON-120]\n     public void testSimpleSetter3() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SizeClassSetter3 result = m.readValue\n+        SizeClassSetter3 result = MAPPER.readValue\n             (\"{ \\\"x\\\": 128 }\",\n              SizeClassSetter3.class);\n         assertEquals(128, result._x);\n      */\n     public void testSetterInheritance() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        BeanSubClass result = m.readValue\n+        BeanSubClass result = MAPPER.readValue\n             (\"{ \\\"x\\\":1, \\\"z\\\" : 3, \\\"y\\\" : 2 }\",\n              BeanSubClass.class);\n         assertEquals(1, result._x);\n \n     public void testImpliedProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        BeanWithDeserialize bean = m.readValue(\"{\\\"a\\\":3}\", BeanWithDeserialize.class);\n+        BeanWithDeserialize bean = MAPPER.readValue(\"{\\\"a\\\":3}\", BeanWithDeserialize.class);\n         assertNotNull(bean);\n         assertEquals(3, bean.a);\n     }", "timestamp": 1342845746, "metainfo": ""}