{"sha": "03de57bccddc652696b0dbd69731368c54d0a297", "log": "Add support for configuring serialization TimeZone for Dates/Calendars (next: deserialization)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n+import java.util.Locale;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n public abstract class DateTimeSerializerBase<T>\n     extends StdScalarSerializer<T>\n         if (property != null) {\n             JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n             if (format != null) {\n+                // Simple case first: serialize as numeric timestamp?\n                 if (format.getShape().isNumeric()) {\n                     return withFormat(true, null);\n                 }\n+                // If not, do we have a pattern?\n+                TimeZone tz = format.getTimeZone();\n                 String pattern = format.getPattern();\n                 if (pattern.length() > 0){\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, prov.getLocale());\n-                    df.setTimeZone(prov.getTimeZone());\n+                    Locale loc = format.getLocale();\n+                    if (loc == null) {\n+                        loc = prov.getLocale();\n+                    }\n+                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n+                    if (tz == null) {\n+                        tz = prov.getTimeZone();\n+                    }\n+                    df.setTimeZone(tz);\n+                    return withFormat(false, df);\n+                }\n+                // If not, do we at least have a custom timezone?\n+                if (tz != null) {\n+                    DateFormat df = prov.getConfig().getDateFormat();\n+                    // one shortcut: with our custom format, can simplify handling a bit\n+                    if (df.getClass() == StdDateFormat.class) {\n+                        df = StdDateFormat.getISO8601Format(tz);\n+                    } else {\n+                        // otherwise need to clone, re-set timezone:\n+                        df = (DateFormat) df.clone();\n+                        df.setTimeZone(tz);\n+                    }\n                     return withFormat(false, df);\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n      */\n     private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID);\n \n+    /*\n+    /**********************************************************\n+    /* Static factories\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Accessor for static GMT timezone instance.\n      */\n     public static TimeZone timeZoneGMT() {\n         return TIMEZONE_GMT;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Formatting\n+    /**********************************************************\n+     */\n     \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n         return formatted.toString();\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Parsing\n+    /**********************************************************\n+     */\n \n     /**\n      * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n      */\n     public final static StdDateFormat instance = new StdDateFormat();\n \n+    /**\n+     * Caller may want to explicitly override timezone to use; if so,\n+     * we will have non-null value here.\n+     */\n+    protected transient TimeZone _timezone;\n+    \n     protected transient DateFormat _formatRFC1123;\n     protected transient DateFormat _formatISO8601;\n     protected transient DateFormat _formatISO8601_z;\n \n     @Override\n     public StdDateFormat clone() {\n-        /* Since we always delegate all work to child DateFormat instances,\n-         * let's NOT call super.clone(); this is bit unusual, but makes\n-         * sense here to avoid unnecessary work.\n+        /* Although there is that much state to share, we do need to\n+         * orchestrate a bit, mostly since timezones may be changed\n          */\n         return new StdDateFormat();\n     }\n      * compliant date format.\n      */\n     public static DateFormat getISO8601Format(TimeZone tz) {\n-        DateFormat df = (DateFormat) DATE_FORMAT_ISO8601.clone();\n-        df.setTimeZone(tz);\n-        return df;\n+        return _cloneFormat(DATE_FORMAT_ISO8601, tz);\n     }\n \n     /**\n      * that uses specific timezone and can handle RFC-1123\n      * compliant date format.\n      */\n-    public static DateFormat getRFC1123Format(TimeZone tz)\n-    {\n-        DateFormat df = (DateFormat) DATE_FORMAT_RFC1123.clone();\n-        df.setTimeZone(tz);\n-        return df;\n+    public static DateFormat getRFC1123Format(TimeZone tz) {\n+        return _cloneFormat(DATE_FORMAT_RFC1123, tz);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n+    @Override\n+    public void setTimeZone(TimeZone tz)\n+    {\n+        /* DateFormats are timezone-specific (via Calendar contained),\n+         * so need to reset instances if timezone changes:\n+         */\n+        if (tz != _timezone) {\n+            _formatRFC1123 = null;\n+            _formatISO8601 = null;\n+            _formatISO8601_z = null;\n+            _formatPlain = null;\n+            _timezone = tz;\n+        }\n+    }\n+    \n     @Override\n     public Date parse(String dateStr) throws ParseException\n     {\n \n     @Override\n     public StringBuffer format(Date date, StringBuffer toAppendTo,\n-                               FieldPosition fieldPosition)\n+            FieldPosition fieldPosition)\n     {\n         if (_formatISO8601 == null) {\n-            _formatISO8601 = (DateFormat) DATE_FORMAT_ISO8601.clone();\n+            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601);\n         }\n         return _formatISO8601.format(date, toAppendTo, fieldPosition);\n     }\n         if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n             if (df == null) {\n-                df = _formatPlain = (DateFormat) DATE_FORMAT_PLAIN.clone();\n+                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN);\n             }\n         } else if (c == 'Z') {\n             df = _formatISO8601_z;\n             if (df == null) {\n-                df = _formatISO8601_z = (DateFormat) DATE_FORMAT_ISO8601_Z.clone();\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z);\n             }\n             // [JACKSON-334]: may be missing milliseconds... if so, add\n             if (dateStr.charAt(len-4) == ':') {\n                 \n                 df = _formatISO8601;\n                 if (_formatISO8601 == null) {\n-                    df = _formatISO8601 = (DateFormat) DATE_FORMAT_ISO8601.clone();\n+                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601);\n                 }\n             } else {\n                 /* 24-Nov-2009, tatu: Ugh. This is getting pretty\n                 dateStr = sb.toString();\n                 df = _formatISO8601_z;\n                 if (df == null) {\n-                    df = _formatISO8601_z = (DateFormat) DATE_FORMAT_ISO8601_Z.clone();\n+                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z);\n                 }\n             }\n         }\n     protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n     {\n         if (_formatRFC1123 == null) {\n-            _formatRFC1123 = (DateFormat) DATE_FORMAT_RFC1123.clone();\n+            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123);\n         }\n         return _formatRFC1123.parse(dateStr, pos);\n     }\n         }\n         return false;\n     }\n+\n+    private final DateFormat _cloneFormat(DateFormat df) {\n+        return _cloneFormat(df, _timezone);\n+    }\n+\n+    private final static DateFormat _cloneFormat(DateFormat df, TimeZone tz)\n+    {\n+        df = (DateFormat) df.clone();\n+        if (tz != null) {\n+            df.setTimeZone(tz);\n+        }\n+        return df;\n+    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd\")\n         public Date date;\n         public DateAsStringBean(long l) { date = new java.util.Date(l); }\n+    }\n+\n+    static class DateInCETBean {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd,HH:00\", timezone=\"CET\")\n+        public Date date;\n+        public DateInCETBean(long l) { date = new java.util.Date(l); }\n     }\n     \n     /*\n         mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n         json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new DateAsStringBean(0L));\n         assertEquals(\"{\\\"date\\\":\\\"1970-01-01\\\"}\", json);\n+\n+        // and with different DateFormat; CET is one hour ahead of GMT\n+        json = mapper.writeValueAsString(new DateInCETBean(0L));\n+        assertEquals(\"{\\\"date\\\":\\\"1970-01-01,01:00\\\"}\", json);\n     }\n }\n ", "timestamp": 1330063766, "metainfo": ""}