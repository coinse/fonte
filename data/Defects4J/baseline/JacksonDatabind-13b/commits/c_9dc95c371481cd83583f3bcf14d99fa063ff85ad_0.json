{"sha": "9dc95c371481cd83583f3bcf14d99fa063ff85ad", "log": "Cleaned up Map handling of ObjectNode", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n public class ObjectNode\n     extends ContainerNode<ObjectNode>\n {\n-    protected LinkedHashMap<String, JsonNode> _children = null;\n+    // note: until 2.1, was explicitly `LinkedHashMap`\n+    protected Map<String, JsonNode> _children = null;\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n \n-    protected ObjectNode(JsonNodeFactory nc, LinkedHashMap<String, JsonNode> children) {\n+    protected ObjectNode(JsonNodeFactory nc, Map<String, JsonNode> children) {\n         super(nc);\n         _children = children;\n     }\n     \n+    /* Question: should this delegate to `JsonNodeFactory`? It does not absolutely\n+     * have to, as long as sub-types override the method but...\n+     */\n     // note: co-variant for type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public ObjectNode deepCopy()\n     {\n+        /* 28-Sep-2012, tatu: Sub-classes really should override this method to\n+         *   produce compliant copies.\n+         * \n+         */\n+        if (getClass() != ObjectNode.class) {\n+            throw new IllegalStateException(\"ObjectNode subtype (\"+getClass().getName()+\" does not override deepCopy(), needs to\");\n+        }\n+        return _defaultDeepCopy();\n+    }\n+ \n+    /**\n+     * Default implementation for 'deepCopy()': can be delegated to by sub-classes\n+     * if necessary; but usually isn't.\n+     */\n+    protected ObjectNode _defaultDeepCopy()\n+    {\n         if (_children == null) {\n             return new ObjectNode(_nodeFactory);\n         }\n         final int len = _children.size();\n-        LinkedHashMap<String, JsonNode> newKids = new LinkedHashMap<String, JsonNode>(Math.max(4, len));\n+        Map<String, JsonNode> newKids = _createMap(Math.max(4, len));\n         for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n             newKids.put(entry.getKey(), entry.getValue().deepCopy());\n         }\n     public ObjectNode with(String propertyName)\n     {\n         if (_children == null) {\n-            _children = new LinkedHashMap<String, JsonNode>();\n+            _children = _createMap();\n         } else {\n             JsonNode n = _children.get(propertyName);\n             if (n != null) {\n     public ArrayNode withArray(String propertyName)\n     {\n         if (_children == null) {\n-            _children = new LinkedHashMap<String, JsonNode>();\n+            _children = _createMap();\n         } else {\n             JsonNode n = _children.get(propertyName);\n             if (n != null) {\n     public JsonNode setAll(Map<String,JsonNode> properties)\n     {\n         if (_children == null) {\n-            _children = new LinkedHashMap<String, JsonNode>(properties);\n+            _children = _createMap();\n         } else {\n             for (Map.Entry<String, JsonNode> en : properties.entrySet()) {\n                 JsonNode n = en.getValue();\n         int len = other.size();\n         if (len > 0) {\n             if (_children == null) {\n-                _children = new LinkedHashMap<String, JsonNode>(len);\n+                _children = _createMap(len);\n             }\n             other.putContentsTo(_children);\n         }\n \n     /*\n     /**********************************************************\n+    /* Overridable methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Internal factory method for creating {@link Map} used for storing\n+     * child nodes. \n+     * Overridable by sub-classes, used when caller does not know what\n+     * optimal size would, used for example when constructing a Map when adding\n+     * the first one.\n+     * \n+     * @since 2.1\n+     */\n+    protected Map<String, JsonNode> _createMap() {\n+        return new LinkedHashMap<String, JsonNode>();\n+    }\n+    \n+    /**\n+     * Internal factory method for creating {@link Map} used for storing\n+     * child nodes. \n+     * Overridable by sub-classes, used when caller has an idea of what\n+     * optimal size should be: used when copying contents of an existing node.\n+     * \n+     * @since 2.1\n+     */\n+    protected Map<String, JsonNode> _createMap(int defaultSize) {\n+        return new LinkedHashMap<String, JsonNode>(defaultSize);\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Package methods (for other node classes to use)\n     /**********************************************************\n      */\n     private final JsonNode _put(String fieldName, JsonNode value)\n     {\n         if (_children == null) {\n-            _children = new LinkedHashMap<String, JsonNode>();\n+            _children = _createMap();\n         }\n         return _children.put(fieldName, value);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n         @JsonView(ViewA.class)\n         public String value = \"x\";\n     }   \n+\n+    // [JACKSON-868]\n+    public static class WebView { }\n+    public static class OtherView { }\n+    public static class Foo {\n+      @JsonView(WebView.class)\n+      public int getFoo() { return 3; }\n+    }\n     \n     /*\n     /**********************************************************\n         //json = mapper.writeValueAsString(bean);\n         assertEquals(\"{\\\"id\\\":\\\"id\\\"}\", json);\n     }\n+\n+    // [JACKSON-868]\n+    public void test() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n+        String json = mapper.writerWithView(OtherView.class).writeValueAsString(new Foo());\n+        assertEquals(json, \"{}\");\n+    }    \n }", "timestamp": 1348851494, "metainfo": ""}