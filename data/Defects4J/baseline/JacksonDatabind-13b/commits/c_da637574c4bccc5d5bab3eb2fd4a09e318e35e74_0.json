{"sha": "da637574c4bccc5d5bab3eb2fd4a09e318e35e74", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     }\n     \n     @Override\n-    public DeserializationConfig withClassIntrospector(ClassIntrospector ci) {\n+    public DeserializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n     }\n \n     @Override\n-    public DeserializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+    public DeserializationConfig with(AnnotationIntrospector ai) {\n         return _withBase(_base.withAnnotationIntrospector(ai));\n     }\n \n     @Override\n-    public DeserializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+    public DeserializationConfig with(VisibilityChecker<?> vc) {\n         return _withBase(_base.withVisibilityChecker(vc));\n     }\n \n     }\n     \n     @Override\n-    public DeserializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+    public DeserializationConfig with(TypeResolverBuilder<?> trb) {\n         return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n \n     @Override\n-    public DeserializationConfig withSubtypeResolver(SubtypeResolver str) {\n+    public DeserializationConfig with(SubtypeResolver str) {\n         return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n     }\n     \n     @Override\n-    public DeserializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+    public DeserializationConfig with(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n     }\n \n     }\n     \n     @Override\n-    public DeserializationConfig withTypeFactory(TypeFactory tf) {\n+    public DeserializationConfig with(TypeFactory tf) {\n         return _withBase( _base.withTypeFactory(tf));\n     }\n \n     @Override\n-    public DeserializationConfig withDateFormat(DateFormat df) {\n+    public DeserializationConfig with(DateFormat df) {\n         return _withBase(_base.withDateFormat(df));\n     }\n     \n     @Override\n-    public DeserializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+    public DeserializationConfig with(HandlerInstantiator hi) {\n         return _withBase(_base.withHandlerInstantiator(hi));\n     }\n \n     public DeserializationConfig withView(Class<?> view) {\n         return (_view == view) ? this : new DeserializationConfig(this, view);\n     }\n+\n+    @Override\n+    public DeserializationConfig with(Locale l) {\n+        return _withBase(_base.with(l));\n+    }\n+\n+    @Override\n+    public DeserializationConfig with(TimeZone tz) {\n+        return _withBase(_base.with(tz));\n+    }\n     \n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n      * Fluent factory method that will construct a new instance with\n      * specified {@link JsonNodeFactory}\n      */\n-    public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n+    public DeserializationConfig with(JsonNodeFactory f) {\n         if (_nodeFactory == f) {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      */\n     protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n             DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n-            null, StdDateFormat.instance, null);\n+            null, StdDateFormat.instance, null, Locale.getDefault(), TimeZone.getDefault());\n     \n     /*\n     /**********************************************************\n      * are defined.\n      */    \n     public void setVisibilityChecker(VisibilityChecker<?> vc) {\n-        _deserializationConfig = _deserializationConfig.withVisibilityChecker(vc);\n-        _serializationConfig = _serializationConfig.withVisibilityChecker(vc);\n+        _deserializationConfig = _deserializationConfig.with(vc);\n+        _serializationConfig = _serializationConfig.with(vc);\n     }\n \n     /**\n      */\n     public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n         _subtypeResolver = str;\n-        _deserializationConfig = _deserializationConfig.withSubtypeResolver(str);\n-        _serializationConfig = _serializationConfig.withSubtypeResolver(str);\n+        _deserializationConfig = _deserializationConfig.with(str);\n+        _serializationConfig = _serializationConfig.with(str);\n         return this;\n     }\n \n      * mapper instance for both serialization and deserialization\n      */\n     public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n-        _serializationConfig = _serializationConfig.withAnnotationIntrospector(ai);\n-        _deserializationConfig = _deserializationConfig.withAnnotationIntrospector(ai);\n+        _serializationConfig = _serializationConfig.with(ai);\n+        _deserializationConfig = _deserializationConfig.with(ai);\n         return this;\n     }\n     \n      * Method for setting custom property naming strategy to use.\n      */\n     public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n-        _serializationConfig = _serializationConfig.withPropertyNamingStrategy(s);\n-        _deserializationConfig = _deserializationConfig.withPropertyNamingStrategy(s);\n+        _serializationConfig = _serializationConfig.with(s);\n+        _deserializationConfig = _deserializationConfig.with(s);\n         return this;\n     }\n \n      * @param typer Type information inclusion handler\n      */\n     public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n-        _deserializationConfig = _deserializationConfig.withTypeResolverBuilder(typer);\n-        _serializationConfig = _serializationConfig.withTypeResolverBuilder(typer);\n+        _deserializationConfig = _deserializationConfig.with(typer);\n+        _serializationConfig = _serializationConfig.with(typer);\n         return this;\n     }\n \n     public ObjectMapper setTypeFactory(TypeFactory f)\n     {\n         _typeFactory = f;\n-        _deserializationConfig = _deserializationConfig.withTypeFactory(f);\n-        _serializationConfig = _serializationConfig.withTypeFactory(f);\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        _serializationConfig = _serializationConfig.with(f);\n         return this;\n     }\n     \n      * {@link #createObjectNode}\n      */\n     public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n-        _deserializationConfig = _deserializationConfig.withNodeFactory(f);\n+        _deserializationConfig = _deserializationConfig.with(f);\n         return this;\n     }\n \n      */\n     public ObjectMapper setDateFormat(DateFormat dateFormat)\n     {\n-        _deserializationConfig = _deserializationConfig.withDateFormat(dateFormat);\n-        _serializationConfig = _serializationConfig.withDateFormat(dateFormat);\n+        _deserializationConfig = _deserializationConfig.with(dateFormat);\n+        _serializationConfig = _serializationConfig.with(dateFormat);\n         return this;\n     }\n \n      */\n     public Object setHandlerInstantiator(HandlerInstantiator hi)\n     {\n-        _deserializationConfig = _deserializationConfig.withHandlerInstantiator(hi);\n-        _serializationConfig = _serializationConfig.withHandlerInstantiator(hi);\n+        _deserializationConfig = _deserializationConfig.with(hi);\n+        _serializationConfig = _serializationConfig.with(hi);\n         return this;\n     }\n     \n     }\n     \n     /**\n-     * Method for overriding default locale (which simply uses\n-     * {@link Locale#getDefault()}).\n+     * Method for overriding default locale to use for formatting.\n+     * Default value used is {@link Locale#getDefault()}.\n      */\n     public ObjectMapper setLocale(Locale l) {\n-        _deserializationContext.setLocale(l);\n-        _serializerProvider.setLocale(l);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for overriding default TimeZone (GMT)\n+        _deserializationConfig = _deserializationConfig.with(l);\n+        _serializationConfig = _serializationConfig.with(l);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for overriding default TimeZone to use for formatting.\n+     * Default value used is {@link TimeZone#getDefault()}.\n      */\n     public ObjectMapper setTimeZone(TimeZone tz) {\n-        _deserializationContext.setTimeZone(tz);\n-        _serializerProvider.setTimeZone(tz);\n+        _deserializationConfig = _deserializationConfig.with(tz);\n+        _serializationConfig = _serializationConfig.with(tz);\n         return this;\n     }\n     \n      */\n     public ObjectWriter writer(DateFormat df) {\n         return new ObjectWriter(this,\n-                getSerializationConfig().withDateFormat(df));\n+                getSerializationConfig().with(df));\n     }\n     \n     /**\n      */\n     public ObjectReader reader() {\n         return new ObjectReader(this, getDeserializationConfig())\n-            .withInjectableValues(_injectableValues);\n+            .with(_injectableValues);\n     }\n \n     /**\n      */\n     public ObjectReader reader(JsonNodeFactory f)\n     {\n-        return new ObjectReader(this, getDeserializationConfig()).withNodeFactory(f);\n+        return new ObjectReader(this, getDeserializationConfig()).with(f);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import java.io.*;\n import java.net.URL;\n import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.TimeZone;\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.core.*;\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withInjectableValues(InjectableValues injectableValues)\n+    public ObjectReader with(InjectableValues injectableValues)\n     {\n         if (_injectableValues == injectableValues) {\n             return this;\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withNodeFactory(JsonNodeFactory f)\n-    {\n-        DeserializationConfig newConfig = _config.withNodeFactory(f);\n+    public ObjectReader with(JsonNodeFactory f)\n+    {\n+        DeserializationConfig newConfig = _config.with(f);\n         return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n     }\n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withSchema(FormatSchema schema)\n+    public ObjectReader with(FormatSchema schema)\n     {\n         if (_schema == schema) {\n             return this;\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     }\n \n+    public ObjectReader with(Locale l) {\n+        DeserializationConfig newConfig = _config.with(l);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+\n+    public ObjectReader with(TimeZone tz) {\n+        DeserializationConfig newConfig = _config.with(tz);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Simple accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n \n import java.io.*;\n import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectWriter withDateFormat(DateFormat df)\n-    {\n-        SerializationConfig newConfig = _config.withDateFormat(df);\n+    public ObjectWriter with(DateFormat df)\n+    {\n+        SerializationConfig newConfig = _config.with(df);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n     }\n \n      */\n     public ObjectWriter withDefaultPrettyPrinter()\n     {\n-        return withPrettyPrinter(new DefaultPrettyPrinter());\n+        return with(new DefaultPrettyPrinter());\n     }\n \n     /**\n      * Method that will construct a new instance that uses specified\n      * provider for resolving filter instances by id.\n      */\n-    public ObjectWriter withFilters(FilterProvider filterProvider)\n+    public ObjectWriter with(FilterProvider filterProvider)\n     {\n         if (filterProvider == _config.getFilterProvider()) { // no change?\n             return this;\n      * Method that will construct a new instance that will use specified pretty\n      * printer (or, if null, will not do any pretty-printing)\n      */\n-    public ObjectWriter withPrettyPrinter(PrettyPrinter pp)\n+    public ObjectWriter with(PrettyPrinter pp)\n     {\n         if (pp == _prettyPrinter) {\n             return this;\n         return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n     }    \n \n+    public ObjectWriter with(Locale l) {\n+        SerializationConfig newConfig = _config.with(l);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    public ObjectWriter with(TimeZone tz) {\n+        SerializationConfig newConfig = _config.with(tz);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Simple accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     }\n \n     @Override\n-    public SerializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+    public SerializationConfig with(AnnotationIntrospector ai) {\n         return _withBase(_base.withAnnotationIntrospector(ai));\n     }\n \n     }\n \n     @Override\n-    public SerializationConfig withClassIntrospector(ClassIntrospector ci) {\n+    public SerializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n     }\n     \n      * (enable if format set as null; disable if non-null)\n      */\n     @Override\n-    public SerializationConfig withDateFormat(DateFormat df) {\n+    public SerializationConfig with(DateFormat df) {\n         SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n         // Also need to toggle this feature based on existence of date format:\n         if (df == null) {\n     }\n     \n     @Override\n-    public SerializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+    public SerializationConfig with(HandlerInstantiator hi) {\n         return _withBase(_base.withHandlerInstantiator(hi));\n     }\n     \n     @Override\n-    public SerializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+    public SerializationConfig with(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n     }\n \n     }\n \n     @Override\n-    public SerializationConfig withSubtypeResolver(SubtypeResolver str) {\n+    public SerializationConfig with(SubtypeResolver str) {\n         return (str == _subtypeResolver)? this : new SerializationConfig(this, str);\n     }\n \n     @Override\n-    public SerializationConfig withTypeFactory(TypeFactory tf) {\n+    public SerializationConfig with(TypeFactory tf) {\n         return _withBase(_base.withTypeFactory(tf));\n     }\n \n     @Override\n-    public SerializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+    public SerializationConfig with(TypeResolverBuilder<?> trb) {\n         return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n     \n     }\n \n     @Override\n-    public SerializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+    public SerializationConfig with(VisibilityChecker<?> vc) {\n         return _withBase(_base.withVisibilityChecker(vc));\n     }\n \n     @Override\n     public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return _withBase(_base.withVisibility(forMethod, visibility));\n+    }\n+\n+    @Override\n+    public SerializationConfig with(Locale l) {\n+        return _withBase(_base.with(l));\n+    }\n+\n+    @Override\n+    public SerializationConfig with(TimeZone tz) {\n+        return _withBase(_base.with(tz));\n     }\n     \n     private final SerializationConfig _withBase(BaseSettings newBase) {\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n package com.fasterxml.jackson.databind.cfg;\n \n import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n      * beyond simply construction of instances; or to use alternative constructors.\n      */\n     protected final HandlerInstantiator _handlerInstantiator;\n+\n+    /**\n+     * Default {@link java.util.Locale} used with serialization formats.\n+     * Default value is {@link Locale#getDefault()}.\n+     */\n+    protected final Locale _locale;\n+\n+    /**\n+     * Default {@link java.util.TimeZone} used with serialization formats.\n+     * Default value is {@link Timezone#getDefault()}, which is typically the\n+     * local timezone (unless overridden for JVM).\n+     */\n+    protected final TimeZone _timeZone;\n     \n     /*\n     /**********************************************************\n \n     public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai,\n             VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n-            TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi)\n+            TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi,\n+            Locale locale, TimeZone tz)\n     {\n         _classIntrospector = ci;\n         _annotationIntrospector = ai;\n         _typeResolverBuilder = typer;\n         _dateFormat = dateFormat;\n         _handlerInstantiator = hi;\n+        _locale = locale;\n+        _timeZone = tz;\n     }\n \n     /*\n     \n     public BaseSettings withClassIntrospector(ClassIntrospector ci) {\n         return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n     \n     public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n         return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n \n     public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n     \n     public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n \n     public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                 _visibilityChecker.withVisibility(forMethod, visibility),\n                 _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n     \n     public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n \n     public BaseSettings withTypeFactory(TypeFactory tf) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n \n     public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                typer, _dateFormat, _handlerInstantiator);\n+                typer, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n     }\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator);\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, hi);\n+                _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone);\n+    }\n+\n+    public BaseSettings with(Locale l) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);\n+    }\n+\n+    public BaseSettings with(TimeZone tz) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz);\n     }\n     \n     /*\n     public HandlerInstantiator getHandlerInstantiator() {\n         return _handlerInstantiator;\n     }\n+\n+    public Locale getLocale() {\n+        return _locale;\n+    }\n+\n+    public TimeZone getTimeZone() {\n+        return _timeZone;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n package com.fasterxml.jackson.databind.cfg;\n \n import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n  * accessors to mode-independent configuration settings\n  * and such.\n  * In addition, shared features are defined\n- * in {@link MapperFeature}\n+ * in {@link MapperFeature}.\n  *<p>\n  * Small part of implementation is included here by aggregating\n  * {@link BaseSettings} instance that contains configuration\n     public final DateFormat getDateFormat() { return _base.getDateFormat(); }\n \n     /**\n+     * Method for accessing the default {@link java.util.Locale} to use\n+     * for formatting, unless overridden by local annotations.\n+     * Initially set to {@link Locale#getDefault()}.\n+     */\n+    public final Locale getLocale() { return _base.getLocale(); }\n+    \n+    /**\n+     * Method for accessing the default {@link java.util.TimeZone} to use\n+     * for formatting, unless overridden by local annotations.\n+     * Initially set to {@link TimeZone#getDefault()}.\n+     */\n+    public final TimeZone getTimeZone() { return _base.getTimeZone(); }\n+    \n+    /**\n      * Accessor for finding currently active view, if any (null if none)\n      */\n     public abstract Class<?> getActiveView();\n         return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers());\n     }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n package com.fasterxml.jackson.databind.cfg;\n \n import java.text.DateFormat;\n+import java.util.Locale;\n import java.util.Map;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n+    public abstract T with(AnnotationIntrospector ai);\n \n     /**\n      * Method for constructing and returning a new instance with additional\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withClassIntrospector(ClassIntrospector ci);\n+    public abstract T with(ClassIntrospector ci);\n \n     /**\n      * Method for constructing and returning a new instance with different\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withDateFormat(DateFormat df);\n+    public abstract T with(DateFormat df);\n \n     /**\n      * Method for constructing and returning a new instance with different\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n+    public abstract T with(HandlerInstantiator hi);\n     \n     /**\n      * Method for constructing and returning a new instance with different\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n+    public abstract T with(PropertyNamingStrategy strategy);\n     \n     /**\n      * Method for constructing and returning a new instance with different\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n      */\n-    public abstract T withSubtypeResolver(SubtypeResolver str);\n+    public abstract T with(SubtypeResolver str);\n     \n     /**\n      * Method for constructing and returning a new instance with different\n      * {@link TypeFactory}\n      * to use.\n      */\n-    public abstract T withTypeFactory(TypeFactory typeFactory);\n+    public abstract T with(TypeFactory typeFactory);\n \n     /**\n      * Method for constructing and returning a new instance with different\n      * {@link TypeResolverBuilder} to use.\n      */\n-    public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n+    public abstract T with(TypeResolverBuilder<?> trb);\n \n     /**\n      * Method for constructing and returning a new instance with different\n      * {@link VisibilityChecker}\n      * to use.\n      */\n-    public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n+    public abstract T with(VisibilityChecker<?> vc);\n \n     /**\n      * Method for constructing and returning a new instance with different\n      * minimal visibility level for specified property type\n      */\n     public abstract T withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * default {@link java.util.Locale} to use for formatting.\n+     */\n+    public abstract T with(Locale l);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * default {@link java.util.TimeZone} to use for formatting of date values.\n+     */\n+    public abstract T with(TimeZone tz);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n             if (property != null) {\n                 JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat(property.getMember());\n                 if (format != null) {\n-                    String pattern = format.pattern;\n+                    String pattern = format.getPattern();\n                     if (pattern.length() > 0){\n                         SimpleDateFormat df = new SimpleDateFormat(pattern, ctxt.getLocale());\n                         df.setTimeZone(ctxt.getTimeZone());\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n         if (property != null) {\n             JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n             if (format != null) {\n-                if (format.shape.isNumeric()) {\n+                if (format.getShape().isNumeric()) {\n                     return withFormat(true, null);\n                 }\n-                String pattern = format.pattern;\n+                String pattern = format.getPattern();\n                 if (pattern.length() > 0){\n                     SimpleDateFormat df = new SimpleDateFormat(pattern, prov.getLocale());\n                     df.setTimeZone(prov.getTimeZone());\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n \n /**\n  * Unit tests for checking handling of DeserializationConfig.\n         ObjectMapper m = new ObjectMapper();\n         DeserializationConfig cfg = m.getDeserializationConfig();\n         // and finally, ensure we could override introspectors\n-        cfg = cfg.withClassIntrospector(null); // no way to verify tho\n-        cfg = cfg.withAnnotationIntrospector(null);\n+        cfg = cfg.with((ClassIntrospector) null); // no way to verify tho\n+        cfg = cfg.with((AnnotationIntrospector) null);\n         assertNull(cfg.getAnnotationIntrospector());\n     }\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n     {\n         // not ideal, to use (ever-changing) current date, but...\n         java.util.Calendar value = Calendar.getInstance();\n-        value.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         long l = 12345678L;\n         value.setTimeInMillis(l);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public void testCalendarMap() throws Exception\n     {\n     \t Calendar c = Calendar.getInstance();\n-    \t c.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+//    \t c.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n          c.setTimeInMillis(123456000L);\n          DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     \t String JSON = \"{ \\\"\"+fmt.format(c.getTime())+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n \n /**\n  * Unit tests for checking handling of SerializationConfig.\n         ObjectMapper m = new ObjectMapper();\n         SerializationConfig cfg = m.getSerializationConfig();\n         // and finally, ensure we could override introspectors\n-        cfg = cfg.withClassIntrospector(null); // no way to verify tho\n-        cfg = cfg.withAnnotationIntrospector(null);\n+        cfg = cfg.with((ClassIntrospector) null); // no way to verify tho\n+        cfg = cfg.with((AnnotationIntrospector) null);\n         assertNull(cfg.getAnnotationIntrospector());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         ObjectWriter w = MAPPER.writer((DateFormat)null);\n         assertEquals(\"0\", w.writeValueAsString(new Date(0L)));\n \n-        w = w.withDateFormat(df);\n+        w = w.with(df);\n         assertEquals(quote(\"1969-12-31X16:00:00\"), w.writeValueAsString(new Date(0L)));\n-        w = w.withDateFormat(null);\n+        w = w.with((DateFormat) null);\n         assertEquals(\"0\", w.writeValueAsString(new Date(0L)));\n     }\n \n \n         // then reverse\n         mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n-        json = mapper.writeValueAsString(new DateAsStringBean(0L));\n+        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new DateAsStringBean(0L));\n         assertEquals(\"{\\\"date\\\":\\\"1970-01-01\\\"}\", json);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n import java.util.*;\n \n \n+import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.databind.*;\n \n /**\n  * Unit tests for checking features added to {@link ObjectWriter}, such\n  * as adding of explicit pretty printer.\n- * \n- * @since 1.6\n  */\n public class TestObjectWriter\n     extends BaseMapTest\n         assertEquals(\"{\\n  \\\"a\\\" : 1\\n}\", writer.writeValueAsString(data));\n \n         // and finally, again without indentation\n-        writer = writer.withPrettyPrinter(null);\n+        writer = writer.with((PrettyPrinter) null);\n         assertEquals(\"{\\\"a\\\":1}\", writer.writeValueAsString(data));\n     }\n }", "timestamp": 1330055900, "metainfo": ""}