{"sha": "3eb74af17d39f5d6017e579590174c3941210d82", "log": "Implement #550", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     // Quick little shortcut, to avoid having to use global TypeFactory instance...\n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n-    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n-     *   sure what'd be simple and elegant way. So until then:\n-     */\n-    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n-\n     // 16-May-2009, tatu: Ditto ^^^\n     protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n \n      * Base settings contain defaults used for all {@link ObjectMapper}\n      * instances.\n      */\n-    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n-            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n+    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(\n+            null, // can not share global ClassIntrospector any more (2.5+)\n+            DEFAULT_ANNOTATION_INTROSPECTOR,\n+            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n             null, StdDateFormat.instance, null,\n             Locale.getDefault(),\n //            TimeZone.getDefault()\n \n         HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n         _mixInAnnotations = mixins;\n-        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n+\n+        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n+        _serializationConfig = new SerializationConfig(base,\n                     _subtypeResolver, mixins);\n-        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n+        _deserializationConfig = new DeserializationConfig(base,\n                     _subtypeResolver, mixins);\n \n         // Some overrides we may need\n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n-\n+    \n     /**\n      * Method for creating a new {@link ObjectMapper} instance that\n      * has same initial configuration as this instance. Note that this\n \n     /**\n      * @since 2.1\n-     * @param exp\n      */\n     protected void _checkInvalidCopy(Class<?> exp)\n     {\n             throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                     +\" (version: \"+version()+\") does not override copy(); it has to\");\n         }\n+    }\n+\n+    /**\n+     * Overridable helper method used to construct default {@link ClassIntrospector}\n+     * to use.\n+     * \n+     * @since 2.5\n+     */\n+    protected ClassIntrospector defaultClassIntrospector() {\n+        return new BasicClassIntrospector();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.Collection;\n+import java.util.Map;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n \n public class BasicClassIntrospector\n     extends ClassIntrospector\n      * This is strictly performance optimization to reduce what is\n      * usually one-time cost, but seems useful for some cases considering\n      * simplicity.\n+     * \n+     * @since 2.4\n      */\n     \n     protected final static BasicBeanDescription STRING_DESC;\n     /**********************************************************\n      */\n \n+    @Deprecated // since 2.5: construct instance directly\n     public final static BasicClassIntrospector instance = new BasicClassIntrospector();\n \n-    public BasicClassIntrospector() { }\n+    /**\n+     * Looks like 'forClassAnnotations()' gets called so frequently that we\n+     * should consider caching to avoid some of the lookups.\n+     * \n+     * @since 2.5\n+     */\n+    protected final LRUMap<JavaType,BasicBeanDescription> _cachedFCA;\n+\n+    public BasicClassIntrospector() {\n+        // a small cache should go a long way here\n+        _cachedFCA = new LRUMap<JavaType,BasicBeanDescription>(16, 64);\n+    }\n     \n     /*\n     /**********************************************************\n     public BasicBeanDescription forSerialization(SerializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n-            \t\ttype, r, true, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n+                        type, r, true, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserialization(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n-            \t\ttype, r, false, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n+                        \t\ttype, r, false, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserializationWithBuilder(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-    \t// no caching for Builders (no standard JDK builder types):\n-    \treturn BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n-            \t\ttype, r, false));\n+        // no std JDK types with Builders, so:\n+\n+        BasicBeanDescription desc = BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n+                type, r, false));\n+        // this is still a superset of \"forClassAnnotations\", so may optimize by optional add:\n+        _cachedFCA.putIfAbsent(type, desc);\n+        return desc;\n     }\n     \n     @Override\n     public BasicBeanDescription forCreation(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(\n             \t\tcollectProperties(cfg, type, r, false, \"set\"));\n-        }\n+            }\n+        }\n+        // should this be cached for FCA?\n         return desc;\n     }\n \n     public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n-                (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            desc = _cachedFCA.get(type);\n+            if (desc == null) {\n+                boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+                AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                        (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n+                desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+                _cachedFCA.put(type, desc);\n+            }\n+        }\n+        return desc;\n     }\n \n     @Override\n     public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n-                (useAnnotations ? ai : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+            AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n+            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n+                    (useAnnotations ? ai : null), r);\n+            desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return desc;\n     }\n     \n     /*\n      * Method called to see if type is one of core JDK types\n      * that we have cached for efficiency.\n      */\n-    protected BasicBeanDescription _findCachedDesc(JavaType type)\n+    protected BasicBeanDescription _findStdTypeDesc(JavaType type)\n     {\n         Class<?> cls = type.getRawClass();\n-        if (cls == String.class) {\n-            return STRING_DESC;\n-        }\n-        if (cls == Boolean.TYPE) {\n-            return BOOLEAN_DESC;\n-        }\n-        if (cls == Integer.TYPE) {\n-            return INT_DESC;\n-        }\n-        if (cls == Long.TYPE) {\n-            return LONG_DESC;\n+        if (cls.isPrimitive()) {\n+            if (cls == Boolean.TYPE) {\n+                return BOOLEAN_DESC;\n+            }\n+            if (cls == Integer.TYPE) {\n+                return INT_DESC;\n+            }\n+            if (cls == Long.TYPE) {\n+                return LONG_DESC;\n+            }\n+        } else {\n+            if (cls == String.class) {\n+                return STRING_DESC;\n+            }\n         }\n         return null;\n     }\n+\n+    /**\n+     * Helper method used to decide whether we can omit introspection\n+     * for members (methods, fields, constructors); we may do so for\n+     * a limited number of container types JDK provides.\n+     */\n+    protected boolean _isStdJDKCollection(JavaType type)\n+    {\n+        if (!type.isContainerType() || type.isArrayType()) {\n+            return false;\n+        }\n+        Class<?> raw = type.getRawClass();\n+        Package pkg = raw.getPackage();\n+        if (pkg != null) {\n+            String pkgName = pkg.getName();\n+            if (pkgName.startsWith(\"java.lang\")\n+                    || pkgName.startsWith(\"java.util\")) {\n+                /* 23-Sep-2014, tatu: Should we be conservative here (minimal number\n+                 *    of matches), or ambitious? Let's do latter for now.\n+                 */\n+                if (Collection.class.isAssignableFrom(raw)\n+                        || Map.class.isAssignableFrom(raw)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        if (_isStdJDKCollection(type)) {\n+            AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                    (cfg.isAnnotationProcessingEnabled() ? cfg.getAnnotationIntrospector() : null), r);\n+            return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n  * NOTE: since version 2.4.2, this is <b>NOT</b> an LRU-based at all; reason\n  * being that it is not possible to use JDK components that do LRU _AND_ perform\n  * well wrt synchronization on multi-core systems. So we choose efficient synchronization\n- * over potentially more effecient handling of entries.\n+ * over potentially more efficient handling of entries.\n+ *<p>\n+ * And yes, there are efficient LRU implementations such as\n+ * <a href=\"https://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a>;\n+ * but at this point we really try to keep external deps to minimum. But perhaps\n+ * a shaded variant may be used one day.\n  */\n public class LRUMap<K,V>\n     implements java.io.Serializable\n         return _map.put(key, value);\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    public V putIfAbsent(K key, V value) {\n+        // not 100% optimal semantically, but better from correctness (never exceeds\n+        // defined maximum) and close enough all in all:\n+        if (_map.size() >= _maxEntries) {\n+            synchronized (this) {\n+                if (_map.size() >= _maxEntries) {\n+                    clear();\n+                }\n+            }\n+        }\n+        return _map.putIfAbsent(key, value);\n+    }\n+    \n     // NOTE: key is of type Object only to retain binary backwards-compatibility\n     public V get(Object key) {  return _map.get(key); }\n ", "timestamp": 1411506297, "metainfo": ""}