{"sha": "6bf829f329e7fe34fe2f336b98ce4a693d232da7", "log": "Add some support for builder-based deserializers for POJOs-as-array feature", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         // Any transformation we may need to apply?\n         JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n         _serializationShape = (format == null) ? null : format.getShape();\n-        \n+\n         _needViewProcesing = hasViews;\n         _vanillaProcessing = !_nonStandardCreation\n                 && (_injectables == null)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n     }\n \n     @Override\n-    protected BuilderBasedDeserializer asArrayDeserializer() {\n-        /* 17-Jul-2012, tatu: Should be doable, but for now let's just not\n-         *   support this combination, and instead wait for an RFE to see\n-         *   if anyone cares.\n-         */\n-        throw new UnsupportedOperationException(\"Can not combine serialization-as-Array with Builder style construction\");\n+    protected BeanAsArrayBuilderDeserializer asArrayDeserializer() {\n+        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n+        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);\n     }\n     \n     /*\n      */\n     \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-    \t\tthrows IOException\n+            throws IOException\n     {\n         try {\n-    \t\treturn _buildMethod.getMember().invoke(builder);\n+            return _buildMethod.getMember().invoke(builder);\n     \t} catch (Exception e) {\n-    \t\twrapInstantiationProblem(e, ctxt);\n-    \t\treturn null;\n-\t\t}\n+    \t    wrapInstantiationProblem(e, ctxt);\n+    \t    return null;\n+    \t}\n     }\n     \n     /**\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             return finishBuild(ctxt, deserializeFromObject(jp, ctxt));\n-\t\t}\n+        }\n         throw ctxt.mappingException(getBeanClass());\n     }\n \n                         continue; // never gets here\n                     }\n                     //  polymorphic?\n-        \t\t    if (bean.getClass() != _beanType.getRawClass()) {\n-        \t\t        return handlePolymorphic(jp, ctxt, bean, unknown);\n-        \t\t    }\n-        \t\t    if (unknown != null) { // nope, just extra unknown stuff...\n-        \t\t        bean = handleUnknownProperties(ctxt, bean, unknown);\n-        \t\t    }\n-        \t\t    // or just clean?\n-        \t\t    return _deserialize(jp, ctxt, bean);\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                    }\n+                    if (unknown != null) { // nope, just extra unknown stuff...\n+                        bean = handleUnknownProperties(ctxt, bean, unknown);\n+                    }\n+                    // or just clean?\n+                    return _deserialize(jp, ctxt, bean);\n                 }\n                 continue;\n             }\n         // We hit END_OBJECT, so:\n         Object bean;\n         try {\n-            bean =  creator.build(ctxt, buffer);\n+            bean = creator.build(ctxt, buffer);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+public class BeanAsArrayBuilderDeserializer\n+    extends BeanDeserializerBase\n+{\n+    /**\n+     * Deserializer we delegate operations that we can not handle.\n+     */\n+    protected final BeanDeserializerBase _delegate;\n+\n+    /**\n+     * Properties in order expected to be found in JSON array.\n+     */\n+    protected final SettableBeanProperty[] _orderedProperties;\n+\n+    protected final AnnotatedMethod _buildMethod;\n+        \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Main constructor used both for creating new instances (by\n+     * {@link BeanDeserializer#asArrayDeserializer}) and for\n+     * creating copies with different delegate.\n+     */\n+    public BeanAsArrayBuilderDeserializer(BeanDeserializerBase delegate,\n+            SettableBeanProperty[] ordered,\n+            AnnotatedMethod buildMethod)\n+    {\n+        super(delegate);\n+        _delegate = delegate;\n+        _orderedProperties = ordered;\n+        _buildMethod = buildMethod;\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n+    {\n+        /* We can't do much about this; could either replace _delegate\n+         * with unwrapping instance, or just replace this one. Latter seems\n+         * more sensible.\n+         */\n+        return _delegate.unwrappingDeserializer(unwrapper);\n+    }\n+\n+    @Override\n+    public BeanAsArrayBuilderDeserializer withObjectIdReader(ObjectIdReader oir) {\n+        return new BeanAsArrayBuilderDeserializer(_delegate.withObjectIdReader(oir),\n+                _orderedProperties, _buildMethod);\n+    }\n+\n+    @Override\n+    public BeanAsArrayBuilderDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n+        return new BeanAsArrayBuilderDeserializer(_delegate.withIgnorableProperties(ignorableProps),\n+                _orderedProperties, _buildMethod);\n+    }\n+\n+    @Override\n+    protected BeanAsArrayBuilderDeserializer asArrayDeserializer() {\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n+            throws IOException\n+    {\n+        try {\n+            return _buildMethod.getMember().invoke(builder);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null;\n+        }\n+    }\n+    \n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n+        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        }\n+        if (!_vanillaProcessing) {\n+            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+        }\n+        Object builder = _valueInstantiator.createUsingDefault(ctxt);\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return finishBuild(ctxt, builder);\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return finishBuild(ctxt, builder);\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* No good way to verify that we have an array... although could I guess\n+         * check via JsonParser. So let's assume everything is working fine, for now.\n+         */\n+        if (_injectables != null) {\n+            injectValues(ctxt, builder);\n+        }\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return finishBuild(ctxt, builder);\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n+        \n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return finishBuild(ctxt, builder);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, non-standard creation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Alternate deserialization method that has to check many more configuration\n+     * aspects than the \"vanilla\" processing.\n+     * Note: should NOT resolve builder; caller will do that\n+     * \n+     * @return Builder object in use.\n+     */\n+    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_nonStandardCreation) {\n+            return _deserializeWithCreator(jp, ctxt);\n+        }\n+        Object builder = _valueInstantiator.createUsingDefault(ctxt);\n+        if (_injectables != null) {\n+            injectValues(ctxt, builder);\n+        }\n+        Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return builder;\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            ++i;\n+            if (prop != null) { // normal case\n+                if (activeView == null || prop.visibleInView(activeView)) {\n+                    try {\n+                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                    }\n+                    continue;\n+                }\n+            }\n+            // otherwise, skip it (view-filtered, no prop etc)\n+            jp.skipChildren();\n+        }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return builder;\n+    }\n+    \n+    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt,\n+                    _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+\n+    /**\n+     * Method called to deserialize bean using \"property-based creator\":\n+     * this means that a non-default constructor or factory method is\n+     * called, and then possibly other setters. The trick is that\n+     * values for creator method need to be buffered, first; and \n+     * due to non-guaranteed ordering possibly some other properties\n+     * as well.\n+     */\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+            final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        final int propCount = props.length;\n+        int i = 0;\n+        Object builder = null;\n+        \n+        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+            SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n+            if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // if we have already constructed POJO, things are simple:\n+            if (builder != null) {\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+                continue;\n+            }\n+            final String propName = prop.getName();\n+            // if not yet, maybe we got a creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n+                    try {\n+                        builder = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    //  polymorphic?\n+                    if (builder.getClass() != _beanType.getRawClass()) {\n+                        /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n+                         *   supported (since ordering of elements may not be guaranteed);\n+                         *   but make explicitly non-supported for now.\n+                         */\n+                        throw ctxt.mappingException(\"Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: \"\n+                                +\"nominal type \"+_beanType.getRawClass().getName()+\", actual type \"+builder.getClass().getName());\n+                    }\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+        }\n+\n+        // In case we didn't quite get all the creator properties, we may have to do this:\n+        if (builder == null) {\n+            try {\n+                builder = creator.build(ctxt, buffer);\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+                return null; // never gets here\n+            }\n+        }\n+        return builder;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, error reporting\n+    /**********************************************************\n+     */\n+\n+    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        // Let's start with failure\n+        throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n+                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\"): type/property designed to be serialized as JSON Array\");\n+        // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n+        //return _delegate.deserialize(jp, ctxt);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n     \t}\n     }\n \n-\t// // 3-property value, with more varied builder\n+    // // 3-property value, with more varied builder\n \t\n-\t@JsonDeserialize(builder=BuildABC.class)\n-\tstatic class ValueClassABC\n-\t{\n-\t\tfinal int a, b, c;\n-\n-\t\tprotected ValueClassABC(int a, int b, int c) {\n-\t\t\tthis.a = a;\n-\t\t\tthis.b = b;\n-\t\t\tthis.c = c;\n-\t\t}\n-\t}\n+    @JsonDeserialize(builder=BuildABC.class)\n+    static class ValueClassABC\n+    {\n+        final int a, b, c;\n+\n+        protected ValueClassABC(int a, int b, int c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n \n     static class BuildABC\n     {\n     \n     // And then with custom naming:\n \n-\t@JsonDeserialize(builder=BuildFoo.class)\n-\tstatic class ValueFoo\n-\t{\n-\t\tfinal int value;\n-\t\tprotected ValueFoo(int v) { value = v; }\n-\t}\n-\n-\t@JsonPOJOBuilder(withPrefix=\"foo\", buildMethodName=\"construct\")\n+    @JsonDeserialize(builder=BuildFoo.class)\n+    static class ValueFoo\n+    {\n+        final int value;\n+        protected ValueFoo(int v) { value = v; }\n+    }\n+\n+    @JsonPOJOBuilder(withPrefix=\"foo\", buildMethodName=\"construct\")\n     static class BuildFoo {\n         private int value;\n         \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Unit tests for \"POJO as array\" feature using Builder-style\n+ * POJO construction.\n+ */\n+public class TestPOJOAsArrayWithBuilder extends BaseMapTest\n+{\n+    @JsonDeserialize(builder=SimpleBuilderXY.class)\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class ValueClassXY\n+    {\n+        final int _x, _y;\n+\n+        protected ValueClassXY(int x, int y) {\n+            _x = x+1;\n+            _y = y+1;\n+        }\n+    }\n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    static class SimpleBuilderXY\n+    {\n+        public int x, y;\n+        \n+        public SimpleBuilderXY withX(int x) {\n+            this.x = x;\n+            return this;\n+        }\n+\n+        public SimpleBuilderXY withY(int y) {\n+            this.y = y;\n+            return this;\n+        }\n+\n+        public ValueClassXY build() {\n+            return new ValueClassXY(x, y);\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Basic tests\n+    /*****************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testSimpleBuilder() throws Exception\n+    {\n+        // Ok, first, ensure that serializer will \"black out\" filtered properties\n+        ValueClassXY value = MAPPER.readValue(\"[1,2]\", ValueClassXY.class);\n+        assertEquals(2, value._x);\n+        assertEquals(3, value._y);\n+    }\n+}", "timestamp": 1343709398, "metainfo": ""}