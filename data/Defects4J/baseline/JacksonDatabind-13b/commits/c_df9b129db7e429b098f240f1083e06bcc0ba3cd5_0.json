{"sha": "df9b129db7e429b098f240f1083e06bcc0ba3cd5", "log": "Merge pull request #595 from johnjohndoe/update-release-versions  Update release versions.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import java.lang.annotation.Annotation;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     \n     /*\n     /**********************************************************\n-    /* Class annotations for Polymorphic type handling (1.5+)\n+    /* Class annotations for Polymorphic type handling\n     /**********************************************************\n     */\n     \n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         return null;\n     }\n+\n+    /**\n+     * Method for adding possible virtual properties to be serialized along\n+     * with regular properties.\n+     * \n+     * @since 2.5\n+     */\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) { }\n     \n     /*\n     /**********************************************************\n         return false;\n     }\n \n+    /**\n+     * Method for finding indication of creator binding mode for\n+     * a creator (something for which {@link #hasCreatorAnnotation} returns\n+     * true), for cases where there may be ambiguity (currently: single-argument\n+     * creator with implicit but no explicit name for the argument).\n+     * \n+     * @since 2.5\n+     */\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Overridable methods: may be used as low-level extension\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n     /* Basic API for finding properties\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @return Ordered Map with logical property name as key, and\n      *    matching getter method as value.\n      */\n     public abstract List<BeanPropertyDefinition> findProperties();\n-    \n+\n     /**\n      * Method for locating all back-reference properties (setters, fields) bean has\n      */\n     public abstract Map<String,AnnotatedMember> findBackReferenceProperties();\n \n     public abstract Set<String> getIgnoredPropertyNames();\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic API for finding creator members\n     /**********************************************************\n      */\n-    \n+\n     public abstract List<AnnotatedConstructor> getConstructors();\n-    \n+\n     public abstract List<AnnotatedMethod> getFactoryMethods();\n-    \n+\n     /**\n      * Method that will locate the no-arg constructor for this class,\n      * if it has one, and that constructor has not been marked as\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n         @Override public AnnotatedMember getMember() { return _member; }\n \n         /**\n+         *<p>\n+         * TODO: move to {@link BeanProperty} in near future, once all standard\n+         * implementations define it.\n+         * \n+         * @since 2.5\n+         */\n+        public boolean isVirtual() { return false; }\n+\n+        /**\n          * Implementation of this method throws\n          * {@link UnsupportedOperationException}, since instances of this\n          * implementation should not be used as part of actual structure\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * \"fluent factory\" methods.\n  * Note also that unlike with Jackson 1, these instances can not be\n  * assigned to {@link ObjectMapper}; in fact, application code should\n- * rarely interact directly with these instance (unlike core Jackson code)\n+ * rarely interact directly with these instances.\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.1.0\n-    private static final long serialVersionUID = -4227480407273773599L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link DeserializationFeature}s enabled.\n      */\n     protected final int _deserFeatures;\n \n      * Factory used for constructing {@link com.fasterxml.jackson.databind.JsonNode} instances.\n      */\n     protected final JsonNodeFactory _nodeFactory;\n-    \n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable.\n+     */\n+    protected final int _parserFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable\n+     */\n+    protected final int _parserFeaturesToChange;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n         _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n         _nodeFactory = JsonNodeFactory.instance;\n         _problemHandlers = null;\n-    }\n-\n+        _parserFeatures = 0;\n+        _parserFeaturesToChange = 0;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures,\n+            int parserFeatures, int parserFeatureMask)\n+    {\n+        super(src, mapperFeatures);\n+        _deserFeatures = deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = parserFeatures;\n+        _parserFeaturesToChange = parserFeatureMask;\n+    }\n+    \n     /**\n      * Copy constructor used to create a non-shared instance with given mix-in\n      * annotation definitions and subtype resolver.\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n-    }\n-\n-    private DeserializationConfig(DeserializationConfig src,\n-            int mapperFeatures, int deserFeatures)\n-    {\n-        super(src, mapperFeatures);\n-        _deserFeatures = deserFeatures;\n-        _nodeFactory = src._nodeFactory;\n-        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = f;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src,\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, String rootName)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, Class<?> view)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     // for unit tests only:\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+                    \n     }\n \n     @Override\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, DeserializationFeature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = (_deserFeatures | feature.getMask());\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures | first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, JsonParser.Feature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig with(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures | feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig without(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures & ~feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withoutFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle, deserialization-specific factory methods\n                 (LinkedNode<DeserializationProblemHandler>) null);\n     }\n \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = (_deserFeatures | feature.getMask());\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures | first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig withFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-    \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified feature disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectReader}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonParser p) {\n+        if (_parserFeaturesToChange != 0) {\n+            int orig = p.getFeatureMask();\n+            int newFlags = (orig & ~_parserFeaturesToChange) | _parserFeatures;\n+            if (orig != newFlags) {\n+                p.setFeatureMask(newFlags);\n+            }\n+        }\n     }\n     \n     /*\n         return (_deserFeatures & f.getMask()) != 0;\n     }\n \n+    public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_parserFeaturesToChange & mask) != 0) {\n+            return (_parserFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+    \n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     /**\n      * Method for checking whether we could find a deserializer\n      * for given type.\n-     * \n+     *\n      * @param type\n      * @since 2.3\n      */\n     }\n \n     /**\n+     * Variant that will try to locate deserializer for current type, but without\n+     * performing any contextualization (unlike {@link #findContextualValueDeserializer})\n+     * or checking for need to create a {@link TypeDeserializer} (unlike\n+     * {@link #findRootValueDeserializer(JavaType)}.\n+     * This method is usually called from within {@link ResolvableDeserializer#resolve},\n+     * and expectation is that caller then calls either\n+     * {@link #handlePrimaryContextualization(JsonDeserializer, BeanProperty)} or\n+     * {@link #handleSecondaryContextualization(JsonDeserializer, BeanProperty)} at a\n+     * later point, as necessary.\n+     *\n+     * @since 2.5\n+     */\n+    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        return _cache.findValueDeserializer(this, _factory, type);\n+    }\n+    \n+    /**\n      * Method for finding a deserializer for root-level value.\n      */\n     @SuppressWarnings(\"unchecked\")\n             BeanProperty prop)\n         throws JsonMappingException\n     {\n-        if (deser != null) {\n-            if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n-            }\n+        if (deser instanceof ContextualDeserializer) {\n+            deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n     }\n      */\n     public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n             BeanProperty prop)\n-        throws JsonMappingException {\n-        if (deser != null && (deser instanceof ContextualDeserializer)) {\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n             deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private DeserializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n  * and as keys for deserializers.\n  *<p>\n  * Instances can (only) be constructed by\n- * <code>com.fasterxml.jackson.databind.TypeFactory</code>.\n+ * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n  *<p>\n  * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n  * it to be pushed through interfaces that only expose that type.\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n import java.math.BigInteger;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonPointer;\n-import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.node.JsonNodeType;\n import com.fasterxml.jackson.databind.node.MissingNode;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n  *<p>\n  * Actual concrete sub-classes can be found from package\n  * {@link com.fasterxml.jackson.databind.node}.\n+ *<p>\n+ * Note that it is possible to \"read\" from nodes, using\n+ * method {@link TreeNode#traverse(ObjectCodec)}, which will result in\n+ * a {@link JsonParser} being constructed. This can be used for (relatively)\n+ * efficient conversations between different representations; and it is what\n+ * core databind uses for methods like {@link ObjectMapper#treeToValue(TreeNode, Class)}\n+ * and {@link ObjectMapper#treeAsTokens(TreeNode)}\n  */\n public abstract class JsonNode\n-    implements TreeNode, Iterable<JsonNode>\n+    implements TreeNode, Iterable<JsonNode>,\n+        JsonSerializable // since 2.5; bit tricky if anyone is sub-classing but...\n {\n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-//    public abstract JsonToken asToken();\n-\n-//    public abstract JsonParser.NumberType numberType();\n-\n-//    public abstract JsonParser traverse();\n+//  public abstract JsonToken asToken();\n+//  public abstract JsonToken traverse();\n+//  public abstract JsonToken traverse(ObjectCodec codec);\n+//  public abstract JsonParser.NumberType numberType();\n \n     @Override\n     public int size() { return 0; }\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n      * \n      * @since 2.1\n      */\n-    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false)\n+    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false),\n+    \n+    /*\n+    /******************************************************\n+    /* Other features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether multiple registrations of same module\n+     * should be ignored or not; if enabled, only the first registration call\n+     * results in module being called, and possible duplicate calls are silently\n+     * ignored; if disabled, no checking is done and all registration calls are\n+     * dispatched to module.\n+     *<p>\n+     * Definition of \"same module\" is based on using {@link Module#getTypeId()};\n+     * modules with same non-null <code>type id</code> are considered same for\n+     * purposes of duplicate registration. This also avoids having to keep track\n+     * of actual module instances; only ids will be kept track of (and only if\n+     * this feature is enabled).\n+     *<p>\n+     * Feature is enabled by default.\n+     *\n+     * @since 2.5\n+     */\n+    IGNORE_DUPLICATE_MODULE_REGISTRATIONS(true)\n+    \n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private MapperFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n     \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n      */\n     @Deprecated\n     protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n-            JsonDeserializer<?> deser)\n-    {\n+            JsonDeserializer<?> deser) {\n         this(type, jp, ctxt, deser, true, null);\n     }\n \n         try {\n             return hasNextValue();\n         } catch (JsonMappingException e) {\n-            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+            return (Boolean) _handleMappingException(e);\n         } catch (IOException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-    }\n-\n+            return (Boolean) _handleIOException(e);\n+        }\n+    }\n+    \n     @Override\n     public T next()\n     {\n     \n     @Override\n     public void close() throws IOException{\n-        if(_parser != null) {\n+        if (_parser != null) {\n             _parser.close();\n         }\n     }\n         // caller should always call 'hasNext[Value]' first; but let's ensure:\n         if (!_hasNextChecked) {\n             if (!hasNextValue()) {\n-                throw new NoSuchElementException();\n+                return _throwNoSuchElement();\n             }\n         }\n         if (_parser == null) {\n-            throw new NoSuchElementException();\n+            return _throwNoSuchElement();\n         }\n         _hasNextChecked = false;\n         T result;\n \n     /**\n      * Convenience method for reading all entries accessible via\n-     * this iterator\n+     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n      * \n      * @return List of entries read\n      * \n      * \n      * @since 2.2\n      */\n-    public List<T> readAll(List<T> resultList) throws IOException\n+    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n     {\n         while (hasNextValue()) {\n-    \t\t    resultList.add(nextValue());\n+            resultList.add(nextValue());\n         }\n         return resultList;\n+    }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @since 2.5\n+     */\n+    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n+    {\n+        while (hasNextValue()) {\n+            results.add(nextValue());\n+        }\n+        return results;\n     }\n     \n     /*\n     public JsonLocation getCurrentLocation() {\n         return _parser.getCurrentLocation();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected <R> R _throwNoSuchElement() {\n+        throw new NoSuchElementException();\n+    }\n+    \n+    protected <R> R _handleMappingException(JsonMappingException e) {\n+        throw new RuntimeJsonMappingException(e.getMessage(), e);\n+    }\n+\n+    protected <R> R _handleIOException(IOException e) {\n+        throw new RuntimeException(e.getMessage(), e);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n      */\n     \n     /**\n-     * Method that returns identifier for module; this can be used by Jackson\n+     * Method that returns a display that can be used by Jackson\n      * for informational purposes, as well as in associating extensions with\n      * module that provides them.\n      */\n     @Override\n     public abstract Version version();\n \n+    /**\n+     * Method that returns an id that may be used to determine if two {@link Module}\n+     * instances are considered to be of same type, for purpose of preventing\n+     * multiple registrations of \"same type of\" module\n+     * (see {@link com.fasterxml.jackson.databind.MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS})\n+     * If `null` is returned, every instance is considered unique.\n+     * If non-null value is returned, equality of id Objects is used to check whether\n+     * modules should be considered to be \"of same type\"\n+     *<p>\n+     * Default implementation returns value of class name ({@link Class#getName}).\n+     *\n+     * @since 2.5\n+     */\n+    public Object getTypeId() {\n+        return getClass().getName();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: registration\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /*\n     /**********************************************************\n+    /* Module-related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of module types (as per {@link Module#getTypeId()} that have been\n+     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}\n+     * is enabled, so that duplicate registration calls can be ignored\n+     * (to avoid adding same handlers multiple times, mostly).\n+     * \n+     * @since 2.5\n+     */\n+    protected Set<Object> _registeredModuleTypes;\n+    \n+    /*\n+    /**********************************************************\n     /* Caching\n     /**********************************************************\n      */\n         }\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override if providing custom\n+    /* ObjectReader/ObjectWriter implementations\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Factory method sub-classes must override, to produce {@link ObjectReader}\n      * instances of proper sub-type\n      */\n     public ObjectMapper registerModule(Module module)\n     {\n+        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n+            Object typeId = module.getTypeId();\n+            if (typeId != null) {\n+                if (_registeredModuleTypes == null) {\n+                    _registeredModuleTypes = new HashSet<Object>();\n+                }\n+                // try adding; if already had it, should skip\n+                if (!_registeredModuleTypes.add(typeId)) {\n+                    return this;\n+                }\n+            }\n+        }\n+        \n         /* Let's ensure we have access to name and version information, \n          * even if we do not have immediate use for either. This way we know\n          * that they will be available from beginning\n             \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n-                mapper.addMixInAnnotations(target, mixinSource);\n+                mapper.addMixIn(target, mixinSource);\n             }\n             \n             @Override\n     /* Configuration, deserialization\n     /**********************************************************\n      */\n+\n+    /**\n+     * Method that can be used to get hold of {@link JsonNodeFactory}\n+     * that this mapper will use when directly constructing\n+     * root {@link JsonNode} instances for Trees.\n+     *<p>\n+     * Note: this is just a shortcut for calling\n+     *<pre>\n+     *   getDeserializationConfig().getNodeFactory()\n+     *</pre>\n+     */\n+    public JsonNodeFactory getNodeFactory() {\n+        return _deserializationConfig.getNodeFactory();\n+    }\n     \n     /**\n      * Method for specifying {@link JsonNodeFactory} to use for\n      * @since 2.4\n      */\n     public ObjectMapper setConfig(SerializationConfig config) {\n-    \t_serializationConfig = config;\n-    \treturn this;\n+        _serializationConfig = config;\n+        return this;\n     }\n     \n     /*\n     \n     /*\n     /**********************************************************\n-    /* Configuration, simple features\n-    /**********************************************************\n-     */\n-\n+    /* Configuration, simple features: MapperFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given {@link MapperFeature} is enabled.\n+     */\n+    public boolean isEnabled(MapperFeature f) {\n+        // ok to use either one, should be kept in sync\n+        return _serializationConfig.isEnabled(f);\n+    }\n+    \n     /**\n      * Method for changing state of an on/off mapper feature for\n      * this mapper instance.\n                 _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n     }\n-    \n+\n+    /**\n+     * Method for enabling specified {@link MapperConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.without(f);\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: SerializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given serialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(SerializationFeature f) {\n+        return _serializationConfig.isEnabled(f);\n+    }\n+\n     /**\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n     }\n \n     /**\n+     * Method for enabling specified {@link DeserializationConfig} feature.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.with(first, f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.without(first, f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: DeserializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given deserialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(DeserializationFeature f) {\n+        return _deserializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n      * Method for changing state of an on/off deserialization feature for\n      * this object mapper.\n      */\n     }\n \n     /**\n-     * Method for changing state of an on/off {@link JsonParser} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for changing state of an on/off {@link JsonGenerator} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link MapperConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.with(f);\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.without(f);\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-    \n-    /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n         return this;\n     }\n     \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} feature.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.with(first, f);\n-        return this;\n-    }\n-    \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.without(first, f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for checking whether given Mapper\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(MapperFeature f) {\n-        // ok to use either one, should be kept in sync\n-        return _serializationConfig.isEnabled(f);\n-    }\n-\n-    /**\n-     * Method for checking whether given serialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(SerializationFeature f) {\n-        return _serializationConfig.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method for checking whether given deserialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(DeserializationFeature f) {\n-        return _deserializationConfig.isEnabled(f);\n-    }\n-\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonParser.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _deserializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n+        _jsonFactory.configure(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonGenerator.Feature f) {\n+        return _serializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off {@link JsonGenerator} feature for\n+     * generator instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n+        _jsonFactory.configure(f,  state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonFactory.Feature\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Convenience method, equivalent to:\n      *<pre>\n      */\n     public boolean isEnabled(JsonFactory.Feature f) {\n         return _jsonFactory.isEnabled(f);\n-    }\n-\n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonParser.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonGenerator.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method that can be used to get hold of {@link JsonNodeFactory}\n-     * that this mapper will use when directly constructing\n-     * root {@link JsonNode} instances for Trees.\n-     *<p>\n-     * Note: this is just a shortcut for calling\n-     *<pre>\n-     *   getDeserializationConfig().getNodeFactory()\n-     *</pre>\n-     */\n-    public JsonNodeFactory getNodeFactory() {\n-        return _deserializationConfig.getNodeFactory();\n     }\n \n     /*\n      * Convenience method for constructing {@link ObjectWriter}\n      * with default settings.\n      */\n-    public ObjectWriter writer() {\n-        return _newWriter(getSerializationConfig());\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer() {\n+        return (W) _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature feature) {\n-        return _newWriter(getSerializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature feature) {\n+        return (W) _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return _newWriter(getSerializationConfig().with(first, other));\n+        return (W) _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n      */\n-    public ObjectWriter writer(DateFormat df) {\n-        return _newWriter(getSerializationConfig().with(df));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(DateFormat df) {\n+        return (W) _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified JSON View (filter).\n      */\n-    public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return _newWriter(getSerializationConfig().withView(serializationView));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithView(Class<?> serializationView) {\n+        return (W) _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime\n-     * type.\n-     */\n-    public ObjectWriter writerWithType(Class<?> rootType) {\n-        return _newWriter(getSerializationConfig(),\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return _newWriter(getSerializationConfig(),\n+     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(JavaType rootType) {\n-        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n      * serialize objects using specified pretty printer for indentation\n      * (or if null, no pretty printer)\n      */\n-    public ObjectWriter writer(PrettyPrinter pp) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(PrettyPrinter pp) {\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n+        return (W) _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using the default pretty printer for indentation\n      */\n-    public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return _newWriter(getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithDefaultPrettyPrinter() {\n+        return (W) _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified filter provider.\n      */\n-    public ObjectWriter writer(FilterProvider filterProvider) {\n-        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FilterProvider filterProvider) {\n+        return (W) _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      * \n      * @param schema Schema to pass to generator\n      */\n-    public ObjectWriter writer(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return _newWriter(getSerializationConfig(), schema);\n+        return (W) _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return _newWriter(getSerializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(Base64Variant defaultBase64) {\n+        return (W) _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(CharacterEscapes escapes) {\n-        return _newWriter(getSerializationConfig()).with(escapes);\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(CharacterEscapes escapes) {\n+        return (W) _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(ContextAttributes attrs) {\n-        return _newWriter(getSerializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(ContextAttributes attrs) {\n+        return (W) _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*\n      * default settings. Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader() {\n-        return _newReader(getDeserializationConfig()).with(_injectableValues);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader() {\n+        return (T) _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature feature) {\n-        return _newReader(getDeserializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature feature) {\n+        return (T) _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return _newReader(getDeserializationConfig().with(first, other));\n+        return (T) _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n+        return (T) _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type) {\n-        return _newReader(getDeserializationConfig(), type, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JavaType type) {\n+        return (T) _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type) {\n-        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Class<?> type) {\n+        return (T) _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type) {\n-        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(TypeReference<?> type) {\n+        return (T)_newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f) {\n-        return _newReader(getDeserializationConfig()).with(f);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JsonNodeFactory f) {\n+        return (T) _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      * \n      * @param schema Schema to pass to parser\n      */\n-    public ObjectReader reader(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return _newReader(getDeserializationConfig(), null, null,\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * \n      * @param injectableValues Injectable values to use\n      */\n-    public ObjectReader reader(InjectableValues injectableValues) {\n-        return _newReader(getDeserializationConfig(), null, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(InjectableValues injectableValues) {\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * deserialize objects using specified JSON View (filter).\n      */\n-    public ObjectReader readerWithView(Class<?> view) {\n-        return _newReader(getDeserializationConfig().withView(view));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerWithView(Class<?> view) {\n+        return (T) _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectReader reader(Base64Variant defaultBase64) {\n-        return _newReader(getDeserializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Base64Variant defaultBase64) {\n+        return (T) _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectReader reader(ContextAttributes attrs) {\n-        return _newReader(getDeserializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(ContextAttributes attrs) {\n+        return (T) _newReader(getDeserializationConfig().with(attrs));\n     }\n \n     /*\n      * call write functionality\n      */\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig();\n-        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n-        // [JACKSON-282]: consider Closeable\n+        cfg.initialize(jgen); // since 2.5\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n     }\n \n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n+        cfg.initialize(jgen); // since 2.5\n \n         // [JACKSON-282]: consider Closeable\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n      * Can be overridden if a custom context is needed.\n      */\n     protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n-            DeserializationConfig cfg)\n-    {\n-        return _deserializationContext.createInstance(cfg,\n-                jp, _injectableValues);\n+            DeserializationConfig cfg) {\n+        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n     }\n     \n     /**\n      *   content to map (note: Json \"null\" value is considered content;\n      *   enf-of-stream not)\n      */\n-    protected JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        _deserializationConfig.initialize(p); // since 2.5\n+\n         /* First: must point to a token; if not pointing to one, advance.\n          * This occurs before first read from JsonParser, as well as\n          * after clearing of current token.\n          */\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == null) {\n             // and then we must get something...\n-            t = jp.nextToken();\n+            t = p.nextToken();\n             if (t == null) {\n                 /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                  *   not an actual parsing problem\n                  */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n             }\n         }\n         return t;\n     }\n \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n+    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, \n             DeserializationConfig config,\n             JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n+        throws IOException\n     {\n         String expName = config.getRootName();\n         if (expName == null) {\n             PropertyName pname = _rootNames.findRootName(rootType, config);\n             expName = pname.getSimpleName();\n         }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n+        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        if (p.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        String actualName = p.getCurrentName();\n         if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                     +expName+\"') for type \"+rootType);\n         }\n         // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result = deser.deserialize(jp, ctxt);\n+        p.nextToken();\n+        Object result = deser.deserialize(p, ctxt);\n         // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n+        if (p.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     extends ObjectCodec\n     implements Versioned, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -4251443320039569153L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n         _unwrapRoot = config.useRootWrapping();\n         _dataFormatReaders = base._dataFormatReaders;\n     }\n-\n+    \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n     {\n         // may need to override ordering, based on data format capabilities\n     }\n \n     /**\n+     * Factory method used to create {@link MappingIterator} instances;\n+     * either default, or custom subtype.\n+     * \n+     * @since 2.5\n+     */\n+    protected <T> MappingIterator<T> _newIterator(JavaType valueType,\n+            JsonParser parser, DeserializationContext ctxt,\n+            JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)\n+    {\n+            return new MappingIterator<T>(valueType, parser, ctxt,\n+                    deser, parserManaged, valueToUpdate);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes may choose to override, if customized\n+    /* initialization is needed.\n+    /**********************************************************\n+     */\n+\n+    /**\n      * NOTE: changed from static to non-static in 2.5; unfortunate but\n      * necessary change to support overridability\n      */\n         if (_schema != null) {\n             p.setSchema(_schema);\n         }\n+        _config.initialize(p); // since 2.5\n+\n         /* First: must point to a token; if not pointing to one, advance.\n          * This occurs before first read from JsonParser, as well as\n          * after clearing of current token.\n         if (_schema != null) {\n             p.setSchema(_schema);\n         }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle, fluent factory methods\n-    /**********************************************************\n-     */\n-\n-    public ObjectReader with(DeserializationConfig config) {\n-        return _with(config);\n-    }    \n-    \n+        _config.initialize(p); // since 2.5\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for DeserializationFeatures\n+    /**********************************************************\n+     */\n+\n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n     public ObjectReader withoutFeatures(DeserializationFeature... features) {\n         return _with(_config.withoutFeatures(features));\n     }    \n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for JsonParser.Features\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectReader with(JsonParser.Feature feature) {\n+        return _with(_config.with(feature));\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withFeatures(features));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(JsonParser.Feature feature) {\n+        return _with(_config.without(feature)); \n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withoutFeatures(features));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods, other\n+    /**********************************************************\n+     */\n+\n+    public ObjectReader with(DeserializationConfig config) {\n+        return _with(config);\n+    }    \n+\n     /**\n      * Method for constructing a new instance with configuration that uses\n      * passed {@link InjectableValues} to provide injectable values.\n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(JavaType valueType)\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectReader forType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) {\n             return this;\n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(Class<?> valueType) {\n-        return withType(_config.constructType(valueType));\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n     }    \n \n     /**\n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(JavaType valueType) {\n+        return forType(valueType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(java.lang.reflect.Type valueType) {\n-        return withType(_config.getTypeFactory().constructType(valueType));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * to data bind into specified type.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n+        return forType(_config.getTypeFactory().constructType(valueType));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(TypeReference<?> valueTypeRef) {\n-        return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n \n     /**\n \n     /*\n     /**********************************************************\n-    /* Overridable factory methods that sub-classes MUST override\n+    /* Overridable factory methods may override\n     /**********************************************************\n      */\n     \n     {\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         // false -> do not close as caller gave parser instance\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        return _newIterator(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType),\n                 false, _valueToUpdate);\n     }\n         _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n-        return new MappingIterator<T>(_valueType, p, ctxt,\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n         _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n-        return new MappingIterator<T>(_valueType, p, ctxt,\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n         _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n-        return new MappingIterator<T>(_valueType, p, ctxt, \n-                _findRootDeserializer(ctxt, _valueType),\n-                true, _valueToUpdate);\n+        return _newIterator(_valueType, p, ctxt, \n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n     protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n-import java.text.DateFormat;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.TimeZone;\n+import java.text.*;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.core.util.Instantiatable;\n-import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.core.util.*;\n+\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n     implements Versioned,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -7040667122552707164L;\n+    private static final long serialVersionUID = 1; // since 2.5\n \n     /**\n      * We need to keep track of explicit disabling of pretty printing;\n \n     /*\n     /**********************************************************\n-    /* Derived settings\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * @since 2.3\n-     */\n-    protected final boolean  _cfgBigDecimalAsPlain;\n-\n-    /*\n-    /**********************************************************\n     /* Life-cycle, constructors\n     /**********************************************************\n      */\n             JavaType rootType, PrettyPrinter pp)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n             FormatSchema s)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n             PrettyPrinter pp, FormatSchema s, CharacterEscapes escapes)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         // may need to override ordering, based on data format capabilities\n         _config = base._config\n             .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n-        _cfgBigDecimalAsPlain = base._cfgBigDecimalAsPlain;\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n     \n     /*\n     /**********************************************************\n-    /* Life-cycle, fluent factories\n+    /* Life-cycle, fluent factories for SerializationFeature\n     /**********************************************************\n      */\n \n     public ObjectWriter withoutFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n-    }    \n-    \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter with(JsonGenerator.Feature feature)  {\n+        SerializationConfig newConfig = _config.with(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter without(JsonGenerator.Feature feature) {\n+        SerializationConfig newConfig = _config.without(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withoutFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withoutFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories, other\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct a new writer instance that will\n      * use specified date format for serializing dates; or if null passed, one\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    \n-    public ObjectWriter withSchema(FormatSchema schema) {\n+    public ObjectWriter with(FormatSchema schema) {\n         if (_schema == schema) {\n             return this;\n         }\n         _verifySchemaType(schema);\n         return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n                 _prettyPrinter, schema, _characterEscapes);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use {@link #with(FormatSchema)} instead\n+     */\n+    @Deprecated\n+    public ObjectWriter withSchema(FormatSchema schema) {\n+        return with(schema);\n     }\n \n     /**\n      *<p>\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectWriter withType(JavaType rootType)\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(JavaType rootType)\n     {\n         JsonSerializer<Object> rootSer;\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n      * Method that will construct a new instance that uses specific type\n      * as the root type for serialization, instead of runtime dynamic\n      * type of the root object itself.\n-     */\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(Class<?> rootType) {\n+        if (rootType == Object.class) {\n+            return forType((JavaType) null);\n+        }\n+        return forType(_config.constructType(rootType));\n+    }\n+\n+    public ObjectWriter forType(TypeReference<?> rootType) {\n+        return forType(_config.getTypeFactory().constructType(rootType.getType()));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated // since 2.5\n+    public ObjectWriter withType(JavaType rootType) {\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(Class<?> rootType) {\n-        if (rootType == Object.class) {\n-            return withType((JavaType) null);\n-        }\n-        return withType(_config.constructType(rootType));\n-    }\n-\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(TypeReference<?> rootType) {\n-        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n+        return forType(rootType);\n     }\n \n     /**\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n      * \n      * @since 2.1\n      */\n-    private void _configureJsonGenerator(JsonGenerator jgen)\n+    protected void _configureJsonGenerator(JsonGenerator gen)\n     {\n         if (_prettyPrinter != null) {\n             PrettyPrinter pp = _prettyPrinter;\n             if (pp == NULL_PRETTY_PRINTER) {\n-                jgen.setPrettyPrinter(null);\n+                gen.setPrettyPrinter(null);\n             } else {\n                 /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n                  *   like the DefaultPrettyPrinter.\n                 if (pp instanceof Instantiatable<?>) {\n                     pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n                 }\n-                jgen.setPrettyPrinter(pp);\n+                gen.setPrettyPrinter(pp);\n             }\n         } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n+            gen.useDefaultPrettyPrinter();\n         }\n         if (_characterEscapes != null) {\n-            jgen.setCharacterEscapes(_characterEscapes);\n+            gen.setCharacterEscapes(_characterEscapes);\n         }\n         // [JACKSON-520]: add support for pass-through schema:\n         if (_schema != null) {\n-            jgen.setSchema(_schema);\n-        }\n-        if (_cfgBigDecimalAsPlain) { // should only set if explicitly set; this should work for now:\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n+            gen.setSchema(_schema);\n+        }\n+        _config.initialize(gen); // since 2.5\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n public class PropertyName\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7930806520033045126L;\n+    private static final long serialVersionUID = 1L; // 2.5\n \n     private final static String _USE_DEFAULT = \"\";\n     private final static String _NO_NAME = \"\";\n     public SerializableString simpleAsEncoded(MapperConfig<?> config) {\n         SerializableString sstr = _encodedSimple;\n         if (sstr == null) {\n-            sstr = config.compileString(_simpleName);\n+            if (config == null) {\n+                sstr = new SerializedString(_simpleName);\n+            } else {\n+                sstr = config.compileString(_simpleName);\n+            }\n             _encodedSimple = sstr;\n         }\n         return sstr;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.core.Base64Variant;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // Valid as of 2.4\n-    private static final long serialVersionUID = -1278867172535832879L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link SerializationFeature}s enabled.\n      */\n     protected final int _serFeatures;\n     \n      * Non-null if explicitly defined; null by default.\n      */\n     protected final FilterProvider _filterProvider;\n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable.\n+     */\n+    protected final int _generatorFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable\n+     */\n+    protected final int _generatorFeaturesToChange;\n     \n     /*\n     /**********************************************************\n         super(base, str, mixins);\n         _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n         _filterProvider = null;\n+        _generatorFeatures = 0;\n+        _generatorFeaturesToChange = 0;\n     }\n     \n     private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n-    }\n-\n-    private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures)\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures,\n+            int generatorFeatures, int generatorFeatureMask)\n     {\n         super(src, mapperFeatures);\n         _serFeatures = serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = generatorFeatures;\n+        _generatorFeaturesToChange = generatorFeatureMask;\n     }\n     \n     private SerializationConfig(SerializationConfig src, BaseSettings base)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, FilterProvider filters)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = filters;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, Class<?> view)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = incl;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, String rootName)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n     \n     /*\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     /**\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     @Override\n         } else {\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n-        return (newMapperFlags == _mapperFeatures) ? this :\n-            new SerializationConfig(this, newMapperFlags, _serFeatures);\n+        return (newMapperFlags == _mapperFeatures) ? this\n+            : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                    _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     @Override\n     public SerializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n     }\n-    \n+\n     /**\n      * In addition to constructing instance with specified date format,\n      * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n         }\n         return cfg;\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(HandlerInstantiator hi) {\n         return _withBase(_base.withHandlerInstantiator(hi));\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n     public SerializationConfig with(TypeResolverBuilder<?> trb) {\n         return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n-    \n+\n     @Override\n     public SerializationConfig withView(Class<?> view) {\n         return (_view == view) ? this : new SerializationConfig(this, view);\n     public SerializationConfig with(ContextAttributes attrs) {\n         return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n     }\n-    \n+\n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle, SerializationConfig specific factory methods\n-    /**********************************************************\n-     */\n-        \n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for SerializationFeature\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified feature enabled.\n     {\n         int newSerFeatures = _serFeatures | feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n-    \n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n     {\n         int newSerFeatures = _serFeatures & ~feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig with(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures | feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig without(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures & ~feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withoutFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, other\n+    /**********************************************************\n+     */\n     \n     public SerializationConfig withFilters(FilterProvider filterProvider) {\n         return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n     public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n         return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonGenerator.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonGenerator g)\n+    {\n+        if (SerializationFeature.INDENT_OUTPUT.enabledIn(_serFeatures)) {\n+            g.useDefaultPrettyPrinter();\n+        }\n+        @SuppressWarnings(\"deprecation\")\n+        boolean useBigDec = SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_serFeatures);\n+        if ((_generatorFeaturesToChange != 0) || useBigDec) {\n+            int orig = g.getFeatureMask();\n+            int newFlags = (orig & ~_generatorFeaturesToChange) | _generatorFeatures;\n+            // although deprecated, needs to be supported for now\n+            if (useBigDec) {\n+                newFlags |= JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();\n+            }\n+            if (orig != newFlags) {\n+                g.setFeatureMask(newFlags);\n+            }\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n     /* MapperConfig implementation/overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean useRootWrapping()\n     {\n         }\n         return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n     }\n-    \n+\n     @Override\n     public AnnotationIntrospector getAnnotationIntrospector()\n     {\n-        /* 29-Jul-2009, tatu: it's now possible to disable use of\n-         *   annotations; can be done using \"no-op\" introspector\n-         */\n         if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n             return super.getAnnotationIntrospector();\n         }\n     public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n         return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n     }\n-    \n+\n     @Override\n     public VisibilityChecker<?> getDefaultVisibilityChecker()\n     {\n         }\n         return vchecker;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration: other\n         return (_serFeatures & f.getMask()) != 0;\n     }\n \n+    /**\n+     * Accessor method that first checks if we have any overrides\n+     * for feature, and only if not, checks state of passed-in\n+     * factory.\n+     * \n+     * @since 2.5\n+     */\n+    public final boolean isEnabled(JsonGenerator.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_generatorFeaturesToChange & mask) != 0) {\n+            return (_generatorFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+    \n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n     public final int getSerializationFeatures() {\n         return _serFeatures;\n     }\n-    \n+\n     public JsonInclude.Include getSerializationInclusion()\n     {\n         if (_serializationInclusion != null) {\n         }\n         return JsonInclude.Include.ALWAYS;\n     }\n-    \n+\n     /**\n      * Method for getting provider used for locating filters given\n      * id (which is usually provided with filter annotations).\n     public FilterProvider getFilterProvider() {\n         return _filterProvider;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Introspection methods\n     /* Debug support\n     /**********************************************************\n      */\n-    \n-    @Override public String toString()\n-    {\n+\n+    @Override\n+    public String toString() {\n         return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     /* Generic output features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that can be enabled to make root value (usually JSON\n      * Object but can be any type) wrapped within a single property\n      * method to use any <code>PrettyPrinter</code> instance.\n      * This feature will only allow using the default implementation.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is disabled by default.\n      */\n     INDENT_OUTPUT(false),\n-    \n+\n     /*\n     /******************************************************\n     /* Error handling features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that determines what happens when no accessors are\n      * found for a type (and there are no annotations to indicate\n      * @since 2.4\n      */\n     FAIL_ON_SELF_REFERENCES(true),\n-    \n+\n     /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n     /* Output life cycle features\n     /******************************************************\n      */\n-    \n+\n      /**\n       * Feature that determines whether <code>close</code> method of\n       * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n       * writeValue() (or equivalent) method is called)\n-      * that implement {@link java.io.Closeable} \n+      * that implement {@link java.io.Closeable}\n       * is called after serialization or not. If enabled, <b>close()</b> will\n       * be called after serialization completes (whether succesfully, or\n       * due to an error manifested by an exception being thrown). You can\n      * Feature is enabled by default.\n      */\n     FLUSH_AFTER_WRITE_VALUE(true),\n-     \n+\n     /*\n     /******************************************************\n     /* Datatype-specific serialization configuration\n      * Note: whether {@link java.util.Map} keys are serialized as Strings\n      * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is enabled by default, so that date/time are by default\n+     * serialized as timestamps.\n      */\n     WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+    /**\n+     * Feature that determines whether time values that represents time periods\n+     * (durations, periods, ranges) are to be serialized by default using\n+     * a numeric (true) or textual (false) representations. Note that numeric\n+     * representation may mean either simple number, or an array of numbers,\n+     * depending on type.\n+     *<p>\n+     * Note: whether {@link java.util.Map} keys are serialized as Strings\n+     * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+     *<p>\n+     * Feature is enabled by default, so that period/duration are by default\n+     * serialized as timestamps.\n+     * \n+     * @since 2.5\n+     */\n+    WRITE_DURATIONS_AS_TIMESTAMPS(true),\n \n     /**\n      * Feature that determines whether {@link java.util.Date}s\n      * Feature is disabled by default.\n      */\n     WRITE_ENUMS_USING_INDEX(false),\n-    \n+\n     /**\n      * Feature that determines whether Map entries with null values are\n      * to be serialized (true) or not (false).\n      * Feature is enabled by default.\n      */\n     WRITE_EMPTY_JSON_ARRAYS(true),\n-    \n+\n     /**\n      * Feature added for interoperability, to work with oddities of\n      * so-called \"BadgerFish\" convention.\n      * support it.\n      *<p>\n      * Feature is disabled by default.\n-     */\n+     * \n+     * @deprecated Since 2.5: use {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_BIGDECIMAL_AS_PLAIN} directly\n+     *    (using {@link ObjectWriter#with(com.fasterxml.jackson.core.JsonGenerator.Feature)}).\n+     */\n+    @Deprecated // since 2.5\n     WRITE_BIGDECIMAL_AS_PLAIN(false),\n-    \n+\n     /**\n      * Feature that controls whether numeric timestamp values are\n      * to be written using nanosecond timestamps (enabled) or not (disabled);\n      * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n      *<p>\n      * Feature is enabled by default, to support most accurate time values possible.\n-     * \n+     *\n      * @since 2.2\n      */\n-    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),    \n-    \n+    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n+\n     /**\n      * Feature that determines whether {@link java.util.Map} entries are first\n      * sorted by key before serialization or not: if enabled, additional sorting\n      * feature: only consider that if there are actual perceived problems.\n      *<p>\n      * Feature is enabled by default.\n-     * \n+     *\n      * @since 2.1\n      */\n     EAGER_SERIALIZER_FETCH(true),\n      *<p>\n      * Feature is disabled by default; meaning that strict identity is used, not\n      * <code>equals()</code>\n-     * \n+     *\n      * @since 2.3\n      */\n     USE_EQUALITY_FOR_OBJECT_ID(false)\n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private SerializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n+\n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n     }\n \n     /**\n-     * Copy-constructor used when making a {@link #copy} of a blueprint\n-     * object.\n+     * Copy-constructor used when making a copy of a blueprint instance.\n      * \n      * @since 2.4.4\n      */\n         // 25-Feb-2011, tatu: As per [JACKSON-519], need to ensure contextuality works here, too\n         return _handleContextualResolvable(ser, property);\n     }\n-    \n+\n     /*\n     /********************************************************\n     /* Accessors for specialized serializers\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+\n+/**\n+ * Annotation that may be used to add \"virtual\" properties to be written\n+ * after regular properties (although ordering may be changed using\n+ * both standard <code>@JsonPropertyOrder</code> annotation, and\n+ * properties of this annotation).\n+ * \n+ * @since 2.5\n+ */\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonAppend\n+{\n+    /**\n+     * Set of attribute-backed properties to include when serializing\n+     * a POJO.\n+     */\n+    public Attr[] attrs() default { };\n+\n+    /**\n+     * Set of general virtual properties to include when serializing a POJO.\n+     */\n+    public Prop[] props() default { };\n+\n+    /**\n+     * Indicator used to determine whether properties defined are to be\n+     * appended before (false) or prepended before (true) regular properties.\n+     * Affects all kinds of properties defined using this annotation.\n+     */\n+    public boolean prepend() default false;\n+    \n+    /**\n+     * Definition of a single attribute-backed property.\n+     * Attribute-backed properties will be appended after regular properties\n+     * in specified order, although their placement may be further changed\n+     * by the usual property-ordering functionality (alphabetic sorting;\n+     * explicit ordering)\n+     */\n+    public @interface Attr\n+    {\n+        /**\n+         * Name of attribute of which value to serialize. Is also used as the\n+         * name of external property to write, unless overridden by\n+         * assigning a value for {@link #propName()}.\n+         */\n+        public String value();\n+\n+        /**\n+         * Name to use for serializing value of the attribute; if not defined,\n+         * {@link #value} will be used instead.\n+         */\n+        public String propName() default \"\";\n+\n+        /**\n+         * Optional namespace to use; only relevant for data formats that use\n+         * namespaces (like XML).\n+         */\n+        public String propNamespace() default \"\";\n+\n+        /**\n+         * When to include attribute-property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+    }\n+    \n+    /**\n+     * Definition of a single general virtual property.\n+     */\n+    public @interface Prop\n+    {\n+        /**\n+         * Actual implementation class (a subtype of {@link VirtualBeanPropertyWriter})\n+         * of the property to instantiate (using the no-argument default constructor).\n+         */\n+        public Class<? extends VirtualBeanPropertyWriter> value();\n+\n+        /**\n+         * Name of the property to possibly use for serializing (although implementation\n+         * may choose to not use this information).\n+         */\n+        public String name() default \"\";\n+\n+        /**\n+         * Optional namespace to use along with {@link #name};\n+         * only relevant for data formats that use namespaces (like XML).\n+         */\n+        public String namespace() default \"\";\n+\n+        /**\n+         * When to include  value of the property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value. As with other properties, actual property implementation may or may\n+         * not choose to use this inclusion information.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+\n+        /**\n+         * Nominal type of the property. Passed as type information for related\n+         * virtual objects, and may (or may not be) used by implementation\n+         * for choosing serializer to use.\n+         */\n+        public Class<?> type() default Object.class;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n  * as either default or explicit values. Hence for class values we must\n  * explicitly use a bogus placeholder to denote equivalent of\n  * \"no class\" (for which 'null' is usually the natural choice).\n- * \n- * @deprecated Since 2.4 use {@link java.lang.Void} instead as the general\n- *   \"no class specified\" marker.\n+ *<p>\n+ * Note that since 2.4, most (but not all!\n+ * {@link com.fasterxml.jackson.annotation.JsonTypeInfo#defaultImpl} is\n+ * a notable exception}) usage should start using\n+ * {@link java.lang.Void} instead as the \"not defined\" marker.\n  */\n-@Deprecated\n public final class NoClass\n {\n     private NoClass() { }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n public class DeserializerFactoryConfig\n     implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 3683541151102256824L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n      * are configured and constructed.\n      */\n     protected final BeanDeserializerModifier[] _modifiers;\n-\n \n     /**\n      * List of objects that may be able to resolve abstract types to\n      * or to support post-constructor functionality.\n      */\n     protected final ValueInstantiators[] _valueInstantiators;\n-    \n+\n     /**\n      * Constructor for creating basic configuration with no additional\n      * handlers.\n         return new DeserializerFactoryConfig(all, _additionalKeyDeserializers, _modifiers,\n                 _abstractTypeResolvers, _valueInstantiators);\n     }\n+\n     /**\n      * Fluent/factory method used to construct a configuration object that\n      * has same key deserializer providers as this instance, plus one specified\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n         return null;\n     }\n \n-    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n-    {\n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n \n         return null;\n     }\n \n+    /**\n+     * Method called to construct a {@link VirtualBeanPropertyWriter} instance\n+     * of specified type.\n+     *\n+     * @since 2.5\n+     */\n+    public VirtualBeanPropertyWriter virtualPropertyWriterInstance(MapperConfig<?> config,\n+            Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n     implements ClassIntrospector.MixInResolver,\n         java.io.Serializable\n {\n-    private static final long serialVersionUID = 8891625428805876137L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     /**\n      * Set of shared mapper features enabled.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -3010349050434697698L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final JavaType _baseType;\n \n     /**********************************************************\n      */\n     \n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Finally, we may have to consider possibility of custom handlers for\n          * these values: but for now this should work ok.\n          */\n-        /* 21-Sep-2013, tatu: It may seem odd that I'm not using a switch here.\n-         *   But turns out that a switch on an enum generates an inner class...\n-         *   crazy! So this is to avoid that, simply since new class weighs about 1kB\n-         *   after compression.\n-         */\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t.isScalarValue()) {\n-            if (t == JsonToken.VALUE_STRING) {\n-                if (_acceptString) {\n-                    return jp.getText();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (_acceptInt) {\n-                    return jp.getIntValue();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                if (_acceptDouble) {\n-                    return Double.valueOf(jp.getDoubleValue());\n-                }\n-            } else if (t == JsonToken.VALUE_TRUE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.TRUE;\n-                }\n-            } else if (t == JsonToken.VALUE_FALSE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.FALSE;\n-                }\n-            }\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case JsonTokenId.ID_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case JsonTokenId.ID_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n         }\n         return null;\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n         Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n+            throw new UnresolvedForwardReference(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\", jp.getCurrentLocation(), roid);\n         }\n         return pojo;\n     }\n }\n \n+\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n         _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n         _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n \n-        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n-         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n-         *    more careful with typos, since compiler won't notice any\n-         *    problems...\n-         */\n-        _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n-        try {\n-            Class<?> key = java.util.concurrent.ConcurrentNavigableMap.class;\n-            Class<?> value = java.util.concurrent.ConcurrentSkipListMap.class;\n-            @SuppressWarnings(\"unchecked\")\n-                Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n-            _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (Throwable e) { // some class loading problems are Errors, others Exceptions\n-            System.err.println(\"Problems with (optional) types: \"+e);\n-        }\n+        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n+        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n+                java.util.concurrent.ConcurrentSkipListMap.class);\n     }\n \n     /* We do some defaulting for abstract Collection classes and\n \n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n-                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n-                Object injectId = intr.findInjectableValueId(ctor.getParameter(0));\n-\n-                if (hasExplicitName || (injectId != null)) {\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n+\n+                if (useProps) {\n                     CreatorProperty[] properties = new CreatorProperty[1];\n-                    PropertyName name = (propDef == null) ? null : propDef.getFullName();\n-                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, ctor.getParameter(0), injectId);\n+                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n+                    AnnotatedParameter arg = ctor.getParameter(0);\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n+                            intr.findInjectableValueId(arg));\n                     creators.addPropertyCreator(ctor, properties);\n                 } else {\n                     /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                             ctor, isCreator,\n                             vchecker.isCreatorVisible(ctor));\n+                    // one more thing: sever link to creator property, to avoid possible later\n+                    // problems with \"unresolved\" constructor property\n+                    if (argDef != null) {\n+                        ((POJOPropertyBuilder) argDef).removeConstructors();\n+                    }\n                 }\n                 // regardless, fully handled\n                 continue;\n         }\n     }\n \n+    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n+            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n+    {\n+        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n+\n+        if (mode == JsonCreator.Mode.PROPERTIES) {\n+            return true;\n+        }\n+        if (mode == JsonCreator.Mode.DELEGATING) {\n+            return false;\n+        }\n+        // If explicit name, or inject id, property-based\n+        if (((propDef != null) && propDef.isExplicitlyNamed())\n+                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n+            return true;\n+        }\n+        if (propDef != null) {\n+            // One more thing: if implicit name matches property with a getter\n+            // or field, we'll consider it property-based as well\n+            String implName = propDef.getName();\n+            if (implName != null && !implName.isEmpty()) {\n+                if (propDef.couldSerialize()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        // in absence of everything else, default to delegating\n+        return false;\n+    }\n+    \n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n             final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n-                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n-                final Object injectId = intr.findInjectableValueId(factory.getParameter(0));\n-                if ((injectId == null) && !hasExplicitName) { // not property based\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n+                if (!useProps) { // not property based but delegating\n                     /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                             factory, isCreator);\n                     // otherwise just ignored\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     extends BeanDeserializerBase\n     implements java.io.Serializable\n {\n+    /* TODOs for future versions:\n+     * \n+     * For 2.6\n+     * \n+     * - Start using new (2.5) methods in JsonParser, like\n+     *   * 'hasTokenId(xxx)'\n+     *   * 'nextFieldName()'\n+     *   \n+     *   for slightly more efficient property lookups, handling\n+     *   (2-3% faster deserialization)\n+     *   Not done for 2.5 since it was just introduced, trying to\n+     *   keep some level of compatibility between \"adjacent\" minor\n+     *   versions.\n+     *   Also: need to ensure efficient impl of those methods for Smile, CBOR\n+     *   at least (in addition to JSON)\n+     * \n+     */\n+\n     private static final long serialVersionUID = 1L;\n \n     /*\n      * like Afterburner change definition.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        // common case first:\n-        if (t == JsonToken.START_OBJECT) {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        // common case first\n+        if (t == JsonToken.START_OBJECT) { // TODO: in 2.6, use 'p.hasTokenId()'\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n-            }\n-            jp.nextToken();\n+                return vanillaDeserialize(p, ctxt, p.nextToken());\n+            }\n+            p.nextToken();\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        return _deserializeOther(jp, ctxt, t);\n-    }\n-\n-    protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n+        }\n+        return _deserializeOther(p, ctxt, t);\n+    }\n+\n+    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n             JsonToken t) throws IOException\n     {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n-            return deserializeFromString(jp, ctxt);\n+            return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n-            return deserializeFromNumber(jp, ctxt);\n+            return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n-\t    return deserializeFromDouble(jp, ctxt);\n+\t    return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return deserializeFromEmbedded(jp, ctxt);\n+            return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n-            return deserializeFromBoolean(jp, ctxt);\n+            return deserializeFromBoolean(p, ctxt);\n         case START_ARRAY:\n             // these only work if there's a (delegating) creator...\n-            return deserializeFromArray(jp, ctxt);\n+            return deserializeFromArray(p, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n+                return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n         default:\n             throw ctxt.mappingException(handledType());\n         }\n     }\n \n-    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser p, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(handledType());\n      * after collecting some or all of the properties to set.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         if (_unwrappedPropertyHandler != null) {\n-            return deserializeWithUnwrapped(jp, ctxt, bean);\n+            return deserializeWithUnwrapped(p, ctxt, bean);\n         }\n         if (_externalTypeIdHandler != null) {\n-            return deserializeWithExternalTypeId(jp, ctxt, bean);\n-        }\n-        JsonToken t = jp.getCurrentToken();\n+            return deserializeWithExternalTypeId(p, ctxt, bean);\n+        }\n+        JsonToken t = p.getCurrentToken();\n         // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             \n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp,\n+    private final Object vanillaDeserialize(JsonParser p,\n     \t\tDeserializationContext ctxt, JsonToken t)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                handleUnknownVanilla(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n             }\n         }\n         return bean;\n     }\n \n     /**\n-     * General version used when handling needs more advanced\n-     * features.\n+     * General version used when handling needs more advanced features.\n      */\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n+         *   to come in as JSON Objects as well; but for now assume they will\n+         *   be simple, single-property references, which means that we can\n+         *   recognize them without having to buffer anything.\n+         *   Once again, if we must, we can do more complex handling with buffering,\n+         *   but let's only do that if and when that becomes necessary.\n+         */\n+        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n+            // TODO: in 2.6, use 'p.hasTokenId()'\n+            if ((p.getCurrentTokenId() == JsonTokenId.ID_FIELD_NAME)\n+                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n+                return deserializeFromObjectId(p, ctxt);\n+            }\n+        }\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n-                return deserializeWithUnwrapped(jp, ctxt);\n+                return deserializeWithUnwrapped(p, ctxt);\n             }\n             if (_externalTypeIdHandler != null) {\n-                return deserializeWithExternalTypeId(jp, ctxt);\n-            }\n-            Object bean = deserializeFromObjectUsingNonDefault(jp, ctxt);\n+                return deserializeWithExternalTypeId(p, ctxt);\n+            }\n+            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n             if (_needViewProcesing) {\n                 Class<?> view = ctxt.getActiveView();\n                 if (view != null) {\n-                    return deserializeWithView(jp, ctxt, bean, view);\n+                    return deserializeWithView(p, ctxt, bean, view);\n                 }\n             }\n             */\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        if (jp.canReadObjectId()) {\n-            Object id = jp.getObjectId();\n+        // [databind#631]: Assign current value, to be accessible by custom deserializers\n+        p.setCurrentValue(bean);\n+        if (p.canReadObjectId()) {\n+            Object id = p.getObjectId();\n             if (id != null) {\n-                _handleTypedObjectId(jp, ctxt, bean, id);\n+                _handleTypedObjectId(p, ctxt, bean, id);\n             }\n         }\n         if (_injectables != null) {\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      */\n     @Override\n     @SuppressWarnings(\"resource\")\n-    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n         \n         // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n         TokenBuffer unknown = null;\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         bean = null; // never gets here\n                     }\n+                    if (bean == null) {\n+                        throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n+                    }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n-                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                        return handlePolymorphic(p, ctxt, bean, unknown);\n                     }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n                     }\n                     // or just clean?\n-                    return deserialize(jp, ctxt, bean);\n+                    return deserialize(p, ctxt, bean);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 continue;\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp);\n+                unknown = new TokenBuffer(p);\n             }\n             unknown.writeFieldName(propName);\n-            unknown.copyCurrentStructure(jp);\n+            unknown.copyCurrentStructure(p);\n         }\n         \n         // We hit END_OBJECT, so:\n     /**********************************************************\n      */\n     \n-    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n             Object bean, Class<?> activeView)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n                 if (!prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * which need special handling\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n-    }    \n+    }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            t = p.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            jp.nextToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            p.nextToken();\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n+                        p.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n                     }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n-                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n-        }\n-        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n     }\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n             Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        \n+        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            t = p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 // [JACKSON-831]: may have property AND be used as external type id:\n-                if (jp.getCurrentToken().isScalarValue()) {\n-                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                if (t.isScalarValue()) {\n+                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                 }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n+            handleUnknownProperty(p, ctxt, bean, propName);         \n         }\n         // and when we get this far, let's try finalizing the deal:\n-        return ext.complete(jp, ctxt, bean);\n+        return ext.complete(p, ctxt, bean);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n-                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    Object value = creatorProp.deserialize(p, ctxt);\n                     if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n                             bean = creator.build(ctxt, buffer);\n                         }\n                         // if so, need to copy all remaining tokens into buffer\n                         while (t == JsonToken.FIELD_NAME) {\n-                            jp.nextToken(); // to skip name\n-                            tokens.copyCurrentStructure(jp);\n-                            t = jp.nextToken();\n+                            p.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(p);\n+                            t = p.nextToken();\n                         }\n                         if (bean.getClass() != _beanType.getRawClass()) {\n                             // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                             //   it's too complicated, so bail out\n                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                         }\n-                        return ext.complete(jp, ctxt, bean);\n+                        return ext.complete(p, ctxt, bean);\n                     }\n                 }\n                 continue;\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n         // We hit END_OBJECT; resolve the pieces:\n         try {\n-            return ext.complete(jp, ctxt, buffer, creator);\n+            return ext.complete(p, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * General version used when handling needs more advanced\n      * features.\n      */\n-    public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException;\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n         if (_objectIdReader != null) {\n             // 05-Aug-2013, tatu: May use native Object Id\n-            if (jp.canReadObjectId()) {\n-                Object id = jp.getObjectId();\n+            if (p.canReadObjectId()) {\n+                Object id = p.getObjectId();\n                 if (id != null) {\n-                    Object ob = typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n-                    return _handleTypedObjectId(jp, ctxt, ob, id);\n+                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n+                    return _handleTypedObjectId(p, ctxt, ob, id);\n                 }\n             }\n             // or, Object Ids Jackson explicitly sets\n-            JsonToken t = jp.getCurrentToken();\n+            JsonToken t = p.getCurrentToken();\n             // for now (2.2.x) we only allow scalar types (Strings, integral numbers):\n             // NOTE: may  need to allow handling of structured values in future for JSOG\n-            if (t != null && t.isScalarValue()) {\n-                return deserializeFromObjectId(jp, ctxt);\n+            if (t != null && (t.isScalarValue() || _objectIdReader.maySerializeAsObject())) {\n+                return deserializeFromObjectId(p, ctxt);\n             }\n         }\n         // In future could check current token... for now this should be enough:\n-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n     }\n \n     /**\n      */\n     protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,\n             Object pojo, Object rawId)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         /* 07-Aug-2013, tatu: One more challenge: type of id may not be type\n          *   of property we are expecting later on; specifically, numeric ids\n     protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return deserializeFromObject(jp, ctxt);\n     }\n-    \n+\n     /**\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n \n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n             DeserializationContext ctxt) throws IOException\n-    {        \n+    {\n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n                     _delegateDeserializer.deserialize(jp, ctxt));\n                     +\" (need to add/enable type information?)\");\n         }\n         throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n-                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+                +_beanType+\": can not instantiate from JSON object (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n     }\n \n     protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,\n             }\n             return bean;\n         }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n-    }\n-\n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n+            return deserializeFromObjectId(p, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n          */\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+        return _valueInstantiator.createFromString(ctxt, p.getText());\n     }\n \n     /**\n      * number.\n      */\n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n-        switch (jp.getNumberType()) {\n+    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        switch (p.getNumberType()) {\n         case FLOAT: // no separate methods for taking float...\n         case DOUBLE:\n             if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n                     return bean;\n                 }\n             }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n         }\n         // actually, could also be BigDecimal, so:\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n+        }\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n     }\n \n     /**\n      * Method called to deserialize POJO value from a JSON boolean value (true, false)\n      */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n         return _valueInstantiator.createFromBoolean(ctxt, value);\n     }\n \n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 wrapInstantiationProblem(e, ctxt);\n             }\n         } else if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                 return null;\n             }\n-            final Object value = deserialize(jp, ctxt);\n-            if (jp.nextToken() != JsonToken.END_ARRAY) {\n-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n+            final Object value = deserialize(p, ctxt);\n+            if (p.nextToken() != JsonToken.END_ARRAY) {\n+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                         \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n             }\n             return value;\n         } else if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY) {\n                 return null;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, \"cause\");\n+            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n+                    new PropertyName(\"cause\"));\n             SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                     am.getGenericParameterType(0));\n             if (prop != null) {\n         if (typeStr != null) {\n             throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n         }\n-    \treturn true;\n+        return true;\n     }\n \n     /**\n             Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n     {\n         Boolean status = ignoredTypes.get(type);\n-        if (status == null) {\n-            BeanDescription desc = config.introspectClassAnnotations(type);\n-            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n-            // We default to 'false', ie. not ignorable\n-            if (status == null) {\n-                status = Boolean.FALSE;\n-            }\n-        }\n-        return status;\n+        if (status != null) {\n+            return status.booleanValue();\n+        }\n+        BeanDescription desc = config.introspectClassAnnotations(type);\n+        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n+        // We default to 'false', i.e. not ignorable\n+        return (status == null) ? false : status.booleanValue(); \n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n         final int len = _readers.length;\n         ObjectReader[] r = new ObjectReader[len];\n         for (int i = 0; i < len; ++i) {\n-            r[i] = _readers[i].withType(type);\n+            r[i] = _readers[i].forType(type);\n         }\n         return new DataFormatReaders(r, _optimalMatch, _minimalMatch, _maxInputLookahead);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.NoClassDefFoundDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.type.*;\n     /**\n      * We will also cache some dynamically constructed deserializers;\n      * specifically, ones that are expensive to construct.\n-     * This currently means bean and Enum deserializers; array, List and Map\n-     * deserializers will not be cached.\n+     * This currently means bean and Enum deserializers; starting with\n+     * 2.5, container deserializers will also be cached.\n      *<p>\n      * Given that we don't expect much concurrency for additions\n      * (should very quickly converge to zero after startup), let's\n-     * explicitly define a low concurrency setting.\n+     * define a relatively low concurrency setting.\n      */\n     final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n-        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n \n     /**\n      * During deserializer construction process we may need to keep track of partially\n         if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n             type = factory.mapAbstractType(config, type);\n         }\n-        BeanDescription beanDesc = config.introspect(type);\n+        BeanDescription beanDesc;\n+        try {\n+            beanDesc = config.introspect(type);\n+        } catch (NoClassDefFoundError error) {\n+            return new NoClassDefFoundDeserializer<Object>(error);\n+        }\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                 beanDesc.getClassInfo());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n      */\n \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-            throws IOException\n+        throws IOException\n     {\n         try {\n             return _buildMethod.getMember().invoke(builder);\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        if (!p.isExpectedStartArrayToken()) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(p, ctxt));\n         }\n         if (!_vanillaProcessing) {\n-            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+            return finishBuild(ctxt, _deserializeNonVanilla(p, ctxt));\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object builder)\n+        throws IOException\n     {\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * \n      * @return Builder object in use.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         if (_injectables != null) {\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return builder;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                        prop.deserializeSetAndReturn(p, ctxt, builder);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, builder, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return builder;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n             final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object builder = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (builder != null) {\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         builder = creator.build(ctxt, buffer);\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n import java.util.HashSet;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n      */\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return _deserializeFromNonArray(jp, ctxt);\n+        if (!p.isExpectedStartArrayToken()) {\n+            return _deserializeFromNonArray(p, ctxt);\n         }\n         if (!_vanillaProcessing) {\n-            return _deserializeNonVanilla(jp, ctxt);\n+            return _deserializeNonVanilla(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n          */\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * Alternate deserialization method that has to check many more configuration\n      * aspects than the \"vanilla\" processing.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeAndSet(jp, ctxt, bean);\n+                        prop.deserializeAndSet(p, ctxt, bean);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object bean = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (bean != null) {\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+                    \n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n     /**********************************************************\n      */\n \n-    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected Object _deserializeFromNonArray(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's start with failure\n         throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n-                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\") from non-Array representation (token: \"+p.getCurrentToken()\n                 +\"): type/property designed to be serialized as JSON Array\");\n         // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n         //return _delegate.deserialize(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n+import java.io.IOException;\n import java.util.*;\n \n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key) throws IOException\n+    {\n+        int index = key.hashCode() & _hashMask;\n+        Bucket bucket = _buckets[index];\n+        // Let's unroll first lookup since that is null or match in 90+% cases\n+        if (bucket == null) {\n+            return false;\n+        }\n+        // Primarily we do just identity comparison as keys should be interned\n+        if (bucket.key == key) {\n+            bucket.value.deserializeAndSet(p, ctxt, bean);\n+            return true;\n+        }\n+        return _findDeserializeAndSet2(p, ctxt, bean, key, index);\n+    }\n+\n+    private final boolean _findDeserializeAndSet2(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key, int index) throws IOException\n+    {\n+        Bucket bucket = _buckets[index];\n+        while ((bucket = bucket.next) != null) {\n+            if (bucket.key == key) {\n+                bucket.value.deserializeAndSet(p, ctxt, bean);\n+                return true;\n+            }\n+        }\n+        SettableBeanProperty prop = _findWithEquals(key, index);\n+        if (prop == null) {\n+            return false;\n+        }\n+        prop.deserializeAndSet(p, ctxt, bean);\n+        return true;\n+    }\n+\n+    /**\n      * @since 2.3\n      */\n     public SettableBeanProperty find(int propertyIndex)\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * A deserializer that stores a {@link NoClassDefFoundError} error\n+ * and throws the stored exception when attempting to deserialize\n+ * a value. Null and empty values can be deserialized without error.\n+ */\n+public class NoClassDefFoundDeserializer<T> extends JsonDeserializer<T>\n+{\n+    private final NoClassDefFoundError _cause;\n+\n+    public NoClassDefFoundDeserializer(NoClassDefFoundError cause)\n+    {\n+        _cause = cause;\n+    }\n+\n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        throw _cause;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n-\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n     public JavaType getIdType() {\n         return _idType;\n     }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.maySerializeAsObject();\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean maySerializeAsObject() {\n+        return generator.maySerializeAsObject();\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.isValidReferencePropertyName(name, parser);\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isValidReferencePropertyName(String name, JsonParser parser) {\n+        return generator.isValidReferencePropertyName(name, parser);\n+    }\n     \n     /**\n      * Method called to read value that is expected to be an Object Reference\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n \n     protected final ObjectIdReader _objectIdReader;\n \n-    @Deprecated // since 2.2\n-    public ObjectIdValueProperty(ObjectIdReader objectIdReader) {\n-        this(objectIdReader, PropertyMetadata.STD_REQUIRED);\n-    }\n-    \n     public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n             PropertyMetadata metadata)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n     extends ContainerDeserializerBase<Collection<Object>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3917273725180652224L;\n+    private static final long serialVersionUID = -1L; // since 2.5\n \n     // // Configuration\n \n                 (JsonDeserializer<Object>) vd, vtd,\n                 _valueInstantiator, (JsonDeserializer<Object>) dd);\n     }\n-    \n+\n+    // Important: do NOT cache if polymorphic values\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return (_valueTypeDeserializer == null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing (ResolvableDeserializer)\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         /* [JACKSON-620]: empty String may be ok; bit tricky to check, however, since\n          *  there is also possibility of \"auto-wrapping\" of single-element arrays.\n          *  Hence we only accept empty String here.\n          */\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            String str = jp.getText();\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String str = p.getText();\n             if (str.length() == 0) {\n                 return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n             }\n         }\n-        return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n-    }\n-\n-    @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n+    }\n+\n+    @Override\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return handleNonArray(jp, ctxt, result);\n-        }\n+        if (!p.isExpectedStartArrayToken()) {\n+            return handleNonArray(p, ctxt, result);\n+        }\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n                 new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n             try {\n                 Object value;\n                 if (t == JsonToken.VALUE_NULL) {\n                     value = valueDes.getNullValue();\n                 } else if (typeDeser == null) {\n-                    value = valueDes.deserialize(jp, ctxt);\n+                    value = valueDes.deserialize(p, ctxt);\n                 } else {\n-                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                 }\n                 if (referringAccumulator != null) {\n                     referringAccumulator.add(value);\n             } catch (UnresolvedForwardReference reference) {\n                 if (referringAccumulator == null) {\n                     throw JsonMappingException\n-                            .from(jp, \"Unresolved forward reference but no identity info\", reference);\n+                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n-    protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n \n         Object value;\n \n             if (t == JsonToken.VALUE_NULL) {\n                 value = valueDes.getNullValue();\n             } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n+                value = valueDes.deserialize(p, ctxt);\n             } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n             }\n         } catch (Exception e) {\n             // note: pass Object.class, not Object[].class, as we need element type for error info\n         private final CollectionReferringAccumulator _parent;\n         public final List<Object> next = new ArrayList<Object>();\n         \n-        private CollectionReferring(CollectionReferringAccumulator parent,\n+        CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n         {\n             super(reference, contentType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n     /* Overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public SettableBeanProperty findBackReference(String refName) {\n         JsonDeserializer<Object> valueDeser = getContentDeserializer();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n      * let's cache instances by default.\n      */\n     @Override\n-    public boolean isCachable() { return true; }\n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_valueTypeDeserializer == null);\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n     extends StdDeserializer<EnumSet<?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3479455075597887177L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final JavaType _enumType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n     public BaseNodeDeserializer(Class<T> vc) {\n         super(vc);\n     }\n-    \n+\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     /*\n     /**********************************************************\n     /* Overridable methods\n     /**********************************************************\n      */\n-    \n+\n     protected void _reportProblem(JsonParser jp, String msg) throws JsonMappingException {\n         throw new JsonMappingException(msg, jp.getTokenLocation());\n     }\n-    \n+\n     /**\n      * \n      * @deprecated Since 2.3, use the overloaded variant\n         // Backwards-compatibility; call in case it's overloaded\n         _handleDuplicateField(fieldName, objectNode, oldValue, newValue);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n-    \n+\n     protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ObjectNode node = nodeFactory.objectNode();\n         JsonToken t = jp.getCurrentToken();\n         }\n         return node;\n     }\n-    \n+\n     protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ArrayNode node = nodeFactory.arrayNode();\n         while (true) {\n             }\n         }\n     }\n-    \n+\n     protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         switch (jp.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n     }\n \n     protected final JsonNode _fromInt(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_INTEGER\n     }\n \n     protected final JsonNode _fromFloat(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)\n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_DECIMAL\n     }\n \n     protected final JsonNode _fromEmbedded(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         // [JACKSON-796]\n         Object ob = jp.getEmbeddedObject();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         return ((rawKeyType == String.class || rawKeyType == Object.class)\n                 && isDefaultKeyDeserializer(keyDeser));\n     }\n-    \n+\n     public void setIgnorableProperties(String[] ignorable) {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n             null : ArrayBuilders.arrayToSet(ignorable);\n     /**********************************************************\n      */\n \n+    /**\n+     * Turns out that these are expensive enough to create so that caching\n+     * does make sense.\n+     *<p>\n+     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n+     * a value type deserializer; this caused an issue with 2.4.4 of\n+     * JAXB Annotations (failing a test).\n+     * It is also possible that some other settings could make deserializers\n+     * un-cacheable; but on the other hand, caching can make a big positive\n+     * difference with performance... so it's a hard choice.\n+     * \n+     * @since 2.4.4\n+     */\n+    @Override\n+    public boolean isCachable() {\n+        return (_valueTypeDeserializer == null) && (_ignorableProperties == null);\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n     }\n \n     @Override\n-    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public Map<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Map<Object,Object> result)\n-        throws IOException, JsonProcessingException\n-    {\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n+        \n         // Ok: must point to START_OBJECT or FIELD_NAME\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             throw ctxt.mappingException(getMapClass());\n         }\n         if (_standardStringKey) {\n-            _readAndBindStringMap(jp, ctxt, result);\n+            _readAndBindStringMap(p, ctxt, result);\n             return result;\n         }\n-        _readAndBind(jp, ctxt, result);\n+        _readAndBind(p, ctxt, result);\n         return result;\n     }\n \n             }\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\") \n     public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n         wrapAndThrow(t, ref, null);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n-            UnresolvedForwardReference reference)\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n+            Object key, UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n         if (accumulator == null) {\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final static class MapReferringAccumulator  {\n+    private final static class MapReferringAccumulator {\n         private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class MapReferring extends Referring {\n+    final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n \n         public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n         public final Object key;\n         \n-        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n     /**\n      * Key deserializer to use; either passed via constructor\n      * (when indicated by annotations), or resolved when\n-     * {@link #resolve} is called;\n+     * {@link #createContextual} is called;\n      */\n     protected final KeyDeserializer _keyDeserializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n-        private final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n+        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n+        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n         \n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n-        private final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n+        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n+        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n         \n         public ByteDeserializer(Class<Byte> cls, Byte nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n-        private final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n+        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n+        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n         \n         public ShortDeserializer(Class<Short> cls, Short nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n-        private final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n+        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n+        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n         \n         public CharacterDeserializer(Class<Character> cls, Character nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n-        private final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n+        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n+        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n         \n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n-        private final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n+        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n+        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n         \n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n-        private final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n+        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n+        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n         \n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n-        private final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n+        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n+        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n         \n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n             elemTypeDeser = elemTypeDeser.forProperty(property);\n         }\n         return withDeserializer(elemTypeDeser, deser);\n+    }\n+\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_elementTypeDeserializer == null);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n  *<p>\n  * Note that although types (delegate, target) may be related, they must not be same; trying\n  * to do this will result in an exception.\n+ *<p>\n+ * Since 2.5 There is {@link StdNodeBasedDeserializer} that is a simplified version\n+ * for cases where intermediate type is {@link JsonNode}\n  * \n  * @param <T> Target type to convert to, from delegate type\n  * \n  * @since 2.1\n+ * \n+ * @see StdNodeBasedDeserializer\n+ * @see Converter\n  */\n public class StdDelegatingDeserializer<T>\n     extends StdDeserializer<T>\n     private static final long serialVersionUID = 1L;\n \n     protected final Converter<Object,T> _converter;\n-    \n+\n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n     protected final JavaType _delegateType;\n-    \n+\n     /**\n      * Underlying serializer for type <code>T<.code>.\n      */\n     protected final JsonDeserializer<Object> _delegateDeserializer;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _delegateType = null;\n         _delegateDeserializer = null;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public StdDelegatingDeserializer(Converter<Object,T> converter,\n             JavaType delegateType, JsonDeserializer<?> delegateDeserializer)\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    protected StdDelegatingDeserializer(StdDelegatingDeserializer<T> src)\n+    {\n+        super(src);\n+        _converter = src._converter;\n+        _delegateType = src._delegateType;\n+        _delegateDeserializer = src._delegateDeserializer;\n+    }\n+\n+    /**\n      * Method used for creating resolved contextual instances. Must be\n      * overridden when sub-classing.\n      */\n             ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt);\n         }\n     }\n-    \n+\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n         throws JsonMappingException\n     public Class<?> handledType() {\n         return _delegateDeserializer.handledType();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Serialization\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         _valueClass = (valueType == null) ? null : valueType.getRawClass();\n     }\n \n+    /**\n+     * Copy-constructor for sub-classes to use, most often when creating\n+     * new instances for {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     * \n+     * @since 2.5\n+     */\n+    protected StdDeserializer(StdDeserializer<?> src) {\n+        _valueClass = src._valueClass;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Accessors\n             }\n             throw ctxt.weirdStringException(text, _valueClass, \"only \\\"true\\\" or \\\"false\\\" recognized\");\n         }\n-        // Issue#381\n+        // [databind#381]\n         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final boolean parsed = _parseBooleanPrimitive(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URL;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.Locale;\n     public final static int TYPE_DATE = 10;\n     public final static int TYPE_CALENDAR = 11;\n     public final static int TYPE_UUID = 12;\n+    public final static int TYPE_URI = 13;\n+    public final static int TYPE_URL = 14;\n+    public final static int TYPE_CLASS = 15;\n \n     final protected int _kind;\n     final protected Class<?> _keyClass;\n             kind = TYPE_FLOAT;\n         } else if (raw == Double.class) {\n             kind = TYPE_DOUBLE;\n+        } else if (raw == URI.class) {\n+            kind = TYPE_URI;\n+        } else if (raw == URL.class) {\n+            kind = TYPE_URL;\n+        } else if (raw == Class.class) {\n+            kind = TYPE_CLASS;\n         } else if (raw == Locale.class) {\n             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n             return (date == null)  ? null : ctxt.constructCalendar(date);\n         case TYPE_UUID:\n             return UUID.fromString(key);\n+        case TYPE_URI:\n+            return URI.create(key);\n+        case TYPE_URL:\n+            return new URL(key);\n+        case TYPE_CLASS:\n+            try {\n+                return ctxt.findClass(key);\n+            } catch (Exception e) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as Class\");\n+            }\n         }\n         return null;\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdNodeBasedDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Convenience deserializer that may be used to deserialize values given an\n+ * intermediate tree representation ({@link JsonNode}).\n+ * Note that this is a slightly simplified alternative to {@link StdDelegatingDeserializer}).\n+ *\n+ * @param <T> Target type of this deserializer; that is, type of values that\n+ *   input data is deserialized into.\n+ * \n+ * @since 2.5\n+ */\n+public abstract class StdNodeBasedDeserializer<T>\n+    extends StdDeserializer<T>\n+    implements ResolvableDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected JsonDeserializer<Object> _treeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected StdNodeBasedDeserializer(JavaType targetType) {\n+        super(targetType);\n+    }\n+\n+    protected StdNodeBasedDeserializer(Class<T> targetType) {\n+        super(targetType);\n+    }\n+\n+    /**\n+     * \"Copy-constructor\" used when creating a modified copies, most often\n+     * if sub-class implements {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     */\n+    protected StdNodeBasedDeserializer(StdNodeBasedDeserializer<?> src) {\n+        super(src);\n+        _treeDeserializer = src._treeDeserializer;\n+    }\n+\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n+        _treeDeserializer = ctxt.findRootValueDeserializer(ctxt.constructType(JsonNode.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    public abstract T convert(JsonNode root, DeserializationContext ctxt) throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+        JsonNode n = (JsonNode) _treeDeserializer.deserialize(jp, ctxt);\n+        return convert(n, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer td)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 19-Nov-2014, tatu: Quite likely we'd have some issues but... let's\n+         *   try, just in case.\n+         */\n+        JsonNode n = (JsonNode) _treeDeserializer.deserializeWithType(jp, ctxt, td);\n+        return convert(n, ctxt);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n \n     protected StdScalarDeserializer(Class<?> vc) { super(vc); }\n     protected StdScalarDeserializer(JavaType valueType) { super(valueType); }\n+\n+    // since 2.5\n+    protected StdScalarDeserializer(StdScalarDeserializer<?> src) { super(src); }\n     \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n                 _valueInstantiator, delegateDeser, valueDeser);\n     }\n \n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return true;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Validation, post-processing\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n         _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Initialization\n      * to: it can not be done earlier since delegated deserializers almost\n      * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         JavaType obType = ctxt.constructType(Object.class);\n         JavaType stringType = ctxt.constructType(String.class);\n         TypeFactory tf = ctxt.getTypeFactory();\n+\n+        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n+         *    should always be called separately, from within \"createContextual()\".\n+         *    But this is a very singular deserializer since it operates on `Object`\n+         *    (and often for `?` type parameter), and as a result, easily and commonly\n+         *    results in cycles, being value deserializer for various Maps and Collections.\n+         *    Because of this, we must somehow break the cycles. This is done here by\n+         *    forcing pseudo-contextualization with null property.\n+         */\n+\n+        // So: first find possible custom instances\n         _mapDeserializer = _findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType));\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n         _numberDeserializer = _findCustomDeser(ctxt, tf.constructType(Number.class));\n+\n+        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n+        // their own\n+        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);\n+        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);\n+        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);\n+        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        // NOTE: since we don't yet have the referring property, this should be fine:\n-        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n+        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n+        // contextualization will only occur at a later point\n+        JsonDeserializer<?> deser = ctxt.findNonContextualValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n-    \n+\n+    /**\n+     * We only use contextualization for optimizing the case where no customization\n+     * occurred; if so, can slip in a more streamlined version.\n+     */\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n         }\n-        JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n-        if (mapDeserializer instanceof ContextualDeserializer) {\n-            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> listDeserializer = _listDeserializer;\n-        if (listDeserializer instanceof ContextualDeserializer) {\n-            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> stringDeserializer = _stringDeserializer;\n-        if (stringDeserializer instanceof ContextualDeserializer) {\n-            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> numberDeserializer = _numberDeserializer;\n-        if (numberDeserializer instanceof ContextualDeserializer) {\n-            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);\n-        }\n-\n-        // And if anything changed, we'll need to change too!\n-        if ((mapDeserializer != _mapDeserializer)\n-                || (listDeserializer != _listDeserializer)\n-                || (stringDeserializer != _stringDeserializer)\n-                || (numberDeserializer != _numberDeserializer)\n-                ) {\n-            return _withResolved(mapDeserializer, listDeserializer,\n-                    stringDeserializer, numberDeserializer);\n-        }\n         return this;\n     }\n \n     /* Deserializer API\n     /**********************************************************\n      */\n-    \n+\n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n     extends AnnotatedMember\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Actual {@link Field} used for access.\n      * Temporary field required for JDK serialization support\n      */\n     protected Serialization _serialization;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n     extends Annotated\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     // Transient since information not needed after construction, so\n     // no need to persist\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n     public final AnnotationMap getParameterAnnotations(int index)\n     {\n         if (_paramAnnotations != null) {\n-            if (index >= 0 && index <= _paramAnnotations.length) {\n+            if (index >= 0 && index < _paramAnnotations.length) {\n                 return _paramAnnotations[index];\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n import java.util.Collection;\n import java.util.List;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n         Boolean r = _primary.findSerializationSortAlphabetically(ann);\n         return (r == null) ? _secondary.findSerializationSortAlphabetically(ann) : r;\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        // first secondary, then primary, to give proper precedence\n+        _primary.findAndAddVirtualProperties(config, ac, properties);\n+        _secondary.findAndAddVirtualProperties(config, ac, properties);\n+    }\n+\n     // // // Serialization: property annotations\n     \n     @Override\n         return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n     }\n \n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator.Mode mode = _primary.findCreatorBinding(a);\n+        if (mode != null) {\n+            return mode;\n+        }\n+        return _secondary.findCreatorBinding(a);\n+    }\n+    \n     protected boolean _isExplicitClassOrOb(Object maybeCls, Class<?> implicit) {\n         if (maybeCls == null) {\n             return false;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n     @Override\n     public ObjectIdInfo getObjectIdInfo() { return  _objectIdInfo; }\n-    \n+\n     @Override\n     public List<BeanPropertyDefinition> findProperties() {\n         return _properties;\n         }\n         return _ignoredPropertyNames;\n     }\n-    \n+\n     @Override\n     public boolean hasKnownClassAnnotations() {\n         return _classInfo.hasAnnotations();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n \n import java.util.Iterator;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n import com.fasterxml.jackson.databind.util.Named;\n \n     @Deprecated // since 2.3\n     public BeanPropertyDefinition withName(String newName) { return withSimpleName(newName); }\n-    \n+\n     /**\n      * Method that can be used to create a definition with\n      * same settings as this one, but with different\n      * @since 2.3\n      */\n     public abstract BeanPropertyDefinition withSimpleName(String newSimpleName);\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic property information, name, type\n \n     /**\n      * Method for accessing additional metadata.\n-     * NOTE: will never return null, so deferencing return value\n+     * NOTE: will never return null, so de-referencing return value\n      * is safe.\n      * \n      * @since 2.3\n      * Method used to find the property member (getter, setter, field) that has\n      * the highest precedence in current context (getter method when serializing,\n      * if available, and so forth), if any.\n+     *<p>\n+     * Note: abstract since 2.5\n      * \n      * @since 2.1\n      */\n-    public AnnotatedMember getPrimaryMember() { return null; }\n+    public abstract AnnotatedMember getPrimaryMember();\n     \n     /*\n     /**********************************************************\n      * fail deserialization), or handled by other means (by providing default\n      * value)\n      */\n-    public final boolean isRequired() {\n+    public boolean isRequired() {\n         PropertyMetadata md = getMetadata();\n         return (md != null)  && md.isRequired();\n     }\n+\n+    /**\n+     * Method used to check if this property has specific inclusion override\n+     * associated with it or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findInclusion() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * {@link AnnotationIntrospector} implementation that handles standard\n      * are considered bundles.\n      */\n     @Override\n-    public boolean isAnnotationBundle(Annotation ann)\n-    {\n+    public boolean isAnnotationBundle(Annotation ann) {\n         return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* General annotations\n \n     // default impl is fine:\n     //public String findEnumValue(Enum<?> value) { return value.name(); }\n-    \n+\n     /*\n     /**********************************************************\n     /* General class annotations\n         JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n+        if (ann == null) {\n+            return;\n+        }\n+        final boolean prepend = ann.prepend();\n+        JavaType propType = null;\n+\n+        // First: any attribute-backed properties?\n+        JsonAppend.Attr[] attrs = ann.attrs();\n+        for (int i = 0, len = attrs.length; i < len; ++i) {\n+            if (propType == null) {\n+                propType = config.constructType(Object.class);\n+            }\n+            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n+                    config, ac, propType);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+\n+        // Then: general-purpose virtual properties?\n+        JsonAppend.Prop[] props = ann.props();\n+        for (int i = 0, len = props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n+                    config, ac);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n+            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n+    {\n+        PropertyMetadata metadata = attr.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        // could add Index, Description in future, if those matter\n+        String attrName = attr.value();\n+\n+        // allow explicit renaming; if none, default to attribute name\n+        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n+        if (!propName.hasSimpleName()) {\n+            propName = new PropertyName(attrName);\n+        }\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                attrName, type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, attr.include());\n+        // can construct the property writer\n+        return AttributePropertyWriter.construct(attrName, propDef,\n+                ac.getAnnotations(), type);\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n+            MapperConfig<?> config, AnnotatedClass ac)\n+    {\n+        PropertyMetadata metadata = prop.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n+        JavaType type = config.constructType(prop.type());\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                propName.getSimpleName(), type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, prop.include());\n+\n+        Class<?> implClass = prop.value();\n+\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n+                : hi.virtualPropertyWriterInstance(config, implClass);\n+        if (bpw == null) {\n+            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n+                    config.canOverrideAccessModifiers());\n+        }\n+\n+        // one more thing: give it necessary contextual information\n+        return bpw.withConfig(config, ac, propDef, type);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Serialization: property annotations\n          */\n         return _hasAnnotation(a, JsonCreator.class);\n     }\n-    \n+\n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n+        return (ann == null) ? null : ann.mode();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n         cls = _classIfExplicit(cls);\n         return (cls == null || cls == implicit) ? null : cls;\n     }\n-    \n+\n+    protected PropertyName _propertyName(String localName, String namespace) {\n+        if (localName.isEmpty()) {\n+            return PropertyName.USE_DEFAULT;\n+        }\n+        if (namespace == null || namespace.isEmpty()) {\n+            return new PropertyName(localName);\n+        }\n+        return new PropertyName(localName, namespace);\n+    }\n+\n     /**\n      * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n      * if given annotated element indicates one is needed.\n         b = b.inclusion(inclusion);\n         b = b.typeProperty(info.property());\n         Class<?> defaultImpl = info.defaultImpl();\n-        if (defaultImpl != JsonTypeInfo.None.class) {\n+\n+        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n+        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n+        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n+        //   valid use (can not instantiate as default)\n+        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n             b = b.defaultImpl(defaultImpl);\n         }\n         b = b.typeIdVisibility(info.visible());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n         @Override\n         public Version version() {\n             return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n-       }\n+        }\n     };\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n \n     protected Linked<AnnotatedMethod> _setters;\n \n-    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai, boolean forSerialization) {\n+    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai,\n+            boolean forSerialization) {\n         this(internalName, internalName, ai, forSerialization);\n     }\n \n             }\n         });\n     }\n-    \n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        if (_annotationIntrospector == null) {\n+            return null;\n+        }\n+        AnnotatedMember am = getAccessor();\n+        return _annotationIntrospector.findSerializationInclusion(am, null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Data aggregation\n         }\n     }\n \n+    /**\n+     * Mutator that will simply drop any constructor parameters property may have.\n+     * \n+     * @since 2.5\n+     */\n+    public void removeConstructors() {\n+        _ctorParameters = null;\n+    }\n+    \n     /**\n      * Method called to trim unnecessary entries, such as implicit\n      * getter if there is an explict one available. This is important\n          * Method called to append given node(s) at the end of this\n          * node chain.\n          */\n-        private Linked<T> append(Linked<T> appendable) {\n+        protected Linked<T> append(Linked<T> appendable) {\n             if (next == null) {\n                 return withNext(appendable);\n             }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+\n+/**\n+ * Placeholder used by virtual properties as placeholder for\n+ * underlying {@link AnnotatedMember}.\n+ * \n+ * @since 2.5\n+ */\n+public class VirtualAnnotatedMember extends AnnotatedMember\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final Class<?> _declaringClass;\n+\n+    protected final Class<?> _rawType;\n+\n+    protected final String _name;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public VirtualAnnotatedMember(Class<?> declaringClass, String name, Class<?> rawType)\n+    {\n+        super(/* AnnotationMap*/ null);\n+        _declaringClass = declaringClass;\n+        _rawType = rawType;\n+        _name = name;\n+    }\n+\n+    @Override\n+    public Annotated withAnnotations(AnnotationMap fallback) {\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Field getAnnotated() { return null; }\n+\n+    @Override\n+    public int getModifiers() { return 0; }\n+\n+    @Override\n+    public String getName() { return _name; }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _rawType;\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _rawType;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _declaringClass; }\n+\n+    @Override\n+    public Member getMember() { return null; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not set virtual property '\"+_name+\"'\");\n+    }\n+\n+    @Override\n+    public Object getValue(Object pojo) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not get virtual property '\"+_name+\"'\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, generic\n+    /**********************************************************\n+     */\n+\n+    public String getFullName() {\n+        return getDeclaringClass().getName() + \"#\" + getName();\n+    }\n+\n+    public int getAnnotationCount() { return 0; }\n+\n+    @Override\n+    public int hashCode() {\n+        return _name.hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        VirtualAnnotatedMember other = (VirtualAnnotatedMember) o;\n+        return (other._declaringClass == _declaringClass)\n+                && other._name.equals(_name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[field \"+getFullName()+\"]\";\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n package com.fasterxml.jackson.databind.jsontype;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n      * available for some reason.\n      */\n     public String idFromBaseType();\n-    \n+\n+    /**\n+     * @deprecated since 2.5; call {@link #typeFromId(DatabindContext, String)} instead\n+     */\n+    @Deprecated // since 2.4\n+    public JavaType typeFromId(String id);\n+\n     /**\n      * Method called to resolve type from given type identifier.\n+     * \n+     * @since 2.5 -- but since 2.3 has existed in {@link com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase}\n      */\n-    public JavaType typeFromId(String id);\n+    public JavaType typeFromId(DatabindContext context, String id);\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n                  * for base class, not via interface. Later on we can add this\n                  * to the interface, assuming deprecation at base class helps.\n                  */\n-                JavaType type;\n-                if (_idResolver instanceof TypeIdResolverBase) {\n-                    type = ((TypeIdResolverBase) _idResolver).typeFromId(ctxt, typeId);\n-                } else {\n-                    type = _idResolver.typeFromId(typeId);\n-                }\n+                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n                 if (type == null) {\n                     // As per [JACKSON-614], use the default impl if no type id available:\n                     deser = _findDefaultImplDeserializer(ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n      */\n     @Deprecated\n     @Override\n-    public abstract JavaType typeFromId(String id);\n+    public JavaType typeFromId(String id) {\n+        return typeFromId(null, id);\n+    }\n \n     /**\n      * New method, replacement for {@link #typeFromId(String)}, which is given\n      * \n      * @since 2.3\n      */\n+    @Override\n     public JavaType typeFromId(DatabindContext context, String id) {\n         return typeFromId(id);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n     protected String idFromValue(Object value) {\n         String id = _idResolver.idFromValue(value);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n     protected String idFromValueAndType(Object value, Class<?> type) {\n         String id = _idResolver.idFromValueAndType(value, type);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n+\n+    // As per [databind#633], maybe better just not do anything...\n+    protected void handleMissingId(Object value) {\n+        /*\n+        String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n+        throw new IllegalArgumentException(\"Can not resolve type id for \"\n+                +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+                */\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n import java.util.Map;\n \n import com.fasterxml.jackson.core.Version;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n     extends Module\n     implements java.io.Serializable\n {\n-    // at 2.4.0:\n-    private static final long serialVersionUID = -8905749147637667249L;\n+    private static final long serialVersionUID = 1L; // 2.5.0\n \n     protected final String _name;\n     protected final Version _version;\n      * use actual name and version number information.\n      */\n     public SimpleModule() {\n-        // when passing 'this', can not chain constructors...\n-        _name = \"SimpleModule-\"+System.identityHashCode(this);\n+        // can't chain when making reference to 'this'\n+        // note: generate different name for direct instantiation, sub-classing\n+        _name = (getClass() == SimpleModule.class) ?\n+                \"SimpleModule-\"+System.identityHashCode(this)\n+                : getClass().getName();\n         _version = Version.unknownVersion();\n     }\n     \n             _serializers = new SimpleSerializers(serializers);\n         }\n     }\n+\n+    /**\n+     * Since instances are likely to be custom, implementation returns\n+     * <code>null</code> if (but only if!) this class is directly instantiated;\n+     * but class name (default impl) for sub-classes.\n+     */\n+    @Override\n+    public Object getTypeId() {\n+        if (getClass() == SimpleModule.class) {\n+            return null;\n+        }\n+        return super.getTypeId();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     protected JsonNode _at(JsonPointer ptr) {\n         return get(ptr.getMatchingIndex());\n     }\n-    \n+\n     // note: co-variant to allow caller-side type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     protected boolean _childrenEqual(ArrayNode other) {\n         return _children.equals(other._children);\n     }\n-    \n+\n     @Override\n     public int hashCode() {\n         return _children.hashCode();\n     }\n-\n \n     @Override\n     public String toString()\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     }\n-    \n+\n     /**\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 64-bit integer value\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n      * Current field name\n      */\n     protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected java.lang.Object _currentValue;\n     \n     public NodeCursor(int contextType, NodeCursor p)\n     {\n     public void overrideCurrentName(String name) {\n         _currentName = name;\n     }\n+\n+    @Override\n+    public java.lang.Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(java.lang.Object v) {\n+        _currentValue = v;\n+    }\n     \n     /*\n     /**********************************************************\n         JsonNode n = currentNode();\n         if (n == null) throw new IllegalStateException(\"No current node\");\n         if (n.isArray()) { // false since we have already returned START_ARRAY\n-            return new Array(n, this);\n+            return new ArrayCursor(n, this);\n         }\n         if (n.isObject()) {\n-            return new Object(n, this);\n+            return new ObjectCursor(n, this);\n         }\n         throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n     }\n      * than JSON Object and Array).\n      * Note that context is NOT created for leaf values.\n      */\n-    protected final static class RootValue\n+    protected final static class RootCursor\n         extends NodeCursor\n     {\n         protected JsonNode _node;\n \n         protected boolean _done = false;\n \n-        public RootValue(JsonNode n, NodeCursor p) {\n+        public RootCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ROOT, p);\n             _node = n;\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Array nodes\n      */\n-    protected final static class Array\n+    protected final static class ArrayCursor\n         extends NodeCursor\n     {\n         protected Iterator<JsonNode> _contents;\n \n         protected JsonNode _currentNode;\n \n-        public Array(JsonNode n, NodeCursor p) {\n+        public ArrayCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ARRAY, p);\n             _contents = n.elements();\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Object nodes\n      */\n-    protected final static class Object\n+    protected final static class ObjectCursor\n         extends NodeCursor\n     {\n         protected Iterator<Map.Entry<String, JsonNode>> _contents;\n \n         protected boolean _needEntry;\n         \n-        public Object(JsonNode n, NodeCursor p)\n+        public ObjectCursor(JsonNode n, NodeCursor p)\n         {\n             super(JsonStreamContext.TYPE_OBJECT, p);\n             _contents = ((ObjectNode) n).fields();\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(int)}, and may be\n+     *  \"smaller\" (like {@link ShortNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     }\n \n     /**\n-     * Alternative method that we need to avoid bumping into NPE issues\n-     * with auto-unboxing.\n+     * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(Long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n+     * <p>\n+     * Note that this is alternative to {@link #put(String, long)} needed to avoid\n+     * bumping into NPE issues with auto-unboxing.\n      * \n      * @return This node (to allow chaining)\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n         _objectCodec = codec;\n         if (n.isArray()) {\n             _nextToken = JsonToken.START_ARRAY;\n-            _nodeCursor = new NodeCursor.Array(n, null);\n+            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n         } else if (n.isObject()) {\n             _nextToken = JsonToken.START_OBJECT;\n-            _nodeCursor = new NodeCursor.Object(n, null);\n+            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n         } else { // value node\n-            _nodeCursor = new NodeCursor.RootValue(n, null);\n+            _nodeCursor = new NodeCursor.RootCursor(n, null);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = NumberSerializer.instance;\n-        _concrete.put(BigInteger.class.getName(), ns);\n-        _concrete.put(BigDecimal.class.getName(), ns);\n+        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n+        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n \n         // Other discrete non-container types:\n         // First, Date/Time zoo:\n             if (ser != null) { break; }\n         }\n         if (ser == null) {\n-            if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n+            // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n+            /*\n+            if (EnumMap.class.isAssignableFrom(type.getRawClass())\n+                    && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                 JavaType keyType = type.getKeyType();\n                 // Need to find key enum values...\n                 EnumValues enums = null;\n                 ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                     elementTypeSerializer, elementValueSerializer);\n             } else {\n-                Object filterId = findFilterId(config, beanDesc);\n-                MapSerializer mapSer = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+            */\n+            Object filterId = findFilterId(config, beanDesc);\n+            MapSerializer mapSer = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n                     type, staticTyping, elementTypeSerializer,\n                     keySerializer, elementValueSerializer, filterId);\n-                Object suppressableValue = findSuppressableContentValue(config,\n-                        type.getContentType(), beanDesc);\n-                if (suppressableValue != null) {\n-                    mapSer = mapSer.withContentInclusion(suppressableValue);\n-                }\n-                ser = mapSer;\n-            }\n+            Object suppressableValue = findSuppressableContentValue(config,\n+                    type.getContentType(), beanDesc);\n+            if (suppressableValue != null) {\n+                mapSer = mapSer.withContentInclusion(suppressableValue);\n+            }\n+            ser = mapSer;\n         }\n         // [Issue#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n      * under which value for the property is written.\n      *<p>\n      * NOTE: do NOT change name of this field; it is accessed by\n-     * Afterburner module.\n+     * Afterburner module (until 2.4; not directly from 2.5)\n      * ALSO NOTE: ... and while it really ought to be `SerializableString`,\n      * changing that is also binary-incompatible change. So nope.\n      */\n     {\n         _member = member;\n         _contextAnnotations = contextAnnotations;\n+\n         _name = new SerializedString(propDef.getName());\n         _wrapperName = propDef.getWrapperName();\n+        _metadata = propDef.getMetadata();\n+        _includeInViews = propDef.findViews();\n+\n         _declaredType = declaredType;\n         _serializer = (JsonSerializer<Object>) ser;\n         _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n         _typeSerializer = typeSer;\n         _cfgSerializationType = serType;\n-        _metadata = propDef.getMetadata();\n \n         if (member instanceof AnnotatedField) {\n             _accessorMethod = null;\n             _accessorMethod = (Method) member.getMember();\n             _field = null;\n         } else {\n-            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n+            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props\n+            _accessorMethod = null;\n+            _field = null;\n         }\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n-        _includeInViews = propDef.findViews();\n \n         // this will be resolved later on, unless nulls are to be suppressed\n         _nullSerializer = null;\n     }\n \n     /**\n+     * Constructor that may be of use to virtual properties, when there is need for\n+     * the zero-arg (\"default\") constructor, and actual initialization is done\n+     * after constructor call.\n+     * \n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter() {\n+        _member = null;\n+        _contextAnnotations = null;\n+\n+        _name = null;\n+        _wrapperName = null;\n+        _metadata = null;\n+        _includeInViews = null;\n+\n+        _declaredType = null;\n+        _serializer = null;\n+        _dynamicSerializers = null;\n+        _typeSerializer = null;\n+        _cfgSerializationType = null;\n+\n+        _accessorMethod = null;\n+        _field = null;\n+        _suppressNulls = false;\n+        _suppressableValue = null;\n+\n+        _nullSerializer = null;\n+    }\n+\n+    /**\n      * \"Copy constructor\" to be used by filtering sub-classes\n      */\n     protected BeanPropertyWriter(BeanPropertyWriter base) {\n         this(base, base._name);\n     }\n \n-    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n-        _name = name;\n+    /**\n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)\n+    {\n+        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency\n+         *   to MapperConfig to encode, and Afterburner having heartburn\n+         *   for SerializableString (vs SerializedString).\n+         *   Hope it can be resolved/reworker in 2.6 timeframe, if not for 2.5\n+         */\n+        _name = new SerializedString(name.getSimpleName());\n         _wrapperName = base._wrapperName;\n \n         _member = base._member;\n         _metadata = base._metadata;\n     }\n \n+    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n+        _name = name;\n+        _wrapperName = base._wrapperName;\n+\n+        _member = base._member;\n+        _contextAnnotations = base._contextAnnotations;\n+        _declaredType = base._declaredType;\n+        _accessorMethod = base._accessorMethod;\n+        _field = base._field;\n+        _serializer = base._serializer;\n+        _nullSerializer = base._nullSerializer;\n+        // one more thing: copy internal settings, if any (since 1.7)\n+        if (base._internalSettings != null) {\n+            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n+        }\n+        _cfgSerializationType = base._cfgSerializationType;\n+        _dynamicSerializers = base._dynamicSerializers;\n+        _suppressNulls = base._suppressNulls;\n+        _suppressableValue = base._suppressableValue;\n+        _includeInViews = base._includeInViews;\n+        _typeSerializer = base._typeSerializer;\n+        _nonTrivialBaseType = base._nonTrivialBaseType;\n+        _metadata = base._metadata;\n+    }\n+\n     public BeanPropertyWriter rename(NameTransformer transformer) {\n         String newName = transformer.transform(_name.getValue());\n         if (newName.equals(_name.toString())) {\n             return this;\n         }\n-        return new BeanPropertyWriter(this, new SerializedString(newName));\n+        return new BeanPropertyWriter(this, new PropertyName(newName));\n     }\n     \n     /**\n     // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-        return _member.getAnnotation(acls);\n+        return (_member == null) ? null : _member.getAnnotation(acls);\n     }\n \n     // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n-        return _contextAnnotations.get(acls);\n+        return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n     }\n \n     @Override public AnnotatedMember getMember() { return _member; }\n     protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode) {\n         propertiesNode.set(getName(), schemaNode);\n     }\n+\n+    /**\n+     * Note: will be defined in {@link BeanProperty}; as of now is not yet.\n+     *<p>\n+     * TODO: move to {@link BeanProperty} in near future, once all standard\n+     * implementations define it.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isVirtual() { return false; }\n     \n     /*\n     /**********************************************************\n         if (_accessorMethod != null) {\n             return _accessorMethod.getGenericReturnType();\n         }\n-        return _field.getGenericType();\n+        if (_field != null) {\n+            return _field.getGenericType();\n+        }\n+        return null;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n         sb.append(\"property '\").append(getName()).append(\"' (\");\n         if (_accessorMethod != null) {\n             sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n+        } else if (_field != null) {\n+            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n         } else {\n-            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n+            sb.append(\"virtual\");\n         }\n         if (_serializer == null) {\n             sb.append(\", no static serializer\");\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, true);\n+            _serializeWithObjectId(bean, gen, provider, true);\n             return;\n         }\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n         } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFields(bean, gen, provider);\n         }\n-        jgen.writeEndObject();\n+        gen.writeEndObject();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         final SerializationConfig config = prov.getConfig();\n         BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n         builder.setConfig(config);\n-        \n+\n         // First: any detectable (auto-detect, annotations) properties to serialize?\n         List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n         if (props == null) {\n             props = new ArrayList<BeanPropertyWriter>();\n         }\n+        // [databind#638]: Allow injection of \"virtual\" properties:\n+        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n+\n         // [JACKSON-440] Need to allow modification bean properties to serialize:\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 props = mod.changeProperties(config, beanDesc, props);\n             }\n         }\n-        \n+\n         // Any properties to suppress?\n         props = filterBeanProperties(config, beanDesc, props);\n-        \n+\n         // [JACKSON-440] Need to allow reordering of properties to serialize\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n \n     /**\n      * Method that will apply by-type limitations (as per [JACKSON-429]);\n-     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType} annotation but\n-     * can be supplied by module-provided introspectors too.\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n+     * annotation but can be supplied by module-provided introspectors too.\n      */\n     protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n     {\n         if (property != null) {\n             AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-            if (intr != null) {\n-                if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) {\n+            AnnotatedMember m = property.getMember();\n+            if ((m != null) && (intr != null)) {\n+                if (intr.findSerializationContentType(m, property.getType()) != null) {\n                     return true;\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n {\n     final protected SerializationConfig _config;\n     final protected BeanDescription _beanDesc;\n-    final protected JsonInclude.Include _outputProps;\n+\n+    /**\n+     * Default inclusion mode for properties of the POJO for which\n+     * properties are collected; possibly overridden on\n+     * per-property basis.\n+     */\n+    final protected JsonInclude.Include _defaultInclusion;\n \n     final protected AnnotationIntrospector _annotationIntrospector;\n \n     {\n         _config = config;\n         _beanDesc = beanDesc;\n-        _outputProps = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n+        _defaultInclusion = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n         _annotationIntrospector = _config.getAnnotationIntrospector();\n     }\n \n         Object valueToSuppress = null;\n         boolean suppressNulls = false;\n \n-        JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps);\n-        if (methodProps != null) {\n-            switch (methodProps) {\n+        JsonInclude.Include inclusion = propDef.findInclusion();\n+        if (inclusion == null) {\n+            inclusion = _defaultInclusion;\n+        }\n+        if (inclusion != null) {\n+            switch (inclusion) {\n             case NON_DEFAULT:\n                 valueToSuppress = getDefaultValue(propDef.getName(), am);\n                 if (valueToSuppress == null) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link BeanPropertyWriter} implementation used with\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend}\n+ * to add \"virtual\" properties in addition to regular ones.\n+ * \n+ * @since 2.5\n+ * \n+ * @see com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter\n+ */\n+public abstract class VirtualBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /**\n+     * Constructor used by most sub-types.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType)\n+    {\n+        this(propDef, contextAnnotations, declaredType, null, null, null,\n+                propDef.findInclusion());\n+    }\n+\n+    /**\n+     * Constructor that may be used by sub-classes for constructing a \"blue-print\" instance;\n+     * one that will only become (or create) actual usable instance when its\n+     * {@link #withConfig} method is called.\n+     */\n+    protected VirtualBeanPropertyWriter() {\n+        super();\n+    }\n+\n+    /**\n+     * Pass-through constructor that may be used by sub-classes that\n+     * want full control over implementation.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, propDef.getPrimaryMember(), contextAnnotations, declaredType,\n+                ser, typeSer, serType,\n+                _suppressNulls(inclusion), _suppressableValue(inclusion));\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base) {\n+        super(base);\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base, PropertyName name) {\n+        super(base, name);\n+    }\n+\n+    protected static boolean _suppressNulls(JsonInclude.Include inclusion) {\n+        return (inclusion != JsonInclude.Include.ALWAYS);\n+    }\n+\n+    protected static Object _suppressableValue(JsonInclude.Include inclusion) {\n+        if ((inclusion == JsonInclude.Include.NON_EMPTY)\n+                || (inclusion == JsonInclude.Include.NON_EMPTY)) {\n+            return MARKER_FOR_EMPTY;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard accessor overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isVirtual() { return true; }\n+\n+    @Override\n+    public Class<?> getPropertyType() {\n+        return _declaredType.getRawClass();\n+    }\n+\n+    @Override\n+    public Type getGenericPropertyType() {\n+        return getPropertyType();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes to define\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to figure out the value to serialize. For simple sub-types\n+     * (such as {@link com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter})\n+     * this may be one of few methods to define, although more advanced implementations\n+     * may choose to not even use this method (by overriding {@link #serializeAsField})\n+     * and define a bogus implementation.\n+     */\n+    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;\n+\n+    /**\n+     * Contextualization method called on a newly constructed virtual bean property.\n+     * Usually a new intance needs to be created due to finality of some of configuration\n+     * members; otherwise while recommended, creating a new instance is not strictly-speaking\n+     * mandatory because calls are made in thread-safe manner, as part of initialization\n+     * before use.\n+     *\n+     * @param config Currenct configuration; guaranteed to be {@link SerializationConfig}\n+     *   (just not typed since caller does not have dependency to serialization-specific types)\n+     * @param declaringClass Class that contains this property writer\n+     * @param propDef Nominal property definition to use\n+     * @param type Declared type for the property\n+     */\n+    public abstract VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type);\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyWriter serialization method overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                gen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, gen, prov);\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap m = _dynamicSerializers;\n+            ser = m.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(m, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        if (value == bean) { // simple check for direct cycles\n+            // three choices: exception; handled by call; or pass-through\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        gen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    \n+    @Override\n+    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, gen, prov);\n+            } else {\n+                gen.writeNull();\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    serializeAsPlaceholder(bean, gen, prov);\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                serializeAsPlaceholder(bean, gen, prov);\n+                return;\n+            }\n+        }\n+        if (value == bean) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link VirtualBeanPropertyWriter} implementation used for\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend},\n+ * to serialize properties backed-by dynamically assignable attribute\n+ * values.\n+ * \n+ * @since 2.5\n+ */\n+public class AttributePropertyWriter\n+    extends VirtualBeanPropertyWriter\n+{\n+    protected final String _attrName;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType) {\n+        this(attrName, propDef, contextAnnotations, declaredType, propDef.findInclusion());\n+    }\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, contextAnnotations, declaredType,\n+                /* value serializer */ null, /* type serializer */ null, /* ser type */ null,\n+                inclusion);\n+        _attrName = attrName;\n+    }\n+\n+    public static AttributePropertyWriter construct(String attrName,\n+            BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations,\n+            JavaType declaredType)\n+    {\n+        return new AttributePropertyWriter(attrName, propDef,\n+                contextAnnotations, declaredType);\n+    }\n+    \n+    protected AttributePropertyWriter(AttributePropertyWriter base) {\n+        super(base);\n+        _attrName = base._attrName;\n+    }\n+\n+    /**\n+     * Since this method should typically not be called on this sub-type,\n+     * default implementation simply throws an {@link IllegalStateException}.\n+     */\n+    @Override\n+    public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type) {\n+        throw new IllegalStateException(\"Should not be called on this type\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for actual serialization, value access\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception {\n+        return prov.getAttribute(_attrName);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n     /**********************************************************\n      */\n \n-    // Re-defined from base class...\n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    // Re-defined from base class, due to differing prefixes\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n-        /* Should not even get here; but let's be nice and re-route\n-         * if need be.\n+        /* 10-Dec-2014, tatu: Not sure if this can be made to work reliably;\n+         *   but for sure delegating to default implementation will not work. So:\n          */\n-        _defaultSerializer.serializeWithType(bean, jgen, provider, typeSer);\n-    }\n-    \n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n+            return;\n+        }\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n+        if (typeStr == null) {\n+            typeSer.writeTypePrefixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForArray(bean, gen, typeStr);\n+        }\n+        serializeAsArray(bean, gen, provider);\n+        if (typeStr == null) {\n+            typeSer.writeTypeSuffixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForArray(bean, gen, typeStr);\n+        }\n+    }\n+\n     /**\n      * Main serialization method that will delegate actual output to\n      * configured\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(provider)) {\n-            serializeAsArray(bean, jgen, provider);\n+            serializeAsArray(bean, gen, provider);\n             return;\n         }\n         /* note: it is assumed here that limitations (type id, object id,\n          * any getter, filtering) have already been checked; so code here\n          * is trivial.\n          */\n-        jgen.writeStartArray();\n-        serializeAsArray(bean, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n+        serializeAsArray(bean, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     /*\n         return props.length == 1;\n     }\n \n-    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected final void serializeAsArray(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             for (final int len = props.length; i < len; ++i) {\n                 BeanPropertyWriter prop = props[i];\n                 if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n-                    jgen.writeNull();\n+                    gen.writeNull();\n                 } else {\n-                    prop.serializeAsElement(bean, jgen, provider);\n+                    prop.serializeAsElement(bean, gen, provider);\n                 }\n             }\n             // NOTE: any getters can not be supported either\n             //if (_anyGetterWriter != null) {\n-            //    _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            //    _anyGetterWriter.getAndSerialize(bean, gen, provider);\n             //}\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n      */\n \n     @Override\n-    public void serialize(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer) throws IOException\n     {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n     extends FilterProvider\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.3.0\n-    private static final long serialVersionUID = -6305772546718366447L;\n+    // for 2.5+\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Mappings from ids to filters.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n     // at least if they can provide access to actual size of value and use `writeStartArray()`\n     // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     @Override\n-    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n     }\n     \n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     // at least if they can provide access to actual size of value and use `writeStartArray()`\n     // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n-    }\n-\n-    @Override\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer) throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n-    protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n+    }\n+\n+    protected abstract void serializeContents(T value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException;\n \n     @SuppressWarnings(\"deprecation\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n      * reference to that member.\n      */\n     final protected AnnotatedMember _typeId;\n-    \n+\n     /**\n      * If this POJO can be alternatively serialized using just an object id\n      * to denote a reference to previously serialized object,\n      * Requested shape from bean class annotations.\n      */\n     final protected JsonFormat.Shape _serializationShape;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n     {\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null) {\n-            Object convDef = intr.findSerializationConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n-                return new StdDelegatingSerializer(conv, delegateType, ser);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                    return new StdDelegatingSerializer(conv, delegateType, ser);\n+                }\n             }\n         }\n         return null;\n     // Main serialization method left unimplemented\n     @Override\n     public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     // Type-info-augmented case implemented as it does not usually differ between impls\n     @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n             return;\n         }\n \n-        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n         if (typeStr == null) {\n-            typeSer.writeTypePrefixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypePrefixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForObject(bean, gen, typeStr);\n         }\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n+        } else {\n+            serializeFields(bean, gen, provider);\n         }\n         if (typeStr == null) {\n-            typeSer.writeTypeSuffixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypeSuffixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForObject(bean, gen, typeStr);\n         }\n     }\n \n         }\n     }\n     \n-    private final String _customTypeId(Object bean)\n+    protected final String _customTypeId(Object bean)\n     {\n         final Object typeId = _typeId.getValue(bean);\n         if (typeId == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n  * Specialized serializer for {@link EnumMap}s. Somewhat tricky to\n  * implement because actual Enum value type may not be available;\n  * and if not, it can only be gotten from actual instance.\n+ * \n+ * @deprecated Since 2.4.4; standard {@link MapSerializer} works better.\n+ *   (to be removed from 2.6)\n  */\n @JacksonStdImpl\n+@Deprecated\n public class EnumMapSerializer\n     extends ContainerSerializer<EnumMap<? extends Enum<?>, ?>>\n     implements ContextualSerializer\n         }\n     }\n     \n-    @SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+    @SuppressWarnings({ \"unchecked\" })\n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n         throws JsonMappingException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(visitor.getProvider())) {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) { // typically serialized as a small number (byte or int)\n                 v2.numberType(JsonParser.NumberType.INT);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n      * Key serializer to use, if it can be statically determined\n      */\n     protected JsonSerializer<Object> _keySerializer;\n-    \n+\n     /**\n      * Value serializer to use, if it can be statically determined\n      */\n \n     /**\n      * Value that indicates suppression mechanism to use; either one of\n-     * values of {@link JsonInclude.Include}, or actual object to compare\n+     * values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include}, or actual object to compare\n      * against (\"default value\")\n      * \n      * @since 2.5\n      */\n     protected final Object _suppressableValue;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n-            Object filterId = intr.findFilterId(property.getMember());\n-            if (filterId != null) {\n-                mser = mser.withFilterId(filterId);\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                Object filterId = intr.findFilterId(m);\n+                if (filterId != null) {\n+                    mser = mser.withFilterId(filterId);\n+                }\n             }\n         }\n         return mser;\n      */\n \n     @Override\n-    public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n             Object suppressableValue = _suppressableValue;\n             if (suppressableValue == null) {\n                 value = _orderEntries(value);\n             }\n             if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n+                serializeFilteredFields(value, gen, provider,\n                         findPropertyFilter(provider, _filterId, value), suppressableValue);\n             } else if (suppressableValue != null) {\n-                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException\n     {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n             Object suppressableValue = _suppressableValue;\n             if (suppressableValue == null) {\n                 value = _orderEntries(value);\n             }\n             if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n+                serializeFilteredFields(value, gen, provider,\n                         findPropertyFilter(provider, _filterId, value), suppressableValue);\n             } else if (suppressableValue != null) {\n-                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     /*\n      * Method called to serialize fields, when the value type is not statically known;\n      * but we know that no value suppression is needed (which simplifies processing a bit)\n      */\n-    public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serializeFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider, null);\n+            serializeTypedFields(value, gen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n             } else {\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n \n             // And then value\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 Class<?> cc = valueElem.getClass();\n                 JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n                     serializers = _dynamicValueSerializers;\n                 }\n                 try {\n-                    serializer.serialize(valueElem, jgen, provider);\n+                    serializer.serialize(valueElem, gen, provider);\n                 } catch (Exception e) {\n                     // Add reference information\n                     String keyDesc = \"\"+keyElem;\n         }\n     }\n \n-    public void serializeOptionalFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             Object suppressableValue)\n         throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider, suppressableValue);\n+            serializeTypedFields(value, gen, provider, suppressableValue);\n             return;\n         }\n         final HashSet<String> ignored = _ignoredEntries;\n             }\n             // and then serialize, if all went well\n             try {\n-                keySerializer.serialize(keyElem, jgen, provider);\n-                valueSer.serialize(valueElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n+                valueSer.serialize(valueElem, gen, provider);\n             } catch (Exception e) {\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n      * so that value serializer is passed and does not need to be fetched from\n      * provider.\n      */\n-    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n         throws IOException\n     {\n             if (ignored != null && ignored.contains(keyElem)) continue;\n \n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n             final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 try {\n                     if (typeSer == null) {\n-                        ser.serialize(valueElem, jgen, provider);\n+                        ser.serialize(valueElem, gen, provider);\n                     } else {\n-                        ser.serializeWithType(valueElem, jgen, provider, typeSer);\n+                        ser.serializeWithType(valueElem, gen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n                     String keyDesc = \"\"+keyElem;\n      * \n      * @since 2.5\n      */\n-    public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             PropertyFilter filter,\n             Object suppressableValue) // since 2.5\n         throws IOException\n             // and with that, ask filter to handle it\n             prop.reset(keyElem, keySerializer, valueSer);\n             try {\n-                filter.serializeAsField(valueElem, jgen, provider, prop);\n+                filter.serializeAsField(valueElem, gen, provider, prop);\n             } catch (Exception e) {\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n         serializeTypedFields(value, gen, provider,\n                 provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Schema related functionality\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n \n /**\n  * like {@link BigInteger} and {@link BigDecimal}.\n  */\n @JacksonStdImpl\n-public final class NumberSerializer\n+public class NumberSerializer\n     extends StdScalarSerializer<Number>\n {\n-    public final static NumberSerializer instance = new NumberSerializer();\n+    /**\n+     * Static instance that is only to be used for {@link java.lang.Number}.\n+     */\n+    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n \n-    public NumberSerializer() { super(Number.class); }\n+    protected final boolean _isInt;\n+\n+    @Deprecated // since 2.5\n+    public NumberSerializer() {\n+        super(Number.class);\n+        _isInt = false;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public NumberSerializer(Class<? extends Number> rawType) {\n+        super(rawType, false);\n+        // since this will NOT be constructed for Integer or Long, only case is:\n+        _isInt = (rawType == BigInteger.class);\n+    }\n \n     @Override\n     public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n+        // should mostly come in as one of these two:\n         if (value instanceof BigDecimal) {\n             jgen.writeNumber((BigDecimal) value);\n         } else if (value instanceof BigInteger) {\n \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-        return createSchemaNode(\"number\", true);\n+        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n-        // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n-        // to ensure no information is lost? But probably won't work that well...\n-        JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-        if (v2 != null) {\n-            v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+        if (_isInt) {\n+            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+            if (v2 != null) {\n+                v2.numberType(JsonParser.NumberType.BIG_INTEGER);\n+            }\n+        } else {\n+            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+            if (v2 != null) {\n+                Class<?> h = handledType();\n+                if (h == BigDecimal.class) {\n+                    v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+                } // otherwise it's for Number... anything we could do there?\n+            }\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n     {\n         protected final JsonParser.NumberType _numberType;\n         protected final String _schemaType;\n+        protected final boolean _isInt;\n \n         protected Base(Class<T> cls, JsonParser.NumberType numberType, String schemaType) {\n             super(cls);\n             _numberType = numberType;\n             _schemaType = schemaType;\n+            _isInt = (numberType == JsonParser.NumberType.INT)\n+                    || (numberType == JsonParser.NumberType.LONG)\n+                    || (numberType == JsonParser.NumberType.BIG_INTEGER)\n+                    ;\n         }\n \n         @Override\n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(_numberType);\n+            if (_isInt) {\n+                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+                if (v2 != null) {\n+                    v2.numberType(_numberType);\n+                }\n+            } else {\n+                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+                if (v2 != null) {\n+                    v2.numberType(_numberType);\n+                }\n             }\n         }\n \n                 BeanProperty property) throws JsonMappingException\n         {\n             if (property != null) {\n-                JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n-                if (format != null) {\n-                    switch (format.getShape()) {\n-                    case STRING:\n-                        return ToStringSerializer.instance;\n-                    default:\n+                AnnotatedMember m = property.getMember();\n+                if (m != null) {\n+                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);\n+                    if (format != null) {\n+                        switch (format.getShape()) {\n+                        case STRING:\n+                            return ToStringSerializer.instance;\n+                        default:\n+                        }\n                     }\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n  *<p>\n  * Note that although types may be related, they must not be same; trying\n  * to do this will result in an exception.\n- * \n+ *\n  * @since 2.1\n  */\n public class StdDelegatingSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n \n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n-            Object convDef = intr.findSerializationContentConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                if (existingSerializer == null) {\n-                    existingSerializer = provider.findValueSerializer(delegateType);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationContentConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    if (existingSerializer == null) {\n+                        existingSerializer = provider.findValueSerializer(delegateType);\n+                    }\n+                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                 }\n-                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n             }\n         }\n         return existingSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n      * @param parametrized Type-erased type of instance being constructed\n      * @param parametersFor class or interface for which type parameters are applied; either\n      *   <code>parametrized</code> or one of its supertypes\n-     * @parameterClasses Type parameters to apply\n+     * @param parameterClasses Type parameters to apply\n      * \n      * @since 2.5\n      */\n      * @param parametrized Actual full type\n      * @param parametersFor class or interface for which type parameters are applied; either\n      *   <code>parametrized</code> or one of its supertypes\n-     * @parameterClasses Type parameters to apply\n+     * @param parameterTypes Type parameters to apply\n      * \n      * @since 2.5\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n import java.util.Collections;\n import java.util.Iterator;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n import com.fasterxml.jackson.databind.PropertyName;\n      * Member that defines logical property. Assumption is that it\n      * should be a 'simple' accessor; meaning a zero-argument getter,\n      * single-argument setter or constructor parameter.\n+     *<p>\n+     * NOTE: for \"virtual\" properties, this is null.\n      */\n     protected final AnnotatedMember _member;\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyMetadata _metadata;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyName _fullName;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final JsonInclude.Include _inclusion;\n+    \n+    /**\n+     * @deprecated Since 2.5 use <code>_fullName</code> instead.\n+     */\n+    @Deprecated\n     protected final String _name;\n     \n     /*\n      */\n     @Deprecated\n     public SimpleBeanPropertyDefinition(AnnotatedMember member, String name) {\n-        this(member, name, null);\n-    }\n-    \n-    private SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n-    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), null, null, null);\n+    }\n+\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, PropertyName fullName,\n+            AnnotationIntrospector intr, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion)\n+    {\n         _introspector = intr;\n         _member = member;\n-        _name = name;\n+        _fullName = fullName;\n+        _name = fullName.getSimpleName();\n+        _metadata = (metadata == null) ? PropertyMetadata.STD_OPTIONAL: metadata;\n+        _inclusion = inclusion;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 Use variant that takes PropertyName\n+     */\n+    @Deprecated\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n+    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), intr, null, null);\n     }\n \n     /**\n      */\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member) {\n-        return new SimpleBeanPropertyDefinition(member, member.getName(),\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n-    \n-    /**\n-     * @since 2.2\n-     */\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(member.getName()),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.5\n+     */\n+    @Deprecated\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member, String name) {\n-        return new SimpleBeanPropertyDefinition(member, name,\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(name),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name) {\n+        return construct(config, member, name, null, null);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion) {\n+          return new SimpleBeanPropertyDefinition(member, name,\n+                  (config == null) ? null : config.getAnnotationIntrospector(),\n+                          metadata, inclusion);\n+      }\n     \n     /*\n     /**********************************************************\n \n     @Deprecated // since 2.3\n     @Override\n-    public SimpleBeanPropertyDefinition withName(String newName) {\n+    public BeanPropertyDefinition withName(String newName) {\n         return withSimpleName(newName);\n     }\n \n     @Override\n-    public SimpleBeanPropertyDefinition withSimpleName(String newName) {\n-        if (_name.equals(newName)) {\n+    public BeanPropertyDefinition withSimpleName(String newName) {\n+        if (_fullName.hasSimpleName(newName) && !_fullName.hasNamespace()) {\n             return this;\n         }\n-        return new SimpleBeanPropertyDefinition(_member, newName, _introspector);\n-    }\n-\n-    @Override\n-    public SimpleBeanPropertyDefinition withName(PropertyName newName) {\n-        return withSimpleName(newName.getSimpleName());\n+        return new SimpleBeanPropertyDefinition(_member, new PropertyName(newName),\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    @Override\n+    public BeanPropertyDefinition withName(PropertyName newName) {\n+        if (_fullName.equals(newName)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, newName,\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withMetadata(PropertyMetadata metadata) {\n+        if (metadata.equals(_metadata)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withInclusion(JsonInclude.Include inclusion) {\n+        if (_inclusion == inclusion) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, _metadata, inclusion);\n     }\n     \n     /*\n      */\n \n     @Override\n-    public String getName() { return _name; }\n-\n-    @Override\n-    public PropertyName getFullName() { return new PropertyName(_name); }\n-    \n+    public String getName() { return _fullName.getSimpleName(); }\n+\n+    @Override\n+    public PropertyName getFullName() { return _fullName; }\n+\n     @Override\n     public String getInternalName() { return getName(); }\n \n     @Override\n     public PropertyName getWrapperName() {\n-        return (_introspector == null) ? null : _introspector.findWrapperName(_member);\n-    }\n-    \n+        return ((_introspector == null) && (_member != null))\n+                ? null : _introspector.findWrapperName(_member);\n+    }\n+\n     // hmmh. what should we claim here?\n \n     @Override public boolean isExplicitlyIncluded() { return false; }\n      */\n     @Override\n     public PropertyMetadata getMetadata() {\n-        return PropertyMetadata.STD_OPTIONAL;\n-    }\n-    \n+        return _metadata;\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        return _inclusion;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to accessors (fields, methods etc)\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n     {\n         return readAndMapFromString(SHARED_MAPPER, input, cls);\n     }\n-    \n-    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n-        throws IOException\n+\n+    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls) throws IOException\n     {\n         return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n     }\n     /* Helper methods, other\n     /**********************************************************\n      */\n-    \n+\n     protected TimeZone getUTCTimeZone() {\n         return TimeZone.getTimeZone(\"GMT\");\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringReader.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringReader\n+    extends FilterReader\n+{\n+    final String _message;\n+\n+    public BrokenStringReader(String content, String msg)\n+    {\n+        super(new StringReader(content));\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public int read(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        int i = super.read(cbuf, off, len);\n+        if (i < 0) {\n+            throw new IOException(_message);\n+        }\n+        return i;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringWriter\n+    extends FilterWriter\n+{\n+    final String _message;\n+\n+    public BrokenStringWriter(String msg) {\n+        super(new StringWriter());\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n         StringReader r = new StringReader(\"{}\");\n         //  bit ugly, but can't think of cleaner simple way to check this...\n         try {\n-            mapper.reader(s).withType(Object.class).readValue(r);\n+            mapper.reader(s).forType(Object.class).readValue(r);\n             fail(\"Excpected exception\");\n         } catch (SchemaException e) {\n             assertSame(s, e._schema);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestHandlerInstantiation extends BaseMapTest\n     }\n     \n     // copied from \"TestCustomTypeIdResolver\"\n-    static class CustomIdResolver implements TypeIdResolver\n+    static class CustomIdResolver extends TypeIdResolverBase\n     {\n         static List<JavaType> initTypes;\n \n             }\n         }\n         @Override\n-        public JavaType typeFromId(String id)\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (id.equals(_id)) {\n                 return TypeFactory.defaultInstance().constructType(TypeIdBean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n {\n     static class MyPojo {\n         public int x;\n-        private int y;\n+        protected int y;\n         \n         public MyPojo() { }\n         public MyPojo(int x0, int y0) {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.node.*;\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper m = new ObjectMapper();\n+        final String JSON = \"{ \\\"x\\\" : 3 }\";\n \n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(JSON, Bean.class);\n         assertNotNull(bean);\n         assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n         m._deserializationContext._cache.flushCachedDeserializers();\n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+\n+        // 07-Nov-2014, tatu: As per [databind#604] verify that Maps also get cached\n+        m = new ObjectMapper();\n+        List<?> stuff = m.readValue(\"[ ]\", List.class);\n+        assertNotNull(stuff);\n+        // may look odd, but due to \"Untyped\" deserializer thing, we actually have\n+        // 3 deserializers (List<?>, Map<?,?>, Object)\n+        assertEquals(3, m._deserializationContext._cache.cachedDeserializersCount());\n     }\n     \n     // [Issue#28]: ObjectMapper.copy()\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n         THIS_IS_AN_ENUM_VALUE_3,\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObjectBase\n+    static class FixtureObjectBase\n     {\n         public static final String       VALUE_STRING = \"foobar\";\n         public static final EFixtureEnum VALUE_ENUM   = EFixtureEnum.THIS_IS_AN_ENUM_VALUE_2;\n         }\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObject extends FixtureObjectBase\n-    {\n-        public Exception getTestError()\n-        {\n+    static class FixtureObject extends FixtureObjectBase\n+    {\n+        public Exception getTestError() {\n             return new Exception(VALUE_ERRTXT);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n-        assertEquals(quote(\"\\\\u0101\"), mapper.writeValueAsString(String.valueOf((char) 257)));\n+        mapper.writeValueAsString(String.valueOf((char) 257));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n \n     static class Bean {\n         public int a;\n-    }\n-    \n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests; root-level value sequences via Mapper\n     public void testRootBeans() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n-\n-        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n         assertTrue(it.hasNext());\n         Bean b = it.next();\n         assertEquals(3, b.a);\n         b = it.next();\n         assertEquals(27, b.a);\n         assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(3, set.iterator().next().a);\n     }\n \n     public void testRootMaps() throws Exception\n             +\"{\\\"boy\\\": \\\"howdy\\\", \\\"huh\\\": \\\"what\\\"}]\";\n         final MappingIterator<Map<String, Object>> iterator = MAPPER\n                 .reader()\n-                .withType(new TypeReference<Map<String, Object>>(){})\n+                .forType(new TypeReference<Map<String, Object>>(){})\n                 .readValues(JSON);\n \n         Map<String,Object> map;\n--- a/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n         }\n     }\n \n-    private static class PrivateThing\n+    static class PrivateThing\n     {\n         @JsonAnyGetter\n         public Map<?,?> getProperties()\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n         mapper.registerModule(module);\n         Map<String,Object> input = new HashMap<String,Object>();\n         input.put(\"a\", Integer.valueOf(3));\n-        String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n+        String json = mapper.writerFor(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n             .writeValueAsString(input);\n         assertEquals(\"{\\\"prefix:a\\\":3}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n \n public class SingleArgCreatorTest extends BaseMapTest\n {\n-    // [Issue#430]: single arg BUT named; should not delegate\n+    // [databind#430]: single arg BUT named; should not delegate\n \n     static class SingleNamedStringBean {\n-\n         final String _ss;\n \n         @JsonCreator\n         public String getSs() { return _ss; }\n     }\n \n-    // [Databind#557]\n+    // For [databind#614]\n+    static class SingleNamedButStillDelegating {\n+        protected final String value;\n+\n+        @JsonCreator(mode=JsonCreator.Mode.DELEGATING)\n+        public SingleNamedButStillDelegating(@JsonProperty(\"foobar\") String v){\n+            value = v;\n+        }\n+\n+        public String getFoobar() { return \"x\"; }\n+    }\n+    \n+    // [databind#557]\n     \n     static class StringyBean\n     {\n         }\n     }\n \n+    static class StringyBeanWithProps\n+    {\n+        public final String value;\n+\n+        @JsonCreator\n+        private StringyBeanWithProps(String v) { value = v; }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+    \n     @SuppressWarnings(\"serial\")\n     static class MyParamIntrospector extends JacksonAnnotationIntrospector\n     {\n+        private final String name;\n+        \n+        public MyParamIntrospector(String n) { name = n; }\n+        \n         @Override\n         public String findImplicitPropertyName(AnnotatedMember param) {\n             if (param instanceof AnnotatedParameter) {\n                 AnnotatedParameter ap = (AnnotatedParameter) param;\n                 switch (ap.getIndex()) {\n-                case 0: return \"value\";\n+                case 0: return name;\n                 }\n                 return \"param\"+ap.getIndex();\n             }\n     public void testSingleStringArgWithImplicitName() throws Exception\n     {\n         final ObjectMapper mapper = new ObjectMapper();\n-        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n         StringyBean bean = mapper.readValue(quote(\"foobar\"), StringyBean.class);\n         assertEquals(\"foobar\", bean.getValue());\n     }    \n+\n+    // [databind#714]\n+    public void testSingleImplicitlyNamedNotDelegating() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n+        StringyBeanWithProps bean = mapper.readValue(\"{\\\"value\\\":\\\"x\\\"}\", StringyBeanWithProps.class);\n+        assertEquals(\"x\", bean.getValue());\n+    }    \n+    \n+    // [databind#714]\n+    public void testSingleExplicitlyNamedButDelegating() throws Exception\n+    {\n+        SingleNamedButStillDelegating bean = MAPPER.readValue(quote(\"xyz\"),\n+                SingleNamedButStillDelegating.class);\n+        assertEquals(\"xyz\", bean.value);\n+    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n package com.fasterxml.jackson.databind.creators;\n \n+import java.io.IOException;\n+import java.util.UUID;\n+\n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n \n-// Mostly for [JACSON-774]\n public class TestCreatorNullValue extends BaseMapTest\n {\n     protected static class Container {\n         }\n     }\n \n-    private static interface Contained<T> {}\n+    protected static interface Contained<T> {}\n \n-    private static class NullContained implements Contained<Object> {}\n+    protected static class NullContained implements Contained<Object> {}\n \n-    private static final NullContained NULL_CONTAINED = new NullContained();\n+    protected static final NullContained NULL_CONTAINED = new NullContained();\n \n-    private static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n+    protected static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n         @Override\n         public Contained<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException {\n             return null;\n         }\n     }\n \n-    private static class ContainerDeserializerResolver extends Deserializers.Base {\n+    protected static class ContainerDeserializerResolver extends Deserializers.Base {\n         @Override\n         public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n                 DeserializationConfig config, BeanDescription beanDesc)\n         {\n             if (!Contained.class.isAssignableFrom(type.getRawClass())) {\n                 return null;\n-            } else {\n-                return new ContainedDeserializer();\n             }\n+            return new ContainedDeserializer();\n         }\n     }\n \n-    private static class TestModule extends Module\n+    protected static class TestModule extends Module\n     {\n         @Override\n         public String getModuleName() {\n         }\n     }\n \n+    // [databind#597]\n+    static class JsonEntity {\n+        protected final String type;\n+        protected final UUID id;\n+\n+        private JsonEntity(String type, UUID id) {\n+            this.type = type;\n+            this.id = id;\n+        }\n+\n+        @JsonCreator\n+        public static JsonEntity create(@JsonProperty(\"type\") String type, @JsonProperty(\"id\") UUID id) {\n+            if (type != null && !type.contains(\" \") && (id != null)) {\n+                return new JsonEntity(type, id);\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         Container container = mapper.readValue(\"{}\", Container.class);\n         assertEquals(NULL_CONTAINED, container.contained);\n     }\n+\n+    // [databind#597]: ensure that a useful exception is thrown\n+    public void testCreatorReturningNull() throws IOException {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        String json = \"{ \\\"type\\\" : \\\"     \\\", \\\"id\\\" : \\\"000c0ffb-a0d6-4d2e-a379-4aeaaf283599\\\" }\";\n+        try {\n+            objectMapper.readValue(json, JsonEntity.class);\n+            fail(\"Should not have succeeded\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"JSON creator returned null\");\n+        }\n+    }    \n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators541.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestCreators541 extends BaseMapTest\n+{\n+    static final class Foo {\n+\n+        @JsonProperty(\"foo\")\n+        protected Map<Integer, Bar> foo;\n+        @JsonProperty(\"anumber\")\n+        protected long anumber;\n+\n+        public Foo() {\n+            anumber = 0;\n+        }\n+\n+        public Map<Integer, Bar> getFoo() {\n+            return foo;\n+        }\n+\n+        public long getAnumber() {\n+            return anumber;\n+        }\n+    }\n+\n+    static final class Bar {\n+\n+        private final long p;\n+        private final List<String> stuff;\n+\n+        @JsonCreator\n+        public Bar(@JsonProperty(\"p\") long p, @JsonProperty(\"stuff\") List<String> stuff) {\n+            this.p = p;\n+            this.stuff = stuff;\n+        }\n+\n+        @JsonProperty(\"s\")\n+        public List<String> getStuff() {\n+            return stuff;\n+        }\n+\n+        @JsonProperty(\"stuff\")\n+        private List<String> getStuffDeprecated() {\n+            return stuff;\n+        }\n+\n+        public long getP() {\n+            return p;\n+        }\n+    }    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testCreator541() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n+        mapper.disable(\n+                MapperFeature.AUTO_DETECT_CREATORS,\n+                MapperFeature.AUTO_DETECT_FIELDS,\n+                MapperFeature.AUTO_DETECT_GETTERS,\n+                MapperFeature.AUTO_DETECT_IS_GETTERS,\n+                MapperFeature.AUTO_DETECT_SETTERS,\n+                MapperFeature.USE_GETTERS_AS_SETTERS\n+        );\n+        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);  \n+\n+        final String JSON = \"{\\n\"\n+                + \"    \\\"foo\\\": {\\n\"\n+                + \"        \\\"0\\\": {\\n\"\n+                + \"            \\\"p\\\": 0,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"              \\\"a\\\", \\\"b\\\" \\n\"\n+                + \"            ]   \\n\"\n+                + \"        },\\n\"\n+                + \"        \\\"1\\\": {\\n\"\n+                + \"            \\\"p\\\": 1000,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"              \\\"c\\\", \\\"d\\\" \\n\"\n+                + \"            ]   \\n\"\n+                + \"        },\\n\"\n+                + \"        \\\"2\\\": {\\n\"\n+                + \"            \\\"p\\\": 2000,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"            ]   \\n\"\n+                + \"        }\\n\"\n+                + \"    },\\n\"\n+                + \"    \\\"anumber\\\": 25385874\\n\"\n+                + \"}\";\n+\n+        Foo obj = mapper.readValue(JSON, Foo.class);\n+        assertNotNull(obj);\n+        assertNotNull(obj.foo);\n+        assertEquals(3, obj.foo.size());\n+        assertEquals(25385874L, obj.getAnumber());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n public class TestPolymorphicCreators\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper beans\n-    /**********************************************************\n-     */\n-\n     static class Animal\n     {\n         // All animals have names, for our demo purposes...\n \n     abstract static class AbstractRoot\n     {\n-        private final String opt;\n+        protected final String opt;\n \n-        private AbstractRoot(String opt) {\n+        protected AbstractRoot(String opt) {\n             this.opt = opt;\n         }\n \n         @JsonCreator\n         public static final AbstractRoot make(@JsonProperty(\"which\") int which,\n             @JsonProperty(\"opt\") String opt) {\n-            if(1 == which) {\n+            if (1 == which) {\n                 return new One(opt);\n             }\n             throw new RuntimeException(\"cannot instantiate \" + which);\n         abstract public int getWhich();\n \n         public final String getOpt() {\n-                return opt;\n+            return opt;\n         }\n     }\n \n     static final class One extends AbstractRoot {\n-        private One(String opt) {\n+        protected One(String opt) {\n             super(opt);\n         }\n \n \n     public void testManualPolymorphicWithNumbered() throws Exception\n     {\n-         final ObjectWriter w = MAPPER.writerWithType(AbstractRoot.class);\n+         final ObjectWriter w = MAPPER.writerFor(AbstractRoot.class);\n          final ObjectReader r = MAPPER.reader(AbstractRoot.class);\n \n          AbstractRoot input = AbstractRoot.make(1, \"oh hai!\");\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n \n     static class Issue442Bean {\n         @JsonUnwrapped\n-        private IntWrapper w = new IntWrapper(13);\n+        protected IntWrapper w = new IntWrapper(13);\n     }\n     \n     final static class SizeClassSetter2\n     }\n \n     static class BeanWithDeserialize {\n-        @JsonDeserialize private int a;\n+        @JsonDeserialize protected int a;\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectReader r = MAPPER.reader(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n-        List<?> result = r.withType(List.class).readValue(quote(\"\"));\n+        List<?> result = r.forType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n         }\n         \n     }\n-    \n+\n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonDeserialize(using=ParentClassDeserializer.class)\n+        public Object prop;\n+    }\n+    \n+    static class ParentClassDeserializer\n+        extends StdScalarDeserializer<Object>\n+    {\n+        protected ParentClassDeserializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+                throws IOException {\n+            Object parent = p.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            return \"prop/\"+ desc;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(7, imm.y);\n     }\n \n+    // [databind#623]\n+    public void testJsonNodeDelegating() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(Immutable.class,\n+            new StdNodeBasedDeserializer<Immutable>(Immutable.class) {\n+                @Override\n+                public Immutable convert(JsonNode root, DeserializationContext ctxt) throws IOException {\n+                    int x = root.path(\"x\").asInt();\n+                    int y = root.path(\"y\").asInt();\n+                    return new Immutable(x, y);\n+                }\n+        });\n+        mapper.registerModule(module);\n+        Immutable imm = mapper.readValue(\"{\\\"x\\\":-10,\\\"y\\\":3}\", Immutable.class);\n+        assertEquals(-10, imm.x);\n+        assertEquals(3, imm.y);\n+    }\n+    \n     public void testIssue882() throws Exception\n     {\n         Model original = new Model(Collections.singletonMap(new CustomKey(123), \"test\"));\n         assertNotNull(w.value.inner);\n         assertEquals(-13, w.value.inner.x);\n     }\n+\n+    // [#631]: \"current value\" access\n+    public void testCurrentValueAccess() throws Exception\n+    {\n+        Issue631Bean bean = MAPPER.readValue(aposToQuotes(\"{'prop':'stuff'}\"),\n+                Issue631Bean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"prop/Issue631Bean\", bean.prop);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n     }\n \n     static class LinkB {\n-        private LinkA a;\n+        protected LinkA a;\n \n         public void setA(LinkA a) { this.a = a; }\n         public LinkA getA() { return a; }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n     {\n         // can not use shared mapper when changing configs...\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        assertNull(reader.withType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n-        assertNull(reader.withType(TestEnum.class).readValue(\" 4343 \"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\" 4343 \"));\n     }\n \n     public void testAllowUnknownEnumValuesForEnumSets() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        EnumSet<TestEnum> result = reader.withType(new TypeReference<EnumSet<TestEnum>>() { })\n+        EnumSet<TestEnum> result = reader.forType(new TypeReference<EnumSet<TestEnum>>() { })\n                 .readValue(\"[\\\"NO-SUCH-VALUE\\\"]\");\n         assertEquals(0, result.size());\n     }\n     public void testAllowUnknownEnumValuesAsMapKeysReadAsNull() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        ClassWithEnumMapKey result = reader.withType(ClassWithEnumMapKey.class)\n+        ClassWithEnumMapKey result = reader.forType(ClassWithEnumMapKey.class)\n                 .readValue(\"{\\\"map\\\":{\\\"NO-SUCH-VALUE\\\":\\\"val\\\"}}\");\n         assertTrue(result.map.containsKey(null));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n-import com.fasterxml.jackson.test.BrokenStringReader;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n \n     static class IssueGH471Bean {\n \n-        private final Object constructorInjected;\n-        private final String constructorValue;\n+        protected final Object constructorInjected;\n+        protected final String constructorValue;\n \n-        @JacksonInject(\"field_injected\") private Object fieldInjected;\n-        @JsonProperty(\"field_value\")     private String fieldValue;\n+        @JacksonInject(\"field_injected\") protected Object fieldInjected;\n+        @JsonProperty(\"field_value\")     protected String fieldValue;\n \n-        private Object methodInjected;\n-        private String methodValue;\n+        protected Object methodInjected;\n+        protected String methodValue;\n \n         public int x;\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n \n         @JsonProperty(\"Location\")\n         @JsonDeserialize(using=MyStackTraceElementDeserializer.class)\n-        private StackTraceElement location;    \n+        protected StackTraceElement location;    \n     }\n \n     @SuppressWarnings(\"serial\")\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public static enum ConcreteType implements ITestType {\n         ONE, TWO;\n     }\n+\n+    static class ClassStringMap extends HashMap<Class<?>,String> { }\n     \n     /*\n     /**********************************************************\n         Map<?,?> result = r.readValue(JSON);\n         assertNull(result);\n \n-        EnumMap<?,?> result2 = r.withType(new TypeReference<EnumMap<Key,String>>() { })\n+        EnumMap<?,?> result2 = r.forType(new TypeReference<EnumMap<Key,String>>() { })\n                 .readValue(JSON);\n         assertNull(result2);\n     }\n         key = map.keySet().iterator().next();\n         assertEquals(\"foo\", key.value);\n     }\n+\n+    public void testClassKeyMap() throws Exception {\n+        ClassStringMap map = MAPPER.readValue(aposToQuotes(\"{'java.lang.String':'foo'}\"),\n+                ClassStringMap.class);\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        assertEquals(\"foo\", map.get(String.class));\n+    }\n     \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import javax.measure.Measure;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestNoClassDefFoundDeserializer extends BaseMapTest {\n+\n+    public static class Parent {\n+        public List<Child> child;\n+    }\n+\n+    public static class Child {\n+        public Measure<?> measure;\n+    }\n+\n+    public void testClassIsMissing()\n+    {\n+        boolean missing = false;\n+        try {\n+            Class.forName(\"javax.measure.Measure\");\n+        } catch (ClassNotFoundException ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"javax.measure.Measure is not in classpath\", missing);\n+    }\n+\n+    public void testDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Parent result = m.readValue(\" { } \", Parent.class);\n+        assertNotNull(result);\n+    }\n+\n+    public void testUseMissingClass() throws Exception\n+    {\n+        boolean missing = false;\n+        try {\n+            ObjectMapper m = new ObjectMapper();\n+            m.readValue(\" { \\\"child\\\" : [{}] } \", Parent.class);\n+        } catch (NoClassDefFoundError ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"cannot instantiate a missing class\", missing);\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n /**\n  * Tests related to [JACKSON-139]\n  */\n-public class TestNumbers\n-    extends BaseMapTest\n+public class TestNumbers extends BaseMapTest\n {\n     /*\n     /**********************************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestObjectReader.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectReader extends BaseMapTest\n+{\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testParserFeatures() throws Exception\n+    {\n+        final String JSON = \"[ /* foo */ 7 ]\";\n+        // default won't accept comments, let's change that:\n+        ObjectReader reader = MAPPER.reader(int[].class)\n+                .with(JsonParser.Feature.ALLOW_COMMENTS);\n+\n+        int[] value = reader.readValue(JSON);\n+        assertNotNull(value);\n+        assertEquals(1, value.length);\n+        assertEquals(7, value[0]);\n+\n+        // but also can go back\n+        try {\n+            reader.without(JsonParser.Feature.ALLOW_COMMENTS).readValue(JSON);\n+            fail(\"Should not have passed\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"foo\");\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n /**\n- * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * Unit tests for verifying \"raw\" (or \"untyped\") data binding from JSON to JDK objects;\n  * one that only uses core JDK types; wrappers, Maps and Lists.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestUntypedDeserialization\n     extends BaseMapTest\n {\n-    @SuppressWarnings(\"serial\")\n     static class UCStringDeserializer\n         extends StdScalarDeserializer<String>\n     {\n         public UCStringDeserializer() { super(String.class); }\n \n         @Override\n-        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return jp.getText().toUpperCase();\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n     static class CustomNumberDeserializer\n         extends StdScalarDeserializer<Number>\n     {\n         }\n \n         @Override\n-        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return value;\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n+    // Let's make this Contextual, to tease out cyclic resolution issues, if any\n     static class ListDeserializer extends StdDeserializer<List<Object>>\n+        implements ContextualDeserializer\n     {\n         public ListDeserializer() { super(List.class); }\n \n             }\n             return list;\n         }\n-    }\n-\n-    @SuppressWarnings(\"serial\")\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            // For now, we just need to access \"untyped\" deserializer; not use it.\n+            \n+            /*JsonDeserializer<Object> ob = */\n+            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);\n+            return this;\n+        }\n+    }\n+\n     static class MapDeserializer extends StdDeserializer<Map<String,Object>>\n     {\n         public MapDeserializer() { super(Map.class); }\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n     \n     public void testSimpleWithJSON() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         POJO pojo = detecting.readValue(utf8Bytes(\"{\\\"x\\\":1}\"));\n         assertNotNull(pojo);\n \n     public void testInvalid() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         try {\n             detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n public class TestInferredMutators extends BaseMapTest\n {\n     public static class Point {\n-        private int x;\n+        protected int x;\n         \n         public int getX() { return x; }\n     }\n \n     public static class FixedPoint {\n-        private final int x;\n+        protected final int x;\n \n         public FixedPoint() { x = 0; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n \n     public static class JacksonExample\n     {\n-        private String attributeProperty;\n-        private String elementProperty;\n-        private List<String> wrappedElementProperty;\n-        private EnumExample enumProperty;\n-        private QName qname;\n+        protected String attributeProperty;\n+        protected String elementProperty;\n+        protected List<String> wrappedElementProperty;\n+        protected EnumExample enumProperty;\n+        protected QName qname;\n \n         @JsonSerialize(using=QNameSerializer.class)\n         public QName getQname()\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n     @JsonAutoDetect\n     (fieldVisibility= JsonAutoDetect.Visibility.NONE,getterVisibility= JsonAutoDetect.Visibility.NONE, setterVisibility= JsonAutoDetect.Visibility.NONE, isGetterVisibility= JsonAutoDetect.Visibility.NONE)\n     static class CoreBean158 {\n-        private String bar = \"x\";\n+        protected String bar = \"x\";\n \n         @JsonProperty\n         public String getBar() {\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testAbstractLists() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         ListWrapper w = new ListWrapper();\n         w.list.add(\"x\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, ListWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, ListWrapper.class);\n         assertEquals(ListWrapper.class, o.getClass());\n         ListWrapper out = (ListWrapper) o;\n+        assertNotNull(out.list);\n         assertEquals(1, out.list.size());\n         assertEquals(\"x\", out.list.get(0));\n    }\n     \n     public void testAbstractMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         MapWrapper w = new MapWrapper();\n         w.map.put(\"key1\", \"name1\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, MapWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, MapWrapper.class);\n         assertEquals(MapWrapper.class, o.getClass());\n         MapWrapper out = (MapWrapper) o;\n         assertEquals(1, out.map.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n-import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestCustomTypeIdResolver extends BaseMapTest\n         }\n     }\n \n-    static class CustomResolverBase implements TypeIdResolver\n+    static class CustomResolverBase extends TypeIdResolverBase\n     {\n         protected final Class<?> superType;\n         protected final Class<?> subType;\n         public void init(JavaType baseType) { }\n \n         @Override\n-        public JavaType typeFromId(String id)\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (\"*\".equals(id)) {\n                 return TypeFactory.defaultInstance().constructType(subType);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n-        byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n+        byte[] json = mapper.writerFor(rootType).writeValueAsBytes(input);\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n {\n     @JsonTypeInfo(use=JsonTypeInfo.Id.NONE)\n     @JsonDeserialize(as=NoType.class)\n-    private static interface NoTypeInterface {\n+    static interface NoTypeInterface {\n     }\n     \n-    private final static class NoType implements NoTypeInterface {\n+    final static class NoType implements NoTypeInterface {\n         public int a = 3;\n     }\n     \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+\n+/**\n+ * Unit tests related to specialized handling of \"default implementation\"\n+ * ({@link JsonTypeInfo#defaultImpl}), as well as related\n+ * cases that allow non-default settings (such as missing type id).\n+ */\n+public class TestPolymorphicWithDefaultImpl extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+    @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+    public static interface Inter { }\n+\n+    public static class MyInter implements Inter {\n+        @JsonProperty(\"blah\") public List<String> blah;\n+    }\n+\n+    public static class LegacyInter extends MyInter\n+    {\n+        @JsonCreator\n+        LegacyInter(Object obj)\n+        {\n+            if (obj instanceof List) {\n+                blah = new ArrayList<String>();\n+                for (Object o : (List<?>) obj) {\n+                    blah.add(o.toString());\n+                }\n+            }\n+            else if (obj instanceof String) {\n+                blah = Arrays.asList(((String) obj).split(\",\"));\n+            }\n+            else {\n+                throw new IllegalArgumentException(\"Unknown type: \" + obj.getClass());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Note: <code>NoClass</code> here has special meaning, of mapping invalid\n+     * types into null instances.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = NoClass.class)\n+    public static class DefaultWithNoClass { }\n+\n+    /**\n+     * Also another variant to verify that from 2.5 on, can use non-deprecated\n+     * value for the same.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = Void.class)\n+    public static class DefaultWithVoidAsDefault { }\n+\n+    // and then one with no defaultImpl nor listed subtypes\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+    abstract static class MysteryPolymorphic { }\n+\n+    // [Databind#511] types\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes(@JsonSubTypes.Type(name=\"sub1\", value = BadSub1.class))\n+    public static class BadItem {}\n+\n+    public static class BadSub1 extends BadItem {\n+        public String a ;\n+    }\n+\n+    public static class Good {\n+        public List<GoodItem> many;\n+    }\n+\n+    public static class Bad {\n+        public List<BadItem> many;\n+    }\n+ \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({@JsonSubTypes.Type(name=\"sub1\", value = GoodSub1.class),\n+            @JsonSubTypes.Type(name=\"sub2\", value = GoodSub2.class) })\n+    public static class GoodItem {}\n+\n+    public static class GoodSub1 extends GoodItem {\n+        public String a ;\n+    }\n+    public static class GoodSub2 extends GoodItem {\n+        public String b ;\n+\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testDeserializationWithObject() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n+        assertTrue(inter instanceof MyInter);\n+        assertFalse(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithString() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"\\\"a,b,c,d\\\"\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArray() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArrayOfSize2() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n+    }\n+\n+    // [Databind#148]\n+    public void testDefaultAsNoClass() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // same, with 2.5 and Void.class\n+    public void testDefaultAsVoid() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#148]\n+    public void testBadTypeAsNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n+        Object ob = mapper.readValue(\"{}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+        ob = mapper.readValue(\"{ \\\"whatever\\\":13}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#511]\n+    public void testInvalidTypeId511() throws Exception {\n+        ObjectReader reader = MAPPER.reader().without(\n+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n+                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n+                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES\n+        );\n+        String json = \"{\\\"many\\\":[{\\\"sub1\\\":{\\\"a\\\":\\\"foo\\\"}},{\\\"sub2\\\":{\\\"b\\\":\\\"bar\\\"}}]}\" ;\n+        Good goodResult = reader.forType(Good.class).readValue(json) ;\n+        assertNotNull(goodResult) ;\n+        Bad badResult = reader.forType(Bad.class).readValue(json);\n+        assertNotNull(badResult);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    /*\n+    public void testDontWriteIfDefaultImpl() throws Exception {\n+        String json = MAPPER.writeValueAsString(new MyInter());\n+        assertEquals(\"{\\\"blah\\\":null}\", json);\n+    }\n+    */\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n     \n     static class MethodWrapperBean\n     {\n-        private Object value;\n+        protected Object value;\n         \n         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n         public Object getValue() { return value; }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n             JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n-            String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n+            String json = mapper.writerFor(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n             }\n             l2.add(new Issue508A());\n             l.add(l2);\n             TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};\n-            String json = mapper.writerWithType(typeRef).writeValueAsString(l);\n+            String json = mapper.writerFor(typeRef).writeValueAsString(l);\n \n             List<?> output = mapper.readValue(json, typeRef);\n             assertEquals(1, output.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n         List<Super> list = new ArrayList<Super>();\n         list.add(new A());\n         map.put(1L, list);\n-        String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n+        String json = mapper.writerFor(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n         assertTrue(\"JSON does not contain '@class': \"+json, json.contains(\"@class\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         public MyParam(T v) { value = v; }\n     }\n \n-    private static class SomeObject {\n-        @SuppressWarnings(\"unused\")\n+    static class SomeObject {\n         public String someValue = UUID.randomUUID().toString();\n     }\n     \n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerFor(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n         result = writeAndMap(mapper2, bean);\n         assertEquals(2, result.size());\n         ObjectMapper mapper3 = mapper2.copy();\n-        mapper3.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper3.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper3, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestDuplicateRegistration.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDuplicateRegistration extends BaseMapTest\n+{\n+    static class MyModule extends Module {\n+        public int regCount;\n+        \n+        public MyModule() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getModuleName() {\n+            return \"TestModule\";\n+        }\n+\n+        @Override\n+        public Version version() {\n+            return Version.unknownVersion();\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context) {\n+            ++regCount;\n+        }\n+    }\n+\n+    public void testDuplicateRegistration() throws Exception\n+    {\n+        // by default, duplicate registration should be prevented\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertTrue(mapper.isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS));\n+        MyModule module = new MyModule();\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        assertEquals(1, module.regCount);\n+\n+        // but may be allowed by changing setting\n+        mapper.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        mapper.registerModule(module);\n+        assertEquals(2, module.regCount);\n+\n+        // and ditto for a new instance\n+        ObjectMapper mapper2 = new ObjectMapper();\n+        mapper2.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        MyModule module2 = new MyModule();\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        assertEquals(3, module2.regCount);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n             assertNotNull(m);\n         }\n     }\n-    \n+\n+    static class TestModule626 extends SimpleModule {\n+        final Class<?> mixin, target;\n+        public TestModule626(Class<?> t, Class<?> m) {\n+            super(\"Test\");\n+            target = t;\n+            mixin = m;\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context) {\n+            context.setMixInAnnotations(target, mixin);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests; first, verifying need for custom handlers\n             verifyException(e, \"No suitable constructor found\");\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests; simple serializers\n     /**********************************************************\n      */\n-    \n+\n     public void testSimpleBeanSerializer() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.registerModule(module);\n     }\n+\n+    // [databind#626]\n+    public void testMixIns626() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // no real annotations, but nominally add ones from 'String' to 'Object', just for testing\n+        mapper.registerModule(new TestModule626(Object.class, String.class));\n+        Class<?> found = mapper.findMixInClassFor(Object.class);\n+        assertEquals(String.class, found);\n+    }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n     public void testBigDecimalAsPlainStringTreeConversion() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n-\n import com.fasterxml.jackson.databind.*;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper()\n                 .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n-                .enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+                .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         final String INPUT = \"{\\\"x\\\":1e2}\";\n         final JsonNode node = mapper.readTree(INPUT);\n         String result = mapper.writeValueAsString(node);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n         }\n     }\n \n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonSerialize(using=ParentClassSerializer.class)\n+        public Object prop;\n+\n+        public Issue631Bean(Object o) {\n+            prop = o;\n+        }\n+    }\n+    \n+    static class ParentClassSerializer\n+        extends StdScalarSerializer<Object>\n+    {\n+        protected ParentClassSerializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator gen,\n+                SerializerProvider provider) throws IOException {\n+            Object parent = gen.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            gen.writeString(desc+\"/\"+value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n     // [Issue#215]: Allow registering CharacterEscapes via ObjectWriter\n     public void testCustomEscapes() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n-                mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n+                MAPPER.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n     \n     public void testNumberSubclass() throws Exception\n         assertEquals(aposToQuotes(\"{'x':42}\"),\n                 MAPPER.writeValueAsString(new LikeNumber(42)));\n     }\n+\n+    public void testWithCurrentValue() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'prop':'Issue631Bean/42'}\"),\n+                MAPPER.writeValueAsString(new Issue631Bean(42)));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n         assertEquals(\"\\\"B\\\"\", mapper.writeValueAsString(EnumWithSubClass.B));\n     }\n \n-    // [JACKSON-193]\n     public void testEnumsWithJsonValue() throws Exception\n     {\n         assertEquals(\"\\\"bar\\\"\", mapper.writeValueAsString(EnumWithJsonValue.B));\n     }\n \n-    // also, for [JACKSON-193], needs to work via mix-ins\n     public void testEnumsWithJsonValueUsingMixin() throws Exception\n     {\n         // can't share, as new mix-ins are added\n         assertEquals(\"\\\"b\\\"\", m.writeValueAsString(TestEnum.B));\n     }\n \n+    // [databind#601]\n+    public void testEnumsWithJsonValueInMap() throws Exception\n+    {\n+        EnumMap<EnumWithJsonValue,String> input = new EnumMap<EnumWithJsonValue,String>(EnumWithJsonValue.class);\n+        input.put(EnumWithJsonValue.B, \"x\");\n+        assertEquals(\"{\\\"\"+EnumWithJsonValue.B.toString()+\"\\\":\\\"x\\\"}\", mapper.writeValueAsString(input));\n+    }\n+    \n     /**\n      * Test for ensuring that @JsonSerializable is used with Enum types as well\n      * as with any other types.\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n-import com.fasterxml.jackson.test.BrokenStringWriter;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n \n         // also: let's ensure that ObjectWriter won't interfere with it\n         bean = new CloseableBean();\n-        m.writerWithType(CloseableBean.class).writeValueAsString(bean);\n+        m.writerFor(CloseableBean.class).writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n         public Person1(String name) { this.name = name; }\n \n         public String getName() {\n-                return name;\n+            return name;\n         }\n \n         public Key<Account> getAccount() {\n-                return account;\n+            return account;\n         }\n \n         public Long getId() {\n-                return id;\n+            return id;\n         }\n \n         public void setAccount(Key<Account> account) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n import java.util.*;\n import java.util.regex.Pattern;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n \n /**\n     public void testBigDecimalAsPlainString()\n         throws Exception\n     {\n-        MAPPER.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        final ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n-        String str = MAPPER.writeValueAsString(map);\n+        String str = mapper.writeValueAsString(map);\n         assertEquals(\"{\\\"pi\\\":3.00000000}\", str);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n     @JsonPropertyOrder(alphabetic=true)\n     final static class ClassGetter<T>\n     {\n-    \tprivate final T _value;\n+        protected final T _value;\n     \t\n-        private ClassGetter(T value) { _value = value;}\n+        protected ClassGetter(T value) { _value = value;}\n  \n         public T getNonRaw() { return _value; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     }\n \n     static class Bar294{\n-        @JsonProperty private String id;\n-        @JsonProperty private String name;\n+        @JsonProperty protected String id;\n+        @JsonProperty protected String name;\n \n         public Bar294() { }\n         public Bar294(String id) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n public class TestJsonSerializeAs extends BaseMapTest\n {\n     // [JACKSON-799] stuff:\n-    \n     public interface Fooable {\n         public int getFoo();\n     }\n             return new FooImpl();\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectWriter WRITER = objectWriter();\n-    \n+\n     // [JACKSON-799]\n     public void testSerializeAsInClass() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n \n public class TestKeySerializers extends BaseMapTest\n {\n         public Map<String,Integer> map = new HashMap<String,Integer>();\n         {\n             map.put(\"Not Karl\", 1);\n+        }\n+    }\n+\n+    enum ABC {\n+        A, B, C\n+    }\n+\n+    static class ABCSerializer extends JsonSerializer<ABC> {\n+        @Override\n+        public void serialize(ABC value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(\"xxx\"+value);\n+        }\n+    }\n+\n+    static class ABCMapWrapper {\n+        public Map<ABC,String> stuff = new HashMap<ABC,String>();\n+        public ABCMapWrapper() {\n+            stuff.put(ABC.B, \"bar\");\n         }\n     }\n \n         final String value2 = mapper.writeValueAsString(new KarlBean());\n         assertEquals(\"{\\\"map\\\":{\\\"Karl\\\":1}}\", value2);\n     }\n+\n+    // Test custom key serializer for enum\n+    public void testCustomForEnum() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\");\n+        mod.addKeySerializer(ABC.class, new ABCSerializer());\n+        mapper.registerModule(mod);\n+\n+        String json = mapper.writeValueAsString(new ABCMapWrapper());\n+        assertEquals(\"{\\\"stuff\\\":{\\\"xxxB\\\":\\\"bar\\\"}}\", json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n \n     public void testUsingObjectWriter() throws IOException\n     {\n-        ObjectWriter w = MAPPER.writerWithType(Object.class);\n+        ObjectWriter w = MAPPER.writerFor(Object.class);\n         Map<String,Object> map = new LinkedHashMap<String,Object>();\n         map.put(\"a\", 1);\n         String json = w.writeValueAsString(map);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n {\n     private final ObjectMapper MAPPER = objectMapper();\n \n-    private static class IntAsString {\n+    static class IntAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public int value = 3;\n     }\n \n-    private static class LongAsString {\n+    static class LongAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public long value = 4;\n     }\n-    \n-    private static class DoubleAsString {\n+\n+    static class DoubleAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public double value = -0.5;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n-    \n+\n     public void testDouble() throws Exception\n     {\n         double[] values = new double[] {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n \n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.PrettyPrinter;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Unit tests for checking features added to {@link ObjectWriter}, such\n public class TestObjectWriter\n     extends BaseMapTest\n {\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testPrettyPrinter() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        ObjectWriter writer = mapper.writer();\n+        ObjectWriter writer = MAPPER.writer();\n         HashMap<String, Integer> data = new HashMap<String,Integer>();\n         data.put(\"a\", 1);\n         \n \n     public void testPrefetch() throws Exception\n     {\n-        ObjectWriter writer = objectWriter();\n+        ObjectWriter writer = MAPPER.writer();\n         assertFalse(writer.hasPrefetchedSerializer());\n-        writer = objectWriter().withType(String.class);\n+        writer = writer.forType(String.class);\n         assertTrue(writer.hasPrefetchedSerializer());\n     }\n-} \n+\n+    public void testObjectWriterFeatures() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writer()\n+                .without(JsonGenerator.Feature.QUOTE_FIELD_NAMES);                \n+        Map<String,Integer> map = new HashMap<String,Integer>();\n+        map.put(\"a\", 1);\n+        assertEquals(\"{a:1}\", writer.writeValueAsString(map));\n+        // but can also reconfigure\n+        assertEquals(\"{\\\"a\\\":1}\", writer.with(JsonGenerator.Feature.QUOTE_FIELD_NAMES)\n+                .writeValueAsString(map));\n+    }\n+\n+    public void testObjectWriterWithNode() throws Exception\n+    {\n+        ObjectNode stuff = MAPPER.createObjectNode();\n+        stuff.put(\"a\", 5);\n+        ObjectWriter writer = MAPPER.writerFor(JsonNode.class);\n+        String json = writer.writeValueAsString(stuff);\n+        assertEquals(\"{\\\"a\\\":5}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n         assertEquals(Boolean.TRUE, result.get(\"b2\"));\n \n         // and then using specified typed writer\n-        ObjectWriter w = mapper.writerWithType(BaseType.class);\n+        ObjectWriter w = mapper.writerFor(BaseType.class);\n         String json = w.writeValueAsString(bean);\n         result = (Map<String,Object>)mapper.readValue(json, Map.class);\n         assertEquals(2, result.size());\n         SubType bean = new SubType();\n \n         // let's constrain by interface:\n-        ObjectWriter w = mapper.writerWithType(BaseInterface.class);\n+        ObjectWriter w = mapper.writerFor(BaseInterface.class);\n         String json = w.writeValueAsString(bean);\n         @SuppressWarnings(\"unchecked\")\n         Map<String,Object> result = mapper.readValue(json, Map.class);\n         // must force static typing, otherwise won't matter a lot\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n-        String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n+        String json = mapper.writerFor(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n         assertEquals(\"[{\\\"b\\\":3}]\", json);\n     }\n         SubType bean = new SubType();\n \n         // and then let's try using incompatible type\n-        ObjectWriter w = mapper.writerWithType(HashMap.class);\n+        ObjectWriter w = mapper.writerFor(HashMap.class);\n         try {\n             w.writeValueAsString(bean);\n             fail(\"Should have failed due to incompatible type\");\n         final String EXP = \"[{\\\"beanClass\\\":\\\"TestRootType$TestClass398\\\",\\\"property\\\":\\\"aa\\\"}]\";\n         \n         // First simplest way:\n-        String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);\n+        String json = mapper.writerFor(collectionType).writeValueAsString(typedList);\n         assertEquals(EXP, json);\n \n         StringWriter out = new StringWriter();\n         JsonFactory f = new JsonFactory();\n-        mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList);\n+        mapper.writerFor(collectionType).writeValue(f.createGenerator(out), typedList);\n \n         assertEquals(EXP, out.toString());\n     }\n     public void testIssue456WrapperPart() throws Exception\n     {\n         ObjectMapper mapper = objectMapper();\n-        assertEquals(\"123\", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n-        assertEquals(\"456\", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n+        assertEquals(\"123\", mapper.writerFor(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n+        assertEquals(\"456\", mapper.writerFor(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n     }\n \n     // [JACKSON-630] also, allow annotation to define root name\n         cmd.uuid = \"1234\";\n         cmd.type = 1;\n \n-        ObjectWriter writer = WRAP_ROOT_MAPPER.writerWithType(TestCommandParent.class);\n+        ObjectWriter writer = WRAP_ROOT_MAPPER.writerFor(TestCommandParent.class);\n         String json =  writer.writeValueAsString(cmd);\n \n         assertEquals(json, \"{\\\"TestCommandParent\\\":{\\\"uuid\\\":\\\"1234\\\",\\\"type\\\":1}}\");\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n     public void testTypedSerialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        String singleJson = mapper.writerFor(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n         // start with specific value case:\n         assertEquals(\"{\\\"a\\\":3}\", singleJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n // Work-around when real solution not yet implemented:        \n //        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n-        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerFor(Issue822Interface[].class).writeValueAsString(\n                 new Issue822Interface[] { new Issue822Impl() }));\n     }\n     \n \n         List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n         list.add(new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<List<Issue822Interface>>(){})\n                 .writeValueAsString(list);\n         assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n         Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();\n         map.put(\"a\", new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<Map<String,Issue822Interface>>(){})\n                 .writeValueAsString(map);\n         assertEquals(\"{\\\"a\\\":{\\\"a\\\":3}}\", listJson);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestVirtualProperties.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonAppend;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Tests for verifying that one can append virtual properties after regular ones.\n+ * \n+ * @since 2.5\n+ */\n+public class TestVirtualProperties extends BaseMapTest\n+{\n+    @JsonAppend(attrs={ @JsonAppend.Attr(\"id\"),\n+        @JsonAppend.Attr(value=\"internal\", propName=\"extra\", required=true)\n+    })\n+    static class SimpleBean\n+    {\n+        public int value = 13;\n+    }\n+\n+    @JsonAppend(prepend=true, attrs={ @JsonAppend.Attr(\"id\"),\n+            @JsonAppend.Attr(value=\"internal\", propName=\"extra\")\n+        })\n+    static class SimpleBeanPrepend\n+    {\n+        public int value = 13;\n+    }\n+\n+    enum ABC {\n+        A, B, C;\n+    }\n+\n+    @JsonAppend(attrs=@JsonAppend.Attr(value=\"desc\", include=JsonInclude.Include.NON_EMPTY))\n+    static class OptionalsBean\n+    {\n+        public int value = 28;\n+    }\n+\n+    static class CustomVProperty\n+        extends VirtualBeanPropertyWriter\n+    {\n+        private CustomVProperty() { super(); }\n+\n+        private CustomVProperty(BeanPropertyDefinition propDef,\n+                Annotations ctxtAnn, JavaType type) {\n+            super(propDef, ctxtAnn, type);\n+        }\n+\n+        @Override\n+        protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) {\n+            if (_name.toString().equals(\"id\")) {\n+                return \"abc123\";\n+            }\n+            if (_name.toString().equals(\"extra\")) {\n+                return new int[] { 42 };\n+            }\n+            return \"???\";\n+        }\n+\n+        @Override\n+        public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+                AnnotatedClass declaringClass, BeanPropertyDefinition propDef,\n+                JavaType type)\n+        {\n+            return new CustomVProperty(propDef, declaringClass.getAnnotations(), type);\n+        }\n+    }\n+\n+    @JsonAppend(prepend=true, props={ @JsonAppend.Prop(value=CustomVProperty.class, name=\"id\"),\n+            @JsonAppend.Prop(value=CustomVProperty.class, name=\"extra\")\n+        })\n+    static class CustomVBean\n+    {\n+        public int value = 72;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectWriter WRITER = objectWriter();\n+\n+    public void testAttributeProperties() throws Exception\n+    {\n+        Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        stuff.put(\"x\", 3);\n+        stuff.put(\"y\", ABC.B);\n+\n+        String json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBean());\n+        assertEquals(aposToQuotes(\"{'value':13,'id':'abc123','extra':{'x':3,'y':'B'}}\"), json);\n+\n+        json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBeanPrepend());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':{'x':3,'y':'B'},'value':13}\"), json);\n+    }\n+\n+    public void testAttributePropInclusion() throws Exception\n+    {\n+        // first, with desc\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28,'desc':'nice'}\"), json);\n+\n+        // then with null (not defined)\n+        json = WRITER.writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+\n+        // and finally \"empty\"\n+        json = WRITER.withAttribute(\"desc\", \"\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+    }\n+\n+    public void testCustomProperties() throws Exception\n+    {\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new CustomVBean());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':[42],'value':72}\"), json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/JSOGDeserialize622Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit test(s) for [databind#622], supporting non-scalar-Object-ids,\n+ * to support things like JSOG.\n+ */\n+public class JSOGDeserialize622Test extends BaseMapTest\n+{\n+    /** the key of the property that holds the ref */\n+    public static final String REF_KEY = \"@ref\";\n+\n+    /**\n+     * JSON input\n+     */\n+    private static final String EXP_EXAMPLE_JSOG =  aposToQuotes(\n+            \"{'@id':'1','foo':66,'next':{'\"+REF_KEY+\"':'1'}}\");\n+\n+    /**\n+     * Customer IdGenerator\n+     */\n+    static class JSOGGenerator extends ObjectIdGenerator<JSOGRef>  {\n+\n+    private static final long serialVersionUID = 1L;\n+    protected transient int _nextValue;\n+    protected final Class<?> _scope;\n+\n+    protected JSOGGenerator() { this(null, -1); }\n+\n+    protected JSOGGenerator(Class<?> scope, int nextValue) {\n+        _scope = scope;\n+        _nextValue = nextValue;\n+    }\n+\n+    @Override\n+    public Class<?> getScope() {\n+        return _scope;\n+    }\n+\n+    @Override\n+    public boolean canUseFor(ObjectIdGenerator<?> gen) {\n+        return (gen.getClass() == getClass()) && (gen.getScope() == _scope);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> forScope(Class<?> scope) {\n+          return (_scope == scope) ? this : new JSOGGenerator(scope, _nextValue);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> newForSerialization(Object context) {\n+          return new JSOGGenerator(_scope, 1);\n+    }\n+\n+    @Override\n+    public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) {\n+          return new IdKey(getClass(), _scope, key);\n+    }\n+\n+    // important: otherwise won't get proper handling\n+    @Override\n+    public boolean maySerializeAsObject() { return true; }\n+\n+    // ditto: needed for handling Object-valued Object references\n+    @Override\n+    public boolean isValidReferencePropertyName(String name, Object parser) {\n+        return REF_KEY.equals(name);\n+    }\n+\n+    @Override\n+    public JSOGRef generateId(Object forPojo) {\n+          int id = _nextValue;\n+          ++_nextValue;\n+          return new JSOGRef(id);\n+    }\n+    }\n+\n+    /**\n+     * The reference deserializer\n+     */\n+    static class JSOGRefDeserializer extends JsonDeserializer<JSOGRef>\n+    {\n+      @Override\n+      public JSOGRef deserialize(JsonParser jp, DeserializationContext ctx) throws IOException {\n+          JsonNode node = jp.readValueAsTree();\n+          return node.isTextual()\n+                  ? new JSOGRef(node.asInt()) : new JSOGRef(node.get(REF_KEY).asInt());\n+      }\n+    }\n+\n+    /**\n+     * The reference object\n+     */\n+    @JsonDeserialize(using=JSOGRefDeserializer.class)\n+    static class JSOGRef\n+    {\n+        @JsonProperty(REF_KEY)\n+        public int ref;\n+\n+        public JSOGRef() { }\n+\n+        public JSOGRef(int val) {\n+            ref = val;\n+        }\n+\n+        @Override\n+        public String toString() { return \"[JSOGRef#\"+ref+\"]\"; }\n+\n+        @Override\n+        public int hashCode() {\n+            return ref;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object other) {\n+            return (other instanceof JSOGRef)\n+                    && ((JSOGRef) other).ref == this.ref;\n+        }\n+    }\n+\n+    /**\n+     * Example class using JSOGGenerator\n+     */\n+    @JsonIdentityInfo(generator=JSOGGenerator.class, property=\"@id\")\n+    public static class IdentifiableExampleJSOG {\n+        public int foo;\n+        public IdentifiableExampleJSOG next;\n+\n+        protected IdentifiableExampleJSOG() { }\n+        public IdentifiableExampleJSOG(int v) {\n+            foo = v;\n+        }\n+    }\n+\n+    public static class JSOGWrapper {\n+        public int value;\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+        public Object jsog;\n+\n+        JSOGWrapper() { }\n+        public JSOGWrapper(int v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Test methods\n+    /**********************************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    // Basic for [#622]\n+    public void testStructJSOGRef() throws Exception\n+    {\n+        IdentifiableExampleJSOG result = MAPPER.readValue(EXP_EXAMPLE_JSOG,\n+                IdentifiableExampleJSOG.class);\n+        assertEquals(66, result.foo);\n+        assertSame(result, result.next);\n+    }\n+\n+    // polymorphic alternative for [#622]\n+    public void testPolymorphicRoundTrip() throws Exception\n+    {\n+        JSOGWrapper w = new JSOGWrapper(15);\n+        // create a nice little loop\n+        IdentifiableExampleJSOG ex = new IdentifiableExampleJSOG(123);\n+        ex.next = ex;\n+        w.jsog = ex;\n+\n+        String json = MAPPER.writeValueAsString(w);\n+\n+        JSOGWrapper out = MAPPER.readValue(json, JSOGWrapper.class);\n+        assertNotNull(out);\n+        assertEquals(15, out.value);\n+        assertTrue(out.jsog instanceof IdentifiableExampleJSOG);\n+        IdentifiableExampleJSOG jsog = (IdentifiableExampleJSOG) out.jsog;\n+        assertEquals(123, jsog.foo);\n+        assertSame(jsog, jsog.next);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/PojoAsArray646Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class PojoAsArray646Test extends BaseMapTest\n+{\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class Outer {\n+\n+        private Map<String, TheItem> attributes;\n+\n+        public Outer() {\n+            attributes = new HashMap<String, TheItem>();\n+        }\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public Map<String, TheItem> getAttributes() {\n+            return attributes;\n+        }\n+    }\n+\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class TheItem {\n+\n+        @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+        @JsonPropertyOrder(alphabetic = true)\n+        public static class NestedItem {\n+            public String nestedStrValue;\n+\n+            @JsonCreator\n+            public NestedItem(@JsonProperty(\"nestedStrValue\") String nestedStrValue) {\n+                this.nestedStrValue = nestedStrValue;\n+            }\n+        }\n+\n+        private String strValue;\n+        private boolean boolValue;\n+        private List<NestedItem> nestedItems;\n+\n+        @JsonCreator\n+        public TheItem(@JsonProperty(\"strValue\") String strValue, @JsonProperty(\"boolValue\") boolean boolValue, @JsonProperty(\"nestedItems\") List<NestedItem> nestedItems) {\n+            this.strValue = strValue;\n+            this.boolValue = boolValue;\n+            this.nestedItems = nestedItems;\n+        }\n+\n+        public String getStrValue() {\n+            return strValue;\n+        }\n+\n+        public void setStrValue(String strValue) {\n+            this.strValue = strValue;\n+        }\n+\n+        public boolean isBoolValue() {\n+            return boolValue;\n+        }\n+\n+        public void setBoolValue(boolean boolValue) {\n+            this.boolValue = boolValue;\n+        }\n+\n+        public List<NestedItem> getNestedItems() {\n+            return nestedItems;\n+        }\n+\n+        public void setNestedItems(List<NestedItem> nestedItems) {\n+            this.nestedItems = nestedItems;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithCustomTypeId() throws Exception {\n+\n+        List<TheItem.NestedItem> nestedList = new ArrayList<TheItem.NestedItem>();\n+        nestedList.add(new TheItem.NestedItem(\"foo1\"));\n+        nestedList.add(new TheItem.NestedItem(\"foo2\"));\n+        TheItem item = new TheItem(\"first\", false, nestedList);\n+        Outer outer = new Outer();\n+        outer.getAttributes().put(\"entry1\", item);\n+\n+        String json = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(outer);\n+\n+        Outer result = MAPPER.readValue(json, Outer.class);\n+        assertNotNull(result);\n+        assertNotNull(result.attributes);\n+        assertEquals(1, result.attributes.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestForwardReference.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * Test for testing forward reference handling\n+ */\n+public class TestForwardReference extends BaseMapTest {\n+\n+\tprivate final ObjectMapper MAPPER = new ObjectMapper()\n+\t\t\t.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n+\t\t\t.enable(SerializationFeature.INDENT_OUTPUT)\n+\t\t\t.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n+\n+\t/** Tests that we can read a hierarchical structure with forward references*/\n+\tpublic void testForwardRef() throws IOException {\n+\t\tMAPPER.readValue(\"{\" +\n+\t\t\t\t\"  \\\"@type\\\" : \\\"TestForwardReference$ForwardReferenceContainerClass\\\",\" +\n+\t\t\t\t\"  \\\"frc\\\" : \\\"willBeForwardReferenced\\\",\" +\n+\t\t\t\t\"  \\\"yac\\\" : {\" +\n+\t\t\t\t\"    \\\"@type\\\" : \\\"TestForwardReference$YetAnotherClass\\\",\" +\n+\t\t\t\t\"    \\\"frc\\\" : {\" +\n+\t\t\t\t\"      \\\"@type\\\" : \\\"One\\\",\" +\n+\t\t\t\t\"      \\\"id\\\" : \\\"willBeForwardReferenced\\\"\" +\n+\t\t\t\t\"    },\" +\n+\t\t\t\t\"    \\\"id\\\" : \\\"anId\\\"\" +\n+\t\t\t\t\"  },\" +\n+\t\t\t\t\"  \\\"id\\\" : \\\"ForwardReferenceContainerClass1\\\"\" +\n+\t\t\t\t\"}\", ForwardReferenceContainerClass.class);\n+\n+\n+\t}\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)\n+\tpublic static class ForwardReferenceContainerClass\n+\t{\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic YetAnotherClass yac;\n+\t\tpublic String id;\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\t@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+\t@JsonSubTypes({\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = \"One\"),\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = \"Two\")})\n+\tstatic abstract class ForwardReferenceClass\n+\t{\n+\t\tpublic String id;\n+\t\tpublic void setId(String id) {\n+\t\t\tthis.id = id;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\tstatic class YetAnotherClass\n+\t{\n+\t\tpublic YetAnotherClass() {}\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic String id;\n+\t}\n+\n+\tpublic static class ForwardReferenceClassOne extends ForwardReferenceClass { }\n+\n+\tpublic static class ForwardReferenceClassTwo extends ForwardReferenceClass { }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n     private static final String POOL_KEY = \"POOL\";\n \n     // // Classes for external id use\n-    \n+\n     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n     static class Identifiable\n     {\n         public int value;\n \n         public Identifiable next;\n-        \n+\n         public Identifiable() { this(0); }\n         public Identifiable(int v) {\n             value = v;\n         public UUIDNode() { this(0); }\n         public UUIDNode(int v) { value = v; }\n     }\n-    \n+\n     // // Classes for external id from property annotations:\n-    \n+\n     static class IdWrapper\n     {\n         @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"@id\")\n     static class ValueNodeExt\n     {\n         public int value;\n-        private int customId;\n+        protected int customId;\n         public IdWrapperExt next;\n         \n         public ValueNodeExt() { this(0); }\n \n     @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n     static class AnySetterObjectId {\n-        private Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n+        protected Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n \n         @JsonAnySetter\n         public void anySet(String field, AnySetterObjectId value) {\n         assertSame(result, result.next);\n     }\n \n+    // Should be ok NOT to have Object id, as well\n+    public void testMissingObjectId() throws Exception\n+    {\n+        Identifiable result = mapper.readValue(aposToQuotes(\"{'value':28, 'next':{'value':29}}\"),\n+                Identifiable.class);\n+        assertNotNull(result);\n+        assertEquals(28, result.value);\n+        assertNotNull(result.next);\n+        assertEquals(29, result.next.value);\n+    }\n+    \n     public void testSimpleUUIDForClassRoundTrip() throws Exception\n     {\n         UUIDNode root = new UUIDNode(1);\n         }\n     }\n \n-    public void testKeepCollectionOrdering()\n-        throws Exception\n+    public void testKeepCollectionOrdering() throws Exception\n     {\n         String json = \"{\\\"employees\\\":[2,1,\"\n                 + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n     static abstract class Base\n     {\n         public int value;\n+        public Base next;\n \n-        public Base next;\n-        \n         public Base() { this(0); }\n         public Base(int v) {\n             value = v;\n         public int id;\n         public Base811 owner;\n             \n-        private Base811() {}\n+        protected Base811() {}\n         public Base811(Process owner) {\n             this.owner = owner;\n             if (owner == null) {\n                 super(owner);\n                 this.parent = parent;\n         }\n-        private Activity() {\n-                super();\n+        protected Activity() {\n+            super();\n         }\n     }\n     \n         public Scope(Process owner, Activity parent) {\n             super(owner, parent);\n         }\n-        private Scope() {\n+        protected Scope() {\n             super();\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n         public String bar = null;\n         public String foo = \"bar\";\n     }\n-    \n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class AsArrayWithMap\n+    {\n+        public Map<Integer,Integer> attrs;\n+\n+        public AsArrayWithMap() { }\n+        public AsArrayWithMap(int x, int y) {\n+            attrs = new HashMap<Integer,Integer>();\n+            attrs.put(x, y);\n+        }\n+    }\n+\n     /*\n     /*****************************************************\n     /* Basic tests\n         assertNotNull(result);\n         assertEquals(\"foobar\", result.name);\n     }\n-    \n+\n     /*\n     /*****************************************************\n     /* Round-trip tests\n         mapper2.setAnnotationIntrospector(new ForceArraysIntrospector());\n         assertEquals(\"[[1,2]]\", mapper2.writeValueAsString(new A()));\n     }\n+\n+    public void testWithMaps() throws Exception\n+    {\n+        AsArrayWithMap input = new AsArrayWithMap(1, 2);\n+        String json = MAPPER.writeValueAsString(input);\n+        AsArrayWithMap output = MAPPER.readValue(json, AsArrayWithMap.class);\n+        assertNotNull(output);\n+        assertNotNull(output.attrs);\n+        assertEquals(1, output.attrs.size());\n+        assertEquals(Integer.valueOf(2), output.attrs.get(1));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n package com.fasterxml.jackson.databind.struct;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n         public int b;\n         public int c;\n     }\n-    \n+\n     /*\n     /*****************************************************\n     /* Basic tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestParentChildReferences.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestParentChildReferences\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First, a simple 'tree': just parent/child linkage\n+     */\n+    static class SimpleTreeNode\n+    {\n+        public String name;\n+        \n+        // Reference back to parent; reference, ignored during ser,\n+        // re-constructed during deser\n+        @JsonBackReference\n+        public SimpleTreeNode parent;\n+\n+        // Reference that is serialized normally during ser, back\n+        // reference within pointed-to instance assigned to point to\n+        // referring bean (\"this\")\n+        @JsonManagedReference\n+        public SimpleTreeNode child;\n+\n+        public SimpleTreeNode() { this(null); }\n+        public SimpleTreeNode(String n) { name = n; }\n+    }\n+\n+    static class SimpleTreeNode2\n+    {\n+        public String name;\n+        protected SimpleTreeNode2 parent;\n+        protected SimpleTreeNode2 child;\n+\n+        public SimpleTreeNode2() { this(null); }\n+        public SimpleTreeNode2(String n) { name = n; }\n+\n+        @JsonBackReference\n+        public SimpleTreeNode2 getParent() { return parent; }\n+        public void setParent(SimpleTreeNode2 p) { parent = p; }\n+\n+        @JsonManagedReference\n+        public SimpleTreeNode2 getChild() { return child; }\n+        public void setChild(SimpleTreeNode2 c) { child = c; }\n+    }\n+    \n+    /**\n+     * Then nodes with two separate linkages; parent/child\n+     * and prev/next-sibling\n+     */\n+    static class FullTreeNode\n+    {\n+        public String name;\n+\n+        // parent-child links\n+        @JsonBackReference(\"parent\")\n+        public FullTreeNode parent;\n+        @JsonManagedReference(\"parent\")\n+        public FullTreeNode firstChild;\n+\n+        // sibling-links\n+        @JsonManagedReference(\"sibling\")\n+        public FullTreeNode next;\n+        @JsonBackReference(\"sibling\")\n+        protected FullTreeNode prev;\n+        \n+        public FullTreeNode() { this(null); }\n+        public FullTreeNode(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing managed references via arrays\n+     */\n+    static class NodeArray\n+    {\n+        @JsonManagedReference(\"arr\")\n+        public ArrayNode[] nodes;\n+    }\n+\n+    static class ArrayNode\n+    {\n+        public String name;\n+        \n+        @JsonBackReference(\"arr\")\n+        public NodeArray parent;\n+\n+        public ArrayNode() { this(null); }\n+        public ArrayNode(String n) { name = n; }\n+    }\n+    \n+    /**\n+     * Class for testing managed references via Collections\n+     */\n+    static class NodeList\n+    {\n+        @JsonManagedReference\n+        public List<NodeForList> nodes;\n+    }\n+\n+    static class NodeForList\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeList parent;\n+\n+        public NodeForList() { this(null); }\n+        public NodeForList(String n) { name = n; }\n+    }\n+    \n+    static class NodeMap\n+    {\n+        @JsonManagedReference\n+        public Map<String,NodeForMap> nodes;\n+    }\n+\n+    static class NodeForMap\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeMap parent;\n+\n+        public NodeForMap() { this(null); }\n+        public NodeForMap(String n) { name = n; }\n+    }\n+\n+    public static class Parent {\n+        @JsonManagedReference\n+        protected final List<Child> children = new ArrayList<Child>();\n+\n+        public List<Child> getChildren() { return children; }\n+\n+        public void addChild(Child child) { children.add(child); child.setParent(this); }\n+    }\n+\n+    public static class Child {\n+        protected Parent parent;\n+        protected final String value; // So that the bean is not empty of properties\n+\n+        public Child(@JsonProperty(\"value\") String value) { this.value = value; }\n+\n+        public String getValue() { return value; }\n+\n+        @JsonBackReference\n+        public Parent getParent() { return parent; }\n+\n+        public void setParent(Parent parent) { this.parent = parent; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+    \n+    // [JACKSON-708]\n+    static class Model708 { }\n+    \n+    static class Advertisement708 extends Model708 {\n+        public String title;\n+        @JsonManagedReference public List<Photo708> photos;\n+    }\n+\n+    static class Photo708 extends Model708 {\n+        public int id;\n+        @JsonBackReference public Advertisement708 advertisement;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimpleRefs() throws Exception\n+    {\n+        SimpleTreeNode root = new SimpleTreeNode(\"root\");\n+        SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+\n+    // [JACKSON-693]\n+    public void testSimpleRefsWithGetter() throws Exception\n+    {\n+        SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n+        SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode2 resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+    \n+    public void testFullRefs() throws Exception\n+    {\n+        FullTreeNode root = new FullTreeNode(\"root\");\n+        FullTreeNode child1 = new FullTreeNode(\"kid1\");\n+        FullTreeNode child2 = new FullTreeNode(\"kid2\");\n+        root.firstChild = child1;\n+        child1.parent = root;\n+        child1.next = child2;\n+        child2.prev = child1;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        FullTreeNode resultChild = resultNode.firstChild;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid1\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+\n+        // and then sibling linkage\n+        assertNull(resultChild.prev);\n+        FullTreeNode resultChild2 = resultChild.next;\n+        assertNotNull(resultChild2);\n+        assertEquals(\"kid2\", resultChild2.name);\n+        assertSame(resultChild, resultChild2.prev);\n+        assertNull(resultChild2.next);\n+    }\n+\n+    public void testArrayOfRefs() throws Exception\n+    {\n+        NodeArray root = new NodeArray();\n+        ArrayNode node1 = new ArrayNode(\"a\");\n+        ArrayNode node2 = new ArrayNode(\"b\");\n+        root.nodes = new ArrayNode[] { node1, node2 };\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n+        ArrayNode[] kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.length);\n+        assertEquals(\"a\", kids[0].name);\n+        assertEquals(\"b\", kids[1].name);\n+        assertSame(result, kids[0].parent);\n+        assertSame(result, kids[1].parent);\n+    }\n+\n+    public void testListOfRefs() throws Exception\n+    {\n+        NodeList root = new NodeList();\n+        NodeForList node1 = new NodeForList(\"a\");\n+        NodeForList node2 = new NodeForList(\"b\");\n+        root.nodes = Arrays.asList(node1, node2);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n+        List<NodeForList> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertEquals(\"a\", kids.get(0).name);\n+        assertEquals(\"b\", kids.get(1).name);\n+        assertSame(result, kids.get(0).parent);\n+        assertSame(result, kids.get(1).parent);\n+    }\n+\n+    public void testMapOfRefs() throws Exception\n+    {\n+        NodeMap root = new NodeMap();\n+        NodeForMap node1 = new NodeForMap(\"a\");\n+        NodeForMap node2 = new NodeForMap(\"b\");\n+        Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();\n+        nodes.put(\"a1\", node1);\n+        nodes.put(\"b2\", node2);\n+        root.nodes = nodes;\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n+        Map<String,NodeForMap> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertNotNull(kids.get(\"a1\"));\n+        assertNotNull(kids.get(\"b2\"));\n+        assertEquals(\"a\", kids.get(\"a1\").name);\n+        assertEquals(\"b\", kids.get(\"b2\").name);\n+        assertSame(result, kids.get(\"a1\").parent);\n+        assertSame(result, kids.get(\"b2\").parent);\n+    }\n+\n+    // for [JACKSON-368]\n+    public void testAbstract368() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n+\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(root, leaf.prev);\n+    }\n+    \n+    public void testIssue693() throws Exception\n+    {\n+        Parent parent = new Parent();\n+        parent.addChild(new Child(\"foo\"));\n+        parent.addChild(new Child(\"bar\"));\n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n+        for (Child child : value.children) {\n+            assertEquals(value, child.getParent());\n+        }\n+    }\n+\n+    public void testIssue708() throws Exception\n+    {\n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        assertNotNull(ad);\n+    }   \n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n         public String first, last;\n     }\n \n+    // [databind#615]\n+    static class Parent {\n+        @JsonUnwrapped\n+        public Child c1;\n+\n+        public Parent() { }\n+        public Parent(String str) { c1 = new Child(str); }\n+    }\n+\n+    static class Child {\n+        public String field;\n+\n+        public Child() { }\n+        public Child(String f) { field = f; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests, serialization\n         assertEquals(2, loc.y);\n     }\n \n+    public void testIssue615() throws Exception\n+    {\n+        Parent input = new Parent(\"name\");\n+        String json = MAPPER.writeValueAsString(input);\n+        Parent output = MAPPER.readValue(json, Parent.class);\n+        assertEquals(\"name\", output.c1.field);\n+    }\n+\n     // 22-Apr-2013, tatu: Commented out as it can't be simply fixed; requires implementing\n     //    deep-update/merge. But leaving here to help with that effort, if/when it proceeds.\n-    \n+\n     /*\n-    \n     // [Issue#211]: Actually just variant of #160\n-    \n+\n     static class Issue211Bean {\n         public String test1;\n \n         public String test3;\n         public String test4;\n     }\n-    \n+\n     public void testIssue211() throws Exception\n     {\n          Issue211Bean bean = new Issue211Bean();\n          assertNotNull(result.unwrapped);\n          assertEquals(\"Field 3 merged\", result.unwrapped.test3);\n          assertEquals(\"Field 4\", result.unwrapped.test4);\n-    }  \n+    }\n     */\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n         \n         // but with different views, different contents\n         bean = mapper.readerWithView(ViewAA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":3, \\\"aa\\\":\\\"foo\\\", \\\"b\\\": 9 }\");\n         // should include 'a' and 'aa' (as per view)\n         assertEquals(3, bean.a);\n         assertEquals(0, bean.b);\n \n         bean = mapper.readerWithView(ViewA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"aa\\\":\\\"x\\\", \\\"b\\\": 3 }\");\n         assertEquals(1, bean.a);\n         assertNull(bean.aa);\n \n         // but with, say, AA, will not get 'b'\n         bean = myMapper.readerWithView(ViewAA.class)\n-                .withType(DefaultsBean.class)\n+                .forType(DefaultsBean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"b\\\": 2 }\");\n         // 'a' not there any more\n         assertEquals(0, bean.a);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n         public final int p;\n \n         @JsonCreator\n-        private Pojo(@JsonProperty(\"p\") int p) {\n+        Pojo(@JsonProperty(\"p\") int p) {\n             this.p = p;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestLocalType609.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Failing test related to [databind#609]\n+ */\n+public class TestLocalType609 extends BaseMapTest\n+{\n+    static class EntityContainer {\n+        RuleForm entity;\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        public <T extends RuleForm> T getEntity() { return (T) entity; }\n+        public <T extends RuleForm> void setEntity(T e) { entity = e; }\n+    }\n+\n+    static class RuleForm {\n+        public int value;\n+\n+        public RuleForm() { }\n+        public RuleForm(int v) { value = v; }\n+    }\n+\n+    public void testLocalPartialType609() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        \n+        EntityContainer input = new EntityContainer(); \n+        input.entity = new RuleForm(12);\n+        String json = mapper.writeValueAsString(input);\n+        \n+        EntityContainer output = mapper.readValue(json, EntityContainer.class);\n+        assertEquals(12, output.getEntity().value);\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n package com.fasterxml.jackson.failing;\n \n import java.util.HashMap;\n-import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n         }\n     }\n \n+    @SuppressWarnings(\"serial\")\n+    static class WatMap extends HashMap<Wat,Boolean> { }\n+    \n     public void testMapJsonValueKey()\n     throws Exception\n     {\n-        Map<Wat, Boolean> input = new HashMap<Wat, Boolean>();\n+        WatMap input = new WatMap();\n         input.put(new Wat(\"3\"), true);\n \n         ObjectMapper mapper = new ObjectMapper();\n--- a/src/test/java/com/fasterxml/jackson/failing/TestObjectIdWithInjectables538.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdWithInjectables538.java\n         A output = null;\n \n         try {\n-            output = MAPPER.reader(inject).withType(A.class).readValue(json);\n+            output = MAPPER.reader(inject).forType(A.class).readValue(json);\n         } catch (Exception e) {\n             throw new IllegalStateException(\"Failed to deserialize from JSON '\"+json+\"'\", e);\n         }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n public class TestUnwrappedWithCreator extends BaseMapTest\n {\n     static class JAddress {\n-        private String address;\n-        private String city;\n-        private String state;\n+        protected String address;\n+        protected String city;\n+        protected String state;\n          \n         @JsonCreator\n-        public JAddress(\n-                @JsonProperty(\"address\") String address,\n+        public JAddress( @JsonProperty(\"address\") String address,\n                 @JsonProperty(\"city\") String city,\n                 @JsonProperty(\"state\") String state\n         ){\n     }\n \n     static class JPerson {\n-        private String _name;\n-        private JAddress _address;\n-        private String _alias;\n+        protected String _name;\n+        protected JAddress _address;\n+        protected String _alias;\n          \n         @JsonCreator\n-        public JPerson(\n-        @JsonProperty(\"name\") String name,\n+        public JPerson(@JsonProperty(\"name\") String name,\n         @JsonUnwrapped JAddress address,\n-        @JsonProperty(\"alias\") String alias\n-        ) {\n+        @JsonProperty(\"alias\") String alias) {\n             _name = name;\n             _address = address;\n             _alias = alias;\n--- a/src/test/java/perf/ObjectReaderTestBase.java\n+++ b/src/test/java/perf/ObjectReaderTestBase.java\n         System.out.print(\"Warming up\");\n \n         final ObjectReader jsonReader = mapper1.reader()\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n \n         final ObjectReader jsonReader = mapper1.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n--- a/src/test/java/perf/ObjectWriterTestBase.java\n+++ b/src/test/java/perf/ObjectWriterTestBase.java\n         }\n \n         final ObjectWriter writer0 = mapper.writer().with(SerializationFeature.EAGER_SERIALIZER_FETCH);\n-        final ObjectWriter writer1 = writer0.withType(inputClass1);\n-        final ObjectWriter writer2 = writer0.withType(inputClass2);\n+        final ObjectWriter writer1 = writer0.forType(inputClass1);\n+        final ObjectWriter writer2 = writer0.forType(inputClass2);\n         \n         int i = 0;\n         int roundsDone = 0;", "timestamp": 1418354050, "metainfo": ""}