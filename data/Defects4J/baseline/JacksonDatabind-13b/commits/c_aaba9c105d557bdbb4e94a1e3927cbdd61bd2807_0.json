{"sha": "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807", "log": "Completed (?) major refactoring to give necessary context for Resolvable Serializers, Deserializers.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n      * @return Serializer instance to use\n      */\n     public abstract JsonSerializer<?> serializerInstance(SerializationConfig config,\n-            Annotated annotated, Class<? extends JsonSerializer<?>> serClass);\n+            Annotated annotated, Class<?> serClass);\n \n     /**\n      * Method called to get an instance of TypeResolverBuilder of specified type.\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.databind.cfg.*;\n-import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Object that contains baseline configuration for serialization\n     public <T extends BeanDescription> T introspect(JavaType type) {\n         return (T) getClassIntrospector().forSerialization(this, type, this);\n     }\n-\n+    \n     /*\n     /**********************************************************\n-    /* Extended API: serializer instantiation\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> serializerInstance(Annotated annotated, Class<?> serClass)\n-    {\n-        HandlerInstantiator hi = getHandlerInstantiator();\n-        if (hi != null) {\n-            JsonSerializer<?> ser = hi.serializerInstance(this, annotated,\n-                    (Class<JsonSerializer<?>>)serClass);\n-            if (ser != null) {\n-                return (JsonSerializer<Object>) ser;\n-            }\n-        }\n-        return (JsonSerializer<Object>) ClassUtil.createInstance(serClass, canOverrideAccessModifiers());\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Debug support\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n      *\n      * @param type The type for which to generate schema\n      */\n-    public abstract JsonSchema generateJsonSchema(Class<?> type, SerializationConfig config, SerializerFactory jsf)\n+    public abstract JsonSchema generateJsonSchema(Class<?> type,\n+            SerializationConfig config, SerializerFactory jsf)\n         throws JsonMappingException;\n \n     /**\n      */\n     public final boolean isEnabled(SerializationConfig.Feature feature) {\n         return _config.isEnabled(feature);\n+    }\n+\n+    /**\n+     * Convenience method for accessing serialization view in use (if any); equivalent to:\n+     *<pre>\n+     *   getConfig().canOverrideAccessModifiers();\n+     *</pre>\n+     */\n+    public final boolean canOverrideAccessModifiers() {\n+        return _config.canOverrideAccessModifiers();\n+    }\n+    \n+    /**\n+     * Convenience method for accessing serialization view in use (if any); equivalent to:\n+     *<pre>\n+     *   getConfig().getAnnotationIntrospector();\n+     *</pre>\n+     */\n+    public final AnnotationIntrospector getAnnotationIntrospector() {\n+        return _config.getAnnotationIntrospector();\n     }\n     \n     /**\n      */\n     public abstract JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType);\n \n+\n+    /*\n+    /**********************************************************\n+    /* Methods for creating instances based on annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to construct and configure serializer instance,\n+     * either given a {@link Class} to instantiate (with default constructor),\n+     * or an uninitialized serializer instance.\n+     * Either way, serialize will be properly resolved\n+     * (via {@link com.fasterxml.jackson.databind.ser.ResolvableSerializer}) and/or contextualized\n+     * (via {@link com.fasterxml.jackson.databind.ser.ContextualSerializer}) as necessary.\n+     * \n+     * @param annotated Annotated entity that contained definition\n+     * @param serDef Serializer definition: either an instance or class\n+     */\n+    public abstract JsonSerializer<Object> serializerInstance(Annotated annotated,\n+            BeanProperty property, Object serDef)\n+        throws JsonMappingException;\n+    \n     /*\n     /********************************************************\n     /* Convenience methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n \n     // Implemented by sub-classes\n     @Override\n-    public abstract JsonSerializer<Object> createSerializer(SerializationConfig config,\n+    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> createKeySerializer(SerializationConfig config,\n+    public JsonSerializer<Object> createKeySerializer(SerializerProvider prov,\n             JavaType type, BeanProperty property)\n     {\n         // Minor optimization: to avoid constructing beanDesc, bail out if none registered\n         if (!_factoryConfig.hasKeySerializers()) {\n             return null;\n         }\n-        \n+\n+        final SerializationConfig config = prov.getConfig();\n         // We should not need any member method info; at most class annotations for Map type\n         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n         JsonSerializer<?> ser = null;\n      * This does not include \"secondary\" interfaces, but\n      * mostly concrete or abstract base classes.\n      */\n-    protected final JsonSerializer<?> findSerializerByPrimaryType(JavaType type,\n-            SerializationConfig config, BeanDescription beanDesc, BeanProperty property,\n+    protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, \n+            JavaType type, BeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n         if (valueMethod != null) {\n             // [JACKSON-586]: need to ensure accessibility of method\n             Method m = valueMethod.getAnnotated();\n-            if (config.canOverrideAccessModifiers()) {\n+            if (prov.canOverrideAccessModifiers()) {\n                 ClassUtil.checkAndFixAccess(m);\n             }\n-            JsonSerializer<Object> ser = findSerializerFromAnnotation(config, valueMethod, property);\n+            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod, property);\n             return new JsonValueSerializer(m, ser, property);\n         }\n         \n         }\n         \n         // Then check for optional/external serializers [JACKSON-386]\n-        JsonSerializer<?> ser = optionalHandlers.findSerializer(config, type);\n+        JsonSerializer<?> ser = optionalHandlers.findSerializer(prov.getConfig(), type);\n         if (ser != null) {\n             return ser;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n             @SuppressWarnings(\"unchecked\")\n             Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n-            return EnumSerializer.construct(enumClass, config, beanDesc);\n+            return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc);\n         }\n         if (Calendar.class.isAssignableFrom(raw)) {\n             return CalendarSerializer.instance;\n      * that tells the class to use for serialization.\n      * Returns null if no such annotation found.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializationConfig config, Annotated a,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        Object serDef = config.getAnnotationIntrospector().findSerializer(a);\n+    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,\n+            Annotated a, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n         if (serDef == null) {\n             return null;\n         }\n-        if (serDef instanceof JsonSerializer) {\n-            JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n-            if (ser instanceof ContextualSerializer<?>) {\n-                return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n-            }\n-            return ser;\n-        }\n-        /* Alas, there's no way to force return type of \"either class\n-         * X or Y\" -- need to throw an exception after the fact\n-         */\n-        if (!(serDef instanceof Class)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned value of type \"+serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n-        }\n-        Class<?> cls = (Class<?>) serDef;\n-        if (!JsonSerializer.class.isAssignableFrom(cls)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+cls.getName()+\"; expected Class<JsonSerializer>\");\n-        }\n-        JsonSerializer<Object> ser = config.serializerInstance(a, (Class<? extends JsonSerializer<?>>) cls);\n-        if (ser instanceof ContextualSerializer<?>) {\n-            return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n-        }\n-        return ser;\n+        return prov.serializerInstance(a, property, serDef);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    protected JsonSerializer<?> buildContainerSerializer(SerializationConfig config, JavaType type,\n-            BeanDescription beanDesc, BeanProperty property, boolean staticTyping)\n-        throws JsonMappingException\n-    {\n+    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n+            JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping)\n+        throws JsonMappingException\n+    {\n+        final SerializationConfig config = prov.getConfig();\n         // Let's see what we can learn about element/content/value type, type serializer for it:\n         JavaType elementType = type.getContentType();\n-        TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType, property);\n+        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n+                elementType, property);\n         \n         // if elements have type serializer, can not force static typing:\n         if (elementTypeSerializer != null) {\n         } else if (!staticTyping) {\n             staticTyping = usesStaticTyping(config, beanDesc, elementTypeSerializer, property);\n         }\n-        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(config,\n+        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                 beanDesc.getClassInfo(), property);\n         \n         if (type.isMapLikeType()) { // implements java.util.Map\n             MapLikeType mlt = (MapLikeType) type;\n-            JsonSerializer<Object> keySerializer = _findKeySerializer(config, beanDesc.getClassInfo(), property);\n+            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo(), property);\n             if (mlt.isTrueMapType()) {\n                 return buildMapSerializer(config, (MapType) mlt, beanDesc, property, staticTyping,\n                         keySerializer, elementTypeSerializer, elementValueSerializer);\n         return type;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonSerializer<Object> _findKeySerializer(SerializationConfig config,\n+    protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov,\n             Annotated a, BeanProperty property)\n         throws JsonMappingException\n     {\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Object serDef = null;\n+        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n \n         // Start with property (more specific); if not found, then find from type\n         if (property != null) {\n             AnnotatedMember m = property.getMember();\n             if (m != null) {\n-                serDef = intr.findKeySerializer(m);\n-            }\n-        }\n-        if (serDef == null) {\n-            serDef = intr.findKeySerializer(a);\n-        }\n-\n-        // ok, what did we get?\n+                Object serDef = intr.findKeySerializer(m);\n+                if (serDef != null) {\n+                    return prov.serializerInstance(m, property, serDef);\n+                }\n+            }\n+        }\n+        Object serDef = intr.findKeySerializer(a);\n         if (serDef != null) {\n-            JsonSerializer<?> ser = null;\n-            if (serDef instanceof JsonSerializer<?>) {\n-                ser = (JsonSerializer<Object>) serDef;\n-            } else {\n-                Class<?> serClass = _verifyAsClass(serDef, \"findKeySerializer\", JsonSerializer.None.class);\n-                if (serClass != null) {\n-                    return config.serializerInstance(a, serClass);\n-                }\n-            }\n-            if (ser instanceof ContextualSerializer<?>) {\n-                ser = ((ContextualSerializer<Object>) ser).createContextual(config, property);\n-            }\n-            return (JsonSerializer<Object>) ser;\n+            return prov.serializerInstance(a, property, serDef);\n         }\n         return null;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonSerializer<Object> _findContentSerializer(SerializationConfig config,\n+    protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,\n             Annotated a, BeanProperty property)\n         throws JsonMappingException\n     {\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Object serDef = null;\n+        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n \n         // Start with property (more specific); if not found, then find from type\n         if (property != null) {\n             AnnotatedMember m = property.getMember();\n             if (m != null) {\n-                serDef = intr.findContentSerializer(m);\n-            }\n-        }\n-        if (serDef == null) {\n-            serDef = intr.findContentSerializer(a);\n-        }\n-\n-        // ok, what did we get?\n+                Object serDef = intr.findContentSerializer(m);\n+                if (serDef != null) {\n+                    return prov.serializerInstance(m, property, serDef);\n+                }\n+            }\n+        }\n+        Object serDef = intr.findContentSerializer(a);\n         if (serDef != null) {\n-            JsonSerializer<?> ser = null;\n-            if (serDef instanceof JsonSerializer<?>) {\n-                ser = (JsonSerializer<Object>) serDef;\n-            } else {\n-                Class<?> serClass = _verifyAsClass(serDef, \"findContentSerializer\", JsonSerializer.None.class);\n-                if (serClass != null) {\n-                    ser = config.serializerInstance(a, serClass);\n-                }\n-            }\n-            if (ser instanceof ContextualSerializer<?>) {\n-                ser = ((ContextualSerializer<Object>) ser).createContextual(config, property);\n-            }\n-            return (JsonSerializer<Object>) ser;\n+            return prov.serializerInstance(a, property, serDef);\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType origType,\n+    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n+            JavaType origType,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n         // Very first thing, let's check if there is explicit serializer annotation:\n+        final SerializationConfig config = prov.getConfig();\n         BeanDescription beanDesc = config.introspect(origType);\n-        JsonSerializer<?> ser = findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n         if (ser != null) {\n             return (JsonSerializer<Object>) ser;\n         }\n         \n         // Container types differ from non-container types:\n         if (origType.isContainerType()) {\n-            return (JsonSerializer<Object>) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n+            return (JsonSerializer<Object>) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n         }\n \n         // Modules may provide serializers of all types:\n          */\n         ser = findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n         if (ser == null) {\n-            ser = findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n+            ser = findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n             if (ser == null) {\n                 /* And this is where this class comes in: if type is not a\n                  * known \"primary JDK type\", perhaps it's a bean? We can still\n                  * get a null, if we can't find a single suitable bean property.\n                  */\n-                ser = findBeanSerializer(config, type, beanDesc, property);\n+                ser = findBeanSerializer(prov, type, beanDesc, property);\n                 /* Finally: maybe we can still deal with it as an\n                  * implementation of some basic JDK interface?\n                  */\n      * given class. Returns null if no properties are found.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> findBeanSerializer(SerializationConfig config, JavaType type,\n-            BeanDescription beanDesc, BeanProperty property)\n+    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov,\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First things first: we know some types are not beans...\n         if (!isPotentialBeanType(type.getRawClass())) {\n             return null;\n         }\n-        JsonSerializer<Object> serializer = constructBeanSerializer(config, beanDesc, property);\n+        JsonSerializer<Object> serializer = constructBeanSerializer(prov, beanDesc, property);\n         // [JACKSON-440] Need to allow overriding actual serializer, as well...\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-                serializer = (JsonSerializer<Object>)mod.modifySerializer(config, beanDesc, serializer);\n+                serializer = (JsonSerializer<Object>)mod.modifySerializer(prov.getConfig(),\n+                        beanDesc, serializer);\n             }\n         }\n         return serializer;\n      * Method called to construct serializer for serializing specified bean type.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected JsonSerializer<Object> constructBeanSerializer(SerializationConfig config,\n+    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n             BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         if (beanDesc.getBeanClass() == Object.class) {\n             throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n         }\n-        \n+\n+        final SerializationConfig config = prov.getConfig();\n         BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n         \n         // First: any detectable (auto-detect, annotations) properties to serialize?\n-        List<BeanPropertyWriter> props = findBeanProperties(config, beanDesc);\n+        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc);\n \n         if (props == null) {\n             props = new ArrayList<BeanPropertyWriter>();\n      * Method used to collect all actual serializable properties.\n      * Can be overridden to implement custom detection schemes.\n      */\n-    protected List<BeanPropertyWriter> findBeanProperties(SerializationConfig config, BeanDescription beanDesc)\n+    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n+            BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n         List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n+        final SerializationConfig config = prov.getConfig();\n \n         // [JACKSON-429]: ignore specified types\n         removeIgnorableTypes(config, beanDesc, properties);\n             }\n             String name = property.getName();\n             if (accessor instanceof AnnotatedMethod) {\n-                result.add(_constructWriter(config, typeBind, pb, staticTyping, name, (AnnotatedMethod) accessor));\n+                result.add(_constructWriter(prov, typeBind, pb, staticTyping, name, (AnnotatedMethod) accessor));\n             } else {\n-                result.add(_constructWriter(config, typeBind, pb, staticTyping, name, (AnnotatedField) accessor));\n+                result.add(_constructWriter(prov, typeBind, pb, staticTyping, name, (AnnotatedField) accessor));\n             }\n         }\n         return result;\n      * Secondary helper method for constructing {@link BeanPropertyWriter} for\n      * given member (field or method).\n      */\n-    protected BeanPropertyWriter _constructWriter(SerializationConfig config, TypeBindings typeContext,\n+    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n+            TypeBindings typeContext,\n             PropertyBuilder pb, boolean staticTyping, String name, AnnotatedMember accessor)\n         throws JsonMappingException\n     {\n-        if (config.canOverrideAccessModifiers()) {\n+        if (prov.canOverrideAccessModifiers()) {\n             accessor.fixAccess();\n         }\n         JavaType type = accessor.getType(typeContext);\n         BeanProperty.Std property = new BeanProperty.Std(name, type, pb.getClassAnnotations(), accessor);\n \n         // Does member specify a serializer? If so, let's use it.\n-        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(config, accessor, property);\n+        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(prov, accessor, property);\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n         if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n-            contentTypeSer = findPropertyContentTypeSerializer(type, config, accessor, property);\n+            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor, property);\n         }\n \n         // and if not JAXB collection/array with annotations, maybe regular type info?\n-        TypeSerializer typeSer = findPropertyTypeSerializer(type, config, accessor, property);\n+        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor, property);\n         BeanPropertyWriter pbw = pb.buildWriter(name, type, annotatedSerializer,\n                         typeSer, contentTypeSer, accessor, staticTyping);\n         // how about views? (1.4+)\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n         pbw.setViews(intr.findSerializationViews(accessor));\n         return pbw;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContextualSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContextualSerializer.java\n package com.fasterxml.jackson.databind.ser;\n \n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.*;\n \n /**\n  * Add-on interface that {@link JsonSerializer}s can implement to get a callback\n      * and return a new instance. This instance should only be returned as-is, in case\n      * it is already suitable for use.\n      * \n-     * @param config Current serialization configuration\n+     * @param prov Serializer provider to use for accessing config, other serializers\n      * @param property Method or field that represents the property\n      *   (and is used to access value to serialize).\n      *   Should be available; but there may be cases where caller can not provide it and\n      * \n      * @throws JsonMappingException\n      */\n-    public JsonSerializer<T> createContextual(SerializationConfig config,\n+    public JsonSerializer<T> createContextual(SerializerProvider prov,\n             BeanProperty property)\n         throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n \n     /**\n       * Method called to create (or, for immutable serializers, reuse) a serializer for given type. \n+      * \n+      * @param prov Provider that needs to be used to resolve annotation-provided\n+      *    serializers (but NOT for others)\n       */\n-    public abstract JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType baseType,\n-            BeanProperty property)\n+    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,\n+            JavaType baseType, BeanProperty property)\n         throws JsonMappingException;\n     \n     /**\n      * \n      * @return Type serializer to use for the base type, if one is needed; null if not.\n      */\n-    public abstract TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType,\n-            BeanProperty property)\n+    public abstract TypeSerializer createTypeSerializer(SerializationConfig config,\n+            JavaType baseType, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * be output as <code>JsonToken.FIELD_NAME</code>) for Map that has specified declared\n      * key type, and is for specified property (or, if property is null, as root value)\n      * \n-     * @param config Serialization configuration in use\n      * @param baseType Declared type for Map keys\n      * @param property Property that contains Map being serialized; null when serializing root Map value.\n      * \n      * @return Serializer to use, if factory knows it; null if not (in which case default serializer\n      *   is to be used)\n      */\n-    public abstract JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType baseType,\n-            BeanProperty property)\n+    public abstract JsonSerializer<Object> createKeySerializer(SerializerProvider prov,\n+            JavaType baseType, BeanProperty property)\n         throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n     @Override\n     public boolean hasSerializerFor(SerializationConfig config,\n-                                    Class<?> cls, SerializerFactory jsf)\n+            Class<?> cls, SerializerFactory jsf)\n     {\n         return createInstance(config, jsf)._findExplicitUntypedSerializer(cls, null) != null;\n     }\n                     }\n                 }\n             }\n-        }            \n-        return _handleContextualResolvable(ser, property);\n+        }\n+        // at this point, resolution has occured, but not contextualization\n+        return _handleContextual(ser, property);\n     }\n \n     /**\n                 }\n             }\n         }\n-        return _handleContextualResolvable(ser, property);\n+        return _handleContextual(ser, property);\n     }\n     \n     /**\n     public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property)\n         throws JsonMappingException\n     {\n-        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, property);\n+        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(this, keyType, property);\n \n         // First things first: maybe there are registered custom implementations\n         // if not, use default one:\n     @Override\n     public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n         return _unknownTypeSerializer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls, instantiating handlers\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n+            BeanProperty property, Object serDef)\n+        throws JsonMappingException\n+    {\n+        if (serDef == null) {\n+            return null;\n+        }\n+        JsonSerializer<?> ser;\n+        \n+        if (serDef instanceof JsonSerializer) {\n+            ser = (JsonSerializer<?>) serDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n+                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>)serDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                ser = hi.serializerInstance(_config, annotated, serClass);\n+            } else {\n+                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        return (JsonSerializer<Object>) _handleContextualResolvable(ser, property);\n     }\n     \n     /*\n          *   and keep track of creation chain to look for loops -- fairly\n          *   easy to do, but won't add yet since it seems unnecessary.\n          */\n-        return (JsonSerializer<Object>)_serializerFactory.createSerializer(_config, type, property);\n+        return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type, property);\n+    }\n+\n+    /**\n+     * Helper method called to resolve and contextualize given\n+     * serializer, if and as necessary.\n+     */\n+    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (ser instanceof ResolvableSerializer) {\n+            ((ResolvableSerializer) ser).resolve(this);\n+        }\n+        return _handleContextual(ser, property);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<Object> ser,\n+    protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n-        if (!(ser instanceof ContextualSerializer<?>)) {\n-            return ser;\n-        }\n-        JsonSerializer<Object> ctxtSer = ((ContextualSerializer<Object>) ser).createContextual(_config, property);\n-        if (ctxtSer != ser) {\n-            // need to re-resolve?\n-            if (ctxtSer instanceof ResolvableSerializer) {\n-                ((ResolvableSerializer) ctxtSer).resolve(this);\n-            }\n-            ser = ctxtSer;\n-        }\n-        return ser;\n+        if (ser instanceof ContextualSerializer<?>) {\n+            ser = ((ContextualSerializer<?>) ser).createContextual(this, property);\n+        }\n+        return (JsonSerializer<Object>) ser;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n-\n \n /**\n  * Simple cache object that allows for doing 2-level lookups: first level is\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n         \n         @Override\n         public JsonSerializer<?> serializerInstance(SerializationConfig config,\n-                Annotated annotated, Class<? extends JsonSerializer<?>> serClass)\n+                Annotated annotated, Class<?> serClass)\n         {\n             if (serClass == MyBeanSerializer.class) {\n                 return new MyBeanSerializer(_prefix);\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n /**\n  * Tests to ensure that we can do contextual key serializers and\n  * deserializers as well as value ser/deser.\n- * \n- * @since 1.8\n  */\n public class TestContextualKeyTypes extends BaseMapTest\n {\n         }\n     \n         @Override\n-        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+        public JsonSerializer<String> createContextual(SerializerProvider prov, BeanProperty property)\n             throws JsonMappingException\n         {\n             return new ContextualKeySerializer(_prefix+\":\");\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n         }\n \n         @Override\n-        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+        public JsonSerializer<String> createContextual(SerializerProvider prov, BeanProperty property)\n                 throws JsonMappingException\n         {\n             String prefix = \"UNKNOWN\";\n         extends JsonSerializer<String>\n         implements ContextualSerializer<String>, ResolvableSerializer\n     {\n-        protected boolean isContextual;\n-        protected boolean isResolved;\n-\n-        public ContextualAndResolvable() { this(false); }\n-        \n-        public ContextualAndResolvable(boolean contextual)\n+        protected int isContextual;\n+        protected int isResolved;\n+\n+        public ContextualAndResolvable() { this(0, 0); }\n+        \n+        public ContextualAndResolvable(int resolved, int contextual)\n         {\n             isContextual = contextual;\n-            isResolved = false;\n+            isResolved = resolved;\n         }\n         \n         @Override\n         }\n \n         @Override\n-        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+        public JsonSerializer<String> createContextual(SerializerProvider prov, BeanProperty property)\n                 throws JsonMappingException\n         {\n-            return new ContextualAndResolvable(true);\n+            return new ContextualAndResolvable(isResolved, isContextual+1);\n         }\n \n         @Override\n         public void resolve(SerializerProvider provider) {\n-            isResolved = true;\n+            ++isResolved;\n         }\n     }\n     \n         SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n         module.addSerializer(String.class, new ContextualAndResolvable());\n         mapper.registerModule(module);\n-        assertEquals(quote(\"contextual=true,resolved=true\"), mapper.writeValueAsString(\"abc\"));\n+        assertEquals(quote(\"contextual=1,resolved=1\"), mapper.writeValueAsString(\"abc\"));\n     }\n \n     public void testContextualArrayElement() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         public CustomJsonSerializerFactory() { super(null); }\n \n         @Override\n-        protected JsonSerializer<Object> constructBeanSerializer( SerializationConfig config, BeanDescription beanDesc,\n+        protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n+                BeanDescription beanDesc,\n                 BeanProperty property)\n             throws JsonMappingException\n         {                \n-            return new CustomJsonSerializer( super.constructBeanSerializer( config, beanDesc, property) );\n+            return new CustomJsonSerializer(super.constructBeanSerializer(prov, beanDesc, property) );\n         }\n     }\n ", "timestamp": 1327459904, "metainfo": ""}