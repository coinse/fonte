{"sha": "81c9937f244120b7505eb50bd659dbca42b2d69b", "log": "Javadoc cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n             ObjectIdInfo objectIdInfo)\n         throws JsonMappingException;\n     \n+    /**\n+     * @since 2.2\n+     */\n+    public abstract Converter<Object,Object> converterInstance(Annotated annotated,\n+            Object converterDef)\n+        throws JsonMappingException;\n+\n     /*\n     /********************************************************\n     /* Convenience methods\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Helper class used for handling details of creating handler instances (things\n             Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n+\n+    /**\n+     * Method called to construct a Converter instance used for specified class.\n+     * \n+     * @since 2.2\n+     */\n+    public Converter<?,?> converterInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     /**********************************************************\n      */\n     \n+    @SuppressWarnings(\"incomplete-switch\")\n     protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         // do we have it resolved?\n         Object pojo = roid.item;\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n+            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] (for \"\n+                    +_beanType+\") -- unresolved forward-reference?\");\n         }\n         return pojo;\n     }\n             final DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n      * Method called to deserialize POJO value from a JSON floating-point\n      * number.\n      */\n+    @SuppressWarnings(\"incomplete-switch\")\n     public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             return finishBuild(ctxt, deserializeFromObject(jp, ctxt));\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n+        default:\n+            throw ctxt.mappingException(getBeanClass());\n+        }\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n          * we must actually check for \"raw\" integers and doubles first, before\n          * calling type deserializer.\n          */\n+        @SuppressWarnings(\"incomplete-switch\")\n         @Override\n         public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n                                           TypeDeserializer typeDeserializer)\n     {\n         public BigIntegerDeserializer() { super(BigInteger.class); }\n \n-        @Override\n-                public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)\n+        @SuppressWarnings(\"incomplete-switch\")\n+        @Override\n+        public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n         {\n             JsonToken t = jp.getCurrentToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n         switch (jp.getCurrentToken()) {\n         case START_OBJECT:\n             return mapObject(jp, ctxt);\n-        case END_OBJECT: // invalid\n-            break;\n         case START_ARRAY:\n             return mapArray(jp, ctxt);\n-        case END_ARRAY: // invalid\n-            break;\n         case FIELD_NAME:\n             return mapObject(jp, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n \n         case VALUE_NULL: // should not get this but...\n             return null;\n-            \n-         }\n-\n-        throw ctxt.mappingException(Object.class);\n+\n+        case END_ARRAY: // invalid\n+        case END_OBJECT: // invalid\n+        default:\n+            throw ctxt.mappingException(Object.class);\n+        }\n     }\n \n     @Override\n \n         case VALUE_NULL: // should not get this far really but...\n             return null;\n-        }\n-        throw ctxt.mappingException(Object.class);\n+        default:\n+            throw ctxt.mappingException(Object.class);\n+        }\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n \t        return withIsGetterVisibility(v);\n             case ALL:\n                 return with(v);\n-            //case NONE:\n+        //case NONE:\n+        default:\n             // break;\n+            return this;\n \t    }\n-            return this;\n \t}\n \t\n //      @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n         return deserializeIfNatural(jp, ctxt, baseType.getRawClass());\n     }\n     \n+    @SuppressWarnings(\"incomplete-switch\")\n     public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n             Class<?> base)\n         throws IOException, JsonProcessingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Standard implementation used by {@link ObjectMapper}:\n     /* Object Id handling\n     /**********************************************************\n      */\n+    \n+    @Override\n+    public WritableObjectId findObjectId(Object forPojo,\n+            ObjectIdGenerator<?> generatorType)\n+    {\n+        if (_seenObjectIds == null) {\n+            _seenObjectIds = new IdentityHashMap<Object,WritableObjectId>();\n+        } else {\n+            WritableObjectId oid = _seenObjectIds.get(forPojo);\n+            if (oid != null) {\n+                return oid;\n+            }\n+        }\n+        // Not seen yet; must add an entry, return it. For that, we need generator\n+        ObjectIdGenerator<?> generator = null;\n+        \n+        if (_objectIdGenerators == null) {\n+            _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8);\n+        } else {\n+            for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) {\n+                ObjectIdGenerator<?> gen = _objectIdGenerators.get(i);\n+                if (gen.canUseFor(generatorType)) {\n+                    generator = gen;\n+                    break;\n+                }\n+            }\n+        }\n+        if (generator == null) {\n+            generator = generatorType.newForSerialization(this);\n+            _objectIdGenerators.add(generator);\n+        }\n+        WritableObjectId oid = new WritableObjectId(generator);\n+        _seenObjectIds.put(forPojo, oid);\n+        return oid;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory method impls\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n+            Object serDef)\n+        throws JsonMappingException\n+    \n+    {\n+        if (serDef == null) {\n+            return null;\n+        }\n+        JsonSerializer<?> ser;\n+        \n+        if (serDef instanceof JsonSerializer) {\n+            ser = (JsonSerializer<?>) serDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n+                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>)serDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass);\n+            if (ser == null) {\n+                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        return (JsonSerializer<Object>) _handleResolvable(ser);\n+    }\n \n     @Override\n     public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n         return gen.forScope(objectIdInfo.getScope());\n     }\n     \n-    @Override\n-    public WritableObjectId findObjectId(Object forPojo,\n-            ObjectIdGenerator<?> generatorType)\n-    {\n-        if (_seenObjectIds == null) {\n-            _seenObjectIds = new IdentityHashMap<Object,WritableObjectId>();\n-        } else {\n-            WritableObjectId oid = _seenObjectIds.get(forPojo);\n-            if (oid != null) {\n-                return oid;\n-            }\n-        }\n-        // Not seen yet; must add an entry, return it. For that, we need generator\n-        ObjectIdGenerator<?> generator = null;\n-        \n-        if (_objectIdGenerators == null) {\n-            _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8);\n-        } else {\n-            for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) {\n-                ObjectIdGenerator<?> gen = _objectIdGenerators.get(i);\n-                if (gen.canUseFor(generatorType)) {\n-                    generator = gen;\n-                    break;\n-                }\n-            }\n-        }\n-        if (generator == null) {\n-            generator = generatorType.newForSerialization(this);\n-            _objectIdGenerators.add(generator);\n-        }\n-        WritableObjectId oid = new WritableObjectId(generator);\n-        _seenObjectIds.put(forPojo, oid);\n-        return oid;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Factory method impls\n-    /**********************************************************\n-     */\n-    \n-    @Override\n-    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n-            Object serDef)\n+    @SuppressWarnings(\"unchecked\")\n+    public Converter<Object,Object> converterInstance(Annotated annotated,\n+            Object converterDef)\n         throws JsonMappingException\n-    \n-    {\n-        if (serDef == null) {\n+    {\n+        if (converterDef == null) {\n             return null;\n         }\n-        JsonSerializer<?> ser;\n-        \n-        if (serDef instanceof JsonSerializer) {\n-            ser = (JsonSerializer<?>) serDef;\n-        } else {\n-            /* Alas, there's no way to force return type of \"either class\n-             * X or Y\" -- need to throw an exception after the fact\n-             */\n-            if (!(serDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n-                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n-            }\n-            Class<?> serClass = (Class<?>)serDef;\n-            // there are some known \"no class\" markers to consider too:\n-            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n-                return null;\n-            }\n-            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n-                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n-            }\n-            HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass);\n-            if (ser == null) {\n-                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n-                        _config.canOverrideAccessModifiers());\n-            }\n-        }\n-        return (JsonSerializer<Object>) _handleResolvable(ser);\n+        if (converterDef instanceof Converter<?,?>) {\n+            return (Converter<Object,Object>) converterDef;\n+        }\n+        if (!(converterDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n+                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n+        }\n+        Class<?> converterClass = (Class<?>)converterDef;\n+        // there are some known \"no class\" markers to consider too:\n+        if (converterClass == Converter.None.class || converterClass == NoClass.class) {\n+            return null;\n+        }\n+        if (!Converter.class.isAssignableFrom(converterClass)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                    +converterClass.getName()+\"; expected Class<Converter>\");\n+        }\n+        HandlerInstantiator hi = _config.getHandlerInstantiator();\n+        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(_config, annotated, converterClass);\n+        if (conv == null) {\n+            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n+                    _config.canOverrideAccessModifiers());\n+        }\n+        return (Converter<Object,Object>) conv;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n-    protected StdDelegatingSerializer(Converter<Object,?> converter,\n+    public StdDelegatingSerializer(Converter<Object,?> converter,\n             JavaType delegateType, JsonSerializer<?> delegateSerializer)\n     {\n         super(delegateType);\n     public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // First: figure out what is the fully generic delegate type:\n-        TypeFactory tf = provider.getTypeFactory();\n-        JavaType implType = tf.constructType(_converter.getClass());\n-        JavaType[] params = tf.findTypeParameters(implType, Converter.class);\n-        if (params == null || params.length != 2) {\n-            throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n-                    +implType);\n-        }\n-        // and then we can find serializer to delegate to, construct a new instance:\n-        JavaType delegateType = params[1];\n+        // First: if already got serializer to delegate to, contextualize it:\n+        if (_delegateSerializer != null) {\n+            if (_delegateSerializer instanceof ContextualSerializer) {\n+                JsonSerializer<?> ser = ((ContextualSerializer)_delegateSerializer).createContextual(provider, property);\n+                if (ser != _delegateSerializer) {\n+                    return this;\n+                }\n+                return withDelegate(_converter, _delegateType, ser);\n+            }\n+            return this;\n+        }\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        JavaType delegateType = _delegateType;\n+        if (delegateType == null) {\n+            TypeFactory tf = provider.getTypeFactory();\n+            JavaType implType = tf.constructType(_converter.getClass());\n+            JavaType[] params = tf.findTypeParameters(implType, Converter.class);\n+            if (params == null || params.length != 2) {\n+                throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                        +implType);\n+            }\n+            delegateType = params[1];\n+        }\n+        // and then find the thing...\n         return withDelegate(_converter, delegateType,\n                 provider.findValueSerializer(delegateType, property));\n     }", "timestamp": 1361156742, "metainfo": ""}