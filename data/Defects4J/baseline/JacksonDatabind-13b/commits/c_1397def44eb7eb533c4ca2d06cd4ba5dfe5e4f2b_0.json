{"sha": "1397def44eb7eb533c4ca2d06cd4ba5dfe5e4f2b", "log": "Implement #527", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n                 if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n                     suppressableValue = JsonInclude.Include.NON_NULL;\n                 }\n-                \n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n+            }\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+                value = _orderEntries(value);\n             }\n             if (_filterId != null) {\n                 serializeFilteredFields(value, jgen, provider,\n                         findPropertyFilter(provider, _filterId, value), suppressableValue);\n-                jgen.writeEndObject();\n-                return;\n-            }\n-            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n-                value = _orderEntries(value);\n-            }\n-            if (suppressableValue != null) {\n-// !!! TEST\n-                serializeFields(value, jgen, provider);\n-//                serializeOptionalFields(value, jgen, provider);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, jgen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n                 serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n             } else {\n                 if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n                     suppressableValue = JsonInclude.Include.NON_NULL;\n                 }\n-                \n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n             }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (suppressableValue != null) {\n-// !!! TEST\n-                serializeFields(value, jgen, provider);\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, jgen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, jgen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n                 serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n             } else {\n      */\n     \n     /**\n-     * Method called to serialize fields, when the value type is not statically known.\n+     * Method called to serialize fields, when the value type is not statically known;\n+     * but we know that no value suppression is needed (which simplifies processing a bit)\n      */\n     public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider);\n+            serializeTypedFields(value, jgen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n-        \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n             if (keyElem == null) {\n                 provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n                 keySerializer.serialize(keyElem, jgen, provider);\n                 try {\n                     serializer.serialize(valueElem, jgen, provider);\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n+                    // Add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n         }\n     }\n \n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            Object suppressableValue)\n+        throws IOException\n+    {\n+        // If value type needs polymorphic type handling, some more work needed:\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedFields(value, jgen, provider, suppressableValue);\n+            return;\n+        }\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            // First find key serializer\n+            final Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+\n+            // Then value serializer\n+            final Object valueElem = entry.getValue();\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+            } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and then serialize, if all went well\n+            try {\n+                keySerializer.serialize(keyElem, jgen, provider);\n+                valueSer.serialize(valueElem, jgen, provider);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+    \n     /**\n      * Method called to serialize fields, when the value type is statically known,\n      * so that value serializer is passed and does not need to be fetched from\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n             Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n             if (keyElem == null) {\n                 provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n                 keySerializer.serialize(keyElem, jgen, provider);\n             }\n+            final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n             } else {\n                         ser.serializeWithType(valueElem, jgen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n     /**\n      * Helper method used when we have a JSON Filter to use for potentially\n      * filtering out Map entries.\n-     *<p>\n-     * NOTE: initially only called externally, by <code>AnyGetterWriter</code>\n      * \n-     * @since 2.3\n+     * @since 2.5\n      */\n     public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             PropertyFilter filter,\n         throws IOException\n     {\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n         final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            // First, serialize key\n+            // First, serialize key; unless ignorable by key\n             final Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                keySerializer = _keySerializer;\n+            }\n+            // or by value; nulls often suppressed\n             final Object valueElem = entry.getValue();\n-            JsonSerializer<Object> keySer;\n-            if (keyElem == null) {\n-                keySer = provider.findNullKeySerializer(_keyType, _property);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySer = _keySerializer;\n-            }\n+\n             JsonSerializer<Object> valueSer;\n             // And then value\n             if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n                 valueSer = provider.getDefaultNullValueSerializer();\n             } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and with that, ask filter to handle it\n+            prop.reset(keyElem, keySerializer, valueSer);\n+            try {\n+                filter.serializeAsField(valueElem, jgen, provider, prop);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter) throws IOException {\n+        serializeFilteredFields(value, gen, provider, filter,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n+    {\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+            final Object valueElem = entry.getValue();\n+    \n+            // And then value\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppression include null suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+                keySerializer.serialize(keyElem, gen, provider);\n+                provider.defaultSerializeNull(gen);\n+            } else {\n+                valueSer = _valueSerializer;\n                 Class<?> cc = valueElem.getClass();\n                 valueSer = serializers.serializerFor(cc);\n                 if (valueSer == null) {\n                     }\n                     serializers = _dynamicValueSerializers;\n                 }\n-            }\n-            prop.reset(keyElem, keySer, valueSer);\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            keySerializer.serialize(keyElem, gen, provider);\n             try {\n-                filter.serializeAsField(valueElem, jgen, provider, prop);\n+                valueSer.serializeWithType(valueElem, gen, provider, _valueTypeSerializer);\n             } catch (Exception e) {\n-                // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n             }\n     }\n \n     @Deprecated // since 2.5\n-    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n-            PropertyFilter filter) throws IOException\n-    {\n-        serializeFilteredFields(value, gen, provider, filter, null);\n-    }\n-    \n     protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n-        throws IOException\n-    {\n-        final JsonSerializer<Object> keySerializer = _keySerializer;\n-        JsonSerializer<Object> prevValueSerializer = null;\n-        Class<?> prevValueClass = null;\n-        final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n-    \n-        for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n-            // First, serialize key\n-            Object keyElem = entry.getKey();\n-            if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, gen, provider);\n-            }\n-    \n-            // And then value\n-            if (valueElem == null) {\n-                provider.defaultSerializeNull(gen);\n-            } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevValueClass) {\n-                    currSerializer = prevValueSerializer;\n-                } else {\n-                    if (_valueType.hasGenericTypes()) {\n-                        currSerializer = provider.findValueSerializer(provider.constructSpecializedType(_valueType, cc), _property);\n-                    } else {\n-                        currSerializer = provider.findValueSerializer(cc, _property);\n-                    }\n-                    prevValueSerializer = currSerializer;\n-                    prevValueClass = cc;\n-                }\n-                try {\n-                    currSerializer.serializeWithType(valueElem, gen, provider, _valueTypeSerializer);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    String keyDesc = \"\"+keyElem;\n-                    wrapAndThrow(provider, e, value, keyDesc);\n-                }\n-            }\n-        }\n-    }\n-\n+        throws IOException {\n+        serializeTypedFields(value, gen, provider,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Schema related functionality\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n             return this;\n         }\n     }\n-    \n+\n+    @JsonInclude(content=JsonInclude.Include.NON_EMPTY)\n+    static class NoEmptyStringsMap extends LinkedHashMap<String,String> {\n+        public NoEmptyStringsMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n             .add(\"a\", \"foo\")\n             .add(\"b\", null)\n             .add(\"c\", \"bar\"));\n-        assertEquals(aposToQuotes(\"{'stuff':{'a':'foo','c':'bar'}}\"), json);\n-    }\n-\n+        assertEquals(aposToQuotes(\"{'a':'foo','c':'bar'}\"), json);\n+    }\n+\n+    // [databind#527]\n+    public void testNonEmptyValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", \"bar\")\n+            .add(\"c\", \"\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','b':'bar'}\"), json);\n+    }\n+    \n     // [databind#527]\n     public void testNonNullValueMapViaProp() throws IOException\n     {", "timestamp": 1413785912, "metainfo": ""}