{"sha": "257da8e4ce33fe77a05f9867ce3e187e522a1b8e", "log": "Starting to implement [Issue#69], upgrade to using PropertyName (to make xml support easier)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     \n     /*\n     /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n+    /* Serialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given property accessors (method,\n+     * field) has an annotation that suggests property name to use\n+     * for serialization.\n+     * Should return null if no annotation\n+     * is found; otherwise a non-null name (possibly\n+     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n+     * \n+     * @param a Property accessor to check\n+     * \n+     * @return Name to use if found; null if not.\n+     * \n+     * @since 2.1\n+     */\n+    public PropertyName findNameForSerialization(Annotated a)\n+    {\n+        return null;\n+    }\n+    \n     /**\n      * Method for checking whether given method has an annotation\n      * that suggests property name associated with method that\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForSerialization} instead\n+     */\n+    @Deprecated\n     public String findSerializationName(AnnotatedMethod am) {\n         return null;\n     }\n-\n-    /**\n-     * Method for checking whether given method has an annotation\n-     * that suggests that the return value of annotated method\n-     * should be used as \"the value\" of the object instance; usually\n-     * serialized as a primitive value such as String or number.\n-     *\n-     * @return True if such annotation is found (and is not disabled);\n-     *   false if no enabled annotation is found\n-     */\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-\n-    /**\n-     * Method for determining the String value to use for serializing\n-     * given enumeration entry; used when serializing enumerations\n-     * as Strings (the standard method).\n-     *\n-     * @return Serialized enum value.\n-     */\n-    public String findEnumValue(Enum<?> value) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: field annotations\n-    /**********************************************************\n-     */\n \n     /**\n      * Method for checking whether given member field represent\n      * If non-null value is returned, it is used as the property\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForSerialization} instead\n+     */\n+    @Deprecated\n     public String findSerializationName(AnnotatedField af) {\n         return null;\n     }\n-\n+    \n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the return value of annotated method\n+     * should be used as \"the value\" of the object instance; usually\n+     * serialized as a primitive value such as String or number.\n+     *\n+     * @return True if such annotation is found (and is not disabled);\n+     *   false if no enabled annotation is found\n+     */\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+    \n+    /**\n+     * Method for determining the String value to use for serializing\n+     * given enumeration entry; used when serializing enumerations\n+     * as Strings (the standard method).\n+     *\n+     * @return Serialized enum value.\n+     */\n+    public String findEnumValue(Enum<?> value) {\n+        return null;\n+    }\n     /*\n     /**********************************************************\n     /* Deserialization: general annotations\n             return result;            \n         }\n \n-        // // // Serialization: method annotations\n+        // // // Serialization: property annotations\n+        \n+        @Override\n+        public PropertyName findNameForSerialization(Annotated a) {\n+            PropertyName n = _primary.findNameForSerialization(a);\n+            if (n != null) {\n+                n = _secondary.findNameForSerialization(a);\n+            }\n+            return n;\n+        }\n         \n         @Override\n         public String findSerializationName(AnnotatedMethod am)\n             }\n             return result;\n         }\n-        \n-        @Override\n-        public boolean hasAsValueAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n-        }\n-        \n-        @Override\n-        public String findEnumValue(Enum<?> value)\n-        {\n-            String result = _primary.findEnumValue(value);\n-            if (result == null) {\n-                result = _secondary.findEnumValue(value);\n-            }\n-            return result;\n-        }        \n-\n-        // // // Serialization: field annotations\n \n         @Override\n         public String findSerializationName(AnnotatedField af)\n             }\n             return result;\n         }\n+        \n+        @Override\n+        public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+        {\n+            return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n+        }\n+        \n+        @Override\n+        public String findEnumValue(Enum<?> value)\n+        {\n+            String result = _primary.findEnumValue(value);\n+            if (result == null) {\n+                result = _secondary.findEnumValue(value);\n+            }\n+            return result;\n+        }        \n \n         // // // Deserialization: general annotations\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Simple value class used for containing names of properties as defined\n+ * by annotations (and possibly other configuration sources).\n+ * \n+ * @since 2.1\n+ */\n+public class PropertyName\n+{\n+    /**\n+     * Special placeholder value that indicates that name to use should be\n+     * based on the standard heuristics. This can be different from returning\n+     * null, as null means \"no information available, whereas this value\n+     * indicates explicit defaulting.\n+     */\n+    public final static PropertyName USE_DEFAULT = new PropertyName(new String(\"\"), null);\n+    \n+    /**\n+     * Basic name of the property.\n+     */\n+    protected final String _simpleName;\n+\n+    /**\n+     * Additional namespace, for formats that have such concept (JSON\n+     * does not, XML does, for example).\n+     */\n+    protected final String _namespace;\n+\n+    public PropertyName(String simpleName) {\n+        this(simpleName, null);\n+    }\n+\n+    public PropertyName(String simpleName, String namespace)\n+    {\n+        _simpleName = simpleName;\n+        _namespace = namespace;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+    \n+    public String getSimpleName() {\n+        return _simpleName;\n+    }\n+\n+    public String getNamespace() {\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Std method overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != PropertyName.class) return false;\n+        if (USE_DEFAULT == o) {\n+            return this == USE_DEFAULT;\n+        }\n+        PropertyName other = (PropertyName) this;\n+        if (_simpleName == null) {\n+            if (other._simpleName != null) return false;\n+        } else if (!_simpleName.equals(other._simpleName)) {\n+            return false;\n+        }\n+        if (_namespace == null) {\n+            return (null == other._namespace);\n+        }\n+        return _namespace.equals(other._namespace);\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        if (_namespace == null) {\n+            return _simpleName.hashCode();\n+        }\n+        return _namespace.hashCode() ^  _simpleName.hashCode();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        if (_namespace == null) {\n+            return _simpleName;\n+        }\n+        return _namespace + \":\" + _simpleName;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n \n     /*\n     /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findSerializationName(AnnotatedMethod am)\n-    {\n-        // @JsonGetter is most specific, has precedence\n-        JsonGetter ann = am.getAnnotation(JsonGetter.class);\n-        if (ann != null) {\n-            return ann.value();\n-        }\n-        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n-        if (pann != null) {\n-            return pann.value();\n-        }\n-        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n-         *   that there is a property, although doesn't define name\n-         */\n-        // 09-Apr-2010, tatu: Ditto for JsonView\n-        if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) {\n-            return \"\";\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n-    {\n-        JsonValue ann = am.getAnnotation(JsonValue.class);\n-        // value of 'false' means disabled...\n-        return (ann != null && ann.value());\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: field annotations\n-    /**********************************************************\n-    */\n+    /* Serialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public PropertyName findNameForSerialization(Annotated a)\n+    {\n+        // [Issue#69], need bit of delegation \n+        // !!! TODO: in 2.2, remove old methods?\n+        String name;\n+        if (a instanceof AnnotatedField) {\n+            name = findSerializationName((AnnotatedField) a);\n+        } else if (a instanceof AnnotatedMethod) {\n+            name = findSerializationName((AnnotatedMethod) a);\n+        } else {\n+            name = null;\n+        }\n+        if (name != null) {\n+            if (name.length() == 0) { // empty String means 'default'\n+                return PropertyName.USE_DEFAULT;\n+            }\n+            return new PropertyName(name);\n+        }\n+        return null;\n+    }\n \n     @Override\n     public String findSerializationName(AnnotatedField af)\n             return \"\";\n         }\n         return null;\n+    }\n+    \n+    @Override\n+    public String findSerializationName(AnnotatedMethod am)\n+    {\n+        // @JsonGetter is most specific, has precedence\n+        JsonGetter ann = am.getAnnotation(JsonGetter.class);\n+        if (ann != null) {\n+            return ann.value();\n+        }\n+        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n+         *   that there is a property, although doesn't define name\n+         */\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+    {\n+        JsonValue ann = am.getAnnotation(JsonValue.class);\n+        // value of 'false' means disabled...\n+        return (ann != null && ann.value());\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n                  *   fields, and similarly for deserialize-only annotations... so\n                  *   no fallbacks in this particular case.\n                  */\n-                explName = ai.findSerializationName(f);\n+                PropertyName pn = ai.findNameForSerialization(f);\n+                explName = (pn == null) ? null : pn.getSimpleName();\n             } else {\n                 explName = ai.findDeserializationName(f);\n             }\n         String implName; // from naming convention\n         boolean visible;\n         \n-        String explName = (ai == null) ? null : ai.findSerializationName(m);\n+        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n+        String explName = (pn == null) ? null : pn.getSimpleName();\n         if (explName == null) { // no explicit name; must follow naming convention\n             implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n             if (implName == null) { // if not, must skip", "timestamp": 1346820400, "metainfo": ""}