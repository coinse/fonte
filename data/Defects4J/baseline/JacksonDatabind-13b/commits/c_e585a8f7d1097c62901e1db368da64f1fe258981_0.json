{"sha": "e585a8f7d1097c62901e1db368da64f1fe258981", "log": "Merge pull request #521 from tea-dragon/master  keep bundle annotations and prevent simple cycles", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = result.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    result.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = target.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    target.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasModified = target.addOrOverride(ann);\n+                if (wasModified && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: no filtering by jackson-annotations\n-                    target.addOrOverride(ann);\n                 }\n             }\n             if (bundles != null) { // and then bundles, if any: important for precedence\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n      * annotation masking or overriding an annotation 'real' constructor\n      * has.\n      */\n-    public final void addOrOverride(Annotation a) {\n-        _annotations.add(a);\n+    public final boolean addOrOverride(Annotation a) {\n+        return _annotations.add(a);\n     }\n \n     /**\n      * annotation if and only if it is not yet present in the\n      * annotation map we have.\n      */\n-    public final void addIfNotPresent(Annotation a) {\n-        _annotations.addIfNotPresent(a);\n+    public final boolean addIfNotPresent(Annotation a) {\n+        return _annotations.addIfNotPresent(a);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n      * Method called to add specified annotation in the Map, but\n      * only if it didn't yet exist.\n      */\n-    public void addIfNotPresent(Annotation ann)\n+    public boolean addIfNotPresent(Annotation ann)\n     {\n         if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n             _add(ann);\n+            return true;\n         }\n+        return false;\n     }\n \n     /**\n      * Method called to add specified annotation in the Map.\n      */\n-    public void add(Annotation ann) {\n-        _add(ann);\n+    public boolean add(Annotation ann) {\n+        return _add(ann);\n     }\n \n     @Override\n     /**********************************************************\n      */\n \n-    protected final void _add(Annotation ann) {\n+    protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n-        _annotations.put(ann.annotationType(), ann);\n+        Annotation previous = _annotations.put(ann.annotationType(), ann);\n+        return (previous != null) && previous.equals(ann);\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n-import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyName;\n \n /* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n  */\n     public class Bean92 {\n         @Bundle92\n         protected String id = \"abc\";\n-    }    \n+    }\n+\n+    @HolderB\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderA {}\n+\n+    @HolderA\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderB {}\n+\n+    static class RecursiveHolder {\n+        @HolderA public int unimportant = 42;\n+    }\n+\n+    @JsonProperty\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface InformativeHolder {\n+        // doesn't really contribute to the test, but would be impossible without this feature\n+        boolean important() default true;\n+    }\n+\n+    static class InformingHolder {\n+        @InformativeHolder public int unimportant = 42;\n+    }\n+\n+    static class BundleAnnotationIntrospector extends JacksonAnnotationIntrospector {\n+        @Override\n+        public PropertyName findNameForSerialization(Annotated a)\n+        {\n+            InformativeHolder informativeHolder = a.getAnnotation(InformativeHolder.class);\n+            if ((informativeHolder != null) && informativeHolder.important()) {\n+                return new PropertyName(\"important\");\n+            }\n+            return super.findNameForSerialization(a);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectMapper MAPPER = new ObjectMapper();\n-    \n+\n+    public void testKeepAnnotationBundle() throws Exception\n+    {\n+        MAPPER.setAnnotationIntrospector(new BundleAnnotationIntrospector());\n+        assertEquals(\"{\\\"important\\\":42}\", MAPPER.writeValueAsString(new InformingHolder()));\n+    }\n+\n+    public void testRecursiveBundles() throws Exception\n+    {\n+        assertEquals(\"{\\\"unimportant\\\":42}\", MAPPER.writeValueAsString(new RecursiveHolder()));\n+    }\n+\n     public void testBundledIgnore() throws Exception\n     {\n         assertEquals(\"{\\\"foobar\\\":13}\", MAPPER.writeValueAsString(new Bean()));\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n /**\n      * Accesor for deserializer use for deserializing content values.\n      */\n     public abstract JsonDeserializer<Object> getContentDeserializer();\n+\n+    /*\n+    /**********************************************************\n+    /* Shared methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method called by various Map(-like) deserializers.\n+     */\n+    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n+    {\n+        // to handle StackOverflow:\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // ... except for mapping exceptions\n+        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n+            throw (IOException) t;\n+        }\n+        throw JsonMappingException.wrapWithPath(t, ref, key);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  * <p>\n  * Note: casting within this class is all messed up -- just could not figure out a way\n  * to properly deal with recursive definition of \"EnumMap<K extends Enum<K>, V>\n- * \n- * @author tsaloranta\n  */\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n public class EnumMapDeserializer\n-    extends StdDeserializer<EnumMap<?,?>>\n+    extends ContainerDeserializerBase<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n     private static final long serialVersionUID = 4564890642370311174L;\n \n     public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n-        super(EnumMap.class);\n+        super(mapType);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n         _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n      */\n     @Override\n     public boolean isCachable() { return true; }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _mapType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Actual deserialization\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n+            String keyName = jp.getCurrentName(); // just for error message\n+            // but we need to let key deserializer handle it separately, nonetheless\n             Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             if (key == null) {\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                     throw ctxt.weirdStringException(value, _enumClass, \"value not one of declared Enum instance names\");\n                 }\n                 /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n-                 *  just skip the entry then. But we must skip the value then.\n+                 *  just skip the entry then. But we must skip the value as well, if so.\n                  */\n                 jp.nextToken();\n                 jp.skipChildren();\n              * not handle them (and maybe fail or return bogus data)\n              */\n             Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = valueDes.getNullValue();\n-            } else if (typeDeser == null) {\n-                value =  valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+\n+            try {\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = valueDes.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value =  valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(e, result, keyName);\n+                return null;\n             }\n             result.put(key, value);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n- * Basic serializer that can take Json \"Object\" structure and\n+ * Basic serializer that can take JSON \"Object\" structure and\n  * construct a {@link java.util.Map} instance, with typed contents.\n  *<p>\n  * Note: for untyped content (one indicated by passing Object.class\n         }\n         return withResolved(kd, vtd, vd, ignored);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* ContainerDeserializerBase API\n                 } else {\n                     result.put(key, value);\n                 }\n-            } catch(UnresolvedForwardReference reference) {\n+            } catch (UnresolvedForwardReference reference) {\n                 handleUnresolvedReference(jp, referringAccumulator, key, reference);\n+            } catch (Exception e) {\n+                wrapAndThrow(e, result, fieldName);\n             }\n         }\n     }\n                 }\n             } catch (UnresolvedForwardReference reference) {\n                 handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n+            } catch (Exception e) {\n+                wrapAndThrow(e, result, fieldName);\n             }\n         }\n     }\n                     try {\n                         result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                     } catch (Exception e) {\n-                        wrapAndThrow(e, _mapType.getRawClass());\n+                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                         return null;\n                     }\n                     _readAndBind(jp, ctxt, result);\n             // other property? needs buffering\n             String fieldName = jp.getCurrentName();\n             Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n-            Object value;            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = valueDes.getNullValue();\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            Object value; \n+\n+            try {\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = valueDes.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(e, _mapType.getRawClass(), propName);\n+                return null;\n             }\n             buffer.bufferMapProperty(key, value);\n         }\n         try {\n             return (Map<Object,Object>)creator.build(ctxt, buffer);\n         } catch (Exception e) {\n-            wrapAndThrow(e, _mapType.getRawClass());\n+            wrapAndThrow(e, _mapType.getRawClass(), null);\n             return null;\n         }\n     }\n \n-    // note: copied from BeanDeserializer; should try to share somehow...\n-    protected void wrapAndThrow(Throwable t, Object ref)\n-        throws IOException\n-    {\n-        // to handle StackOverflow:\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        // ... except for mapping exceptions\n-        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n-            throw (IOException) t;\n-        }\n-        throw JsonMappingException.wrapWithPath(t, ref, null);\n+    @Deprecated // since 2.5\n+    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n+        wrapAndThrow(t, ref, null);\n     }\n \n     private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n {\n     protected final PropertyName _propertyName;\n     protected final Class<? extends ObjectIdGenerator<?>> _generator;\n-    private final Class<? extends ObjectIdResolver> _resolver;\n+    protected final Class<? extends ObjectIdResolver> _resolver;\n     protected final Class<?> _scope;\n     protected final boolean _alwaysAsId;\n \n         if (_alwaysAsId == state) {\n             return this;\n         }\n-        return new ObjectIdInfo(_propertyName, _scope, _generator, state);\n+        return new ObjectIdInfo(_propertyName, _scope, _generator, state, _resolver);\n     }\n     \n     public PropertyName getPropertyName() { return _propertyName; }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     @Override public PropertyName getWrapperName() { return _wrapperName; }\n     @Override public boolean isRequired() { return _metadata.isRequired(); }\n     @Override public PropertyMetadata getMetadata() { return _metadata; }\n-    \n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _member.getAnnotation(acls);\n     }\n \n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         return _contextAnnotations.get(acls);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.lang.annotation.Annotation;\n+\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n     public abstract String getName();\n \n     public abstract PropertyName getFullName();\n+\n+    /**\n+     * Convenience method for accessing annotation that may be associated\n+     * either directly on property, or, if not, via enclosing class (context).\n+     * This allows adding baseline contextual annotations, for example, by adding\n+     * an annotation for a given class and making that apply to all properties\n+     * unless overridden by per-property annotations.\n+     *<p>\n+     * This method is functionally equivalent to:\n+     *<pre>\n+     *  MyAnnotation ann = propWriter.getAnnotation(MyAnnotation.class);\n+     *  if (ann == null) {\n+     *    ann = propWriter.getContextAnnotation(MyAnnotation.class);\n+     *  }\n+     *</pre>\n+     * that is, tries to find a property annotation first, but if one is not\n+     * found, tries to find context-annotation (from enclosing class) of\n+     * same type.\n+     * \n+     * @since 2.5\n+     */\n+    public <A extends Annotation> A findAnnotation(Class<A> acls) {\n+        A ann = getAnnotation(acls);\n+        if (ann == null) {\n+            ann = getContextAnnotation(acls);\n+        }\n+        return ann;\n+    }\n     \n+    /**\n+     * Method for accessing annotations directly declared for property that this\n+     * writer is associated with.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for accessing annotations declared in context of the property that this\n+     * writer is associated with; usually this means annotations on enclosing class\n+     * for property.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getContextAnnotation(Class<A> acls);\n+\n     /*\n     /**********************************************************\n     /* Serialization methods, regular output\n     /**\n      * The main serialization method called by filter when property is to be written normally.\n      */\n-    public abstract void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * filtered, but the underlying data format requires a placeholder of some kind.\n      * This is usually the case for tabular (positional) data formats such as CSV.\n      */\n-    public abstract void serializeAsOmittedField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsOmittedField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n      * data format; so it is typically NOT called for fully tabular formats such as CSV,\n      * where logical output is still as form of POJOs.\n      */\n-    public abstract void serializeAsElement(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsElement(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * but then value is to be omitted. This requires output of a placeholder value\n      * of some sort; often similar to {@link #serializeAsOmittedField}.\n      */\n-    public abstract void serializeAsPlaceholder(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsPlaceholder(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.PropertyName;\n  */\n public class MapProperty extends PropertyWriter\n {\n-    protected TypeSerializer _typeSerializer;\n-    \n-    protected Object _key, _value;\n+    protected final TypeSerializer _typeSerializer;\n+\n+    protected final BeanProperty _property;\n+\n+    protected Object _key;\n \n     protected JsonSerializer<Object> _keySerializer, _valueSerializer;\n \n-    public MapProperty(TypeSerializer typeSer)\n+    /**\n+     * @deprecated since 2.4\n+     */\n+    @Deprecated // since 2.4\n+    public MapProperty(TypeSerializer typeSer) {\n+        this(typeSer, null);\n+    }\n+    \n+    public MapProperty(TypeSerializer typeSer, BeanProperty prop)\n     {\n         _typeSerializer = typeSer;\n+        _property = prop;\n+    }\n+\n+    /**\n+     * Deprecated method with wrong signature; value should not be assigned\n+     * to property, should be passed via proper call-through methods.\n+     * \n+     * @deprecated Since 2.5, remove in 2.6\n+     */\n+    @Deprecated // since 2.5\n+    public void reset(Object key, Object value,\n+            JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {\n+        reset(key, keySer, valueSer);\n     }\n     \n     /**\n      * Initialization method that needs to be called before passing\n      * property to filter.\n      */\n-    public void reset(Object key, Object value,\n+    public void reset(Object key,\n             JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer)\n     {\n         _key = key;\n-        _value = value;\n         _keySerializer = keySer;\n         _valueSerializer = valueSer;\n     }\n     }\n \n     @Override\n-    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getContextAnnotation(acls);\n+    }\n+    \n+    @Override\n+    public void serializeAsField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws IOException\n     {\n         _keySerializer.serialize(_key, jgen, provider);\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n \n     @Override\n-    public void serializeAsOmittedField(Object pojo, JsonGenerator jgen,\n+    public void serializeAsOmittedField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (!jgen.canOmitFields()) {\n     }\n \n     @Override\n-    public void serializeAsElement(Object pojo, JsonGenerator jgen,\n+    public void serializeAsElement(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n     \n     @Override\n-    public void serializeAsPlaceholder(Object pojo, JsonGenerator jgen,\n+    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         jgen.writeNull();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n-        final MapProperty prop = new MapProperty(_valueTypeSerializer);\n+        final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             // First, serialize key\n                     serializers = _dynamicValueSerializers;\n                 }\n             }\n-            prop.reset(keyElem, valueElem, keySer, valueSer);\n+            prop.reset(keyElem, keySer, valueSer);\n             try {\n-                filter.serializeAsField(value, jgen, provider, prop);\n+                filter.serializeAsField(valueElem, jgen, provider, prop);\n             } catch (Exception e) {\n                 // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n package com.fasterxml.jackson.databind.filter;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.PropertyWriter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n \n public class TestMapFiltering extends BaseMapTest\n {\n+    @Target({ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomOffset\n+    {\n+        public int value();\n+    }\n+\n     @SuppressWarnings(\"serial\")\n     @JsonFilter(\"filterForMaps\")\n     static class FilteredBean extends LinkedHashMap<String,Integer> { }\n     \n     static class MapBean {\n         @JsonFilter(\"filterX\")\n+        @CustomOffset(1)\n         public Map<String,Integer> values;\n         \n         public MapBean() {\n             values.put(\"c\", 9);\n         }\n     }\n-    \n+\n+    static class MyMapFilter implements PropertyFilter\n+    {\n+        @Override\n+        public void serializeAsField(Object value, JsonGenerator jgen,\n+                SerializerProvider provider, PropertyWriter writer)\n+            throws Exception\n+        {\n+            String name = writer.getName();\n+            if (!\"a\".equals(name)) {\n+                return;\n+            }\n+            CustomOffset n = writer.findAnnotation(CustomOffset.class);\n+            int offset = (n == null) ? 0 : n.value();\n+            Integer I = offset + ((Integer) value).intValue();\n+\n+            writer.serializeAsField(I, jgen, provider);\n+        }\n+\n+        @Override\n+        public void serializeAsElement(Object elementValue, JsonGenerator jgen,\n+                SerializerProvider prov, PropertyWriter writer)\n+                throws Exception {\n+            // not needed for testing\n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+                throws JsonMappingException {\n+            \n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor,\n+                SerializerProvider provider) throws JsonMappingException {\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(aposToQuotes(\"{'b':3}\"), json);\n     }\n     \n+    // [Issue#522]\n+    public void testMapFilteringWithAnnotations() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n+                new MyMapFilter());\n+        String json = MAPPER.writer(prov).writeValueAsString(new MapBean());\n+        // a=1 should become a=2\n+        assertEquals(aposToQuotes(\"{'values':{'a':2}}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n     }\n \n     static class ContactImpl implements Contact {\n+        @Override\n         public String getCity() { return \"Seattle\"; }\n     }\n \n     static class ContactMixin implements Contact {\n+        @Override\n         @JsonProperty\n         public String getCity() { return null; }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n \n import com.fasterxml.jackson.annotation.JsonAnySetter;\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonIdentityReference;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n     }\n \n     @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\", resolver = PoolResolver.class)\n+    @JsonIdentityReference(alwaysAsId = true) // #524\n     static class WithCustomResolution {\n         public int id;\n         public int data;", "timestamp": 1409002962, "metainfo": ""}