{"sha": "044bb5ae7f72d1a4e002812ccfacbdd438d053db", "log": "Work towards sub-classable ObjectReader (for CSV)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n+\n+    /**\n+     * Overridable helper method used to construct default {@link ClassIntrospector}\n+     * to use.\n+     * \n+     * @since 2.5\n+     */\n+    protected ClassIntrospector defaultClassIntrospector() {\n+        return new BasicClassIntrospector();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override\n+    /**********************************************************\n+     */\n     \n     /**\n      * Method for creating a new {@link ObjectMapper} instance that\n      * \n      * @since 2.1\n      */\n-    public ObjectMapper copy()\n-    {\n+    public ObjectMapper copy() {\n         _checkInvalidCopy(ObjectMapper.class);\n         return new ObjectMapper(this);\n     }\n \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config) {\n+        return new ObjectReader(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues) {\n+        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n+    }\n+    \n     /**\n      * @since 2.1\n      */\n                     +\" (version: \"+version()+\") does not override copy(); it has to\");\n         }\n     }\n-\n-    /**\n-     * Overridable helper method used to construct default {@link ClassIntrospector}\n-     * to use.\n-     * \n-     * @since 2.5\n-     */\n-    protected ClassIntrospector defaultClassIntrospector() {\n-        return new BasicClassIntrospector();\n-    }\n     \n     /*\n     /**********************************************************\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Module registration, discovery\n      * without defining expected value type.\n      */\n     public ObjectReader reader() {\n-        return new ObjectReader(this, getDeserializationConfig())\n-            .with(_injectableValues);\n+        return _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * without defining expected value type.\n      */\n     public ObjectReader reader(DeserializationFeature feature) {\n-        return new ObjectReader(this, getDeserializationConfig().with(feature));\n+        return _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      */\n     public ObjectReader reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n+        return _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate)\n-    {\n+    public ObjectReader readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n+        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig(), type, null,\n+    public ObjectReader reader(JavaType type) {\n+        return _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    public ObjectReader reader(Class<?> type) {\n+        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    public ObjectReader reader(TypeReference<?> type) {\n+        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig()).with(f);\n+    public ObjectReader reader(JsonNodeFactory f) {\n+        return _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return _newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * @param injectableValues Injectable values to use\n      */\n     public ObjectReader reader(InjectableValues injectableValues) {\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return _newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * deserialize objects using specified JSON View (filter).\n      */\n     public ObjectReader readerWithView(Class<?> view) {\n-        return new ObjectReader(this, getDeserializationConfig().withView(view));\n+        return _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * @since 2.1\n      */\n     public ObjectReader reader(Base64Variant defaultBase64) {\n-        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n+        return _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader reader(ContextAttributes attrs) {\n-        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n-    }\n-    \n+        return _newReader(getDeserializationConfig().with(attrs));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n     /**********************************************************\n      */\n-   \n+\n     /**\n      * Convenience method for doing two-step conversion from given value, into\n      * instance of given value type. This is functionality equivalent to first\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods for deserialization, overridable\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     /**\n      * Constructor used by {@link ObjectMapper} for initial instantiation\n      */\n-    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config)\n-    {\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n         this(mapper, config, null, null, null, null);\n     }\n \n \n     /*\n     /**********************************************************\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* reader instances, (re)configuring parser instances\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n+        return new ObjectReader(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n+        return new ObjectReader(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues,\n+            DataFormatReaders dataFormatReaders) {\n+        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n+                 schema,  injectableValues, dataFormatReaders);\n+    }\n+\n+    /**\n+     * NOTE: changed from static to non-static in 2.5; unfortunate but\n+     * necessary change to support overridability\n+     */\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = p.getCurrentToken();\n+        if (t == null) { // and then we must get something...\n+            t = p.nextToken();\n+            if (t == null) {\n+                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n+     * of multiple values means that we may or may not want to advance the stream,\n+     * but need to do other initialization.\n+     *<p>\n+     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n+     * \n+     * @since 2.5\n+     */\n+    protected void _initForMultiRead(JsonParser p) throws IOException {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Life-cycle, fluent factory methods\n     /**********************************************************\n      */\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectReader with(DeserializationFeature feature) {\n+    public final ObjectReader with(DeserializationFeature feature) {\n         return _with(_config.with(feature));\n     }    \n \n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader with(DeserializationFeature first,\n+    public final ObjectReader with(DeserializationFeature first,\n             DeserializationFeature... other)\n     {\n         return _with(_config.with(first, other));\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader withFeatures(DeserializationFeature... features) {\n+    public final ObjectReader withFeatures(DeserializationFeature... features) {\n         return _with(_config.withFeatures(features));\n     }    \n     \n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n-    public ObjectReader without(DeserializationFeature feature) {\n+    public final ObjectReader without(DeserializationFeature feature) {\n         return _with(_config.without(feature)); \n     }    \n \n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader without(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n+    public final ObjectReader without(DeserializationFeature first,\n+            DeserializationFeature... other) {\n         return _with(_config.without(first, other));\n     }    \n \n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n+    public final ObjectReader withoutFeatures(DeserializationFeature... features) {\n         return _with(_config.withoutFeatures(features));\n     }    \n     \n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config,\n+        return _new(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues, _dataFormatReaders);\n     }\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader with(JsonNodeFactory f) {\n+    public final ObjectReader with(JsonNodeFactory f) {\n         return _with(_config.with(f));\n     }\n \n         if (f == _parserFactory) {\n             return this;\n         }\n-        ObjectReader r = new ObjectReader(this, f);\n+        ObjectReader r = _new(this, f);\n         // Also, try re-linking, if possible...\n         if (f.getCodec() == null) {\n             f.setCodec(r);\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withRootName(String rootName) {\n+    public final ObjectReader withRootName(String rootName) {\n         return _with(_config.withRootName(rootName));\n     }\n \n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues, _dataFormatReaders);\n     }\n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(JavaType valueType)\n+    public final ObjectReader withType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) {\n             return this;\n         if (det != null) {\n             det = det.withType(valueType);\n         }\n-        return new ObjectReader(this, _config, valueType, rootDeser,\n+        return _new(this, _config, valueType, rootDeser,\n                 _valueToUpdate, _schema, _injectableValues, det);\n     }    \n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(Class<?> valueType) {\n+    public final ObjectReader withType(Class<?> valueType) {\n         return withType(_config.constructType(valueType));\n     }    \n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(java.lang.reflect.Type valueType) {\n+    public final ObjectReader withType(java.lang.reflect.Type valueType) {\n         return withType(_config.getTypeFactory().constructType(valueType));\n     }    \n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n+    public final ObjectReader withType(TypeReference<?> valueTypeRef) {\n         return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n \n         } else {\n             t = _valueType;\n         }\n-        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n+        return _new(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues, _dataFormatReaders);\n     }\n \n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withView(Class<?> activeView) {\n+    public final ObjectReader withView(Class<?> activeView) {\n         return _with(_config.withView(activeView));\n     }\n \n-    public ObjectReader with(Locale l) {\n+    public final ObjectReader with(Locale l) {\n         return _with(_config.with(l));\n     }\n \n-    public ObjectReader with(TimeZone tz) {\n+    public final ObjectReader with(TimeZone tz) {\n         return _with(_config.with(tz));\n     }\n \n-    public ObjectReader withHandler(DeserializationProblemHandler h) {\n+    public final ObjectReader withHandler(DeserializationProblemHandler h) {\n         return _with(_config.withHandler(h));\n     }\n \n-    public ObjectReader with(Base64Variant defaultBase64) {\n+    public final ObjectReader with(Base64Variant defaultBase64) {\n         return _with(_config.with(defaultBase64));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(ObjectReader... readers)\n-    {\n+    public final ObjectReader withFormatDetection(ObjectReader... readers) {\n         return withFormatDetection(new DataFormatReaders(readers));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(DataFormatReaders readers)\n-    {\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, _injectableValues, readers);\n     }\n \n     /**\n      * @since 2.3\n      */\n-    public ObjectReader with(ContextAttributes attrs) {\n-        DeserializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public final ObjectReader with(ContextAttributes attrs) {\n+        return _with(_config.with(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n-    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n-        DeserializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public final ObjectReader withAttributes(Map<Object,Object> attrs) {\n+        return _with(_config.withAttributes(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n-    public ObjectReader withAttribute(Object key, Object value) {\n-        DeserializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public final ObjectReader withAttribute(Object key, Object value) {\n+        return _with( _config.withAttribute(key, value));\n     }\n \n     /**\n      * @since 2.3\n      */\n-    public ObjectReader withoutAttribute(Object key) {\n-        DeserializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public final ObjectReader withoutAttribute(Object key) {\n+        return _with(_config.withoutAttribute(key));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable factory methods that sub-classes MUST override\n+    /**********************************************************\n+     */\n+    \n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        if (_dataFormatReaders != null) {\n+            return _new(this, newConfig)\n+                .withFormatDetection(_dataFormatReaders.with(newConfig));\n+        }\n+        return _new(this, newConfig);\n     }\n     \n     /*\n         }\n         return result;\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Helper methods, common parser initialization\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * NOTE: changed from static to non-static in 2.5; unfortunate but\n-     * necessary change to support overridability\n-     */\n-    protected JsonToken _initForReading(JsonParser p) throws IOException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n-        /* First: must point to a token; if not pointing to one, advance.\n-         * This occurs before first read from JsonParser, as well as\n-         * after clearing of current token.\n-         */\n-        JsonToken t = p.getCurrentToken();\n-        if (t == null) { // and then we must get something...\n-            t = p.nextToken();\n-            if (t == null) {\n-                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n-                 *   not an actual parsing problem\n-                 */\n-                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n-            }\n-        }\n-        return t;\n-    }\n-\n-    /**\n-     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n-     * of multiple values means that we may or may not want to advance the stream,\n-     * but need to do other initialization.\n-     * \n-     * @since 2.5\n-     */\n-    protected void _initForMultiRead(JsonParser p) throws IOException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n-    }\n \n     /*\n     /**********************************************************\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n         return _context.createInstance(cfg, jp, _injectableValues);\n     }\n-    \n-    protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) {\n-            return this;\n-        }\n-        if (_dataFormatReaders != null) {\n-            return new ObjectReader(this, newConfig)\n-                .withFormatDetection(_dataFormatReaders.with(newConfig));\n-        }\n-        return new ObjectReader(this, newConfig);\n-    }\n \n     protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n     {", "timestamp": 1412358617, "metainfo": ""}