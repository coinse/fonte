{"sha": "52a924401ffedeb1170401e760443e184692cbb1", "log": "Fixed issues uncovered with handling of contextual serializers (was not always resolving ContextualSerializers properly)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n      */\n \n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> serializerInstance(Annotated annotated, Class<? extends JsonSerializer<?>> serClass)\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated, Class<?> serClass)\n     {\n         HandlerInstantiator hi = getHandlerInstantiator();\n         if (hi != null) {\n-            JsonSerializer<?> ser = hi.serializerInstance(this, annotated, serClass);\n+            JsonSerializer<?> ser = hi.serializerInstance(this, annotated,\n+                    (Class<JsonSerializer<?>>)serClass);\n             if (ser != null) {\n                 return (JsonSerializer<Object>) ser;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         }\n         return cls;\n     }\n-\n-    }\n-\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         throws JsonMappingException\n     {\n         Class<?> raw = type.getRawClass();\n-        if (String[].class == raw) {\n-            return new StdArraySerializers.StringArraySerializer(property);\n-        }\n-        // other standard types?\n-        JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n-        if (ser != null) {\n-            return ser;\n+        // Important: do NOT use standard serializers if non-standard element value serializer specified\n+        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+            if (String[].class == raw) {\n+                return new StdArraySerializers.StringArraySerializer(property);\n+            } else {\n+                // other standard types?\n+                JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n         }\n         return new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                 property, elementValueSerializer);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)\n+    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,\n+            Annotated a, T type)\n     {\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         // then key class\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected static JsonSerializer<Object> findKeySerializer(SerializationConfig config,\n+    protected JsonSerializer<Object> findKeySerializer(SerializationConfig config,\n             Annotated a, BeanProperty property)\n         throws JsonMappingException\n     {\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Object serDef = intr.findKeySerializer(a);\n-        if (serDef == null || serDef == JsonSerializer.None.class || serDef == NoClass.class) {\n-            if (property != null) {\n-                AnnotatedMember m = property.getMember();\n-                if (m != null) {\n-                    serDef = intr.findKeySerializer(m);\n-                }\n-            }\n-        }\n+        Object serDef = null;\n+\n+        // Start with property (more specific); if not found, then find from type\n+        if (property != null) {\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                serDef = intr.findKeySerializer(m);\n+            }\n+        }\n+        if (serDef == null) {\n+            serDef = intr.findKeySerializer(a);\n+        }\n+\n         // ok, what did we get?\n         if (serDef != null) {\n+            JsonSerializer<?> ser = null;\n             if (serDef instanceof JsonSerializer<?>) {\n-                JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n-                if (ser instanceof ContextualSerializer<?>) {\n-                    return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+                ser = (JsonSerializer<Object>) serDef;\n+            } else {\n+                Class<?> serClass = _verifyAsClass(serDef, \"findKeySerializer\", JsonSerializer.None.class);\n+                if (serClass != null) {\n+                    return config.serializerInstance(a, serClass);\n                 }\n-                return ser;\n-            }\n-            if (!(serDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector.findKeySerializer() returned value of type \"+serDef.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n-            }\n-            Class<?> serClass = (Class<?>) serDef;\n-            if (serClass != JsonSerializer.None.class && serClass != NoClass.class) {\n-                return config.serializerInstance(a, (Class<JsonSerializer<?>>) serClass);\n-            }\n+            }\n+            if (ser instanceof ContextualSerializer<?>) {\n+                ser = ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+            }\n+            return (JsonSerializer<Object>) ser;\n         }\n         return null;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected static JsonSerializer<Object> findContentSerializer(SerializationConfig config,\n+    protected JsonSerializer<Object> findContentSerializer(SerializationConfig config,\n             Annotated a, BeanProperty property)\n         throws JsonMappingException\n     {\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Object serDef = intr.findContentSerializer(a);\n-        if (serDef == null || serDef == JsonSerializer.None.class || serDef == NoClass.class) {\n-            if (property != null) {\n-                AnnotatedMember m = property.getMember();\n-                if (m != null) {\n-                    serDef = intr.findContentSerializer(m);\n-                }\n-            }\n-        }\n+        Object serDef = null;\n+\n+        // Start with property (more specific); if not found, then find from type\n+        if (property != null) {\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                serDef = intr.findContentSerializer(m);\n+            }\n+        }\n+        if (serDef == null) {\n+            serDef = intr.findContentSerializer(a);\n+        }\n+\n         // ok, what did we get?\n         if (serDef != null) {\n+            JsonSerializer<?> ser = null;\n             if (serDef instanceof JsonSerializer<?>) {\n-                JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n-                if (ser instanceof ContextualSerializer<?>) {\n-                    return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+                ser = (JsonSerializer<Object>) serDef;\n+            } else {\n+                Class<?> serClass = _verifyAsClass(serDef, \"findContentSerializer\", JsonSerializer.None.class);\n+                if (serClass != null) {\n+                    ser = config.serializerInstance(a, serClass);\n                 }\n-                return ser;\n-            }\n-            if (!(serDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector.findContentSerializer() returned value of type \"+serDef.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n-            }\n-            Class<?> serClass = (Class<?>) serDef;\n-            if (serClass != JsonSerializer.None.class && serClass != NoClass.class) {\n-                return config.serializerInstance(a, (Class<JsonSerializer<?>>) serClass);\n-            }\n+            }\n+            if (ser instanceof ContextualSerializer<?>) {\n+                ser = ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+            }\n+            return (JsonSerializer<Object>) ser;\n         }\n         return null;\n     }\n         }\n         return false;\n     }\n+\n+    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Efficient implement for serializing {@link List}s that contains Strings and are random-accessible.\n  * may be overridde; because of this, logic is needed to ensure that the default\n  * serializer is in use to use fastest mode, or if not, to defer to custom\n  * String serializer.\n- * \n- * @since 1.7\n  */\n @JacksonStdImpl\n public final class IndexedStringListSerializer\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n         JsonSerializer<?> ser = provider.findValueSerializer(String.class, _property);\n-        if (!isDefaultSerializer(ser)) {\n+        if (!ClassUtil.isJacksonStdImpl(ser)) {\n             _serializer = (JsonSerializer<String>) ser;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n             schema.put(\"required\", !isOptional);\n         }\n         return schema;\n-    }\n-\n-    /**\n-     * Method that can be called to determine if given serializer is the default\n-     * serializer Jackson uses; as opposed to a custom serializer installed by\n-     * a module or calling application. Determination is done using\n-     * {@link JacksonStdImpl} annotation on serializer class.\n-     * \n-     * @since 1.7\n-     */\n-    protected boolean isDefaultSerializer(JsonSerializer<?> serializer)\n-    {\n-        return (serializer != null && serializer.getClass().getAnnotation(JacksonStdImpl.class) != null);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Efficient implement for serializing {@link Collection}s that contain Strings.\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n         JsonSerializer<?> ser = provider.findValueSerializer(String.class, _property);\n-        if (!isDefaultSerializer(ser)) {\n+        if (!ClassUtil.isJacksonStdImpl(ser)) {\n             _serializer = (JsonSerializer<String>) ser;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n         // Shouldbe able to optimize bit more in future...\n         return defaultInstance().constructType(t).getRawClass();\n     }\n-\n-    /**\n-     * Method used by framework for handling types that are known\n-     * not to have generic types both due to being passed as Class,\n-     * and because caller guarantees that no container types\n-     * are passed (this is important since type modifiers will not\n-     * be consulted).\n-     */\n-    public SimpleType unsafeTrivialType(Class<?> erasedType) {\n-        return new SimpleType(erasedType);\n-    }\n     \n     /*\n-    /**********************************************************\n     /* Type conversion, parameterization resolution methods\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n \n import java.lang.reflect.*;\n import java.util.*;\n+\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n public final class ClassUtil\n {\n \n     /**\n      * Method for finding enclosing class for non-static inner classes\n-     * \n-     * @since 1.9\n      */\n     public static Class<?> getOuterClass(Class<?> type)\n     {\n         return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public static boolean isConcrete(Member member)\n     {\n         int mod = member.getModifiers();\n      * the innermost {@link Exception} or {@link Error} as is.\n      * This is useful in cases where mandatory wrapping is added, which\n      * is often done by Reflection API.\n-     * \n-     * @since 1.7\n      */\n     public static void throwRootCause(Throwable t) throws Exception\n     {\n     /**\n      * Helper method used to get default value for wrappers used for primitive types\n      * (0 for Integer etc)\n-     * \n-     * @since 1.6.1\n      */\n     public static Object defaultValue(Class<?> cls)\n     {\n     /**\n      * Helper method for finding wrapper type for given primitive type (why isn't\n      * there one in JDK?)\n-     * \n-     * @since 1.7.1\n      */\n     public static Class<?> wrapperType(Class<?> primitiveType)\n     {\n      * enumeration type of given {@link EnumSet}, without having\n      * access to its declaration.\n      * Code is needed to work around design flaw in JDK.\n-     * \n-     * @since 1.5\n      */\n     public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)\n \t{\n      * enumeration type of given {@link EnumSet}, without having\n      * access to its declaration.\n      * Code is needed to work around design flaw in JDK.\n-     * \n-     * @since 1.5\n      */\n     public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m)\n     {\n      * or its superclass (for enums with instance fields or methods)\n      */\n     @SuppressWarnings(\"unchecked\")\n-\tpublic static Class<? extends Enum<?>> findEnumType(Class<?> cls)\n+    public static Class<? extends Enum<?>> findEnumType(Class<?> cls)\n     {\n \t\t// enums with \"body\" are sub-classes of the formal type\n \t\tif (cls.getSuperclass() != Enum.class) {\n \t\t}\n \t\treturn (Class<? extends Enum<?>>) cls;\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Jackson-specific stuff\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to determine if given Object is the default\n+     * implementation Jackson uses; as opposed to a custom serializer installed by\n+     * a module or calling application. Determination is done using\n+     * {@link JacksonStdImpl} annotation on handler (serializer, deserializer etc)\n+     * class.\n+     */\n+    public static boolean isJacksonStdImpl(Object impl) {\n+        return (impl != null) && isJacksonStdImpl(impl.getClass());\n+    }\n+\n+    public static boolean isJacksonStdImpl(Class<?> implClass) {\n+        return (implClass.getAnnotation(JacksonStdImpl.class) != null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper classes\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n  * Test cases to verify that it is possible to define serializers\n  * that can use contextual information (like field/method\n  * annotations) for configuration.\n- * \n- * @since 1.7\n  */\n public class TestContextualSerialization extends BaseMapTest\n {\n         public final String[] beans;\n         \n         public ContextualArrayBean(String... strings) {\n+            beans = strings;\n+        }\n+    }\n+\n+    static class ContextualArrayElementBean\n+    {\n+        @Prefix(\"elem->\")\n+        @JsonSerialize(contentUsing=AnnotatedContextualSerializer.class)\n+        public final String[] beans;\n+        \n+        public ContextualArrayElementBean(String... strings) {\n             beans = strings;\n         }\n     }\n     /**********************************************************\n      */\n \n-    /**\n-     * Test to verify that contextual serializer can make use of property\n-     * (method, field) annotations.\n-     */\n+    // Test to verify that contextual serializer can make use of property\n+    // (method, field) annotations.\n     public void testMethodAnnotations() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"{\\\"value\\\":\\\"see:foobar\\\"}\", mapper.writeValueAsString(new ContextualBean(\"foobar\")));\n     }\n \n-    /**\n-     * Test to verify that contextual serializer can also use annotations\n-     * for enclosing class.\n-     */\n+    // Test to verify that contextual serializer can also use annotations\n+    // for enclosing class.\n     public void testClassAnnotations() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"{\\\"wrapped\\\":{\\\"value\\\":\\\"see:xyz\\\"}}\", mapper.writeValueAsString(new ContextualBeanWrapper(\"xyz\")));\n     }\n     \n-    /**\n-     * Serializer should get passed property context even if contained in an array.\n-     */\n+    // Serializer should get passed property context even if contained in an array.\n     public void testMethodAnnotationInArray() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"{\\\"beans\\\":[\\\"array->123\\\"]}\", mapper.writeValueAsString(beans));\n     }\n \n-    /**\n-     * Serializer should get passed property context even if contained in a Collection.\n-     */\n+    // Serializer should get passed property context even if contained in a Collection.\n     public void testMethodAnnotationInList() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"{\\\"beans\\\":[\\\"list->abc\\\"]}\", mapper.writeValueAsString(beans));\n     }\n \n-    /**\n-     * Serializer should get passed property context even if contained in a Collection.\n-     */\n+    // Serializer should get passed property context even if contained in a Collection.\n     public void testMethodAnnotationInMap() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.registerModule(module);\n         assertEquals(quote(\"contextual=true,resolved=true\"), mapper.writeValueAsString(\"abc\"));\n     }\n+\n+    public void testContextualArrayElement() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ContextualArrayElementBean beans = new ContextualArrayElementBean(\"456\");\n+        assertEquals(\"{\\\"beans\\\":[\\\"elem->456\\\"]}\", mapper.writeValueAsString(beans));\n+    }\n }", "timestamp": 1326596889, "metainfo": ""}