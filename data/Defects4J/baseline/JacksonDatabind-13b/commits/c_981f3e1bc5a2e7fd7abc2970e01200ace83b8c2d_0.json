{"sha": "981f3e1bc5a2e7fd7abc2970e01200ace83b8c2d", "log": "Fixing issue #142, problems with EnumMap, polymorphic types", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n                 if (kt == null || !kt.isEnum()) {\n                     throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                 }\n-                deser = new EnumMapDeserializer(type, null, contentDeser);\n+                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n             }\n \n             // Otherwise, generic handler works ok.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     extends StdDeserializer<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 1916979386940205321L;\n+    private static final long serialVersionUID = 1518773374647478964L;\n \n     protected final JavaType _mapType;\n     \n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n+\n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n+    public EnumMapDeserializer(JavaType mapType,\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser) {\n+        this(mapType, keyDeserializer, valueDeser, null);\n+    }\n     \n     public EnumMapDeserializer(JavaType mapType,\n-            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser)\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n     {\n         super(EnumMap.class);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n         _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n     }\n \n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n     public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n             JsonDeserializer<?> valueDeserializer)\n     {\n-        if ((keyDeserializer == _keyDeserializer) && valueDeserializer == _valueDeserializer) {\n+        return withResolved(keyDeserializer, valueDeserializer, null);\n+    } \n+    \n+    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n+            JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    {\n+        if ((keyDeserializer == _keyDeserializer)\n+                && (valueDeserializer == _valueDeserializer)\n+                && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         }\n         return new EnumMapDeserializer(_mapType,\n-                keyDeserializer, valueDeserializer);\n+                keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n     }\n     \n     /**\n                 vd = ((ContextualDeserializer) vd).createContextual(ctxt, property);\n             }\n         }\n-\n-        return withResolved(kd, vd);\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vd, vtd);\n     }\n     \n     /**\n             throw ctxt.mappingException(EnumMap.class);\n         }\n         EnumMap result = constructMap();\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n             Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             /* note: MUST check for nulls separately: deserializers will\n              * not handle them (and maybe fail or return bogus data)\n              */\n-            Object value = (t == JsonToken.VALUE_NULL) ?\n-                null :  _valueDeserializer.deserialize(jp, ctxt);\n+            Object value;\n+            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value =  valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n             result.put(key, value);\n         }\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             t = jp.nextToken();\n         }\n         final KeyDeserializer keyDes = _keyDeserializer;\n-        \n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n         JsonSerializer<Object> prevSerializer = null;\n         Class<?> prevClass = null;\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             // First, serialize key\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            // And then value\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n+                continue;\n+            }\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> currSerializer;\n+            if (cc == prevClass) {\n+                currSerializer = prevSerializer;\n             } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevClass) {\n-                    currSerializer = prevSerializer;\n+                currSerializer = provider.findValueSerializer(cc, _property);\n+                prevSerializer = currSerializer;\n+                prevClass = cc;\n+            }\n+            try {\n+                if (vts == null) {\n+                    currSerializer.serialize(valueElem, jgen, provider);\n                 } else {\n-                    currSerializer = provider.findValueSerializer(cc, _property);\n-                    prevSerializer = currSerializer;\n-                    prevClass = cc;\n+                    currSerializer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n-                try {\n-                    currSerializer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n-                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n         throws IOException, JsonGenerationException\n     {\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 // clumsy, but has to do for now:\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n-            } else {\n-                try {\n+                continue;\n+            }\n+            try {\n+                if (vts == null) {\n                     valueSer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n+                } else {\n+                    valueSer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n             return new KeyType(v, true);\n         }\n     }\n+\n+    // Issue #142\n+    public static class EnumMapContainer {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+        public EnumMap<KeyEnum,ITestType> testTypes;\n+    }\n+\n+    public static class ListContainer {\n+        public List<ITestType> testTypes;\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+    public static interface ITestType { }\n+\n+    public static enum KeyEnum {\n+        A, B\n+    }\n+    public static enum ConcreteType implements ITestType {\n+        ONE, TWO;\n+    }\n+\n+    \n     \n     /*\n     /**********************************************************\n         assertNull(result.get(Key.WHATEVER));\n         assertNull(result.get(Key.KEY1));\n     }\n-    \n+\n+    public void testEnumPolymorphicSerializationTest() throws Exception \n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        List<ITestType> testTypesList = new ArrayList<ITestType>();\n+        testTypesList.add(ConcreteType.ONE);\n+        testTypesList.add(ConcreteType.TWO);\n+        ListContainer listContainer = new ListContainer();\n+        listContainer.testTypes = testTypesList;\n+        String json = mapper.writeValueAsString(listContainer);\n+        listContainer = mapper.readValue(json, ListContainer.class);\n+        EnumMapContainer enumMapContainer = new EnumMapContainer();\n+        EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);\n+        testTypesMap.put(KeyEnum.A, ConcreteType.ONE);\n+        testTypesMap.put(KeyEnum.B, ConcreteType.TWO);\n+        enumMapContainer.testTypes = testTypesMap;\n+        \n+        json = mapper.writeValueAsString(enumMapContainer);\n+        enumMapContainer = mapper.readValue(json, EnumMapContainer.class);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods, maps with Date", "timestamp": 1357705907, "metainfo": ""}