{"sha": "993292ca6e0539f8393320b4bfe819dad7553b19", "log": "Fixed Map deserialization with forward reference not keeping ordering.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        MapReferring referringAccumulator = null;\n-        if(valueDes.getObjectIdReader() != null){\n-            referringAccumulator = new MapReferring(result);\n+        MapReferringAccumuator referringAccumulator = null;\n+        boolean useObjectId = valueDes.getObjectIdReader() != null;\n+        if (useObjectId) {\n+            referringAccumulator = new MapReferringAccumuator(result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n                  *   that there are no duplicate field names? (and/or what\n                  *   to do, keep-first or keep-last)\n                  */\n-                result.put(key, value);\n+                if (useObjectId) {\n+                    referringAccumulator.put(key, value);\n+                } else {\n+                    result.put(key, value);\n+                }\n             } catch(UnresolvedForwardReference reference) {\n                 handleUnresolvedReference(jp, referringAccumulator, key, reference);\n             }\n         }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        MapReferring referringAccumulator = null;\n-        if(valueDes.getObjectIdReader() != null){\n-            referringAccumulator = new MapReferring(result);\n+        MapReferringAccumuator referringAccumulator = null;\n+        boolean useObjectId = valueDes.getObjectIdReader() != null;\n+        if (useObjectId) {\n+            referringAccumulator = new MapReferringAccumuator(result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n                 } else {\n                     value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                 }\n-                result.put(fieldName, value);\n+                if (useObjectId) {\n+                    referringAccumulator.put(fieldName, value);\n+                } else {\n+                    result.put(fieldName, value);\n+                }\n             } catch (UnresolvedForwardReference reference) {\n                 handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n             }\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferring referring, Object key,\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumuator accumulator, Object key,\n             UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n-        if (referring == null) {\n+        if (accumulator == null) {\n             throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n         }\n-        referring.flagUnresolved(reference.getUnresolvedId(), key);\n+        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final class MapReferring implements Referring {\n-        private Map<Object,Object> _accumulator = new HashMap<Object,Object>();\n+    private final class MapReferringAccumuator  {\n         private Map<Object,Object> _result;\n-\n-        public MapReferring(Map<Object,Object> result)\n+        /**\n+         * A list of {@link UnresolvedId} to maintain ordering.\n+         */\n+        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+\n+        public MapReferringAccumuator(Map<Object, Object> result)\n         {\n             _result = result;\n         }\n \n-        @Override\n-        public void handleResolvedForwardReference(Object id, Object value)\n+        public void put(Object key, Object value)\n+        {\n+            if (_accumulator.isEmpty()) {\n+                _result.put(key, value);\n+            } else {\n+                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                unresolvedId._next.put(key, value);\n+            }\n+        }\n+\n+        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n+        {\n+            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation());\n+            _accumulator.add(id);\n+            return id;\n+        }\n+\n+        public void resolveForwardReference(Object id, Object value)\n             throws IOException\n         {\n-            if (!_accumulator.containsKey(id)) {\n-                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n-                        + \"] that wasn't previously seen as unresolved.\");\n-            }\n-            Object key = _accumulator.get(id);\n-            _result.put(key, value);\n-        }\n-\n-        public void flagUnresolved(Object id, Object key)\n-        {\n-            _accumulator.put(id, key);\n+            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            // Resolve ordering after resolution of an id. This mean either:\n+            // 1- adding to the result map in case of the first unresolved id.\n+            // 2- merge the content of the resolved id with its previous unresolved id.\n+            Map<Object,Object> previous = _result;\n+            while (iterator.hasNext()) {\n+                UnresolvedId unresolvedId = iterator.next();\n+                if (unresolvedId._id.equals(id)) {\n+                    iterator.remove();\n+                    previous.put(unresolvedId._key, value);\n+                    previous.putAll(unresolvedId._next);\n+                    return;\n+                }\n+                previous = unresolvedId._next;\n+            }\n+\n+            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                    + \"] that wasn't previously seen as unresolved.\");\n+        }\n+\n+        /**\n+         * Helper class to maintain processing order of value. The resolved\n+         * object associated with {@link #_id} comes before the values in\n+         * {@link _next}.\n+         */\n+        private final class UnresolvedId extends Referring {\n+            private final Object _id;\n+            private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n+            private final Object _key;\n+\n+            private UnresolvedId(Object key, Object id, JsonLocation location)\n+            {\n+                super(location);\n+                _key = key;\n+                _id = id;\n+            }\n+\n+            @Override\n+            public void handleResolvedForwardReference(Object id, Object value)\n+                throws IOException\n+            {\n+                resolveForwardReference(id, value);\n+            }\n         }\n     }\n }", "timestamp": 1389625653, "metainfo": ""}