{"sha": "6870021b9433496004a3a5dd7772af0c7f93b9ca", "log": "A fix related to JsonNode serialization; JsonNode should be JsonSerializable.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n  * and {@link ObjectMapper#treeAsTokens(TreeNode)}\n  */\n public abstract class JsonNode\n-    implements TreeNode, Iterable<JsonNode>\n+    implements TreeNode, Iterable<JsonNode>,\n+        JsonSerializable // since 2.5; bit tricky if anyone is sub-classing but...\n {\n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime\n-     * type.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n     public <W extends ObjectWriter> W writerWithType(Class<?> rootType) {\n         return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n+     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n     public <W extends ObjectWriter> W writerWithType(TypeReference<?> rootType) {\n         return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n+     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n     public <W extends ObjectWriter> W writerWithType(JavaType rootType) {\n         return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n-import java.text.DateFormat;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.TimeZone;\n+import java.text.*;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.core.util.Instantiatable;\n-import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.core.util.*;\n+\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         private final CollectionReferringAccumulator _parent;\n         public final List<Object> next = new ArrayList<Object>();\n         \n-        private CollectionReferring(CollectionReferringAccumulator parent,\n+        CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n         {\n             super(reference, contentType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n-        private final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n+        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n+        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n         \n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n-        private final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n+        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n+        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n         \n         public ByteDeserializer(Class<Byte> cls, Byte nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n-        private final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n+        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n+        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n         \n         public ShortDeserializer(Class<Short> cls, Short nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n-        private final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n+        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n+        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n         \n         public CharacterDeserializer(Class<Character> cls, Character nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n-        private final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n+        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n+        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n         \n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n-        private final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n+        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n+        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n         \n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n-        private final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n+        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n+        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n         \n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n-        private final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n+        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n+        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n         \n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n--- a/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n         }\n     }\n \n-    private static class PrivateThing\n+    static class PrivateThing\n     {\n         @JsonAnyGetter\n         public Map<?,?> getProperties()\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n \n     public void testManualPolymorphicWithNumbered() throws Exception\n     {\n-         final ObjectWriter w = MAPPER.writerWithType(AbstractRoot.class);\n+         final ObjectWriter w = MAPPER.writerFor(AbstractRoot.class);\n          final ObjectReader r = MAPPER.reader(AbstractRoot.class);\n \n          AbstractRoot input = AbstractRoot.make(1, \"oh hai!\");\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java\n \t@JsonSubTypes({\n \t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = \"One\"),\n \t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = \"Two\")})\n-\tprivate static abstract class ForwardReferenceClass\n+\tstatic abstract class ForwardReferenceClass\n \t{\n \t\tpublic String id;\n \t\tpublic void setId(String id) {\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n-        byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n+        byte[] json = mapper.writerFor(rootType).writeValueAsBytes(input);\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n             JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n-            String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n+            String json = mapper.writerFor(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n             }\n             l2.add(new Issue508A());\n             l.add(l2);\n             TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};\n-            String json = mapper.writerWithType(typeRef).writeValueAsString(l);\n+            String json = mapper.writerFor(typeRef).writeValueAsString(l);\n \n             List<?> output = mapper.readValue(json, typeRef);\n             assertEquals(1, output.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n         List<Super> list = new ArrayList<Super>();\n         list.add(new A());\n         map.put(1L, list);\n-        String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n+        String json = mapper.writerFor(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n         assertTrue(\"JSON does not contain '@class': \"+json, json.contains(\"@class\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerFor(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n \n         // also: let's ensure that ObjectWriter won't interfere with it\n         bean = new CloseableBean();\n-        m.writerWithType(CloseableBean.class).writeValueAsString(bean);\n+        m.writerFor(CloseableBean.class).writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n \n     public void testUsingObjectWriter() throws IOException\n     {\n-        ObjectWriter w = MAPPER.writerWithType(Object.class);\n+        ObjectWriter w = MAPPER.writerFor(Object.class);\n         Map<String,Object> map = new LinkedHashMap<String,Object>();\n         map.put(\"a\", 1);\n         String json = w.writeValueAsString(map);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Unit tests for checking features added to {@link ObjectWriter}, such\n         assertEquals(\"{\\\"a\\\":1}\", writer.with(JsonGenerator.Feature.QUOTE_FIELD_NAMES)\n                 .writeValueAsString(map));\n     }\n-} \n+\n+    public void testObjectWriterWithNode() throws Exception\n+    {\n+        ObjectNode stuff = MAPPER.createObjectNode();\n+        stuff.put(\"a\", 5);\n+        ObjectWriter writer = MAPPER.writerFor(JsonNode.class);\n+        String json = writer.writeValueAsString(stuff);\n+        assertEquals(\"{\\\"a\\\":5}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n         assertEquals(Boolean.TRUE, result.get(\"b2\"));\n \n         // and then using specified typed writer\n-        ObjectWriter w = mapper.writerWithType(BaseType.class);\n+        ObjectWriter w = mapper.writerFor(BaseType.class);\n         String json = w.writeValueAsString(bean);\n         result = (Map<String,Object>)mapper.readValue(json, Map.class);\n         assertEquals(2, result.size());\n         SubType bean = new SubType();\n \n         // let's constrain by interface:\n-        ObjectWriter w = mapper.writerWithType(BaseInterface.class);\n+        ObjectWriter w = mapper.writerFor(BaseInterface.class);\n         String json = w.writeValueAsString(bean);\n         @SuppressWarnings(\"unchecked\")\n         Map<String,Object> result = mapper.readValue(json, Map.class);\n         // must force static typing, otherwise won't matter a lot\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n-        String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n+        String json = mapper.writerFor(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n         assertEquals(\"[{\\\"b\\\":3}]\", json);\n     }\n         SubType bean = new SubType();\n \n         // and then let's try using incompatible type\n-        ObjectWriter w = mapper.writerWithType(HashMap.class);\n+        ObjectWriter w = mapper.writerFor(HashMap.class);\n         try {\n             w.writeValueAsString(bean);\n             fail(\"Should have failed due to incompatible type\");\n         final String EXP = \"[{\\\"beanClass\\\":\\\"TestRootType$TestClass398\\\",\\\"property\\\":\\\"aa\\\"}]\";\n         \n         // First simplest way:\n-        String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);\n+        String json = mapper.writerFor(collectionType).writeValueAsString(typedList);\n         assertEquals(EXP, json);\n \n         StringWriter out = new StringWriter();\n         JsonFactory f = new JsonFactory();\n-        mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList);\n+        mapper.writerFor(collectionType).writeValue(f.createGenerator(out), typedList);\n \n         assertEquals(EXP, out.toString());\n     }\n     public void testIssue456WrapperPart() throws Exception\n     {\n         ObjectMapper mapper = objectMapper();\n-        assertEquals(\"123\", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n-        assertEquals(\"456\", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n+        assertEquals(\"123\", mapper.writerFor(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n+        assertEquals(\"456\", mapper.writerFor(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n     }\n \n     // [JACKSON-630] also, allow annotation to define root name\n         cmd.uuid = \"1234\";\n         cmd.type = 1;\n \n-        ObjectWriter writer = WRAP_ROOT_MAPPER.writerWithType(TestCommandParent.class);\n+        ObjectWriter writer = WRAP_ROOT_MAPPER.writerFor(TestCommandParent.class);\n         String json =  writer.writeValueAsString(cmd);\n \n         assertEquals(json, \"{\\\"TestCommandParent\\\":{\\\"uuid\\\":\\\"1234\\\",\\\"type\\\":1}}\");\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n     public void testTypedSerialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        String singleJson = mapper.writerFor(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n         // start with specific value case:\n         assertEquals(\"{\\\"a\\\":3}\", singleJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n // Work-around when real solution not yet implemented:        \n //        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n-        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerFor(Issue822Interface[].class).writeValueAsString(\n                 new Issue822Interface[] { new Issue822Impl() }));\n     }\n     \n \n         List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n         list.add(new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<List<Issue822Interface>>(){})\n                 .writeValueAsString(list);\n         assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n         Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();\n         map.put(\"a\", new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<Map<String,Issue822Interface>>(){})\n                 .writeValueAsString(map);\n         assertEquals(\"{\\\"a\\\":{\\\"a\\\":3}}\", listJson);\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n         public final int p;\n \n         @JsonCreator\n-        private Pojo(@JsonProperty(\"p\") int p) {\n+        Pojo(@JsonProperty(\"p\") int p) {\n             this.p = p;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n public class TestUnwrappedWithCreator extends BaseMapTest\n {\n     static class JAddress {\n-        private String address;\n-        private String city;\n-        private String state;\n+        protected String address;\n+        protected String city;\n+        protected String state;\n          \n         @JsonCreator\n-        public JAddress(\n-                @JsonProperty(\"address\") String address,\n+        public JAddress( @JsonProperty(\"address\") String address,\n                 @JsonProperty(\"city\") String city,\n                 @JsonProperty(\"state\") String state\n         ){\n     }\n \n     static class JPerson {\n-        private String _name;\n-        private JAddress _address;\n-        private String _alias;\n+        protected String _name;\n+        protected JAddress _address;\n+        protected String _alias;\n          \n         @JsonCreator\n-        public JPerson(\n-        @JsonProperty(\"name\") String name,\n+        public JPerson(@JsonProperty(\"name\") String name,\n         @JsonUnwrapped JAddress address,\n-        @JsonProperty(\"alias\") String alias\n-        ) {\n+        @JsonProperty(\"alias\") String alias) {\n             _name = name;\n             _address = address;\n             _alias = alias;", "timestamp": 1416447778, "metainfo": ""}