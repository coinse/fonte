{"sha": "920bb4e447b7ff1419c926277ebac4c9406de0f5", "log": "Completed refactoring of AnnotatedClass, now fully lazily initialized", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n     public static AnnotatedClass construct(Class<?> cls,\n             AnnotationIntrospector aintr, MixInResolver mir)\n     {\n-        List<Class<?>> st = ClassUtil.findSuperTypes(cls, null);\n-        return new AnnotatedClass(cls, st, aintr, mir, null);\n+        return new AnnotatedClass(cls,\n+                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n     }\n \n     /**\n     public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n             AnnotationIntrospector aintr, MixInResolver mir)\n     {\n-        List<Class<?>> empty = Collections.emptyList();\n-        return new AnnotatedClass(cls, empty, aintr, mir, null);\n+        return new AnnotatedClass(cls,\n+                Collections.<Class<?>>emptyList(), aintr, mir, null);\n     }\n     \n     /*\n \n     public Iterable<AnnotatedMethod> memberMethods()\n     {\n+        if (_memberMethods == null) {\n+            resolveMemberMethods();\n+        }\n         return _memberMethods;\n     }\n \n     public int getMemberMethodCount()\n     {\n+        if (_memberMethods == null) {\n+            resolveMemberMethods();\n+        }\n         return _memberMethods.size();\n     }\n \n     public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n     {\n+        if (_memberMethods == null) {\n+            resolveMemberMethods();\n+        }\n         return _memberMethods.find(name, paramTypes);\n     }\n \n      * \n      * @param methodFilter Filter used to determine which methods to include\n      */\n-    public void resolveMemberMethods(MethodFilter methodFilter)\n+    private void resolveMemberMethods()\n     {\n         _memberMethods = new AnnotatedMethodMap();\n         AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n         // first: methods from the class itself\n-        _addMemberMethods(_class, methodFilter, _memberMethods, _primaryMixIn, mixins);\n+        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n \n         // and then augment these with annotations from super-types:\n         for (Class<?> cls : _superTypes) {\n             Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);\n-            _addMemberMethods(cls, methodFilter, _memberMethods, mixin, mixins);\n+            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n         }\n         // Special case: mix-ins for Object.class? (to apply to ALL classes)\n         if (_mixInResolver != null) {\n             Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n             if (mixin != null) {\n-                _addMethodMixIns(methodFilter, _memberMethods, mixin, mixins);\n+                _addMethodMixIns(_memberMethods, mixin, mixins);\n             }\n         }\n \n     /**********************************************************\n      */\n \n-    protected void _addMemberMethods(Class<?> cls,\n-            MethodFilter methodFilter, AnnotatedMethodMap methods,\n+    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n     {\n         // first, mixIns, since they have higher priority then class methods\n         if (mixInCls != null) {\n-            _addMethodMixIns(methodFilter, methods, mixInCls, mixIns);\n+            _addMethodMixIns(methods, mixInCls, mixIns);\n         }        \n         if (cls == null) { // just so caller need not check when passing super-class\n             return;\n \n         // then methods from the class itself\n         for (Method m : cls.getDeclaredMethods()) {\n-            if (!_isIncludableMethod(m, methodFilter)) {\n+            if (!_isIncludableMemberMethod(m)) {\n                 continue;\n             }\n             AnnotatedMethod old = methods.find(m);\n         }\n     }\n \n-    protected void _addMethodMixIns(MethodFilter methodFilter, AnnotatedMethodMap methods,\n+    protected void _addMethodMixIns(AnnotatedMethodMap methods,\n             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n     {\n         for (Method m : mixInCls.getDeclaredMethods()) {\n-            if (!_isIncludableMethod(m, methodFilter)) {\n+            if (!_isIncludableMemberMethod(m)) {\n                 continue;\n             }\n             AnnotatedMethod am = methods.find(m);\n     /**********************************************************\n      */\n \n-    protected boolean _isIncludableMethod(Method m, MethodFilter filter)\n-    {\n-        if (filter != null && !filter.includeMethod(m)) {\n+    protected boolean _isIncludableMemberMethod(Method m)\n+    {\n+        if (Modifier.isStatic(m.getModifiers())) {\n             return false;\n         }\n         /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n         if (m.isSynthetic() || m.isBridge()) {\n             return false;\n         }\n-        return true;\n+        // also, for now we have no use for methods with 2 or more arguments:\n+        int pcount = m.getParameterTypes().length;\n+        return (pcount <= 2);\n     }\n \n     private boolean _isIncludableField(Field f)\n    {\n        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n    }\n-    \n+   \n     /*\n     /**********************************************************\n     /* Other methods\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n         AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Long.TYPE, null, null);\n         LONG_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(Long.TYPE), ac);\n     }\n-\n-    // // // Then static filter singletons\n-    \n-    protected final static MethodFilter MINIMAL_FILTER = new MinimalMethodFilter();\n     \n     /*\n     /**********************************************************\n     public POJOPropertiesCollector collectProperties(MapperConfig<?> config,\n             JavaType type, MixInResolver r, boolean forSerialization)\n     {\n-        AnnotatedClass ac = classWithCreators(config, type, r);\n-        ac.resolveMemberMethods(MINIMAL_FILTER);\n+        boolean useAnnotations = config.isAnnotationProcessingEnabled();\n+        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                (useAnnotations ? config.getAnnotationIntrospector() : null), r);\n         return constructPropertyCollector(config, ac, type, forSerialization).collect();\n     }\n \n             boolean forSerialization)\n     {\n         return new POJOPropertiesCollector(config, forSerialization, type, ac);\n-    }\n-    \n-    public AnnotatedClass classWithCreators(MapperConfig<?> config,\n-            JavaType type, MixInResolver r)\n-    {\n-        boolean useAnnotations = config.isAnnotationProcessingEnabled();\n-        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? ai : null), r);\n-        ac.resolveMemberMethods(MINIMAL_FILTER);\n-        return ac;\n     }\n     \n     /**\n         }\n         return null;\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Going forward, we will only do very minimal filtering;\n-     * mostly just gets rid of static methods really.\n-     */\n-    private static class MinimalMethodFilter\n-        implements MethodFilter\n-    {\n-        @Override\n-        public boolean includeMethod(Method m)\n-        {\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                return false;\n-            }\n-            int pcount = m.getParameterTypes().length;\n-            return (pcount <= 2);\n-        }\n-    }\n }", "timestamp": 1327298446, "metainfo": ""}