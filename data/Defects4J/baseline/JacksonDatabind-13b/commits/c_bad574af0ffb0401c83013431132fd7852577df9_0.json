{"sha": "bad574af0ffb0401c83013431132fd7852577df9", "log": "Improving java.sql.Date serialization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n         return this;\n     }\n-    \n+\n+    /**\n+     * Method that allows overriding of the underlying {@link DeserializationConfig}\n+     * object.\n+     * It is added as a fallback method that may be used if no other configuration\n+     * modifier method works: it should not be used if there are alternatives,\n+     * and its use is generally discouraged.\n+     *<p>\n+     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n+     * by-passing some of checks applied to other configuration methods.\n+     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n+     * this is only thread-safe if done before calling any deserialization methods.\n+     * \n+     * @since 2.4\n+     */\n+    public ObjectMapper setConfig(DeserializationConfig config) {\n+    \t_deserializationConfig = config;\n+    \treturn this;\n+    }\n     \n     /*\n     /**********************************************************\n         _serializationConfig = _serializationConfig.with(v);\n         _deserializationConfig = _deserializationConfig.with(v);\n         return this;\n+    }\n+\n+    /**\n+     * Method that allows overriding of the underlying {@link SerializationConfig}\n+     * object, which contains serialization-specific configuration settings.\n+     * It is added as a fallback method that may be used if no other configuration\n+     * modifier method works: it should not be used if there are alternatives,\n+     * and its use is generally discouraged.\n+     *<p>\n+     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n+     * by-passing some of checks applied to other configuration methods.\n+     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n+     * this is only thread-safe if done before calling any serialization methods.\n+     * \n+     * @since 2.4\n+     */\n+    public ObjectMapper setConfig(SerializationConfig config) {\n+    \t_serializationConfig = config;\n+    \treturn this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n {\n     public static final CalendarSerializer instance = new CalendarSerializer();\n \n-    public CalendarSerializer() { this(false, null); }\n+    public CalendarSerializer() { this(null, null); }\n \n-    public CalendarSerializer(boolean useTimestamp, DateFormat customFormat) {\n+    public CalendarSerializer(Boolean useTimestamp, DateFormat customFormat) {\n         super(Calendar.class, useTimestamp, customFormat);\n     }\n \n     @Override\n-    public CalendarSerializer withFormat(boolean timestamp, DateFormat customFormat)\n-    {\n-        if (timestamp) {\n-            return new CalendarSerializer(true, null);\n-        }\n-        return new CalendarSerializer(false, customFormat);\n+    public CalendarSerializer withFormat(Boolean timestamp, DateFormat customFormat) {\n+        return new CalendarSerializer(timestamp, customFormat);\n     }\n \n     @Override\n     public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        if (_useTimestamp) {\n+        if (_asTimestamp(provider)) {\n             jgen.writeNumber(_timestamp(value));\n         } else if (_customFormat != null) {\n             // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n     public static final DateSerializer instance = new DateSerializer();\n     \n     public DateSerializer() {\n-        this(false, null);\n+        this(null, null);\n     }\n         \n-    public DateSerializer(boolean useTimestamp, DateFormat customFormat) {\n+    public DateSerializer(Boolean useTimestamp, DateFormat customFormat) {\n         super(Date.class, useTimestamp, customFormat);\n     }\n \n     @Override\n-    public DateSerializer withFormat(boolean timestamp, DateFormat customFormat)\n-    {\n-        if (timestamp) {\n-            return new DateSerializer(true, null);\n-        }\n-        return new DateSerializer(false, customFormat);\n+    public DateSerializer withFormat(Boolean timestamp, DateFormat customFormat) {\n+        return new DateSerializer(timestamp, customFormat);\n     }\n \n     @Override\n     public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        if (_useTimestamp) {\n+        if (_asTimestamp(provider)) {\n             jgen.writeNumber(_timestamp(value));\n         } else if (_customFormat != null) {\n             // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n      * Flag that indicates that serialization must be done as the\n      * Java timestamp, regardless of other settings.\n      */\n-    protected final boolean _useTimestamp;\n+    protected final Boolean _useTimestamp;\n     \n     /**\n      * Specific format to use, if not default format: non null value\n     protected final DateFormat _customFormat;\n \n     protected DateTimeSerializerBase(Class<T> type,\n-            boolean useTimestamp, DateFormat customFormat)\n+            Boolean useTimestamp, DateFormat customFormat)\n     {\n         super(type);\n         _useTimestamp = useTimestamp;\n         _customFormat = customFormat;\n     }\n \n-    public abstract DateTimeSerializerBase<T> withFormat(boolean timestamp, DateFormat customFormat);\n+    public abstract DateTimeSerializerBase<T> withFormat(Boolean timestamp, DateFormat customFormat);\n \n     @Override\n     public JsonSerializer<?> createContextual(SerializerProvider prov,\n         if (property != null) {\n             JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n             if (format != null) {\n-                // Simple case first: serialize as numeric timestamp?\n+\n+            \t// Simple case first: serialize as numeric timestamp?\n                 if (format.getShape().isNumeric()) {\n-                    return withFormat(true, null);\n+                    return withFormat(Boolean.TRUE, null);\n                 }\n+\n+        \t\tBoolean asNumber = (format.getShape() == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;\n                 // If not, do we have a pattern?\n                 TimeZone tz = format.getTimeZone();\n                 if (format.hasPattern()) {\n                         tz = prov.getTimeZone();\n                     }\n                     df.setTimeZone(tz);\n-                    return withFormat(false, df);\n+                    return withFormat(asNumber, df);\n                 }\n                 // If not, do we at least have a custom timezone?\n                 if (tz != null) {\n                         df = (DateFormat) df.clone();\n                         df.setTimeZone(tz);\n                     }\n-                    return withFormat(false, df);\n+                    return withFormat(asNumber, df);\n                 }\n             }\n         }\n     protected abstract long _timestamp(T value);\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n         //todo: (ryan) add a format for the date in the schema?\n-        boolean asNumber = _useTimestamp;\n-        if (!asNumber) {\n-            if (_customFormat == null) {\n-                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n-            }\n-        }\n-        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n+        return createSchemaNode(_asTimestamp(provider) ? \"number\" : \"string\", true);\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n-        boolean asNumber = _useTimestamp;\n-        if (!asNumber) {\n-            if (_customFormat == null) {\n-                asNumber = visitor.getProvider().isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n-            }\n+        _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected boolean _asTimestamp(SerializerProvider provider) {\n+        if (_useTimestamp != null) {\n+        \treturn _useTimestamp.booleanValue();\n         }\n+        if (_customFormat == null) {\n+        \treturn provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        }\n+        return false;\n+    }\n+\n+    protected void _acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint,\n+\t\tboolean asNumber) throws JsonMappingException\n+    {\n         if (asNumber) {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) {\n             }\n         }\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Actual serialization\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.text.DateFormat;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n /**\n  * Compared to regular {@link java.util.Date} serialization, we do use String\n  */\n @JacksonStdImpl\n public class SqlDateSerializer\n-    extends StdScalarSerializer<java.sql.Date>\n+    extends DateTimeSerializerBase<java.sql.Date>\n {\n-    public SqlDateSerializer() { super(java.sql.Date.class); }\n+    public SqlDateSerializer() {\n+        /* 12-Apr-2014, tatu: for now, pass explicit 'false' to mean 'not using timestamp',\n+         *     for backwards compatibility; this differs from other Date/Calendar types.\n+         */\n+    \tthis(Boolean.FALSE);\n+    }\n \n+    protected SqlDateSerializer(Boolean useTimestamp) {\n+    \tsuper(java.sql.Date.class, useTimestamp, null);\n+    }\n+\n+    @Override\n+    public SqlDateSerializer withFormat(Boolean timestamp, DateFormat customFormat) {\n+    \treturn new SqlDateSerializer(timestamp);\n+    }\n+\n+    @Override\n+    protected long _timestamp(java.sql.Date value) {\n+        return (value == null) ? 0L : value.getTime();\n+    }\n+    \n     @Override\n     public void serialize(java.sql.Date value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        jgen.writeString(value.toString());\n+        if (_useTimestamp) {\n+            jgen.writeNumber(_timestamp(value));\n+        } else {\n+        \tjgen.writeString(value.toString());\n+        }\n     }\n \n     @Override\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n-        JsonStringFormatVisitor v2 = (visitor == null) ? null : visitor.expectStringFormat(typeHint);\n-        if (v2 != null) {\n-            v2.format(JsonValueFormat.DATE_TIME);\n-        }\n+    \t_acceptJsonFormatVisitor(visitor, typeHint, _useTimestamp);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         public DateAsNumberBean(long l) { date = new java.util.Date(l); }\n     }\n \n+    static class SqlDateAsDefaultBean {\n+        public java.sql.Date date;\n+        public SqlDateAsDefaultBean(long l) { date = new java.sql.Date(l); }\n+    }\n+\n+    static class SqlDateAsNumberBean {\n+        @JsonFormat(shape=JsonFormat.Shape.NUMBER)\n+        public java.sql.Date date;\n+        public SqlDateAsNumberBean(long l) { date = new java.sql.Date(l); }\n+    }\n+    \n     static class DateAsStringBean {\n         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd\")\n         public Date date;\n         // use date 1999-04-01 (note: months are 0-based, use constant)\n         java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);\n         assertEquals(quote(\"1999-04-01\"), MAPPER.writeValueAsString(date));\n+\n+        assertEquals(aposToQuotes(\"{'date':'1969-12-31'}\"), MAPPER.writeValueAsString(new SqlDateAsDefaultBean(0L)));\n+\n+        // but may explicitly force timestamp too\n+        assertEquals(aposToQuotes(\"{'date':0}\"), MAPPER.writeValueAsString(new SqlDateAsNumberBean(0L)));\n     }\n \n     public void testTimeZone() throws IOException\n         // first: test overriding writing as timestamp\n         mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n         json = mapper.writeValueAsString(new DateAsNumberBean(0L));\n-        assertEquals(\"{\\\"date\\\":0}\", json);\n+        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n \n         // then reverse\n         mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);", "timestamp": 1397336587, "metainfo": ""}