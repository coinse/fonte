{"sha": "24cbdbdfcf3eab994dd202d60c30f094adc3617d", "log": "Implemented forward reference resolution for collection based deserialization.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         JsonToken t;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-\n+        CollectionReferring referringAccumulator = null;\n+        if(valueDes.getObjectIdReader() != null){\n+            referringAccumulator = new CollectionReferring(result);\n+        }\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            result.add(value);\n+            try {\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                if (referringAccumulator != null) {\n+                    referringAccumulator.add(value);\n+                } else {\n+                    result.add(value);\n+                }\n+            } catch (UnresolvedForwardReference reference) {\n+                if (referringAccumulator == null) {\n+                    throw JsonMappingException\n+                            .from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+                }\n+                referringAccumulator.flagUnresolved(reference.getUnresolvedId());\n+                reference.getRoid().appendReferring(referringAccumulator);\n+            }\n         }\n         return result;\n     }\n         return result;\n     }\n \n+    public final class CollectionReferring implements Referring {\n+        private Collection<Object> _result;\n+        /**\n+         * A list of {@link UnresolvedId} to maintain ordering.\n+         */\n+        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+\n+        public CollectionReferring(Collection<Object> result)\n+        {\n+            _result = result;\n+        }\n+\n+        public void add(Object value)\n+        {\n+            if (_accumulator.isEmpty()) {\n+                _result.add(value);\n+            } else {\n+                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                unresolvedId._next.add(value);\n+            }\n+        }\n+\n+        public void flagUnresolved(Object id)\n+        {\n+            _accumulator.add(new UnresolvedId(id));\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            // Resolve ordering after resolution of an id. This mean either:\n+            // 1- adding to the result collection in case of the first unresolved id.\n+            // 2- merge the content of the resolved id with its previous unresolved id.\n+            Collection<Object> previous = _result;\n+            while (iterator.hasNext()) {\n+                UnresolvedId unresolvedId = iterator.next();\n+                if (unresolvedId._id.equals(id)) {\n+                    iterator.remove();\n+                    previous.add(value);\n+                    previous.addAll(unresolvedId._next);\n+                    return;\n+                }\n+                previous = unresolvedId._next;\n+            }\n+\n+            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                    + \"] that wasn't previously seen as unresolved.\");\n+        }\n+    }\n+\n+    /**\n+     * Helper class to maintain processing order of value. The resolved object\n+     * associated with {@link #_id} comes before the values in {@link _next}.\n+     */\n+    private static final class UnresolvedId {\n+        private final Object _id;\n+        private final List<Object> _next = new ArrayList<Object>();\n+\n+        private UnresolvedId(Object id)\n+        {\n+            _id = id;\n+        }\n+    }\n }", "timestamp": 1389625653, "metainfo": ""}