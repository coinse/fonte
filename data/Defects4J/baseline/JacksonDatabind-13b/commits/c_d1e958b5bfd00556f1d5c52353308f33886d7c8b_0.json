{"sha": "d1e958b5bfd00556f1d5c52353308f33886d7c8b", "log": "more work on [#120], now Map type", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         return deser;\n     }\n \n-    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n-    @Override\n-    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n-            CollectionLikeType type, final BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        JavaType contentType = type.getContentType();\n-        // Very first thing: is deserializer hard-coded for elements?\n-        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n-\n-        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n-        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n-        // but if not, may still be possible to find:\n-        if (contentTypeDeser == null) {\n-            contentTypeDeser = findTypeDeserializer(ctxt.getConfig(), contentType);\n-        }\n-        return _findCustomCollectionLikeDeserializer(type, ctxt.getConfig(), beanDesc,\n-                contentTypeDeser, contentDeser);\n-    }\n-  \n     protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n             }\n         }\n         return null;\n+    }\n+    \n+    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n+    @Override\n+    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n+            CollectionLikeType type, final BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        JavaType contentType = type.getContentType();\n+        // Very first thing: is deserializer hard-coded for elements?\n+        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (contentTypeDeser == null) {\n+            contentTypeDeser = findTypeDeserializer(config, contentType);\n+        }\n+        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n+                contentTypeDeser, contentDeser);\n+        if (deser != null) {\n+            // and then new with 2.2: ability to post-process it too (Issue#120)\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n \n     protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n         }\n \n         // 23-Nov-2010, tatu: Custom deserializer?\n-        JsonDeserializer<?> custom = _findCustomMapDeserializer(type, config, beanDesc,\n+        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                 keyDes, contentTypeDeser, contentDeser);\n \n-        if (custom != null) {\n-            return custom;\n-        }\n-        // Value handling is identical for all, but EnumMap requires special handling for keys\n-        Class<?> mapClass = type.getRawClass();\n-        if (EnumMap.class.isAssignableFrom(mapClass)) {\n-            Class<?> kt = keyType.getRawClass();\n-            if (kt == null || !kt.isEnum()) {\n-                throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n-            }\n-            return new EnumMapDeserializer(type, null, contentDeser);\n-        }\n-\n-        // Otherwise, generic handler works ok.\n-\n-        /* But there is one more twist: if we are being asked to instantiate\n-         * an interface or abstract Map, we need to either find something\n-         * that implements the thing, or give up.\n-         *\n-         * Note that we do NOT try to guess based on secondary interfaces\n-         * here; that would probably not work correctly since casts would\n-         * fail later on (as the primary type is not the interface we'd\n-         * be implementing)\n-         */\n-        if (type.isInterface() || type.isAbstract()) {\n-            @SuppressWarnings(\"rawtypes\")\n-            Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n-            if (fallback == null) {\n-                throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n-            }\n-            mapClass = fallback;\n-            type = (MapType) config.constructSpecializedType(type, mapClass);\n-            // But if so, also need to re-check creators...\n-            beanDesc = config.introspectForCreation(type);\n-        }\n-        ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-        MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n-        md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n-        return md;\n+        if (deser == null) {\n+            // Value handling is identical for all, but EnumMap requires special handling for keys\n+            Class<?> mapClass = type.getRawClass();\n+            if (EnumMap.class.isAssignableFrom(mapClass)) {\n+                Class<?> kt = keyType.getRawClass();\n+                if (kt == null || !kt.isEnum()) {\n+                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n+                }\n+                deser = new EnumMapDeserializer(type, null, contentDeser);\n+            }\n+\n+            // Otherwise, generic handler works ok.\n+    \n+            /* But there is one more twist: if we are being asked to instantiate\n+             * an interface or abstract Map, we need to either find something\n+             * that implements the thing, or give up.\n+             *\n+             * Note that we do NOT try to guess based on secondary interfaces\n+             * here; that would probably not work correctly since casts would\n+             * fail later on (as the primary type is not the interface we'd\n+             * be implementing)\n+             */\n+            if (deser == null) {\n+                if (type.isInterface() || type.isAbstract()) {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n+                    if (fallback == null) {\n+                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+                    }\n+                    mapClass = fallback;\n+                    type = (MapType) config.constructSpecializedType(type, mapClass);\n+                    // But if so, also need to re-check creators...\n+                    beanDesc = config.introspectForCreation(type);\n+                }\n+                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n+                MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n+                md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n+                deser = md;\n+            }\n+        }\n+        // and then new with 2.2: ability to post-process it too (Issue#120)\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n+            }\n+        }\n+        return deser;\n     }\n \n     // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n     {\n         JavaType keyType = type.getKeyType();\n         JavaType contentType = type.getContentType();\n+        final DeserializationConfig config = ctxt.getConfig();\n         \n         // First: is there annotation-specified deserializer for values?\n         @SuppressWarnings(\"unchecked\")\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (contentTypeDeser == null) {\n-            contentTypeDeser = findTypeDeserializer(ctxt.getConfig(), contentType);\n-        }\n-        return _findCustomMapLikeDeserializer(type, ctxt.getConfig(),\n+            contentTypeDeser = findTypeDeserializer(config, contentType);\n+        }\n+        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                 beanDesc, keyDes, contentTypeDeser, contentDeser);\n+        if (deser != null) {\n+            // and then new with 2.2: ability to post-process it too (Issue#120)\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n \n     protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n             CollectionLikeType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n         return deserializer;\n     }\n+\n+    /**\n+     * @since 2.2\n+     */\n+    public JsonDeserializer<?> modifyMapDeserializer(DeserializationConfig config,\n+            MapType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+        return deserializer;\n+    }\n+\n+    /**\n+     * @since 2.2\n+     */\n+    public JsonDeserializer<?> modifyMapLikeDeserializer(DeserializationConfig config,\n+            MapLikeType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+        return deserializer;\n+    }\n     \n     /*\n     \n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException;\n \n-    public abstract JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n-            MapType type, BeanDescription beanDesc)\n-        throws JsonMappingException;\n-\n-    public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n-            MapLikeType type, BeanDescription beanDesc)\n-        throws JsonMappingException;\n-\n     public abstract KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n             JavaType type)\n         throws JsonMappingException;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.type.ArrayType;\n import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.MapType;\n \n @SuppressWarnings(\"serial\")\n public class TestBeanDeserializer extends BaseMapTest\n             };\n         }\n     }\n+\n+    static class MapDeserializerModifier extends BeanDeserializerModifier {\n+        public JsonDeserializer<?> modifyMapDeserializer(DeserializationConfig config, MapType valueType,\n+                BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+            return (JsonDeserializer<?>) new StdDeserializer<Object>(Object.class) {\n+                @Override public Object deserialize(JsonParser jp,\n+                        DeserializationContext ctxt) {\n+                    HashMap<String,String> map = new HashMap<String,String>();\n+                    map.put(\"a\", \"foo\");\n+                    return map;\n+                }\n+            };\n+        }\n+    }\n     \n     /*\n     /********************************************************\n         assertEquals(1, result.size());\n         assertEquals(\"foo\", result.get(0));\n     }\n+\n+    public void testModifyMapDeserializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\")\n+            .setDeserializerModifier(new MapDeserializerModifier())\n+        );\n+        Map<?,?> result = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Map.class);\n+        assertEquals(1, result.size());\n+        assertEquals(\"foo\", result.get(\"a\"));\n+    }\n }", "timestamp": 1354323883, "metainfo": ""}