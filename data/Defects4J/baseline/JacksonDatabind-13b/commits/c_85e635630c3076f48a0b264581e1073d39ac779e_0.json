{"sha": "85e635630c3076f48a0b264581e1073d39ac779e", "log": "Fixes to @JsonUnwrapped serialization; now multi-level name transformations work correctly", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         _typeSerializer = base._typeSerializer;\n         _nonTrivialBaseType = base._nonTrivialBaseType;\n     }\n-    \n-    public BeanPropertyWriter withName(String newName) {\n+\n+    public BeanPropertyWriter rename(NameTransformer transformer) {\n+        String newName = transformer.transform(_name.getValue());\n         if (newName.equals(_name.toString())) {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/FilteredBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/FilteredBeanPropertyWriter.java\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n  * Decorated {@link BeanPropertyWriter} that will filter out properties\n         }\n \n         @Override\n-        public SingleView withName(String newName) {\n-            return new SingleView(_delegate.withName(newName), _view);\n+        public SingleView rename(NameTransformer transformer) {\n+            return new SingleView(_delegate.rename(transformer), _view);\n         }\n         \n         @Override\n         }\n \n         @Override\n-        public MultiView withName(String newName) {\n-            return new MultiView(_delegate.withName(newName), _views);\n+        public MultiView rename(NameTransformer transformer) {\n+            return new MultiView(_delegate.rename(transformer), _views);\n         }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n public class UnwrappingBeanPropertyWriter\n     extends BeanPropertyWriter\n {\n-    protected final NameTransformer _unwrapper;\n+    /**\n+     * Transformer used to add prefix and/or suffix for properties\n+     * of unwrapped POJO.\n+     */\n+    protected final NameTransformer _nameTransformer;\n     \n     /*\n     /**********************************************************\n     \n     public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, NameTransformer unwrapper) {\n         super(base);\n-        _unwrapper = unwrapper;\n+        _nameTransformer = unwrapper;\n     }\n \n-    private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, SerializedString name) {\n+    private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, NameTransformer transformer,\n+            SerializedString name) {\n         super(base, name);\n-        _unwrapper = base._unwrapper;\n+        _nameTransformer = transformer;\n     }\n \n     @Override\n-    public UnwrappingBeanPropertyWriter withName(String newName) {\n-        if (newName.equals(_name.toString())) {\n-            return this;\n-        }\n-        return new UnwrappingBeanPropertyWriter(this, new SerializedString(newName));\n+    public UnwrappingBeanPropertyWriter rename(NameTransformer transformer)\n+    {\n+        String oldName = _name.getValue();\n+        String newName = transformer.transform(oldName);\n+\n+        // important: combine transformers:\n+        transformer = NameTransformer.chainedTransformer(transformer, _nameTransformer);\n+    \n+        return new UnwrappingBeanPropertyWriter(this, transformer, new SerializedString(newName));\n     }\n \n     /*\n     {\n         super.assignSerializer(ser);\n         if (_serializer != null) {\n-            _serializer = _serializer.unwrappingSerializer(_unwrapper);\n+            NameTransformer t = _nameTransformer;\n+            if (_serializer.isUnwrappingSerializer()) {\n+                t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) _serializer)._nameTransformer);\n+            }\n+            _serializer = _serializer.unwrappingSerializer(t);\n         }\n     }\n     \n         } else {\n             serializer = provider.findValueSerializer(type, this);\n         }\n-        serializer = serializer.unwrappingSerializer(_unwrapper);\n+        NameTransformer t = _nameTransformer;\n+        if (serializer.isUnwrappingSerializer()) {\n+            t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) serializer)._nameTransformer);\n+        }\n+        serializer = serializer.unwrappingSerializer(t);\n+        \n         _dynamicSerializers = _dynamicSerializers.newWith(type, serializer);\n         return serializer;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n public class UnwrappingBeanSerializer\n     extends BeanSerializerBase\n {\n+    /**\n+     * Transformer used to add prefix and/or suffix for properties\n+     * of unwrapped POJO.\n+     */\n+    protected final NameTransformer _nameTransformer;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n      * Constructor used for creating unwrapping instance of a\n      * standard <code>BeanSerializer</code>\n      */\n-    public UnwrappingBeanSerializer(BeanSerializerBase src, NameTransformer unwrapper) {\n-        super(src, unwrapper);\n+    public UnwrappingBeanSerializer(BeanSerializerBase src, NameTransformer transformer) {\n+        super(src, transformer);\n+        _nameTransformer = transformer;\n     }\n \n     /*\n      */\n \n     @Override\n-    public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n-        /* !!! 13-Jan-2011, tatu: do we need to do something here?\n-         *    Would this affect multi-level unwrapping?\n-         */\n-        return this;\n+    public JsonSerializer<Object> unwrappingSerializer(NameTransformer transformer) {\n+        // !!! 23-Jan-2012, tatu: Should we chain transformers?\n+        return new UnwrappingBeanSerializer(this, transformer);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n         for (int i = 0; i < len; ++i) {\n             BeanPropertyWriter bpw = props[i];\n             if (bpw != null) {\n-                result[i] = bpw.withName(transformer.transform(bpw.getName()));\n+                result[i] = bpw.rename(transformer);\n             }\n         }\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/util/NameTransformer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/NameTransformer.java\n  * of names using different strategies (prefixes, suffixes).\n  * Default implementation is \"no-operation\" (aka identity transformation).\n  */\n-public class NameTransformer\n+public abstract class NameTransformer\n {\n     /**\n      * Singleton \"no-operation\" transformer which simply returns given\n      * name as is. Used commonly as placeholder or marker.\n      */\n-    public final static NameTransformer NOP = new NameTransformer();\n+    public final static NameTransformer NOP = new NameTransformer() {\n+        @Override\n+        public String transform(String name) {\n+            return name;\n+        }\n+        @Override\n+        public String reverse(String transformed) {\n+            // identity transformation is always reversible:\n+            return transformed;\n+        }\n+    };\n \n     protected NameTransformer() { }\n-\n+    \n     /**\n      * Factory method for constructing a simple transformer based on\n      * prefix and/or suffix.\n                 return new NameTransformer() {\n                     @Override\n                     public String transform(String name) { return prefix + name + suffix; }\n+                    @Override\n+                    public String reverse(String transformed) {\n+                        if (transformed.startsWith(prefix)) {\n+                            String str = transformed.substring(prefix.length());\n+                            if (str.endsWith(suffix)) {\n+                                return str.substring(0, str.length() - suffix.length());\n+                            }\n+                        }\n+                        return null;\n+                    }\n+                    @Override\n+                    public String toString() { return \"[PreAndSuffixTransformer('\"+prefix+\"','\"+suffix+\"')]\"; }\n                 };\n             }\n             return new NameTransformer() {\n                 @Override\n                 public String transform(String name) { return prefix + name; }\n+                @Override\n+                public String reverse(String transformed) {\n+                    if (transformed.startsWith(prefix)) {\n+                        return transformed.substring(prefix.length());\n+                    }\n+                    return null;\n+                }\n+                @Override\n+                public String toString() { return \"[PrefixTransformer('\"+prefix+\"')]\"; }\n             };\n         }\n         if (hasSuffix) {\n             return new NameTransformer() {\n                 @Override\n                 public String transform(String name) { return name + suffix; }\n+                @Override\n+                public String reverse(String transformed) {\n+                    if (transformed.endsWith(suffix)) {\n+                        return transformed.substring(0, transformed.length() - suffix.length());\n+                    }\n+                    return null;\n+                }\n+                @Override\n+                public String toString() { return \"[SuffixTransformer('\"+suffix+\"')]\"; }\n             };\n         }\n         return NOP;\n     }\n+\n+    /**\n+     * Method that constructs transformer that applies given transformers\n+     * as a sequence; essentially combines separate transform operations\n+     * into one logical transformation.\n+     */\n+    public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2) {\n+        return new Chained(t1, t2);\n+    }\n     \n     /**\n-     * Method called when transformation is needed\n+     * Method called when (forward) transformation is needed.\n      */\n-    public String transform(String name) { return name; }\n+    public abstract String transform(String name);\n+\n+    /**\n+     * Method called when reversal of transformation is needed; should return\n+     * null if this is not possible, that is, given name can not have been\n+     * result of calling {@link #transform} of this object.\n+     */\n+    public abstract String reverse(String transformed);\n+\n+    public static class Chained extends NameTransformer\n+    {\n+        protected final NameTransformer _t1, _t2;\n+        \n+        public Chained(NameTransformer t1, NameTransformer t2) {\n+            _t1 = t1;\n+            _t2 = t2;\n+        }\n+\n+        @Override\n+        public String transform(String name) {\n+            return _t1.transform(_t2.transform(name));\n+        }\n+\n+        @Override\n+        public String reverse(String transformed) {\n+            transformed = _t1.reverse(transformed);\n+            if (transformed != null) {\n+                transformed = _t2.reverse(transformed);\n+            }\n+            return transformed;\n+        }\n+\n+        @Override\n+        public String toString() { return \"[ChainedTransformer(\"+_t1+\", \"+_t2+\")]\"; }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n         }\n     }\n     \n-    static class Location {\n+    final static class Location {\n         public int x;\n         public int y;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n \n     public void testDeepPrefixedUnwrappingSerialize() throws Exception\n     {\n-        assertEquals(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"_x\\\":1,\\\"_y\\\":1}\",\n-                mapper.writeValueAsString(new DeepPrefixUnwrap(\"Bubba\", 1, 1)));\n+        String json = mapper.writeValueAsString(new DeepPrefixUnwrap(\"Bubba\", 1, 1));\n+        assertEquals(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":1,\\\"u._y\\\":1}\", json);\n     }\n \n     public void testHierarchicConfigSerialize() throws Exception\n     {\n-        assertEquals(\"{\\\"general.names.name\\\":\\\"Fred\\\",\\\"misc.value\\\":25}\",\n-                mapper.writeValueAsString(new ConfigRoot(\"Fred\", 25)));\n+        String json = mapper.writeValueAsString(new ConfigRoot(\"Fred\", 25));\n+        assertEquals(\"{\\\"general.names.name\\\":\\\"Fred\\\",\\\"misc.value\\\":25}\", json);\n     }\n     \n     /*\n     /**********************************************************\n      */\n \n+    /*\n     public void testPrefixedUnwrapping() throws Exception\n     {\n         PrefixUnwrap bean = mapper.readValue(\"{\\\"name\\\":\\\"Axel\\\",\\\"_x\\\":4,\\\"_y\\\":7}\", PrefixUnwrap.class);\n         assertNotNull(root.misc);\n         assertEquals(3, root.misc.value);\n     }\n-\n+*/\n }", "timestamp": 1327362749, "metainfo": ""}