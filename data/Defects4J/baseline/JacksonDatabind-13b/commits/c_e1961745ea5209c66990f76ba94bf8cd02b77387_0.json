{"sha": "e1961745ea5209c66990f76ba94bf8cd02b77387", "log": "Implement [JACKSON-764], programmatic way to set root name to use for root-wrapping", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * with respect to mix-in annotations; where this is guaranteed as\n  * long as caller follow \"copy-then-use\" pattern)\n  */\n-public class DeserializationConfig\n+public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationConfig.Feature, DeserializationConfig>\n {\n     /**\n         _problemHandlers = problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n-       \n+\n+    private DeserializationConfig(DeserializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle, factory methods from MapperConfig\n     \n     @Override\n     public DeserializationConfig withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n-        return new DeserializationConfig(this, _base.withClassIntrospector(ci));\n+        return _withBase(_base.withClassIntrospector(ci));\n     }\n \n     @Override\n     public DeserializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return new DeserializationConfig(this, _base.withAnnotationIntrospector(ai));\n+        return _withBase(_base.withAnnotationIntrospector(ai));\n     }\n \n     @Override\n     public DeserializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n-        return new DeserializationConfig(this, _base.withVisibilityChecker(vc));\n+        return _withBase(_base.withVisibilityChecker(vc));\n     }\n \n     @Override\n     public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n-        return new DeserializationConfig(this, _base.withVisibility(forMethod, visibility));\n+        return _withBase( _base.withVisibility(forMethod, visibility));\n     }\n     \n     @Override\n     public DeserializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n-        return new DeserializationConfig(this, _base.withTypeResolverBuilder(trb));\n+        return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n \n     @Override\n     public DeserializationConfig withSubtypeResolver(SubtypeResolver str) {\n-        return new DeserializationConfig(this, str);\n+        return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n     }\n     \n     @Override\n     public DeserializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n-        return new DeserializationConfig(this, _base.withPropertyNamingStrategy(pns));\n+        return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this, rootName);\n     }\n     \n     @Override\n     public DeserializationConfig withTypeFactory(TypeFactory tf) {\n-        return (tf == _base.getTypeFactory()) ? this : new DeserializationConfig(this, _base.withTypeFactory(tf));\n+        return _withBase( _base.withTypeFactory(tf));\n     }\n \n     @Override\n     public DeserializationConfig withDateFormat(DateFormat df) {\n-        return (df == _base.getDateFormat()) ? this : new DeserializationConfig(this, _base.withDateFormat(df));\n+        return _withBase(_base.withDateFormat(df));\n     }\n     \n     @Override\n     public DeserializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n-        return (hi == _base.getHandlerInstantiator()) ? this : new DeserializationConfig(this, _base.withHandlerInstantiator(hi));\n+        return _withBase(_base.withHandlerInstantiator(hi));\n     }\n \n     @Override\n     public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return new DeserializationConfig(this, _base.withInsertedAnnotationIntrospector(ai));\n+        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n     }\n \n     @Override\n     public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return new DeserializationConfig(this, _base.withAppendedAnnotationIntrospector(ai));\n+        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n+    }\n+\n+    private final DeserializationConfig _withBase(BaseSettings newBase) {\n+        return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     }\n     \n     /*\n         }\n         return NopAnnotationIntrospector.instance;\n     }\n+\n+    @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+    }\n     \n     /**\n      * Accessor for getting bean description that only contains class\n         return vchecker;\n     }\n \n-    public boolean isEnabled(DeserializationConfig.Feature f) {\n+    public final boolean isEnabled(DeserializationConfig.Feature f) {\n         return (_deserFeatures & f.getMask()) != 0;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n \n     /**\n-     * This is the default {@link DateFormat} used unless overridden by\n-     * custom implementation.\n-     */\n-    protected final static DateFormat DEFAULT_DATE_FORMAT = StdDateFormat.instance;\n-\n+     * Base settings contain defaults used for all {@link ObjectMapper}\n+     * instances.\n+     */\n     protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n             DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n-            null, DEFAULT_DATE_FORMAT, null);\n+            null, StdDateFormat.instance, null);\n     \n     /*\n     /**********************************************************\n     }\n \n     /**\n-     * Construct mapper that uses specified {@link JsonFactory}\n+     * Constructs instance that uses specified {@link JsonFactory}\n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s.\n      */\n         this(jf, null, null);\n     }\n \n-    public ObjectMapper(JsonFactory jf,\n-            SerializerProvider sp, DeserializerProvider dp)\n-    {\n-    \tthis(jf, sp, dp, null, null);\n-    }\n-\n-    /**\n+    /**\n+     * Constructs instance that uses specified {@link JsonFactory}\n+     * for constructing necessary {@link JsonParser}s and/or\n+     * {@link JsonGenerator}s, and uses given providers for accessing\n+     * serializers and deserializers.\n      * \n      * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n      * @param sp SerializerProvider to use: if null, a {@link StdSerializerProvider} will be constructed\n      * @param dp DeserializerProvider to use: if null, a {@link StdDeserializerProvider} will be constructed\n-     * @param sconfig Serialization configuration to use; if null, basic {@link SerializationConfig}\n-     * \twill be constructed\n-     * @param dconfig Deserialization configuration to use; if null, basic {@link DeserializationConfig}\n-     * \twill be constructed\n      */\n     public ObjectMapper(JsonFactory jf,\n-            SerializerProvider sp, DeserializerProvider dp,\n-            SerializationConfig sconfig, DeserializationConfig dconfig)\n+            SerializerProvider sp, DeserializerProvider dp)\n     {\n         /* 02-Mar-2009, tatu: Important: we MUST default to using\n          *   the mapping factory, otherwise tree serialization will\n         _subtypeResolver = new StdSubtypeResolver();\n         // and default type factory is shared one\n         _typeFactory = TypeFactory.defaultInstance();\n-        _serializationConfig = (sconfig != null) ? sconfig :\n-            new SerializationConfig(DEFAULT_BASE,\n+        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n-        _deserializationConfig = (dconfig != null) ? dconfig :\n-            new DeserializationConfig(DEFAULT_BASE,\n+        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n         _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n     public SerializationConfig getSerializationConfig() {\n         return _serializationConfig;\n     }\n-    \n-    /**\n-     * Method for replacing the shared default serialization configuration\n-     * object.\n-     */\n-    public ObjectMapper setSerializationConfig(SerializationConfig cfg) {\n-        _serializationConfig = cfg;\n-        return this;\n-    }\n \n     /**\n      * Method that returns\n      */\n     public DeserializationConfig getDeserializationConfig() {\n         return _deserializationConfig;\n-    }\n-\n-    /**\n-     * Method for replacing the shared default deserialization configuration\n-     * object.\n-     */\n-    public ObjectMapper setDeserializationConfig(DeserializationConfig cfg) {\n-        _deserializationConfig = cfg;\n-        return this;\n     }\n     \n     /*\n             DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n             JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n             // ok, let's get the value\n-            if (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) {\n-                result = _unwrapAndDeserialize(jp, valueType, ctxt, deser);\n+            if (cfg.useRootWrapping()) {\n+                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n             } else {\n                 result = deser.deserialize(jp, ctxt);\n             }\n                 DeserializationConfig cfg = getDeserializationConfig();\n                 DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n                 JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n-                if (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) {\n-                    result = _unwrapAndDeserialize(jp, valueType, ctxt, deser);\n+                if (cfg.useRootWrapping()) {\n+                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                 } else {\n                     result = deser.deserialize(jp, ctxt);\n                 }\n         return t;\n     }\n \n-    protected Object _unwrapAndDeserialize(JsonParser jp, JavaType rootType,\n-            DeserializationContext ctxt, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        SerializedString rootName = _deserializerProvider.findExpectedRootName(ctxt.getConfig(), rootType);\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n+            DeserializationConfig config,\n+            JavaType rootType, JsonDeserializer<Object> deser)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        String expName = config.getRootName();\n+        if (expName == null) {\n+            SerializedString sstr = _deserializerProvider.findExpectedRootName(config, rootType);\n+            expName = sstr.getValue();\n+        }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         if (jp.nextToken() != JsonToken.FIELD_NAME) {\n             throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         String actualName = jp.getCurrentName();\n-        if (!rootName.getValue().equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"+rootName\n-                    +\"') for type \"+rootType);\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n         }\n         // ok, then move to value itself....\n         jp.nextToken();\n-        \n         Object result = deser.deserialize(jp, ctxt);\n         // and last, verify that we now get matching END_OBJECT\n         if (jp.nextToken() != JsonToken.END_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         }\n         _schema = schema;\n         _injectableValues = injectableValues;\n-        _unwrapRoot = config.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        _unwrapRoot = config.useRootWrapping();\n     }\n     \n     /**\n         }\n         _schema = schema;\n         _injectableValues = injectableValues;\n-        _unwrapRoot = config.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        _unwrapRoot = config.useRootWrapping();\n     }\n \n     /**\n         _valueToUpdate = base._valueToUpdate;\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n-        _unwrapRoot = config.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        _unwrapRoot = config.useRootWrapping();\n     }\n     \n     /**\n         DeserializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     }    \n+\n+    /**\n+     * Method for constructing a new instance with configuration that uses\n+     * passed {@link InjectableValues} to provide injectable values.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withInjectableValues(InjectableValues injectableValues)\n+    {\n+        if (_injectableValues == injectableValues) {\n+            return this;\n+        }\n+        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+                _schema, injectableValues);\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance with configuration that uses\n+     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n+     * instances.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withNodeFactory(JsonNodeFactory f)\n+    {\n+        DeserializationConfig newConfig = _config.withNodeFactory(f);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+\n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * specifies what root name to expect for \"root name unwrapping\".\n+     * See {@link DeserializationConfig#withRootName(String)} for\n+     * details.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withRootName(String rootName)\n+    {\n+        DeserializationConfig newConfig = _config.withRootName(rootName);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+    \n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * passes specified {@link FormatSchema} to {@link JsonParser} that\n+     * is constructed for parsing content.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withSchema(FormatSchema schema)\n+    {\n+        if (_schema == schema) {\n+            return this;\n+        }\n+        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+                schema, _injectableValues);\n+    }\n     \n     /**\n      * Method for constructing a new reader instance that is configured\n     {\n         return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n-    \n-    /**\n-     * Method for constructing a new reader instance with configuration that uses\n-     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n-     * instances.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withNodeFactory(JsonNodeFactory f)\n-    {\n-        // node factory is stored within config, so need to copy that first\n-        if (f == _config.getNodeFactory()) return this;\n-        return new ObjectReader(this, _config.withNodeFactory(f), _valueType, _valueToUpdate,\n-                _schema, _injectableValues);\n-    }\n \n     /**\n      * Method for constructing a new instance with configuration that\n         return new ObjectReader(this, _config, t, value,\n                 _schema, _injectableValues);\n     }    \n-\n-    /**\n-     * Method for constructing a new instance with configuration that\n-     * passes specified {@link FormatSchema} to {@link JsonParser} that\n-     * is constructed for parsing content.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withSchema(FormatSchema schema)\n-    {\n-        if (_schema == schema) {\n-            return this;\n-        }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n-                schema, _injectableValues);\n-    }\n-\n-    /**\n-     * Method for constructing a new instance with configuration that uses\n-     * passed {@link InjectableValues} to provide injectable values.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withInjectableValues(InjectableValues injectableValues)\n-    {\n-        if (_injectableValues == injectableValues) {\n-            return this;\n-        }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n-                _schema, injectableValues);\n-    }\n     \n     /*\n     /**********************************************************\n             JavaType rootType, JsonDeserializer<Object> deser)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        SerializedString rootName = _provider.findExpectedRootName(ctxt.getConfig(), rootType);\n+        String expName = _config.getRootName();\n+        if (expName == null) {\n+            SerializedString sstr = _provider.findExpectedRootName(_config, rootType);\n+            expName = sstr.getValue();\n+        }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         if (jp.nextToken() != JsonToken.FIELD_NAME) {\n             throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         String actualName = jp.getCurrentName();\n-        if (!rootName.getValue().equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"+rootName\n-                    +\"') for type \"+rootType);\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n         }\n         // ok, then move to value itself....\n         jp.nextToken();\n         // and last, verify that we now get matching END_OBJECT\n         if (jp.nextToken() != JsonToken.END_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +rootName+\"'), but \"+jp.getCurrentToken());\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n \n     /**\n      * Copy constructor used for building variations.\n-     * \n-     * @since 1.7\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config)\n     {\n         SerializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n     }    \n-    \n+\n+    /**\n+     * Fluent factory method that will construct a new writer instance that will\n+     * use specified date format for serializing dates; or if null passed, one\n+     * that will serialize dates as numeric timestamps.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectWriter withDateFormat(DateFormat df)\n+    {\n+        SerializationConfig newConfig = _config.withDateFormat(df);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that will use the default\n+     * pretty printer for serialization.\n+     */\n+    public ObjectWriter withDefaultPrettyPrinter()\n+    {\n+        return withPrettyPrinter(new DefaultPrettyPrinter());\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that uses specified\n+     * provider for resolving filter instances by id.\n+     */\n+    public ObjectWriter withFilters(FilterProvider filterProvider)\n+    {\n+        if (filterProvider == _config.getFilterProvider()) { // no change?\n+            return this;\n+        }\n+        return new ObjectWriter(this, _config.withFilters(filterProvider));\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that will use specified pretty\n+     * printer (or, if null, will not do any pretty-printing)\n+     */\n+    public ObjectWriter withPrettyPrinter(PrettyPrinter pp)\n+    {\n+        if (pp == _prettyPrinter) {\n+            return this;\n+        }\n+        // since null would mean \"don't care\", need to use placeholder to indicate \"disable\"\n+        if (pp == null) {\n+            pp = NULL_PRETTY_PRINTER;\n+        }\n+        return new ObjectWriter(this, _config, _rootType, pp, _schema);\n+    }\n+\n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * specifies what root name to use for \"root element wrapping\".\n+     * See {@link SerializationConfig#withRootName(String)} for details.\n+     *<p>\n+     * Note that method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectWriter withRootName(String rootName)\n+    {\n+        SerializationConfig newConfig = _config.withRootName(rootName);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that uses specific format schema\n+     * for serialization.\n+     *<p>\n+     * Note that method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    \n+    public ObjectWriter withSchema(FormatSchema schema)\n+    {\n+        return (_schema == schema) ? this :\n+            new ObjectWriter(this, _config, _rootType, _prettyPrinter, schema);\n+    }\n+    \n+    /**\n+     * Method that will construct a new instance that uses specific type\n+     * as the root type for serialization, instead of runtime dynamic\n+     * type of the root object itself.\n+     *<p>\n+     * Note that method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectWriter withType(JavaType rootType)\n+    {\n+        return (rootType == _rootType) ? this\n+        // type is stored here, no need to make a copy of config\n+            : new ObjectWriter(this, _config, rootType, _prettyPrinter, _schema);\n+    }    \n+\n+    /**\n+     * Method that will construct a new instance that uses specific type\n+     * as the root type for serialization, instead of runtime dynamic\n+     * type of the root object itself.\n+     */\n+    public ObjectWriter withType(Class<?> rootType) {\n+        return withType(_config.constructType(rootType));\n+    }\n+\n+    public ObjectWriter withType(TypeReference<?> rootType) {\n+        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n+    }\n+\n     /**\n      * Method that will construct a new instance that uses specified\n      * serialization view for serialization (with null basically disables\n      * view processing)\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n      */\n     public ObjectWriter withView(Class<?> view)\n     {\n-        if (view == _config.getSerializationView()) return this;\n-        return new ObjectWriter(this, _config.withView(view));\n+        return (view == _config.getSerializationView()) ? this\n+            : new ObjectWriter(this, _config.withView(view));\n     }    \n-    \n-    /**\n-     * Method that will construct a new instance that uses specific type\n-     * as the root type for serialization, instead of runtime dynamic\n-     * type of the root object itself.\n-     */\n-    public ObjectWriter withType(JavaType rootType)\n-    {\n-        if (rootType == _rootType) return this;\n-        // type is stored here, no need to make a copy of config\n-        return new ObjectWriter(this, _config, rootType, _prettyPrinter, _schema);\n-    }    \n-\n-    /**\n-     * Method that will construct a new instance that uses specific type\n-     * as the root type for serialization, instead of runtime dynamic\n-     * type of the root object itself.\n-     */\n-    public ObjectWriter withType(Class<?> rootType)\n-    {\n-        return withType(_config.constructType(rootType));\n-    }\n-\n-    public ObjectWriter withType(TypeReference<?> rootType)\n-    {\n-        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n-    }\n-    \n-    /**\n-     * Method that will construct a new instance that will use specified pretty\n-     * printer (or, if null, will not do any pretty-printing)\n-     */\n-    public ObjectWriter withPrettyPrinter(PrettyPrinter pp)\n-    {\n-        if (pp == _prettyPrinter) {\n-            return this;\n-        }\n-        // since null would mean \"don't care\", need to use placeholder to indicate \"disable\"\n-        if (pp == null) {\n-            pp = NULL_PRETTY_PRINTER;\n-        }\n-        return new ObjectWriter(this, _config, _rootType, pp, _schema);\n-    }\n-\n-    /**\n-     * Method that will construct a new instance that will use the default\n-     * pretty printer for serialization.\n-     * \n-     * @since 1.6\n-     */\n-    public ObjectWriter withDefaultPrettyPrinter()\n-    {\n-        return withPrettyPrinter(new DefaultPrettyPrinter());\n-    }\n-\n-    /**\n-     * Method that will construct a new instance that uses specified\n-     * provider for resolving filter instances by id.\n-     * \n-     * @since 1.7\n-     */\n-    public ObjectWriter withFilters(FilterProvider filterProvider)\n-    {\n-        if (filterProvider == _config.getFilterProvider()) { // no change?\n-            return this;\n-        }\n-        return new ObjectWriter(this, _config.withFilters(filterProvider));\n-    }\n-\n-    /**\n-     * @since 1.8\n-     */\n-    public ObjectWriter withSchema(FormatSchema schema)\n-    {\n-        if (_schema == schema) {\n-            return this;\n-        }\n-        return new ObjectWriter(this, _config, _rootType, _prettyPrinter, schema);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct a new writer instance that will\n-     * use specified date format for serializing dates; or if null passed, one\n-     * that will serialize dates as numeric timestamps.\n-     * \n-     * @since 1.9\n-     */\n-    public ObjectWriter withDateFormat(DateFormat df)\n-    {\n-        SerializationConfig newConfig = _config.withDateFormat(df);\n-        if (newConfig == _config) {\n-            return this;\n-        }\n-        return new ObjectWriter(this, newConfig);\n-    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.databind.cfg.BaseSettings;\n-import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n+import com.fasterxml.jackson.databind.cfg.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n  * with respect to mix-in annotations; where this is guaranteed as\n  * long as caller follow \"copy-then-use\" pattern)\n  */\n-public class SerializationConfig\n+public final class SerializationConfig\n     extends MapperConfigBase<SerializationConfig.Feature, SerializationConfig>\n {\n     /**\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    private SerializationConfig(SerializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = src._serializationView;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n     @Override\n     public SerializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public SerializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new SerializationConfig(this, rootName);\n     }\n     \n     @Override\n     }\n     \n     @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+    }\n+    \n+    @Override\n     public AnnotationIntrospector getAnnotationIntrospector()\n     {\n         /* 29-Jul-2009, tatu: it's now possible to disable use of\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n         }\n         return flags;\n     }\n-    \n     /*\n     /**********************************************************\n     /* Life-cycle: factory methods\n      * mapper features disabled.\n      */\n     public abstract T without(MapperConfig.Feature... features);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link ClassIntrospector}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci);\n-\n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link AnnotationIntrospector} to use (replacing old one).\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link VisibilityChecker}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n-\n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * minimal visibility level for specified property type\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link TypeResolverBuilder}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link SubtypeResolver}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withSubtypeResolver(SubtypeResolver str);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link PropertyNamingStrategy}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link TypeFactory}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withTypeFactory(TypeFactory typeFactory);\n-    \n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link DateFormat}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withDateFormat(DateFormat df);\n-\n-    /**\n-     * Method for constructing and returning a new instance with different\n-     * {@link HandlerInstantiator}\n-     * to use.\n-     *<p>\n-     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n-     * if directly calling this method.\n-     */\n-    public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n-\n-    /**\n-     * Method for constructing and returning a new instance with additional\n-     * {@link AnnotationIntrospector} inserted (as the highest priority one)\n-     */\n-    public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);\n-\n-    /**\n-     * Method for constructing and returning a new instance with additional\n-     * {@link AnnotationIntrospector} appended (as the lowest priority one)\n-     */\n-    public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);\n     \n     /*\n     /**********************************************************\n     public final boolean shouldSortPropertiesAlphabetically() {\n         return isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n     }\n+\n+    /**\n+     * Accessor for checking whether configuration indicates that\n+     * \"root wrapping\" (use of an extra property/name pair at root level)\n+     * is expected or not.\n+     */\n+    public abstract boolean useRootWrapping();\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n package com.fasterxml.jackson.databind.cfg;\n \n+import java.text.DateFormat;\n import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public abstract class MapperConfigBase<CFG extends ConfigFeature,\n     T extends MapperConfigBase<CFG,T>>\n      * in addition to) ones declared using annotations.\n      */\n     protected final SubtypeResolver _subtypeResolver;\n+\n+    /**\n+     * Explicitly definite root name to use, if any; if empty\n+     * String, will disable root-name wrapping; if null, will\n+     * use defaults\n+     */\n+    protected final String _rootName;\n     \n     /*\n     /**********************************************************\n         super(base, DEFAULT_MAPPER_FEATURES);\n         _mixInAnnotations = mixins;\n         _subtypeResolver = str;\n+        _rootName = null;\n     }\n     \n     /**\n         super(src);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+    }\n+\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base)\n+    {\n+        super(base, src._mapperFeatures);\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, int mapperFeatures)\n         super(src._base, mapperFeatures);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str) {\n         super(src);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = str;\n-    }\n-\n-    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base)\n-    {\n-        super(base, src._mapperFeatures);\n-        _mixInAnnotations = src._mixInAnnotations;\n-        _subtypeResolver = src._subtypeResolver;\n-    }\n-\n+        _rootName = src._rootName;\n+    }\n+\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, String rootName) {\n+        super(src);\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = rootName;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Addition fluent factory methods, common to all sub-types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link AnnotationIntrospector} to use (replacing old one).\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} appended (as the lowest priority one)\n+     */\n+    public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} inserted (as the highest priority one)\n+     */\n+    public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link ClassIntrospector}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link DateFormat}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withDateFormat(DateFormat df);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link HandlerInstantiator}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link PropertyNamingStrategy}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * root name to use (none, if null).\n+     *<p>\n+     * Note that when a root name is set to a non-Empty String, this will automatically force use\n+     * of root element wrapping with given name. If empty String passed, will\n+     * disable root name wrapping; and if null used, will instead use\n+     * <code>Feature</code> to determine if to use wrapping, and annotation\n+     * (or default name) for actual root name to use.\n+     * \n+     * @param rootName to use: if null, means \"use default\" (clear setting);\n+     *   if empty String (\"\") means that no root name wrapping is used;\n+     *   otherwise defines root name to use.\n+     */\n+    public abstract T withRootName(String rootName);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link SubtypeResolver}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withSubtypeResolver(SubtypeResolver str);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeFactory}\n+     * to use.\n+     */\n+    public abstract T withTypeFactory(TypeFactory typeFactory);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeResolverBuilder} to use.\n+     */\n+    public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link VisibilityChecker}\n+     * to use.\n+     */\n+    public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * minimal visibility level for specified property type\n+     */\n+    public abstract T withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility);\n+    \n     /*\n     /**********************************************************\n     /* Simple accessors\n     public final SubtypeResolver getSubtypeResolver() {\n         return _subtypeResolver;\n     }\n+\n+    public final String getRootName() {\n+        return _rootName;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n      * Method called on the actual non-blueprint provider instance object,\n      * to kick off the serialization.\n      */\n-    protected  void _serializeValue(JsonGenerator jgen, Object value)\n+    protected final void _serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonProcessingException\n     {\n         JsonSerializer<Object> ser;\n             Class<?> cls = value.getClass();\n             // true, since we do want to cache root-level typed serializers (ditto for null property)\n             ser = findTypedValueSerializer(cls, true, null);\n-            // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n-            if (wrap) {\n+\n+            // Ok: should we wrap result in an additional property (\"root name\")?\n+            String rootName = _config.getRootName();\n+            if (rootName == null) { // not explicitly specified\n+                // [JACKSON-163]\n+                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+                if (wrap) {\n+                    jgen.writeStartObject();\n+                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                }\n+            } else if (rootName.length() == 0) {\n+                wrap = false;\n+            } else { // [JACKSON-764]\n+                // empty String means explicitly disabled; non-empty that it is enabled\n+                wrap = true;\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                jgen.writeFieldName(rootName);\n             }\n         }\n         try {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n         assertNotNull(result);\n     }\n     \n+    // [JACKSON-764]\n+    public void testRootUsingExplicitConfig() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectWriter writer = mapper.writer().withRootName(\"wrapper\");\n+        String json = writer.writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"wrapper\\\":{\\\"a\\\":3}}\", json);\n+\n+        ObjectReader reader = mapper.reader(Bean.class).withRootName(\"wrapper\");\n+        Bean bean = reader.readValue(json);\n+        assertNotNull(bean);\n+\n+        // also: verify that we can override Feature as well:\n+        ObjectMapper wrapping = rootMapper();\n+        json = wrapping.writer().withRootName(\"something\").writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"something\\\":{\\\"a\\\":3}}\", json);\n+        json = wrapping.writer().withRootName(\"\").writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"a\\\":3}\", json);\n+\n+        bean = wrapping.reader(Bean.class).withRootName(\"\").readValue(json);\n+        assertNotNull(bean);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods", "timestamp": 1327277027, "metainfo": ""}