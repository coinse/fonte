{"sha": "f4441ecc7f881fda71a979f616f525823b23b16e", "log": "Convert JsonValueSerializer to ContextualSerializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n                 ClassUtil.checkAndFixAccess(m);\n             }\n             JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod, property);\n-            return new JsonValueSerializer(m, ser, property);\n+            return new JsonValueSerializer(m, ser);\n         }\n         \n         // One unfortunate special case, as per [JACKSON-484]\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n-import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n /**\n  * Serializer class that can serialize Object that have a\n  * <p/>\n  * Implementation note: we will post-process resulting serializer\n  * (much like what is done with {@link BeanSerializer})\n- * to figure out actual serializers for final types. This must be\n- * done from {@link #resolve} method, and NOT from constructor;\n+ * to figure out actual serializers for final types.\n+ *  This must be done from {@link #createContextual} method, and NOT from constructor;\n  * otherwise we could end up with an infinite loop.\n  */\n @JacksonStdImpl\n public class JsonValueSerializer\n     extends StdSerializer<Object>\n-    implements ResolvableSerializer, SchemaAware\n+    implements ContextualSerializer, SchemaAware\n {\n     protected final Method _accessorMethod;\n \n-    protected JsonSerializer<Object> _valueSerializer;\n+    protected final JsonSerializer<Object> _valueSerializer;\n \n     protected final BeanProperty _property;\n     \n      * we actually must force type information wrapping, even though\n      * one would not normally be added.\n      */\n-    protected boolean _forceTypeInformation;\n-    \n+    protected final boolean _forceTypeInformation;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n     /**\n      * @param ser Explicit serializer to use, if caller knows it (which\n      *    occurs if and only if the \"value method\" was annotated with\n      *    {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}), otherwise\n      *    null\n      */\n-    public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser, BeanProperty property)\n+    public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser)\n     {\n         super(Object.class);\n         _accessorMethod = valueMethod;\n         _valueSerializer = ser;\n+        _property = null;\n+        _forceTypeInformation = true; // gets reconsidered when we are contextualized\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonValueSerializer(JsonValueSerializer src, BeanProperty property,\n+            JsonSerializer<?> ser, boolean forceTypeInfo)\n+    {\n+        super(Object.class);\n+        _accessorMethod = src._accessorMethod;\n+        _valueSerializer = (JsonSerializer<Object>) ser;\n         _property = property;\n-    }\n-\n+        _forceTypeInformation = forceTypeInfo;\n+    }\n+\n+    public JsonValueSerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> ser, boolean forceTypeInfo)\n+    {\n+        if (_property == property && _valueSerializer == ser\n+                && forceTypeInfo == _forceTypeInformation) {\n+            return this;\n+        }\n+        return new JsonValueSerializer(this, property, ser, forceTypeInfo);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Post-processing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We can try to find the actual serializer for value, if we can\n+     * statically figure out what the result type must be.\n+     */\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = _valueSerializer;\n+        if (ser == null) {\n+            /* Can only assign serializer statically if the declared type is final:\n+             * if not, we don't really know the actual type until we get the instance.\n+             */\n+            // 10-Mar-2010, tatu: Except if static typing is to be used\n+            if (provider.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)\n+                    || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n+                JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n+                // false -> no need to cache\n+                /* 10-Mar-2010, tatu: Ideally we would actually separate out type\n+                 *   serializer from value serializer; but, alas, there's no access\n+                 *   to serializer factory at this point... \n+                 */\n+                /* 09-Dec-2010, tatu: Turns out we must add special handling for\n+                 *   cases where \"native\" (aka \"natural\") type is being serialized,\n+                 *   using standard serializer\n+                 */\n+                ser = provider.findTypedValueSerializer(t, false, _property);\n+                boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser);\n+                return withResolved(property, ser, forceTypeInformation);\n+            }\n+        } else if (ser instanceof ContextualSerializer) {\n+            ser = ((ContextualSerializer) ser).createContextual(provider, property);\n+            return withResolved(property, ser, _forceTypeInformation);\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov)\n         throws IOException, JsonGenerationException\n                 ((SchemaAware) _valueSerializer).getSchema(provider, null) :\n                 JsonSchema.getDefaultSchemaNode();\n     }\n-    \n-    /*\n-    /*******************************************************\n-    /* ResolvableSerializer impl\n-    /*******************************************************\n-     */\n-\n-    /**\n-     * We can try to find the actual serializer for value, if we can\n-     * statically figure out what the result type must be.\n-     */\n-    @Override\n-    public void resolve(SerializerProvider provider)\n-        throws JsonMappingException\n-    {\n-        if (_valueSerializer == null) {\n-            /* Note: we can only assign serializer statically if the\n-             * declared type is final -- if not, we don't really know\n-             * the actual type until we get the instance.\n-             */\n-            // 10-Mar-2010, tatu: Except if static typing is to be used\n-            if (provider.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)\n-                    || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n-                JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n-                // false -> no need to cache\n-                /* 10-Mar-2010, tatu: Ideally we would actually separate out type\n-                 *   serializer from value serializer; but, alas, there's no access\n-                 *   to serializer factory at this point... \n-                 */\n-                _valueSerializer = provider.findTypedValueSerializer(t, false, _property);\n-                /* 09-Dec-2010, tatu: Turns out we must add special handling for\n-                 *   cases where \"native\" (aka \"natural\") type is being serialized,\n-                 *   using standard serializer\n-                 */\n-                _forceTypeInformation = isNaturalTypeWithStdHandling(t, _valueSerializer);\n-            }\n-        }\n-    }\n-\n-    protected boolean isNaturalTypeWithStdHandling(JavaType type, JsonSerializer<?> ser)\n-    {\n-        Class<?> cls = type.getRawClass();\n+\n+    protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser)\n+    {\n         // First: do we have a natural type being handled?\n-        if (type.isPrimitive()) {\n-            if (cls != Integer.TYPE && cls != Boolean.TYPE && cls != Double.TYPE) {\n+        if (rawType.isPrimitive()) {\n+            if (rawType != Integer.TYPE && rawType != Boolean.TYPE && rawType != Double.TYPE) {\n                 return false;\n             }\n         } else {\n-            if (cls != String.class &&\n-                    cls != Integer.class && cls != Boolean.class && cls != Double.class) {\n+            if (rawType != String.class &&\n+                    rawType != Integer.class && rawType != Boolean.class && rawType != Double.class) {\n                 return false;\n             }\n         }\n-        // Second: and it's handled with standard serializer?\n-        return (ser.getClass().getAnnotation(JacksonStdImpl.class)) != null;\n+        return isDefaultSerializer(ser);\n     }\n     \n     /*", "timestamp": 1328060875, "metainfo": ""}