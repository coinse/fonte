{"sha": "8662c12613121f707a20d9169b9da32441f0f958", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     /**\n      * Method called by framework to determine whether given annotation\n      * is handled by this introspector.\n-     */\n+     *\n+     * @deprecated Not used since 2.0; deprecated sicne 2.1\n+     */\n+    @Deprecated\n     public boolean isHandled(Annotation ann) {\n         return false;\n     }\n         \n         // // // Generic annotation properties, lookup\n         \n+        @Deprecated\n         @Override\n         public boolean isHandled(Annotation ann) {\n             return _primary.isHandled(ann) || _secondary.isHandled(ann);\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n \n /**\n  * Sub-class of {@link JsonFactory} that will create a proper\n- * {@link ObjectCodec} to allow seamless conversions between\n- * Json content and Java objects (POJOs).\n+ * {@link ObjectCodec} to allow seam-less conversions between\n+ * JSON content and Java objects (POJOs).\n  * The only addition to regular {@link JsonFactory} currently\n  * is that {@link ObjectMapper} is constructed and passed as\n  * the codec to use.\n     @Override\n     public MatchStrength hasFormat(InputAccessor acc) throws IOException\n     {\n-        return hasJSONFormat(acc);\n+        if (getClass() == MappingJsonFactory.class) {\n+            return hasJSONFormat(acc);\n+        }\n+        return null;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n         AnnotatedClass ac = beanDesc.getClassInfo();\n         String nameStr = intr.findRootName(ac);\n         // No answer so far? Let's just default to using simple class name\n-        if (nameStr == null) {\n+        if (nameStr == null || nameStr.length() == 0) {\n             // Should we strip out enclosing class tho? For now, nope:\n             nameStr = rootType.getSimpleName();\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n         public int a = 3;\n     }\n     \n+    @JsonRootName(\"\")\n+    static class RootBeanWithEmpty {\n+        public int a = 2;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", json);\n         Bean bean = mapper.readValue(json, Bean.class);\n         assertNotNull(bean);\n+\n+        // also same with explicitly \"not defined\"...\n+        json = mapper.writeValueAsString(new RootBeanWithEmpty());\n+        assertEquals(\"{\\\"RootBeanWithEmpty\\\":{\\\"a\\\":2}}\", json);\n+        RootBeanWithEmpty bean2 = mapper.readValue(json, RootBeanWithEmpty.class);\n+        assertNotNull(bean2);\n+        assertEquals(2, bean2.a);\n     }\n \n     public void testRootViaWriterAndReader() throws Exception\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n-import com.fasterxml.jackson.annotation.JsonAutoDetect;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n-import com.fasterxml.jackson.annotation.PropertyAccessor;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n-import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n-import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n-import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n-import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.ser.*;\n-import com.fasterxml.jackson.databind.type.ClassKey;\n-import com.fasterxml.jackson.databind.type.SimpleType;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.type.TypeModifier;\n+import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n import com.fasterxml.jackson.databind.util.StdDateFormat;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig config = getSerializationConfig();\n+        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n+        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n         if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n      * as well\n      */\n     protected final PrettyPrinter _prettyPrinter;\n-\n+    \n     /**\n      * When using data format that uses a schema, schema is passed\n      * to generator.\n     public void writeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        // 10-Aug-2012, tatu: As per [Issue#12], may need to force PrettyPrinter settings, so:\n+        _configureJsonGenerator(jgen);\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)\n+                && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, _config);\n         } else {\n             if (_rootType == null) {\n             }\n         }\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Serialization methods, others\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_prettyPrinter != null) {\n-            PrettyPrinter pp = _prettyPrinter;\n-            if (pp == NULL_PRETTY_PRINTER) {\n-                jgen.setPrettyPrinter(null);\n-            } else {\n-                /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n-                 *   like the DefaultPrettyPrinter.\n-                 */\n-                if (pp instanceof Instantiatable<?>) {\n-                    pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n-                }\n-                jgen.setPrettyPrinter(pp);\n-            }\n-        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [JACKSON-520]: add support for pass-through schema:\n-        if (_schema != null) {\n-            jgen.setSchema(_schema);\n-        }\n+        _configureJsonGenerator(jgen);\n         // [JACKSON-282]: consider Closeable\n         if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n-            _configAndWriteCloseable(jgen, value, _config);\n+            _writeCloseable(jgen, value, _config);\n             return;\n         }\n         boolean closed = false;\n      * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n-    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+    private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         Closeable toClose = (Closeable) value;\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n                 _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n-            }\n-            // [JACKSON-520]: add support for pass-through schema:\n-            if (_schema != null) {\n-                jgen.setSchema(_schema);\n             }\n             JsonGenerator tmpJgen = jgen;\n             jgen = null;\n             return null;\n         }\n     }\n+    \n+    /**\n+     * Helper method called to set or override settings of passed-in\n+     * {@link JsonGenerator}\n+     * \n+     * @since 2.1\n+     */\n+    private final void _configureJsonGenerator(JsonGenerator jgen)\n+    {\n+        if (_prettyPrinter != null) {\n+            PrettyPrinter pp = _prettyPrinter;\n+            if (pp == NULL_PRETTY_PRINTER) {\n+                jgen.setPrettyPrinter(null);\n+            } else {\n+                /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n+                 *   like the DefaultPrettyPrinter.\n+                 */\n+                if (pp instanceof Instantiatable<?>) {\n+                    pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n+                }\n+                jgen.setPrettyPrinter(pp);\n+            }\n+        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n+        // [JACKSON-520]: add support for pass-through schema:\n+        if (_schema != null) {\n+            jgen.setSchema(_schema);\n+        }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.io.StringWriter;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n         private int getY() { return 2; }\n     }\n \n+    static class Indentable {\n+        public int a = 3;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Main tests\n     /**********************************************************\n      */\n \n+    final static ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testDefaults()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SerializationConfig cfg = m.getSerializationConfig();\n+        SerializationConfig cfg = MAPPER.getSerializationConfig();\n \n         // First, defaults:\n         assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n \n     public void testOverrideIntrospectors()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SerializationConfig cfg = m.getSerializationConfig();\n+        SerializationConfig cfg = MAPPER.getSerializationConfig();\n         // and finally, ensure we could override introspectors\n         cfg = cfg.with((ClassIntrospector) null); // no way to verify tho\n         cfg = cfg.with((AnnotationIntrospector) null);\n \n     public void testIndentation() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationFeature.INDENT_OUTPUT, true);\n         Map<String,Integer> map = new HashMap<String,Integer>();\n         map.put(\"a\", Integer.valueOf(2));\n-        String result = serializeAsString(m, map).trim();\n+        String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT)\n+                .writeValueAsString(map);\n         // 02-Jun-2009, tatu: not really a clean way but...\n-        String lf = System.getProperty(\"line.separator\");\n+        String lf = getLF();\n         assertEquals(\"{\"+lf+\"  \\\"a\\\" : 2\"+lf+\"}\", result);\n     }\n \n     public void testAnnotationsDisabled() throws Exception\n     {\n         // first: verify that annotation introspection is enabled by default\n-        ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperFeature.USE_ANNOTATIONS));\n-        Map<String,Object> result = writeAndMap(m, new AnnoBean());\n+        assertTrue(MAPPER.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        Map<String,Object> result = writeAndMap(MAPPER, new AnnoBean());\n         assertEquals(2, result.size());\n \n-        m = new ObjectMapper();\n-        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n-        result = writeAndMap(m, new AnnoBean());\n+        ObjectMapper m2 = new ObjectMapper();\n+        m2.configure(MapperFeature.USE_ANNOTATIONS, false);\n+        result = writeAndMap(m2, new AnnoBean());\n         assertEquals(1, result.size());\n     }\n \n         assertEquals(0, prov.cachedSerializersCount());\n     }\n \n+    // Test for [Issue#12]\n+    public void testIndentWithPassedGenerator() throws Exception\n+    {\n+        Indentable input = new Indentable();\n+        assertEquals(\"{\\\"a\\\":3}\", MAPPER.writeValueAsString(input));\n+        String LF = getLF();\n+        String INDENTED = \"{\"+LF+\"  \\\"a\\\" : 3\"+LF+\"}\";\n+        final ObjectWriter indentWriter = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT);\n+        assertEquals(INDENTED, indentWriter.writeValueAsString(input));\n+\n+        // [Issue#12]\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = MAPPER.getJsonFactory().createGenerator(sw);\n+        indentWriter.writeValue(jgen, input);\n+        jgen.close();\n+        assertEquals(INDENTED, sw.toString());\n+\n+        // and also with ObjectMapper itself\n+        sw = new StringWriter();\n+        ObjectMapper m2 = new ObjectMapper();\n+        m2.enable(SerializationFeature.INDENT_OUTPUT);\n+        jgen = m2.getJsonFactory().createGenerator(sw);\n+        m2.writeValue(jgen, input);\n+        jgen.close();\n+        assertEquals(INDENTED, sw.toString());\n+    }\n+\n+    private final static String getLF() {\n+        return System.getProperty(\"line.separator\");\n+    }\n }", "timestamp": 1344661623, "metainfo": ""}