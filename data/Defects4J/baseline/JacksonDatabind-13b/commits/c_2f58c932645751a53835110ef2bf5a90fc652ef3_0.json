{"sha": "2f58c932645751a53835110ef2bf5a90fc652ef3", "log": "Attempt to fix #435", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n         \n         // Barring that, we may have recently constructed an instance:\n         ClassKey key = new ClassKey(clz);\n-        JavaType result;\n-        \n-        synchronized (_typeCache) {\n-            result = _typeCache.get(key);\n-        }\n+        JavaType result = _typeCache.get(key); // ok, cache object is synced\n         if (result != null) {\n             return result;\n         }\n         // First: do we have an array type?\n         if (clz.isArray()) {\n             result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n-        /* Also: although enums can also be fully resolved, there's little\n-         * point in doing so (T extends Enum<T>) etc.\n-         */\n+            /* Also: although enums can also be fully resolved, there's little\n+             * point in doing so (T extends Enum<T>) etc.\n+             */\n         } else if (clz.isEnum()) {\n             result = new SimpleType(clz);\n-        /* Maps and Collections aren't quite as hot; problem is, due\n-         * to type erasure we often do not know typing and can only assume\n-         * base Object.\n-         */\n+            /* Maps and Collections aren't quite as hot; problem is, due\n+             * to type erasure we often do not know typing and can only assume\n+             * base Object.\n+             */\n         } else if (Map.class.isAssignableFrom(clz)) {\n             result = _mapType(clz);\n         } else if (Collection.class.isAssignableFrom(clz)) {\n         } else {\n             result = new SimpleType(clz);\n         }\n-        \n-        synchronized (_typeCache) {\n-            _typeCache.put(key, result);\n-        }\n-        \n+        _typeCache.put(key, result); // cache object syncs\n         return result;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n import java.io.*;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n  * Helper for simple bounded LRU maps used for reusing lookup values.\n  * Note that serialization behavior is such that contents are NOT serialized,\n  * on assumption that all use cases are for caching where persistence\n  * does not make sense. The only thing serialized is the cache size of Map.\n+ *<p>\n+ * NOTE: the only reason we extend {@link LinkedHashMap} instead of aggregating\n+ * it is that this way we can override {@link #removeEldestEntry}.\n+ * Access, however, MUST be done using single-element access methods (or matching\n+ * <code>xxxAll()</code> methods that call them); access via iterators are not\n+ * guaranteed to work.\n+ *<p>\n+ * NOTE: since version 2.4, uses {@link ReentrantReadWriteLock} to improve\n+ * concurrent access.\n  */\n public class LRUMap<K,V> extends LinkedHashMap<K,V>\n     implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n-    protected final int _maxEntries;\n+    protected final transient Lock _readLock, _writeLock;\n+    \n+    protected final transient int _maxEntries;\n     \n     public LRUMap(int initialEntries, int maxEntries)\n     {\n         super(initialEntries, 0.8f, true);\n         _maxEntries = maxEntries;\n+        final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+        _readLock = rwl.readLock();\n+        _writeLock = rwl.writeLock();\n     }\n \n     @Override\n-    protected boolean removeEldestEntry(Map.Entry<K,V> eldest)\n-    {\n+    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n         return size() > _maxEntries;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Overrides to support proper concurrency\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public V get(Object key) {\n+        _readLock.lock();\n+        try {\n+            return super.get(key);\n+        } finally {\n+            _readLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        _writeLock.lock();\n+        try {\n+            return super.put(key, value);\n+        } finally {\n+            _writeLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        _writeLock.lock();\n+        try {\n+            return super.remove(key);\n+        } finally {\n+            _writeLock.unlock();\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Serializable overrides\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n package com.fasterxml.jackson.databind.util;\n \n import com.fasterxml.jackson.core.SerializableString;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n      */\n     protected transient LRUMap<ClassKey,SerializableString> _rootNames;\n \n-    public RootNameLookup() { }\n+    public RootNameLookup() {\n+        _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);\n+   }\n \n     public SerializableString findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     public SerializableString findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         ClassKey key = new ClassKey(rootType);\n-\n-        synchronized (this) {\n-            if (_rootNames == null) {\n-                _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);\n-            } else {\n-                SerializableString name = _rootNames.get(key);\n-                if (name != null) {\n-                    return name;\n-                }\n-            }\n+        SerializableString name = _rootNames.get(key);\n+        if (name != null) {\n+            return name;\n         }\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         } else {\n             nameStr = pname.getSimpleName();\n         }\n-        SerializableString name = config.compileString(nameStr);\n-        synchronized (this) {\n-            _rootNames.put(key, name);\n-        }\n+        name = config.compileString(nameStr);\n+        _rootNames.put(key, name);\n         return name;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Serializable overrides\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Need to override to reproduce cache object via constructor, instead\n+     * of serialize/deserialize (since we do NOT want to retain cached data)\n+     */\n+    protected Object readResolve() {\n+        return new RootNameLookup();\n+    }\n }", "timestamp": 1397094382, "metainfo": ""}