{"sha": "69cf0732320d4a36c21f6fd55d5069471fe76032", "log": "Fix for #511", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n     extends TypeDeserializer\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 278445030337366675L;\n+    private static final long serialVersionUID = 1;\n     \n     protected final TypeIdResolver _idResolver;\n     \n         synchronized (_deserializers) {\n             deser = _deserializers.get(typeId);\n             if (deser == null) {\n-                /* As per [Issue#305], need to provide contextual info. But for\n+                /* As per [Databind#305], need to provide contextual info. But for\n                  * backwards compatibility, let's start by only supporting this\n                  * for base class, not via interface. Later on we can add this\n                  * to the interface, assuming deprecation at base class helps.\n                 }\n                 if (type == null) {\n                     // As per [JACKSON-614], use the default impl if no type id available:\n-                    if (_defaultImpl == null) {\n+                    deser = _findDefaultImplDeserializer(ctxt);\n+                    if (deser == null) {\n                         throw ctxt.unknownTypeException(_baseType, typeId);\n                     }\n-                    deser = _findDefaultImplDeserializer(ctxt);\n                 } else {\n                     /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                      *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n              *   for \"try to deserialize with native tpye id\"?\n              */\n-            if (_defaultImpl == null) {\n+            deser = _findDefaultImplDeserializer(ctxt);\n+            if (deser == null) {\n                 throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n             }\n-            deser = _findDefaultImplDeserializer(ctxt);\n         } else {\n             String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n             deser = _findDeserializer(ctxt, typeIdStr);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n /**\n- * Unit tests related to [JACKSON-712]; specialized handling of\n+ * Unit tests related to specialized handling of\n  * otherwise invalid type id embedding cases.\n  */\n public class TestTypedDeserializationWithDefault extends BaseMapTest\n     // and then one with no defaultImpl nor listed subtypes\n     @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n     abstract static class MysteryPolymorphic { }\n-    \n+\n+    // [Databind#511] types\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes(@JsonSubTypes.Type(name=\"sub1\", value = BadSub1.class))\n+    public static class BadItem {}\n+\n+    public static class BadSub1 extends BadItem {\n+        public String a ;\n+    }\n+\n+    public static class Good {\n+        public List<GoodItem> many;\n+    }\n+\n+    public static class Bad {\n+        public List<BadItem> many;\n+    }\n+ \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({@JsonSubTypes.Type(name=\"sub1\", value = GoodSub1.class),\n+            @JsonSubTypes.Type(name=\"sub2\", value = GoodSub2.class) })\n+    public static class GoodItem {}\n+\n+    public static class GoodSub1 extends GoodItem {\n+        public String a ;\n+    }\n+    public static class GoodSub2 extends GoodItem {\n+        public String b ;\n+\n+    }    \n     /*\n     /**********************************************************\n     /* Unit tests, deserialization\n         assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n     }\n \n-    // [Issue#148]\n+    // [Databind#148]\n     public void testDefaultAsNoClass() throws Exception\n     {\n         Object ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ }\");\n         assertNull(ob);\n     }\n \n-    // [Issue#148]\n+    // [Databind#148]\n     public void testBadTypeAsNull() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         ob = mapper.readValue(\"{ \\\"whatever\\\":13}\", MysteryPolymorphic.class);\n         assertNull(ob);\n     }\n+\n+    // [Databind#511]\n+    public void testInvalidTypeId511() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper().disable(\n+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n+                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n+                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES\n+        );\n+        String json = \"{\\\"many\\\":[{\\\"sub1\\\":{\\\"a\\\":\\\"foo\\\"}},{\\\"sub2\\\":{\\\"b\\\":\\\"bar\\\"}}]}\" ;\n+        Good goodResult = mapper.readValue(json, Good.class) ;\n+        assertNotNull(goodResult) ;\n+        Bad badResult = mapper.readValue(json, Bad.class);\n+        assertNotNull(badResult);\n+    }\n }", "timestamp": 1411512295, "metainfo": ""}