{"sha": "c3fbb3ad1e0b83ccc56a876fe9c7a2adfd4dd210", "log": "Clean up, to get rid of deprecated stuff", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     /**\n      * Value type used with managed and back references; contains type and\n      * logic name, used to link related references\n-     * \n-     * @since 1.6\n      */\n     public static class ReferenceProperty\n     {\n              * reference object), but is used for resolving back references during\n              * deserialization.\n              * Usually this can be defined by using\n-             * {@link org.codehaus.jackson.annotate.JsonManagedReference}\n+             * {@link com.fasterxml.jackson.annotation.JsonManagedReference}\n              */\n             MANAGED_REFERENCE\n     \n              * Reference property that Jackson manages by suppressing it during serialization,\n              * and reconstructing during deserialization.\n              * Usually this can be defined by using\n-             * {@link org.codehaus.jackson.annotate.JsonBackReference}\n+             * {@link com.fasterxml.jackson.annotation.JsonBackReference}\n              */\n             ,BACK_REFERENCE\n             ;\n      * Factory method for accessing \"no operation\" implementation\n      * of introspector: instance that will never find any annotation-based\n      * configuration.\n-     * \n-     * @since 1.3\n      */\n     public static AnnotationIntrospector nopInstance() {\n         return NopAnnotationIntrospector.instance;\n      * for XML compatibility purposes) for given class, if one\n      * is defined. Returns null if no declaration found; can return\n      * explicit empty String, which is usually ignored as well as null.\n-     *\n-     * @since 1.3\n      */\n     public abstract String findRootName(AnnotatedClass ac);\n \n      * List of property names is applied\n      * after other detection mechanisms, to filter out these specific\n      * properties from being serialized and deserialized.\n-     * \n-     * @since 1.4\n      */\n     public abstract String[] findPropertiesToIgnore(AnnotatedClass ac);\n \n     /**\n      * Method for checking whether an annotation indicates that all unknown properties\n-     * \n-     * @since 1.4\n      */\n     public abstract Boolean findIgnoreUnknownProperties(AnnotatedClass ac);\n \n      * @return Boolean.TRUE if properties of type should be ignored;\n      *   Boolean.FALSE if they are not to be ignored, null for default\n      *   handling (which is 'do not ignore')\n-     *   \n-     * @since 1.7\n      */\n     public Boolean isIgnorableType(AnnotatedClass ac) {\n         return null;\n      * A baseline checker is given, and introspector is to either return it as is (if\n      * no annotations are found), or build and return a derived instance (using checker's build\n      * methods).\n-     *\n-     *  @since 1.5\n      */\n     public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n         return checker;\n      * @param baseType Base java type of value for which resolver is to be found\n      * \n      * @return Type resolver builder for given type, if one found; null if none\n-     * \n-     * @since 1.5 -- although changed in 1.8 to pass configuration object\n      */\n     public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n             AnnotatedClass ac, JavaType baseType) {\n      * \n      * @return Type resolver builder for properties of given entity, if one found;\n      *    null if none\n-     * \n-     * @since 1.5 -- although changed in 1.8 to pass configuration object\n      */\n     public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n             AnnotatedMember am, JavaType baseType) {\n      * \n      * @return Type resolver builder for values contained in properties of given entity,\n      *    if one found; null if none\n-     * \n-     * @since 1.5 -- although changed in 1.8 to pass configuration object\n      */    \n     public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n             AnnotatedMember am, JavaType containerType) {\n      * has to do it if/as necessary)\n      * \n      * @param a Annotated entity (class, field/method) to check for annotations\n-     * \n-     * @since 1.5\n      */\n     public List<NamedType> findSubtypes(Annotated a) {\n         return null;\n      * Method for checking if specified type has explicit name.\n      * \n      * @param ac Class to check for type name annotations\n-     * \n-     * @since 1.5\n      */\n     public String findTypeName(AnnotatedClass ac) {\n         return null;\n     /**\n      * Note: defined as non-abstract to reduce fragility between\n      * versions.\n-     * \n-     * @since 1.6\n      */\n     public ReferenceProperty findReferenceType(AnnotatedMember member) {\n         return null;\n      * Method called to check whether given property is marked to be \"unwrapped\"\n      * when being serialized (and appropriately handled in reverse direction,\n      * i.e. expect unwrapped representation during deserialization)\n-     * \n-     * @since 1.9\n      */\n     public Boolean shouldUnwrapProperty(AnnotatedMember member) {\n         return null;\n      * Default implementation calls existing 'isIgnored' methods\n      * such as {@link #isIgnorableField(AnnotatedField)} and\n      * {@link #isIgnorableMethod(AnnotatedMethod)}.\n-     * \n-     * @since 1.9\n      */\n     public boolean hasIgnoreMarker(AnnotatedMember m)\n     {\n      */\n     public abstract boolean isIgnorableMethod(AnnotatedMethod m);\n \n-    /**\n-     * @since 1.2\n-     */\n     public abstract boolean isIgnorableConstructor(AnnotatedConstructor c);\n \n     /*\n      * (such as actual exact type; or serializer to use which means\n      * no type information is needed) take precedence.\n      *\n-     * @since 1.2\n-     *\n      * @return Typing mode to use, if annotation is found; null otherwise\n      */\n     public abstract JsonSerialize.Typing findSerializationTyping(Annotated a);\n     /**\n      * Method for accessing defined property serialization order (which may be\n      * partial). May return null if no ordering is defined.\n-     * \n-     * @since 1.4\n      */\n     public abstract String[] findSerializationPropertyOrder(AnnotatedClass ac);\n \n      * Method for checking whether an annotation indicates that serialized properties\n      * for which no explicit is defined should be alphabetically (lexicograpically)\n      * ordered\n-     * \n-     * @since 1.4\n      */\n     public abstract Boolean findSerializationSortAlphabetically(AnnotatedClass ac);\n     \n      * Method getting {@link ValueInstantiator} to use for given\n      * type (class): return value can either be an instance of\n      * instantiator, or class of instantiator to create.\n-     * \n-     * @since 1.9\n      */\n     public Object findValueInstantiator(AnnotatedClass ac) {\n         return null;\n      *\n      * @return True if such annotation is found (and is not disabled),\n      *   false otherwise\n-     *   \n-     * @since 1.6\n      */\n     public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n         return false;\n          * Helper method for constructing a Pair from two given introspectors (if\n          * neither is null); or returning non-null introspector if one is null\n          * (and return just null if both are null)\n-         * \n-         * @since 1.7\n          */\n         public static AnnotationIntrospector create(AnnotationIntrospector primary,\n                 AnnotationIntrospector secondary)\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     protected LinkedNode<DeserializationProblemHandler> _problemHandlers;\n     \n     /**\n-     * Factory used for constructing {@link org.codehaus.jackson.JsonNode} instances.\n-     *\n-     * @since 1.6\n+     * Factory used for constructing {@link com.fasterxml.jackson.core.JsonNode} instances.\n      */\n     protected final JsonNodeFactory _nodeFactory;\n \n      * it is handled like it was, except for the fact that it is\n      * assigned with a call to {@link #passSerializationFeatures}\n      * instead of constructor.\n-     * \n-     * @since 1.9\n      */\n     protected boolean _sortPropertiesAlphabetically;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     /**\n      * Method for enabling automatic inclusion of type information, needed\n      * for proper deserialization of polymorphic types (unless types\n-     * have been annotated with {@link org.codehaus.jackson.annotate.JsonTypeInfo}).\n+     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n      * \n      * @param applicability Defines kinds of types for which additional type information\n      *    is added; see {@link DefaultTyping} for more information.\n     /**\n      * Method for enabling automatic inclusion of type information -- needed\n      * for proper deserialization of polymorphic types (unless types\n-     * have been annotated with {@link org.codehaus.jackson.annotate.JsonTypeInfo}) --\n+     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n      * using \"As.PROPERTY\" inclusion mechanism and specified property name\n      * to use for inclusion (default being \"@class\" since default type information\n      * always uses class name as type identifier)\n-     * \n-     * @since 1.7\n      */\n     public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n     {\n     /**\n      * Method for disabling automatic inclusion of type information; if so, only\n      * explicitly annotated types (ones with\n-     * {@link org.codehaus.jackson.annotate.JsonTypeInfo}) will have\n+     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n      * additional embedded type information.\n      */\n     public ObjectMapper disableDefaultTyping() {\n      * as well as details of how information is embedded.\n      * \n      * @param typer Type information inclusion handler\n-     * \n-     * \n      */\n     public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n         _deserializationConfig = _deserializationConfig.withTypeResolverBuilder(typer);\n      * (as an alternative to using annotations).\n      * Type for given class is determined from appropriate annotation;\n      * or if missing, default name (unqualified class name)\n-     * \n-     * @since 1.6\n      */\n     public void registerSubtypes(Class<?>... classes) {\n         getSubtypeResolver().registerSubtypes(classes);\n      * Name may be provided as part of argument, but if not will\n      * be based on annotations or use default name (unqualified\n      * class name).\n-     * \n-     * @since 1.6\n      */\n     public void registerSubtypes(NamedType... types) {\n         getSubtypeResolver().registerSubtypes(types);\n \n     /**\n      * Accessor for getting currently configured {@link TypeFactory} instance.\n-     * \n-     * @since 1.8\n      */\n     public TypeFactory getTypeFactory() {\n         return _typeFactory;\n      * Convenience method for constructing {@link JavaType} out of given\n      * type (typically <code>java.lang.Class</code>), but without explicit\n      * context.\n-     * \n-     * @since 1.8\n      */\n     public JavaType constructType(Type t) {\n         return _typeFactory.constructType(t);\n      * Method for specifying {@link JsonNodeFactory} to use for\n      * constructing root level tree nodes (via method\n      * {@link #createObjectNode}\n-     *\n-     * @since 1.2\n      */\n     public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n         _deserializationConfig = _deserializationConfig.withNodeFactory(f);\n      * Note that usually it is better to use method {@link #filteredWriter}; however, sometimes\n      * this method is more convenient. For example, some frameworks only allow configuring\n      * of ObjectMapper instances and not ObjectWriters.\n-     * \n-     * @since 1.8\n      */\n     public void setFilters(FilterProvider filterProvider) {\n         _serializationConfig = _serializationConfig.withFilters(filterProvider);\n      * create properly configured {@link ObjectWriter} and use that; this because\n      * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n      * thread-safe when configuring methods (such as this one) are NOT called.\n-     * \n-     * @since 1.8\n      */\n     public void setDateFormat(DateFormat dateFormat)\n     {\n     }\n     \n     /**\n-     * @since 1.9\n+     * Method for configuring {@link InjectableValues} which used to find\n+     * values to inject.\n      */\n     public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n         _injectableValues = injectableValues;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n         /**\n          * Feature that determines whether properties that have no view\n          * annotations are included in JSON serialization views (see\n-         * {@link org.codehaus.jackson.map.annotate.JsonView} for more\n+         * {@link com.fasterxml.jackson.annotation.JsonView} for more\n          * details on JSON Views).\n          * If enabled, non-annotated properties will be included;\n          * when disabled, they will be excluded. So this feature\n          *<p>\n          * Default value is enabled, meaning that non-annotated\n          * properties are included in all views if there is no\n-         * {@link org.codehaus.jackson.map.annotate.JsonView} annotation.\n+         * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n          */\n         DEFAULT_VIEW_INCLUSION(true),\n         \n          * Feature that allows enabling (or disabling) indentation\n          * for the underlying generator, using the default pretty\n          * printer (see\n-         * {@link org.codehaus.jackson.JsonGenerator#useDefaultPrettyPrinter}\n+         * {@link com.fasterxml.jackson.core.JsonGenerator#useDefaultPrettyPrinter}\n          * for details).\n          *<p>\n          * Note that this only affects cases where\n-         * {@link org.codehaus.jackson.JsonGenerator}\n+         * {@link com.fasterxml.jackson.core.JsonGenerator}\n          * is constructed implicitly by ObjectMapper: if explicit\n          * generator is passed, its configuration is not changed.\n          *<p>\n          * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n          * serialization!):\n          * if enabled, default ordering is alphabetic (similar to\n-         * how {@link org.codehaus.jackson.annotate.JsonPropertyOrder#alphabetic()}\n+         * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n          * works); if disabled, order is unspecified (based on what JDK gives\n          * us, which may be declaration order, but not guaranteed).\n          *<p>\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n  * as either default or explicit values. Hence for class values we must\n  * explicitly use a bogus placeholder to denote equivalent of\n  * \"no class\" (for which 'null' is usually the natural choice).\n- *<p>\n- * Note before version 1.4, this marker class was under\n- * \"org.codehaus.jackson.annotate\". However, since it is only used\n- * by annotations in \"org.codehaus.jackson.map.annotate\" (and not externally\n- * exposed), it was moved to that package as of version 1.5.\n  */\n public final class NoClass\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n  *   ({@link #createMapDeserializer}), and another for POJOs\n  *   ({@link #createBeanDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}.\n  *  </li>\n- * <li>For Tree Model ({@link org.codehaus.jackson.JsonNode}) properties there is\n+ * <li>For Tree Model ({@link com.fasterxml.jackson.core.JsonNode}) properties there is\n  *    {@link #createTreeDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n  * <li>For enumerated types ({@link java.lang.Enum}) there is\n  *    {@link #createEnumDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n  *<p>\n  * Unlike with {@link Serializers}, multiple different methods are used since different\n  * kinds of types typically require different kinds of inputs.\n- * \n- * @since 1.7\n  */\n public interface Deserializers\n {\n      *    {@link ResolvableDeserializer} callback)\n      * \n      * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n-     * \n-     * @since 1.8\n      */\n     public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config,\n             DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n     /**\n      * Method called to locate deserializer for specified JSON tree node type.\n      * \n-     * @param nodeType Specific type of JSON tree nodes to deserialize (subtype of {@link org.codehaus.jackson.JsonNode})\n+     * @param nodeType Specific type of JSON tree nodes to deserialize (subtype of {@link com.fasterxml.jackson.core.JsonNode})\n      * @param config Configuration in effect\n      * \n      * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorProperty.java\n  * deserializer and injecting are separate, here we deal the two as related\n  * things. This is necessary to add proper priority, as well as to simplify\n  * coordination.\n- *<p>\n- * Note that this class was moved in Jackson 1.9\n- * from being a static sub-class of \"org.codehaus.jackson.map.deser.SettableBeanProperty\"\n- * into separate class, to make it easier to use it for custom creators.\n  */\n public class CreatorProperty\n     extends SettableBeanProperty\n     /**\n      * Id of value to inject, if value injection should be used for this parameter\n      * (in addition to, or instead of, regular deserialization).\n-     * \n-     * @since 1.9\n      */\n     protected final Object _injectableValueId;\n     \n     /**\n      * Method that can be called to locate value to be injected for this\n      * property, if it is configured for this.\n-     * \n-     * @since 1.9\n      */\n     public Object findInjectableValue(DeserializationContext context, Object beanInstance)\n     {\n     \n     /**\n      * Method to find value to inject, and inject it to this property.\n-     * \n-     * @since 1.9\n      */\n     public void inject(DeserializationContext context, Object beanInstance)\n         throws IOException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n \n /**\n  * Helper class that is used to flatten JSON structure when using\n- * \"external type id\" (see {@link org.codehaus.jackson.annotate.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n+ * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n  * This is needed to store temporary state and buffer tokens, as the structure is\n  * rearranged a bit so that actual type deserializer can resolve type and \n  * finalize deserialization.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n-\n /**\n  * Basic serializer that can take JSON \"Array\" structure and\n  * construct a {@link java.util.Collection} instance, with typed contents.\n  * as the type), {@link UntypedObjectDeserializer} is used instead.\n  * It can also construct {@link java.util.List}s, but not with specific\n  * POJO types, only other containers and primitives/wrappers.\n- * \n- * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.CollectionDeserializer)\n  */\n @JacksonStdImpl\n public class CollectionDeserializer\n \n     // // Instance construction settings:\n     \n-    /**\n-     * @since 1.9\n-     */\n     protected final ValueInstantiator _valueInstantiator;\n     \n     /**\n     /**\n      * Copy-constructor that can be used by sub-classes to allow\n      * copy-on-write styling copying of settings of an existing instance.\n-     * \n-     * @since 1.9\n      */\n     protected CollectionDeserializer(CollectionDeserializer src)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n  * to properly deal with recursive definition of \"EnumMap<K extends Enum<K>, V>\n  * \n  * @author tsaloranta\n- * \n- * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.EnumMapDeserializer')\n  */\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n public class EnumMapDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n /**\n  * Container for deserializers used for instantiating \"primitive arrays\",\n  * arrays that contain non-object java primitive types.\n- * \n- * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.ArrayDeserilizers)\n  */\n public class PrimitiveArrayDeserializers\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n     /**\n      * Helper method for encapsulating calls to low-level double value parsing; single place\n      * just because we need a work-around that must be applied to all calls.\n-     *<p>\n-     * Note: copied from <code>org.codehaus.jackson.io.NumberUtil</code> (to avoid dependency to\n-     * version 1.8; except for String constants, but that gets compiled in bytecode here)\n      */\n     protected final static double parseDouble(String numStr) throws NumberFormatException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n \n /**\n  * Base class for simple key deserializers.\n- * \n- * @since 1.9 (moved from 'org.codehaus.jackson.map.deser.StdKeyDeserializer')\n  */\n public abstract class StdKeyDeserializer\n     extends KeyDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n  *<p>\n  * Note that this deserializer was significantly changed in Jackson 1.7\n  * (due to massive changes in {@link BeanDeserializer}).\n- * \n- * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.ThrowableDeserializer')\n  */\n public class ThrowableDeserializer\n     extends BeanDeserializer\n \n     /**\n      * Alternative constructor used when creating \"unwrapping\" deserializers\n-     * \n-     * @since 1.9\n      */\n     protected ThrowableDeserializer(BeanDeserializer src, boolean ignoreAllUnknown)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n  * javax.xml classes) from standard factories that offer them.\n  * \n  * @author tatu\n- *\n- * @since 1.6.1\n  */\n public class OptionalHandlerFactory\n {\n     private final static String PACKAGE_PREFIX_JODA_DATETIME = \"org.joda.time.\";\n     private final static String PACKAGE_PREFIX_JAVAX_XML = \"javax.xml.\";\n \n-    private final static String SERIALIZERS_FOR_JODA_DATETIME = \"org.codehaus.jackson.map.ext.JodaSerializers\";\n-    private final static String SERIALIZERS_FOR_JAVAX_XML = \"org.codehaus.jackson.map.ext.CoreXMLSerializers\";\n-    private final static String DESERIALIZERS_FOR_JODA_DATETIME = \"org.codehaus.jackson.map.ext.JodaDeserializers\";\n-    private final static String DESERIALIZERS_FOR_JAVAX_XML = \"org.codehaus.jackson.map.ext.CoreXMLDeserializers\";\n+    private final static String SERIALIZERS_FOR_JODA_DATETIME = \"com.fasterxml.jackson.databind.ext.JodaSerializers\";\n+    private final static String SERIALIZERS_FOR_JAVAX_XML = \"com.fasterxml.jackson.databind.ext.CoreXMLSerializers\";\n+    private final static String DESERIALIZERS_FOR_JODA_DATETIME = \"com.fasterxml.jackson.databind.ext.JodaDeserializers\";\n+    private final static String DESERIALIZERS_FOR_JAVAX_XML = \"com.fasterxml.jackson.databind.ext.CoreXMLDeserializers\";\n \n     // Plus we also have a single serializer for DOM Node:\n     private final static String CLASS_NAME_DOM_NODE = \"org.w3c.dom.Node\";\n     private final static String CLASS_NAME_DOM_DOCUMENT = \"org.w3c.dom.Node\";\n-    private final static String SERIALIZER_FOR_DOM_NODE = \"org.codehaus.jackson.map.ext.DOMSerializer\";\n-    private final static String DESERIALIZER_FOR_DOM_DOCUMENT = \"org.codehaus.jackson.map.ext.DOMDeserializer$DocumentDeserializer\";\n-    private final static String DESERIALIZER_FOR_DOM_NODE = \"org.codehaus.jackson.map.ext.DOMDeserializer$NodeDeserializer\";\n+    private final static String SERIALIZER_FOR_DOM_NODE = \"com.fasterxml.jackson.databind.ext.DOMSerializer\";\n+    private final static String DESERIALIZER_FOR_DOM_DOCUMENT = \"com.fasterxml.jackson.databind.ext.DOMDeserializer$DocumentDeserializer\";\n+    private final static String DESERIALIZER_FOR_DOM_NODE = \"com.fasterxml.jackson.databind.ext.DOMDeserializer$NodeDeserializer\";\n     \n     public final static OptionalHandlerFactory instance = new OptionalHandlerFactory();\n     \n      */\n     \n     public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type)\n-//            BasicBeanDescription beanInfo, BeanProperty property)\n     {\n         Class<?> rawType = type.getRawClass();\n         String className = rawType.getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n     /**********************************************************\n      */\n \n-    /**        \n-     * @since 1.9\n-     */\n     @Override\n     public AnnotatedClass getClassInfo() { return _classInfo; }\n     \n \n     /**\n      * Method for locating the getter method that is annotated with\n-     * {@link org.codehaus.jackson.annotate.JsonValue} annotation,\n+     * {@link com.fasterxml.jackson.annotation.JsonValue} annotation,\n      * if any. If multiple ones are found,\n      * an error is reported by throwing {@link IllegalArgumentException}\n      */\n      * Method that will locate the no-arg constructor for this class,\n      * if it has one, and that constructor has not been marked as\n      * ignorable.\n-     * \n-     * @since 1.9\n      */\n     @Override\n     public AnnotatedConstructor findDefaultConstructor()\n \n     /**\n      * Method used to locate the method of introspected class that\n-     * implements {@link org.codehaus.jackson.annotate.JsonAnySetter}. If no such method exists\n+     * implements {@link com.fasterxml.jackson.annotation.JsonAnySetter}. If no such method exists\n      * null is returned. If more than one are found, an exception\n      * is thrown.\n      * Additional checks are also made to see that method signature\n \n     /**\n      * Method used to locate the method of introspected class that\n-     * implements {@link org.codehaus.jackson.annotate.JsonAnyGetter}.\n+     * implements {@link com.fasterxml.jackson.annotation.JsonAnyGetter}.\n      * If no such method exists null is returned.\n      * If more than one are found, an exception is thrown.\n-     * \n-     * @since 1.6\n      */\n     @Override\n     public AnnotatedMethod findAnyGetter() throws IllegalArgumentException\n     \n     /**\n      * Method for locating all back-reference properties (setters, fields) bean has\n-     * \n-     * @since 1.6\n      */\n     public Map<String,AnnotatedMember> findBackReferenceProperties()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     public boolean isHandled(Annotation ann)\n     {\n         Class<? extends Annotation> acls = ann.annotationType();\n-\n-        /* 16-May-2009, tatu: used to check this like so...\n-           final String JACKSON_PKG_PREFIX = \"org.codehaus.jackson\";\n-\n-           Package pkg = acls.getPackage();\n-           return (pkg != null) && (pkg.getName().startsWith(JACKSON_PKG_PREFIX));\n-        */\n-\n-        // but this is more reliable, now that we have tag annotation:\n         return acls.getAnnotation(JacksonAnnotation.class) != null;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n-\n /**\n- * A {@link org.codehaus.jackson.JsonNode} that represents a JSON-Schema instance.\n+ * Container for a logical JSON Schema instance.\n+ * Internally schema data is stored as a JSON Tree\n+ * (instance of {@link com.fasterxml.jackson.core.JsonNode} is the root\n+ * of schema document)\n  *\n  * @author Ryan Heaton\n  * @see <a href=\"http://json-schema.org/\">JSON Schema</a>\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializationConfig;\n \n-\n /**\n  * Interface that defines builders that are configured based on\n- * annotations (like {@link JsonTypeInfo} or JAXB annotations),\n+ * annotations (like {@link com.fasterxml.jackson.annotation.JsonTypeInfo} or JAXB annotations),\n  * and produce type serializers and deserializers used for\n  * handling type information embedded in JSON to allow for safe\n  * polymorphic type handling.\n  * in second case builder has to first verify whether type information is\n  * applicable for given type, and if not, just return null to indicate this.\n  * \n- * @since 1.5\n  * @author tatu\n  */\n public interface TypeResolverBuilder<T extends TypeResolverBuilder<T>>\n      * usually only used with {@link As#PROPERTY}.\n      *<p>\n      * If not explicitly called, name of property to use is based on\n-     * defaults for {@link org.codehaus.jackson.annotate.JsonTypeInfo.Id} configured.\n+     * defaults for {@link com.fasterxml.jackson.annotation.JsonTypeInfo.Id} configured.\n      * \n      * @param propName Name of JSON property to use for including\n      *    type information\n     /**\n      * Method for specifying default implementation to use if type id \n      * is either not available, or can not be resolved.\n-     * \n-     * @since 1.9\n      */\n     public T defaultImpl(Class<?> defaultImpl);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n  * for a super type will also be used for handling subtypes, unless an exact match\n  * is found first. As an example, handler for {@link CharSequence} would also be used\n  * serializing {@link StringBuilder} instances, unless a direct mapping was found.\n- * \n- * @since 1.7\n  */\n public class SimpleSerializers extends Serializers.Base\n {\n         if (cls == null || cls == Object.class) {\n             throw new IllegalArgumentException(\"JsonSerializer of type \"+ser.getClass().getName()\n                     +\" does not define valid handledType() -- must either register with method that takes type argument \"\n-                    +\" or make serializer extend 'org.codehaus.jackson.map.ser.std.SerializerBase'\"); \n+                    +\" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.SerializerBase'\"); \n         }\n         _addSerializer(cls, ser);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/package-info.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/package-info.java\n /**\n- * Contains concrete {@link org.codehaus.jackson.JsonNode} implementations\n+ * Contains concrete {@link com.fasterxml.jackson.core.JsonNode} implementations\n  * Jackson uses for the Tree model.\n  * These classes are public since concrete type will be needed\n  * for most operations that modify node trees. For read-only access concrete\n--- a/src/main/java/com/fasterxml/jackson/databind/package-info.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/package-info.java\n Java objects (beans or Tree Model: support for both is via\n {@link com.fasterxml.jackson.databind.ObjectMapper} class, as well\n as convenience methods included in\n-{@link org.codehaus.jackson.JsonParser}\n+{@link com.fasterxml.jackson.core.JsonParser}\n <p>\n Object mapper will convert Json content to ant from\n basic Java wrapper types (Integer, Boolean, Double),\n Collection types (List, Map), Java Beans,\n Strings and nulls.\n <p>\n-Tree mapper builds dynamically typed tree of <code>JsonNode</code>s\n-from Json content (and writes such trees as Json),\n-similar to how DOM model works with xml.\n+Tree mapper builds dynamically typed tree of {@link com.fasterxml.jackson.core.JsonNode}s\n+from JSON content (and writes such trees as JSON),\n+similar to how DOM model works with XML.\n Main benefits over Object mapping are:\n <ul>\n  <li>No null checks are needed (dummy\n and Array elements)\n   </li>\n  <li>No type casts are usually needed: all public access methods are defined\n-in basic JsonNode class, and when \"incompatible\" method (such as Array\n+in basic <code>JsonNode</code> class, and when \"incompatible\" method (such as Array\n element access on, say, Boolean node) is used, returned node is\n virtual \"missing\" node.\n   </li>\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.ser.std.MapSerializer;\n \n-\n /**\n  * Class similar to {@link BeanPropertyWriter}, but that will be used\n- * for serializing {@link org.codehaus.jackson.annotate.JsonAnyGetter} annotated\n+ * for serializing {@link com.fasterxml.jackson.annotation.JsonAnyGetter} annotated\n  * (Map) properties\n- * \n- * @since 1.6\n  */\n public class AnyGetterWriter\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n      * Actually it may not make much sense to eagerly instantiate all\n      * kinds of serializers: so this Map actually contains class references,\n      * not instances\n-     *\n-     * @since 1.6\n      */\n     protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =\n         new HashMap<String, Class<? extends JsonSerializer<?>>>();\n     /**\n      * Helper method called to check if a class or method\n      * has an annotation\n-     * (@link org.codehaus.jackson.map.ser.JsonSerialize#using)\n+     * (@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using)\n      * that tells the class to use for serialization.\n      * Returns null if no such annotation found.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n- \n /**\n  * Factory class that can provide serializers for any regular Java beans\n  * (as defined by \"having at least one get method recognizable as bean\n     /**\n      * Configuration settings for this factory; immutable instance (just like this\n      * factory), new version created via copy-constructor (fluent-style)\n-     * \n-     * @since 1.7\n      */\n     protected final Config _factoryConfig;\n \n     \n     /**\n      * Configuration settings container class for bean serializer factory\n-     * \n-     * @since 1.7\n      */\n     public static class ConfigImpl extends Config\n     {\n         \n         // Any properties to suppress?\n         props = filterBeanProperties(config, beanDesc, props);\n-        // Do they need to be sorted in some special way?\n-        props = sortBeanProperties(config, beanDesc, props);\n         \n         // [JACKSON-440] Need to allow reordering of properties to serialize\n         if (_factoryConfig.hasSerializerModifiers()) {\n     /**\n      * Method called to find filter that is configured to be used with bean\n      * serializer being built, if any.\n-     * \n-     * @since 1.7\n      */\n     protected Object findFilterId(SerializationConfig config, BasicBeanDescription beanDesc)\n     {\n                 }\n             }\n         }\n-        return props;\n-    }\n-\n-    /**\n-     * Overridable method that will impose given partial ordering on\n-     * list of discovered propertied. Method can be overridden to\n-     * provide custom ordering of properties, beyond configurability\n-     * offered by annotations (whic allow alphabetic ordering, as\n-     * well as explicit ordering by providing array of property names).\n-     *<p>\n-     * By default Creator properties will be ordered before other\n-     * properties. Explicit custom ordering will override this implicit\n-     * default ordering.\n-     */\n-    /**\n-     * Method that used to be called (pre-1.9) to impose configured\n-     * ordering on list of discovered properties.\n-     * With 1.9 it is not needed any more as ordering is done earlier.\n-     * \n-     * @deprecated Since 1.9 this method does nothing, so there is no\n-     *    benefit from overriding it; it will be removed from 2.0.\n-     */\n-    @Deprecated\n-    protected List<BeanPropertyWriter> sortBeanProperties(SerializationConfig config,\n-            BasicBeanDescription beanDesc, List<BeanPropertyWriter> props)\n-    {\n         return props;\n     }\n \n \n     /**\n      * Method that will apply by-type limitations (as per [JACKSON-429]);\n-     * by default this is based on {@link org.codehaus.jackson.annotate.JsonIgnoreType} annotation but\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType} annotation but\n      * can be supplied by module-provided introspectors too.\n      */\n     protected void removeIgnorableTypes(SerializationConfig config, BasicBeanDescription beanDesc,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n package com.fasterxml.jackson.databind.ser;\n \n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.RuntimeJsonMappingException;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * Abstract class that defines API used by {@link SerializerProvider}\n  */\n public abstract class SerializerFactory\n {\n-\n     /*\n     /**********************************************************\n     /* Helper class to contain configuration settings\n \n     /**\n      * Configuration settings container class for bean serializer factory.\n-     * \n-     * @since 1.7\n      */\n     public abstract static class Config\n     {\n          */\n         public abstract Config withAdditionalSerializers(Serializers additional);\n \n-        /**\n-         * @since 1.8\n-         */\n         public abstract Config withAdditionalKeySerializers(Serializers additional);\n         \n         /**\n      */\n \n     /**\n-     * @since 1.7\n+     * Accessor for configuration object.\n      */\n     public abstract Config getConfig();\n     \n      * of this method, as it usually requires instantiating a new instance of\n      * factory type. Check out javadocs for\n      * {@link com.fasterxml.jackson.databind.ser.BeanSerializerFactory} for more details.\n-     * \n-     * @since 1.7\n      */\n     public abstract SerializerFactory withConfig(Config config);\n \n      *<pre>\n      *   withConfig(getConfig().withAdditionalSerializers(additional));\n      *<pre>\n-     * \n-     * @since 1.7\n      */\n     public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n         return withConfig(getConfig().withAdditionalSerializers(additional));\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n         return withConfig(getConfig().withAdditionalKeySerializers(additional));\n     }\n      *<pre>\n      *   withConfig(getConfig().withSerializerModifier(modifier));\n      *<pre>\n-     * \n-     * @since 1.7\n      */\n     public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n         return withConfig(getConfig().withSerializerModifier(modifier));\n      * @param baseType Declared type to use as the base type for type information serializer\n      * \n      * @return Type serializer to use for the base type, if one is needed; null if not.\n-     * \n-     * @since 1.7\n      */\n     public abstract TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType,\n             BeanProperty property)\n      * \n      * @return Serializer to use, if factory knows it; null if not (in which case default serializer\n      *   is to be used)\n-     *   \n-     * @since 1.8\n      */\n     public abstract JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType baseType,\n             BeanProperty property)\n         throws JsonMappingException;\n-    \n-    /*\n-    /**********************************************************\n-    /* Deprecated (as of 1.7) SerializerFactory API:\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Deprecated version of accessor for type id serializer: as of 1.7 one needs\n-     * to instead call version that passes property information through.\n-     * \n-     * @since 1.5\n-     * \n-     * @deprecated Since 1.7, call variant with more arguments\n-     */\n-    @Deprecated\n-    public final JsonSerializer<Object> createSerializer(JavaType type, SerializationConfig config) {\n-        try {\n-            return createSerializer(config, type, null);\n-        } catch (JsonMappingException e) { // not optimal but:\n-            throw new RuntimeJsonMappingException(e);\n-        }\n-    }\n-    \n-    /**\n-     * Deprecated version of accessor for type id serializer: as of 1.7 one needs\n-     * to instead call version that passes property information through.\n-     * \n-     * @since 1.5\n-     * \n-     * @deprecated Since 1.7, call variant with more arguments\n-     */\n-    @Deprecated\n-    public final TypeSerializer createTypeSerializer(JavaType baseType, SerializationConfig config) {\n-        try {\n-            return createTypeSerializer(config, baseType, null);\n-        } catch (JsonMappingException e) { // not optimal but:\n-            throw new RuntimeException(e);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.type.*;\n \n-\n /**\n  * Interface that defines API for simple extensions that can provide additional serializers\n  * for various types. Access is by a single callback method; instance is to either return\n  * does not support handling of the type. In latter case, further calls can be made\n  * for other providers; in former case returned serializer is used for handling of\n  * instances of specified type.\n- * \n- * @since 1.7\n  */\n public interface Serializers\n {\n      * specified array type.\n      * Implementation should return a serializer instance if it supports\n      * specified type; or null if it does not.\n-     * \n-     * @since 1.8\n      */\n     public JsonSerializer<?> findArraySerializer(SerializationConfig config,\n             ArrayType type, BeanDescription beanDesc, BeanProperty property,\n             return null;\n         }\n     }\n-\n-    /**\n-     * @deprecated As of 1.9, use {@link Base} instead\n-     */\n-    @Deprecated\n-    public static class None extends Base { }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n import com.fasterxml.jackson.databind.ser.impl.SerializerCache;\n import com.fasterxml.jackson.databind.ser.impl.UnknownSerializer;\n import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n-import com.fasterxml.jackson.databind.ser.std.StdKeySerializer;\n import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n-\n-\n \n /**\n  * Default {@link SerializerProvider} implementation. Handles\n \n     public final static JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER =\n         new FailingSerializer(\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\");\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link StdKeySerializers} instead\n-     */\n-    @Deprecated\n-    public final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n \n     public final static JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER = new UnknownSerializer();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n      */\n \n     /**\n-     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n-     */\n-    @JacksonStdImpl\n-    @Deprecated\n-    public final static class CalendarSerializer\n-        extends com.fasterxml.jackson.databind.ser.std.CalendarSerializer { }\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n-     */\n-    @Deprecated\n-    @JacksonStdImpl\n-    public final static class UtilDateSerializer\n-        extends com.fasterxml.jackson.databind.ser.std.DateSerializer {\n-        \n-    }\n-\n-    /**\n      * Compared to regular {@link UtilDateSerializer}, we do use String\n      * representation here. Why? Basically to truncate of time part, since\n      * that should not be used by plain SQL date.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     \n     /**\n      * Value serializer to use, if it can be statically determined\n-     * \n-     * @since 1.5\n      */\n     protected JsonSerializer<Object> _elementSerializer;\n \n     /**\n      * Collection-valued property being serialized with this instance\n-     * \n-     * @since 1.7\n      */\n     protected final BeanProperty _property;\n \n     /**\n      * If element type can not be statically determined, mapping from\n      * runtime type to serializer is handled using this object\n-     * \n-     * @since 1.7\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n-\n-    /**\n-     * @deprecated since 1.8\n-     */\n-    @Deprecated\n-    protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping,\n-            TypeSerializer vts, BeanProperty property)\n-    {\n-        this(cls, et, staticTyping, vts, property, null);\n-    }\n \n     protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping,\n             TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n  * of variants that only differ in small details.\n  * Can be used for custom bean serializers as well, although that\n  * is not the primary design goal.\n- * \n- * @since 1.9\n  */\n public abstract class BeanSerializerBase\n     extends SerializerBase<Object>\n     final protected BeanPropertyWriter[] _filteredProps;\n \n     /**\n-     * Handler for {@link org.codehaus.jackson.annotate.JsonAnyGetter}\n+     * Handler for {@link com.fasterxml.jackson.annotation.JsonAnyGetter}\n      * annotated properties\n-     * \n-     * @since 1.6\n      */\n     final protected AnyGetterWriter _anyGetterWriter;\n \n      * Alternative serialization method that gets called when there is a\n      * {@link BeanPropertyFilter} that needs to be called to determine\n      * which properties are to be serialized (and possibly how)\n-     * \n-     * @since 1.7\n      */\n     protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     /**\n      * Helper method used to locate filter that is needed, based on filter id\n      * this serializer was constructed with.\n-     * \n-     * @since 1.7\n      */\n     protected BeanPropertyFilter findFilter(SerializerProvider provider)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n  * Standard serializer for {@link java.util.Calendar}.\n  * As with other time/date types, is configurable to produce timestamps\n  * (standard Java 64-bit timestamp) or textual formats (usually ISO-8601).\n- * \n- * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.StdSerializers#CalendarSerializer}\n  */\n @JacksonStdImpl\n public class CalendarSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n /**\n  * For efficiency, we will serialize Dates as longs, instead of\n  * potentially more readable Strings.\n- *<p>\n- * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.StdSerializers#UtilDateSerializer}\n  */\n @JacksonStdImpl\n public class DateSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n \n     /**\n      * Property being serialized with this instance\n-     * \n-     * @since 1.7\n      */\n     protected final BeanProperty _property;\n     \n     /**\n      * Value serializer to use, if it can be statically determined\n-     * \n-     * @since 1.5\n      */\n     protected JsonSerializer<Object> _valueSerializer;\n \n      * Type serializer used for values, if any.\n      */\n     protected final TypeSerializer _valueTypeSerializer;\n-\n-    /**\n-     * @deprecated Since 1.8, use variant that takes value serializer\n-     */\n-    @Deprecated\n-    public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,\n-            TypeSerializer vts, BeanProperty property)\n-    {\n-        this(valueType, staticTyping, keyEnums, vts, property, null);\n-    }\n \n     public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,\n             TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer)\n     @Override\n     public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n     {\n-        return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts,  _property);\n+        return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts,  _property, _valueSerializer);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n /**\n  * Serializer class that can serialize Object that have a\n- * {@link org.codehaus.jackson.annotate.JsonValue} annotation to\n+ * {@link com.fasterxml.jackson.annotation.JsonValue} annotation to\n  * indicate that serialization should be done by calling the method\n  * annotated, and serializing result it returns.\n  * <p/>\n      * is used for \"natural\" types (boolean, int, String, double); and where\n      * we actually must force type information wrapping, even though\n      * one would not normally be added.\n-     * \n-     * @since 1.7\n      */\n     protected boolean _forceTypeInformation;\n     \n     /**\n      * @param ser Explicit serializer to use, if caller knows it (which\n-     *            occurs if and only if the \"value method\" was annotated with\n-     *            {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}), otherwise\n-     *            null\n+     *    occurs if and only if the \"value method\" was annotated with\n+     *    {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}), otherwise\n+     *    null\n      */\n     public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser, BeanProperty property)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n     \n     /**\n      * Map-valued property being serialized with this instance\n-     * \n-     * @since 1.7\n      */\n     protected final BeanProperty _property;\n     \n \n     /**\n      * Declared type of keys\n-     * \n-     * @since 1.7\n      */\n     protected final JavaType _keyType;\n \n \n     /**\n      * Key serializer to use, if it can be statically determined\n-     * \n-     * @since 1.7\n      */\n     protected JsonSerializer<Object> _keySerializer;\n \n     /**\n      * Value serializer to use, if it can be statically determined\n-     * \n-     * @since 1.5\n      */\n     protected JsonSerializer<Object> _valueSerializer;\n \n     /**\n      * If value type can not be statically determined, mapping from\n      * runtime value types to serializers are stored in this object.\n-     * \n-     * @since 1.8\n      */\n     protected PropertySerializerMap _dynamicValueSerializers;\n     \n         return ms;\n     }\n     \n-    /**\n-     * Factory method used to construct Map serializers.\n-     * \n-     * @param ignoredList Array of entry names that are to be filtered on\n-     *    serialization; null if none\n-     * @param mapType Declared type information (needed for static typing)\n-     * @param staticValueType Whether static typing should be used for the\n-     *    Map (which includes its contents)\n-     * @param vts Type serializer to use for map entry values, if any\n-     * \n-     * @deprecated As of 1.8; use the variant with more arguments\n-     */\n-    @Deprecated\n-    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n-            boolean staticValueType, TypeSerializer vts, BeanProperty property)\n-    {\n-        return construct(ignoredList, mapType, staticValueType, vts, property, null, null);\n-    }\n-\n     public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n             boolean staticValueType, TypeSerializer vts, BeanProperty property,\n             JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n  * types that are default mappings for corresponding JSON scalar\n  * types: {@link java.lang.String}, {@link java.lang.Integer},\n  * {@link java.lang.Double} and {@link java.lang.Boolean}.\n- * \n- * @since 1.9 (refactored from 'org.codehaus.jackson.map.StdSerializers#NontTypedScalarSerializer')\n  */\n public abstract class NonTypedScalarSerializerBase<T>\n     extends ScalarSerializerBase<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n \n /**\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n- * \n- * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.impl.ObjectArraySerializer')\n  */\n @JacksonStdImpl\n public class ObjectArraySerializer\n \n     /**\n      * Value serializer to use, if it can be statically determined.\n-     * \n-     * @since 1.5\n      */\n     protected JsonSerializer<Object> _elementSerializer;\n \n     /**\n      * If element type can not be statically determined, mapping from\n      * runtime type to serializer is handled using this object\n-     * \n-     * @since 1.7\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n     \n-    /**\n-     * @deprecated since 1.8\n-     */\n-    @Deprecated\n-    public ObjectArraySerializer(JavaType elemType, boolean staticTyping,\n-            TypeSerializer vts, BeanProperty property)\n-    {\n-        this(elemType, staticTyping, vts, property, null);\n-    }\n     \n     public ObjectArraySerializer(JavaType elemType, boolean staticTyping,\n             TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer)\n         }\n     }        \n \n-    /**\n-     * @since 1.7\n-     */\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n         return result.serializer;\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             JavaType type, SerializerProvider provider) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n-\n \n /**\n  * Base class used by all standard serializers. Provides some convenience\n         _handledType = t;\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     @SuppressWarnings(\"unchecked\")\n     protected SerializerBase(JavaType type) {\n         _handledType = (Class<T>) type.getRawClass();\n         // [JACKSON-55] Need to add reference information\n         throw JsonMappingException.wrapWithPath(t, bean, index);\n     }\n-\n-    /**\n-     * @deprecated Use version that takes <code>SerializerProvider</code> instead.\n-     */\n-    @Deprecated\n-    public void wrapAndThrow(Throwable t, Object bean, String fieldName) throws IOException {\n-        wrapAndThrow(null, t, bean, fieldName);\n-    }\n-\n-    /**\n-     * @deprecated Use version that takes <code>SerializerProvider</code> instead.\n-     */\n-    @Deprecated\n-    public void wrapAndThrow(Throwable t, Object bean, int index) throws IOException {\n-        wrapAndThrow(null, t, bean, index);\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n /**\n  * Helper class used to resolve String values (either JSON Object field\n  * names or regular String values) into Java Enum instances.\n- * \n- * @since 1.9 renamed from 'org.codehaus.jackson.map.deser.EnumResolver'\n  */\n public class EnumResolver<T extends Enum<T>>\n {\n     /**\n      * Factory method for constructing resolver that maps from Enum.toString() into\n      * Enum value\n-     * \n-     * @since 1.6\n      */\n     public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingToString(Class<ET> enumCls)\n     {\n     /**\n      * Method that needs to be used instead of {@link #constructUsingToString}\n      * if static type of enum is not known.\n-     * \n-     * @since 1.6\n      */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public static EnumResolver<?> constructUnsafeUsingToString(Class<?> rawEnumCls)", "timestamp": 1324793241, "metainfo": ""}