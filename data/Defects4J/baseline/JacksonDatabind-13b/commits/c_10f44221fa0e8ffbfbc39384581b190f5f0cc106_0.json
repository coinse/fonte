{"sha": "10f44221fa0e8ffbfbc39384581b190f5f0cc106", "log": "Fix #565: add support for `Map.Entry`", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     private final static Class<?> CLASS_STRING = String.class;\n     private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n     private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n \n     /**\n      * We need a placeholder for creator properties that don't have name\n         \n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n-        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        // Then optional type info: if type has been resolved, we may already know type deserializer:\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n-                    beanDesc, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n         }\n         return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n-\n-    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Map(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc)\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Enum deserializers\n         }\n         return deser;\n     }\n-\n-    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     /*\n     /**********************************************************\n             return custom;\n         }\n         return JsonNodeDeserializer.getDeserializer(nodeClass);\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n     }\n     \n     /*\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     }\n \n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl (partial): key deserializers\n         if (rawType == CLASS_ITERABLE) {\n             // [Issue#199]: Can and should 'upgrade' to a Collection type:\n             TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n+            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n             CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n             // Should we re-introspect beanDesc? For now let's not...\n             return createCollectionDeserializer(ctxt, ct, beanDesc);\n+        }\n+        if (rawType == CLASS_MAP_ENTRY) {\n+            final DeserializationConfig config = ctxt.getConfig();\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_MAP_ENTRY);\n+            JavaType kt, vt;\n+            if (tps == null || tps.length != 2) {\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = tps[0];\n+                vt = tps[1];\n+            }\n+            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n+            if (vts == null) {\n+                vts = findTypeDeserializer(config, vt);\n+            }\n+            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n+            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n+            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n         }\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n         if (rawType == TokenBuffer.class) {\n             return new TokenBufferDeserializer();\n         }\n+        if (AtomicReference.class.isAssignableFrom(rawType)) {\n+            // Must find parameterization\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+            JavaType referencedType;\n+            if (params == null || params.length < 1) { // untyped (raw)\n+                referencedType = TypeFactory.unknownType();\n+            } else {\n+                referencedType = params[0];\n+            }\n+            TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n+            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n+            JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n+            return new AtomicReferenceDeserializer(referencedType, vts, deser);\n+        }\n+        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n+        if (deser != null) {\n+            return deser;\n+        }\n         return JdkDeserializers.find(rawType, clsName);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, finding custom deserializers\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n+                    beanDesc, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import java.lang.reflect.Type;\n import java.util.*;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n-import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n     \n     /*\n     /**********************************************************\n-    /* Overrides for super-class methods used for finding\n-    /* custom deserializers\n-    /**********************************************************\n-     */\n-\n-    // Note: NOT overriding, superclass has no matching method\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return (JsonDeserializer<Object>) deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* DeserializerFactory API implementation\n     /**********************************************************\n      */\n         // note: we do NOT check for custom deserializers here, caller has already\n         // done that\n         JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n+        // Also: better ensure these are post-processable?\n         if (deser != null) {\n-            return deser;\n-        }\n-        \n-        Class<?> cls = type.getRawClass();\n-        // [JACKSON-283]: AtomicReference is a rather special type...\n-        if (AtomicReference.class.isAssignableFrom(cls)) {\n-            // Must find parameterization\n-            TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n-            JavaType referencedType;\n-            if (params == null || params.length < 1) { // untyped (raw)\n-                referencedType = TypeFactory.unknownType();\n-            } else {\n-                referencedType = params[0];\n-            }\n-            TypeDeserializer valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), referencedType);\n-            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n-            deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n-            return new AtomicReferenceDeserializer(referencedType, valueTypeDeser, deser);\n-        }\n-        return findOptionalStdDeserializer(ctxt, type, beanDesc);\n-    }\n-\n-    /**\n-     * Overridable method called after checking all other types.\n-     * \n-     * @since 2.2\n-     */\n-    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n     \n     protected JavaType materializeAbstractType(DeserializationContext ctxt,\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Basic serializer that can take JSON \"Object\" structure and\n+ * construct a {@link java.util.Map} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.Map}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ */\n+@JacksonStdImpl\n+public class MapEntryDeserializer\n+    extends ContainerDeserializerBase<Map.Entry<Object,Object>>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = 1;\n+\n+    // // Configuration: typing, deserializers\n+\n+    protected final JavaType _type;\n+\n+    /**\n+     * Key deserializer to use; either passed via constructor\n+     * (when indicated by annotations), or resolved when\n+     * {@link #resolve} is called;\n+     */\n+    protected final KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public MapEntryDeserializer(JavaType type,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(type);\n+        if (type.containedTypeCount() != 2) { // sanity check\n+            throw new IllegalArgumentException(\"Missing generic type information for \"+type);\n+        }\n+        _type = type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     */\n+    protected MapEntryDeserializer(MapEntryDeserializer src)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = src._keyDeserializer;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n+\n+    protected MapEntryDeserializer(MapEntryDeserializer src,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Fluent factory method used to create a copy with slightly\n+     * different settings. When sub-classing, MUST be overridden.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntryDeserializer withResolved(KeyDeserializer keyDeser,\n+            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser)\n+    {\n+        \n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser)) {\n+            return this;\n+        }\n+        return new MapEntryDeserializer(this,\n+                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * when it is known for which property deserializer is needed for.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _keyDeserializer;\n+        if (kd == null) {\n+            kd = ctxt.findKeyDeserializer(_type.containedType(0), property);\n+        } else {\n+            if (kd instanceof ContextualKeyDeserializer) {\n+                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n+            }\n+        }\n+        JsonDeserializer<?> vd = _valueDeserializer;\n+        vd = findConvertingContentDeserializer(ctxt, property, vd);\n+        if (vd == null) {\n+            vd = ctxt.findContextualValueDeserializer(_type.containedType(1), property);\n+        } else { // if directly assigned, probably not yet contextual, so:\n+            vd = ctxt.handleSecondaryContextualization(vd, property);\n+        }\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vtd, vd);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _type.containedType(1);\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n+            // [JACKSON-620] (empty) String may be ok however:\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n+        }\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        if (t != JsonToken.FIELD_NAME) {\n+            if (t == JsonToken.END_OBJECT) {\n+                throw ctxt.mappingException(\"Can not deserialize a Map.Entry out of empty JSON Object\");\n+            }\n+            throw ctxt.mappingException(handledType(), t);\n+        }\n+        \n+        final KeyDeserializer keyDes = _keyDeserializer;\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        final String keyStr = jp.getCurrentName();\n+        Object key = keyDes.deserializeKey(keyStr, ctxt);\n+        Object value = null;\n+        // And then the value...\n+        t = jp.nextToken();\n+        try {\n+            // Note: must handle null explicitly here; value deserializers won't\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = valueDes.getNullValue();\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(e, Map.Entry.class, keyStr);\n+        }\n+\n+        // Close, but also verify that we reached the END_OBJECT\n+        t = jp.nextToken();\n+        if (t != JsonToken.END_OBJECT) {\n+            if (t == JsonToken.FIELD_NAME) { // most likely\n+                throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: more than entry in JSON (second field: '\"+jp.getCurrentName()+\"')\");\n+            }\n+            // how would this occur?\n+            throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: unexpected content after JSON Object entry: \"+t);\n+        }\n+        return new AbstractMap.SimpleEntry<Object,Object>(key, value);\n+    }\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Map.Entry<Object,Object> result) throws IOException\n+    {\n+        throw new IllegalStateException(\"Can not update Map.Entry values\");\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JavaType getValueType() { return _type; }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n      * Simple test to ensure that @JsonDeserialize.using is\n      * recognized\n      */\n-    public void testMapWithDeserializer() throws IOException\n+    public void testMapWithDeserializer() throws Exception\n     {\n         CustomMap result = MAPPER.readValue(quote(\"xyz\"), CustomMap.class);\n         assertEquals(1, result.size());\n         assertEquals(\"xyz\", result.get(\"x\"));\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Test methods, annotated Map.Entry\n+    /**********************************************************\n+     */\n+\n+    public void testMapEntrySimpleTypes() throws Exception\n+    {\n+        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes(\"[{'a':15},{'b':42}]\"),\n+                new TypeReference<List<Map.Entry<String,Long>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(\"b\", stuff.get(1).getKey());\n+        assertEquals(Long.valueOf(42), stuff.get(1).getValue());\n+    }\n+\n+    public void testMapEntryWithStringBean() throws Exception\n+    {\n+        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes(\"[{'28':'Foo'},{'13':'Bar'}]\"),\n+                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());\n+        \n+        StringWrapper sw = stuff.get(1).getValue();\n+        assertEquals(\"Bar\", sw.str);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Error tests\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n         StringIntMapEntry input = new StringIntMapEntry(\"answer\", 42);\n         String json = MAPPER.writeValueAsString(input);\n         assertEquals(aposToQuotes(\"{'answer':42}\"), json);\n+\n+        StringIntMapEntry[] array = new StringIntMapEntry[] { input };\n+        json = MAPPER.writeValueAsString(array);\n+        assertEquals(aposToQuotes(\"[{'answer':42}]\"), json);\n     }        \n }", "timestamp": 1412040017, "metainfo": ""}