{"sha": "c8fbc8010a23a7fea255c2a9c3ba4366c937865f", "log": "Refactoring to try to reduce amount of mandatory initializations", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n     private static final long serialVersionUID = 1;\n \n     /**\n-     * We will pre-create serializers for common non-structured\n-     * (that is things other than Collection, Map or array)\n-     * types. These need not go through factory.\n-     */\n-    final protected static HashMap<ClassKey, JsonDeserializer<Object>> _simpleDeserializers\n-        = new HashMap<ClassKey, JsonDeserializer<Object>>();\n-\n-    /**\n      * Also special array deserializers for primitive array types.\n      */\n     final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n \n     /**\n      * Set of available key deserializers is currently limited\n-     * to standard types; and all known instances are storing in this map.\n+     * to standard types; and all known instances are stored in this map.\n      */\n     final protected static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n-\n-    static {\n-        // First, add the fall-back \"untyped\" deserializer:\n-        _add(_simpleDeserializers, Object.class, new UntypedObjectDeserializer());\n-    \n-        // Then String and String-like converters:\n-        StdDeserializer<?> strDeser = new StringDeserializer();\n-        _add(_simpleDeserializers, String.class, strDeser);\n-        _add(_simpleDeserializers, CharSequence.class, strDeser);\n-    \n-        // Primitives/wrappers, other Numbers:\n-        _add(_simpleDeserializers, NumberDeserializers.all());\n-        // Date/time types\n-        _add(_simpleDeserializers, DateDeserializers.all());\n-        // other JDK types\n-        _add(_simpleDeserializers, JdkDeserializers.all());\n-        // and a few Jackson types as well:\n-        _add(_simpleDeserializers, JacksonDeserializers.all());\n-    }\n-\n-    private static void _add(Map<ClassKey, JsonDeserializer<Object>> desers,\n-            StdDeserializer<?>[] serializers) {\n-        for (StdDeserializer<?> ser : serializers) {\n-            _add(desers, ser.getValueClass(), ser);\n-        }\n-    }\n-\n-    private static void _add(Map<ClassKey, JsonDeserializer<Object>> desers,\n-            Class<?> valueClass, StdDeserializer<?> stdDeser)\n-    {\n-        @SuppressWarnings(\"unchecked\")\n-        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) stdDeser;\n-        desers.put(new ClassKey(valueClass), deser);\n-    }\n     \n     /* We do some defaulting for abstract Map classes and\n      * interfaces, to avoid having to use exact types or annotations in\n         return b.buildTypeDeserializer(config, contentType, subtypes);\n     }\n \n+    private final static Class<?> CLASS_OBJECT = Object.class;\n+    private final static Class<?> CLASS_STRING = String.class;\n+    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n+\n+    /**\n+     * Helper method called to find one of default serializers for \"well-known\"\n+     * platform types: JDK-provided types, and small number of public Jackson\n+     * API types.\n+     * \n+     * @since 2.2\n+     */\n+    public JsonDeserializer<?> findDefaultSerializer(Class<?> rawType)\n+    {\n+        String clsName = rawType.getName();\n+        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n+            // Object (\"untyped\"), String equivalents:\n+            if (rawType == CLASS_OBJECT) {\n+                return UntypedObjectDeserializer.instance;\n+            }\n+            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n+                return StringDeserializer.instance;\n+            }\n+            // Primitives/wrappers, other Numbers:\n+            JsonDeserializer<?> deser = NumberDeserializers.find(rawType);\n+            if (deser == null) {\n+                deser = DateDeserializers.find(rawType);\n+                if (deser == null) {\n+                    deser = JdkDeserializers.find(rawType);\n+                }\n+            }\n+            return deser;\n+        }\n+        if (clsName.startsWith(\"com.fasterxml.\")) {\n+            // and a few Jackson types as well:\n+            return JacksonDeserializers.find(rawType);\n+        }\n+        return null;\n+    }\n+\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n-import com.fasterxml.jackson.databind.deser.impl.FieldProperty;\n-import com.fasterxml.jackson.databind.deser.impl.MethodProperty;\n-import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n-import com.fasterxml.jackson.databind.deser.impl.PropertyBasedObjectIdGenerator;\n-import com.fasterxml.jackson.databind.deser.impl.SetterlessProperty;\n+import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n     {\n         Class<?> cls = type.getRawClass();\n         // note: we do NOT check for custom deserializers here; that's for sub-class to do\n-        JsonDeserializer<Object> deser = _simpleDeserializers.get(new ClassKey(cls));\n+        JsonDeserializer<?> deser = findDefaultSerializer(cls);\n         if (deser != null) {\n-            return deser;\n+            return (JsonDeserializer<Object>) deser;\n         }\n         \n         // [JACKSON-283]: AtomicReference is a rather special type...\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    public final static ClassDeserializer instance = new ClassDeserializer();\n+    \n     public ClassDeserializer() { super(Class.class); }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n \n import java.io.IOException;\n import java.sql.Timestamp;\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.Locale;\n-import java.util.TimeZone;\n+import java.text.*;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n+\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n+\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n @SuppressWarnings(\"serial\")\n public class DateDeserializers\n {\n+    private final static HashSet<String> _classNames = new HashSet<String>();\n+    static {\n+        Class<?>[] numberTypes = new Class<?>[] {\n+            Calendar.class,\n+            GregorianCalendar.class,\n+            java.sql.Date.class,\n+            java.util.Date.class,\n+            Timestamp.class,\n+            TimeZone.class\n+        };\n+        for (Class<?> cls : numberTypes) {\n+            _classNames.add(cls.getName());\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Since 2.2 -- use {@link #find} instead.\n+     */\n     public static StdDeserializer<?>[] all()\n     {\n         return  new StdDeserializer[] {\n-            new CalendarDeserializer(), // for nominal type of java.util.Calendar\n-            new DateDeserializer(),\n+            CalendarDeserializer.instance, // for nominal type of java.util.Calendar\n+            DateDeserializer.instance,\n             /* 24-Jan-2010, tatu: When including type information, we may\n              *    know that we specifically need GregorianCalendar...\n              */\n-            new CalendarDeserializer(GregorianCalendar.class),\n-            new SqlDateDeserializer(),\n-            new TimestampDeserializer(),\n-            new TimeZoneDeserializer()\n+            CalendarDeserializer.gregorianInstance,\n+            SqlDateDeserializer.instance,\n+            TimestampDeserializer.instance,\n+            TimeZoneDeserializer.instance\n         };\n     }\n \n+    public static JsonDeserializer<?> find(Class<?> rawType)\n+    {\n+        if (!_classNames.contains(rawType.getName())) {\n+            return null;\n+        }\n+        // Start with most common types; int, boolean, long, double\n+        if (rawType == Calendar.class) {\n+            return CalendarDeserializer.instance;\n+        }\n+        if (rawType == java.util.Date.class) {\n+            return DateDeserializer.instance;\n+        }\n+        if (rawType == java.sql.Date.class) {\n+            return SqlDateDeserializer.instance;\n+        }\n+        if (rawType == Timestamp.class) {\n+            return TimestampDeserializer.instance;\n+        }\n+        if (rawType == TimeZone.class) {\n+            return TimeZoneDeserializer.instance;\n+        }\n+        if (rawType == GregorianCalendar.class) {\n+            return CalendarDeserializer.gregorianInstance;\n+        }\n+        // should never occur\n+        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Intermediate class for Date-based ones\n \n         protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df, String formatStr);\n         \n-//      @Override\n+        @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n            throws JsonMappingException\n         {\n     public static class CalendarDeserializer\n         extends DateBasedDeserializer<Calendar>\n     {\n+        public final static CalendarDeserializer instance = new CalendarDeserializer();\n+        public final static CalendarDeserializer gregorianInstance = new CalendarDeserializer(GregorianCalendar.class);\n+        \n         /**\n          * We may know actual expected type; if so, it will be\n          * used for instantiation.\n     public static class DateDeserializer\n         extends DateBasedDeserializer<Date>\n     {\n+        public final static DateDeserializer instance = new DateDeserializer();\n+\n         public DateDeserializer() { super(Date.class); }\n         public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) {\n             super(base, df, formatString);\n     public static class SqlDateDeserializer\n         extends DateBasedDeserializer<java.sql.Date>\n     {\n+        public final static SqlDateDeserializer instance = new SqlDateDeserializer();\n+\n         public SqlDateDeserializer() { super(java.sql.Date.class); }\n         public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df, String formatString) {\n             super(src, df, formatString);\n     public static class TimestampDeserializer\n         extends DateBasedDeserializer<Timestamp>\n     {\n+        public final static TimestampDeserializer instance = new TimestampDeserializer();\n+\n         public TimestampDeserializer() { super(Timestamp.class); }\n         public TimestampDeserializer(TimestampDeserializer src, DateFormat df, String formatString) {\n             super(src, df, formatString);\n     protected static class TimeZoneDeserializer\n         extends FromStringDeserializer<TimeZone>\n     {\n+        public final static TimeZoneDeserializer instance = new TimeZoneDeserializer();\n+\n         public TimeZoneDeserializer() { super(TimeZone.class); }\n \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n @SuppressWarnings(\"serial\")\n public class JacksonDeserializers\n {\n+    /**\n+     * @deprecated Since 2.2 -- use {@link #find} instead.\n+     */\n+    @Deprecated\n     public static StdDeserializer<?>[] all()\n     {\n         // note: JsonLocation supported via ValueInstantiator\n         return  new StdDeserializer[] {\n-            new JavaTypeDeserializer(),\n-            new TokenBufferDeserializer(),\n+            JavaTypeDeserializer.instance,\n+            TokenBufferDeserializer.instance\n         };\n     }\n \n+    public static JsonDeserializer<?> find(Class<?> rawType)\n+    {\n+        if (rawType == TokenBuffer.class) {\n+            return TokenBufferDeserializer.instance;\n+        }\n+        if (JavaType.class.isAssignableFrom(rawType)) {\n+            return JavaTypeDeserializer.instance;\n+        }\n+        return null;\n+    }\n+    \n     public static ValueInstantiator findValueInstantiator(DeserializationConfig config,\n             BeanDescription beanDesc)\n     {\n         if (beanDesc.getBeanClass() == JsonLocation.class) {\n-            return new JsonLocationInstantiator();\n+            return JsonLocationInstantiator.instance;\n         }\n         return null;\n     }\n     public static class JavaTypeDeserializer\n         extends StdScalarDeserializer<JavaType>\n     {\n+        public final static JavaTypeDeserializer instance = new JavaTypeDeserializer();\n+        \n         public JavaTypeDeserializer() { super(JavaType.class); }\n         \n         @Override\n      */\n     public static class JsonLocationInstantiator extends ValueInstantiator\n     {\n+        public final static JsonLocationInstantiator instance = new JsonLocationInstantiator();\n+        \n         @Override\n         public String getValueTypeDesc() {\n             return JsonLocation.class.getName();\n     public static class TokenBufferDeserializer\n         extends StdScalarDeserializer<TokenBuffer>\n     {\n+        public final static TokenBufferDeserializer instance = new TokenBufferDeserializer();\n+        \n         public TokenBufferDeserializer() { super(TokenBuffer.class); }\n \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n @SuppressWarnings(\"serial\")\n public class JdkDeserializers\n {\n+    /**\n+     * @deprecated Since 2.2 -- use {@link #find} instead.\n+     */\n+    @Deprecated\n     public static StdDeserializer<?>[] all()\n     {\n         return new StdDeserializer[] {\n-\n             // from String types:\n-            new StringDeserializer(),\n             new UUIDDeserializer(),\n             new URLDeserializer(),\n             new URIDeserializer(),\n             new StackTraceElementDeserializer()\n         };\n     }\n+\n+    public static JsonDeserializer<?> find(Class<?> rawType)\n+    {\n+        if (rawType == UUID.class) {\n+            return UUIDDeserializer.instance;\n+        }\n+        if (rawType == URIDeserializer.class) {\n+            /* Ok: following ones would work via String-arg detection too;\n+             * if we get more may want to formally change.\n+             */\n+            return URIDeserializer.instance;\n+        }\n+        if (rawType == URL.class) {\n+            return URLDeserializer.instance;\n+        }\n+        if (rawType == File.class) {\n+            return FileDeserializer.instance;\n+            \n+            /* But these will require custom handling regardless:\n+             */\n+        }\n+        if (rawType == Currency.class) {\n+            return CurrencyDeserializer.instance;\n+        }\n+        if (rawType == Pattern.class) {\n+            return PatternDeserializer.instance;\n+        }\n+        if (rawType == Locale.class) {\n+            return LocaleDeserializer.instance;\n+        }\n+        if (rawType == InetAddress.class) {\n+            return InetAddressDeserializer.instance;\n+        }\n+        if (rawType == Charset.class) {\n+            return CharsetDeserializer.instance;\n+        }\n+        if (rawType == Class.class) {\n+            return ClassDeserializer.instance;\n+        }\n+        if (rawType == StackTraceElement.class) {\n+            return StackTraceElementDeserializer.instance;\n+        }\n+        if (rawType == AtomicBoolean.class) {\n+            // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n+            return AtomicBooleanDeserializer.instance;\n+        }\n+        return null;\n+    }\n+    \n     \n     /*\n     /**********************************************************\n     public static class UUIDDeserializer\n         extends FromStringDeserializer<UUID>\n     {\n+        public final static UUIDDeserializer instance = new UUIDDeserializer();\n+        \n         public UUIDDeserializer() { super(UUID.class); }\n \n         @Override\n     public static class URLDeserializer\n         extends FromStringDeserializer<URL>\n     {\n+        public final static URLDeserializer instance = new URLDeserializer();\n+\n         public URLDeserializer() { super(URL.class); }\n         \n         @Override\n     public static class URIDeserializer\n         extends FromStringDeserializer<URI>\n     {\n+        public final static URIDeserializer instance = new URIDeserializer();\n+\n         public URIDeserializer() { super(URI.class); }\n     \n         @Override\n     public static class CurrencyDeserializer\n         extends FromStringDeserializer<Currency>\n     {\n+        public final static CurrencyDeserializer instance = new CurrencyDeserializer();\n+\n         public CurrencyDeserializer() { super(Currency.class); }\n         \n         @Override\n     public static class PatternDeserializer\n         extends FromStringDeserializer<Pattern>\n     {\n+        public final static PatternDeserializer instance = new PatternDeserializer();\n+\n         public PatternDeserializer() { super(Pattern.class); }\n         \n         @Override\n     protected static class LocaleDeserializer\n         extends FromStringDeserializer<Locale>\n     {\n+        public final static LocaleDeserializer instance = new LocaleDeserializer();\n+\n         public LocaleDeserializer() { super(Locale.class); }\n         \n         @Override\n     protected static class InetAddressDeserializer\n         extends FromStringDeserializer<InetAddress>\n     {\n+        public final static InetAddressDeserializer instance = new InetAddressDeserializer();\n+\n         public InetAddressDeserializer() { super(InetAddress.class); }\n     \n         @Override\n     protected static class CharsetDeserializer\n         extends FromStringDeserializer<Charset>\n     {\n+        public final static CharsetDeserializer instance = new CharsetDeserializer();\n+\n         public CharsetDeserializer() { super(Charset.class); }\n     \n         @Override\n     public static class FileDeserializer\n         extends FromStringDeserializer<File>\n     {\n+        public final static FileDeserializer instance = new FileDeserializer();\n+\n         public FileDeserializer() { super(File.class); }\n         \n         @Override\n             return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n         }\n         \n-//        @Override\n+        @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property) throws JsonMappingException\n         {\n     public static class AtomicBooleanDeserializer\n         extends StdScalarDeserializer<AtomicBoolean>\n     {\n+        public final static AtomicBooleanDeserializer instance = new AtomicBooleanDeserializer();\n+\n         public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n         \n         @Override\n     public static class StackTraceElementDeserializer\n         extends StdScalarDeserializer<StackTraceElement>\n     {\n+        public final static StackTraceElementDeserializer instance = new StackTraceElementDeserializer();\n+\n         public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n     \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.HashSet;\n \n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n+\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n  */\n public class NumberDeserializers\n {\n+    private final static HashSet<String> _classNames = new HashSet<String>();\n+    static {\n+        Class<?>[] numberTypes = new Class<?>[] {\n+            Boolean.class, Boolean.TYPE,\n+            Byte.class, Byte.TYPE,\n+            Short.class, Short.TYPE,\n+            Character.class, Character.TYPE,\n+            Integer.class, Integer.TYPE,\n+            Long.class, Long.TYPE,\n+            Float.class, Float.TYPE,\n+            Double.class, Double.TYPE,\n+            // and more generic ones\n+            Number.class, BigDecimal.class, BigInteger.class\n+        };\n+        for (Class<?> cls : numberTypes) {\n+            _classNames.add(cls.getName());\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Since 2.2 -- use {@link #find} instead.\n+     */\n+    @Deprecated\n     public static StdDeserializer<?>[] all()\n     {\n         return new StdDeserializer<?>[] {\n         };\n     }\n     \n+    public static JsonDeserializer<?> find(Class<?> rawType)\n+    {\n+        if (!_classNames.contains(rawType.getName())) {\n+            return null;\n+        }\n+        // Start with most common types; int, boolean, long, double\n+        if (rawType == Integer.TYPE) {\n+            return IntegerDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Integer.class) {\n+            return IntegerDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Boolean.TYPE) {\n+            return BooleanDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Boolean.class) {\n+            return BooleanDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Long.TYPE) {\n+            return LongDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Long.class) {\n+            return LongDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Double.TYPE) {\n+            return DoubleDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Double.class) {\n+            return DoubleDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Character.TYPE) {\n+            return CharacterDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Character.class) {\n+            return CharacterDeserializer.wrapperInstance;\n+        }\n+\n+        if (rawType == Byte.TYPE) {\n+            return ByteDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Byte.class) {\n+            return ByteDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Short.TYPE) {\n+            return ShortDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Short.class) {\n+            return ShortDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Float.TYPE) {\n+            return FloatDeserializer.primitiveInstance;\n+        }\n+        if (rawType == Float.class) {\n+            return FloatDeserializer.wrapperInstance;\n+        }\n+        if (rawType == Number.class) {\n+            return NumberDeserializer.instance;\n+        }\n+        if (rawType == BigDecimal.class) {\n+            return BigDecimalDeserializer.instance;\n+        }\n+        if (rawType == BigInteger.class) {\n+            return BigIntegerDeserializer.instance;\n+        }\n+        // should never occur\n+        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Then one intermediate base class for things that have\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n+        private final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n+        \n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n+        private final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n+        \n         public ByteDeserializer(Class<Byte> cls, Byte nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n+        private final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n+        \n         public ShortDeserializer(Class<Short> cls, Short nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n+        private final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n+        \n         public CharacterDeserializer(Class<Character> cls, Character nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n+        private final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n+        \n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n+        private final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n+        \n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n+        private final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n+        \n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n             super(cls, nvl);\n     {\n         private static final long serialVersionUID = 1L;\n \n+        private final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n+        private final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n+        \n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n             super(cls, nvl);\n     public final static class NumberDeserializer\n         extends StdScalarDeserializer<Number>\n     {\n+        public final static NumberDeserializer instance = new NumberDeserializer();\n+        \n         public NumberDeserializer() { super(Number.class); }\n \n         @Override\n     public static class BigIntegerDeserializer\n         extends StdScalarDeserializer<BigInteger>\n     {\n+        public final static BigIntegerDeserializer instance = new BigIntegerDeserializer();\n+\n         public BigIntegerDeserializer() { super(BigInteger.class); }\n \n         @SuppressWarnings(\"incomplete-switch\")\n     public static class BigDecimalDeserializer\n         extends StdScalarDeserializer<BigDecimal>\n     {\n+        public final static BigDecimalDeserializer instance = new BigDecimalDeserializer();\n+ \n         public BigDecimalDeserializer() { super(BigDecimal.class); }\n \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    /**\n+     * @since 2.2\n+     */\n+    public final static StringDeserializer instance = new StringDeserializer();\n+    \n     public StringDeserializer() { super(String.class); }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n     private static final long serialVersionUID = 1L;\n \n     private final static Object[] NO_OBJECTS = new Object[0];\n+\n+    /**\n+     * @since 2.2\n+     */\n+    public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer();\n     \n     public UntypedObjectDeserializer() { super(Object.class); }\n ", "timestamp": 1361334173, "metainfo": ""}