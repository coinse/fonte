{"sha": "b2a9ca7bb27c21b12ccd8d17314e83275381027c", "log": "Javadoc cleanup, removing pre-2.0 @since annotations", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n      *<p>\n      * Default implementation just throws\n      * {@link UnsupportedOperationException}, to indicate that types\n-     * that do not explicitly add support do not expect to get the call.\n+     * that do not explicitly add support do not necessarily support\n+     * update-existing-value operation (esp. immutable types)\n      */\n     public T deserialize(JsonParser jp, DeserializationContext ctxt,\n                          T intoValue)\n      * \n      * @param typeDeserializer Deserializer to use for handling type information\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n         // We could try calling \n-        return (T) typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n          *   field names are (usually) interned too, hence lookups will be faster.\n          */\n         // 23-Oct-2009, tatu: should this be disabled wrt [JACKSON-180]?\n+        /*   Probably need not, given that namespace of field/method names\n+         *   is not unbounded, unlike potential JSON names.\n+         */\n         if (propName == null || propName.length() == 0) {\n             _propName = \"\";\n         } else {\n         }\n         throw new JsonMappingException(th.getMessage(), null, th);\n     }\n-    \n+\n     @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n-\n+    \n     /*\n     /**********************************************************\n     /* Implementation classes\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n /**\n  * Provider for deserializers that handle some basic data types\n  * for <a href=\"http://joda-time.sourceforge.net/\">Joda</a> date/time library.\n- *\n- * @since 1.4\n  */\n public class JodaDeserializers\n     implements Provider<StdDeserializer<?>>\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public static class LocalDateDeserializer\n         extends JodaDeserializer<LocalDate>\n     {\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public static class LocalDateTimeDeserializer\n         extends JodaDeserializer<LocalDateTime>\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n     /**\n      * Fluent factory method that will construct a new instance that uses specified\n      * instance annotations instead of currently configured ones.\n-     * \n-     * @since 1.9\n      */\n     public abstract Annotated withAnnotations(AnnotationMap fallback);\n \n     /**\n      * Fluent factory method that will construct a new instance that uses\n      * annotations from specified {@link Annotated} as fallback annotations\n-     * \n-     * @since 1.9\n      */\n     public final Annotated withFallBackAnnotationsFrom(Annotated annotated) {\n         return withAnnotations(AnnotationMap.merge(getAllAnnotations(), annotated.getAllAnnotations()));\n     /**\n      * Full generic type of the annotated element; definition\n      * of what exactly this means depends on sub-class.\n-     * \n-     * @since 1.5\n      */\n     public abstract Type getGenericType();\n \n     /**\n      * \"Raw\" type (type-erased class) of the annotated element; definition\n      * of what exactly this means depends on sub-class.\n-     * \n-     * @since 1.5\n      */\n     public abstract Class<?> getRawType();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n      * This is implemented for fiedlds and single-argument\n      * methods; but not for constructor parameters or\n      * other types of methods.\n-     * \n-     * @since 1.9\n      */\n     public abstract void setValue(Object pojo, Object value)\n         throws UnsupportedOperationException, IllegalArgumentException;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n {\n     /**\n      * Member (method, constructor) that this parameter belongs to\n-     * \n-     * @since 1.7\n      */\n     protected final AnnotatedWithParams _owner;\n     \n     \n     /**\n      * Index of the parameter within argument list\n-     * \n-     * @since 1.9\n      */\n     protected final int _index;\n     \n      * has this parameter as member of its argument list.\n      * \n      * @return Owner (member or creator) object of this parameter\n-     * \n-     * @since 1.9\n      */\n     public AnnotatedWithParams getOwner() { return _owner; }\n     \n      * Accessor for index of this parameter within argument list\n      * \n      * @return Index of this parameter within argument list\n-     * \n-     * @since 1.9\n      */\n     public int getIndex() { return _index; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n  * form for inclusion mechanism {@link As#PROPERTY}\n  * is slighty different if value is not expressed as JSON Object:\n  * and as such both type deserializer and serializer need to\n- * JSON Object form (array, object or other (== scalar)) being\n- * used.\n- * \n- * @since 1.5\n- * @author tatus\n+ * JSON Object form (array, object or other (== scalar)) being used.\n  */\n public abstract class TypeDeserializer\n {\n      * class to use in cases where type id is not\n      * accessible for some reason (either missing, or can not be\n      * resolved)\n-     * \n-     * @since 1.9\n      */\n     public abstract Class<?> getDefaultImpl();\n     \n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromObject(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromArray(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromScalar(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * using JSON node representation, or \"untyped\" Java object\n      * (which may be Map, Collection, wrapper/primitive etc).\n      */\n-    public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromAny(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n      * Alternative version of the prefix-for-scalar method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n             Class<?> type)\n      * Alternative version of the prefix-for-object method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n             Class<?> type)\n      * Alternative version of the prefix-for-array method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n             Class<?> type)\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n  * to basically transform external type id into structure that looks more like\n  * \"wrapper-array\" style inclusion. This intermediate form is chosen to allow\n  * supporting all possible JSON structures.\n- * \n- * @since 1.9\n  */\n public class AsExternalTypeDeserializer extends AsArrayTypeDeserializer\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n             if (_typePropertyName.equals(name)) { // gotcha!\n                 String typeId = jp.getText();\n                 JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n-                // deserializer should take care of closing END_OBJECT as well\n-               if (tb != null) {\n+               if (tb != null) { // need to put back skipped properties?\n                     jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n                 }\n                 /* Must point to the next value; tb had no current, jp\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n \n /**\n- * @author tatus\n+ * Base class for all standard Jackson {@link TypeDeserializer}s.\n  */\n public abstract class TypeDeserializerBase extends TypeDeserializer\n {\n     /**\n      * Type to use as the default implementation, if type id is\n      * missing or can not be resolved.\n-     * \n-     * @since 1.9\n      */\n     protected final JavaType _defaultImpl;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * Node class that represents Arrays mapped from Json content.\n      * @param other Array to add contents from\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode addAll(ArrayNode other)\n     {\n      * @param nodes Nodes to add\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode addAll(Collection<JsonNode> nodes)\n     {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Boolean value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Boolean value) {\n         if (value == null) {\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.6\n-     */\n     protected void addContentsTo(List<JsonNode> dst)\n     {\n         if (_children != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Byte value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Short value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.shortValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     public NumericNode numberNode(long v) { return LongNode.valueOf(v); }\n \n     /**\n-     * Alternate factory method that will handle wrapper value, which may\n-     * be null.\n-     * Due to possibility of null, returning type is not guaranteed to be\n-     * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n+     * Alternate factory method that will handle wrapper value, which may be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n      */\n     public ValueNode numberNode(Long value) {\n         return (value == null) ? nullNode() : LongNode.valueOf(value.longValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Float value) {\n         return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Double value) {\n         return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * @param fieldNames Names of fields to remove\n      * \n      * @return This ObjectNode after removing entries\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode remove(Collection<String> fieldNames)\n     {\n      * @param properties Properties to add\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode putAll(Map<String,JsonNode> properties)\n     {\n      * @param other Object of which properties to add to this object\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode putAll(ObjectNode other)\n     {\n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n      * @return This ObjectNode (to allow call chaining)\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode retain(Collection<String> fieldNames)\n     {\n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n      * @return This ObjectNode (to allow call chaining)\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode retain(String... fieldNames) {\n         return retain(Arrays.asList(fieldNames));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Boolean value) {\n         if (value == null) {\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.6\n-     */\n     protected void putContentsTo(Map<String,JsonNode> dst)\n     {\n         if (_children != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n      * @param baseType Declared type to use as the base type for type information serializer\n      * \n      * @return Type serializer to use for property values, if one is needed; null if not.\n-     * \n-     * @since 1.5\n      */\n     public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config,\n             AnnotatedMember accessor, BeanProperty property)\n      * @param containerType Declared type of the container to use as the base type for type information serializer\n      * \n      * @return Type serializer to use for property value contents, if one is needed; null if not.\n-     * \n-     * @since 1.5\n      */    \n     public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config,\n             AnnotatedMember accessor, BeanProperty property)\n \n     /**\n      * Method called to construct serializer for serializing specified bean type.\n-     * \n-     * @since 1.6\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonSerializer<Object> constructBeanSerializer(SerializationConfig config,\n     }\n \n     /**\n-     * Helper method that will remove all properties that do not have a\n-     * mutator.\n-     * \n-     * @since 1.9\n+     * Helper method that will remove all properties that do not have a mutator.\n      */\n     protected void removeSetterlessGetters(SerializationConfig config, BasicBeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n      * Basic {@link Serializers} implementation that implements all methods but provides\n      * no serializers. Its main purpose is to serve as a base class so that\n      * sub-classes only need to override methods they need.\n-     * \n-     * @since 1.9\n      */\n     public static class Base implements Serializers\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n  * this implementation is optimized for efficiency.\n  * Instances are immutable; new instances are created with factory methods: this\n  * is important to ensure correct multi-threaded access.\n- * \n- * @since 1.7\n  */\n public abstract class PropertySerializerMap\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n  * Optimized lookup table for accessing two types of serializers; typed\n  * and non-typed. Only accessed from a single thread, so no synchronization\n  * needed for accessors.\n- * \n- * @since 1.7\n  */\n public final class ReadOnlyClassToSerializerMap\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.4\n-     */\n     public synchronized int size() {\n         return _sharedMap.size();\n     }\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n     {\n         synchronized (this) {\n         }\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,\n             SerializerProvider provider)\n         throws JsonMappingException\n         }\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser,\n             SerializerProvider provider)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n  * to determine whether to serialize property as is, or to filter it out.\n- * \n- * @since 1.7\n  */\n public abstract class SimpleBeanPropertyFilter implements BeanPropertyFilter\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n      * result an exception (default) or not.\n      * Note that this is only relevant if no default filter has been\n      * configured.\n-     * \n-     * @since 1.9\n      */\n     protected boolean _cfgFailOnUnknownId = true;\n     \n         return this;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public BeanPropertyFilter getDefaultFilter() {\n         return _defaultFilter;\n     }\n     \n-    /**\n-     * @since 1.9\n-     */\n     public SimpleFilterProvider setFailOnUnknownId(boolean state) {\n         _cfgFailOnUnknownId = state;\n         return this;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public boolean willFailOnUnknownId() {\n         return _cfgFailOnUnknownId;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n /**\n  * Simple serializer for {@link java.net.InetAddress}. Main complexity is\n  * with registration, since same serializer is to be used for sub-classes.\n- *\n- * @since 1.8\n  */\n public class InetAddressSerializer\n     extends ScalarSerializerBase<InetAddress>\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n- * This is a simple dummy serializer that will just output raw values by calling toString()\n- * on value to serialize.\n- * \n- * @since 1.7\n+ * This is a simple dummy serializer that will just output raw values by calling\n+ * toString() on value to serialize.\n  */\n @JacksonStdImpl\n public class RawSerializer<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n      * \"real\" Collection type; meaning whether it represents a parameterized\n      * subtype of {@link java.util.Collection} or just something that acts\n      * like one.\n-     * \n-     * @since 1.8\n      */\n     public boolean isTrueCollectionType() {\n         return Collection.class.isAssignableFrom(_class);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/HierarchicType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/HierarchicType.java\n  * specific relationship between one subtype and one supertype. This is needed\n  * for resolving type parameters. Instances are doubly-linked so that chain\n  * can be traversed in both directions\n- * \n- * @since 1.6\n  */\n public class HierarchicType\n {\n     /**\n      * Method that can be used to create a deep clone of this hierarchic type, including\n      * super types (but not subtypes)\n-     * \n-     * @since 1.9\n      */\n     public HierarchicType deepCloneWithoutSubtype()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public JavaType widenKey(Class<?> keySubclass)\n     {\n         // Can do a quick check first:\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.7:\n     @Override\n     public MapLikeType withTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h);\n     }\n \n-    // Since 1.7:\n     @Override\n     public MapLikeType withContentTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapLikeType withValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapLikeType withContentValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.9\n-     */\n     public MapLikeType withKeyTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public MapLikeType withKeyValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,\n                 _valueHandler, _typeHandler);\n      * \"real\" Collection type; meaning whether it represents a parameterized\n      * subtype of {@link java.util.Collection} or just something that acts\n      * like one.\n-     * \n-     * @since 1.8\n      */\n     public boolean isTrueMapType() {\n         return Map.class.isAssignableFrom(_class);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     @Override\n     public JavaType widenKey(Class<?> keySubclass)\n     {\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.7:\n     @Override\n     public MapType withTypeHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType, _valueHandler, h);\n     }\n \n-    // Since 1.7:\n     @Override\n     public MapType withContentTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.9:\n     @Override\n     public MapType withValueHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType, h, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapType withContentValueHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType.withValueHandler(h),\n     /**********************************************************\n      */\n     \n-    /**\n-     * @since 1.9\n-     */\n     @Override\n     public MapType withKeyTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     @Override\n     public MapType withKeyValueHandler(Object h) {\n         return new MapType(_class, _keyType.withValueHandler(h), _valueType,\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n \n /**\n  * Helper class used for resolving type parameters for given class\n- * \n- * @since 1.5\n  */\n public class TypeBindings\n {\n      * Sometimes it is necessary to allow hierarchic resolution of types: specifically\n      * in cases where there are local bindings (for methods, constructors). If so,\n      * we'll just use simple delegation model.\n-     * \n-     * @since 1.7\n      */\n     private final TypeBindings _parentBindings;\n \n      * allow delegation from explicitly defined local overrides\n      * (local type variables for methods, constructors) to\n      * contextual (class-defined) ones.\n-     * \n-     * @since 1.7\n      */\n     public TypeBindings childInstance() {\n         return new TypeBindings(_typeFactory, this, _contextClass, _contextType);\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type)\n     {\n         _typeFactory = tf;\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.8\n-     */\n-    /*\n-    public TypeFactory getTypeFactory() {\n-        return _typeFactory;\n-    }\n-    */\n-    \n     public int getBindingCount() {\n         if (_bindings == null) {\n             _resolve();\n         if (_placeholders != null && _placeholders.contains(name)) {\n             return UNBOUND;\n         }\n-        // New with 1.7: check parent context\n         if (_parentBindings != null) {\n             return _parentBindings.findType(name);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n     }\n     \n     /**\n-     * Helper method for exposing contents of arrays using a read-only\n-     * iterator\n-     * \n-     * @since 1.7\n+     * Helper method for exposing contents of arrays using a read-only iterator\n      */\n     public static <T> Iterator<T> arrayAsIterator(T[] array)\n     {\n     /**\n      * Iterator implementation used to efficiently expose contents of an\n      * Array as read-only iterator.\n-     * \n-     * @since 1.7\n      */\n     private final static class ArrayIterator<T>\n         implements Iterator<T>, Iterable<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n /**\n  * Helper class that contains functionality needed by both serialization\n  * and deserialization side.\n- *\n- * @since 1.9\n  */\n public class BeanUtil\n {\n-    /*\n-     * Helper method to use for sorting bean properties, based on\n-     * ordering rules indicated by annotations, config features.\n-     * \n-     * @param config Serialization/Deserialization configuration in effect\n-     * @param beanDesc Bean description\n-     * @param props Properties to sort if/as necessary\n-     * @param defaultSortByAlpha Whether properties should be (re)sorted alphabetically\n-     *   by default (unless overridden by type)\n-     */\n-    /*\n-    public static <T extends Named> List<T> sortProperties(MapperConfig<?> config,\n-            BasicBeanDescription beanDesc, List<T> props,\n-            boolean defaultSortByAlpha)\n-    {\n-        // First, order by [JACKSON-90] (explicit ordering and/or alphabetic)\n-        // and then for [JACKSON-170] (implicitly order creator properties before others)\n-        List<String> creatorProps = beanDesc.findCreatorPropertyNames();\n-        // Then how about explicit ordering?\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        AnnotatedClass ac = beanDesc.getClassInfo();\n-        String[] propertyOrder = intr.findSerializationPropertyOrder(ac);\n-        Boolean alpha = intr.findSerializationSortAlphabetically(ac);\n-        boolean sort;\n-        \n-        if (alpha == null) {\n-            sort = defaultSortByAlpha;\n-        } else {\n-            sort = alpha.booleanValue();\n-        }\n-        // no sorting? no need to shuffle, then\n-        if (!sort && creatorProps.isEmpty() && propertyOrder == null) {\n-            return props;\n-        }\n-        int size = props.size();\n-        Map<String,T> all;\n-        // Need to (re)sort alphabetically?\n-        if (sort) {\n-            all = new TreeMap<String,T>();\n-        } else {\n-            all = new LinkedHashMap<String,T>(size+size);\n-        }\n-\n-        for (T w : props) {\n-            all.put(w.getName(), w);\n-        }\n-        Map<String,T> ordered = new LinkedHashMap<String,T>(size+size);\n-        // Ok: primarily by explicit order\n-        if (propertyOrder != null) {\n-            for (String name : propertyOrder) {\n-                T w = all.get(name);\n-                if (w != null) {\n-                    ordered.put(name, w);\n-                }\n-            }\n-        }\n-        // And secondly by sorting Creator properties before other unordered properties\n-        for (String name : creatorProps) {\n-            T w = all.get(name);\n-            if (w != null) {\n-                ordered.put(name, w);\n-            }\n-        }\n-        // And finally whatever is left (trying to put again will not change ordering)\n-        ordered.putAll(all);\n-        return new ArrayList<T>(ordered.values());\n-    }\n-    */\n-\n     /*\n     /**********************************************************\n     /* Handling \"getter\" names\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Comparators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Comparators.java\n \n /**\n  * Helper class for constructing objects for comparing content values\n- * \n- * @since 1.9.0\n  */\n public class Comparators\n {\n      *<p>\n      * Note: current implementation is not optimized for speed; if performance\n      * ever becomes an issue, it is possible to construct much more efficient\n-     * typed instances (one for Object[] and sub-types; one per primitive type)\n-     * \n-     * @since 1.9\n+     * typed instances (one for Object[] and sub-types; one per primitive type).\n      */\n     public static Object getArrayComparator(final Object defaultValue)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Named.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Named.java\n package com.fasterxml.jackson.databind.util;\n \n /**\n- * Simple tag interface mostly to allow sorting by name\n- *\n- * @since 1.9\n+ * Simple tag interface mostly to allow sorting by name.\n  */\n public interface Named {\n     public String getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ObjectBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ObjectBuffer.java\n         return result;\n     }\n \n-    /**\n-     * Another\n-     * \n-     * @since 1.6\n-     */\n     public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList)\n     {\n         for (Node n = _bufferHead; n != null; n = n.next()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n \n     /**\n      * ISO-8601 with just the Date part, no time\n-     *\n-     * @since 1.3.1\n      */\n     protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n ", "timestamp": 1327119381, "metainfo": ""}