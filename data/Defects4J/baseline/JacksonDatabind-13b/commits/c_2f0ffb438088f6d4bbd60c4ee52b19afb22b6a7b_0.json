{"sha": "2f0ffb438088f6d4bbd60c4ee52b19afb22b6a7b", "log": "Remote separate TimeZone deserializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n             java.sql.Date.class,\n             java.util.Date.class,\n             Timestamp.class,\n-            TimeZone.class\n         };\n         for (Class<?> cls : numberTypes) {\n             _classNames.add(cls.getName());\n         }\n         if (rawType == Timestamp.class) {\n             return TimestampDeserializer.instance;\n-        }\n-        if (rawType == TimeZone.class) {\n-            return TimeZoneDeserializer.instance;\n         }\n         if (rawType == GregorianCalendar.class) {\n             return CalendarDeserializer.gregorianInstance;\n             return new Timestamp(_parseDate(jp, ctxt).getTime());\n         }\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Deserializer implementations for Date-related types\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * As per [JACKSON-522], also need special handling for TimeZones\n-     */\n-    protected static class TimeZoneDeserializer\n-        extends FromStringDeserializer<TimeZone>\n-    {\n-        public final static TimeZoneDeserializer instance = new TimeZoneDeserializer();\n-\n-        public TimeZoneDeserializer() { super(TimeZone.class); }\n-\n-        @Override\n-        protected TimeZone _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return TimeZone.getTimeZone(value);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n import java.nio.charset.Charset;\n import java.util.Currency;\n import java.util.Locale;\n+import java.util.TimeZone;\n import java.util.regex.Pattern;\n \n import com.fasterxml.jackson.core.*;\n             Pattern.class,\n             Locale.class,\n             Charset.class,\n+            TimeZone.class,\n             InetAddress.class,\n             InetSocketAddress.class,\n         };\n             kind = Std.STD_LOCALE;\n         } else if (rawType == Charset.class) {\n             kind = Std.STD_CHARSET;\n+        } else if (rawType == TimeZone.class) {\n+            kind = Std.STD_TIME_ZONE;\n         } else if (rawType == InetAddress.class) {\n             kind = Std.STD_INET_ADDRESS;\n         } else if (rawType == InetSocketAddress.class) {\n         public final static int STD_PATTERN = 7;\n         public final static int STD_LOCALE = 8;\n         public final static int STD_CHARSET = 9;\n-        public final static int STD_INET_ADDRESS = 10;\n-        public final static int STD_INET_SOCKET_ADDRESS = 11;\n-        \n+        public final static int STD_TIME_ZONE = 10;\n+        public final static int STD_INET_ADDRESS = 11;\n+        public final static int STD_INET_SOCKET_ADDRESS = 12;\n+\n         protected final int _kind;\n         \n         protected Std(Class<?> valueType, int kind) {\n                 }\n             case STD_CHARSET:\n                 return Charset.forName(value);\n+            case STD_TIME_ZONE:\n+                return TimeZone.getTimeZone(value);\n             case STD_INET_ADDRESS:\n                 return InetAddress.getByName(value);\n             case STD_INET_SOCKET_ADDRESS:", "timestamp": 1388623218, "metainfo": ""}