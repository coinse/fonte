{"sha": "a4f093fce7fc561c866de52801bade505ffe9e76", "log": "Fixing #406", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n  * for converting between java types and type id included in JSON content.\n  * In simplest cases this can be a simple class with static mapping between\n  * type names and matching classes.\n+ *<p>\n+ * NOTE: since 2.4, applicable to properties as well (should have been long time\n+ *  ago, but problem only found then)\n  */\n-@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @JacksonAnnotation\n public @interface JsonTypeIdResolver\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n  * used for handling serialization and deserialization of type information,\n  * needed for handling of polymorphic types (or sometimes just for linking\n  * abstract types to concrete types)\n+ *<p>\n+ * NOTE: since 2.4, applicable to properties as well (should have been long time\n+ *  ago, but problem only found then)\n  */\n-@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonTypeResolver\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n         public CustomBeanImpl(int x) { this.x = x; }\n     }\n \n-    static class CustomBeanWrapper {\n-//        @JsonTypeInfo(use=Id.NONE, include=As.EXTERNAL_PROPERTY, property=\"type\")\n-        @JsonTypeInfo(use=Id.CUSTOM, include=As.PROPERTY, property=\"type\")\n-        public CustomBean value;\n+    static class ExtBeanWrapper {\n+        @JsonTypeInfo(use=Id.CUSTOM, include=As.EXTERNAL_PROPERTY, property=\"type\")\n+        @JsonTypeIdResolver(ExtResolver.class)\n+        public ExtBean value;\n     }\n-    \n-    static class CustomResolver implements TypeIdResolver\n-    {\n+\n+    static class CustomResolver extends CustomResolverBase {\n+        // yes, static: just for test purposes, not real use\n         static List<JavaType> initTypes;\n \n-        public CustomResolver() { }\n-\n-        @Override\n-        public Id getMechanism() {\n-            return Id.CUSTOM;\n+        public CustomResolver() {\n+            super(CustomBean.class, CustomBeanImpl.class);\n         }\n \n         @Override\n-        public String idFromValue(Object value)\n-        {\n-            if (value instanceof CustomBean) {\n+        public void init(JavaType baseType) {\n+            if (initTypes != null) {\n+                initTypes.add(baseType);\n+            }\n+        }\n+    }\n+    \n+    static abstract class ExtBean { }\n+\n+    static class ExtBeanImpl extends ExtBean {\n+        public int y;\n+        \n+        public ExtBeanImpl() { }\n+        public ExtBeanImpl(int y) { this.y = y; }\n+    }\n+    \n+    static class ExtResolver extends CustomResolverBase {\n+        public ExtResolver() {\n+            super(ExtBean.class, ExtBeanImpl.class);\n+        }\n+    }\n+\n+    static class CustomResolverBase implements TypeIdResolver\n+    {\n+        protected final Class<?> superType;\n+        protected final Class<?> subType;\n+\n+        public CustomResolverBase(Class<?> baseType, Class<?> implType) {\n+            superType = baseType;\n+            subType = implType;\n+        }\n+\n+        @Override public Id getMechanism() { return Id.CUSTOM; }\n+\n+        @Override public String idFromValue(Object value) {\n+            if (superType.isAssignableFrom(value.getClass())) {\n                 return \"*\";\n             }\n             return \"unknown\";\n         }\n \n         @Override\n-        public void init(JavaType baseType) {\n-            if (initTypes != null) {\n-                initTypes.add(baseType);\n-            }\n-        }\n+        public void init(JavaType baseType) { }\n \n         @Override\n         public JavaType typeFromId(String id)\n         {\n             if (\"*\".equals(id)) {\n-                return TypeFactory.defaultInstance().constructType(CustomBeanImpl.class);\n+                return TypeFactory.defaultInstance().constructType(subType);\n             }\n             return null;\n         }\n \n     public void testCustomWithExternal() throws Exception\n     {\n-        CustomBeanWrapper w = new CustomBeanWrapper();\n-        w.value = new CustomBeanImpl(12);\n+        ExtBeanWrapper w = new ExtBeanWrapper();\n+        w.value = new ExtBeanImpl(12);\n \n         String json = MAPPER.writeValueAsString(w);\n \n-System.out.println(\"JSON = \"+json);\n-        \n-        CustomBeanWrapper out = MAPPER.readValue(json, CustomBeanWrapper.class);\n+        ExtBeanWrapper out = MAPPER.readValue(json, ExtBeanWrapper.class);\n         assertNotNull(out);\n         \n-        assertEquals(12, ((CustomBeanImpl) out.value).x);\n+        assertEquals(12, ((ExtBeanImpl) out.value).y);\n     }\n }", "timestamp": 1392412203, "metainfo": ""}