{"sha": "09e5f52bd407a132386b42dc042d8be5b79eeba6", "log": "trying to simplify default handling of \"untyped\" deserialization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n-    private final static Object[] NO_OBJECTS = new Object[0];\n+    protected final static Object[] NO_OBJECTS = new Object[0];\n \n     /**\n      * @deprecated Since 2.3, construct a new instance, needs to be resolved\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n+        // 20-Apr-2014, tatu: If nothing custom, let's use \"vanilla\" instance,\n+        //     simpler and can avoid some of delegation\n+        if ((_stringDeserializer == null) && (_numberDeserializer == null)\n+                && (_mapDeserializer == null) && (_listDeserializer == null)\n+                &&  getClass() == UntypedObjectDeserializer.class) {\n+            return Vanilla.std;\n+        }\n         JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n         if (mapDeserializer instanceof ContextualDeserializer) {\n             mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n         return new UntypedObjectDeserializer(this,\n                 mapDeser, listDeser, stringDeser, numberDeser);\n     }\n-        \n+\n     /*\n     /**********************************************************\n     /* Deserializer API\n         } while (jp.nextToken() != JsonToken.END_ARRAY);\n         return buffer.completeAndClearBuffer(values, ptr);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Separate \"vanilla\" implementation for common case of\n+    /* no custom deserializer overrides\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public static class Vanilla\n+        extends StdDeserializer<Object>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static Vanilla std = new Vanilla();\n+\n+        public Vanilla() { super(Object.class); }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            switch (jp.getCurrentTokenId()) {\n+            case JsonTokenId.ID_START_OBJECT:\n+                {\n+                    JsonToken t = jp.nextToken();\n+                    if (t  == JsonToken.END_OBJECT) {\n+                        return new LinkedHashMap<String,Object>(2);\n+                    }\n+                }\n+            case JsonTokenId.ID_FIELD_NAME:\n+                return mapObject(jp, ctxt);\n+            case JsonTokenId.ID_START_ARRAY:\n+                {\n+                    JsonToken t = jp.nextToken();\n+                    if (t == JsonToken.END_ARRAY) { // and empty one too\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                            return NO_OBJECTS;\n+                        }\n+                        return new ArrayList<Object>(2);\n+                    }\n+                }\n+                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                    return mapArrayToArray(jp, ctxt);\n+                }\n+                return mapArray(jp, ctxt);\n+            case JsonTokenId.ID_EMBEDDED_OBJECT:\n+                return jp.getEmbeddedObject();\n+            case JsonTokenId.ID_STRING:\n+                return jp.getText();\n+\n+            case JsonTokenId.ID_NUMBER_INT:\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    return jp.getBigIntegerValue(); // should be optimal, whatever it is\n+                }\n+                return jp.getNumberValue(); // should be optimal, whatever it is\n+\n+            case JsonTokenId.ID_NUMBER_FLOAT:\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    return jp.getDecimalValue();\n+                }\n+                return Double.valueOf(jp.getDoubleValue());\n+\n+            case JsonTokenId.ID_TRUE:\n+                return Boolean.TRUE;\n+            case JsonTokenId.ID_FALSE:\n+                return Boolean.FALSE;\n+\n+            case JsonTokenId.ID_NULL: // should not get this but...\n+                return null;\n+\n+            //case JsonTokenId.ID_END_ARRAY: // invalid\n+            //case JsonTokenId.ID_END_OBJECT: // invalid\n+            default:\n+                throw ctxt.mappingException(Object.class);\n+            }\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n+        {\n+            switch (jp.getCurrentTokenId()) {\n+            case JsonTokenId.ID_START_ARRAY:\n+            case JsonTokenId.ID_START_OBJECT:\n+            case JsonTokenId.ID_FIELD_NAME:\n+                return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+\n+            case JsonTokenId.ID_STRING:\n+                return jp.getText();\n+\n+            case JsonTokenId.ID_NUMBER_INT:\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    return jp.getBigIntegerValue();\n+                }\n+                return jp.getNumberValue();\n+\n+            case JsonTokenId.ID_NUMBER_FLOAT:\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    return jp.getDecimalValue();\n+                }\n+                return Double.valueOf(jp.getDoubleValue());\n+\n+            case JsonTokenId.ID_TRUE:\n+                return Boolean.TRUE;\n+            case JsonTokenId.ID_FALSE:\n+                return Boolean.FALSE;\n+            case JsonTokenId.ID_EMBEDDED_OBJECT:\n+                return jp.getEmbeddedObject();\n+\n+            case JsonTokenId.ID_NULL: // should not get this far really but...\n+                return null;\n+            default:\n+                throw ctxt.mappingException(Object.class);\n+            }\n+        }\n+\n+        protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            Object value = deserialize(jp, ctxt);\n+            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n+                ArrayList<Object> l = new ArrayList<Object>(2);\n+                l.add(value);\n+                return l;\n+            }\n+            Object value2 = deserialize(jp, ctxt);\n+            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n+                ArrayList<Object> l = new ArrayList<Object>(2);\n+                l.add(value);\n+                l.add(value2);\n+                return l;\n+            }\n+            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+            Object[] values = buffer.resetAndStart();\n+            int ptr = 0;\n+            values[ptr++] = value;\n+            values[ptr++] = value2;\n+            int totalSize = ptr;\n+            do {\n+                value = deserialize(jp, ctxt);\n+                ++totalSize;\n+                if (ptr >= values.length) {\n+                    values = buffer.appendCompletedChunk(values);\n+                    ptr = 0;\n+                }\n+                values[ptr++] = value;\n+            } while (jp.nextToken() != JsonToken.END_ARRAY);\n+            // let's create full array then\n+            ArrayList<Object> result = new ArrayList<Object>(totalSize);\n+            buffer.completeAndClearBuffer(values, ptr, result);\n+            return result;\n+        }\n+\n+        /**\n+         * Method called to map a JSON Object into a Java value.\n+         */\n+        protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            // will point to FIELD_NAME at this point, guaranteed\n+            String field1 = jp.getText();\n+            jp.nextToken();\n+            Object value1 = deserialize(jp, ctxt);\n+            if (jp.nextToken() == JsonToken.END_OBJECT) { // single entry; but we want modifiable\n+                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n+                result.put(field1, value1);\n+                return result;\n+            }\n+            String field2 = jp.getText();\n+            jp.nextToken();\n+            Object value2 = deserialize(jp, ctxt);\n+            if (jp.nextToken() == JsonToken.END_OBJECT) {\n+                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n+                result.put(field1, value1);\n+                result.put(field2, value2);\n+                return result;\n+            }\n+            // And then the general case; default map size is 16\n+            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n+            result.put(field1, value1);\n+            result.put(field2, value2);\n+            do {\n+                String fieldName = jp.getText();\n+                jp.nextToken();\n+                result.put(fieldName, deserialize(jp, ctxt));\n+            } while (jp.nextToken() != JsonToken.END_OBJECT);\n+            return result;\n+        }\n+\n+        /**\n+         * Method called to map a JSON Array into a Java Object array (Object[]).\n+         */\n+        protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+            Object[] values = buffer.resetAndStart();\n+            int ptr = 0;\n+            do {\n+                Object value = deserialize(jp, ctxt);\n+                if (ptr >= values.length) {\n+                    values = buffer.appendCompletedChunk(values);\n+                    ptr = 0;\n+                }\n+                values[ptr++] = value;\n+            } while (jp.nextToken() != JsonToken.END_ARRAY);\n+            return buffer.completeAndClearBuffer(values, ptr);\n+        }\n+    }\n }\n--- a/src/test/java/perf/ManualReadPerfUntyped.java\n+++ b/src/test/java/perf/ManualReadPerfUntyped.java\n         }\n         byte[] data = readAll(args[0]);\n \n+        JsonFactory f = new JsonFactory();\n+        boolean doIntern = true;\n+\n+        f.configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, doIntern);\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, doIntern);\n+        \n         ObjectMapper m = new ObjectMapper();\n         Object input1 = m.readValue(data, Object.class);\n         JsonNode input2 = m.readTree(data);\n \n     // When comparing to simple streaming parsing, uncomment:\n \n+    @Override\n+    protected long testDeser1(int reps, String input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+\n+    @Override\n+    protected long testDeser2(int reps, String input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+    \n     /*\n+    @Override\n+    protected long testDeser1(int reps, String input, ObjectReader reader) throws Exception {\n+        long start = System.currentTimeMillis();\n+        final JsonFactory f = reader.getFactory();\n+        while (--reps >= 0) {\n+            JsonParser p = f.createParser(input);\n+            while (p.nextToken() != null) {\n+                ;\n+            }\n+            p.close();\n+        }\n+        hash = f.hashCode();\n+        return System.currentTimeMillis() - start;\n+    }\n+    \n     @Override\n     protected long testDeser2(int reps, String input, ObjectReader reader) throws Exception {\n         long start = System.currentTimeMillis();\n--- a/src/test/java/perf/ObjectReaderBase.java\n+++ b/src/test/java/perf/ObjectReaderBase.java\n         return _testDeser(reps, input, reader);\n     }\n     \n-    private final long _testDeser(int reps, byte[] input, ObjectReader reader) throws Exception\n+    protected final long _testDeser(int reps, byte[] input, ObjectReader reader) throws Exception\n     {\n         long start = System.currentTimeMillis();\n         Object result = null;\n         return _testDeser(reps, input, reader);\n     }\n     \n-    private final long _testDeser(int reps, String input, ObjectReader reader) throws Exception\n+    protected final long _testDeser(int reps, String input, ObjectReader reader) throws Exception\n     {\n         long start = System.currentTimeMillis();\n         Object result = null;", "timestamp": 1398057990, "metainfo": ""}