{"sha": "418a239a360683f065ea18fb4d1cb8d40c646c8e", "log": "Adding unit tests for verifying 'isEmpty()', custom null value serialization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         _deserializationConfig = (dconfig != null) ? dconfig :\n             new DeserializationConfig(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER,\n                     null, null, _typeFactory, null);\n-        _serializerProvider = (sp == null) ? new StdSerializerProvider() : sp;\n+        _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n         _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Versioned impl\n         _rootDeserializers.put(valueType, deser);\n         return deser;\n     }\n-    \n+\n     protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg)\n     {\n         return new StdDeserializationContext(cfg, jp, _deserializerProvider,\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n-\n \n /**\n  * Abstract class that defines API used by {@link ObjectMapper} and\n      * used to write JSON property names matching null keys for Java\n      * Maps (which will throw an exception if try write such property\n      * name)\n-     * \n-     * @since 1.8\n      */\n     public abstract void setNullKeySerializer(JsonSerializer<Object> nks);\n \n      * Method that can be used to specify serializer that will be\n      * used to write JSON values matching Java null values\n      * instead of default one (which simply writes JSON null)\n-     * \n-     * @since 1.8\n      */\n     public abstract void setNullValueSerializer(JsonSerializer<Object> nvs);\n     \n      *<p>\n      * Note that key serializer registration are different from value serializer\n      * registrations.\n-     * \n-     * @since 1.8\n      */\n     public abstract void setDefaultKeySerializer(JsonSerializer<Object> ks);\n     \n      * \n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n-     *    \n-     * @since 1.5\n      */\n     public abstract void serializeValue(SerializationConfig cfg, JsonGenerator jgen,\n             Object value, JavaType rootType, SerializerFactory jsf)\n      *<pre>\n      *   getConfig().getSerializationView();\n      *</pre>\n-     *\n-     * @since 1.4\n      */\n     public final Class<?> getSerializationView() { return _serializationView; }\n \n      *<pre>\n      *   getConfig().getFilterProvider();\n      *</pre>\n-     *\n-     * @since 1.4\n      */\n     public final FilterProvider getFilterProvider() {\n         return _config.getFilterProvider();\n     }\n \n     /**\n-     * @since 1.8\n+     * Convenience method for constructing {@link JavaType} for given JDK\n+     * type (usually {@link java.lang.Class})\n      */\n     public JavaType constructType(Type type) {\n          return _config.getTypeFactory().constructType(type);\n     }\n \n     /**\n-     * @since 1.9.1\n+     * Convenience method for constructing subtypes, retaining generic\n+     * type parameter (if any)\n      */\n     public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n         return _config.constructSpecializedType(baseType, subclass);\n     /**\n      * Similar to {@link #findValueSerializer(Class)}, but takes full generics-aware\n      * type instead of raw class.\n-     * \n-     * @since 1.5\n      */\n     public abstract JsonSerializer<Object> findValueSerializer(JavaType serializationType,\n             BeanProperty property)\n      *   runtime type, but can also be static declared type, depending on configuration\n      * \n      * @param cache Whether resulting value serializer should be cached or not; this is just\n-     *    a hint \n-     *    \n-     * @since 1.5\n+     *    a hint\n      */\n     public abstract JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n             boolean cache, BeanProperty property)\n      * \n      * @param cache Whether resulting value serializer should be cached or not; this is just\n      *    a hint \n-     *    \n-     * @since 1.5\n      */\n     public abstract JsonSerializer<Object> findTypedValueSerializer(JavaType valueType,\n             boolean cache, BeanProperty property)\n      */\n \n     /**\n+     * @since 2.0\n+     */\n+    public abstract JsonSerializer<Object> getDefaultNullKeySerializer()\n+        throws JsonMappingException;\n+\n+    /**\n+     * @since 2.0\n+     */\n+    public abstract JsonSerializer<Object> getDefaultNullValueSerializer()\n+        throws JsonMappingException;\n+    \n+    /**\n      * Method called to get the serializer to use for serializing\n      * Map keys that are nulls: this is needed since JSON does not allow\n      * any non-String value as key, including null.\n      * will either throw an exception, or use an empty String; but\n      * other behaviors are possible.\n      */\n-    public abstract JsonSerializer<Object> getNullKeySerializer();\n-\n-    /**\n-     * Method called to get the serializer to use for serializing\n-     * values (root level, Array members or List field values)\n-     * that are nulls. Specific accessor is needed because nulls\n-     * in Java do not contain type information.\n-     *<p>\n-     * Typically returned serializer just writes out Json literal\n-     * null value.\n-     */\n-    public abstract JsonSerializer<Object> getNullValueSerializer();\n+    /**\n+     * Method called to find a serializer to use for null values for given\n+     * declared type. Note that type is completely based on declared type,\n+     * since nulls in Java have no type and thus runtime type can not be\n+     * determined.\n+     * \n+     * @since 2.0\n+     */\n+    public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType,\n+            BeanProperty property)\n+        throws JsonMappingException {\n+        return getDefaultNullKeySerializer();\n+    }\n+\n+    /**\n+     * Method called to get the serializer to use for serializing null\n+     * property values.\n+     *<p>\n+     * Default implementation simply calls {@link #getDefaultNullValueSerializer()};\n+     * can be overridden to add custom null serialization for properties\n+     * of certain type or name.\n+     * \n+     * @since 2.0\n+     */\n+    public JsonSerializer<Object> findNullValueSerializer(BeanProperty property)\n+        throws JsonMappingException {\n+        return getDefaultNullValueSerializer();\n+    }\n \n     /**\n      * Method called to get the serializer to use if provider\n         throws IOException, JsonProcessingException\n     {\n         if (value == null) {\n-            getNullValueSerializer().serialize(null, jgen, this);\n+            getDefaultNullValueSerializer().serialize(null, jgen, this);\n         } else {\n             Class<?> cls = value.getClass();\n             findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);\n             /* Note: can't easily check for suppression at this point\n              * any more; caller must check it.\n              */\n-            getNullValueSerializer().serialize(null, jgen, this);\n+            getDefaultNullValueSerializer().serialize(null, jgen, this);\n         } else {\n             Class<?> cls = value.getClass();\n             findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);\n     public final void defaultSerializeNull(JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n-        getNullValueSerializer().serialize(null, jgen, this);\n+        getDefaultNullValueSerializer().serialize(null, jgen, this);\n     }\n     \n     /*\n      *<p> \n      * The main use case for this method is to allow conditional flushing of\n      * serializer cache, if certain number of entries is reached.\n-     * \n-     * @since 1.4\n      */\n     public abstract int cachedSerializersCount();\n \n      * This can be used to remove memory usage (in case some serializers are\n      * only used once or so), or to force re-construction of serializers after\n      * configuration changes for mapper than owns the provider.\n-     * \n-     * @since 1.4\n      */\n     public abstract void flushCachedSerializers();\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializerProvider.java\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n-\n \n /**\n  * Default {@link DeserializerProvider} implementation.\n public class StdDeserializerProvider\n     extends DeserializerProvider\n {\n+    \n     /*\n     /**********************************************************\n     /* Caching\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Annotations;\n \n-\n /**\n  * Base bean property handler class, which implements common parts of\n  * reflection-based functionality for accessing a property value\n  * and serializing it.\n+ *<p> \n+ * Note that current design tries to keep instances immutable (semi-functional\n+ * style); mostly because these instances are exposed to application\n+ * code and this is to reduce likelihood of data corruption and\n+ * synchronization issues.\n  */\n public class BeanPropertyWriter\n     implements BeanProperty\n {\n+    /**\n+     * Marker object used to indicate \"do not serialize if empty\"\n+     */\n+    public final static Object MARKER_FOR_EMPTY = new Object();\n+    \n     /*\n     /**********************************************************\n     /* Settings for accessing property value to serialize\n      * Serializer to use for writing out the value: null if it can not\n      * be known statically; non-null if it can.\n      */\n-    protected final JsonSerializer<Object> _serializer;\n-\n+    protected JsonSerializer<Object> _serializer;\n+\n+    /**\n+     * Serializer used for writing out null values, if any: if null,\n+     * null values are to be suppressed.\n+     */\n+    protected JsonSerializer<Object> _nullSerializer;\n+    \n     /**\n      * In case serializer is not known statically (i.e. <code>_serializer</code>\n      * is null), we will use a lookup structure for storing dynamically\n      * resolved mapping from type(s) to serializer(s).\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n-    \n-    /**\n-     * Flag to indicate that null values for this property are not\n-     * to be written out. That is, if property has value null,\n-     * no entry will be written\n+\n+    /**\n+     * Whether null values are to be suppressed (nothing written out if\n+     * value is null) or not.\n      */\n     protected final boolean _suppressNulls;\n-\n+    \n     /**\n      * Value that is considered default value of the property; used for\n      * default-value-suppression if enabled.\n      * Base type of the property, if the declared type is \"non-trivial\";\n      * meaning it is either a structured type (collection, map, array),\n      * or parameterized. Used to retain type information about contained\n-     * type, which is mostly necessary if type metadata is to be\n+     * type, which is mostly necessary if type meta-data is to be\n      * included.\n      */\n     protected JavaType _nonTrivialBaseType;\n     public BeanPropertyWriter(AnnotatedMember member, Annotations contextAnnotations,\n             String name, JavaType declaredType,\n             JsonSerializer<Object> ser, TypeSerializer typeSer, JavaType serType,\n-            Method m, Field f,\n-            boolean suppressNulls, Object suppressableValue)\n+            Method m, Field f, boolean suppressNulls, Object suppressableValue)\n     {\n         this(member, contextAnnotations, new SerializedString(name), declaredType,\n                 ser, typeSer, serType,\n         _field = f;\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n+\n+        // this will be resolved later on, unless nulls are to be suppressed\n+        _nullSerializer = null;\n     }\n \n     /**\n      */\n     protected BeanPropertyWriter(BeanPropertyWriter base)\n     {\n-        this(base, base._serializer);\n-    }\n-    \n-    /**\n-     * \"Copy constructor\" to be used by filtering sub-classes\n-     */\n-    protected BeanPropertyWriter(BeanPropertyWriter base, JsonSerializer<Object> ser)\n-    {\n-        _serializer = ser;\n-        \n         _member = base._member;\n         _contextAnnotations = base._contextAnnotations;\n         _declaredType = base._declaredType;\n         _accessorMethod = base._accessorMethod;\n         _field = base._field;\n+        _serializer = base._serializer;\n+        _nullSerializer = base._nullSerializer;\n         // one more thing: copy internal settings, if any (since 1.7)\n         if (base._internalSettings != null) {\n             _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n         _includeInViews = base._includeInViews;\n         _typeSerializer = base._typeSerializer;\n         _nonTrivialBaseType = base._nonTrivialBaseType;\n-   }\n-\n-    /**\n-     * Method that will construct and return a new writer that has\n-     * same properties as this writer, but uses specified serializer\n-     * instead of currently configured one (if any).\n-     */\n-    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n-    {\n-        // sanity check to ensure sub-classes override...\n-        if (getClass() != BeanPropertyWriter.class) {\n-            throw new IllegalStateException(\"BeanPropertyWriter sub-class does not override 'withSerializer()'; needs to!\");\n-        }\n-        return new BeanPropertyWriter(this, ser);\n-    }\n-\n+    }\n+\n+    /**\n+     * Method called to assign value serializer for property\n+     * \n+     * @since 2.0\n+     */\n+    public void assignSerializer(JsonSerializer<Object> ser)\n+    {\n+        // may need to disable check in future?\n+        if (_serializer != null && _serializer != ser) {\n+            throw new IllegalStateException(\"Can not override serializer\");\n+        }\n+        _serializer = ser;\n+    }\n+\n+    /**\n+     * Method called to assign null value serializer for property\n+     * \n+     * @since 2.0\n+     */\n+    public void assignNullSerializer(JsonSerializer<Object> nullSer)\n+    {\n+        // may need to disable check in future?\n+        if (_nullSerializer != null && _nullSerializer != nullSer) {\n+            throw new IllegalStateException(\"Can not override null serializer\");\n+        }\n+        _nullSerializer = nullSer;\n+    }\n+    \n     /**\n      * Method called create an instance that handles details of unwrapping\n      * contained value.\n     public SerializedString getSerializedName() { return _name; }\n     \n     public boolean hasSerializer() { return _serializer != null; }\n+    public boolean hasNullSerializer() { return _nullSerializer != null; }\n+\n+    public boolean willSuppressNulls() { return _suppressNulls; }\n     \n     // Needed by BeanSerializer#getSchema\n     public JsonSerializer<Object> getSerializer() {\n         Object value = get(bean);\n         // Null handling is bit different, check that first\n         if (value == null) {\n-            if (!_suppressNulls) {\n+            if (_nullSerializer != null) {\n                 jgen.writeFieldName(_name);\n-                prov.defaultSerializeNull(jgen);\n+                _nullSerializer.serialize(null, jgen, prov);\n             }\n             return;\n         }\n         if (value == bean) {\n             _reportSelfReference(bean);\n         }\n-        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n-            return;\n+        if (_suppressableValue != null) {\n+            if ((MARKER_FOR_EMPTY == _suppressableValue) || _suppressableValue.equals(value)) {\n+                return;\n+            }\n         }\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n         }\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n     protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n  * (not factory) and there is no configurability, this\n  * factory is stateless.\n  * This means that a global singleton instance can be used.\n- *<p>\n- * Notes for version 1.7 (and above): the new module registration system\n- * required addition of {@link #withConfig}, which has to\n- * be redefined by sub-classes so that they can work properly with\n- * pluggable additional serializer providing components.\n  */\n public class BeanSerializerFactory\n     extends BasicSerializerFactory\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n  *<p>\n  * Default method implementations are \"no-op\"s, meaning that methods are implemented\n  * but have no effect.\n- * \n- * @since 1.7\n  */\n public abstract class BeanSerializerModifier\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/FilteredBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/FilteredBeanPropertyWriter.java\n \n \n /**\n- * Decorated {@link BeanPropertyWriter} that will filter out\n- * properties that are not to be included in currently active\n- * JsonView.\n- *\n- * @since 1.4\n+ * Decorated {@link BeanPropertyWriter} that will filter out properties\n+ * that are not to be included in currently active JsonView.\n  */\n public abstract class FilteredBeanPropertyWriter\n {    \n             _delegate = delegate;\n             _view = view;\n         }\n-        \n+\n         @Override\n-        public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser) {\n-            return new SingleView(_delegate.withSerializer(ser), _view);\n+        public void assignSerializer(JsonSerializer<Object> ser) {\n+            _delegate.assignSerializer(ser);\n+        }\n+\n+        @Override\n+        public void assignNullSerializer(JsonSerializer<Object> nullSer) {\n+            _delegate.assignNullSerializer(nullSer);\n         }\n         \n         @Override\n         }\n         \n         @Override\n-        public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser) {\n-            return new MultiView(_delegate.withSerializer(ser), _views);\n+        public void assignSerializer(JsonSerializer<Object> ser) {\n+            _delegate.assignSerializer(ser);\n+        }\n+\n+        @Override\n+        public void assignNullSerializer(JsonSerializer<Object> nullSer) {\n+            _delegate.assignNullSerializer(nullSer);\n         }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n package com.fasterxml.jackson.databind.ser;\n \n-import java.lang.reflect.Array;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.Map;\n-\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n                 // always suppress nulls\n                 suppressNulls = true;\n                 // but possibly also 'empty' values:\n-                valueToSuppress = getEmptyValueChecker(name, declaredType);\n+                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n                 break;\n             case NON_NULL:\n                 suppressNulls = true;\n                 // fall through\n             case ALWAYS: // default\n                 // we may still want to suppress empty collections, as per [JACKSON-254]:\n-                if (declaredType.isContainerType()) {\n-                    valueToSuppress = getContainerValueChecker(name, declaredType);\n+                if (declaredType.isContainerType()\n+                        && !_config.isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS)) {\n+                    valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n                 }\n                 break;\n             }\n         }\n     }\n \n-    /**\n-     * Helper method called to see if we need a comparator Object to check if values\n-     * of a container (Collection, array) property should be suppressed.\n-     * This is usually\n-     * \n-     * @param propertyName Name of property to handle\n-     * @param propertyType Declared type of values of the property to handle\n-     * @return Object whose <code>equals()</code> method is called to check if given value\n-     *    is \"empty Collection\" value to suppress; or null if no such check should be done\n-     *    (declared type not Collection or array)\n-     * \n-     * @since 1.9\n-     */\n-    protected Object getContainerValueChecker(String propertyName, JavaType propertyType)\n-    {\n-        // currently we will only check for certain kinds of empty containers:\n-        if (!_config.isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS)) {\n-            if (propertyType.isArrayType()) {\n-                return new EmptyArrayChecker();\n-            }\n-            if (Collection.class.isAssignableFrom(propertyType.getRawClass())) {\n-                return new EmptyCollectionChecker();\n-            }\n-        }\n-        return null;\n-    }\n-\n-        \n-    /**\n-     * Helper method called to see if we need a comparator Object to check if values\n-     * of specified type are consider empty.\n-     * If type has such concept, will build a comparator; otherwise return null, and\n-     * in latter case, only null values are considered 'empty'.\n-     * \n-     * @param propertyName Name of property to handle\n-     * @param propertyType Declared type of values of the property to handle\n-     * @return Object whose <code>equals()</code> method is called to check if given value\n-     *    is \"empty Collection\" value to suppress; or null if no such check should be done\n-     *    (declared type not Collection or array)\n-     * \n-     * @since 1.9\n-     */\n-    protected Object getEmptyValueChecker(String propertyName, JavaType propertyType)\n-    {\n-        Class<?> rawType = propertyType.getRawClass();\n-        if (rawType == String.class) {\n-            return new EmptyStringChecker();\n-        }\n-        if (propertyType.isArrayType()) {\n-            return new EmptyArrayChecker();\n-        }\n-        if (Collection.class.isAssignableFrom(rawType)) {\n-            return new EmptyCollectionChecker();\n-        }\n-        if (Map.class.isAssignableFrom(rawType)) {\n-            return new EmptyMapChecker();\n-        }\n-        return null;\n-    }\n-\n     /*\n     /**********************************************************\n     /* Helper methods for exception handling\n         if (t instanceof RuntimeException) throw (RuntimeException) t;\n         throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Helper object used to check if given Collection object is null or empty\n-     * \n-     * @since 1.9\n-     */\n-    public static class EmptyCollectionChecker\n-    {\n-        @Override public boolean equals(Object other) {\n-            return (other == null) ||  ((Collection<?>) other).size() == 0;\n-        }\n-    }\n-\n-    /**\n-     * Helper object used to check if given Map object is null or empty\n-     * \n-     * @since 1.9\n-     */\n-    public static class EmptyMapChecker\n-    {\n-        @Override public boolean equals(Object other) {\n-            return (other == null) ||  ((Map<?,?>) other).size() == 0;\n-        }\n-    }\n-\n-    /**\n-     * Helper object used to check if given array object is null or empty\n-     * \n-     * @since 1.9\n-     */\n-    public static class EmptyArrayChecker\n-    {\n-        @Override\n-        public boolean equals(Object other) {\n-            return (other == null) || Array.getLength(other) == 0;\n-        }\n-     }\n-\n-    /**\n-     * Helper object used to check if given String object is null or empty\n-     * \n-     * @since 1.9\n-     */\n-    public static class EmptyStringChecker\n-    {\n-        @Override\n-        public boolean equals(Object other) {\n-            return (other == null) || ((String) other).length() == 0;\n-        }\n-     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.StdDeserializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n  * Provider is also responsible for some parts of type serialization;\n  * specifically for locating proper type serializers.\n  */\n-public class StdSerializerProvider\n+public abstract class StdSerializerProvider\n     extends SerializerProvider\n {\n     /**\n      * Overridable method, used to create a non-blueprint instances from the blueprint.\n      * This is needed to retain state during serialization.\n      */\n-    protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf)\n-    {\n-        return new StdSerializerProvider(config, this, jsf);\n-    }\n+    protected abstract StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf);\n \n     /*\n     /**********************************************************\n     }\n \n     @Override\n-    public JsonSerializer<Object> getNullKeySerializer() {\n+    public JsonSerializer<Object> getDefaultNullKeySerializer() {\n         return _nullKeySerializer;\n     }\n \n     @Override\n-    public JsonSerializer<Object> getNullValueSerializer() {\n+    public JsonSerializer<Object> getDefaultNullValueSerializer() {\n         return _nullValueSerializer;\n     }\n \n     public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n         return _unknownTypeSerializer;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Abstract method impls, convenience methods\n         boolean wrap;\n \n         if (value == null) {\n-            ser = getNullValueSerializer();\n+            // no type provided; must just use the default null serializer\n+            ser = getDefaultNullValueSerializer();\n             wrap = false; // no name to use for wrapping; can't do!\n         } else {\n             Class<?> cls = value.getClass();\n \n         JsonSerializer<Object> ser;\n         if (value == null) {\n-            ser = getNullValueSerializer();\n+            ser = getDefaultNullValueSerializer();\n             wrap = false;\n         } else {\n             // Let's ensure types are compatible at this point\n      */\n \n     /**\n+     * Standard implementation used by {@link ObjectMapper}; just implements\n+     * <code>createInstance</code> method which is abstract in\n+     * {@link StdDeserializerProvider}\n+     */\n+    public final static class Impl extends StdSerializerProvider\n+    {\n+        public Impl() { super(); }\n+        private Impl(SerializationConfig config, StdSerializerProvider src, SerializerFactory f) {\n+            super(config, src, f);\n+        }\n+\n+        @Override\n+        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n+            return new Impl(config, this, jsf);\n+        }\n+        \n+    }\n+    \n+    /**\n      * Simple serializer that will call configured type serializer, passing\n      * in configured data serializer, and exposing it all as a simple\n      * serializer.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n     public UnwrappingBeanPropertyWriter(BeanPropertyWriter base) {\n         super(base);\n     }\n-\n-    public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, JsonSerializer<Object> ser) {\n-        super(base, ser);\n-    }\n     \n-    @Override\n-    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n-    {\n-        if (getClass() != UnwrappingBeanPropertyWriter.class) {\n-            throw new IllegalStateException(\"UnwrappingBeanPropertyWriter sub-class does not override 'withSerializer()'; needs to!\");\n-        }\n-        // better try to create unwrapping instance\n-        if (!ser.isUnwrappingSerializer()) {\n-            ser = ser.unwrappingSerializer();\n-        }\n-        return new UnwrappingBeanPropertyWriter(this, ser);\n-    }\n-\n     @Override\n     public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n         throws Exception\n     {\n         Object value = get(bean);\n         if (value == null) {\n-            /* Hmmh. I assume we MUST pretty much suppress nulls, since we\n-             * can't really unwrap it...\n-             */\n+            // Hmmh. I assume we MUST pretty much suppress nulls, since we\n+            // can't really unwrap them...\n             return;\n         }\n         // For non-nulls, first: simple check for direct cycles\n         if (value == bean) {\n             _reportSelfReference(bean);\n         }\n-        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n+        if (_suppressableValue != null) {\n+            if ((MARKER_FOR_EMPTY == _suppressableValue) || _suppressableValue.equals(value)) {\n+                return;\n+            }\n             return;\n         }\n         JsonSerializer<Object> ser = _serializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n         int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length;\n         for (int i = 0, len = _props.length; i < len; ++i) {\n             BeanPropertyWriter prop = _props[i];\n+            // let's start with null serializer resolution actually\n+            if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) {\n+                JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop);\n+                if (nullSer != null) {\n+                    prop.assignNullSerializer(nullSer);\n+                    // also: remember to replace filtered property too? (see [JACKSON-364])\n+                    if (i < filteredCount) {\n+                        BeanPropertyWriter w2 = _filteredProps[i];\n+                        if (w2 != null) {\n+                            w2.assignNullSerializer(nullSer);\n+                        }\n+                    }\n+                }\n+            }\n+            \n             if (prop.hasSerializer()) {\n                 continue;\n             }\n                     }\n                 }\n             }\n-            prop = prop.withSerializer(ser);\n-            _props[i] = prop;\n+            prop.assignSerializer(ser);\n             // and maybe replace filtered property too? (see [JACKSON-364])\n             if (i < filteredCount) {\n                 BeanPropertyWriter w2 = _filteredProps[i];\n                 if (w2 != null) {\n-                    _filteredProps[i] = w2.withSerializer(ser);\n+                    w2.assignSerializer(ser);\n                 }\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n      * Key serializer to use, if it can be statically determined\n      */\n     protected JsonSerializer<Object> _keySerializer;\n-\n+    \n     /**\n      * Value serializer to use, if it can be statically determined\n      */\n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n                 // [JACKSON-314] skip entries with null values?\n                 if (skipNulls && valueElem == null) continue;\n             Object valueElem = entry.getValue();\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n                 // [JACKSON-314] also may need to skip entries with null values\n                 if (skipNulls && valueElem == null) continue;\n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n                 // [JACKSON-314] also may need to skip entries with null values\n                 if (skipNulls && valueElem == null) continue;\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonRawValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonRawValue.java\n     public void testNullStringGetter() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        String value = null;\n-        String result = m.writeValueAsString(new ClassGetter<String>(value));\n-        String expected = String.format(\"{\\\"nonRaw\\\":%d,\\\"raw\\\":%d,\\\"value\\\":%d}\", value, value, value);\n+        String result = m.writeValueAsString(new ClassGetter<String>(null));\n+        String expected = \"{\\\"nonRaw\\\":null,\\\"raw\\\":null,\\\"value\\\":null}\";\n         assertEquals(expected, result);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n     @JsonSerialize\n     static class EmptyWithAnno { }\n \n+    // for [JACKSON-695]:\n+\n+    @JsonSerialize(using=NonZeroSerializer.class, include=JsonSerialize.Inclusion.NON_EMPTY)\n+    static class NonZero {\n+        public int value;\n+        \n+        public NonZero(int i) { value = i; }\n+    }\n+\n+    static class NonZeroWrapper {\n+        public NonZero value;\n+        \n+        public NonZeroWrapper(int i) {\n+            value = new NonZero(i);\n+        }\n+    }\n+    \n+    static class NonZeroSerializer extends JsonSerializer<NonZero>\n+    {\n+        @Override\n+        public void serialize(NonZero value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+            jgen.writeNumber(value.value);\n+        }\n+\n+        @Override\n+        public boolean isEmpty(NonZero value) {\n+System.err.println(\"Empty? \"+value);            \n+            if (value == null) return true;\n+            return (value.value == 0);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    protected final ObjectMapper mapper = new ObjectMapper();\n+    \n     /**\n      * Test to check that [JACKSON-201] works if there is a recognized\n      * annotation (which indicates type is serializable)\n      */\n     public void testEmptyWithAnnotations() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // First: without annotations, should complain\n         try {\n             serializeAsString(mapper, new Empty());\n         assertEquals(\"{}\", serializeAsString(mapper, new EmptyWithAnno()));\n \n         // Including class annotation through mix-ins\n-        mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n-        assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n+        ObjectMapper m2 = new ObjectMapper();\n+        m2.getSerializationConfig().addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        assertEquals(\"{}\", m2.writeValueAsString(new Empty()));\n     }\n \n     /**\n      */\n     public void testEmptyWithFeature() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // should be enabled by default\n         assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n         mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n         assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n     }\n+\n+    // [JACKSON-695], JsonSerializer.isEmpty()\n+    public void testCustomNoEmpty() throws Exception\n+    {\n+        // first non-empty:\n+        assertEquals(\"{\\\"value\\\":123}\", mapper.writeValueAsString(new NonZeroWrapper(123)));\n+        // then empty:\n+        assertEquals(\"{}\", mapper.writeValueAsString(new NonZeroWrapper(0)));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n         }\n     }\n \n+    static class Bean1 {\n+        public String name = null;\n+    }\n+\n+    static class Bean2 {\n+        public String type = null;\n+    }\n+    \n+    static class MyNullProvider extends StdSerializerProvider\n+    {\n+        public MyNullProvider() { super(); }\n+        public MyNullProvider(SerializationConfig config, MyNullProvider base, SerializerFactory jsf) {\n+            super(config, base, jsf);\n+        }\n+        \n+        protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {\n+            return new MyNullProvider(config, this, jsf);\n+        }\n+        \n+        @Override\n+        public JsonSerializer<Object> findNullValueSerializer(BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            if (\"name\".equals(property.getName())) {\n+                return new NullSerializer();\n+            }\n+            return super.findNullValueSerializer(property);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n     public void testSimple() throws Exception\n     {\n         assertEquals(\"null\", new ObjectMapper().writeValueAsString(null));\n     }\n \n-    public void testCustom() throws Exception\n+    public void testOverriddenDefaultNulls() throws Exception\n     {\n-        StdSerializerProvider sp = new StdSerializerProvider();\n+        StdSerializerProvider sp = new StdSerializerProvider.Impl();\n         sp.setNullValueSerializer(new NullSerializer());\n         ObjectMapper m = new ObjectMapper();\n         m.setSerializerProvider(sp);\n         assertEquals(\"\\\"foobar\\\"\", m.writeValueAsString(null));\n     }\n+\n+    public void testCustomNulls() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.setSerializerProvider(new MyNullProvider());\n+        assertEquals(\"{\\\"name\\\":\\\"foobar\\\"}\", m.writeValueAsString(new Bean1()));\n+        assertEquals(\"{\\\"type\\\":null}\", m.writeValueAsString(new Bean2()));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n         ObjectMapper mapper = new ObjectMapper();\n         SerializationConfig config = mapper.getSerializationConfig();\n         SerializerFactory f = new BeanSerializerFactory(null);\n-        StdSerializerProvider prov = new StdSerializerProvider().createInstance(config, f);\n+        StdSerializerProvider prov = new StdSerializerProvider.Impl().createInstance(config, f);\n \n         // Should have working default key and null key serializers\n         assertNotNull(prov.findKeySerializer(null, null));\n-        assertNotNull(prov.getNullKeySerializer());\n+        assertNotNull(prov.getDefaultNullKeySerializer());\n+        assertNotNull(prov.getDefaultNullValueSerializer());\n         // as well as 'unknown type' one (throws exception)\n         assertNotNull(prov.getUnknownTypeSerializer(getClass()));\n         ", "timestamp": 1326433927, "metainfo": ""}