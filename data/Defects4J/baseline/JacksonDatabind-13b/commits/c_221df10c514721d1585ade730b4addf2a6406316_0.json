{"sha": "221df10c514721d1585ade730b4addf2a6406316", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n      */\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException;\n+    \n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param isOptional Is the type optional\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.*;\n+\n+import javax.xml.bind.annotation.XmlElement;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n             if (id != null && id.length() > 0) {\n                 o.put(\"id\", id);\n             }\n-        }        \n+        }\n+ \n         //todo: should the classname go in the title?\n         //o.put(\"title\", _className);\n         ObjectNode propertiesNode = o.objectNode();\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n             JavaType propType = prop.getSerializationType();\n+\n             // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n             Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n             // Maybe it already has annotated/statically configured serializer?\n                 }\n                 ser = provider.findValueSerializer(serType, prop);\n             }\n+            boolean isOptional = !isPropertyRequired(prop, provider);\n+            \n             JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                    ((SchemaAware) ser).getSchema(provider, hint) : \n+                    ((SchemaAware) ser).getSchema(provider, hint, isOptional) : \n                     JsonSchema.getDefaultSchemaNode();\n             propertiesNode.put(prop.getName(), schemaNode);\n         }\n         o.put(\"properties\", propertiesNode);\n         return o;\n     }\n+\n+    /**\n+     * Determines if a bean property is required. Currently this looks for any XmlElement annotations\n+     * that have a require attribute.\n+     * @param prop the bean property.\n+     * @return true if the property is optional, false otherwise.\n+     */\n+\tprivate boolean isPropertyRequired(final BeanPropertyWriter prop, final SerializerProvider provider) {\n+\t\tBoolean value = provider.getAnnotationIntrospector().hasRequiredMarker(prop.getMember());\n+\t\treturn value == null ? false : value.booleanValue();\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n         return createSchemaNode(\"string\");\n     }\n     \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException\n+    {\n+    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n+    \tif (!isOptional) {\n+    \t\tschema.put(\"required\", !isOptional);\n+    \t}\n+        return schema;\n+    }\n+    \n     protected ObjectNode createObjectNode() {\n         return JsonNodeFactory.instance.objectNode();\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n         private String property2;\n         private String[] property3;\n         private Collection<Float> property4;\n-\n+        @JsonProperty(required=true)\n+        private String property5;\n+        \n         public int getProperty1()\n         {\n             return property1;\n         {\n             this.property4 = property4;\n         }\n+        \n+        public String getProperty5()\n+        {\n+            return property5;\n+        }\n+\n+        public void setProperty5(String property5)\n+        {\n+            this.property5 = property5;\n+        }\n     }\n \n     public class TrivialBean {\n         throws Exception\n     {\n         JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+        \n         assertNotNull(jsonSchema);\n \n         // test basic equality, and that equals() handles null, other obs\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue();\n             }\n-            return jp.getIntValue();\n+            /* and as per [JACKSON-839], allow \"upgrade\" to bigger types: out-of-range\n+             * entries can not be produced without type, so this should \"just work\",\n+             * even if it is bit unclean\n+             */\n+            return jp.getNumberValue();\n \n         case VALUE_NUMBER_FLOAT:\n             // For [JACKSON-72], see above\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+/**\n+ * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * one that only uses core JDK types; wrappers, Maps and Lists.\n+ */\n+public class TestUntypedDeserialization\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSampleDoc()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* To get \"untyped\" Mapping (to Maps, Lists, instead of beans etc),\n+         * we'll specify plain old Object.class as the target.\n+         */\n+        Object root = new ObjectMapper().readValue(jf.createJsonParser(new StringReader(JSON)), Object.class);\n+\n+        assertType(root, Map.class);\n+        Map<?,?> rootMap = (Map<?,?>) root;\n+        assertEquals(1, rootMap.size());\n+        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();\n+        assertEquals(\"Image\", rootEntry.getKey());\n+        Object image = rootEntry.getValue();\n+        assertType(image, Map.class);\n+        Map<?,?> imageMap = (Map<?,?>) image;\n+        assertEquals(5, imageMap.size());\n+\n+        Object value = imageMap.get(\"Width\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);\n+\n+        value = imageMap.get(\"Height\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);\n+\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get(\"Title\"));\n+\n+        // Another Object, \"thumbnail\"\n+        value = imageMap.get(\"Thumbnail\");\n+        assertType(value, Map.class);\n+        Map<?,?> tnMap = (Map<?,?>) value;\n+        assertEquals(3, tnMap.size());\n+\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get(\"Height\"));\n+        // for some reason, width is textual, not numeric...\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get(\"Width\"));\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get(\"Url\"));\n+\n+        // And then number list, \"IDs\"\n+        value = imageMap.get(\"IDs\");\n+        assertType(value, List.class);\n+        List<Object> ids = (List<Object>) value;\n+        assertEquals(4, ids.size());\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));\n+\n+        // and that's all folks!\n+    }\n+\n+    // [JACKSON-839]: allow 'upgrade' of big integers into Long, BigInteger\n+    public void testObjectSerializeWithLong() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT, As.PROPERTY);\n+        final long VALUE = 1337800584532L;\n+\n+        String serialized = \"{\\\"timestamp\\\":\"+VALUE+\"}\";\n+        // works fine as node\n+        JsonNode deserialized = mapper.readTree(serialized);\n+        assertEquals(VALUE, deserialized.get(\"timestamp\").asLong());\n+        // and actually should work in Maps too\n+        Map<?,?> deserMap = mapper.readValue(serialized, Map.class);\n+        Number n = (Number) deserMap.get(\"timestamp\");\n+        assertNotNull(n);\n+        assertSame(Long.class, n.getClass());\n+        assertEquals(Long.valueOf(VALUE), n);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestUntypedSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tries verify simplest aspects of\n+ * \"Native\" java type mapper; basically that is can properly serialize\n+ * core JDK objects to JSON.\n+ */\n+public class TestUntypedSerialization\n+    extends BaseMapTest\n+{\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ArrayList<Object> doc = new ArrayList<Object>();\n+        doc.add(\"Elem1\");\n+        doc.add(Integer.valueOf(3));\n+        Map<String,Object> struct = new LinkedHashMap<String, Object>();\n+        struct.put(\"first\", Boolean.TRUE);\n+        struct.put(\"Second\", new ArrayList<Object>());\n+        doc.add(struct);\n+        doc.add(Boolean.FALSE);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f =  new JsonFactory();\n+\n+        // loop more than once, just to ensure caching works ok (during second round)\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            \n+            JsonParser jp = f.createJsonParser(str);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"Elem1\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(3, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"first\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"Second\", getAndVerifyText(jp));\n+            \n+            if (jp.nextToken() != JsonToken.START_ARRAY) {\n+                fail(\"Expected START_ARRAY: JSON == '\"+str+\"'\");\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+            \n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();\n+        JsonFactory f =  new JsonFactory();\n+\n+        doc.put(\"a1\", \"\\\"text\\\"\");\n+        doc.put(\"int\", Integer.valueOf(137));\n+        doc.put(\"foo bar\", Long.valueOf(1234567890L));\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            JsonParser jp = f.createJsonParser(str);\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"a1\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"\\\"text\\\"\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"int\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(137, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"foo bar\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1234567890L, jp.getLongValue());\n+            \n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+}", "timestamp": 1338435959, "metainfo": ""}