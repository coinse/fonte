{"sha": "377aab01b89b2468856d3314cc389c5e3c2cde77", "log": "Some work wrt #588; minor refactoring to support custom ObjectWriter sub-classes", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n      * values of type this serializer handles.\n      *\n      * @param value Value to serialize; can <b>not</b> be null.\n-     * @param jgen Generator used to output resulting Json content\n+     * @param gen Generator used to output resulting Json content\n      * @param provider Provider that can be used to get serializers for\n      *   serializing Objects value contains, if any.\n      */\n-    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+    public abstract void serialize(T value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * implementation would look like:\n      *<pre>\n      *  // note: method to call depends on whether this type is serialized as JSON scalar, object or Array!\n-     *  typeSer.writeTypePrefixForScalar(value, jgen);\n-     *  serialize(value, jgen, provider);\n-     *  typeSer.writeTypeSuffixForScalar(value, jgen);\n+     *  typeSer.writeTypePrefixForScalar(value, gen);\n+     *  serialize(value, gen, provider);\n+     *  typeSer.writeTypeSuffixForScalar(value, gen);\n      *</pre>\n      * and implementations for type serialized as JSON Arrays or Objects would differ slightly,\n      * as <code>START-ARRAY>/<code>END-ARRAY</code> and\n      * need to be properly handled with respect to serializing of contents.\n      *\n      * @param value Value to serialize; can <b>not</b> be null.\n-     * @param jgen Generator used to output resulting Json content\n+     * @param gen Generator used to output resulting Json content\n      * @param provider Provider that can be used to get serializers for\n      *   serializing Objects value contains, if any.\n      * @param typeSer Type serializer to use for including type information\n      */\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException\n     {\n      * Default implementation will consider only null values to be empty.\n      * \n      * @since 2.0\n-     */\n+     * \n+     * @deprecated Since 2.5 Use {@link #isEmpty(SerializerProvider, Object)} instead\n+     */\n+    @Deprecated\n     public boolean isEmpty(T value) {\n         return (value == null);\n     }\n \n+    /**\n+     * Method called to check whether given serializable value is\n+     * considered \"empty\" value (for purposes of suppressing serialization\n+     * of empty values).\n+     *<p>\n+     * Default implementation will consider only null values to be empty.\n+     *<p>\n+     * NOTE: replaces {@link #isEmpty(Object)}, deprecated in 2.5\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isEmpty(SerializerProvider provider, T value) {\n+        // replace with implementation in 2.6 or later\n+        return isEmpty(value);\n+    }\n+    \n     /**\n      * Method that can be called to see whether this serializer instance\n      * will use Object Id to handle cyclic references.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     /**********************************************************\n     /* Methods sub-classes MUST override, used for constructing\n     /* reader instances, (re)configuring parser instances\n+    /* Added in 2.5\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n-\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* reader instances, (re)configuring parser instances.\n+    /* Added in 2.5\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(ObjectWriter base, JsonFactory f) {\n+        return new ObjectWriter(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(ObjectWriter base, SerializationConfig config) {\n+        return new ObjectWriter(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(ObjectWriter base, SerializationConfig config,\n+            JavaType rootType, JsonSerializer<Object> rootSer,\n+            PrettyPrinter pp, FormatSchema s, CharacterEscapes escapes) {\n+        return new ObjectWriter(base, config, rootType, rootSer, pp, s, escapes);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Life-cycle, fluent factories for SerializationFeature\n      */\n     public ObjectWriter with(SerializationFeature feature)  {\n         SerializationConfig newConfig = _config.with(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(SerializationFeature first, SerializationFeature... other) {\n         SerializationConfig newConfig = _config.with(first, other);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter withFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n     \n     /**\n      */\n     public ObjectWriter without(SerializationFeature feature) {\n         SerializationConfig newConfig = _config.without(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter without(SerializationFeature first, SerializationFeature... other) {\n         SerializationConfig newConfig = _config.without(first, other);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter withoutFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /*\n      */\n     public ObjectWriter with(JsonGenerator.Feature feature)  {\n         SerializationConfig newConfig = _config.with(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withFeatures(JsonGenerator.Feature... features) {\n         SerializationConfig newConfig = _config.withFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter without(JsonGenerator.Feature feature) {\n         SerializationConfig newConfig = _config.without(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withoutFeatures(JsonGenerator.Feature... features) {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /*\n      */\n     public ObjectWriter with(DateFormat df) {\n         SerializationConfig newConfig = _config.with(df);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(FilterProvider filterProvider) {\n         return (filterProvider == _config.getFilterProvider()) ? this\n-                 : new ObjectWriter(this, _config.withFilters(filterProvider));\n+                 : _new(this, _config.withFilters(filterProvider));\n     }\n \n     /**\n         if (pp == null) {\n             pp = NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+        return _new(this, _config, _rootType, _rootSerializer,\n                 pp, _schema, _characterEscapes);\n     }\n \n      */\n     public ObjectWriter withRootName(String rootName) {\n         SerializationConfig newConfig = _config.withRootName(rootName);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+        return _new(this, _config, _rootType, _rootSerializer,\n                 _prettyPrinter, schema, _characterEscapes);\n     }\n \n             rootType = rootType.withStaticTyping();\n             rootSer = _prefetchRootSerializer(_config, rootType);\n         }\n-        return new ObjectWriter(this, _config, rootType, rootSer,\n+        return _new(this, _config, rootType, rootSer,\n                 _prettyPrinter, _schema, _characterEscapes);\n     }    \n \n      */\n     public ObjectWriter withView(Class<?> view) {\n         SerializationConfig newConfig = _config.withView(view);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }    \n \n     public ObjectWriter with(Locale l) {\n         SerializationConfig newConfig = _config.with(l);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     public ObjectWriter with(TimeZone tz) {\n         SerializationConfig newConfig = _config.with(tz);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(Base64Variant b64variant) {\n         SerializationConfig newConfig = _config.with(b64variant);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n         if (_characterEscapes == escapes) {\n             return this;\n         }\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+        return _new(this, _config, _rootType, _rootSerializer,\n                 _prettyPrinter, _schema, escapes);\n     }\n \n      * @since 2.3\n      */\n     public ObjectWriter with(JsonFactory f) {\n-        return (f == _generatorFactory) ? this : new ObjectWriter(this, f);\n+        return (f == _generatorFactory) ? this : _new(this, f);\n     }    \n \n     /**\n      */\n     public ObjectWriter with(ContextAttributes attrs) {\n         SerializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withAttributes(Map<Object,Object> attrs) {\n         SerializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withAttribute(Object key, Object value) {\n         SerializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withoutAttribute(Object key) {\n         SerializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n         // [databind#631]: Assign current value, to be accessible by custom serializers\n         p.setCurrentValue(bean);\n+\n         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n             String propName = p.getCurrentName();\n             p.nextToken();\n                 handleUnknownVanilla(p, ctxt, bean, propName);\n             }\n         }\n-        \n+\n         // 13-Dec-2014, tatu: For 2.6, we'll do:\n         /*\n         if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n             } while ((propName = p.nextFieldName()) != null);\n         }\n         */\n-        \n         return bean;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n      * using appropriate serializer.\n      */\n     @Override\n-    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n     {\n         // inlined 'get()'\n         final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n         // Null handling is bit different, check that first\n         if (value == null) {\n             if (_nullSerializer != null) {\n-                jgen.writeFieldName(_name);\n-                _nullSerializer.serialize(null, jgen, prov);\n+                gen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, gen, prov);\n             }\n             return;\n         }\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n             // three choices: exception; handled by call; or pass-through\n-            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n                 return;\n             }\n         }\n-        jgen.writeFieldName(_name);\n+        gen.writeFieldName(_name);\n         if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n+            ser.serialize(value, gen, prov);\n         } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n         }\n     }\n \n      * @since 2.3\n      */\n     @Override\n-    public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    public void serializeAsOmittedField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n     {\n-        if (!jgen.canOmitFields()) {\n-            jgen.writeOmittedField(_name.getValue());\n+        if (!gen.canOmitFields()) {\n+            gen.writeOmittedField(_name.getValue());\n         }\n     }\n     \n      * @since 2.3\n      */\n     @Override\n-    public void serializeAsElement(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n         throws Exception\n     {\n         // inlined 'get()'\n         final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n         if (value == null) { // nulls need specialized handling\n             if (_nullSerializer != null) {\n-                _nullSerializer.serialize(null, jgen, prov);\n+                _nullSerializer.serialize(null, gen, prov);\n             } else { // can NOT suppress entries in tabular output\n-                jgen.writeNull();\n+                gen.writeNull();\n             }\n             return;\n         }\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n-                    serializeAsPlaceholder(bean, jgen, prov);\n+                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n+                    serializeAsPlaceholder(bean, gen, prov);\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n-                serializeAsPlaceholder(bean, jgen, prov);\n+                serializeAsPlaceholder(bean, gen, prov);\n                 return;\n             }\n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n                 return;\n             }\n         }\n         if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n+            ser.serialize(value, gen, prov);\n         } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n         }\n     }\n \n      * @since 2.1\n      */\n     @Override\n-    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+    public void serializeAsPlaceholder(Object bean, JsonGenerator gen, SerializerProvider prov)\n         throws Exception\n     {\n         if (_nullSerializer != null) {\n-            _nullSerializer.serialize(null, jgen, prov);\n+            _nullSerializer.serialize(null, gen, prov);\n         } else {\n-            jgen.writeNull();\n+            gen.writeNull();\n         }\n     }\n     \n      * @return True if method fully handled self-referential value; false if not (caller\n      *    is to handle it) or {@link JsonMappingException} if there is no way handle it\n      */\n-    protected boolean _handleSelfReference(Object bean, JsonGenerator jgen, SerializerProvider prov, JsonSerializer<?> ser)\n+    protected boolean _handleSelfReference(Object bean, JsonGenerator gen, SerializerProvider prov, JsonSerializer<?> ser)\n             throws JsonMappingException {\n         if (prov.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES)\n                 && !ser.usesObjectId()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n         }\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n         }\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     serializeAsPlaceholder(bean, gen, prov);\n                     return;\n                 }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n         }\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n                 }\n                 // also may need to skip non-empty values:\n                 if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n-                        && valueSer.isEmpty(valueElem)) {\n+                        && valueSer.isEmpty(provider, valueElem)) {\n                     continue;\n                 }\n             }\n                 }\n                 // also may need to skip non-empty values:\n                 if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n-                        && valueSer.isEmpty(valueElem)) {\n+                        && valueSer.isEmpty(provider, valueElem)) {\n                     continue;\n                 }\n             }\n                 }\n                 // also may need to skip non-empty values:\n                 if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n-                        && valueSer.isEmpty(valueElem)) {\n+                        && valueSer.isEmpty(provider, valueElem)) {\n                     continue;\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n         JsonFormatVisitable, SchemaAware\n {\n     protected final Converter<Object,?> _converter;\n-    \n+\n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n      */\n \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonProcessingException\n+    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         Object delegateValue = convertValue(value);\n         // should we accept nulls?\n         if (delegateValue == null) {\n-            provider.defaultSerializeNull(jgen);\n+            provider.defaultSerializeNull(gen);\n             return;\n         }\n-        _delegateSerializer.serialize(delegateValue, jgen, provider);\n-    }\n-\n-    @Override\n-    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+        _delegateSerializer.serialize(delegateValue, gen, provider);\n+    }\n+\n+    @Override\n+    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n     {\n         /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n          *    let's give it a chance?\n          */\n         Object delegateValue = convertValue(value);\n-        _delegateSerializer.serializeWithType(delegateValue, jgen, provider, typeSer);\n-    }\n-\n-    @Override\n+        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+    }\n+\n+    @Override\n+    @Deprecated // since 1.5\n     public boolean isEmpty(Object value)\n     {\n         Object delegateValue = convertValue(value);\n         return _delegateSerializer.isEmpty(delegateValue);\n     }\n-    \n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, Object value)\n+    {\n+        Object delegateValue = convertValue(value);\n+        return _delegateSerializer.isEmpty(prov, delegateValue);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Schema functionality\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n     public ToStringSerializer(Class<?> handledType) {\n         super(handledType, false);\n     }\n-    \n+\n     @Override\n+    @Deprecated\n     public boolean isEmpty(Object value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, Object value) {\n         if (value == null) {\n             return true;\n         }\n     }\n     \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeString(value.toString());\n+        gen.writeString(value.toString());\n     }\n \n     /* 01-Mar-2011, tatu: We were serializing as \"raw\" String; but generally that\n      * change this behavior.\n      */\n     @Override\n-    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException\n     {\n-        typeSer.writeTypePrefixForScalar(value, jgen);\n-        serialize(value, jgen, provider);\n-        typeSer.writeTypeSuffixForScalar(value, jgen);\n+        typeSer.writeTypePrefixForScalar(value, gen);\n+        serialize(value, gen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, gen);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n import java.io.IOException;\n import java.util.UUID;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n     extends StdScalarSerializer<UUID>\n {\n     final static char[] HEX_CHARS = \"0123456789abcdef\".toCharArray();\n-    \n+\n     public UUIDSerializer() { super(UUID.class); }\n \n     @Override\n-    public boolean isEmpty(UUID value)\n+    @Deprecated // since 2.5\n+    public boolean isEmpty(UUID value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, UUID value)\n     {\n         if (value == null) {\n             return true;\n         }\n         return false;\n     }\n-    \n+\n     @Override\n-    public void serialize(UUID value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(UUID value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // First: perhaps we could serialize it as raw binary data?\n-        if (jgen.canWriteBinaryNatively()) {\n+        if (gen.canWriteBinaryNatively()) {\n             /* 07-Dec-2013, tatu: One nasty case; that of TokenBuffer. While it can\n              *   technically retain binary data, we do not want to do use binary\n              *   with it, as that results in UUIDs getting converted to Base64 for\n              *   most conversions.\n              */\n-            if (!(jgen instanceof TokenBuffer)) {\n-                jgen.writeBinary(_asBytes(value));\n+            if (!(gen instanceof TokenBuffer)) {\n+                gen.writeBinary(_asBytes(value));\n                 return;\n             }\n         }\n         _appendShort((int) (lsb >>> 32), ch, 24);\n         _appendInt((int) lsb, ch, 28);\n \n-        jgen.writeString(ch, 0, 36);\n+        gen.writeString(ch, 0, 36);\n     }\n \n     private static void _appendInt(int bits, char[] ch, int offset)\n--- a/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n         assertNotNull(type);\n     }\n }\n-", "timestamp": 1418612712, "metainfo": ""}