{"sha": "d55cab3629bef89c3e0f90f057c1542abc2180ab", "log": "First fix for #622 that seems to work (after minor fixes to test also; id class MUST implement #equals() and #hashCode()!) Will see if polymorphic case would support, and if not, what is needed to support it.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     }\n \n     /**\n-     * General version used when handling needs more advanced\n-     * features.\n+     * General version used when handling needs more advanced features.\n      */\n     @Override\n     public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n+        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n+         *   to come in as JSON Objects as well; but for now assume they will\n+         *   be simple, single-prooerty references, which means that we can\n+         *   recognize them without having to buffer anything.\n+         *   Once again, if we must, we can do more complex handling with buffering,\n+         *   but let's only do that if and when that becomes necessary.\n+         */\n+        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n+            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n+                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n+                return deserializeFromObjectId(p, ctxt);\n+            }\n+        }\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n                 return deserializeWithUnwrapped(p, ctxt);\n             if (_needViewProcesing) {\n                 Class<?> view = ctxt.getActiveView();\n                 if (view != null) {\n-                    return deserializeWithView(jp, ctxt, bean, view);\n+                    return deserializeWithView(p, ctxt, bean, view);\n                 }\n             }\n             */\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        // [databind#631]: Assign current value, to be accessible by custom deserializers\n         p.setCurrentValue(bean);\n         if (p.canReadObjectId()) {\n             Object id = p.getObjectId();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * General version used when handling needs more advanced\n      * features.\n      */\n-    public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n         throws IOException;\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException\n     {\n         // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n         if (_objectIdReader != null) {\n             // 05-Aug-2013, tatu: May use native Object Id\n-            if (jp.canReadObjectId()) {\n-                Object id = jp.getObjectId();\n+            if (p.canReadObjectId()) {\n+                Object id = p.getObjectId();\n                 if (id != null) {\n-                    Object ob = typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n-                    return _handleTypedObjectId(jp, ctxt, ob, id);\n+                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n+                    return _handleTypedObjectId(p, ctxt, ob, id);\n                 }\n             }\n             // or, Object Ids Jackson explicitly sets\n-            JsonToken t = jp.getCurrentToken();\n+            JsonToken t = p.getCurrentToken();\n             // for now (2.2.x) we only allow scalar types (Strings, integral numbers):\n             // NOTE: may  need to allow handling of structured values in future for JSOG\n-            if (t != null && t.isScalarValue()) {\n-                return deserializeFromObjectId(jp, ctxt);\n+            if (t != null && (t.isScalarValue() || _objectIdReader.maySerializeAsObject())) {\n+                return deserializeFromObjectId(p, ctxt);\n             }\n         }\n         // In future could check current token... for now this should be enough:\n-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n     }\n \n     /**\n      */\n     protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,\n             Object pojo, Object rawId)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         /* 07-Aug-2013, tatu: One more challenge: type of id may not be type\n          *   of property we are expecting later on; specifically, numeric ids\n     protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return deserializeFromObject(jp, ctxt);\n     }\n-    \n+\n     /**\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n \n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n             DeserializationContext ctxt) throws IOException\n-    {        \n+    {\n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n                     _delegateDeserializer.deserialize(jp, ctxt));\n             }\n             return bean;\n         }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n-    }\n-\n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n+            return deserializeFromObjectId(p, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n          */\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+        return _valueInstantiator.createFromString(ctxt, p.getText());\n     }\n \n     /**\n      * number.\n      */\n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n-        switch (jp.getNumberType()) {\n+    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        switch (p.getNumberType()) {\n         case FLOAT: // no separate methods for taking float...\n         case DOUBLE:\n             if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n                     return bean;\n                 }\n             }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n         }\n         // actually, could also be BigDecimal, so:\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n+        }\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n     }\n \n     /**\n      * Method called to deserialize POJO value from a JSON boolean value (true, false)\n      */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n         return _valueInstantiator.createFromBoolean(ctxt, value);\n     }\n \n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 wrapInstantiationProblem(e, ctxt);\n             }\n         } else if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                 return null;\n             }\n-            final Object value = deserialize(jp, ctxt);\n-            if (jp.nextToken() != JsonToken.END_ARRAY) {\n-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n+            final Object value = deserialize(p, ctxt);\n+            if (p.nextToken() != JsonToken.END_ARRAY) {\n+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                         \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n             }\n             return value;\n         } else if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY) {\n                 return null;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n-\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n     public JavaType getIdType() {\n         return _idType;\n     }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.maySerializeAsObject();\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean maySerializeAsObject() {\n+        return generator.maySerializeAsObject();\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.isValidReferencePropertyName(name, parser);\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isValidReferencePropertyName(String name, JsonParser parser) {\n+        return generator.isValidReferencePropertyName(name, parser);\n+    }\n     \n     /**\n      * Method called to read value that is expected to be an Object Reference\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n \n     protected final ObjectIdReader _objectIdReader;\n \n-    @Deprecated // since 2.2\n-    public ObjectIdValueProperty(ObjectIdReader objectIdReader) {\n-        this(objectIdReader, PropertyMetadata.STD_REQUIRED);\n-    }\n-    \n     public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n             PropertyMetadata metadata)\n     {\n--- a/src/test/java/com/fasterxml/jackson/failing/JSOGDeserialize622Test.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/JSOGDeserialize622Test.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n \n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-\n import com.fasterxml.jackson.databind.*;\n \n /**\n  */\n public class JSOGDeserialize622Test extends BaseMapTest\n {\n-  /** the key of the property that holds the ref */\n-  public static final String REF_KEY = \"@ref\";\n+    /** the key of the property that holds the ref */\n+    public static final String REF_KEY = \"@ref\";\n \n-  /**\n-   * JSON input\n-   */\n-  private static final String EXP_EXAMPLE_JSOG =  aposToQuotes(\n-          \"{'@id':'1','foo':66,'next':{'\"+REF_KEY+\"':'1'}}\");\n+    /**\n+     * JSON input\n+     */\n+    private static final String EXP_EXAMPLE_JSOG =  aposToQuotes(\n+            \"{'@id':'1','foo':66,'next':{'\"+REF_KEY+\"':'1'}}\");\n \n-  private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper mapper = new ObjectMapper();\n \n-  /**\n-   * Customer IdGenerator\n-   */\n-  static class JSOGGenerator extends ObjectIdGenerator<JSOGRef>  {\n+    /**\n+     * Customer IdGenerator\n+     */\n+    static class JSOGGenerator extends ObjectIdGenerator<JSOGRef>  {\n \n     private static final long serialVersionUID = 1L;\n     protected transient int _nextValue;\n           return new IdKey(getClass(), _scope, key);\n     }\n \n+    // important: otherwise won't get proper handling\n+    @Override\n+    public boolean maySerializeAsObject() { return true; }\n+\n+    @Override\n+    public boolean isValidReferencePropertyName(String name, Object parser) {\n+        return REF_KEY.equals(name);\n+    }\n+\n     @Override\n     public JSOGRef generateId(Object forPojo) {\n           int id = _nextValue;\n           ++_nextValue;\n           return new JSOGRef(id);\n     }\n-  }\n+    }\n \n-  /**\n-   * The reference deserializer\n-   */\n-  static class JSOGRefDeserializer extends JsonDeserializer<JSOGRef>\n-  {\n-    @Override\n-    public JSOGRef deserialize(JsonParser jp, DeserializationContext ctx) throws IOException, JsonProcessingException {\n-      JsonNode node = jp.readValueAsTree();\n-      return node.isTextual()\n-              ? new JSOGRef(node.asInt()) : new JSOGRef(node.get(REF_KEY).asInt());\n+    /**\n+     * The reference deserializer\n+     */\n+    static class JSOGRefDeserializer extends JsonDeserializer<JSOGRef>\n+    {\n+      @Override\n+      public JSOGRef deserialize(JsonParser jp, DeserializationContext ctx) throws IOException {\n+          JsonNode node = jp.readValueAsTree();\n+          return node.isTextual()\n+                  ? new JSOGRef(node.asInt()) : new JSOGRef(node.get(REF_KEY).asInt());\n+      }\n     }\n-  }\n \n-  /**\n-   * The reference object\n-   */\n-  @JsonDeserialize(using=JSOGRefDeserializer.class)\n-  static class JSOGRef\n-  {\n-    @JsonProperty(REF_KEY)\n-    public int ref;\n+    /**\n+     * The reference object\n+     */\n+    @JsonDeserialize(using=JSOGRefDeserializer.class)\n+    static class JSOGRef\n+    {\n+        @JsonProperty(REF_KEY)\n+        public int ref;\n \n-    public JSOGRef() { }\n+        public JSOGRef() { }\n \n-    public JSOGRef(int val) {\n-      ref = val;\n+        public JSOGRef(int val) {\n+            ref = val;\n+        }\n+\n+        @Override\n+        public String toString() { return \"[JSOGRef#\"+ref+\"]\"; }\n+\n+        @Override\n+        public int hashCode() {\n+            return ref;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object other) {\n+            return (other instanceof JSOGRef)\n+                    && ((JSOGRef) other).ref == this.ref;\n+        }\n     }\n-  }\n \n+    /**\n+     * Example class using JSOGGenerator\n+     */\n+    @JsonIdentityInfo(generator=JSOGGenerator.class, property=\"@id\")\n+    public static class IdentifiableExampleJSOG {\n+        public int foo;\n+        public IdentifiableExampleJSOG next;\n+    }\n \n-  /**\n-   * Example class using JSOGGenerator\n-   */\n-  @JsonIdentityInfo(generator=JSOGGenerator.class)\n-  public static class IdentifiableExampleJSOG {\n-      public int foo;\n-      public IdentifiableExampleJSOG next;\n-  }\n+    /*\n+    /**********************************************************************\n+    /* Test methods\n+    /**********************************************************************\n+     */\n \n-  /*\n-  /**********************************************************************\n-  /* Test methods\n-  /**********************************************************************\n-   */\n-\n-  // for [databind#622]\n-  public void testStructJSOGRef() throws Exception {\n-      // Because the value ({@ref:1}) is not scalar, parser thinks it is not an id \n-      // and tries to deserialize as normal a new IdentifiableExampleJSOG \n-      // then  complains about unrecognized field \"@ref\"\n-      IdentifiableExampleJSOG result = mapper.readValue(EXP_EXAMPLE_JSOG,\n-              IdentifiableExampleJSOG.class);\n-\n-      assertEquals(66, result.foo);\n-      assertSame(result, result.next);\n-  }\n+    // for [databind#622]\n+    public void testStructJSOGRef() throws Exception {\n+        IdentifiableExampleJSOG result = mapper.readValue(EXP_EXAMPLE_JSOG,\n+                IdentifiableExampleJSOG.class);\n+        assertEquals(66, result.foo);\n+        assertSame(result, result.next);\n+    }\n }", "timestamp": 1418192081, "metainfo": ""}