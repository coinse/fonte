{"sha": "7b5694b77e5e8c0ef2b57c4f97c4785462671dd6", "log": "Refactoring to try to (eventually) solve #357; still problematic wrt contextualization, infinite recursion", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n      *   finding any serializer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n-            BeanProperty property)\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Fast lookup from local lookup thingy works?\n                 if (ser == null) {\n                     // If neither, must create\n                     ser = _createAndCacheUntypedSerializer(valueType);\n-                    // Not found? Must use the unknown type serializer\n-                    /* Couldn't create? Need to return the fallback serializer, which\n-                     * most likely will report an error: but one question is whether\n-                     * we should cache it?\n-                     */\n+                    // Not found? Must use the unknown type serializer, which will report error later on\n                     if (ser == null) {\n                         ser = getUnknownTypeSerializer(valueType);\n                         // Should this be added to lookups?\n     public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // Fast lookup from local lookup thingy works?\n+        // (see comments from above method)\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n         if (ser == null) {\n-            // If not, maybe shared map already has it?\n             ser = _serializerCache.untypedValueSerializer(valueType);\n             if (ser == null) {\n-                // If neither, must create\n                 ser = _createAndCacheUntypedSerializer(valueType);\n-                // Not found? Must use the unknown type serializer\n-                /* Couldn't create? Need to return the fallback serializer, which\n-                 * most likely will report an error: but one question is whether\n-                 * we should cache it?\n-                 */\n                 if (ser == null) {\n                     ser = getUnknownTypeSerializer(valueType.getRawClass());\n-                    // Should this be added to lookups?\n                     if (CACHE_UNKNOWN_MAPPINGS) {\n                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                     }\n         return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    ser = _createAndCacheUntypedSerializer(valueType);\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(valueType);\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * Similar to {@link #findValueSerializer(JavaType, BeanProperty)}, but used\n      * when finding \"primary\" property value serializer (one directly handling\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         }\n         return ser;\n     }\n-    \n+\n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n         return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n     }\n-\n+    \n     /**\n      * @since 2.3\n      */\n \n     @Override\n     public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         jgen.writeStartObject();\n         if (!value.isEmpty()) {\n     @Override\n     public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         typeSer.writeTypePrefixForObject(value, jgen);\n         if (!value.isEmpty()) {\n      * Method called to serialize fields, when the value type is not statically known.\n      */\n     public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n      */\n     protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n      */\n     public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             PropertyFilter filter)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final HashSet<String> ignored = _ignoredEntries;\n         final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n     }\n     \n     protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         JsonSerializer<Object> prevValueSerializer = null;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n         }\n         // and then find the thing...\n         return withDelegate(_converter, delegateType,\n-                provider.findValueSerializer(delegateType, property));\n+//                provider.findValueSerializer(delegateType, property));\n+                provider.findValueSerializer(delegateType));\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n             BeanProperty prop, JsonSerializer<?> existingSerializer)\n         throws JsonMappingException\n     {\n+        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n+         *   when applying contextual content converter; this is not ideal way,\n+         *   but should work for most cases.\n+         */\n+\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n             Object convDef = intr.findSerializationContentConverter(prop.getMember());\n                 Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 if (existingSerializer == null) {\n-                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n+                    existingSerializer = provider.findValueSerializer(delegateType);\n                 }\n                 return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n             }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     // [Issue#357]\n-    static class A { }\n+    static class Value { }\n \n-    static class B {\n-        @JsonSerialize(contentConverter = AToStringConverter.class)\n-        public List<A> list = Arrays.asList(new A());\n+    static class ListWrapper {\n+        @JsonSerialize(contentConverter = ValueToStringListConverter.class)\n+        public List<Value> list = Arrays.asList(new Value());\n     }\n \n-    static class AToStringConverter extends StdConverter<A, List<String>> {\n+    static class ValueToStringListConverter extends StdConverter<Value, List<String>> {\n         @Override\n-        public List<String> convert(A value) {\n+        public List<String> convert(Value value) {\n             return Arrays.asList(\"Hello world!\");\n         }\n     }\n \n     // [Issue#357]\n     public void testConverterForList357() throws Exception {\n-        String json = objectWriter().writeValueAsString(new B());\n+        String json = objectWriter().writeValueAsString(new ListWrapper());\n         assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n     }\n }", "timestamp": 1413735655, "metainfo": ""}