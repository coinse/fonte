{"sha": "603991b7813511725e464d9189f3db4742730334", "log": "Fix the problem with dep loop for \"untyped\" object deserializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n     @Override\n     public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n         if (!jp.isExpectedStartArrayToken()) {\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n      */\n     protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n      * to: it can not be done earlier since delegated deserializers almost\n      * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         JavaType obType = ctxt.constructType(Object.class);\n         JavaType stringType = ctxt.constructType(String.class);\n         TypeFactory tf = ctxt.getTypeFactory();\n+\n+        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n+         *    should always be called separately, from within \"createContextual()\".\n+         *    But this is a very singular deserializer since it operates on `Object`\n+         *    (and often for `?` type parameter), and as a result, easily and commonly\n+         *    results in cycles, being value deserializer for various Maps and Collections.\n+         *    Because of this, we must somehow break the cycles. This is done here by\n+         *    forcing pseudo-contextualization with null property.\n+         */\n+\n+        // So: first find possible custom instances\n         _mapDeserializer = _findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType));\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n         _numberDeserializer = _findCustomDeser(ctxt, tf.constructType(Number.class));\n+\n+        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n+        // their own\n+        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);\n+        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);\n+        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);\n+        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n-    \n+\n+    /**\n+     * We only use contextualization for optimizing the case where no customization\n+     * occurred; if so, can slip in a more streamlined version.\n+     */\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n                 && (_mapDeserializer == null) && (_listDeserializer == null)\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n-        }\n-        JsonDeserializer<?> mapDeserializer = ctxt.handlePrimaryContextualization(_mapDeserializer, property);\n-        JsonDeserializer<?> listDeserializer = ctxt.handlePrimaryContextualization(_listDeserializer, property);\n-        JsonDeserializer<?> stringDeserializer = ctxt.handlePrimaryContextualization(_stringDeserializer, property);\n-        JsonDeserializer<?> numberDeserializer = ctxt.handlePrimaryContextualization(_numberDeserializer, property);\n-\n-        // And if anything changed, we'll need to change too!\n-        if ((mapDeserializer != _mapDeserializer)\n-                || (listDeserializer != _listDeserializer)\n-                || (stringDeserializer != _stringDeserializer)\n-                || (numberDeserializer != _numberDeserializer)\n-                ) {\n-            return _withResolved(mapDeserializer, listDeserializer,\n-                    stringDeserializer, numberDeserializer);\n         }\n         return this;\n     }", "timestamp": 1417026349, "metainfo": ""}