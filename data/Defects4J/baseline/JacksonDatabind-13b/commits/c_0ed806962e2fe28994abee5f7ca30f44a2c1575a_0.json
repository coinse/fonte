{"sha": "0ed806962e2fe28994abee5f7ca30f44a2c1575a", "log": "Merge pull request #598 from herau/597  fix NPE #597", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n                     } catch (Exception e) {\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         bean = null; // never gets here\n+                    }\n+                    if (bean == null) {\n+                        throw ctxt.instantiationException(_beanType.getRawClass(), \" the created object is null\");\n                     }\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestNpe597.java\n+package com.fasterxml.jackson.failing;\n+\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+public class TestNpe597 extends BaseMapTest\n+{\n+\n+    static class JsonEntity {\n+        private final String type;\n+        private final UUID id;\n+\n+        private JsonEntity(String type, UUID id) {\n+            this.type = type;\n+            this.id = id;\n+        }\n+\n+        @JsonCreator\n+        public static JsonEntity create(@JsonProperty(\"type\") String type, @JsonProperty(\"id\") UUID id) {\n+            if (type != null && !type.contains(\" \") && (id != null)) {\n+                return new JsonEntity(type, id);\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n+    public void testDeserialize() throws IOException {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        String json = \"{ \\\"type\\\" : \\\"     \\\", \\\"id\\\" : \\\"000c0ffb-a0d6-4d2e-a379-4aeaaf283599\\\" }\";\n+        objectMapper.readValue(json, JsonEntity.class);\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -3010349050434697698L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final JavaType _baseType;\n \n     /**********************************************************\n      */\n     \n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Finally, we may have to consider possibility of custom handlers for\n          * these values: but for now this should work ok.\n          */\n-        /* 21-Sep-2013, tatu: It may seem odd that I'm not using a switch here.\n-         *   But turns out that a switch on an enum generates an inner class...\n-         *   crazy! So this is to avoid that, simply since new class weighs about 1kB\n-         *   after compression.\n-         */\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t.isScalarValue()) {\n-            if (t == JsonToken.VALUE_STRING) {\n-                if (_acceptString) {\n-                    return jp.getText();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (_acceptInt) {\n-                    return jp.getIntValue();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                if (_acceptDouble) {\n-                    return Double.valueOf(jp.getDoubleValue());\n-                }\n-            } else if (t == JsonToken.VALUE_TRUE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.TRUE;\n-                }\n-            } else if (t == JsonToken.VALUE_FALSE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.FALSE;\n-                }\n-            }\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case JsonTokenId.ID_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case JsonTokenId.ID_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n         }\n         return null;\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);", "timestamp": 1415122222, "metainfo": ""}