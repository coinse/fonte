{"sha": "b342798a24693735d734b25896191a768ccca16f", "log": "Merge pull request #282 from cheddar/funky_polymorphic_serde  Jackson tries to deserialize the interface instead of the concrete class requested", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestPolymorphicDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ */\n+public class TestPolymorphicDeserialization extends BaseMapTest\n+{\n+  @Test\n+  public void testName() throws Exception\n+  {\n+    ObjectMapper mapper = objectMapper();\n+\n+    Assert.assertEquals(\"A\", mapper.readValue(\"{\\\"type\\\": \\\"a\\\"}\", SomeInterface.class).get());\n+    Assert.assertEquals(\"A\", mapper.readValue(\"{}\", SomeInterface.class).get());\n+    Assert.assertEquals(\"B\", mapper.readValue(\"{\\\"type\\\": \\\"b\\\"}\", SomeInterface.class).get());\n+    Assert.assertEquals(\"A\", mapper.readValue(\"{\\\"type\\\": \\\"c\\\"}\", SomeInterface.class).get());\n+\n+    Assert.assertEquals(\"A\", mapper.readValue(\"{\\\"type\\\": \\\"a\\\"}\", ClassA.class).get());\n+    Assert.assertEquals(\"B\", mapper.readValue(\"{\\\"type\\\": \\\"b\\\"}\", ClassB.class).get());\n+    Assert.assertEquals(\"C\", mapper.readValue(\"{\\\"type\\\": \\\"c\\\"}\", ClassC.class).get());\n+  }\n+\n+  @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = ClassA.class)\n+  @JsonSubTypes({\n+          @JsonSubTypes.Type(name = \"a\", value = ClassA.class),\n+          @JsonSubTypes.Type(name = \"b\", value = ClassB.class)\n+  })\n+  public static interface SomeInterface\n+  {\n+    public String get();\n+  }\n+\n+  public static class ClassA implements SomeInterface\n+  {\n+    @Override\n+    public String get()\n+    {\n+      return \"A\";\n+    }\n+  }\n+\n+  public static class ClassB implements SomeInterface\n+  {\n+    @Override\n+    public String get()\n+    {\n+      return \"B\";\n+    }\n+  }\n+\n+  public static class ClassC implements SomeInterface\n+  {\n+    @Override\n+    public String get()\n+    {\n+      return \"C\";\n+    }\n+  }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n     public void serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException\n     {\n-        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        Class<?> cls = value.getClass();\n+        // true, since we do want to cache root-level typed serializers (ditto for null property)\n+        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n+\n+        // Ok: should we wrap result in an additional property (\"root name\")?\n         final boolean wrap;\n-\n-        if (value == null) { // no type provided; must just use the default null serializer\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false; // no name to use for wrapping; can't do!\n-        } else {\n-            Class<?> cls = value.getClass();\n-            // true, since we do want to cache root-level typed serializers (ditto for null property)\n-            ser = findTypedValueSerializer(cls, true, null);\n-\n-            // Ok: should we wrap result in an additional property (\"root name\")?\n-            String rootName = _config.getRootName();\n-            if (rootName == null) { // not explicitly specified\n-                // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-                if (wrap) {\n-                    jgen.writeStartObject();\n-                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n-                }\n-            } else if (rootName.length() == 0) {\n-                wrap = false;\n-            } else { // [JACKSON-764]\n-                // empty String means explicitly disabled; non-empty that it is enabled\n-                wrap = true;\n+        String rootName = _config.getRootName();\n+        if (rootName == null) { // not explicitly specified\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(rootName);\n-            }\n+                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else { // [JACKSON-764]\n+            // empty String means explicitly disabled; non-empty that it is enabled\n+            wrap = true;\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(rootName);\n         }\n         try {\n             ser.serialize(value, jgen, this);\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonGenerationException\n     {\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        // Let's ensure types are compatible at this point\n+        if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+            _reportIncompatibleRootType(value, rootType);\n+        }\n+        // root value, not reached via property:\n+        JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n+\n+        // Ok: should we wrap result in an additional property (\"root name\")?\n         final boolean wrap;\n-\n-        JsonSerializer<Object> ser;\n-        if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                _reportIncompatibleRootType(value, rootType);\n-            }\n-            // root value, not reached via property:\n-            ser = findTypedValueSerializer(rootType, true, null);\n+        String rootName = _config.getRootName();\n+        if (rootName == null) { // not explicitly specified\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n+                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else { // [JACKSON-764]\n+            // empty String means explicitly disabled; non-empty that it is enabled\n+            wrap = true;\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(rootName);\n         }\n         try {\n             ser.serialize(value, jgen, this);\n             JsonSerializer<Object> ser)\n         throws IOException, JsonGenerationException\n     {\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        // Let's ensure types are compatible at this point\n+        if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+            _reportIncompatibleRootType(value, rootType);\n+        }\n+        // root value, not reached via property:\n+        if (ser == null) {\n+            ser = findTypedValueSerializer(rootType, true, null);\n+        }\n+        // Ok: should we wrap result in an additional property (\"root name\")?\n         final boolean wrap;\n-\n-        if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (rootType != null) {\n-                if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                    _reportIncompatibleRootType(value, rootType);\n-                }\n-            }\n-            // root value, not reached via property:\n-            if (ser == null) {\n-                ser = findTypedValueSerializer(rootType, true, null);\n-            }\n+        String rootName = _config.getRootName();\n+        if (rootName == null) { // not explicitly specified\n+            // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n+                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else { // [JACKSON-764]\n+            // empty String means explicitly disabled; non-empty that it is enabled\n+            wrap = true;\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(rootName);\n         }\n         try {\n             ser.serialize(value, jgen, this);\n             throw new JsonMappingException(msg, e);\n         }\n     }\n-    \n+\n+    /**\n+     * Helper method called when root value to serialize is null\n+     * \n+     * @since 2.3\n+     */\n+    protected void _serializeNull(JsonGenerator jgen)\n+        throws IOException, JsonGenerationException\n+    {\n+        JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n+        try {\n+            ser.serialize(null, jgen, this);\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n      * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n      * For efficient operation, let's try to minimize number of times we\n      * need to introspect root element name to use.\n      */\n-    protected LRUMap<ClassKey,SerializedString> _rootNames;\n+    protected transient LRUMap<ClassKey,SerializedString> _rootNames;\n \n     public RootNameLookup() { }\n \n         return findRootName(rootType.getRawClass(), config);\n     }\n \n-    public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n+    public SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         ClassKey key = new ClassKey(rootType);\n \n-        if (_rootNames == null) {\n-            _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n-        } else {\n-            SerializedString name = _rootNames.get(key);\n-            if (name != null) {\n-                return name;\n+        synchronized (this) {\n+            if (_rootNames == null) {\n+                _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n+            } else {\n+                SerializedString name = _rootNames.get(key);\n+                if (name != null) {\n+                    return name;\n+                }\n             }\n         }\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n             nameStr = pname.getSimpleName();\n         }\n         SerializedString name = new SerializedString(nameStr);\n-        _rootNames.put(key, name);\n+        synchronized (this) {\n+            _rootNames.put(key, name);\n+        }\n         return name;\n     }\n }", "timestamp": 1376597806, "metainfo": ""}