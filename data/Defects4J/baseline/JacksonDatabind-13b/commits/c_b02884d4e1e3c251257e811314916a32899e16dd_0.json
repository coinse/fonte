{"sha": "b02884d4e1e3c251257e811314916a32899e16dd", "log": "clean up", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * it could serialize an instance of given Class.\n      * Check is done\n      * by checking whether a serializer can be found for the type.\n+     *<p>\n+     * NOTE: since this method does NOT throw exceptions, but internal\n+     * processing may, caller usually has little information as to why\n+     * serialization would fail.\n      *\n      * @return True if mapper can find a serializer for instances of\n      *  given class (potentially serializable), false otherwise (not\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n \n     /*\n     /**********************************************************\n-    /* Managing and accessing of opaque internal settings\n-    /* (used by extensions)\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Method for accessing value of specified internal setting.\n-     * \n-     * @return Value of the setting, if any; null if none.\n-     */\n-    public Object getInternalSetting(Object key)\n-    {\n-        if (_internalSettings == null) {\n-            return null;\n-        }\n-        return _internalSettings.get(key);\n-    }\n-    \n-    /**\n-     * Method for setting specific internal setting to given value\n-     * \n-     * @return Old value of the setting, if any (null if none)\n-     */\n-    public Object setInternalSetting(Object key, Object value)\n-    {\n-        if (_internalSettings == null) {\n-            _internalSettings = new HashMap<Object,Object>();\n-        }\n-        return _internalSettings.put(key, value);\n-    }\n-\n-    /**\n-     * Method for removing entry for specified internal setting.\n-     * \n-     * @return Existing value of the setting, if any (null if none)\n-     */\n-    public Object removeInternalSetting(Object key)\n-    {\n-        Object removed = null;\n-        if (_internalSettings != null) {\n-            removed = _internalSettings.remove(key);\n-            // to reduce memory usage, let's also drop the Map itself, if empty\n-            if (_internalSettings.size() == 0) {\n-                _internalSettings = null;\n-            }\n-        }\n-        return removed;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Accessors\n-    /**********************************************************\n-     */\n-\n-    public SerializedString getSerializedName() { return _name; }\n-    \n-    public boolean hasSerializer() { return _serializer != null; }\n-    public boolean hasNullSerializer() { return _nullSerializer != null; }\n-\n-    /**\n-     * Accessor that will return true if this bean property has to support\n-     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n-     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n-     *<p>\n-     * Default implementation simply returns false.\n-     * \n-     * @since 2.3\n-     */\n-    public boolean isUnwrapping() {\n-        return false;\n-    }\n-    \n-    public boolean willSuppressNulls() { return _suppressNulls; }\n-    \n-    // Needed by BeanSerializer#getSchema\n-    public JsonSerializer<Object> getSerializer() {\n-        return _serializer;\n-    }\n-\n-    public JavaType getSerializationType() {\n-        return _cfgSerializationType;\n-    }\n-\n-    public Class<?> getRawSerializationType() {\n-        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n-    }\n-    \n-    public Class<?> getPropertyType() \n-    {\n-        if (_accessorMethod != null) {\n-            return _accessorMethod.getReturnType();\n-        }\n-        return _field.getType();\n-    }\n-\n-    /**\n-     * Get the generic property type of this property writer.\n-     *\n-     * @return The property type, or null if not found.\n-     */\n-    public Type getGenericPropertyType()\n-    {\n-        if (_accessorMethod != null) {\n-            return _accessorMethod.getGenericReturnType();\n-        }\n-        return _field.getGenericType();\n-    }\n-\n-    public Class<?>[] getViews() { return _includeInViews; }\n-\n-    /**\n-     *<p>\n-     * NOTE: due to introspection, this is a <b>slow</b> method to call\n-     * and should never be called during actual serialization or filtering\n-     * of the property. Rather it is needed for traversal needed for things\n-     * like constructing JSON Schema instances.\n-     * \n-     * @since 2.1\n-     * \n-     * @deprecated since 2.2, use {@link #isRequired()} instead.\n-     */\n-    @Deprecated\n-    protected boolean isRequired(AnnotationIntrospector intr) {\n-        return _metadata.isRequired();\n-    }\n-\n-    /*\n-    /**********************************************************\n     /* Legacy support for JsonFormatVisitable\n     /**********************************************************\n      */\n     \n     /*\n     /**********************************************************\n+    /* Managing and accessing of opaque internal settings\n+    /* (used by extensions)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing value of specified internal setting.\n+     * \n+     * @return Value of the setting, if any; null if none.\n+     */\n+    public Object getInternalSetting(Object key)\n+    {\n+        if (_internalSettings == null) {\n+            return null;\n+        }\n+        return _internalSettings.get(key);\n+    }\n+    \n+    /**\n+     * Method for setting specific internal setting to given value\n+     * \n+     * @return Old value of the setting, if any (null if none)\n+     */\n+    public Object setInternalSetting(Object key, Object value)\n+    {\n+        if (_internalSettings == null) {\n+            _internalSettings = new HashMap<Object,Object>();\n+        }\n+        return _internalSettings.put(key, value);\n+    }\n+\n+    /**\n+     * Method for removing entry for specified internal setting.\n+     * \n+     * @return Existing value of the setting, if any (null if none)\n+     */\n+    public Object removeInternalSetting(Object key)\n+    {\n+        Object removed = null;\n+        if (_internalSettings != null) {\n+            removed = _internalSettings.remove(key);\n+            // to reduce memory usage, let's also drop the Map itself, if empty\n+            if (_internalSettings.size() == 0) {\n+                _internalSettings = null;\n+            }\n+        }\n+        return removed;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    public SerializedString getSerializedName() { return _name; }\n+    \n+    public boolean hasSerializer() { return _serializer != null; }\n+    public boolean hasNullSerializer() { return _nullSerializer != null; }\n+\n+    /**\n+     * Accessor that will return true if this bean property has to support\n+     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n+     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n+     *<p>\n+     * Default implementation simply returns false.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean isUnwrapping() {\n+        return false;\n+    }\n+    \n+    public boolean willSuppressNulls() { return _suppressNulls; }\n+    \n+    // Needed by BeanSerializer#getSchema\n+    public JsonSerializer<Object> getSerializer() {\n+        return _serializer;\n+    }\n+\n+    public JavaType getSerializationType() {\n+        return _cfgSerializationType;\n+    }\n+\n+    public Class<?> getRawSerializationType() {\n+        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n+    }\n+    \n+    public Class<?> getPropertyType() \n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getReturnType();\n+        }\n+        return _field.getType();\n+    }\n+\n+    /**\n+     * Get the generic property type of this property writer.\n+     *\n+     * @return The property type, or null if not found.\n+     */\n+    public Type getGenericPropertyType()\n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getGenericReturnType();\n+        }\n+        return _field.getGenericType();\n+    }\n+\n+    public Class<?>[] getViews() { return _includeInViews; }\n+\n+    /**\n+     *<p>\n+     * NOTE: due to introspection, this is a <b>slow</b> method to call\n+     * and should never be called during actual serialization or filtering\n+     * of the property. Rather it is needed for traversal needed for things\n+     * like constructing JSON Schema instances.\n+     * \n+     * @since 2.1\n+     * \n+     * @deprecated since 2.2, use {@link #isRequired()} instead.\n+     */\n+    @Deprecated\n+    protected boolean isRequired(AnnotationIntrospector intr) {\n+        return _metadata.isRequired();\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Serialization functionality\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n      * Note that no Exceptions are thrown, including unchecked ones:\n      * implementations are to swallow exceptions if necessary.\n      */\n-    public boolean hasSerializerFor(Class<?> cls) {\n-    \ttry {\n-    \t\treturn _findExplicitUntypedSerializer(cls) != null;\n-    \t} catch (JsonMappingException e) {\n-    \t\t// usually bad practice, but here caller only asked if a serializer\n-    \t\t// could be found; for which exception is useless\n-    \t\treturn false;\n-    \t}\n+    public boolean hasSerializerFor(Class<?> cls)\n+    {\n+        try {\n+            return _findExplicitUntypedSerializer(cls) != null;\n+        } catch (JsonMappingException e) {\n+            // usually bad practice, but here caller only asked if a serializer\n+            // could be found; for which exception is useless\n+            return false;\n+        }\n     }\n \n     /*\n     public JsonSerializer<Object> serializerInstance(Annotated annotated,\n             Object serDef)\n         throws JsonMappingException\n-    \n     {\n         if (serDef == null) {\n             return null;", "timestamp": 1375503200, "metainfo": ""}