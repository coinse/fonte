{"sha": "ba0470fba09489f0fd97f2718e064b5105cafad7", "log": "Merged [JACKSON-712] fix in, with proper 2.0 changes", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n {\n     protected final JavaType _baseType;\n+\n+    // support for \"native\" types, which require special care:\n+    \n+    protected final boolean _acceptString;\n+    protected final boolean _acceptBoolean;\n+    protected final boolean _acceptInt;\n+    protected final boolean _acceptDouble;\n     \n     public AbstractDeserializer(JavaType bt)\n     {\n         _baseType = bt;\n+        Class<?> cls = bt.getRawClass();\n+        _acceptString = cls.isAssignableFrom(String.class);\n+        _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class);\n+        _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class);\n+        _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n     }\n \n     @Override\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n-        /* As per [JACKSON-417], there is a chance we might be \"native\" types (String, Boolean,\n-         * Integer), which do not include any type information...\n-         */\n-        switch (jp.getCurrentToken()) {\n-        /* First, so-called \"native\" types (ones that map\n-         * naturally and thus do not need or use type ids)\n-         */\n-        case VALUE_STRING:\n-            return jp.getText();\n-\n-        case VALUE_NUMBER_INT:\n-            // For [JACKSON-100], see above:\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n-                return jp.getBigIntegerValue();\n-            }\n-            return jp.getIntValue();\n-\n-        case VALUE_NUMBER_FLOAT:\n-            // For [JACKSON-72], see above\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                return jp.getDecimalValue();\n-            }\n-            return Double.valueOf(jp.getDoubleValue());\n-\n-        case VALUE_TRUE:\n-            return Boolean.TRUE;\n-        case VALUE_FALSE:\n-            return Boolean.FALSE;\n-        case VALUE_EMBEDDED_OBJECT:\n-            return jp.getEmbeddedObject();\n-\n-        case VALUE_NULL: // should not get this far really but...\n-            return null;\n-\n-        case START_ARRAY:\n-            /* 11-Feb-2011, tatu: Uh. Given that we know very little about the type\n-             *   here, we can't be sure but it sure looks like we must have used\n-             *   \"As.WRAPPER_ARRAY\" here. This will NOT work properly if someone\n-             *   tries to use \"As.WRAPPER_OBJECT\"; but let's tackle one issue\n-             *   at a time. See [JACKSON-485] for an example of where this fix\n-             *   is needed.\n-             */\n-            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n-\n-            /*\n-        case START_OBJECT:\n-        case FIELD_NAME:\n-             */\n+        // First: support \"natural\" values (which are always serialized without type info!)\n+        Object result = _deserializeIfNatural(jp, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n-\n-        // should we call 'fromAny' or 'fromObject'? We should get an object, for abstract types, right?\n-        // 11-Feb-2011: not necessarily; for example, when serialize Enums that implement an interface... *sigh*\n-        //return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n-\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n \n     public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n     {\n-        // no can do:\n-        throw ctxt.instantiationException(_baseType.getRawClass(), \"abstract types can only be instantiated with additional type information\");\n+        // This method should never be called...\n+        throw ctxt.instantiationException(_baseType.getRawClass(), \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n+    }\n+\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* As per [JACKSON-417], there is a chance we might be \"natular\" types\n+         * (String, Boolean, Integer, Double), which do not include any type information...\n+         * Care must be taken to only return this if return type matches, however.\n+         * Finally, we may have to consider possibility of custom handlers for\n+         * these values: but for now this should work ok.\n+         */\n+        switch (jp.getCurrentToken()) {\n+        case VALUE_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+\n+        case VALUE_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case VALUE_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n+        }\n+        return null;\n     }\n }\n+\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n  * {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer}) for converting\n  * between type and matching id; id is stored in JSON and needed for\n  * creating instances of proper subtypes when deserializing values.\n- * \n- * @since 1.5\n  */\n public interface TypeIdResolver\n {\n      * value and type, using suggested type (that serializer provides)\n      * and possibly value of that type. Most common implementation will\n      * use suggested type as is.\n-     * \n-     * @since 1.8\n      */\n     public String idFromValueAndType(Object value, Class<?> suggestedType);\n+\n+    /**\n+     * Method that can be called to figure out type id to use for instances\n+     * of base type (declared type of property). This is usually only used\n+     * for fallback handling, for cases where real type information is not\n+     * available for some reason.\n+     */\n+    public String idFromBaseType();\n     \n     /**\n      * Method called to resolve type from given type identifier.\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     private final Object _deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n+        boolean hadStartArray = jp.isExpectedStartArrayToken();\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n         Object value = deser.deserialize(jp, ctxt);\n         // And then need the closing END_ARRAY\n-        if (jp.nextToken() != JsonToken.END_ARRAY) {\n+        if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) {\n             throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY,\n                     \"expected closing END_ARRAY after type information and deserialized value\");\n         }\n         throws IOException, JsonProcessingException\n     {\n         if (!jp.isExpectedStartArrayToken()) {\n-            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY,\n-                    \"need JSON Array to contain As.WRAPPER_ARRAY type information for class \"+baseTypeName());\n+            // [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...\n+            // but should there be a way to limit this to likely success cases?\n+            if (_defaultImpl != null) {\n+                return _idResolver.idFromBaseType();\n+            }\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"need JSON Array to contain As.WRAPPER_ARRAY type information for class \"+baseTypeName());\n         }\n         // And then type id as a String\n         if (jp.nextToken() != JsonToken.VALUE_STRING) {\n-            throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING,\n-                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n+            if (_defaultImpl != null) {\n+                return _idResolver.idFromBaseType();\n+            }\n+            throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n         }\n         String result = jp.getText();\n         jp.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n             t = jp.nextToken();\n+        } else if (t == JsonToken.START_ARRAY) {\n+            /* This is most likely due to the fact that not all Java types are\n+             * serialized as JSON Objects; so if \"as-property\" inclusion is requested,\n+             * serialization of things like Lists must be instead handled as if\n+             * \"as-wrapper-array\" was requested.\n+             * But this can also be due to some custom handling: so, if \"defaultImpl\"\n+             * is defined, it will be asked to handle this case.\n+             */\n+            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);\n         } else if (t != JsonToken.FIELD_NAME) {\n-            throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.PROPERTY type information (for class \"+baseTypeName()+\")\");\n+            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);\n         }\n         // Ok, let's try to find the property. But first, need token buffer...\n         TokenBuffer tb = null;\n         return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);\n     }\n     \n-    // off-lined to keep main method lean and meand...\n+    // off-lined to keep main method lean and mean...\n     protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n             DeserializationContext ctxt, TokenBuffer tb)\n         throws IOException, JsonProcessingException\n     {\n-        // As per [JACKSON-614], may have default implement to use\n+        // As per [JACKSON-614], may have default implementation to use\n         if (_defaultImpl != null) { \n             JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n             if (tb != null) {\n             }\n             return deser.deserialize(jp, ctxt);\n         }\n-        // if not, an error\n+        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n+        Object result = _deserializeIfNatural(jp, ctxt);\n+        if (result != null) {\n+            return result;\n+        }\n+        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n+        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            return super.deserializeTypedFromAny(jp, ctxt);\n+        }\n         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                 \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n     }\n     // These are fine from base class:\n     //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n     //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n+\n+    /**\n+     * Helper method used to check if given parser might be pointing to\n+     * a \"natural\" value, and one that would be acceptable as the\n+     * result value (compatible with declared base type)\n+     */\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case VALUE_STRING:\n+            if (_baseType.getRawClass().isAssignableFrom(String.class)) {\n+                return jp.getText();\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            if (_baseType.getRawClass().isAssignableFrom(Integer.class)) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+\n+        case VALUE_NUMBER_FLOAT:\n+            if (_baseType.getRawClass().isAssignableFrom(Double.class)) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case VALUE_FALSE:\n+            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n package com.fasterxml.jackson.databind.jsontype.impl;\n-\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n \n     @Override\n     public void init(JavaType bt) {\n-        /* Standard type id resolvers do not need this;\n-         * only useful for custom ones.\n+        // Standard type id resolvers do not need this: only useful for custom ones.\n+    }\n+\n+    @Override\n+    public String idFromBaseType()\n+    {\n+        /* By default we will just defer to regular handling, handing out the\n+         * base type; and since there is no value, must just pass null here\n+         * assuming that implementations can deal with it.\n+         * Alternative would be to pass a bogus Object, but that does not seem right.\n          */\n+        return idFromValueAndType(null, _baseType.getRawClass());\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n             }\n             return null;\n         }\n+\n+        @Override\n+        public String idFromBaseType() {\n+            return \"xxx\";\n+        }\n     }\n \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n             }\n             return null;\n         }\n+\n+        @Override\n+        public String idFromBaseType() {\n+            return \"xxx\";\n+        }\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests related to [JACKSON-712]; specialized handling of\n+ * otherwise invalid type id embedding cases.\n+ */\n+public class TestTypedDeserializationWithDefault extends BaseMapTest\n+{\n+  private final ObjectMapper mapper = new ObjectMapper();\n+\n+  @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+  @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+  public static interface Inter { }\n+\n+  public static class MyInter implements Inter\n+  {\n+    @JsonProperty(\"blah\")\n+    public List<String> blah;\n+  }\n+\n+  public static class LegacyInter extends MyInter\n+  {\n+    @JsonCreator\n+    LegacyInter(Object obj)\n+    {\n+      if (obj instanceof List) {\n+        blah = new ArrayList<String>();\n+        for (Object o : (List<?>) obj) {\n+          blah.add(o.toString());\n+        }\n+      }\n+      else if (obj instanceof String) {\n+        blah = Arrays.asList(((String) obj).split(\",\"));\n+      }\n+      else {\n+        throw new IllegalArgumentException(\"Unknown type: \" + obj.getClass());\n+      }\n+    }\n+  }\n+\n+  public void testDeserializationWithObject() throws Exception\n+  {\n+    Inter inter = mapper.readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\", Inter.class);\n+\n+    assertTrue(inter instanceof MyInter);\n+    assertFalse(inter instanceof LegacyInter);\n+    assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+  }\n+\n+  public void testDeserializationWithString() throws Exception\n+  {\n+    Inter inter = mapper.readValue(\"\\\"a,b,c,d\\\"\", Inter.class);\n+\n+    assertTrue(inter instanceof LegacyInter);\n+    assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+  }\n+\n+  public void testDeserializationWithArray() throws Exception\n+  {\n+    Inter inter = mapper.readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\", Inter.class);\n+\n+    assertTrue(inter instanceof LegacyInter);\n+    assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+  }\n+\n+  public void testDeserializationWithArrayOfSize2() throws Exception\n+  {\n+    Inter inter = mapper.readValue(\"[\\\"a\\\", \\\"b\\\"]\", Inter.class);\n+\n+    assertTrue(inter instanceof LegacyInter);\n+    assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n+  }\n+}", "timestamp": 1325225645, "metainfo": ""}