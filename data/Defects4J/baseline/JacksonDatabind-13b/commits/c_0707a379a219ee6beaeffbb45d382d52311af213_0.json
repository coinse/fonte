{"sha": "0707a379a219ee6beaeffbb45d382d52311af213", "log": "minor clean up", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -3010349050434697698L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final JavaType _baseType;\n \n     /**********************************************************\n      */\n     \n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Finally, we may have to consider possibility of custom handlers for\n          * these values: but for now this should work ok.\n          */\n-        /* 21-Sep-2013, tatu: It may seem odd that I'm not using a switch here.\n-         *   But turns out that a switch on an enum generates an inner class...\n-         *   crazy! So this is to avoid that, simply since new class weighs about 1kB\n-         *   after compression.\n-         */\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t.isScalarValue()) {\n-            if (t == JsonToken.VALUE_STRING) {\n-                if (_acceptString) {\n-                    return jp.getText();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (_acceptInt) {\n-                    return jp.getIntValue();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                if (_acceptDouble) {\n-                    return Double.valueOf(jp.getDoubleValue());\n-                }\n-            } else if (t == JsonToken.VALUE_TRUE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.TRUE;\n-                }\n-            } else if (t == JsonToken.VALUE_FALSE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.FALSE;\n-                }\n-            }\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case JsonTokenId.ID_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case JsonTokenId.ID_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n         }\n         return null;\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);", "timestamp": 1415078998, "metainfo": ""}