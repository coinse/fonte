{"sha": "0688a9acc3463827ca406360a901d7526f699806", "log": "Completed initial set of refactoring to be able to solve #307 and perhaps #317", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n  * using {@link com.fasterxml.jackson.annotation.JsonFilter})\n  * for filtering bean properties to serialize.\n  *<p>\n- * Note that Jackson 2.1 added two new methods -- as a result, it is\n- * strongly recommended that custom implementations extend\n- * {@link com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter},\n- * to avoid backwards compatibility issues in future.\n+ * Starting with version 2.3 this class is deprecated; use\n+ * {@link PropertyFilter} instead.\n+ * \n+ * @deprecated Since 2.3: use {@link PropertyFilter} instead.\n  */\n+@Deprecated\n public interface BeanPropertyFilter\n {\n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/FilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/FilterProvider.java\n package com.fasterxml.jackson.databind.ser;\n \n+import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n+\n /**\n- * Interface for objects that providers instances of {@link BeanPropertyFilter}\n+ * Interface for objects that providers instances of {@link PropertyFilter}\n  * that match given ids. A provider is configured to be used during serialization,\n  * to find filter to used based on id specified by {@link com.fasterxml.jackson.annotation.JsonFilter}\n  * annotation on bean class.\n      * \n      * @return Filter registered with specified id, if one defined; null if\n      *   none found.\n+     *   \n+     * @deprecated Since 2.3 deprecated because {@link BeanPropertyFilter} is deprecated;\n      */\n+    @Deprecated\n     public abstract BeanPropertyFilter findFilter(Object filterId);\n+\n+    /**\n+     * Lookup method used to find {@link PropertyFilter} that has specified id.\n+     * Note that id is typically a {@link java.lang.String}, but is not necessarily\n+     * limited to that; that is, while standard components use String, custom\n+     * implementation can choose other kinds of keys.\n+     *<p>\n+     * This method is the replacement for {@link #findFilter} starting with 2.3.\n+     *<p>\n+     * Note that the default implementation is designed to support short-term\n+     * backwards compatibility, and will call the deprecated <code>findFilter</code>\n+     * method, then wrap filter if one found as {@link PropertyFilter}.\n+     * It should be overridden by up-to-date implementations\n+     * \n+     * @since 2.3\n+     */\n+    public PropertyFilter findPropertyFilter(Object filterId)\n+    {\n+        @SuppressWarnings(\"deprecation\")\n+        BeanPropertyFilter old = findFilter(filterId);\n+        if (old == null) {\n+            return null;\n+        }\n+        return SimpleBeanPropertyFilter.from(old);\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyFilter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Interface that defines API for filter objects use (as configured\n+ * using {@link com.fasterxml.jackson.annotation.JsonFilter})\n+ * for filtering bean properties to serialize.\n+ *<p>\n+ * Note that this is the replacement for <code>BeanPropertyFilter</code>,\n+ * which is replaced because it was too closely bound to Bean properties\n+ * and would not work with {@link java.util.Map}s or \"any getters\".\n+ *<p>\n+ * Note that since this is an interface, it is\n+ * strongly recommended that custom implementations extend\n+ * {@link com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter},\n+ * to avoid backwards compatibility issues in case interface needs to change.\n+ * \n+ * @since 2.3\n+ */\n+public interface PropertyFilter\n+{\n+    /**\n+     * Method called by {@link BeanSerializer} to let filter decide what to do with\n+     * given bean property value: the usual choices are to either filter out (i.e.\n+     * do nothing) or write using given {@link BeanPropertyWriter}, although filters\n+     * can choose other to do something different altogether.\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.serializeAsField(pojo, jgen, prov);\n+     * }\n+     *</pre>\n+     * \n+     * @param pojo Object that contains property value to serialize\n+     * @param jgen Generator use for serializing value\n+     * @param prov Provider that can be used for accessing dynamic aspects of serialization\n+     *    processing\n+     * @param writer Default bean property serializer to use\n+     */\n+    public void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov,\n+            PropertyWriter writer)\n+        throws Exception;\n+    \n+    /**\n+     * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n+     * form the given property exist within the parent, or root, schema. Filters can omit\n+     * adding the property to the node, or choose the form of the schema value for the property.\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(propertiesNode, provider);\n+     * }\n+     *</pre>\n+     * \n+     * @param writer Bean property writer to use to create schema value\n+     * @param propertiesNode Node which the given property would exist within\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     * \tprocessing\n+     * \n+     * @deprecated Since 2.3: new code should use the alternative <code>depositSchemaProperty</code>\n+     *   method\n+     */\n+    @Deprecated\n+    public void depositSchemaProperty(PropertyWriter writer, ObjectNode propertiesNode,\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n+     * form the given property exist within the parent, or root, schema. Filters can omit\n+     * adding the property to the node, or choose the form of the schema value for the property\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(objectVisitor, provider);\n+     * }\n+     *</pre>\n+     * \n+     * @param writer Bean property serializer to use to create schema value\n+     * @param objectVisitor JsonObjectFormatVisitor which should be aware of \n+     * the property's existence\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     * \tprocessing\n+     */\n+    public void depositSchemaProperty(PropertyWriter writer, JsonObjectFormatVisitor objectVisitor,\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.databind.ser.*;\n \n /**\n- * Simple {@link BeanPropertyFilter} implementation that only uses property name\n+ * Simple {@link PropertyFilter} implementation that only uses property name\n  * to determine whether to serialize property as is, or to filter it out.\n  *<p>\n  * Use of this class as the base implementation for any custom\n- * {@link BeanPropertyFilter} implementations is strongly encouraged,\n+ * {@link PropertyFilter} implementations is strongly encouraged,\n  * because it can provide default implementation for any methods that may\n- * be added in {@link BeanPropertyFilter} (as unfortunate as additions may be).\n+ * be added in {@link PropertyFilter} (as unfortunate as additions may be).\n  */\n+@SuppressWarnings(\"deprecation\")\n public abstract class SimpleBeanPropertyFilter\n-    implements BeanPropertyFilter // sub-classes must also implement java.io.Serializable\n+    implements BeanPropertyFilter, PropertyFilter\n+        // sub-classes must also implement java.io.Serializable\n {\n     /*\n     /**********************************************************\n         return new SerializeExceptFilter(properties);\n     }\n \n+    /**\n+     * Helper method to ease transition from {@link BeanPropertyWriter} into\n+     * {@link PropertyWriter}\n+     * \n+     * @since 2.3\n+     */\n+    public static PropertyFilter from(final BeanPropertyFilter src)\n+    {\n+        return new PropertyFilter() {\n+            @Override\n+            public void serializeAsField(Object pojo, JsonGenerator jgen,\n+                    SerializerProvider prov, PropertyWriter writer)\n+                throws Exception {\n+                src.serializeAsField(pojo, jgen, prov, (BeanPropertyWriter) writer);\n+            }\n+\n+            @Deprecated\n+            @Override\n+            public void depositSchemaProperty(PropertyWriter writer,\n+                    ObjectNode propertiesNode, SerializerProvider provider)\n+                throws JsonMappingException {\n+                src.depositSchemaProperty((BeanPropertyWriter) writer, propertiesNode, provider);\n+            }\n+\n+            @Override\n+            public void depositSchemaProperty(PropertyWriter writer,\n+                    JsonObjectFormatVisitor objectVisitor,\n+                SerializerProvider provider) throws JsonMappingException {\n+                src.depositSchemaProperty((BeanPropertyWriter) writer, objectVisitor, provider);\n+            }\n+            \n+        };\n+    }\n+\n     /*\n     /**********************************************************\n     /* Methods for sub-classes\n      */\n     protected abstract boolean include(BeanPropertyWriter writer);\n \n+    /**\n+     * @since 2.3\n+     */\n+    protected abstract boolean include(PropertyWriter writer);\n+\n+    /*\n+    /**********************************************************\n+    /* BeanPropertyFilter implementation\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public void serializeAsField(Object bean, JsonGenerator jgen,\n             SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n     public void depositSchemaProperty(BeanPropertyWriter writer,\n             JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n         throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(objectVisitor);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyFilter implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+            SerializerProvider provider, PropertyWriter writer)\n+        throws Exception\n+    {\n+        if (include(writer)) {\n+            writer.serializeAsField(pojo, jgen, provider);\n+        } else if (!jgen.canOmitFields()) { // since 2.3\n+            writer.serializeAsOmittedField(pojo, jgen, provider);\n+        }\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public void depositSchemaProperty(PropertyWriter writer,\n+            ObjectNode propertiesNode, SerializerProvider provider)\n+            throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(propertiesNode, provider);\n+        }\n+    }\n+\n+    @Override\n+    public void depositSchemaProperty(PropertyWriter writer,\n+            JsonObjectFormatVisitor objectVisitor,\n+            SerializerProvider provider) throws JsonMappingException \n     {\n         if (include(writer)) {\n             writer.depositSchemaProperty(objectVisitor);\n         protected boolean include(BeanPropertyWriter writer) {\n             return _propertiesToInclude.contains(writer.getName());\n         }\n+\n+        @Override\n+        protected boolean include(PropertyWriter writer) {\n+            return _propertiesToInclude.contains(writer.getName());\n+        }\n     }\n \n     /**\n         protected boolean include(BeanPropertyWriter writer) {\n             return !_propertiesToExclude.contains(writer.getName());\n         }\n+\n+        @Override\n+        protected boolean include(PropertyWriter writer) {\n+            return !_propertiesToExclude.contains(writer.getName());\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n /**\n  * Simple {@link FilterProvider} implementation that just stores\n  * direct id-to-filter mapping.\n+ *<p>\n+ * Note that version 2.3 was a partial rewrite, now that\n+ * {@link PropertyFilter} is set to replace <code>BeanPropertyFilter</code>.\n  */\n public class SimpleFilterProvider\n     extends FilterProvider\n     implements java.io.Serializable // since 2.1\n {\n-    // generated for 2.1.0\n-    private static final long serialVersionUID = -2825494703774121220L;\n+    // for 2.3.0\n+    private static final long serialVersionUID = -6305772546718366447L;\n \n     /**\n      * Mappings from ids to filters.\n      */\n-    protected final Map<String,BeanPropertyFilter> _filtersById;\n+    protected final Map<String,PropertyFilter> _filtersById;\n \n     /**\n      * This is the filter we return in case no mapping was found for\n      * given id; default is 'null' (in which case caller typically\n      * reports an error), but can be set to an explicit filter.\n      */\n-    protected BeanPropertyFilter _defaultFilter;\n+    protected PropertyFilter _defaultFilter;\n \n     /**\n      * Flag that indicates whether request for an unknown filter id should\n      */\n     \n     public SimpleFilterProvider() {\n-        this(new HashMap<String,BeanPropertyFilter>());\n+        this(new HashMap<String,Object>());\n     }\n \n     /**\n-     * @param mapping Mapping from id to filter; used as is, no copy is made.\n+     * @param mapping Mapping from id to filter; used as is if if possible\n      */\n-    public SimpleFilterProvider(Map<String,BeanPropertyFilter> mapping) {\n-        _filtersById = mapping;\n+    @SuppressWarnings(\"unchecked\")\n+    public SimpleFilterProvider(Map<String,?> mapping)\n+    {\n+        /* 16-Oct-2013, tatu: Since we can now be getting both new and old\n+         *   obsolete filters (PropertyFilter vs BeanPropertyFilter), need\n+         *   to verify contents.\n+         */\n+        for (Object ob : mapping.values()) {\n+            if (!(ob instanceof PropertyFilter)) {\n+                _filtersById = _convert(mapping);\n+                return;\n+            }\n+        }\n+        _filtersById = (Map<String,PropertyFilter>) mapping;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private final static Map<String,PropertyFilter> _convert(Map<String,?> filters)\n+    {\n+        HashMap<String,PropertyFilter> result = new HashMap<String,PropertyFilter>();\n+        for (Map.Entry<String, ?> entry : filters.entrySet()) {\n+            Object f = entry.getValue();\n+            if (f instanceof PropertyFilter) {\n+                result.put(entry.getKey(), (PropertyFilter) f);\n+            } else if (f instanceof BeanPropertyFilter) {\n+                result.put(entry.getKey(), _convert((BeanPropertyFilter) f));\n+            } else {\n+                throw new IllegalArgumentException(\"Unrecognized filter type (\"+f.getClass().getName()+\")\");\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\") \n+    private final static PropertyFilter _convert(BeanPropertyFilter f) {\n+        return SimpleBeanPropertyFilter.from((BeanPropertyFilter) f);   \n     }\n     \n     /**\n      * where there is no mapping from given id to an explicit filter.\n      * \n      * @param f Filter to return when no filter is found for given id\n+     * \n+     * @deprecated Since 2.3 should use {@link PropertyFilter} instead of {@link BeanPropertyFilter}\n      */\n+    @Deprecated\n     public SimpleFilterProvider setDefaultFilter(BeanPropertyFilter f)\n+    {\n+        _defaultFilter = SimpleBeanPropertyFilter.from(f);\n+        return this;\n+    }\n+\n+    public SimpleFilterProvider setDefaultFilter(PropertyFilter f)\n     {\n         _defaultFilter = f;\n         return this;\n     }\n \n-    public BeanPropertyFilter getDefaultFilter() {\n+    /**\n+     * Overloaded variant just to resolve \"ties\" when using {@link SimpleBeanPropertyFilter}.\n+     */\n+    public SimpleFilterProvider setDefaultFilter(SimpleBeanPropertyFilter f)\n+    {\n+        _defaultFilter = f;\n+        return this;\n+    }\n+    \n+    public PropertyFilter getDefaultFilter() {\n         return _defaultFilter;\n     }\n     \n     public boolean willFailOnUnknownId() {\n         return _cfgFailOnUnknownId;\n     }\n-    \n+\n+    /**\n+     * @deprecated since 2.3\n+     */\n+    @Deprecated\n     public SimpleFilterProvider addFilter(String id, BeanPropertyFilter filter) {\n+        _filtersById.put(id, _convert(filter));\n+        return this;\n+    }\n+\n+    public SimpleFilterProvider addFilter(String id, PropertyFilter filter) {\n         _filtersById.put(id, filter);\n         return this;\n     }\n \n-    public BeanPropertyFilter removeFilter(String id) {\n+    /**\n+     * Overloaded variant just to resolve \"ties\" when using {@link SimpleBeanPropertyFilter}.\n+     */\n+    public SimpleFilterProvider addFilter(String id, SimpleBeanPropertyFilter filter) {\n+        _filtersById.put(id, filter);\n+        return this;\n+    }\n+    \n+    public PropertyFilter removeFilter(String id) {\n         return _filtersById.remove(id);\n     }\n \n     /* Public lookup API\n     /**********************************************************\n      */\n-    \n+\n+    @Deprecated // since 2.3\n     @Override\n     public BeanPropertyFilter findFilter(Object filterId)\n     {\n-        BeanPropertyFilter f = _filtersById.get(filterId);\n+        throw new UnsupportedOperationException(\"Access to deprecated filters not supported\");\n+    }\n+    \n+    @Override\n+    public PropertyFilter findPropertyFilter(Object filterId)\n+    {\n+        PropertyFilter f = _filtersById.get(filterId);\n         if (f == null) {\n             f = _defaultFilter;\n             if (f == null && _cfgFailOnUnknownId) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n \n     /**\n      * Alternative serialization method that gets called when there is a\n-     * {@link BeanPropertyFilter} that needs to be called to determine\n+     * {@link PropertyFilter} that needs to be called to determine\n      * which properties are to be serialized (and possibly how)\n      */\n     protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen,\n         } else {\n             props = _props;\n         }\n-        final BeanPropertyFilter filter = findFilter(provider);\n+        final PropertyFilter filter = findFilter(provider);\n         // better also allow missing filter actually..\n         if (filter == null) {\n             serializeFields(bean, jgen, provider);\n      * Helper method used to locate filter that is needed, based on filter id\n      * this serializer was constructed with.\n      */\n-    protected BeanPropertyFilter findFilter(SerializerProvider provider)\n+    protected PropertyFilter findFilter(SerializerProvider provider)\n         throws JsonMappingException\n     {\n         final Object filterId = _propertyFilterId;\n         FilterProvider filters = provider.getFilterProvider();\n         // Not ok to miss the provider, if a filter is declared to be needed.\n         if (filters == null) {\n-            throw new JsonMappingException(\"Can not resolve BeanPropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n-        }\n-        BeanPropertyFilter filter = filters.findFilter(filterId);\n+            throw new JsonMappingException(\"Can not resolve PropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n+        }\n+        PropertyFilter filter = filters.findPropertyFilter(filterId);\n         // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n         return filter;\n     }\n         //todo: should the classname go in the title?\n         //o.put(\"title\", _className);\n         ObjectNode propertiesNode = o.objectNode();\n-        final BeanPropertyFilter filter;\n+        final PropertyFilter filter;\n         if (_propertyFilterId != null) {\n             filter = findFilter(provider);\n         } else {\n             return;\n         }\n         if (_propertyFilterId != null) {\n-            BeanPropertyFilter filter = findFilter(visitor.getProvider());\n+            PropertyFilter filter = findFilter(visitor.getProvider());\n             for (int i = 0; i < _props.length; i++) {\n                 filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());\n             }", "timestamp": 1381984537, "metainfo": ""}