{"sha": "96c6fb0b89c3ce1cfffb02e05d125cab4582be4b", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n                 PropertyName pn = ai.findNameForDeserialization(param);\n                 String name = (pn == null) ? null : pn.getSimpleName();\n                 // is it legal not to have name?\n-                if (name != null) {\n+                if (name != null && name.length() > 0) {\n                     // shouldn't need to worry about @JsonIgnore (no real point, so)\n                     POJOPropertyBuilder prop = _property(name);\n-                    // 28-Mar-2014, tatu: for now, all names considered explicit\n+                    // 28-Mar-2014, tatu: for now, all creator names considered explicit;\n+                    //    may need to change for JDK 8 where implicit names exist\n                     prop.addCtor(param, name, true, true, false);\n                     _creatorProperties.add(prop);\n                 }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.Map;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n         }\n         return chain1.append(chain2);\n     }\n+\n+    // // Deprecated variants that do not take 'explName': to be removed in a later version\n+    // // (but are used at least by 2.3 and earlier versions of Scala module at least so\n+    // // need to be careful with phasing out if before 3.0)\n+    \n+    /**\n+     * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n+     *   whether name of property was provided by annotation (and not derived from accessor name);\n+     *   this method simply passes 'true' for it.\n+     */\n+    @Deprecated\n+    public void addField(AnnotatedField a, String name, boolean visible, boolean ignored) {\n+        addField(a, name, true, visible, ignored);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n+     *   whether name of property was provided by annotation (and not derived from accessor name);\n+     *   this method simply passes 'true' for it.\n+     */\n+    @Deprecated\n+    public void addCtor(AnnotatedParameter a, String name, boolean visible, boolean ignored) {\n+        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, true, visible, ignored);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n+     *   whether name of property was provided by annotation (and not derived from accessor name);\n+     *   this method simply passes 'true' for it.\n+     */\n+    @Deprecated\n+    public void addGetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n+        _getters = new Linked<AnnotatedMethod>(a, _getters, name, true, visible, ignored);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n+     *   whether name of property was provided by annotation (and not derived from accessor name);\n+     *   this method simply passes 'true' for it.\n+     */\n+    @Deprecated\n+    public void addSetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n+        _setters = new Linked<AnnotatedMethod>(a, _setters, name, true, visible, ignored);\n+    }\n     \n     /*\n     /**********************************************************\n      * should be renamed from the implicit name; and also verify that there\n      * are no conflicting rename definitions.\n      */\n+//    public Map<String,POJOPropertyBuilder> findRenamed()\n     public String findNewName()\n     {\n+//        Map<String,POJOPropertyBuilder> renamed = null;\n         Linked<? extends AnnotatedMember> renamed = null;\n         renamed = findRenamed(_fields, renamed);\n         renamed = findRenamed(_getters, renamed);\n             Linked<? extends AnnotatedMember> renamed)\n     {\n         for (; node != null; node = node.next) {\n+            if (!node.isNameExplicit) {\n+                continue;\n+            }\n             String name = node.name;\n-            if (name == null) {\n-                continue;\n-            }\n             // different from default name?\n             /* 14-Mar-2014, tatu: As per [#369], Must match local name... but,\n              *   shouldn't really exclude namespace. Not sure what's the best\n              *   fix but for now, let's not worry about that.\n-             * \n              */\n             if (name.equals(_name.getSimpleName())) { // nope, skip\n                 continue;\n             next = n;\n             // ensure that we'll never have missing names\n             this.name = (name == null || name.length() == 0) ? null : name;\n+            \n             isNameExplicit = explName;\n             isVisible = visible;\n             isMarkedIgnored = ignored;\n         \n         @Override\n         public String toString() {\n-            String msg = value.toString()+\"[visible=\"+isVisible+\"]\";\n+            String msg = value.toString()+\"[visible=\"+isVisible+\",ignore=\"+isMarkedIgnored\n+                    +\",explicitName=\"+isNameExplicit+\"]\";\n             if (next != null) {\n                 msg = msg + \", \"+next.toString();\n             }", "timestamp": 1396232645, "metainfo": ""}