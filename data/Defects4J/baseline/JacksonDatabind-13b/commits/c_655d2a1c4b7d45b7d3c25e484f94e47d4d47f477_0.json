{"sha": "655d2a1c4b7d45b7d3c25e484f94e47d4d47f477", "log": "Minor improvements to MappingIterator, preparing for sub-classability (initially for CSV)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n         try {\n             return hasNextValue();\n         } catch (JsonMappingException e) {\n-            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+            return _handleMappingException(e);\n         } catch (IOException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-    }\n-\n+            return _handleIOException(e);\n+        }\n+    }\n+    \n     @Override\n     public T next()\n     {\n     \n     @Override\n     public void close() throws IOException{\n-        if(_parser != null) {\n+        if (_parser != null) {\n             _parser.close();\n         }\n     }\n         // caller should always call 'hasNext[Value]' first; but let's ensure:\n         if (!_hasNextChecked) {\n             if (!hasNextValue()) {\n-                throw new NoSuchElementException();\n+                return _throwNoSuchElement();\n             }\n         }\n         if (_parser == null) {\n-            throw new NoSuchElementException();\n+            return _throwNoSuchElement();\n         }\n         _hasNextChecked = false;\n         T result;\n \n     /**\n      * Convenience method for reading all entries accessible via\n-     * this iterator\n+     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n      * \n      * @return List of entries read\n      * \n      * \n      * @since 2.2\n      */\n-    public List<T> readAll(List<T> resultList) throws IOException\n+    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n     {\n         while (hasNextValue()) {\n-    \t\t    resultList.add(nextValue());\n+            resultList.add(nextValue());\n         }\n         return resultList;\n+    }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @since 2.5\n+     */\n+    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n+    {\n+        while (hasNextValue()) {\n+            results.add(nextValue());\n+        }\n+        return results;\n     }\n     \n     /*\n     public JsonLocation getCurrentLocation() {\n         return _parser.getCurrentLocation();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected <R> R _throwNoSuchElement() {\n+        throw new NoSuchElementException();\n+    }\n+    \n+    protected <R> R _handleMappingException(JsonMappingException e) {\n+        throw new RuntimeJsonMappingException(e.getMessage(), e);\n+    }\n+\n+    protected <R> R _handleIOException(IOException e) {\n+        throw new RuntimeException(e.getMessage(), e);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * Convenience method for constructing {@link ObjectWriter}\n      * with default settings.\n      */\n-    public ObjectWriter writer() {\n-        return _newWriter(getSerializationConfig());\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer() {\n+        return (W) _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature feature) {\n-        return _newWriter(getSerializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature feature) {\n+        return (W) _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return _newWriter(getSerializationConfig().with(first, other));\n+        return (W) _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n      */\n-    public ObjectWriter writer(DateFormat df) {\n-        return _newWriter(getSerializationConfig().with(df));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(DateFormat df) {\n+        return (W) _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified JSON View (filter).\n      */\n-    public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return _newWriter(getSerializationConfig().withView(serializationView));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithView(Class<?> serializationView) {\n+        return (W) _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * runtime type of value. Type must be a super-type of runtime\n      * type.\n      */\n-    public ObjectWriter writerWithType(Class<?> rootType) {\n-        return _newWriter(getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithType(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n-    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return _newWriter(getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithType(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n-    public ObjectWriter writerWithType(JavaType rootType) {\n-        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithType(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n      * serialize objects using specified pretty printer for indentation\n      * (or if null, no pretty printer)\n      */\n-    public ObjectWriter writer(PrettyPrinter pp) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(PrettyPrinter pp) {\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n+        return (W) _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using the default pretty printer for indentation\n      */\n-    public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return _newWriter(getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithDefaultPrettyPrinter() {\n+        return (W) _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified filter provider.\n      */\n-    public ObjectWriter writer(FilterProvider filterProvider) {\n-        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FilterProvider filterProvider) {\n+        return (W) _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      * \n      * @param schema Schema to pass to generator\n      */\n-    public ObjectWriter writer(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return _newWriter(getSerializationConfig(), schema);\n+        return (W) _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return _newWriter(getSerializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(Base64Variant defaultBase64) {\n+        return (W) _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(CharacterEscapes escapes) {\n-        return _newWriter(getSerializationConfig()).with(escapes);\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(CharacterEscapes escapes) {\n+        return (W) _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(ContextAttributes attrs) {\n-        return _newWriter(getSerializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(ContextAttributes attrs) {\n+        return (W) _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*\n      * default settings. Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader() {\n-        return _newReader(getDeserializationConfig()).with(_injectableValues);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader() {\n+        return (T) _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature feature) {\n-        return _newReader(getDeserializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature feature) {\n+        return (T) _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return _newReader(getDeserializationConfig().with(first, other));\n+        return (T) _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n+        return (T) _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type) {\n-        return _newReader(getDeserializationConfig(), type, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JavaType type) {\n+        return (T) _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type) {\n-        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Class<?> type) {\n+        return (T) _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type) {\n-        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(TypeReference<?> type) {\n+        return (T)_newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f) {\n-        return _newReader(getDeserializationConfig()).with(f);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JsonNodeFactory f) {\n+        return (T) _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      * \n      * @param schema Schema to pass to parser\n      */\n-    public ObjectReader reader(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return _newReader(getDeserializationConfig(), null, null,\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * \n      * @param injectableValues Injectable values to use\n      */\n-    public ObjectReader reader(InjectableValues injectableValues) {\n-        return _newReader(getDeserializationConfig(), null, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(InjectableValues injectableValues) {\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * deserialize objects using specified JSON View (filter).\n      */\n-    public ObjectReader readerWithView(Class<?> view) {\n-        return _newReader(getDeserializationConfig().withView(view));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerWithView(Class<?> view) {\n+        return (T) _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectReader reader(Base64Variant defaultBase64) {\n-        return _newReader(getDeserializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Base64Variant defaultBase64) {\n+        return (T) _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectReader reader(ContextAttributes attrs) {\n-        return _newReader(getDeserializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(ContextAttributes attrs) {\n+        return (T) _newReader(getDeserializationConfig().with(attrs));\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         _unwrapRoot = config.useRootWrapping();\n         _dataFormatReaders = base._dataFormatReaders;\n     }\n-\n+    \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n     {\n         // may need to override ordering, based on data format capabilities\n--- a/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n \n     static class Bean {\n         public int a;\n-    }\n-    \n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests; root-level value sequences via Mapper\n     public void testRootBeans() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n-\n-        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n         assertTrue(it.hasNext());\n         Bean b = it.next();\n         assertEquals(3, b.a);\n         b = it.next();\n         assertEquals(27, b.a);\n         assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(3, set.iterator().next().a);\n     }\n \n     public void testRootMaps() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n         result = writeAndMap(mapper2, bean);\n         assertEquals(2, result.size());\n         ObjectMapper mapper3 = mapper2.copy();\n-        mapper3.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper3.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper3, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));", "timestamp": 1414646947, "metainfo": ""}