{"sha": "52313b8e56ce4b54821dcd78129151d7a45497eb", "log": "Merge pull request #387 from yinzara/master  Requested changes for new UNWRAP_SINGLE_VALUE_ARRAYS DeserializationFeature", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * values to the corresponding value type.  This is basically the opposite of the {@link #ACCEPT_SINGLE_VALUE_AS_ARRAY}\n      * feature.  If more than one value is found in the array, a JsonMappingException is thrown.\n      * <p>\n-     * Feature is disabled by default.\n-     * \n+     * \n+     * Feature is disabled by default\n      * @since 2.4\n      */\n     UNWRAP_SINGLE_VALUE_ARRAYS(false),\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n                             );\n                 }\n                 return value;\n-            } else if (t == JsonToken.VALUE_NULL && !_valueClass.isPrimitive()) {\n-                //Issue#unreported\n-                //  This handles the case where the value required is the Character wrapper class and the token is the null token\n-                return getEmptyValue();\n             }\n             throw ctxt.mappingException(_valueClass, t);\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n     final static class FloatBean {\n         float _v;\n         void setV(float v) { _v = v; }\n+    }\n+    \n+    final static class CharacterBean {\n+        char _v;\n+        void setV(char v) { _v = v; }\n+        char getV() { return _v; }\n+    }\n+    \n+    final static class CharacterWrapperBean {\n+        Character _v;\n+        void setV(Character v) { _v = v; }\n+        Character getV() { return _v; }\n     }\n \n     /**\n         // But can also pass in ascii code\n         result = MAPPER.readValue(new StringReader(\" \"+((int) 'X')), Character.class);\n         assertEquals(Character.valueOf('X'), result);\n+        \n+        final CharacterWrapperBean wrapper = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), CharacterWrapperBean.class);\n+        assertNotNull(wrapper);\n+        assertNull(wrapper.getV());\n+        \n+        final ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);\n+            mapper.readValue(\"{\\\"v\\\":null}\", CharacterBean.class);\n+            fail(\"Attempting to deserialize a 'null' JSON reference into a 'char' property did not throw an exception\");\n+        } catch (JsonMappingException exp) {\n+            //Exception thrown as required\n+        }\n+        \n+        mapper.disable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);  \n+        final CharacterBean charBean = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), CharacterBean.class);\n+        assertNotNull(wrapper);\n+        assertEquals('\\u0000', charBean.getV());\n     }\n \n     public void testIntWrapper() throws Exception\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n         return mappingException(targetClass, _parser.getCurrentToken());\n     }\n \n-    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)\n-    {\n-        String clsName = _calcName(targetClass);\n-        return JsonMappingException.from(_parser,\n-                \"Can not deserialize instance of \"+clsName+\" out of \"+token+\" token\");\n+    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {\n+        return JsonMappingException.from(_parser, \"Can not deserialize instance of \"+_calcName(targetClass)+\" out of \"+token+\" token\");\n     }\n     \n     /**\n      * to indicate problem with physically constructing instance of\n      * specified class (missing constructor, exception from constructor)\n      */\n-    public JsonMappingException instantiationException(Class<?> instClass, Throwable t)\n-    {\n+    public JsonMappingException instantiationException(Class<?> instClass, Throwable t) {\n         return JsonMappingException.from(_parser,\n-                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(),\n-                t);\n+                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(), t);\n     }\n \n     public JsonMappingException instantiationException(Class<?> instClass, String msg) {\n      * Object field name was not in format to be able to deserialize specified\n      * key type.\n      */\n-    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)\n-    {\n+    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) {\n         return InvalidFormatException.from(_parser,\n                 \"Can not construct Map key of type \"+keyClass.getName()+\" from String \\\"\"+_desc(keyValue)+\"\\\": \"+msg,\n                 keyValue, keyClass);\n      * Helper method for indicating that the current token was expected to be another\n      * token.\n      */\n-    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg)\n-    {\n+    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg) {\n         return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n     }\n \n      * Helper method for constructing exception to indicate that given\n      * type id (parsed from JSON) could not be converted to a Java type.\n      */\n-    public JsonMappingException unknownTypeException(JavaType type, String id)\n-    {\n+    public JsonMappingException unknownTypeException(JavaType type, String id) {\n         return JsonMappingException.from(_parser, \"Could not resolve type id '\"+id+\"' into a subtype of \"+type);\n     }\n \n-    public JsonMappingException endOfInputException(Class<?> instClass)\n-    {\n+    public JsonMappingException endOfInputException(Class<?> instClass) {\n         return JsonMappingException.from(_parser, \"Unexpected end-of-input when trying to deserialize a \"\n                 +instClass.getName());\n     }\n         return df;\n     }\n \n-    protected String determineClassName(Object instance)\n-    {\n+    protected String determineClassName(Object instance) {\n         return ClassUtil.getClassDescription(instance);\n     }\n     \n     /**********************************************************\n      */\n \n-    protected String _calcName(Class<?> cls)\n-    {\n+    protected String _calcName(Class<?> cls) {\n         if (cls.isArray()) {\n             return _calcName(cls.getComponentType())+\"[]\";\n         }\n         return cls.getName();\n     }\n     \n-    protected String _valueDesc()\n-    {\n+    protected String _valueDesc() {\n         try {\n             return _desc(_parser.getText());\n         } catch (Exception e) {\n             return \"[N/A]\";\n         }\n     }\n-    protected String _desc(String desc)\n-    {\n+\n+    protected String _desc(String desc) {\n         // !!! should we quote it? (in case there are control chars, linefeeds)\n         if (desc.length() > MAX_ERROR_STR_LEN) {\n             desc = desc.substring(0, MAX_ERROR_STR_LEN) + \"]...[\" + desc.substring(desc.length() - MAX_ERROR_STR_LEN);\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n     implements java.io.Serializable, // 2.1\n         java.lang.reflect.Type // 2.2\n {\n-    private static final long serialVersionUID = 6774285981275451126L;\n+    private static final long serialVersionUID = 1;\n \n     /**\n      * This is the nominal type-erased Class that would be close to the\n      */\n     protected final Class<?> _class;\n \n-    protected final int _hashCode;\n+    protected final int _hash;\n \n     /**\n      * Optional handler (codec) that can be attached to indicate \n             Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n         _class = raw;\n-        _hashCode = raw.getName().hashCode() + additionalHash;\n+        _hash = raw.getName().hashCode() + additionalHash;\n         _valueHandler = valueHandler;\n         _typeHandler = typeHandler;\n         _asStatic = asStatic;\n      * true if instantiation of this Type is given (type-erased) Class.\n      */\n     @Override\n-    public final boolean hasRawClass(Class<?> clz) {\n-        return _class == clz;\n-    }\n+    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n \n     @Override\n     public boolean isAbstract() {\n         /* 19-Feb-2010, tatus: Holy mackarel; primitive types\n          *    have 'abstract' flag set...\n          */\n-        if (_class.isPrimitive()) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isThrowable() {\n-        return Throwable.class.isAssignableFrom(_class);\n-    }\n+        return _class.isPrimitive();\n+    }\n+\n+    @Override\n+    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n \n     @Override\n     public boolean isArrayType() { return false; }\n      * \n      * @since 2.2\n      */\n-    public final boolean useStaticType() {\n-        return _asStatic;\n-    }\n+    public final boolean useStaticType() { return _asStatic; }\n     \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public boolean hasGenericTypes()\n-    {\n-        return containedTypeCount() > 0;\n-    }\n+    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n \n     @Override\n     public JavaType getKeyType() { return null; }\n     /**********************************************************\n      */\n \n-    protected void _assertSubclass(Class<?> subclass, Class<?> superClass)\n-    {\n+    protected void _assertSubclass(Class<?> subclass, Class<?> superClass) {\n         if (!_class.isAssignableFrom(subclass)) {\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" is not assignable to \"+_class.getName());\n         }\n     public abstract boolean equals(Object o);\n \n     @Override\n-    public final int hashCode() { return _hashCode; }\n+    public final int hashCode() { return _hash; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * to specify what kind of types (classes) default typing should\n      * be used for. It will only be used if no explicit type information\n      * is found, but this enumeration further limits subset of those types.\n+     *<p>\n+     * Since 2.4 there are special exceptions for JSON Tree model\n+     * types (sub-types of {@link TreeNode}: default typing is never\n+     * applied to them\n+     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n      */\n     public enum DefaultTyping {\n         /**\n          * properties with declared type of {@link java.lang.Object}\n          * or an abstract type (abstract class or interface).\n          * Note that this does <b>not</b> include array types.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         OBJECT_AND_NON_CONCRETE,\n \n          * Value that means that default typing will be used for\n          * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n          * plus all array types for them.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         NON_CONCRETE_AND_ARRAYS,\n         \n          * \"natural\" types (String, Boolean, Integer, Double), which\n          * can be correctly inferred from JSON; as well as for\n          * all arrays of non-final types.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         NON_FINAL\n     }\n                 }\n                 // fall through\n             case OBJECT_AND_NON_CONCRETE:\n-                return (t.getRawClass() == Object.class) || !t.isConcrete();\n+                return (t.getRawClass() == Object.class) || !t.isConcrete()\n+                        // [Issue#88] Should not apply to JSON tree models:\n+                        || TreeNode.class.isAssignableFrom(t.getRawClass());\n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n-                return !t.isFinal(); // includes Object.class\n+                // [Issue#88] Should not apply to JSON tree models:\n+                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n             default:\n             //case JAVA_LANG_OBJECT:\n                 return (t.getRawClass() == Object.class);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n         }\n         Class<?> implClass = objectIdInfo.getGeneratorType();\n         JavaType idType;\n-    \tSettableBeanProperty idProp;\n+        SettableBeanProperty idProp;\n         ObjectIdGenerator<?> gen;\n \n         // Just one special case: Property-based generator is trickier\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n  * setter-backed properties, as well as a few more esoteric variations,\n  * can be handled.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class SettableBeanProperty\n     implements BeanProperty,\n         java.io.Serializable\n {\n-    private static final long serialVersionUID = -1026580169193933453L;\n-\n     /**\n      * To avoid nasty NPEs, let's use a placeholder for _valueDeserializer,\n      * if real deserializer is not (yet) available.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FailingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FailingDeserializer.java\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws JsonMappingException\n-    {\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonMappingException{\n         throw ctxt.mappingException(_message);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n \n /**\n  * Default {@link TypeResolverBuilder} implementation.\n- *\n- * @author tatu\n  */\n public class StdTypeResolverBuilder\n     implements TypeResolverBuilder<StdTypeResolverBuilder>\n         return this;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n-        if (_idType == JsonTypeInfo.Id.NONE) {\n-            return null;\n-        }\n+        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n-        if (_idType == JsonTypeInfo.Id.NONE) {\n-            return null;\n-        }\n+        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n \n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n         \n      * (property name to use for type id when using \"as-property\" inclusion).\n      */\n     @Override\n-    public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n-    {\n+    public StdTypeResolverBuilder typeProperty(String typeIdPropName) {\n         // ok to have null/empty; will restore to use defaults\n         if (typeIdPropName == null || typeIdPropName.length() == 0) {\n             typeIdPropName = _idType.getDefaultPropertyName();\n     }\n \n     @Override\n-    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)\n-    {\n+    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {\n         _defaultImpl = defaultImpl;\n         return this;\n     }\n     /**********************************************************\n      */\n \n+    @Override public Class<?> getDefaultImpl() { return _defaultImpl; }\n+\n     public String getTypeProperty() { return _typeProperty; }\n-\n-    @Override\n-    public Class<?> getDefaultImpl() {\n-        return _defaultImpl;\n-    }\n-\n     public boolean isTypeIdVisible() { return _typeIdVisible; }\n     \n     /*\n      * given configuration.\n      */\n     protected TypeIdResolver idResolver(MapperConfig<?> config,\n-            JavaType baseType, Collection<NamedType> subtypes,\n-            boolean forSer, boolean forDeser)\n+            JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser)\n     {\n         // Custom id resolver?\n-        if (_customIdResolver != null) {\n-            return _customIdResolver;\n-        }\n-        if (_idType == null) {\n-            throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n-        }\n+        if (_customIdResolver != null) { return _customIdResolver; }\n+        if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n         switch (_idType) {\n         case CLASS:\n             return new ClassNameIdResolver(baseType, config.getTypeFactory());\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForTreeNodes.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDefaultForTreeNodes extends BaseMapTest\n+{\n+    public static class Foo {\n+        public String bar;\n+\n+        public Foo() { }\n+        public Foo(String b) { bar = b; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper DEFAULT_MAPPER = new ObjectMapper();\n+    {\n+        DEFAULT_MAPPER.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+    }\n+    \n+    public void testValueAsStringWithDefaultTyping() throws Exception\n+    {\n+        Foo foo = new Foo(\"baz\");\n+        String json = DEFAULT_MAPPER.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = DEFAULT_MAPPER.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueToTreeWithDefaultTyping() throws Exception\n+    {\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = DEFAULT_MAPPER.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n     /**********************************************************\n      */\n \n-    private final ObjectMapper mapper = new ObjectMapper();\n-    \n-    public void testSimpleUnwrappingSerialize() throws Exception\n-    {\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testSimpleUnwrappingSerialize() throws Exception {\n         assertEquals(\"{\\\"name\\\":\\\"Tatu\\\",\\\"x\\\":1,\\\"y\\\":2}\",\n-                mapper.writeValueAsString(new Unwrapping(\"Tatu\", 1, 2)));\n+                MAPPER.writeValueAsString(new Unwrapping(\"Tatu\", 1, 2)));\n     }\n-    public void testDeepUnwrappingSerialize() throws Exception\n-    {\n+\n+    public void testDeepUnwrappingSerialize() throws Exception {\n         assertEquals(\"{\\\"name\\\":\\\"Tatu\\\",\\\"x\\\":1,\\\"y\\\":2}\",\n-                mapper.writeValueAsString(new DeepUnwrapping(\"Tatu\", 1, 2)));\n+                MAPPER.writeValueAsString(new DeepUnwrapping(\"Tatu\", 1, 2)));\n     }\n \n     /*\n     /* Tests, deserialization\n     /**********************************************************\n      */\n-    \n+\n     public void testSimpleUnwrappedDeserialize() throws Exception\n     {\n-        Unwrapping bean = mapper.readValue(\"{\\\"name\\\":\\\"Tatu\\\",\\\"y\\\":7,\\\"x\\\":-13}\",\n+        Unwrapping bean = MAPPER.readValue(\"{\\\"name\\\":\\\"Tatu\\\",\\\"y\\\":7,\\\"x\\\":-13}\",\n                 Unwrapping.class);\n         assertEquals(\"Tatu\", bean.name);\n         Location loc = bean.location;\n         assertEquals(-13, loc.x);\n         assertEquals(7, loc.y);\n     }\n-    \n+\n     public void testDoubleUnwrapping() throws Exception\n     {\n-        TwoUnwrappedProperties bean = mapper.readValue(\"{\\\"first\\\":\\\"Joe\\\",\\\"y\\\":7,\\\"last\\\":\\\"Smith\\\",\\\"x\\\":-13}\",\n+        TwoUnwrappedProperties bean = MAPPER.readValue(\"{\\\"first\\\":\\\"Joe\\\",\\\"y\\\":7,\\\"last\\\":\\\"Smith\\\",\\\"x\\\":-13}\",\n                 TwoUnwrappedProperties.class);\n         Location loc = bean.location;\n         assertNotNull(loc);\n         assertEquals(\"Joe\", name.first);\n         assertEquals(\"Smith\", name.last);\n     }\n-    \n+\n     public void testDeepUnwrapping() throws Exception\n     {\n-        DeepUnwrapping bean = mapper.readValue(\"{\\\"x\\\":3,\\\"name\\\":\\\"Bob\\\",\\\"y\\\":27}\",\n+        DeepUnwrapping bean = MAPPER.readValue(\"{\\\"x\\\":3,\\\"name\\\":\\\"Bob\\\",\\\"y\\\":27}\",\n                 DeepUnwrapping.class);\n         Unwrapping uw = bean.unwrapped;\n         assertNotNull(uw);\n         assertEquals(3, loc.x);\n         assertEquals(27, loc.y);\n     }\n-    \n+\n     public void testUnwrappedDeserializeWithCreator() throws Exception\n     {\n-        UnwrappingWithCreator bean = mapper.readValue(\"{\\\"x\\\":1,\\\"y\\\":2,\\\"name\\\":\\\"Tatu\\\"}\",\n+        UnwrappingWithCreator bean = MAPPER.readValue(\"{\\\"x\\\":1,\\\"y\\\":2,\\\"name\\\":\\\"Tatu\\\"}\",\n                 UnwrappingWithCreator.class);\n         assertEquals(\"Tatu\", bean.name);\n         Location loc = bean.location;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedIssue383.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestUnwrappedIssue383 extends BaseMapTest\n+{\n+    // [Issue#383]\n+    static class RecursivePerson {\n+        public String name;\n+        public int age;\n+        @JsonUnwrapped(prefix=\"child.\") public RecursivePerson child;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests, serialization\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testRecursiveUsage() throws Exception\n+    {\n+        final String JSON = \"{ 'name': 'Bob', 'age': 45, 'gender': 0, 'child.name': 'Bob jr', 'child.age': 15 }}\";\n+        RecursivePerson p = MAPPER.readValue(aposToQuotes(JSON), RecursivePerson.class);\n+        assertNotNull(p);\n+        assertEquals(\"Bob\", p.name);\n+        assertNotNull(p.child);\n+        assertEquals(\"Bob jr\", p.child.name);\n+    }\n+}", "timestamp": 1389500127, "metainfo": ""}