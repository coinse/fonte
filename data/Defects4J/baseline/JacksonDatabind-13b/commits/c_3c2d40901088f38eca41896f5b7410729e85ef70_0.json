{"sha": "3c2d40901088f38eca41896f5b7410729e85ef70", "log": "extends iso8601 format to support parse according expression: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n import java.text.ParseException;\n \n /**\n- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n- * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+ * \n+ * @see http://www.w3.org/TR/NOTE-datetime\n  */\n public class ISO8601Utils {\n \n     private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID);\n \n     /*\n-    /**********************************************************\n-    /* Static factories\n-    /**********************************************************\n-     */\n-    \n+     * /********************************************************** /* Static factories\n+     * /**********************************************************\n+     */\n+\n     /**\n      * Accessor for static GMT timezone instance.\n      */\n-    public static TimeZone timeZoneGMT() { return TIMEZONE_GMT; }\n+    public static TimeZone timeZoneGMT() {\n+        return TIMEZONE_GMT;\n+    }\n \n     /*\n-    /**********************************************************\n-    /* Formatting\n-    /**********************************************************\n-     */\n-    \n+     * /********************************************************** /* Formatting\n+     * /**********************************************************\n+     */\n+\n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n-     *\n+     * \n      * @param date the date to format\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n      */\n \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n      */\n \n     /**\n      * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n-     * @param tz     timezone to use for the formatting (GMT will produce 'Z')\n+     * @param tz timezone to use for the formatting (GMT will produce 'Z')\n      * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n      */\n     public static String format(Date date, boolean millis, TimeZone tz) {\n     }\n \n     /*\n-    /**********************************************************\n-    /* Parsing\n-    /**********************************************************\n+     * /********************************************************** /* Parsing\n+     * /**********************************************************\n      */\n \n     /**\n      * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n+     * \n      * @param date ISO string to parse in the appropriate format.\n      * @param pos The position to start parsing from, updated to where parsing stopped.\n      * @return the parsed date\n      * @throws ParseException if the date is not in the appropriate format\n      */\n-    public static Date parse(String date, ParsePosition pos) throws ParseException\n-    {\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n         Exception fail = null;\n         try {\n             int offset = pos.getIndex();\n \n             // extract year\n             int year = parseInt(date, offset, offset += 4);\n-            checkOffset(date, offset, '-');\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract month\n-            int month = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, '-');\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract day\n-            int day = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, 'T');\n-\n-            // extract hours, minutes, seconds and milliseconds\n-            int hour = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int minutes = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int seconds = parseInt(date, offset += 1, offset += 2);\n-            // milliseconds can be optional in the format\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n             int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n-            if (date.charAt(offset) == '.') {\n-                checkOffset(date, offset, '.');\n-                milliseconds = parseInt(date, offset += 1, offset += 3);\n+            if (checkOffset(date, offset, 'T')) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            milliseconds = parseInt(date, offset += 1, offset += 3);\n+                        }\n+                    }\n+                }\n             }\n \n             // extract timezone\n             String timezoneId;\n+            if (date.length() <= offset) {\n+                throw new IndexOutOfBoundsException(\"No time zone indicator \");\n+            }\n             char timezoneIndicator = date.charAt(offset);\n             if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                 String timezoneOffset = date.substring(offset);\n \n             pos.setIndex(offset);\n             return calendar.getTime();\n-            //If we get a ParseException it'll already have the right message/offset.\n-            //Other exception types can convert here.\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n         } catch (IndexOutOfBoundsException e) {\n             fail = e;\n         } catch (NumberFormatException e) {\n         } catch (IllegalArgumentException e) {\n             fail = e;\n         }\n-        String input = (date == null) ? null : ('\"'+date+\"'\");\n-        throw new ParseException(\"Failed to parse date [\"+input\n-            +\"]: \"+fail.getMessage(), pos.getIndex());\n-    }\n-\n-    /**\n-     * Check if the expected character exist at the given offset of the\n-     *\n-     * @param value    the string to check at the specified offset\n-     * @param offset   the offset to look for the expected character\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n      * @param expected the expected character\n-     * @throws IndexOutOfBoundsException if the expected character is not found\n-     */\n-    private static void checkOffset(String value, int offset, char expected) throws ParseException {\n-        char found = value.charAt(offset);\n-        if (found != expected) {\n-            throw new ParseException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\", offset);\n-        }\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return value.length() > offset ? (value.charAt(offset) == expected) : false;\n     }\n \n     /**\n      * Parse an integer located between 2 given offsets in a string\n-     *\n-     * @param value      the string to parse\n+     * \n+     * @param value the string to parse\n      * @param beginIndex the start index for the integer in the string\n-     * @param endIndex   the end index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n      * @return the int\n      * @throws NumberFormatException if the value is not a number\n      */\n \n     /**\n      * Zero pad a number to a specified length\n-     *\n+     * \n      * @param buffer buffer to use for padding\n-     * @param value  the integer value to pad if necessary.\n+     * @param value the integer value to pad if necessary.\n      * @param length the length of the string we should zero pad\n      */\n     private static void padInt(StringBuilder buffer, int value, int length) {\n         buffer.append(strValue);\n     }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.util.*;\n+import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.util.ISO8601Utils;\n \n /**\n  * @see ISO8601Utils\n  */\n-public class ISO8601UtilsTest extends BaseMapTest\n-{\n+public class ISO8601UtilsTest extends BaseMapTest {\n     private Date date;\n+    private Date dateWithoutTime;\n     private Date dateZeroMillis;\n+    private Date dateZeroSecondAndMillis;\n \n     @Override\n-    public void setUp()\n-    {\n+    public void setUp() {\n         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(Calendar.MILLISECOND, 789);\n         date = cal.getTime();\n         cal.set(Calendar.MILLISECOND, 0);\n         dateZeroMillis = cal.getTime();\n+        cal.set(Calendar.SECOND, 0);\n+        dateZeroSecondAndMillis = cal.getTime();\n+        \n+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        dateWithoutTime = cal.getTime();\n+\n     }\n \n     public void testFormat() {\n         assertEquals(date, d);\n     }\n \n+    public void testParseShortDate() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T19:51:23.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T19:51:23Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T21:51:23.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortDateTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseWithoutTime() throws ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+    }\n+\n+    public void testParseWithoutTimeAndTimeZoneMustFail() {\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+    }\n+    \n+    \n+    public void testParseOptional() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T1951Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51+02:00\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+    }\n }", "timestamp": 1411134087, "metainfo": ""}