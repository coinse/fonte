{"sha": "01266dab7806780e1090e7b55f97a87c2a6e2746", "log": "Minor changes to support overridability, eventually to be used by CSV module", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        JsonParser jp = _parserFactory.createParser(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(src);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return new MappingIterator<T>(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n-        JsonParser jp = _parserFactory.createParser(json);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(json);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return new MappingIterator<T>(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n      */\n \n     @Override\n-    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n-        throws JsonProcessingException\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n     {\n         try {\n             return readValue(treeAsTokens(n), valueType);\n     }    \n     \n     @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n         throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n \n     /**\n      * Actual implementation of value reading+binding operation.\n      */\n-    protected Object _bind(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n     {\n         /* First: may need to read the next token, to initialize state (either\n          * before first read from parser, or after previous token has been cleared)\n         return result;\n     }\n     \n-    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n+    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n+    {\n         try {\n             Object result;\n             JsonToken t = _initForReading(jp);\n         }\n     }\n \n-    protected JsonNode _bindAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n+        try {\n+            return _bindAsTree(jp);\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n     {\n         JsonNode result;\n         JsonToken t = _initForReading(jp);\n         return result;\n     }\n     \n-    protected JsonNode _bindAndCloseAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        try {\n-            return _bindAsTree(jp);\n-        } finally {\n-            try {\n-                jp.close();\n-            } catch (IOException ioe) { }\n-        }\n-    }\n-    \n     /**\n      * @since 2.1\n      */\n-    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p,\n-            Object valueToUpdate)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n+    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n+    {\n+        _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n         return new MappingIterator<T>(_valueType, p, ctxt, \n                 _findRootDeserializer(ctxt, _valueType),\n                 true, _valueToUpdate);\n     }\n-    \n-    protected static JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n+            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n+    {\n+        String expName = _config.getRootName();\n+        if (expName == null) {\n+            PropertyName pname = _rootNames.findRootName(rootType, _config);\n+            expName = pname.getSimpleName();\n+        }\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        Object result;\n+        if (_valueToUpdate == null) {\n+            result = deser.deserialize(jp, ctxt);\n+        } else {\n+            deser.deserialize(jp, ctxt, _valueToUpdate);\n+            result = _valueToUpdate;                    \n+        }\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods, common parser initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * NOTE: changed from static to non-static in 2.5; unfortunate but\n+     * necessary change to support overridability\n+     */\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n         /* First: must point to a token; if not pointing to one, advance.\n          * This occurs before first read from JsonParser, as well as\n          * after clearing of current token.\n          */\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == null) { // and then we must get something...\n-            t = jp.nextToken();\n+            t = p.nextToken();\n             if (t == null) {\n                 /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                  *   not an actual parsing problem\n                  */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n             }\n         }\n         return t;\n     }\n \n+    /**\n+     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n+     * of multiple values means that we may or may not want to advance the stream,\n+     * but need to do other initialization.\n+     * \n+     * @since 2.5\n+     */\n+    protected void _initForMultiRead(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, locating deserializers etc\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n         }\n         return deser;\n     }\n-    \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n-            JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        String expName = _config.getRootName();\n-        if (expName == null) {\n-            PropertyName pname = _rootNames.findRootName(rootType, _config);\n-            expName = pname.getSimpleName();\n-        }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n-        if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n-                    +expName+\"') for type \"+rootType);\n-        }\n-        // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result;\n-        if (_valueToUpdate == null) {\n-            result = deser.deserialize(jp, ctxt);\n-        } else {\n-            deser.deserialize(jp, ctxt, _valueToUpdate);\n-            result = _valueToUpdate;                    \n-        }\n-        // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        return result;\n-    }\n \n     /*\n     /**********************************************************", "timestamp": 1412356786, "metainfo": ""}