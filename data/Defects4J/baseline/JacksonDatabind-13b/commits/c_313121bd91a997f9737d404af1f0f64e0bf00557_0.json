{"sha": "313121bd91a997f9737d404af1f0f64e0bf00557", "log": "Initial support for Map-filtering, via properties", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n      * annotated properties\n      */\n     final protected AnyGetterWriter _anyGetterWriter;\n-    \n+\n     /**\n      * Id of the bean property filter to use, if any; null if none.\n      */\n         } else {\n             props = _props;\n         }\n-        final PropertyFilter filter = findFilter(provider);\n+        final PropertyFilter filter = findFilter(provider, _propertyFilterId);\n         // better also allow missing filter actually..\n         if (filter == null) {\n             serializeFields(bean, jgen, provider);\n         }\n     }\n \n-    /**\n-     * Helper method used to locate filter that is needed, based on filter id\n-     * this serializer was constructed with.\n-     */\n-    protected PropertyFilter findFilter(SerializerProvider provider)\n-        throws JsonMappingException\n-    {\n-        final Object filterId = _propertyFilterId;\n-        FilterProvider filters = provider.getFilterProvider();\n-        // Not ok to miss the provider, if a filter is declared to be needed.\n-        if (filters == null) {\n-            throw new JsonMappingException(\"Can not resolve PropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n-        }\n-        PropertyFilter filter = filters.findPropertyFilter(filterId);\n-        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n-        return filter;\n-    }\n-\n     @Deprecated\n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         ObjectNode propertiesNode = o.objectNode();\n         final PropertyFilter filter;\n         if (_propertyFilterId != null) {\n-            filter = findFilter(provider);\n+            filter = findFilter(provider, _propertyFilterId);\n         } else {\n             filter = null;\n         }\n             return;\n         }\n         if (_propertyFilterId != null) {\n-            PropertyFilter filter = findFilter(visitor.getProvider());\n+            PropertyFilter filter = findFilter(visitor.getProvider(), _propertyFilterId);\n             for (int i = 0; i < _props.length; i++) {\n                 filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonMapFormatVisitor;\n      * runtime value types to serializers are stored in this object.\n      */\n     protected PropertySerializerMap _dynamicValueSerializers;\n-    \n+\n+    /**\n+     * Id of the property filter to use, if any; null if none.\n+     *\n+     * @since 2.3\n+     */\n+    protected final Object _filterId;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _valueSerializer = (JsonSerializer<Object>) valueSerializer;\n         _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n         _property = null;\n+        _filterId = null;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         _valueSerializer = (JsonSerializer<Object>) valueSerializer;\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = property;\n+        _filterId = src._filterId;\n     }\n \n     protected MapSerializer(MapSerializer src, TypeSerializer vts)\n         _valueSerializer = src._valueSerializer;\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = src._property;\n+        _filterId = src._filterId;\n+    }\n+\n+    protected MapSerializer(MapSerializer src, Object filterId)\n+    {\n+        super(Map.class, false);\n+        _ignoredEntries = src._ignoredEntries;\n+        _keyType = src._keyType;\n+        _valueType = src._valueType;\n+        _valueTypeIsStatic = src._valueTypeIsStatic;\n+        _valueTypeSerializer = src._valueTypeSerializer;\n+        _keySerializer = src._keySerializer;\n+        _valueSerializer = src._valueSerializer;\n+        _dynamicValueSerializers = src._dynamicValueSerializers;\n+        _property = src._property;\n+        _filterId = filterId;\n     }\n     \n     @Override\n             HashSet<String> ignored)\n     {\n         return new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n+    }\n+\n+    public MapSerializer withFilterId(Object filterId) {\n+        return (_filterId == filterId) ? this : new MapSerializer(this, filterId);\n     }\n     \n     public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n                 }\n             }\n         }\n-        return withResolved(property, keySer, ser, ignored);\n+        MapSerializer mser =  withResolved(property, keySer, ser, ignored);\n+\n+        // [Issue#307]: allow filtering\n+        if (property != null) {\n+            Object filterId = intr.findFilterId(property.getMember());\n+            if (filterId != null) {\n+                mser = mser.withFilterId(filterId);\n+            }\n+        }\n+        return mser;\n     }\n     \n     /*\n     {\n         jgen.writeStartObject();\n         if (!value.isEmpty()) {\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, jgen, provider, findFilter(provider, _filterId));\n+                return;\n+            }\n             if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n         }\n         return existingSerializer;\n     }\n+\n+    /**\n+     * Helper method used to locate filter that is needed, based on filter id\n+     * this serializer was constructed with.\n+     * \n+     * @since 2.3\n+     */\n+    protected PropertyFilter findFilter(SerializerProvider provider, Object filterId)\n+        throws JsonMappingException\n+    {\n+        FilterProvider filters = provider.getFilterProvider();\n+        // Not ok to miss the provider, if a filter is declared to be needed.\n+        if (filters == null) {\n+            throw new JsonMappingException(\"Can not resolve PropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n+        }\n+        PropertyFilter filter = filters.findPropertyFilter(filterId);\n+        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n+        return filter;\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n \n public class TestMapFiltering extends BaseMapTest\n {\n+    @SuppressWarnings(\"serial\")\n+    static class FilteredBean extends LinkedHashMap<String,Integer> { }\n+    \n     static class MapBean {\n         @JsonFilter(\"filterX\")\n         public Map<String,Integer> values;\n     /* Unit tests\n     /**********************************************************\n      */\n+\n+    final ObjectMapper MAPPER = objectMapper();\n     \n-    // should also work for @JsonAnyGetter, as per [JACKSON-516]\n-    public void testAnyGetterFiltering() throws Exception\n+    public void testMapFilteringViaProps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n                 SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n         assertEquals(aposToQuotes(\"{'values':{'b':5}}\"),\n-                mapper.writer(prov).writeValueAsString(new MapBean()));\n+                MAPPER.writer(prov).writeValueAsString(new MapBean()));\n     }\n \n+    public void testMapFilteringViaClass() throws Exception\n+    {\n+        FilteredBean bean = new FilteredBean();\n+        bean.put(\"a\", 4);\n+        bean.put(\"b\", 3);\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n+                SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+        assertEquals(aposToQuotes(\"{'b':3}\"),\n+                MAPPER.writer(prov).writeValueAsString(bean));\n+    }\n+    \n }", "timestamp": 1382225758, "metainfo": ""}