{"sha": "e1ceccd484643cd7a8e213de14bc3a85eebb3c11", "log": "Fix [JACKSON-798]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handleToken(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                // first things first: external type-ids are tricky, so:\n-                if (ext.handleToken(jp, ctxt, propName, null)) {\n-                    continue;\n-                }\n-                // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue; // never gets here\n+                // first: let's check to see if this might be part of value with external type id:\n+                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                    ;\n+                } else {\n+                    // Last creator property to set?\n+                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        Object bean;\n+                        try {\n+                            bean = creator.build(ctxt, buffer);\n+                        } catch (Exception e) {\n+                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                            continue; // never gets here\n+                        }\n+                        // if so, need to copy all remaining tokens into buffer\n+                        while (t == JsonToken.FIELD_NAME) {\n+                            jp.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(jp);\n+                            t = jp.nextToken();\n+                        }\n+                        if (bean.getClass() != _beanType.getRawClass()) {\n+                            // !!! 08-Jul-2011, tatu: Could probably support; but for now\n+                            //   it's too complicated, so bail out\n+                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                        }\n+                        return ext.complete(jp, ctxt, bean);\n                     }\n-                    // if so, need to copy all remaining tokens into buffer\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n-                    }\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n-                        //   it's too complicated, so bail out\n-                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                    }\n-                    return ext.complete(jp, ctxt, bean);\n                 }\n                 continue;\n             }\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handleToken(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n             }\n         }\n \n-        // We hit END_OBJECT, so:\n-        Object bean;\n+        // We hit END_OBJECT; resolve the pieces:\n         try {\n-            bean = creator.build(ctxt, buffer);\n+            return ext.complete(jp, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return ext.complete(jp, ctxt, bean);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n \n     /*\n     /**********************************************************\n-    /* Handling for cases where we have property/-ies wth\n+    /* Handling for cases where we have property/-ies with\n     /* external type id\n     /**********************************************************\n      */\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handleToken(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n     \t\tDeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n-        tokens.writeStartObject();\n-\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n-            // creator property?\n-            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n-            if (creatorProp != null) {\n-                // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue; // never gets here\n-                    }\n-                    // if so, need to copy all remaining tokens into buffer\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n-                    }\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n-                        //   it's too complicated, so bail out\n-                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                    }\n-                    return ext.complete(jp, ctxt, bean);\n-                }\n-                continue;\n-            }\n-            // regular property? needs buffering\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n-                continue;\n-            }\n-            // external type id (or property that depends on it)?\n-            if (ext.handleToken(jp, ctxt, propName, null)) {\n-                continue;\n-            }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-                continue;\n-            }\n-            // \"any property\"?\n-            if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n-            }\n-        }\n-\n-        // We hit END_OBJECT, so:\n-        Object bean;\n-        try {\n-            bean = creator.build(ctxt, buffer);\n-        } catch (Exception e) {\n-            wrapInstantiationProblem(e, ctxt);\n-            return null; // never gets here\n-        }\n-        return ext.complete(jp, ctxt, bean);\n-    }    \n+        // !!! 04-Mar-2012, TODO: Need to fix -- will not work as is...\n+        throw new IllegalStateException(\"Deserialization with Builder, External type id, @JsonCreator not yet implemented\");\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n     public void set(Object instance, Object value) throws IOException\n     {\n         /* Hmmmh. Should we return quietly (NOP), or error?\n-         * For now, let's just bail out without fuss.\n+         * Perhaps better to throw an exception, since it's generally an error.\n          */\n-        //throw new IllegalStateException(\"Method should never be called on a \"+getClass().getName());\n+        throw new IllegalStateException(\"Method should never be called on a \"+getClass().getName());\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n     }\n \n     /**\n-     * Method called to ask handler to handle value of given property;\n-     * either by resolving type id it contains (if it matches type\n+     * Method called to ask handler to handle value of given property,\n+     * at point where parser points to the first token of the value.\n+     * Handling can mean either resolving type id it contains (if it matches type\n      * property name), or by buffering the value for further use.\n+     * \n+     * @return True, if the given property was properly handled\n      */\n-    public boolean handleToken(JsonParser jp, DeserializationContext ctxt,\n+    public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n             String propName, Object bean)\n         throws IOException, JsonProcessingException\n     {\n          * we have all pertinent information:\n          */\n         if (canDeserialize) {\n-            _deserialize(jp, ctxt, bean, index);\n+            _deserializeAndSet(jp, ctxt, bean, index);\n             // clear stored data, to avoid deserializing+setting twice:\n             _typeIds[index] = null;\n             _tokens[index] = null;\n         }\n         return true;\n     }\n-\n+    \n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n         throws IOException, JsonProcessingException\n     {\n+\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             if (_typeIds[i] == null) {\n                 // let's allow missing both type and property (may already have been set, too)\n                 SettableBeanProperty prop = _properties[i].getProperty();\n                 throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n             }\n-            _deserialize(jp, ctxt, bean, i);\n+            _deserializeAndSet(jp, ctxt, bean, i);\n         }\n         return bean;\n     }\n-    \n-    protected final void _deserialize(JsonParser jp, DeserializationContext ctxt, Object bean, int index)\n+\n+    /**\n+     * Variant called when creation of the POJO involves buffering of creator properties\n+     * as well as property-based creator.\n+     */\n+    public Object complete(JsonParser jp, DeserializationContext ctxt,\n+            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n+        throws IOException, JsonProcessingException\n+    {\n+        // first things first: deserialize all data buffered:\n+        final int len = _properties.length;\n+        Object[] values = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            if (_typeIds[i] == null) {\n+                // let's allow missing both type and property (may already have been set, too)\n+                if (_tokens[i] == null) {\n+                    continue;\n+                }\n+                // but not just one\n+                throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName());\n+            } else if (_tokens[i] == null) {\n+                SettableBeanProperty prop = _properties[i].getProperty();\n+                throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n+            }\n+            values[i] = _deserialize(jp, ctxt, i);\n+        }\n+        // second: fill in creator properties:\n+        for (int i = 0; i < len; ++i) {\n+            SettableBeanProperty prop = _properties[i].getProperty();\n+            if (creator.findCreatorProperty(prop.getName()) != null) {\n+                buffer.assignParameter(prop.getPropertyIndex(), values[i]);\n+            }\n+        }\n+        Object bean = creator.build(ctxt, buffer);\n+        // third: assign non-creator properties\n+        for (int i = 0; i < len; ++i) {\n+            SettableBeanProperty prop = _properties[i].getProperty();\n+            if (creator.findCreatorProperty(prop.getName()) == null) {\n+                prop.set(bean, values[i]);\n+            }\n+        }\n+        return bean;\n+    }\n+\n+    protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n+            int index)\n+        throws IOException, JsonProcessingException\n+    {\n+        TokenBuffer merged = new TokenBuffer(jp.getCodec());\n+        merged.writeStartArray();\n+        merged.writeString(_typeIds[index]);\n+        JsonParser p2 = _tokens[index].asParser(jp);\n+        p2.nextToken();\n+        merged.copyCurrentStructure(p2);\n+        merged.writeEndArray();\n+        // needs to point to START_OBJECT (or whatever first token is)\n+        p2 = merged.asParser(jp);\n+        p2.nextToken();\n+        return _properties[index].getProperty().deserialize(p2, ctxt);\n+    }\n+    \n+    protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index)\n         throws IOException, JsonProcessingException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n  */\n public final class PropertyValueBuffer\n {\n-    final JsonParser _parser;\n-    final DeserializationContext _context;\n+    protected final JsonParser _parser;\n+    protected final DeserializationContext _context;\n     \n     /**\n      * Buffer used for storing creator parameters for constructing\n      * instance\n      */\n-    final Object[] _creatorParameters;\n+    protected final Object[] _creatorParameters;\n     \n     /**\n      * Number of creator parameters we are still missing.\n     }\n \n     protected PropertyValue buffered() { return _buffered; }\n+\n+    public boolean isComplete() { return _paramsNeeded <= 0; }\n     \n     /**\n      * @return True if we have received all creator parameters\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n     static class FunkyExternalBean {\n         public int i = 3;\n     }\n+\n+    // [JACKSON-798]: problems with polymorphic types, external prop\n+\n+    @JsonSubTypes(value= { @JsonSubTypes.Type(value=Derived1.class, name=\"d1\"),\n+            @JsonSubTypes.Type(value=Derived2.class, name=\"d2\") })\n+    interface Base {\n+        String getBaseProperty();\n+    }\n+  \n+    static class Derived1 implements Base {\n+        private String derived1Property;\n+        private String baseProperty;\n+        protected  Derived1() { throw new IllegalStateException(\"wrong constructor called\"); }\n+        \n+        @JsonCreator\n+        public Derived1(@JsonProperty(\"derived1Property\") String d1p,\n+                        @JsonProperty(\"baseProperty\") String bp) {\n+            derived1Property = d1p;\n+            baseProperty = bp;\n+        }\n+\n+        @Override\n+        @JsonProperty public String getBaseProperty() {\n+            return baseProperty;\n+        }\n+\n+        @JsonProperty public String getDerived1Property() {\n+            return derived1Property;\n+        }\n+    }\n+\n+    static class Derived2 implements Base {\n+        private String derived2Property;\n+        private String baseProperty;\n+        protected  Derived2() { throw new IllegalStateException(\"wrong constructor called\"); }\n+\n+        @JsonCreator\n+        public Derived2(@JsonProperty(\"derived2Property\") String d2p,\n+                        @JsonProperty(\"baseProperty\") String bp) {\n+            derived2Property = d2p;\n+            baseProperty = bp;\n+        }\n+\n+        @Override\n+        @JsonProperty public String getBaseProperty() {\n+            return baseProperty;\n+        }\n+\n+        @JsonProperty public String getDerived2Property() {\n+            return derived2Property;\n+        }\n+    }\n+    \n+    static class BaseContainer {\n+        protected final Base base;\n+        protected final String baseContainerProperty;\n+        protected BaseContainer() { throw new IllegalStateException(\"wrong constructor called\"); }\n+\n+        @JsonCreator\n+        public BaseContainer(@JsonProperty(\"baseContainerProperty\") String bcp, @JsonProperty(\"base\") Base b) {\n+            baseContainerProperty = bcp;\n+            base = b;\n+        }\n+\n+        @JsonProperty\n+        public String getBaseContainerProperty() { return baseContainerProperty; }\n+\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY, property=\"type\")\n+        @JsonProperty\n+        public Base getBase() { return base; }\n+    }\n     \n     /*\n     /**********************************************************\n     /* Unit tests, serialization\n     /**********************************************************\n      */\n-\n+    \n     public void testSimpleSerialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     /* Unit tests, deserialization\n     /**********************************************************\n      */\n-    \n+\n     public void testSimpleDeserialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(11, vb.value);\n     }\n \n-    /**\n-     * Test for verifying that it's ok to have multiple (say, 3)\n-     * externally typed things, mixed with other stuff...\n-     */\n+    // Test for verifying that it's ok to have multiple (say, 3)\n+    // externally typed things, mixed with other stuff...\n     public void testMultipleTypeIdsDeserialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(3, result.foo);\n     }\n \n-    /**\n-     * Also, it should be ok to use @JsonCreator as well...\n-     */\n+    // Also, it should be ok to use @JsonCreator as well...\n     public void testExternalTypeWithCreator() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertNotNull(result);\n         assertEquals(3, result.i);\n     }\n+\n+    public void testIssue798() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        Base base = new Derived1(\"derived1 prop val\", \"base prop val\");\n+        BaseContainer baseContainer = new BaseContainer(\"bc prop val\", base);\n+        String generatedJson = mapper.writeValueAsString(baseContainer);\n+        BaseContainer baseContainer2 = mapper.readValue(generatedJson,BaseContainer.class);\n+        assertEquals(\"bc prop val\", baseContainer.getBaseContainerProperty());\n+\n+        Base b = baseContainer2.getBase();\n+        assertNotNull(b);\n+        if (b.getClass() != Derived1.class) {\n+            fail(\"Should have type Derived1, was \"+b.getClass().getName());\n+        }\n+\n+        Derived1 derived1 = (Derived1) b;\n+        assertEquals(\"base prop val\", derived1.getBaseProperty());\n+        assertEquals(\"derived1 prop val\", derived1.getDerived1Property());\n+    }\n }", "timestamp": 1330919556, "metainfo": ""}