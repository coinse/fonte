{"sha": "4000268b9e0b9db53b5a8be57a2418743f0619ad", "log": "Converting deserializers to use JsonParser.getValueAsString(), to make more robust", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n package com.fasterxml.jackson.databind.deser.std;\n-\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.regex.Pattern;\n \n-import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n-import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n public class JdkDeserializers\n {\n      * if sub-classing was needed could re-factor into reusable part, final\n      * \"Impl\" sub-class\n      */\n+    /*\n     @JacksonStdImpl\n     public final static class StringDeserializer\n         extends StdScalarDeserializer<String>\n             return deserialize(jp, ctxt);\n         }\n     }\n+    */\n     \n     public static class UUIDDeserializer\n         extends FromStringDeserializer<UUID>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n             \n             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                 // Ok: no need to convert Strings, but must recognize nulls\n-                String value = (t == JsonToken.VALUE_NULL) ? null : jp.getText();\n+                String value = (t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt);\n                 if (ix >= chunk.length) {\n                     chunk = buffer.appendCompletedChunk(chunk);\n                     ix = 0;\n                 }\n                 throw ctxt.mappingException(_valueClass);\n             }\n-            return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : jp.getText() };\n+            return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n             return Double.MIN_VALUE;\n         }\n         return Double.parseDouble(numStr);\n+    }\n+    \n+    /**\n+     * Helper method used for accessing String value, if possible, doing\n+     * necessary conversion or throwing exception as necessary.\n+     * \n+     * @since 2.1\n+     */\n+    protected final String _parseString(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        String value = jp.getValueAsString();\n+        if (value != null) {\n+            return value;\n+        }\n+        throw ctxt.mappingException(String.class, jp.getCurrentToken());\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         JsonToken t;\n \n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            result.add((t == JsonToken.VALUE_NULL) ? null : jp.getText());\n+            result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt));\n         }\n         return result;\n     }\n         if (t == JsonToken.VALUE_NULL) {\n             value = null;\n         } else {\n-            value = (valueDes == null) ? jp.getText() : valueDes.deserialize(jp, ctxt);\n+            value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt);\n         }\n         result.add(value);\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n     public String deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        JsonToken curr = jp.getCurrentToken();\n-        // Usually should just get string value:\n-        if (curr == JsonToken.VALUE_STRING) {\n-            return jp.getText();\n+        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n+        String text = jp.getValueAsString();\n+        if (text != null) {\n+            return text;\n         }\n         // [JACKSON-330]: need to gracefully handle byte[] data, as base64\n+        JsonToken curr = jp.getCurrentToken();\n         if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n             Object ob = jp.getEmbeddedObject();\n             if (ob == null) {\n             }\n             // otherwise, try conversion using toString()...\n             return ob.toString();\n-        }\n-        // Can deserialize any scalar value, but not markers\n-        if (curr.isScalarValue()) {\n-            return jp.getText();\n         }\n         throw ctxt.mappingException(_valueClass, curr);\n     }", "timestamp": 1348374135, "metainfo": ""}