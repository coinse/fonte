{"sha": "e6cc4ceff4e1d119f1779d1370ff99aaa2911f23", "log": "Updated TokenQueue so :contains(text) can be escaped, if looking for ( or ) within text", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n  */\n public class TokenQueue {\n     private LinkedList<Character> queue;\n+    private static final Character ESC = '\\\\'; // escape char for chomp balanced.\n \n     /**\n      Create a new TokenQueue.\n \n     /**\n      * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n-     * and leave \" four\" on the queue\n+     * and leave \" four\" on the queue. Unbalanced openers and closers can be escaped (with \\). Those escapes will be left\n+     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n+     * contains text strings; use unescape for that.\n      * @param open opener\n      * @param close closer\n      * @return data matched from the queue\n     public String chompBalanced(Character open, Character close) {\n         StringBuilder accum = new StringBuilder();\n         int depth = 0;\n-        int i = 0;\n+        Character last = null;\n+\n         do {\n             if (queue.isEmpty()) break;\n             Character c = consume();\n-            if (c.equals(open))\n-                depth++;\n-            else if (c.equals(close))\n-                depth--;\n-\n-            if (depth > 0 && i > 0)\n-                accum.append(c); // dont include the outer match pair in the return\n-            i++;\n+            if (last == null || !last.equals(ESC)) {\n+                if (c.equals(open))\n+                    depth++;\n+                else if (c.equals(close))\n+                    depth--;\n+            }\n+\n+            if (depth > 0 && last != null)\n+                accum.append(c); // don't include the outer match pair in the return\n+            last = c;\n         } while (depth > 0);\n         return accum.toString();\n+    }\n+    \n+    /**\n+     * Unescaped a \\ escaped string.\n+     * @param in backslash escaped string\n+     * @return unescaped string\n+     */\n+    public static String unescape(String in) {\n+        StringBuilder out = new StringBuilder();\n+        Character last = null;\n+        for (Character c : in.toCharArray()) {\n+            if (c.equals(ESC)) {\n+                if (last != null && last.equals(ESC))\n+                    out.append(c);\n+            }\n+            else \n+                out.append(c);\n+            last = c;\n+        }\n+        return out.toString();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n             return indexEquals();\n         } else if (tq.matches(\":has(\")) {\n             return has();\n-        } else if (tq.matchChomp(\":contains(\")) {\n+        } else if (tq.matches(\":contains(\")) {\n             return contains();\n         } else { // unhandled\n             throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n     // pseudo selector :contains(text)\n     // todo: allow escaped ) in there. probably do a balanced match, for convenience of caller\n     private Elements contains() {\n-        String searchText = tq.chompTo(\")\");\n+        tq.consume(\":contains\");\n+        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n         Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n         \n         return root.getElementsContainingText(searchText);\n--- a/src/test/java/org/jsoup/parser/TokenQueueTest.java\n+++ b/src/test/java/org/jsoup/parser/TokenQueueTest.java\n         assertEquals(\"one (two) three\", guts);\n         assertEquals(\" four\", remainder);\n     }\n+    \n+    @Test public void chompEscapedBalanced() {\n+        TokenQueue tq = new TokenQueue(\":contains(one (two) \\\\( \\\\) \\\\) three) four\");\n+        String pre = tq.consumeTo(\"(\");\n+        String guts = tq.chompBalanced('(', ')');\n+        String remainder = tq.remainder();\n+\n+        assertEquals(\":contains\", pre);\n+        assertEquals(\"one (two) \\\\( \\\\) \\\\) three\", guts);\n+        assertEquals(\"one (two) ( ) ) three\", TokenQueue.unescape(guts));\n+        assertEquals(\" four\", remainder);\n+    }\n \n     @Test public void chompBalancedMatchesAsMuchAsPossible() {\n         TokenQueue tq = new TokenQueue(\"unbalanced(something(or another\");\n         String match = tq.chompBalanced('(', ')');\n         assertEquals(\"something(or another\", match);\n     }\n+    \n+    @Test public void unescape() {\n+        assertEquals(\"one ( ) \\\\\", TokenQueue.unescape(\"one \\\\( \\\\) \\\\\\\\\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(1, ps3.size());\n         assertEquals(\"light\", ps3.first().className());\n     }\n+    \n+    @Test public void testPsuedoContainsWithParentheses() {\n+        Document doc = Jsoup.parse(\"<div><p id=1>This (is good)</p><p id=2>This is bad)</p>\");\n+        \n+        Elements ps1 = doc.select(\"p:contains(this (is good))\");\n+        assertEquals(1, ps1.size());\n+        assertEquals(\"1\", ps1.first().id());\n+        \n+        Elements ps2 = doc.select(\"p:contains(this is bad\\\\))\");\n+        assertEquals(1, ps2.size());\n+        assertEquals(\"2\", ps2.first().id());\n+    }\n }", "timestamp": 1309605114, "metainfo": ""}