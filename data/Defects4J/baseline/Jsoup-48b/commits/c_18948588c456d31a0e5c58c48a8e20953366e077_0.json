{"sha": "18948588c456d31a0e5c58c48a8e20953366e077", "log": "Don't allocate new char[]s for every character reference", "commit": "\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         selfClosingFlagAcknowledged = true;\n     }\n \n+    final private char[] charRefHolder = new char[1]; // holder to not have to keep creating arrays\n     char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (reader.matchesAnySorted(notCharRefCharsSorted))\n             return null;\n \n+        final char[] charRef = charRefHolder;\n         reader.mark();\n         if (reader.matchConsume(\"#\")) { // numbered\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return new char[]{replacementChar};\n+                charRef[0] = replacementChar;\n+                return charRef;\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n+                if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+                    charRef[0] = (char) charval;\n+                    return charRef;\n+                } else\n                 return Character.toChars(charval);\n             }\n         } else { // named\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return new char[]{Entities.getCharacterByName(nameRef)};\n+            charRef[0] = Entities.getCharacterByName(nameRef);\n+            return charRef;\n         }\n     }\n ", "timestamp": 1414560857, "metainfo": ""}