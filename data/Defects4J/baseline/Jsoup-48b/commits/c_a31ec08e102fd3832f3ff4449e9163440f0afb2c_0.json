{"sha": "a31ec08e102fd3832f3ff4449e9163440f0afb2c", "log": "Refactored entity decoding.  Modified the heuristic entity decoder to be less greedy; does not repeatedly chomp down the string until a match is found, and requires a semicolon terminator for extended entities.  Updated Entities to use the entity decoder in Tokeniser, vs the legacy decoder.  Fixes #224.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n+\n+import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n import java.io.InputStream;\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n+    private static final Map<String, Character> base;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n     private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\n \n     /**\n      * Check if the input is a known named entity\n-     * @param name the possible entity name (e.g. \"lt\" or \"amp\"\n+     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity\n      */\n     public static boolean isNamedEntity(String name) {\n         return full.containsKey(name);\n+    }\n+\n+    /**\n+     * Check if the input is a known named entity in the base entity set.\n+     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n+     * @return true if a known named entity in the base set\n+     * @see #isNamedEntity(String)\n+     */\n+    public static boolean isBaseNamedEntity(String name) {\n+        return base.containsKey(name);\n     }\n \n     /**\n      * @return\n      */\n     static String unescape(String string, boolean strict) {\n-        // todo: change this method to use Tokeniser.consumeCharacterReference\n-        if (!string.contains(\"&\"))\n-            return string;\n-\n-        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\\\d*);?\n-        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n-        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n-\n-        while (m.find()) {\n-            int charval = -1;\n-            String num = m.group(3);\n-            if (num != null) {\n-                try {\n-                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n-                    charval = Integer.valueOf(num, base);\n-                } catch (NumberFormatException e) {\n-                } // skip\n-            } else {\n-                String name = m.group(1);\n-                if (full.containsKey(name))\n-                    charval = full.get(name);\n-            }\n-\n-            if (charval != -1 || charval > 0xFFFF) { // out of range\n-                String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n-            } else {\n-                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n-            }\n-        }\n-        m.appendTail(accum);\n-        return accum.toString();\n+        return Parser.unescapeEntities(string, strict);\n     }\n \n     // xhtml has restricted entities\n \n     static {\n         xhtmlByVal = new HashMap<Character, String>();\n-        baseByVal = toCharacterKey(loadEntities(\"entities-base.properties\")); // most common / default\n+        base = loadEntities(\"entities-base.properties\");  // most common / default\n+        baseByVal = toCharacterKey(base);\n         full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n         fullByVal = toCharacterKey(full);\n \n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     }\n \n     /**\n+     * Utility method to unescape HTML entities from a string\n+     * @param string HTML escaped string\n+     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n+     * @return an unescaped string\n+     */\n+    public static String unescapeEntities(String string, boolean inAttribute) {\n+        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n+        return tokeniser.unescapeEntities(inAttribute);\n+    }\n+\n+    /**\n      * @param bodyHtml HTML to parse\n      * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n      *\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n                 return (char) charval;\n             }\n         } else { // named\n-            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n+            // get as many letters as possible, and look for matching entities.\n             String nameRef = reader.consumeLetterThenDigitSequence();\n-            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n             boolean looksLegit = reader.matches(';');\n-            boolean found = false;\n-            while (nameRef.length() > 0 && !found) {\n-                if (Entities.isNamedEntity(nameRef))\n-                    found = true;\n-                else {\n-                    nameRef = nameRef.substring(0, nameRef.length()-1);\n-                    reader.unconsume();\n-                }\n-            }\n+            // found if a base named entity without a ;, or an extended entity with the ;.\n+            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n+\n             if (!found) {\n+                reader.rewindToMark();\n                 if (looksLegit) // named with semicolon\n-                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n-                reader.rewindToMark();\n+                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n                 return null;\n             }\n             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n         // Element currentNode = currentNode();\n         // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n     }\n+\n+    /**\n+     * Utility method to consume reader and unescape entities found within.\n+     * @param inAttribute\n+     * @return unescaped string from reader\n+     */\n+    String unescapeEntities(boolean inAttribute) {\n+        StringBuilder builder = new StringBuilder();\n+        while (!reader.isEmpty()) {\n+            builder.append(reader.consumeTo('&'));\n+            if (reader.matches('&')) {\n+                reader.consume();\n+                Character c = consumeCharacterReference(null, inAttribute);\n+                if (c == null)\n+                    builder.append('&');\n+                else\n+                    builder.append(c);\n+            }\n+        }\n+        return builder.toString();\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n-import org.jsoup.nodes.Entities;\n \n import java.nio.charset.Charset;\n \n     }\n \n     @Test public void unescape() {\n-        String text = \"Hello &amp;&LT&gt; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n-        assertEquals(\"Hello &<> \u00c5 \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n+        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n+        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n \n         assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));\n     }\n \n     @Test public void strictUnescape() { // for attributes, enforce strict unescaping (must look like &xxx; , not just &xxx)\n-        String text = \"Hello &mid &amp;\";\n-        assertEquals(\"Hello &mid &\", Entities.unescape(text, true));\n-        assertEquals(\"Hello \u2223 &\", Entities.unescape(text));\n-        assertEquals(\"Hello \u2223 &\", Entities.unescape(text, false));\n+        String text = \"Hello &amp= &amp;\";\n+        assertEquals(\"Hello &amp= &\", Entities.unescape(text, true));\n+        assertEquals(\"Hello &= &\", Entities.unescape(text));\n+        assertEquals(\"Hello &= &\", Entities.unescape(text, false));\n     }\n \n     \n         assertEquals(\"&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;\", p.html());\n         assertEquals(\"\u00b9\u00b2\u00b3\u00bc\u00bd\u00be\", p.text());\n     }\n+\n+    @Test public void noSpuriousDecodes() {\n+        String string = \"http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\";\n+        assertEquals(string, Entities.unescape(string));\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n     @Test public void strictAttributeUnescapes() {\n         String html = \"<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>\";\n         Elements els = Jsoup.parse(html).select(\"a\");\n-        assertEquals(\"?foo=bar\u2223&lt=true\", els.first().attr(\"href\")); // &mid gets to \u2223 because not tailed by =; lt is so not unescaped\n+        assertEquals(\"?foo=bar&mid&lt=true\", els.first().attr(\"href\"));\n         assertEquals(\"?foo=bar<qux&lg=1\", els.last().attr(\"href\"));\n     }\n \n     @Test public void moreAttributeUnescapes() {\n         String html = \"<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>\";\n         Elements els = Jsoup.parse(html).select(\"a\");\n-        assertEquals(\"&wr_id=123&mid-size=true&ok=\u2240\", els.first().attr(\"href\"));\n+        assertEquals(\"&wr_id=123&mid-size=true&ok=&wr\", els.first().attr(\"href\"));\n     }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         assertEquals(\"html\", nodes.get(0).nodeName());\n         assertEquals(\"<html> <head></head> <body> <ol> <li>One</li> </ol> <p>Two</p> </body> </html>\", StringUtil.normaliseWhitespace(nodes.get(0).outerHtml()));\n     }\n+\n+    @Test public void doesNotFindShortestMatchingEntity() {\n+        // previous behaviour was to identify a possible entity, then chomp down the string until a match was found.\n+        // (as defined in html5.) However in practise that lead to spurious matches against the author's intent.\n+        String html = \"One &clubsuite; &clubsuit;\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(StringUtil.normaliseWhitespace(\"One &amp;clubsuite; \u2663\"), doc.body().html());\n+    }\n+\n+    @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch() {\n+        // extended entities need a ; at the end to match, base does not\n+        String html = \"&amp &quot &reg &icy &hopf &icy; &hopf;\";\n+        Document doc = Jsoup.parse(html);\n+        doc.outputSettings().escapeMode(Entities.EscapeMode.extended); // modifies output only to clarify test\n+        assertEquals(StringUtil.normaliseWhitespace(\"&amp; &quot; &reg; &amp;icy &amp;hopf &icy; &hopf;\"), doc.body().html());\n+    }\n }", "timestamp": 1348427812, "metainfo": ""}