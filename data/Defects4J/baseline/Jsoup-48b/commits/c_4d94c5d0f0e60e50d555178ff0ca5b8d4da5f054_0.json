{"sha": "4d94c5d0f0e60e50d555178ff0ca5b8d4da5f054", "log": "Modified Node.clone() to use iterative approach.  Uses BFS to clone nodes. Fixes #290.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.LinkedList;\n import java.util.List;\n \n /**\n      */\n     @Override\n     public Node clone() {\n-        return doClone(null); // splits for orphan\n-    }\n-\n+        Node thisClone = doClone(null); // splits for orphan\n+\n+        // Queue up nodes that need their children cloned (BFS).\n+        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n+        nodesToProcess.add(thisClone);\n+\n+        while (!nodesToProcess.isEmpty()) {\n+            Node currParent = nodesToProcess.remove();\n+\n+            for (int i = 0; i < currParent.childNodes.size(); i++) {\n+                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n+                currParent.childNodes.set(i, childClone);\n+                nodesToProcess.add(childClone);\n+            }\n+        }\n+\n+        return thisClone;\n+    }\n+\n+    /*\n+     * Return a clone of the node using the given parent (which can be null).\n+     * Not a deep copy of children.\n+     */\n     protected Node doClone(Node parent) {\n         Node clone;\n+\n         try {\n             clone = (Node) super.clone();\n         } catch (CloneNotSupportedException e) {\n         clone.attributes = attributes != null ? attributes.clone() : null;\n         clone.baseUri = baseUri;\n         clone.childNodes = new ArrayList<Node>(childNodes.size());\n+\n         for (Node child: childNodes)\n-            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n+            clone.childNodes.add(child);\n \n         return clone;\n     }", "timestamp": 1360378812, "metainfo": ""}