{"sha": "147df44faa4eb12ffd4a0063fc3284f784ea67c8", "log": "Style update  ", "commit": "\n--- a/src/java/org/apache/commons/cli/AlreadySelectedException.java\n+++ b/src/java/org/apache/commons/cli/AlreadySelectedException.java\n  * has been provided.\n  *\n  * @author John Keyes ( john at integralsource.com )\n- * @see ParseException\n+ * @version $Revision$, $Date$\n  */\n public class AlreadySelectedException extends ParseException\n {\n      */\n     public AlreadySelectedException(OptionGroup group, Option option)\n     {\n-        this(\"The option '\" + option.getKey() + \"' was specified but an option from this group \" +\n-                \"has already been selected: '\" + group.getSelected() + \"'\");\n+        this(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+                + \"has already been selected: '\" + group.getSelected() + \"'\");\n         this.group = group;\n         this.option = option;\n     }\n     /**\n      * Returns the option group where another option has been selected.\n      *\n+     * @return the related option group\n      * @since 1.2\n      */\n     public OptionGroup getOptionGroup()\n     /**\n      * Returns the option that was added to the group and triggered the exception.\n      *\n+     * @return the related option\n      * @since 1.2\n      */\n     public Option getOption()\n--- a/src/java/org/apache/commons/cli/BasicParser.java\n+++ b/src/java/org/apache/commons/cli/BasicParser.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n /**\n  * the {@link Parser#flatten(Options,String[],boolean) flatten} method.\n  *\n  * @author John Keyes (john at integralsource.com)\n- * @see Parser\n+ * @version $Revision$, $Date$\n  */\n-public class BasicParser extends Parser {\n-\n+public class BasicParser extends Parser\n+{\n     /**\n      * <p>A simple implementation of {@link Parser}'s abstract\n-     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n+     * {@link Parser#flatten(Options, String[], boolean) flatten} method.</p>\n      *\n      * <p><b>Note:</b> <code>options</code> and <code>stopAtNonOption</code>\n      * are not used in this <code>flatten</code> method.</p>\n      * when an non option is found.\n      * @return The <code>arguments</code> String array.\n      */\n-    protected String[] flatten(Options options, String[] arguments, \n-                               boolean stopAtNonOption)\n+    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n     {\n         // just echo the arguments\n         return arguments;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n import java.io.Serializable;\n import java.util.List;\n import java.util.Properties;\n \n-/** \n- * <p>Represents list of arguments parsed against\n- * a {@link Options} descriptor.<p>\n+/**\n+ * Represents list of arguments parsed against a {@link Options} descriptor.\n  *\n  * <p>It allows querying of a boolean {@link #hasOption(String opt)},\n  * in addition to retrieving the {@link #getOptionValue(String opt)}\n  * @author bob mcwhirter (bob @ werken.com)\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n  */\n-public class CommandLine implements Serializable {\n-\n+public class CommandLine implements Serializable\n+{\n     private static final long serialVersionUID = 1L;\n \n     /** the unrecognised options/arguments */\n     /** the processed options */\n     private List options = new ArrayList();\n \n-    /** Map of unique options for ease to get complete list of options */\n-//    private Set allOptions = new HashSet();\n-\n     /**\n      * Creates a command line.\n      */\n      */\n     public boolean hasOption(String opt)\n     {\n-        return options.contains( resolveOption(opt));\n+        return options.contains(resolveOption(opt));\n     }\n \n     /** \n     {\n         List values = new ArrayList();\n \n-        for ( Iterator it = options.iterator(); it.hasNext(); )\n+        for (Iterator it = options.iterator(); it.hasNext();)\n         {\n             Option option = (Option) it.next();\n-            if (opt.equals(option.getOpt()) || opt.equals( option.getLongOpt()))\n+            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n             {\n                 values.addAll(option.getValuesList());\n             }\n     }\n \n     /**\n-     * <p>Retrieves the option object given the long or short option as a String</p>\n+     * Retrieves the option object given the long or short option as a String\n+     * \n      * @param opt short or long name of the option\n      * @return Canonicalized option\n      */\n-    private Option resolveOption( String opt )\n+    private Option resolveOption(String opt)\n     {\n         opt = Util.stripLeadingHyphens(opt);\n-        for ( Iterator it = options.iterator(); it.hasNext(); )\n+        for (Iterator it = options.iterator(); it.hasNext();)\n         {\n             Option option = (Option) it.next();\n             if (opt.equals(option.getOpt()))\n             {\n                 return option;\n             }\n-            if (opt.equals( option.getLongOpt()))\n+\n+            if (opt.equals(option.getLongOpt()))\n             {\n                 return option;\n-        }\n+            }\n \n         }\n         return null;\n      * Retrieve the argument, if any, of an option.\n      *\n      * @param opt name of the option\n-     * @param defaultValue is the default value to be returned if the option \n+     * @param defaultValue is the default value to be returned if the option\n      * is not specified\n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise <code>defaultValue</code>.\n      * Retrieve the argument, if any, of an option.\n      *\n      * @param opt character name of the option\n-     * @param defaultValue is the default value to be returned if the option \n+     * @param defaultValue is the default value to be returned if the option\n      * is not specified\n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise <code>defaultValue</code>.\n                 {\n                     // no explicit value, handle it as a boolean\n                     props.put(values.get(0), \"true\");\n-                }                \n+                }\n             }\n         }\n \n     }\n \n     /**\n-     * Add an option to the command line.  The values of \n-     * the option are stored.\n+     * Add an option to the command line.  The values of the option are stored.\n      *\n      * @param opt the processed option\n      */\n     /**\n      * Returns an iterator over the Option members of CommandLine.\n      *\n-     * @return an <code>Iterator</code> over the processed {@link Option} \n+     * @return an <code>Iterator</code> over the processed {@link Option}\n      * members of this {@link CommandLine}\n      */\n     public Iterator iterator()\n--- a/src/java/org/apache/commons/cli/CommandLineParser.java\n+++ b/src/java/org/apache/commons/cli/CommandLineParser.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n-import java.util.Properties;\n-\n /**\n- * A class that implements the <code>CommandLineParser</code> interface \n+ * A class that implements the <code>CommandLineParser</code> interface\n  * can parse a String array according to the {@link Options} specified\n  * and return a {@link CommandLine}.\n  *\n  * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n  */\n-public interface CommandLineParser {\n-\n+public interface CommandLineParser\n+{\n     /**\n      * Parse the arguments according to the specified options.\n      *\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    CommandLine parse(Options options, String[] arguments)\n-               throws ParseException;\n+    CommandLine parse(Options options, String[] arguments) throws ParseException;\n \n     /**\n      * Parse the arguments according to the specified options and\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    /* To maintain binary compatibility, this is commented out. \n-       It is still in the abstract Parser class, so most users will \n-       still reap the benefit. \n-    CommandLine parse(Options options, String[] arguments, \n-                      Properties properties)\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties)\n                throws ParseException;\n      */\n \n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    CommandLine parse(Options options, String[] arguments, \n-                      boolean stopAtNonOption)\n-               throws ParseException;\n+    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n \n     /**\n      * Parse the arguments according to the specified options and\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    /* To maintain binary compatibility, this is commented out. \n-       It is still in the abstract Parser class, so most users will \n-       still reap the benefit. \n-    CommandLine parse(Options options, String[] arguments, \n-                      Properties properties, boolean stopAtNonOption)\n-               throws ParseException;\n+    /* To maintain binary compatibility, this is commented out.\n+       It is still in the abstract Parser class, so most users will\n+       still reap the benefit.\n+    CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException;\n      */\n }\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n import java.util.List;\n \n /**\n- * The class GnuParser provides an implementation of the \n- * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n+ * The class GnuParser provides an implementation of the\n+ * {@link Parser#flatten(Options, String[], boolean) flatten} method.\n  *\n  * @author John Keyes (john at integralsource.com)\n- * @see Parser\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class GnuParser extends Parser {\n-\n+public class GnuParser extends Parser\n+{\n     /**\n-     * <p>This flatten method does so using the following rules:\n+     * This flatten method does so using the following rules:\n      * <ol>\n-     *  <li>If an {@link Option} exists for the first character of \n-     *  the <code>arguments</code> entry <b>AND</b> an {@link Option} \n-     *  does not exist for the whole <code>argument</code> then\n-     *  add the first character as an option to the processed tokens\n-     *  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n-     *  <li>Otherwise just add the token to the processed tokens list.\n-     *  </li>\n+     *   <li>If an {@link Option} exists for the first character of\n+     *   the <code>arguments</code> entry <b>AND</b> an {@link Option}\n+     *   does not exist for the whole <code>argument</code> then\n+     *   add the first character as an option to the processed tokens\n+     *   list e.g. \"-D\" and add the rest of the entry to the also.</li>\n+     *   <li>Otherwise just add the token to the processed tokens list.</li>\n      * </ol>\n-     * </p>\n      *\n-     * @param options The Options to parse the arguments by.\n-     * @param arguments The arguments that have to be flattened.\n-     * @param stopAtNonOption specifies whether to stop \n-     * flattening when a non option has been encountered\n+     * @param options         The Options to parse the arguments by.\n+     * @param arguments       The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop flattening when\n+     *                        a non option has been encountered\n      * @return a String array of the flattened arguments\n      */\n     protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n  *\n  * @author Slawek Zachcial\n  * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n  */\n-public class HelpFormatter {\n+public class HelpFormatter\n+{\n     // --------------------------------------------------------------- Constants\n \n     /** default number of characters per line */\n      */\n     public int getWidth()\n     {\n-        return this.defaultWidth;\n+        return defaultWidth;\n     }\n \n     /**\n      */\n     public int getLeftPadding()\n     {\n-        return this.defaultLeftPad;\n+        return defaultLeftPad;\n     }\n \n     /**\n      */\n     public int getDescPadding()\n     {\n-        return this.defaultDescPad;\n+        return defaultDescPad;\n     }\n \n     /**\n      */\n     public String getSyntaxPrefix()\n     {\n-        return this.defaultSyntaxPrefix;\n+        return defaultSyntaxPrefix;\n     }\n \n     /**\n      */\n     public String getNewLine()\n     {\n-        return this.defaultNewLine;\n+        return defaultNewLine;\n     }\n \n     /**\n      */\n     public String getOptPrefix()\n     {\n-        return this.defaultOptPrefix;\n+        return defaultOptPrefix;\n     }\n \n     /**\n      */\n     public String getLongOptPrefix()\n     {\n-        return this.defaultLongOptPrefix;\n+        return defaultLongOptPrefix;\n     }\n \n     /**\n      */\n     public String getArgName()\n     {\n-        return this.defaultArgName;\n+        return defaultArgName;\n     }\n \n     /**\n      * \n      * Defaults to case-insensitive alphabetical sorting by option key\n      */\n-    public Comparator getOptionComparator() \n-    {\n-        return this.optionComparator;\n+    public Comparator getOptionComparator()\n+    {\n+        return optionComparator;\n     }\n \n     /**\n      * \n      * Passing in a null parameter will set the ordering to the default mode\n      */\n-    public void setOptionComparator(Comparator comparator) \n-    {\n-        if ( comparator == null ) \n+    public void setOptionComparator(Comparator comparator)\n+    {\n+        if (comparator == null)\n         {\n             this.optionComparator = new OptionComparator();\n-        } \n-        else \n+        }\n+        else\n         {\n             this.optionComparator = comparator;\n         }\n     }\n \n-\n-    // ------------------------------------------------------------------ Public\n-\n-    /**\n-     * <p>Print the help for <code>options</code> with the specified\n+    /**\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to\n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param cmdLineSyntax the syntax for this application\n      * @param options the Options instance\n     }\n \n     /**\n-     * <p>Print the help for <code>options</code> with the specified\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to \n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param cmdLineSyntax the syntax for this application\n      * @param options the Options instance\n-     * @param autoUsage whether to print an automatically generated \n+     * @param autoUsage whether to print an automatically generated\n      * usage statement\n      */\n-    public void printHelp(String cmdLineSyntax, Options options, \n-                          boolean autoUsage)\n+    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n     {\n         printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n     }\n \n     /**\n-     * <p>Print the help for <code>options</code> with the specified\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to\n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param cmdLineSyntax the syntax for this application\n      * @param header the banner to display at the begining of the help\n      * @param options the Options instance\n      * @param footer the banner to display at the end of the help\n      */\n-    public void printHelp(String cmdLineSyntax, String header, Options options, \n-                          String footer)\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n     {\n         printHelp(cmdLineSyntax, header, options, footer, false);\n     }\n \n     /**\n-     * <p>Print the help for <code>options</code> with the specified\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to \n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param cmdLineSyntax the syntax for this application\n      * @param header the banner to display at the begining of the help\n      * @param options the Options instance\n      * @param footer the banner to display at the end of the help\n-     * @param autoUsage whether to print an automatically generated \n+     * @param autoUsage whether to print an automatically generated\n      * usage statement\n      */\n-    public void printHelp(String cmdLineSyntax, String header, Options options, \n-                          String footer, boolean autoUsage)\n-    {\n-        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n-                  autoUsage);\n-    }\n-\n-    /**\n-     * <p>Print the help for <code>options</code> with the specified\n+    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n+    }\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to\n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param width the number of characters to be displayed on each line\n      * @param cmdLineSyntax the syntax for this application\n      * @param options the Options instance\n      * @param footer the banner to display at the end of the help\n      */\n-    public void printHelp(int width, String cmdLineSyntax, String header, \n-                          Options options, String footer)\n+    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n     {\n         printHelp(width, cmdLineSyntax, header, options, footer, false);\n     }\n \n     /**\n-     * <p>Print the help for <code>options</code> with the specified\n+     * Print the help for <code>options</code> with the specified\n      * command line syntax.  This method prints help information to\n-     * System.out.</p>\n+     * System.out.\n      *\n      * @param width the number of characters to be displayed on each line\n      * @param cmdLineSyntax the syntax for this application\n      * @param autoUsage whether to print an automatically generated \n      * usage statement\n      */\n-    public void printHelp(int width, String cmdLineSyntax, String header, \n+    public void printHelp(int width, String cmdLineSyntax, String header,\n                           Options options, String footer, boolean autoUsage)\n     {\n         PrintWriter pw = new PrintWriter(System.out);\n \n-        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n-                  defaultDescPad, footer, autoUsage);\n+        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n         pw.flush();\n     }\n \n     /**\n-     * <p>Print the help for <code>options</code> with the specified\n-     * command line syntax.</p>\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n      *\n      * @param pw the writer to which the help will be written\n      * @param width the number of characters to be displayed on each line\n                           String header, Options options, int leftPad, \n                           int descPad, String footer)\n     {\n-        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n-                  footer, false);\n-    }\n-\n-\n-    /**\n-     * <p>Print the help for <code>options</code> with the specified\n-     * command line syntax.</p>\n+        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n+    }\n+\n+\n+    /**\n+     * Print the help for <code>options</code> with the specified\n+     * command line syntax.\n      *\n      * @param pw the writer to which the help will be written\n      * @param width the number of characters to be displayed on each line\n      * @param descPad the number of characters of padding to be prefixed\n      * to each description line\n      * @param footer the banner to display at the end of the help\n-     * @param autoUsage whether to print an automatically generated \n+     * @param autoUsage whether to print an automatically generated\n      * usage statement\n      */\n-    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n-                          String header, Options options, int leftPad, \n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n+                          String header, Options options, int leftPad,\n                           int descPad, String footer, boolean autoUsage)\n     {\n         if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n      * @param options The command line Options\n      *\n      */\n-    public void printUsage(PrintWriter pw, int width, String app, \n-                           Options options)\n+    public void printUsage(PrintWriter pw, int width, String app, Options options)\n     {\n         // initialise the string buffer\n-        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n-                                                                 .append(\" \");\n+        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n \n         // create a list for processed option groups\n         final Collection processedGroups = new ArrayList();\n         Option option;\n \n         List optList = new ArrayList(options.getOptions());\n-        Collections.sort(optList, getOptionComparator() );\n+        Collections.sort(optList, getOptionComparator());\n         // iterate over the options\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n \n \n         // call printWrapped\n-        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n-                     buff.toString());\n+        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n     }\n \n     /**\n      * @param group the group to append\n      * @see #appendOption(StringBuffer,Option,boolean)\n      */\n-    private void appendOptionGroup(final StringBuffer buff, \n-                                          final OptionGroup group)\n+    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n     {\n         if (!group.isRequired())\n         {\n         }\n \n         List optList = new ArrayList(group.getOptions());\n-        Collections.sort(optList, getOptionComparator() );\n+        Collections.sort(optList, getOptionComparator());\n         // for each option in the OptionGroup\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n      * @param option the Option to append\n      * @param required whether the Option is required or not\n      */\n-    private static void appendOption(final StringBuffer buff, \n-                                     final Option option, \n-                                     final boolean required)\n+    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n     {\n         if (!required)\n         {\n     }\n \n     /**\n-     * <p>Print the cmdLineSyntax to the specified writer, using the\n-     * specified width.</p>\n+     * Print the cmdLineSyntax to the specified writer, using the\n+     * specified width.\n      *\n      * @param pw The printWriter to write the help to\n      * @param width The number of characters per line for the usage statement.\n     {\n         int argPos = cmdLineSyntax.indexOf(' ') + 1;\n \n-        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n-                     defaultSyntaxPrefix + cmdLineSyntax);\n+        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Print the specified text to the specified PrintWriter.</p>\n+     * Print the specified text to the specified PrintWriter.\n      *\n      * @param pw The printWriter to write the help to\n      * @param width The number of characters to display per line\n     }\n \n     /**\n-     * <p>Print the specified text to the specified PrintWriter.</p>\n+     * Print the specified text to the specified PrintWriter.\n      *\n      * @param pw The printWriter to write the help to\n      * @param width The number of characters to display per line\n      * @param nextLineTabStop The position on the next line for the first tab.\n      * @param text The text to be written to the PrintWriter\n      */\n-    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n-                             String text)\n+    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n     {\n         StringBuffer sb = new StringBuffer(text.length());\n \n     // --------------------------------------------------------------- Protected\n \n     /**\n-     * <p>Render the specified Options and return the rendered Options\n-     * in a StringBuffer.</p>\n+     * Render the specified Options and return the rendered Options\n+     * in a StringBuffer.\n      *\n      * @param sb The StringBuffer to place the rendered Options into.\n      * @param width The number of characters to display per line\n      *\n      * @return the StringBuffer with the rendered Options contents.\n      */\n-    protected StringBuffer renderOptions(StringBuffer sb, int width, \n-                                         Options options, int leftPad, \n-                                         int descPad)\n+    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n     {\n         final String lpad = createPadding(leftPad);\n         final String dpad = createPadding(descPad);\n         int max = 0;\n         StringBuffer optBuf;\n         List prefixList = new ArrayList();\n-        Option option;\n+\n         List optList = options.helpOptions();\n \n-        Collections.sort(optList, getOptionComparator() );\n+        Collections.sort(optList, getOptionComparator());\n \n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n-            option = (Option) i.next();\n+            Option option = (Option) i.next();\n             optBuf = new StringBuffer(8);\n \n             if (option.getOpt() == null)\n             {\n-                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n-                      .append(option.getLongOpt());\n+                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n             }\n             else\n             {\n-                optBuf.append(lpad).append(defaultOptPrefix)\n-                      .append(option.getOpt());\n+                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n \n                 if (option.hasLongOpt())\n                 {\n-                    optBuf.append(',').append(defaultLongOptPrefix)\n-                          .append(option.getLongOpt());\n+                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                 }\n             }\n \n             }\n \n             prefixList.add(optBuf);\n-            max = (optBuf.length() > max)       ? optBuf.length() : max;\n+            max = (optBuf.length() > max) ? optBuf.length() : max;\n         }\n \n         int x = 0;\n \n         for (Iterator i = optList.iterator(); i.hasNext();)\n         {\n-            option = (Option) i.next();\n+            Option option = (Option) i.next();\n             optBuf = new StringBuffer(prefixList.get(x++).toString());\n \n             if (optBuf.length() < max)\n     }\n \n     /**\n-     * <p>Render the specified text and return the rendered Options\n-     * in a StringBuffer.</p>\n+     * Render the specified text and return the rendered Options\n+     * in a StringBuffer.\n      *\n      * @param sb The StringBuffer to place the rendered text into.\n      * @param width The number of characters to display per line\n     }\n \n     /**\n-     * Finds the next text wrap position after <code>startPos</code> for the \n+     * Finds the next text wrap position after <code>startPos</code> for the\n      * text in <code>text</code> with the column width <code>width</code>.\n      * The wrap point is the last postion before startPos+width having a \n      * whitespace character (space, \\n, \\r).\n      *\n      * @param text The text being searched for the wrap position\n      * @param width width of the wrapped text\n-     * @param startPos position from which to start the lookup whitespace \n+     * @param startPos position from which to start the lookup whitespace\n      * character\n-     * @return postion on which the text must be wrapped or -1 if the wrap \n+     * @return postion on which the text must be wrapped or -1 if the wrap\n      * position is at the end of the text\n      */\n     protected int findWrapPos(String text, int width, int startPos)\n \n         // the line ends before the max wrap pos or a new line char found\n         if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n-            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n-        {\n-            return pos+1;\n-        }\n-        else if ((startPos + width) >= text.length())\n+                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n+        {\n+            return pos + 1;\n+        }\n+        else if (startPos + width >= text.length())\n         {\n             return -1;\n         }\n         char c;\n \n         while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n+                && (c != '\\n') && (c != '\\r'))\n         {\n             --pos;\n         }\n             ++pos;\n         }\n \n-        return (pos == text.length())        ? (-1) : pos;\n-    }\n-\n-    /**\n-     * <p>Return a String of padding of length <code>len</code>.</p>\n+        return (pos == text.length()) ? (-1) : pos;\n+    }\n+\n+    /**\n+     * Return a String of padding of length <code>len</code>.\n      *\n      * @param len The length of the String of padding to create.\n      *\n     }\n \n     /**\n-     * <p>Remove the trailing whitespace from the specified String.</p>\n+     * Remove the trailing whitespace from the specified String.\n      *\n      * @param s The String to remove the trailing padding from.\n      *\n     // ---------------------------------------------------------------- Private\n     // ---------------------------------------------------------- Inner classes\n     /**\n-     * <p>This class implements the <code>Comparator</code> interface\n-     * for comparing Options.</p>\n-     */\n-    private static class OptionComparator\n-        implements Comparator {\n+     * This class implements the <code>Comparator</code> interface\n+     * for comparing Options.\n+     */\n+    private static class OptionComparator implements Comparator\n+    {\n \n         /**\n-         * <p>Compares its two arguments for order. Returns a negative \n-         * integer, zero, or a positive integer as the first argument \n-         * is less than, equal to, or greater than the second.</p>\n+         * Compares its two arguments for order. Returns a negative\n+         * integer, zero, or a positive integer as the first argument\n+         * is less than, equal to, or greater than the second.\n          *\n          * @param o1 The first Option to be compared.\n          * @param o2 The second Option to be compared.\n-         *\n-         * @return a negative integer, zero, or a positive integer as \n-         * the first argument is less than, equal to, or greater than the \n-         * second.\n+         * @return a negative integer, zero, or a positive integer as\n+         *         the first argument is less than, equal to, or greater than the\n+         *         second.\n          */\n         public int compare(Object o1, Object o2)\n         {\n-            Option opt1 = (Option)o1;\n-            Option opt2 = (Option)o2;\n+            Option opt1 = (Option) o1;\n+            Option opt2 = (Option) o2;\n \n             return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n         }\n--- a/src/java/org/apache/commons/cli/MissingArgumentException.java\n+++ b/src/java/org/apache/commons/cli/MissingArgumentException.java\n  * is not provided with an argument.\n  *\n  * @author John Keyes (john at integralsource.com)\n- * @see ParseException\n+ * @version $Revision$, $Date$\n  */\n public class MissingArgumentException extends ParseException\n {\n      * Return the option requiring an argument that wasn't provided\n      * on the command line.\n      *\n+     * @return the related option\n      * @since 1.2\n      */\n     public Option getOption()\n--- a/src/java/org/apache/commons/cli/MissingOptionException.java\n+++ b/src/java/org/apache/commons/cli/MissingOptionException.java\n  * Thrown when a required option has not been provided.\n  *\n  * @author John Keyes ( john at integralsource.com )\n- * @see ParseException\n+ * @version $Revision$, $Date$\n  */\n public class MissingOptionException extends ParseException\n {\n     /**\n      * Return the list of options (as strings) missing in the command line parsed.\n      *\n+     * @return the missing options\n      * @since 1.2\n      */\n     public List getMissingOptions()\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n+import java.util.List;\n \n /** <p>Describes a single command-line option.  It maintains\n  * information regarding the short-name of the option, the long-name,\n  *\n  * @author bob mcwhirter (bob @ werken.com)\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class Option implements Cloneable, Serializable {\n-\n+public class Option implements Cloneable, Serializable\n+{\n     private static final long serialVersionUID = 1L;\n \n-    /** constant that specifies the number of argument values has \n-        not been specified */\n+    /** constant that specifies the number of argument values has not been specified */\n     public static final int UNINITIALIZED = -1;\n \n     /** constant that specifies the number of argument values is infinite */\n     public static final int UNLIMITED_VALUES = -2;\n \n-    /** opt the name of the option */\n+    /** the name of the option */\n     private String opt;\n \n-    /** longOpt is the long representation of the option */\n+    /** the long representation of the option */\n     private String longOpt;\n \n-    /** argName specifies the name of the argument for this option */\n+    /** the name of the argument for this option */\n     private String argName = \"arg\";\n \n     /** description of the option */\n     private String description;\n \n-    /** required specifies whether this option is required to be present */\n+    /** specifies whether this option is required to be present */\n     private boolean required;\n \n     /** specifies whether the argument value of this Option is optional */\n     private boolean optionalArg;\n \n-    /** \n-     * numberOfArgs specifies the number of argument values this option \n-     * can have \n-     */\n+    /** the number of argument values this option can have */\n     private int numberOfArgs = UNINITIALIZED;\n \n     /** the type of this Option */\n     private Object type;\n \n     /** the list of argument values **/\n-    private ArrayList values = new ArrayList();\n+    private List values = new ArrayList();\n \n     /** the character that is the value separator */\n     private char valuesep;\n      * @throws IllegalArgumentException if there are any non valid\n      * Option characters in <code>opt</code>.\n      */\n-    public Option(String opt, String description)\n-           throws IllegalArgumentException\n+    public Option(String opt, String description) throws IllegalArgumentException\n     {\n         this(opt, null, false, description);\n     }\n      * @throws IllegalArgumentException if there are any non valid\n      * Option characters in <code>opt</code>.\n      */\n-    public Option(String opt, boolean hasArg, String description)\n-           throws IllegalArgumentException\n+    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n     {\n         this(opt, null, hasArg, description);\n     }\n      * @throws IllegalArgumentException if there are any non valid\n      * Option characters in <code>opt</code>.\n      */\n-    public Option(String opt, String longOpt, boolean hasArg,\n-                  String description)\n+    public Option(String opt, String longOpt, boolean hasArg, String description)\n            throws IllegalArgumentException\n     {\n         // ensure that the option is valid\n         // if 'opt' is null, then it is a 'long' option\n         if (opt == null)\n         {\n-            return this.longOpt;\n-        }\n-\n-        return this.opt;\n+            return longOpt;\n+        }\n+\n+        return opt;\n     }\n \n     /** \n      */\n     public String getOpt()\n     {\n-        return this.opt;\n+        return opt;\n     }\n \n     /**\n      */\n     public Object getType()\n     {\n-        return this.type;\n+        return type;\n     }\n \n     /**\n      */\n     public String getLongOpt()\n     {\n-        return this.longOpt;\n+        return longOpt;\n     }\n \n     /**\n      */\n     public boolean hasOptionalArg()\n     {\n-        return this.optionalArg;\n+        return optionalArg;\n     }\n \n     /** \n      */\n     public boolean hasLongOpt()\n     {\n-        return (this.longOpt != null);\n+        return longOpt != null;\n     }\n \n     /** \n      */\n     public boolean hasArg()\n     {\n-        return (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n+        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n     }\n \n     /** \n      */\n     public String getDescription()\n     {\n-        return this.description;\n+        return description;\n     }\n \n     /**\n      */\n     public boolean isRequired()\n     {\n-        return this.required;\n+        return required;\n     }\n \n     /**\n      */\n     public String getArgName()\n     {\n-        return this.argName;\n+        return argName;\n     }\n \n     /**\n      */\n     public boolean hasArgName()\n     {\n-        return (this.argName != null && this.argName.length() > 0);\n+        return argName != null && argName.length() > 0;\n     }\n \n     /** \n      */\n     public boolean hasArgs()\n     {\n-        return (this.numberOfArgs > 1)\n-                || (this.numberOfArgs == UNLIMITED_VALUES);\n+        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n     }\n \n     /** \n      */\n     public char getValueSeparator()\n     {\n-        return this.valuesep;\n+        return valuesep;\n     }\n \n     /**\n      */\n     public boolean hasValueSeparator()\n     {\n-        return (this.valuesep > 0);\n+        return valuesep > 0;\n     }\n \n     /** \n      */\n     public int getArgs()\n     {\n-        return this.numberOfArgs;\n+        return numberOfArgs;\n     }\n \n     /**\n     {\n         switch (numberOfArgs)\n         {\n-        case UNINITIALIZED:\n-            throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n-\n-        default:\n-            processValue(value);\n+            case UNINITIALIZED:\n+                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n+\n+            default:\n+                processValue(value);\n         }\n     }\n \n                     break;\n                 }\n \n-\n                 // store\n                 add(value.substring(0, index));\n \n-\n                 // parse\n                 value = value.substring(index + 1);\n-\n \n                 // get new index\n                 index = value.indexOf(sep);\n             }\n         }\n \n-\n         // store the actual value or the last value that has been parsed\n         add(value);\n     }\n             throw new RuntimeException(\"Cannot add value, list full.\");\n         }\n \n-\n         // store value\n-        this.values.add(value);\n+        values.add(value);\n     }\n \n     /**\n      */\n     public String getValue()\n     {\n-        return hasNoValues() ? null : (String) this.values.get(0);\n+        return hasNoValues() ? null : (String) values.get(0);\n     }\n \n     /**\n      * @throws IndexOutOfBoundsException if index is less than 1\n      * or greater than the number of the values for this Option.\n      */\n-    public String getValue(int index)\n-        throws IndexOutOfBoundsException\n-    {\n-        return hasNoValues() ? null : (String) this.values.get(index);\n+    public String getValue(int index) throws IndexOutOfBoundsException\n+    {\n+        return hasNoValues() ? null : (String) values.get(index);\n     }\n \n     /**\n      */\n     public String[] getValues()\n     {\n-        return hasNoValues()\n-               ? null : (String[]) this.values.toArray(new String[this.values.size()]);\n+        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n     }\n \n     /**\n      * @return the values of this Option as a List\n      * or null if there are no values\n      */\n-    public java.util.List getValuesList()\n-    {\n-        return this.values;\n+    public List getValuesList()\n+    {\n+        return values;\n     }\n \n     /** \n     {\n         StringBuffer buf = new StringBuffer().append(\"[ option: \");\n \n-        buf.append(this.opt);\n-\n-        if (this.longOpt != null)\n-        {\n-            buf.append(\" \").append(this.longOpt);\n+        buf.append(opt);\n+\n+        if (longOpt != null)\n+        {\n+            buf.append(\" \").append(longOpt);\n         }\n \n         buf.append(\" \");\n         if (hasArgs())\n         {\n             buf.append(\"[ARG...]\");\n-        } else if (hasArg()) {\n+        }\n+        else if (hasArg())\n+        {\n             buf.append(\" [ARG]\");\n         }\n \n-        buf.append(\" :: \").append(this.description);\n-\n-        if (this.type != null)\n-        {\n-            buf.append(\" :: \").append(this.type);\n+        buf.append(\" :: \").append(description);\n+\n+        if (type != null)\n+        {\n+            buf.append(\" :: \").append(type);\n         }\n \n         buf.append(\" ]\");\n      */\n     private boolean hasNoValues()\n     {\n-        return this.values.size() == 0;\n-    }\n-\n-    public boolean equals( Object o )\n-    {\n-        if ( this == o )\n+        return values.isEmpty();\n+    }\n+\n+    public boolean equals(Object o)\n+    {\n+        if (this == o)\n         {\n             return true;\n         }\n-        if ( o == null || getClass() != o.getClass() )\n+        if (o == null || getClass() != o.getClass())\n         {\n             return false;\n         }\n         Option option = (Option) o;\n \n \n-        if ( opt != null ? !opt.equals( option.opt ) : option.opt != null )\n+        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n         {\n             return false;\n         }\n-        if ( longOpt != null ? !longOpt.equals( option.longOpt ) : option.longOpt != null )\n+        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n         {\n             return false;\n         }\n     public int hashCode()\n     {\n         int result;\n-        result = ( opt != null ? opt.hashCode() : 0 );\n-        result = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\n+        result = (opt != null ? opt.hashCode() : 0);\n+        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n         return result;\n     }\n \n      *\n      * @throws RuntimeException\n      */\n-    public Object clone() {\n-        try {\n+    public Object clone()\n+    {\n+        try\n+        {\n             Option option = (Option) super.clone();\n             option.values = new ArrayList(values);\n             return option;\n-        } catch(CloneNotSupportedException cnse) {\n+        }\n+        catch (CloneNotSupportedException cnse)\n+        {\n             throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n         }\n     }\n \n     /**\n-     * <p>Clear the Option values. After a \n-     * parse is complete, these are left with data in them \n-     * and they need clearing if another parse is done. </p>\n+     * Clear the Option values. After a parse is complete, these are left with\n+     * data in them and they need clearing if another parse is done.\n      *\n      * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n      */\n-    void clearValues() {\n-        this.values.clear();\n+    void clearValues()\n+    {\n+        values.clear();\n     }\n \n     /**\n      * @deprecated\n      * @throws UnsupportedOperationException\n      */\n-    public boolean addValue(String value) {\n-        throw new UnsupportedOperationException(\n-           \"The addValue method is not intended for client use. \" + \n-           \"Subclasses should use the addValueForProcessing method instead. \"\n-           );\n+    public boolean addValue(String value)\n+    {\n+        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n+                + \"Subclasses should use the addValueForProcessing method instead. \");\n     }\n \n }\n--- a/src/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/OptionBuilder.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n /**\n- * <p>OptionBuilder allows the user to create Options using descriptive\n- * methods.</p>\n- * <p>Details on the Builder pattern can be found at \n+ * OptionBuilder allows the user to create Options using descriptive methods.\n+ *\n+ * <p>Details on the Builder pattern can be found at\n  * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n  * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n  *\n  * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n  * @since 1.0\n  */\n-public class OptionBuilder {\n-\n+public final class OptionBuilder\n+{\n     /** long option */\n     private static String longopt;\n \n      */\n     public static OptionBuilder hasArg(boolean hasArg)\n     {\n-        OptionBuilder.numberOfArgs = (hasArg == true) ? 1 : Option.UNINITIALIZED;\n-\n-        return instance;\n-    }\n-\n-    /**\n-     * The next Option created will have the specified argument value \n-     * name.\n+        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n+\n+        return instance;\n+    }\n+\n+    /**\n+     * The next Option created will have the specified argument value name.\n      *\n      * @param name the name for the argument value\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * The next Option created can have <code>num</code> \n-     * argument values.\n+     * The next Option created can have <code>num</code> argument values.\n      *\n      * @param num the number of args that the option can have\n      * @return the OptionBuilder instance\n     }\n \n     /**\n-     * The next Option can have an unlimited number of\n-     * optional arguments.\n+     * The next Option can have an unlimited number of optional arguments.\n      *\n      * @return the OptionBuilder instance\n      */\n     }\n \n     /**\n-     * The next Option can have the specified number of \n-     * optional arguments.\n+     * The next Option can have the specified number of optional arguments.\n      *\n      * @param numArgs - the maximum number of optional arguments\n      * the next Option created can have.\n     }\n \n     /**\n-     * The next Option created will have a value that will be an instance \n+     * The next Option created will have a value that will be an instance\n      * of <code>type</code>.\n      *\n      * @param newType the type of the Options argument value\n     }\n \n     /**\n-     * Create an Option using the current settings and with \n+     * Create an Option using the current settings and with\n      * the specified Option <code>char</code>.\n      *\n      * @param opt the character representation of the Option\n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create(char opt)\n-                         throws IllegalArgumentException\n+    public static Option create(char opt) throws IllegalArgumentException\n     {\n         return create(String.valueOf(opt));\n     }\n      * Create an Option using the current settings\n      *\n      * @return the Option instance\n-     * @throws IllegalArgumentException if <code>longOpt</code> has\n-     * not been set.  \n-     */\n-    public static Option create()\n-                         throws IllegalArgumentException\n+     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n+     */\n+    public static Option create() throws IllegalArgumentException\n     {\n         if (longopt == null)\n         {\n     }\n \n     /**\n-     * Create an Option using the current settings and with \n+     * Create an Option using the current settings and with\n      * the specified Option <code>char</code>.\n      *\n-     * @param opt the <code>java.lang.String</code> representation \n+     * @param opt the <code>java.lang.String</code> representation\n      * of the Option\n      * @return the Option instance\n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create(String opt)\n-                         throws IllegalArgumentException\n+    public static Option create(String opt) throws IllegalArgumentException\n     {\n         // create the option\n         Option option = new Option(opt, description);\n-\n \n         // set the option properties\n         option.setLongOpt(longopt);\n         // return the Option instance\n         return option;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n  * A group of mutually exclusive options.\n  *\n  * @author John Keyes ( john at integralsource.com )\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class OptionGroup implements Serializable {\n-\n+public class OptionGroup implements Serializable\n+{\n     private static final long serialVersionUID = 1L;\n     \n     /** hold the options */\n     }\n \n     /**\n-     * set the selected option of this group to <code>name</code>.\n+     * Set the selected option of this group to <code>name</code>.\n+     *\n      * @param option the option that is selected\n      * @throws AlreadySelectedException if an option from this group has \n      * already been selected.\n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if ((this.selected == null) || this.selected.equals(option.getOpt()))\n+        if (selected == null || selected.equals(option.getOpt()))\n         {\n-            this.selected = option.getOpt();\n+            selected = option.getOpt();\n         }\n         else\n         {\n      */\n     public boolean isRequired()\n     {\n-        return this.required;\n+        return required;\n     }\n \n     /**\n-     * <p>Returns the stringified version of this OptionGroup.</p>\n+     * Returns the stringified version of this OptionGroup.\n+     * \n      * @return the stringified representation of this group\n      */\n     public String toString()\n--- a/src/java/org/apache/commons/cli/OptionValidator.java\n+++ b/src/java/org/apache/commons/cli/OptionValidator.java\n  * Validates an Option string.\n  *\n  * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision$, $Date$\n  * @since 1.1\n  */\n-class OptionValidator {\n-\n+class OptionValidator\n+{\n     /**\n-     * <p>Validates whether <code>opt</code> is a permissable Option\n+     * Validates whether <code>opt</code> is a permissable Option\n      * shortOpt.  The rules that specify if the <code>opt</code>\n-     * is valid are:</p>\n+     * is valid are:\n+     *\n      * <ul>\n      *  <li><code>opt</code> is not NULL</li>\n      *  <li>a single character <code>opt</code> that is either\n     }\n \n     /**\n-     * <p>Returns whether the specified character is a valid Option.</p>\n+     * Returns whether the specified character is a valid Option.\n      *\n      * @param c the option to validate\n-     * @return true if <code>c</code> is a letter, ' ', '?' or '@', \n-     * otherwise false.\n+     * @return true if <code>c</code> is a letter, ' ', '?' or '@',\n+     *         otherwise false.\n      */\n     private static boolean isValidOpt(char c)\n     {\n-        return (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n+        return isValidChar(c) || c == ' ' || c == '?' || c == '@';\n     }\n \n     /**\n-     * <p>Returns whether the specified character is a valid character.</p>\n+     * Returns whether the specified character is a valid character.\n      *\n      * @param c the character to validate\n      * @return true if <code>c</code> is a letter.\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n import java.util.List;\n import java.util.Map;\n \n-/** <p>Main entry-point into the library.</p>\n+/**\n+ * <p>Main entry-point into the library.</p>\n  *\n  * <p>Options represents a collection of {@link Option} objects, which\n  * describe the possible options for a command-line.<p>\n  *\n  * @author bob mcwhirter (bob @ werken.com)\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class Options implements Serializable {\n-\n+public class Options implements Serializable\n+{\n     private static final long serialVersionUID = 1L;\n-    \n+\n     /** a map of the options with the character key */\n     private Map shortOpts = new HashMap();\n \n     /** a map of the option groups */\n     private Map optionGroups = new HashMap();\n \n-    /** Construct a new Options descriptor\n-     */\n-    public Options()\n-    {\n-        // nothing to do\n-    }\n-\n     /**\n      * Add the specified option group.\n      *\n         while (options.hasNext())\n         {\n             Option option = (Option) options.next();\n-\n \n             // an Option cannot be required if it is in an\n             // OptionGroup, either the group is required or\n \n         return this;\n     }\n-    \n+\n     /**\n      * Lists the OptionGroups that are members of this Options instance.\n-     * \n+     *\n      * @return a Collection of OptionGroup instances.\n      */\n     Collection getOptionGroups()\n         return new HashSet(optionGroups.values());\n     }\n \n-    /** \n+    /**\n      * Add an option that only contains a short-name.\n      * It may be specified as requiring an argument.\n      *\n         return this;\n     }\n \n-    /** \n+    /**\n      * Add an option that contains a short-name and a long-name.\n      * It may be specified as requiring an argument.\n      *\n      * @param description Self-documenting description\n      * @return the resulting Options instance\n      */\n-    public Options addOption(String opt, String longOpt, boolean hasArg, \n-                             String description)\n+    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n     {\n         addOption(new Option(opt, longOpt, hasArg, description));\n \n     /**\n      * Adds an option instance\n      *\n-     * @param opt the option that is to be added \n+     * @param opt the option that is to be added\n      * @return the resulting Options instance\n      */\n     public Options addOption(Option opt)\n         }\n \n         // if the option is required add it to the required list\n-        if (opt.isRequired() ) \n-        {\n-            if( requiredOpts.contains(key) ) {\n-                requiredOpts.remove( requiredOpts.indexOf(key) );\n+        if (opt.isRequired())\n+        {\n+            if (requiredOpts.contains(key))\n+            {\n+                requiredOpts.remove(requiredOpts.indexOf(key));\n             }\n             requiredOpts.add(key);\n         }\n         return this;\n     }\n \n-    /** \n+    /**\n      * Retrieve a read-only list of options in this set\n      *\n      * @return read-only Collection of {@link Option} objects in this descriptor\n         return new ArrayList(shortOpts.values());\n     }\n \n-    /** \n+    /**\n      * Returns the required options.\n      *\n      * @return List of required options\n         return requiredOpts;\n     }\n \n-    /** \n+    /**\n      * Retrieve the {@link Option} matching the long or short name specified.\n      * The leading hyphens in the name are ignored (up to 2).\n      *\n         return (Option) longOpts.get(opt);\n     }\n \n-    /** \n-     * Returns whether the named {@link Option} is a member\n-     * of this {@link Options}.\n+    /**\n+     * Returns whether the named {@link Option} is a member of this {@link Options}.\n      *\n      * @param opt short or long name of the {@link Option}\n      * @return true if the named {@link Option} is a member\n         return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n     }\n \n-    /** \n-     * Returns the OptionGroup the <code>opt</code>\n-     * belongs to.\n+    /**\n+     * Returns the OptionGroup the <code>opt</code> belongs to.\n      * @param opt the option whose OptionGroup is being queried.\n      *\n      * @return the OptionGroup if <code>opt</code> is part\n         return (OptionGroup) optionGroups.get(opt.getKey());\n     }\n \n-    /** \n+    /**\n      * Dump state, suitable for debugging.\n      *\n      * @return Stringified form of this object\n--- a/src/java/org/apache/commons/cli/ParseException.java\n+++ b/src/java/org/apache/commons/cli/ParseException.java\n  * Base for Exceptions thrown during parsing of a command-line.\n  *\n  * @author bob mcwhirter (bob @ werken.com)\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n public class ParseException extends Exception\n {\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n import java.util.ArrayList;\n import java.util.Properties;\n \n /**\n- * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n+ * <code>Parser</code> creates {@link CommandLine}s.\n  *\n  * @author John Keyes (john at integralsource.com)\n- * @see Parser\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public abstract class Parser implements CommandLineParser {\n-\n+public abstract class Parser implements CommandLineParser\n+{\n     /** commandline instance */\n     protected CommandLine cmd;\n \n     /** list of required options strings */\n     private List requiredOptions;\n \n-    protected void setOptions(final Options options) {\n+    protected void setOptions(final Options options)\n+    {\n         this.options = options;\n         this.requiredOptions = new ArrayList(options.getRequiredOptions());\n     }\n \n-    protected Options getOptions() {\n+    protected Options getOptions()\n+    {\n         return options;\n     }\n \n-    protected List getRequiredOptions() {\n+    protected List getRequiredOptions()\n+    {\n         return requiredOptions;\n     }\n \n-\n-    /**\n-     * <p>Subclasses must implement this method to reduce\n-     * the <code>arguments</code> that have been passed to the parse \n-     * method.</p>\n+    /**\n+     * Subclasses must implement this method to reduce\n+     * the <code>arguments</code> that have been passed to the parse method.\n      *\n      * @param opts The Options to parse the arguments by.\n      * @param arguments The arguments that have to be flattened.\n-     * @param stopAtNonOption specifies whether to stop \n+     * @param stopAtNonOption specifies whether to stop\n      * flattening when a non option has been encountered\n      * @return a String array of the flattened arguments\n      */\n-    protected abstract String[] flatten(Options opts, String[] arguments, \n-                                        boolean stopAtNonOption);\n-\n-    /**\n-     * <p>Parses the specified <code>arguments</code> \n-     * based on the specifed {@link Options}.</p>\n+    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption);\n+\n+    /**\n+     * Parses the specified <code>arguments</code> based\n+     * on the specifed {@link Options}.\n      *\n      * @param options the <code>Options</code>\n      * @param arguments the <code>arguments</code>\n      * @throws ParseException if an error occurs when parsing the\n      * arguments.\n      */\n-    public CommandLine parse(Options options, String[] arguments)\n-                      throws ParseException\n+    public CommandLine parse(Options options, String[] arguments) throws ParseException\n     {\n         return parse(options, arguments, null, false);\n     }\n \n     /**\n-     * Parse the arguments according to the specified options and\n-     * properties.\n-     *\n-     * @param options the specified Options\n-     * @param arguments the command line arguments\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param options    the specified Options\n+     * @param arguments  the command line arguments\n      * @param properties command line option name-value pairs\n      * @return the list of atomic option and value tokens\n-     *\n      * @throws ParseException if there are any problems encountered\n-     * while parsing the command line tokens.\n+     *                        while parsing the command line tokens.\n      *\n      * @since 1.1\n      */\n-    public CommandLine parse(Options options, String[] arguments, \n-                             Properties properties)\n-        throws ParseException\n+    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n     {\n         return parse(options, arguments, properties, false);\n     }\n \n     /**\n-     * <p>Parses the specified <code>arguments</code> \n-     * based on the specifed {@link Options}.</p>\n-     *\n-     * @param options the <code>Options</code>\n-     * @param arguments the <code>arguments</code>\n-     * @param stopAtNonOption specifies whether to stop \n-     * interpreting the arguments when a non option has \n-     * been encountered and to add them to the CommandLines\n-     * args list.\n-     *\n+     * Parses the specified <code>arguments</code>\n+     * based on the specifed {@link Options}.\n+     *\n+     * @param options         the <code>Options</code>\n+     * @param arguments       the <code>arguments</code>\n+     * @param stopAtNonOption specifies whether to stop interpreting the\n+     *                        arguments when a non option has been encountered\n+     *                        and to add them to the CommandLines args list.\n      * @return the <code>CommandLine</code>\n-     * @throws ParseException if an error occurs when parsing the\n-     * arguments.\n-     */\n-    public CommandLine parse(Options options, String[] arguments, \n-                             boolean stopAtNonOption)\n-        throws ParseException\n+     * @throws ParseException if an error occurs when parsing the arguments.\n+     */\n+    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n     {\n         return parse(options, arguments, null, stopAtNonOption);\n     }\n      *\n      * @since 1.1\n      */\n-    public CommandLine parse(Options options, String[] arguments, \n-                             Properties properties, boolean stopAtNonOption)\n-        throws ParseException\n+    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n+            throws ParseException\n     {\n         // clear out the data in options in case it's been used before (CLI-71)\n-        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n+        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n+        {\n             Option opt = (Option) it.next();\n             opt.clearValues();\n         }\n             arguments = new String[0];\n         }\n \n-        List tokenList = Arrays.asList(flatten(getOptions(), \n-                                               arguments, \n-                                               stopAtNonOption));\n+        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n \n         ListIterator iterator = tokenList.listIterator();\n \n     }\n \n     /**\n-     * <p>Sets the values of Options using the values in \n-     * <code>properties</code>.</p>\n+     * Sets the values of Options using the values in <code>properties</code>.\n      *\n      * @param properties The value properties to be processed.\n      */\n \n                 if (opt.hasArg())\n                 {\n-                    if ((opt.getValues() == null)\n-                        || (opt.getValues().length == 0))\n+                    if (opt.getValues() == null || opt.getValues().length == 0)\n                     {\n                         try\n                         {\n                         }\n                     }\n                 }\n-                else if (!(\"yes\".equalsIgnoreCase(value) \n-                           || \"true\".equalsIgnoreCase(value)\n-                           || \"1\".equalsIgnoreCase(value)))\n+                else if (!(\"yes\".equalsIgnoreCase(value)\n+                        || \"true\".equalsIgnoreCase(value)\n+                        || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n \n     /**\n      * <p>Process the argument values for the specified Option\n-     * <code>opt</code> using the values retrieved from the \n+     * <code>opt</code> using the values retrieved from the\n      * specified iterator <code>iter</code>.\n      *\n      * @param opt The current Option\n      * @throws ParseException if an argument value is required\n      * and it is has not been found.\n      */\n-    public void processArgs(Option opt, ListIterator iter)\n-        throws ParseException\n+    public void processArgs(Option opt, ListIterator iter) throws ParseException\n     {\n         // loop until an option is found\n         while (iter.hasNext())\n             // found a value\n             try\n             {\n-                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n+                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n             }\n             catch (RuntimeException exp)\n             {\n             }\n         }\n \n-        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n+        if (opt.getValues() == null && !opt.hasOptionalArg())\n         {\n             throw new MissingArgumentException(opt);\n         }\n     }\n \n     /**\n-     * <p>Process the Option specified by <code>arg</code>\n-     * using the values retrieved from the specfied iterator\n-     * <code>iter</code>.\n+     * Process the Option specified by <code>arg</code> using the values\n+     * retrieved from the specfied iterator <code>iter</code>.\n      *\n      * @param arg The String value representing an Option\n-     * @param iter The iterator over the flattened command \n-     * line arguments.\n-     *\n-     * @throws ParseException if <code>arg</code> does not\n-     * represent an Option\n-     */\n-    protected void processOption(String arg, ListIterator iter)\n-        throws ParseException\n+     * @param iter The iterator over the flattened command line arguments.\n+     *\n+     * @throws ParseException if <code>arg</code> does not represent an Option\n+     */\n+    protected void processOption(String arg, ListIterator iter) throws ParseException\n     {\n         boolean hasOption = getOptions().hasOption(arg);\n \n         {\n             throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n         }\n-        \n+\n         // get the option represented by arg\n         Option opt = (Option) getOptions().getOption(arg).clone();\n \n             processArgs(opt, iter);\n         }\n \n-\n         // set the option on the command line\n         cmd.addOption(opt);\n     }\n--- a/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n import java.net.URL;\n import java.util.Date;\n \n-/** \n+/**\n  * <p>\n  * Allows Options to be created from a single String.\n  * The pattern contains various single character flags and via\n  * <code>Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");</code>\n  *\n  * <p>\n- * TODO These need to break out to OptionType and also \n+ * TODO These need to break out to OptionType and also\n  * to be pluggable.\n  * </p>\n  *\n  * @author Henri Yandell (bayard @ generationjava.com)\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class PatternOptionBuilder {\n-\n+public class PatternOptionBuilder\n+{\n     /** String class */\n     public static final Class STRING_VALUE = String.class;\n \n     /** Class class */\n     public static final Class CLASS_VALUE = Class.class;\n \n-    /// can we do this one?? \n+    /// can we do this one??\n     // is meant to check that the file exists, else it errors.\n     // ie) it's for reading not writing.\n \n     /**\n      * Returns whether <code>ch</code> is a value code, i.e.\n      * whether it represents a class in a pattern.\n-     * \n+     *\n      * @param ch the specified character\n      * @return true if <code>ch</code> is a value code, otherwise false.\n      */\n     }\n \n     /**\n-     * Returns the {@link Options} instance represented by \n-     * <code>pattern</code>.\n+     * Returns the {@link Options} instance represented by <code>pattern</code>.\n      *\n      * @param pattern the pattern string\n      * @return The {@link Options} instance\n         {\n             char ch = pattern.charAt(i);\n \n-            // a value code comes after an option and specifies \n+            // a value code comes after an option and specifies\n             // details about it\n             if (!isValueCode(ch))\n             {\n                     OptionBuilder.hasArg(type != null);\n                     OptionBuilder.isRequired(required);\n                     OptionBuilder.withType(type);\n-                    \n+\n                     // we have a previous one to deal with\n                     options.addOption(OptionBuilder.create(opt));\n                     required = false;\n             OptionBuilder.hasArg(type != null);\n             OptionBuilder.isRequired(required);\n             OptionBuilder.withType(type);\n-            \n+\n             // we have a final one to deal with\n             options.addOption(OptionBuilder.create(opt));\n         }\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n import java.util.List;\n \n /**\n- * The class PosixParser provides an implementation of the \n+ * The class PosixParser provides an implementation of the\n  * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n  *\n  * @author John Keyes (john at integralsource.com)\n- * @see Parser\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n-public class PosixParser extends Parser {\n-\n+public class PosixParser extends Parser\n+{\n     /** holder for flattened tokens */\n     private List tokens = new ArrayList();\n \n      *  is a valid {@link Option} id.  If it is a valid id, then add the\n      *  entry to the list of processed tokens and set the current {@link Option}\n      *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n-     *  is true, then the remaining entries are copied to the list of \n+     *  is true, then the remaining entries are copied to the list of\n      *  processed tokens.  Otherwise, the current entry is ignored.</li>\n      *  <li>if the current <code>arguments</code> entry is more than two\n      *  characters in length and the first character is \"<b>-</b>\" then\n      *  we need to burst the entry to determine its constituents.  For more\n-     *  information on the bursting algorithm see \n+     *  information on the bursting algorithm see\n      *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n-     *  <li>if the current <code>arguments</code> entry is not handled \n+     *  <li>if the current <code>arguments</code> entry is not handled\n      *  by any of the previous rules, then the entry is added to the list\n      *  of processed tokens.</li>\n      * </ol>\n                 else\n                 {\n                     tokens.add(opt);\n-                    if (pos != -1) {\n+                    if (pos != -1)\n+                    {\n                         tokens.add(token.substring(pos + 1));\n                     }\n                 }\n     }\n \n     /**\n-     * <p>Breaks <code>token</code> into its constituent parts\n+     * Breaks <code>token</code> into its constituent parts\n      * using the following algorithm.\n+     *\n      * <ul>\n      *  <li>ignore the first character (\"<b>-</b>\")</li>\n      *  <li>foreach remaining character check if an {@link Option}\n      *  exists with that id.</li>\n      *  <li>if an {@link Option} does exist then add that character\n      *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n-     *  <li>if the {@link Option} can have an argument value and there \n-     *  are remaining characters in the token then add the remaining \n+     *  <li>if the {@link Option} can have an argument value and there\n+     *  are remaining characters in the token then add the remaining\n      *  characters as a token to the list of processed tokens.</li>\n-     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n+     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n      *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n-     *  \"<b>--</b>\" followed by the remaining characters and also \n+     *  \"<b>--</b>\" followed by the remaining characters and also\n      *  the remaining tokens directly to the processed tokens list.</li>\n      *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n      *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n      *  character prepended with \"<b>-</b>\".</li>\n      * </ul>\n-     * </p>\n      *\n      * @param token The current token to be <b>burst</b>\n      * @param stopAtNonOption Specifies whether to stop processing\n     protected void burstToken(String token, boolean stopAtNonOption)\n     {\n         Option currentOption;\n-        \n+\n         for (int i = 1; i < token.length(); i++)\n         {\n             String ch = String.valueOf(token.charAt(i));\n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n-/*\n+/**\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n  * contributor license agreements.  See the NOTICE file distributed with\n  * this work for additional information regarding copyright ownership.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n import java.io.File;\n import java.util.Date;\n \n /**\n-  * This is a temporary implementation. TypeHandler will handle the \n-  * pluggableness of OptionTypes and it will direct all of these types \n-  * of conversion functionalities to ConvertUtils component in Commons \n-  * alreayd. BeanUtils I think.\n+  * This is a temporary implementation. TypeHandler will handle the\n+  * pluggableness of OptionTypes and it will direct all of these types\n+  * of conversion functionalities to ConvertUtils component in Commons\n+  * already. BeanUtils I think.\n   *\n   * @author Henri Yandell (bayard @ generationjava.com)\n-  * @version $Revision$\n+  * @version $Revision$, $Date$\n   */\n-public class TypeHandler {\n-\n+public class TypeHandler\n+{\n     /**\n      * Returns the <code>Object</code> of type <code>obj</code>\n      * with the value of <code>str</code>.\n       * Create an Object from the classname and empty constructor.\n       *\n       * @param str the argument value\n-      * @return the initialised object, or null if it couldn't create \n+      * @return the initialised object, or null if it couldn't create\n       * the Object.\n       */\n     public static Object createObject(String str)\n     }\n \n     /**\n-     * Create a number from a String. If a . is present, it creates a \n+     * Create a number from a String. If a . is present, it creates a\n      * Double, otherwise a Long.\n      *\n      * @param str the value\n     {\n         try\n         {\n-            if( str.indexOf('.') != -1 )\n+            if (str.indexOf('.') != -1)\n             {\n                 return Double.valueOf(str);\n             }\n--- a/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+++ b/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n  * option was seen.\n  *\n  * @author bob mcwhiter (bob @ werken.com)\n- * @version $Revision$\n+ * @version $Revision$, $Date$\n  */\n public class UnrecognizedOptionException extends ParseException\n {\n     /**\n      * Returns the unrecognized option.\n      *\n+     * @return the related option\n      * @since 1.2\n      */\n     public String getOption()\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.cli;\n \n /**\n  * Contains useful helper methods for classes within this package.\n  *\n  * @author John Keyes (john at integralsource.com)\n+ * @version $Revision$, $Date$\n  */\n-class Util {\n-\n+class Util\n+{\n     /**\n-     * <p>Remove the hyphens from the begining of <code>str</code> and\n-     * return the new String.</p>\n+     * Remove the hyphens from the begining of <code>str</code> and\n+     * return the new String.\n      *\n      * @param str The string from which the hyphens should be removed.\n      *\n      */\n     static String stripLeadingHyphens(String str)\n     {\n-        if (str == null) {\n+        if (str == null)\n+        {\n             return null;\n         }\n         if (str.startsWith(\"--\"))\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\")) {\n+        if (str.startsWith(\"\\\"\"))\n+        {\n             str = str.substring(1, str.length());\n         }\n-        if (str.endsWith(\"\\\"\")) {\n-            str = str.substring(0, str.length()-1);\n+        if (str.endsWith(\"\\\"\"))\n+        {\n+            str = str.substring(0, str.length() - 1);\n         }\n         return str;\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/cli/ArgumentIsOptionTest.java\n+++ b/src/test/org/apache/commons/cli/ArgumentIsOptionTest.java\n         CommandLine cl = parser.parse(options, args);\n         assertTrue(\"Confirm -p is set\", cl.hasOption(\"p\"));\n         assertTrue(\"Confirm -attr is set\", cl.hasOption(\"attr\"));\n-        assertTrue(\"Confirm arg of -attr\",\n-                cl.getOptionValue(\"attr\").equals(\"p\"));\n+        assertTrue(\"Confirm arg of -attr\", cl.getOptionValue(\"attr\").equals(\"p\"));\n         assertTrue(\"Confirm all arguments recognized\", cl.getArgs().length == 0);\n     }\n \n--- a/src/test/org/apache/commons/cli/UtilTest.java\n+++ b/src/test/org/apache/commons/cli/UtilTest.java\n /**\n  * @author brianegge\n  */\n-public class UtilTest extends TestCase {\n-\n-    public void testStripLeadingHyphens() {\n+public class UtilTest extends TestCase\n+{\n+    public void testStripLeadingHyphens()\n+    {\n         assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n         assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n         assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n         assertNull(Util.stripLeadingHyphens(null));\n     }\n \n-    public void testStripLeadingAndTrailingQuotes() {\n+    public void testStripLeadingAndTrailingQuotes()\n+    {\n         assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n     }\n }", "timestamp": 1217319228, "metainfo": ""}