{"sha": "b0e1b80b6d4a10a9c9f46539bc4c7a3cce55886e", "log": "Applying Brian Egge's fix and unit test from CLI-13.   ", "commit": "\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n package org.apache.commons.cli;\n \n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.Map;\n+import java.util.Set;\n+import java.util.HashSet;\n \n /** \n  * <p>Represents list of arguments parsed against\n     private List args = new LinkedList();\n \n     /** the processed options */\n-    private Map options = new HashMap();\n-\n-    /** the option name map */\n-    private Map names = new HashMap();\n+    private Set options = new HashSet();\n \n     /** Map of unique options for ease to get complete list of options */\n-    private Map hashcodeMap = new HashMap();\n-\n-    /** the processed options */\n-    private Option[] optionsArray;\n+//    private Set allOptions = new HashSet();\n \n     /**\n      * Creates a command line.\n      */\n     public boolean hasOption(String opt)\n     {\n-        return options.containsKey(opt);\n+        return options.contains( resolveOption(opt));\n     }\n \n     /** \n     {\n         String res = getOptionValue(opt);\n \n-        if (!options.containsKey(opt))\n+        Option option = resolveOption(opt);\n+        if (option == null)\n         {\n             return null;\n         }\n \n-        Object type = ((Option) options.get(opt)).getType();\n+        Object type = option.getType();\n \n         return (res == null)        ? null : TypeHandler.createValue(res, type);\n     }\n      */\n     public String[] getOptionValues(String opt)\n     {\n+        Option key = resolveOption( opt );\n+\n+        if (options.contains(key))\n+        {\n+            return key.getValues();\n+        }\n+\n+        return null;\n+        }\n+\n+    /**\n+     * <p>Retrieves the option object given the long or short option as a String</p>\n+     * @param opt short or long name of the option\n+     * @return Canonicalized option\n+     */\n+    private Option resolveOption( String opt )\n+    {\n         opt = Util.stripLeadingHyphens(opt);\n-\n-        String key = opt;\n-\n-        if (names.containsKey(opt))\n+        for ( Iterator it = options.iterator(); it.hasNext(); )\n         {\n-            key = (String) names.get(opt);\n-        }\n-\n-        if (options.containsKey(key))\n-        {\n-            return ((Option) options.get(key)).getValues();\n-        }\n-\n+            Option option = (Option) it.next();\n+            if (opt.equals(option.getOpt()))\n+            {\n+                return option;\n+            }\n+            if (opt.equals( option.getLongOpt()))\n+            {\n+                return option;\n+        }\n+\n+        }\n         return null;\n     }\n \n      */\n     void addOption(Option opt)\n     {\n-        hashcodeMap.put(new Integer(opt.hashCode()), opt);\n-\n-        String key = opt.getKey();\n-\n-        if (key == null)\n-        {\n-            key = opt.getLongOpt();\n-        }\n-        else\n-        {\n-            names.put(opt.getLongOpt(), key);\n-        }\n-\n-        options.put(key, opt);\n+        options.add(opt);\n     }\n \n     /**\n      */\n     public Iterator iterator()\n     {\n-        return hashcodeMap.values().iterator();\n+        return options.iterator();\n     }\n \n     /**\n      */\n     public Option[] getOptions()\n     {\n-        Collection processed = options.values();\n-\n+        Collection processed = options;\n \n         // reinitialise array\n-        optionsArray = new Option[processed.size()];\n+        Option[] optionsArray = new Option[processed.size()];\n \n         // return the array\n         return (Option[]) processed.toArray(optionsArray);\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n     {\n         return this.values.size() == 0;\n     }\n+\n+    public boolean equals( Object o )\n+    {\n+        if ( this == o )\n+        {\n+            return true;\n+        }\n+        if ( o == null || getClass() != o.getClass() )\n+        {\n+            return false;\n+        }\n+\n+        Option option = (Option) o;\n+\n+\n+        if ( opt != null ? !opt.equals( option.opt ) : option.opt != null )\n+        {\n+            return false;\n+        }\n+        if ( longOpt != null ? !longOpt.equals( option.longOpt ) : option.longOpt != null )\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public int hashCode()\n+    {\n+        int result;\n+        result = ( opt != null ? opt.hashCode() : 0 );\n+        result = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\n+        return result;\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/bug/BugCLI13Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.bug;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.cli.PosixParser;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class BugCLI13Test\n+    extends TestCase\n+{\n+    public void testCLI13()\n+        throws ParseException\n+    {\n+        final String debugOpt = \"debug\";\n+        Option debug = OptionBuilder\n+            .withArgName( debugOpt )\n+            .withDescription( \"turn on debugging\" )\n+            .withLongOpt( debugOpt )\n+            .hasArg()\n+            .create( 'd' );\n+        Options options = new Options();\n+        options.addOption( debug );\n+        CommandLine commandLine = new PosixParser().parse( options, new String[]{\"-d\", \"true\"} );\n+\n+        assertEquals(\"true\", commandLine.getOptionValue( debugOpt ));\n+        assertEquals(\"true\", commandLine.getOptionValue( 'd' ));\n+        assertTrue(commandLine.hasOption( 'd'));\n+        assertTrue(commandLine.hasOption( debugOpt));\n+    }\n+}", "timestamp": 1179190058, "metainfo": ""}