{"sha": "1b8b422a5fba1a37d789fe1a6b9173e7cc44fbb0", "log": "ArrayNode: make _children final  Simplifies quite a lot of code in the process.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n public class ArrayNode\n     extends ContainerNode<ArrayNode>\n {\n-    // before 2.1, was explicitly `ArrayList`\n-    protected List<JsonNode> _children;\n+    protected final List<JsonNode> _children = new ArrayList<JsonNode>();\n \n     public ArrayNode(JsonNodeFactory nc) { super(nc); }\n \n     protected ArrayNode(JsonNodeFactory nc, List<JsonNode> children) {\n         super(nc);\n-        _children = children;\n+        _children.addAll(children);\n     }\n     \n     // note: co-variant to allow caller-side type safety\n      */\n     protected ArrayNode _defaultDeepCopy()\n     {\n-        if (_children == null) {\n-            return new ArrayNode(_nodeFactory);\n-        }\n         final int len = _children.size();\n-        List<JsonNode> newKids = _createList(Math.max(4, len));\n-        for (int i = 0; i < len; ++i) {\n-            newKids.add(_children.get(i).deepCopy());\n-        }\n+        final List<JsonNode> newKids = new ArrayList<JsonNode>(len);\n+\n+        for (JsonNode child : _children)\n+            newKids.add(child.deepCopy());\n+\n         return new ArrayNode(_nodeFactory, newKids);\n     }\n     \n     @Override\n     public int size()\n     {\n-        return (_children == null) ? 0 : _children.size();\n+        return _children.size();\n     }\n \n     @Override\n     public Iterator<JsonNode> elements()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.iterator();\n     }\n \n     @Override\n     public JsonNode get(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.get(index);\n         }\n         return null;\n     @Override\n     public JsonNode path(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.get(index);\n         }\n         return MissingNode.getInstance();\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartArray();\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n-                 *   extend BaseJsonNode? Or if not, at least implement\n-                 *   JsonSerializable? Let's start with former, change if\n-                 *   we must.\n-                 */\n-                ((BaseJsonNode)n).serialize(jg, provider);\n-            }\n+        for (JsonNode n : _children) {\n+            /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+             *   extend BaseJsonNode? Or if not, at least implement\n+             *   JsonSerializable? Let's start with former, change if\n+             *   we must.\n+             */\n+            ((BaseJsonNode)n).serialize(jg, provider);\n         }\n         jg.writeEndArray();\n     }\n         throws IOException, JsonProcessingException\n     {\n         typeSer.writeTypePrefixForArray(this, jg);\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                ((BaseJsonNode)n).serialize(jg, provider);\n+        for (JsonNode n : _children) {\n+            ((BaseJsonNode)n).serialize(jg, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        for (JsonNode node : _children) {\n+            JsonNode value = node.findValue(fieldName);\n+            if (value != null) {\n+                return value;\n             }\n         }\n-        typeSer.writeTypeSuffixForArray(this, jg);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, finding value nodes\n-    /**********************************************************\n-     */\n-    \n-    @Override\n-    public JsonNode findValue(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                JsonNode value = node.findValue(fieldName);\n-                if (value != null) {\n-                    return value;\n-                }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findValues(fieldName, foundSoFar);\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        for (JsonNode node : _children) {\n+            JsonNode parent = node.findParent(fieldName);\n+            if (parent != null) {\n+                return (ObjectNode) parent;\n             }\n         }\n         return null;\n     }\n-    \n-    @Override\n-    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findValues(fieldName, foundSoFar);\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-\n-    @Override\n-    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-    \n-    @Override\n-    public ObjectNode findParent(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                JsonNode parent = node.findParent(fieldName);\n-                if (parent != null) {\n-                    return (ObjectNode) parent;\n-                }\n-            }\n-        }\n-        return null;        \n-    }\n \n     @Override\n     public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n     {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findParents(fieldName, foundSoFar);\n-            }\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findParents(fieldName, foundSoFar);\n         }\n         return foundSoFar;\n     }\n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _set(index, value);\n+        if (index < 0 || index >= _children.size()) {\n+            throw new IndexOutOfBoundsException(\"Illegal index \"+ index +\", array size \"+size());\n+        }\n+        return _children.set(index, value);\n     }\n \n     /**\n      */\n     public ArrayNode addAll(ArrayNode other)\n     {\n-        int len = other.size();\n-        if (len > 0) {\n-            if (_children == null) {\n-                _children = _createList(len+2);\n-            }\n-            other.addContentsTo(_children);\n-        }\n+        _children.addAll(other._children);\n         return this;\n     }\n \n      */\n     public ArrayNode addAll(Collection<JsonNode> nodes)\n     {\n-        int len = nodes.size();\n-        if (len > 0) {\n-            if (_children == null) {\n-                _children = _createList(nodes.size());\n-            }\n-            _children.addAll(nodes);\n-        }\n+        _children.addAll(nodes);\n         return this;\n     }\n     \n      */\n     public JsonNode remove(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.remove(index);\n         }\n         return null;\n     @Override\n     public ArrayNode removeAll()\n     {\n-        _children = null;\n+        _children.clear();\n         return this;\n     }\n     \n \n     protected void addContentsTo(List<JsonNode> dst)\n     {\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                dst.add(n);\n-            }\n-        }\n+        dst.addAll(_children);\n     }\n \n     /*\n     {\n         if (o == this) return true;\n         if (o == null) return false;\n-        if (o.getClass() != getClass() && !(o instanceof ArrayNode)) {\n+        if (!(o instanceof ArrayNode)) {\n             return false;\n         }\n-        /* This is bit convoluted, but the goal is to make it possible to\n-         * fully override equality comparison, even though it is\n-         * asymmetric (i.e. can be called on either side, but we\n-         * want behavior to match).\n-         */\n-        return _equals((ArrayNode) o);\n-    }\n-\n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _equals(ArrayNode other)\n-    {\n-        return _stdEquals(other)\n-                &&_customEquals(other)\n-                && other._customEquals(this)\n-                ;\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _customEquals(ArrayNode other) {\n-        return true;\n-    }\n-\n-    /**\n-     * Standard equality check, which may also be overridden by\n-     * sub-classes if necessary (but usually isn't).\n-     *\n-     * @since 2.1\n-     */\n-    protected final boolean _stdEquals(ArrayNode other)\n-    {\n-        if (_children == null || _children.size() == 0) {\n-            return other.size() == 0;\n-        }\n-        return other._sameChildren(_children);\n+        return _children.equals(((ArrayNode) o)._children);\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        int hash;\n-        if (_children == null) {\n-            hash = 1;\n-        } else {\n-            hash = _children.size();\n-            for (JsonNode n : _children) {\n-                if (n != null) {\n-                    hash ^= n.hashCode();\n-                }\n-            }\n-        }\n-        return hash;\n+        return _children.hashCode();\n     }\n \n \n     {\n         StringBuilder sb = new StringBuilder(16 + (size() << 4));\n         sb.append('[');\n-        if (_children != null) {\n-            for (int i = 0, len = _children.size(); i < len; ++i) {\n-                if (i > 0) {\n-                    sb.append(',');\n-                }\n-                sb.append(_children.get(i).toString());\n+        for (int i = 0, len = _children.size(); i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n             }\n+            sb.append(_children.get(i).toString());\n         }\n         sb.append(']');\n         return sb.toString();\n     /**********************************************************\n      */\n \n-    public JsonNode _set(int index, JsonNode value)\n-    {\n-        if (_children == null || index < 0 || index >= _children.size()) {\n-            throw new IndexOutOfBoundsException(\"Illegal index \"+index+\", array size \"+size());\n-        }\n-        return _children.set(index, value);\n-    }\n-\n     private ArrayNode _add(JsonNode node)\n     {\n-        if (_children == null) {\n-            _children = _createList();\n-        }\n         _children.add(node);\n         return this;\n     }\n \n     private ArrayNode _insert(int index, JsonNode node)\n     {\n-        if (_children == null) {\n-            _children = _createList();\n-            _children.add(node);\n-            return this;\n-        }\n         if (index < 0) {\n             _children.add(0, node);\n         } else if (index >= _children.size()) {\n         }\n         return this;\n     }\n-\n-    /**\n-     * Note: this method gets called iff <code>otherChildren</code>\n-     * is non-empty\n-     */\n-    private boolean _sameChildren(List<JsonNode> otherChildren)\n-    {\n-        int len = otherChildren.size();\n-        if (this.size() != len) { // important: call size() to handle case of null list...\n-            return false;\n-        }\n-        for (int i = 0; i < len; ++i) {\n-            if (!_children.get(i).equals(otherChildren.get(i))) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n }", "timestamp": 1358991294, "metainfo": ""}