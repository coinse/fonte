{"sha": "7d4201c6768db3feb83c5d441195d9e4a6f25a08", "log": "Solve the cyclic/untyped-deser problem for 2.4 as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n         _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Initialization\n      * to: it can not be done earlier since delegated deserializers almost\n      * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         JavaType obType = ctxt.constructType(Object.class);\n         JavaType stringType = ctxt.constructType(String.class);\n         TypeFactory tf = ctxt.getTypeFactory();\n+\n+        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n+         *    should always be called separately, from within \"createContextual()\".\n+         *    But this is a very singular deserializer since it operates on `Object`\n+         *    (and often for `?` type parameter), and as a result, easily and commonly\n+         *    results in cycles, being value deserializer for various Maps and Collections.\n+         *    Because of this, we must somehow break the cycles. This is done here by\n+         *    forcing pseudo-contextualization with null property.\n+         */\n+\n+        // So: first find possible custom instances\n         _mapDeserializer = _findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType));\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n         _numberDeserializer = _findCustomDeser(ctxt, tf.constructType(Number.class));\n+\n+        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n+        // their own\n+        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);\n+        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);\n+        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);\n+        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        // NOTE: since we don't yet have the referring property, this should be fine:\n         JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n-    \n+\n+    /**\n+     * We only use contextualization for optimizing the case where no customization\n+     * occurred; if so, can slip in a more streamlined version.\n+     */\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n         }\n-        JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n-        if (mapDeserializer instanceof ContextualDeserializer) {\n-            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> listDeserializer = _listDeserializer;\n-        if (listDeserializer instanceof ContextualDeserializer) {\n-            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> stringDeserializer = _stringDeserializer;\n-        if (stringDeserializer instanceof ContextualDeserializer) {\n-            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> numberDeserializer = _numberDeserializer;\n-        if (numberDeserializer instanceof ContextualDeserializer) {\n-            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);\n-        }\n-\n-        // And if anything changed, we'll need to change too!\n-        if ((mapDeserializer != _mapDeserializer)\n-                || (listDeserializer != _listDeserializer)\n-                || (stringDeserializer != _stringDeserializer)\n-                || (numberDeserializer != _numberDeserializer)\n-                ) {\n-            return _withResolved(mapDeserializer, listDeserializer,\n-                    stringDeserializer, numberDeserializer);\n-        }\n         return this;\n     }\n \n     /* Deserializer API\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {", "timestamp": 1417026700, "metainfo": ""}