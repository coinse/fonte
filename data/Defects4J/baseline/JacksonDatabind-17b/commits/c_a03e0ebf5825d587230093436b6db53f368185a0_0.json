{"sha": "a03e0ebf5825d587230093436b6db53f368185a0", "log": "Implemented [JACKSON-732] for 2.0", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n      * <code>Class<JsonSerializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated am) {\n+    public Object findKeySerializer(Annotated am) {\n         return null;\n     }\n \n      * <code>Class<JsonSerializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated am) {\n+    public Object findContentSerializer(Annotated am) {\n         return null;\n     }\n     \n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Class<? extends KeyDeserializer> findKeyDeserializer(Annotated am);\n+    public abstract Object findKeyDeserializer(Annotated am);\n \n     /**\n      * Method for getting a deserializer definition for content (values) of\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated am);\n+    public abstract Object findContentDeserializer(Annotated am);\n \n     /**\n      * Method for accessing annotated type definition that a\n         }\n         \n         @Override\n-        public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a)\n-        {\n-            Class<? extends JsonSerializer<?>> result = _primary.findKeySerializer(a);\n-            if (result == null || result == JsonSerializer.None.class) {\n+        public Object findKeySerializer(Annotated a)\n+        {\n+            Object result = _primary.findKeySerializer(a);\n+            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n                 result = _secondary.findKeySerializer(a);\n             }\n             return result;\n         }\n \n         @Override\n-        public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a)\n-        {\n-            Class<? extends JsonSerializer<?>> result = _primary.findContentSerializer(a);\n-            if (result == null || result == JsonSerializer.None.class) {\n+        public Object findContentSerializer(Annotated a)\n+        {\n+            Object result = _primary.findContentSerializer(a);\n+            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n                 result = _secondary.findContentSerializer(a);\n             }\n             return result;\n         }\n         \n         @Override\n-        public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated am)\n-        {\n-            Class<? extends KeyDeserializer> result = _primary.findKeyDeserializer(am);\n-            if (result == null || result == KeyDeserializer.None.class) {\n+        public Object findKeyDeserializer(Annotated am)\n+        {\n+            Object result = _primary.findKeyDeserializer(am);\n+            if (result == null || result == KeyDeserializer.None.class || result == NoClass.class) {\n                 result = _secondary.findKeyDeserializer(am);\n             }\n             return result;\n         }\n \n         @Override\n-        public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated am)\n-        {\n-            Class<? extends JsonDeserializer<?>> result = _primary.findContentDeserializer(am);\n-            if (result == null || result == JsonDeserializer.None.class) {\n+        public Object findContentDeserializer(Annotated am)\n+        {\n+            Object result = _primary.findContentDeserializer(am);\n+            if (result == null || result == JsonDeserializer.None.class || result == NoClass.class) {\n                 result = _secondary.findContentDeserializer(am);\n             }\n             return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n \n     @SuppressWarnings(\"unchecked\")\n     public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n-            Class<? extends JsonDeserializer<?>> deserClass)\n+            Class<?> deserClass)\n     {\n         HandlerInstantiator hi = getHandlerInstantiator();\n         if (hi != null) {\n-            JsonDeserializer<?> deser = hi.deserializerInstance(this, annotated, deserClass);\n+            JsonDeserializer<?> deser = hi.deserializerInstance(this, annotated,\n+                    (Class<JsonDeserializer<?>>)deserClass);\n             if (deser != null) {\n                 return (JsonDeserializer<Object>) deser;\n             }\n     }\n \n     public KeyDeserializer keyDeserializerInstance(Annotated annotated,\n-            Class<? extends KeyDeserializer> keyDeserClass)\n+            Class<?> keyDeserClass)\n     {\n         HandlerInstantiator hi = getHandlerInstantiator();\n         if (hi != null) {\n-            KeyDeserializer keyDeser = hi.keyDeserializerInstance(this, annotated, keyDeserClass);\n+            @SuppressWarnings(\"unchecked\")\n+            KeyDeserializer keyDeser = hi.keyDeserializerInstance(this, annotated,\n+                    (Class<KeyDeserializer>)keyDeserClass);\n             if (keyDeser != null) {\n                 return (KeyDeserializer) keyDeser;\n             }\n     }\n \n     public ValueInstantiator valueInstantiatorInstance(Annotated annotated,\n-            Class<? extends ValueInstantiator> instClass)\n+            Class<?> instClass)\n     {\n         HandlerInstantiator hi = getHandlerInstantiator();\n         if (hi != null) {\n-            ValueInstantiator inst = hi.valueInstantiatorInstance(this, annotated, instClass);\n+            @SuppressWarnings(\"unchecked\")\n+            ValueInstantiator inst = hi.valueInstantiatorInstance(this, annotated,\n+                    (Class<ValueInstantiator>)instClass);\n             if (inst != null) {\n                 return (ValueInstantiator) inst;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n \n import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n              *   is not good: for now, let's just avoid errors)\n              */\n             if (keyType != null && keyType.getValueHandler() == null) {\n-                Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(a);\n-                if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n-                    KeyDeserializer kd = config.keyDeserializerInstance(a, kdClass);\n-                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                    keyType = type.getKeyType(); // just in case it's used below\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = null;\n+                    if (kdDef instanceof KeyDeserializer) {\n+                        kd = (KeyDeserializer) kdDef;\n+                    } else {\n+                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n+                        if (kdClass != null) {\n+                            kd = config.keyDeserializerInstance(a, kdClass);\n+                        }\n+                    }\n+                    if (kd != null) {\n+                        type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n                 }\n             }            \n             \n             // ... as well as deserializer for contents:\n             JavaType contentType = type.getContentType();\n             if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n-                Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(a);\n-                if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n-                    JsonDeserializer<Object> cd = config.deserializerInstance(a, cdClass);\n-                    type = (T) type.withContentValueHandler(cd);\n+                Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = config.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = (T) type.withContentValueHandler(cd);\n+                    }\n                 }\n             }\n         }\n      * have type variable binding information (when deserializing\n      * using generic type passed as type reference), which is\n      * needed in some cases.\n-     *<p>\n-     * Starting with version 1.3, this method will also resolve instances\n-     * of key and content deserializers if defined by annotations.\n      */\n     protected JavaType resolveType(DeserializationConfig config,\n             BasicBeanDescription beanDesc, JavaType type, AnnotatedMember member,\n             AnnotationIntrospector intr = config.getAnnotationIntrospector();\n             JavaType keyType = type.getKeyType();\n             if (keyType != null) {\n-                Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(member);\n-                if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n-                    KeyDeserializer kd = config.keyDeserializerInstance(member, kdClass);\n-                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n-                    keyType = type.getKeyType(); // just in case it's used below\n+                Object kdDef = intr.findKeyDeserializer(member);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = null;\n+                    if (kdDef instanceof KeyDeserializer) {\n+                        kd = (KeyDeserializer) kdDef;\n+                    } else {\n+                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n+                        if (kdClass != null) {\n+                            kd = config.keyDeserializerInstance(member, kdClass);\n+                        }\n+                    }\n+                    if (kd != null) {\n+                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n                 }\n             }\n             // and all container types have content types...\n-            Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(member);\n-            if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n-                JsonDeserializer<Object> cd = config.deserializerInstance(member, cdClass);\n-                type = type.withContentValueHandler(cd);\n+            Object cdDef = intr.findContentDeserializer(member);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = null;\n+                if (cdDef instanceof JsonDeserializer<?>) {\n+                    cd = (JsonDeserializer<?>) cdDef;\n+                } else {\n+                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass != null) {\n+                        cd = config.deserializerInstance(member, cdClass);\n+                    }\n+                }\n+                if (cd != null) {\n+                    type = type.withContentValueHandler(cd);\n+                }\n             }\n             /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n              *    information to use for polymorphic members; and specifically types for\n         BasicBeanDescription beanDesc = config.introspect(enumType);\n         return beanDesc.findJsonValueMethod();\n     }\n-}\n+\n+    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n+\n+    }\n+\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n     \n     public JsonSerializer<?> buildContainerSerializer(SerializationConfig config, JavaType type,\n             BasicBeanDescription beanDesc, BeanProperty property, boolean staticTyping)\n+        throws JsonMappingException\n     {\n         // Let's see what we can learn about element/content/value type, type serializer for it:\n         JavaType elementType = type.getContentType();\n     /**\n      * Helper method that handles configuration details when constructing serializers for\n      * Collection and Collection-like types.\n-     * \n-     * @since 1.8\n      */\n     protected JsonSerializer<?> buildCollectionLikeSerializer(SerializationConfig config,\n             CollectionLikeType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+        throws JsonMappingException\n     {\n         for (Serializers serializers : customSerializers()) {\n             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, type, beanDesc, property,\n     /**\n      * Helper method that handles configuration details when constructing serializers for\n      * {@link java.util.List} types that support efficient by-index access\n-     *<p> \n-     * Note: signature changed in 1.8, to take 'staticTyping' argument\n      */\n     protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n             CollectionType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+        throws JsonMappingException\n     {\n         // Module-provided custom collection serializers?\n         for (Serializers serializers : customSerializers()) {\n         return StdContainerSerializers.enumSetSerializer(enumType, property);\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     protected boolean isIndexedList(Class<?> cls)\n     {\n         return RandomAccess.class.isAssignableFrom(cls);\n      * Helper method that handles configuration details when constructing serializers for\n      * all \"Map-like\" types; both ones that implement {@link java.util.Map} and\n      * ones that do not (but that have been indicated to behave like Maps).\n-     * \n-     * @since 1.8\n      */\n     protected JsonSerializer<?> buildMapLikeSerializer(SerializationConfig config, MapLikeType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             JsonSerializer<Object> keySerializer,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        throws JsonMappingException\n     {\n         for (Serializers serializers : customSerializers()) {\n             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, type, beanDesc, property,\n     /**\n      * Helper method that handles configuration details when constructing serializers for\n      * {@link java.util.Map} types.\n-     *<p> \n-     * Note: signature changed in 1.8, to take 'staticTyping' argument\n      */\n     protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             JsonSerializer<Object> keySerializer,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        throws JsonMappingException\n     {\n         for (Serializers serializers : customSerializers()) {\n             JsonSerializer<?> ser = serializers.findMapSerializer(config, type, beanDesc, property,\n     /**\n      * Helper method that handles configuration details when constructing serializers for\n      * {@link java.util.EnumMap} types.\n-     *<p> \n-     * Note: signature changed in 1.8, to take 'staticTyping' argument\n      */\n     protected JsonSerializer<?> buildEnumMapSerializer(SerializationConfig config, JavaType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+        throws JsonMappingException\n     {\n         JavaType keyType = type.getKeyType();\n         // Need to find key enum values...\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        throws JsonMappingException\n     {\n         Class<?> raw = type.getRawClass();\n         if (String[].class == raw) {\n     protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping)\n+        throws JsonMappingException\n     {\n         // if there's generic type, it'll be the first contained type\n         JavaType valueType = type.containedType(0);\n     protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type,\n             BasicBeanDescription beanDesc, BeanProperty property,\n             boolean staticTyping)\n+        throws JsonMappingException\n     {\n         // if there's generic type, it'll be the first contained type\n         JavaType valueType = type.containedType(0);\n      */\n     \n     /**\n-     * Helper method used to encapsulate details of annotation-based type\n-     * coercion\n-     * \n-     * @since 1.8\n+     * Helper method used to encapsulate details of annotation-based type coercion\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)\n         return modifySecondaryTypesByAnnotation(config, a, type);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     @SuppressWarnings(\"unchecked\")\n     protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)\n     {\n         return type;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected static JsonSerializer<Object> findKeySerializer(SerializationConfig config,\n             Annotated a, BeanProperty property)\n+        throws JsonMappingException\n     {\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Class<? extends JsonSerializer<?>> serClass = intr.findKeySerializer(a);\n-        if (serClass == null || serClass == JsonSerializer.None.class) {\n+        Object serDef = intr.findKeySerializer(a);\n+        if (serDef == null || serDef == JsonSerializer.None.class || serDef == NoClass.class) {\n             if (property != null) {\n-                serClass = intr.findKeySerializer(property.getMember());\n-            }\n-        }\n-        if (serClass != null && serClass != JsonSerializer.None.class) {\n-            return config.serializerInstance(a, serClass);\n+                AnnotatedMember m = property.getMember();\n+                if (m != null) {\n+                    serDef = intr.findKeySerializer(m);\n+                }\n+            }\n+        }\n+        // ok, what did we get?\n+        if (serDef != null) {\n+            if (serDef instanceof JsonSerializer<?>) {\n+                JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n+                if (ser instanceof ContextualSerializer<?>) {\n+                    return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+                }\n+                return ser;\n+            }\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector.findKeySerializer() returned value of type \"+serDef.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>) serDef;\n+            if (serClass != JsonSerializer.None.class && serClass != NoClass.class) {\n+                return config.serializerInstance(a, (Class<JsonSerializer<?>>) serClass);\n+            }\n         }\n         return null;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected static JsonSerializer<Object> findContentSerializer(SerializationConfig config,\n             Annotated a, BeanProperty property)\n+        throws JsonMappingException\n     {\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Class<? extends JsonSerializer<?>> serClass = intr.findContentSerializer(a);\n-        if (serClass == null || serClass == JsonSerializer.None.class) {\n+        Object serDef = intr.findContentSerializer(a);\n+        if (serDef == null || serDef == JsonSerializer.None.class || serDef == NoClass.class) {\n             if (property != null) {\n-                serClass = intr.findContentSerializer(property.getMember());\n-            }\n-        }\n-        if (serClass != null && serClass != JsonSerializer.None.class) {\n-            return config.serializerInstance(a, serClass);\n+                AnnotatedMember m = property.getMember();\n+                if (m != null) {\n+                    serDef = intr.findContentSerializer(m);\n+                }\n+            }\n+        }\n+        // ok, what did we get?\n+        if (serDef != null) {\n+            if (serDef instanceof JsonSerializer<?>) {\n+                JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n+                if (ser instanceof ContextualSerializer<?>) {\n+                    return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+                }\n+                return ser;\n+            }\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector.findContentSerializer() returned value of type \"+serDef.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>) serDef;\n+            if (serClass != JsonSerializer.None.class && serClass != NoClass.class) {\n+                return config.serializerInstance(a, (Class<JsonSerializer<?>>) serClass);\n+            }\n         }\n         return null;\n     }", "timestamp": 1326578499, "metainfo": ""}