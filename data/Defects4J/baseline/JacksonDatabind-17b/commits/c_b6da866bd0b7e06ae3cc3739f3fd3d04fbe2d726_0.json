{"sha": "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726", "log": "Improve handling of native type ids; use non-native type ids as fallback", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     {\n         // 02-Aug-2013, tatu: May need to use native type ids\n         if (jp.canReadTypeId()) {\n-            return _deserializeWithNativeTypeId(jp, ctxt);\n+            Object typeId = jp.getTypeId();\n+            if (typeId != null) {\n+                Object ob = _deserializeWithNativeTypeId(jp, ctxt, typeId);\n+                if (ob != null) {\n+                    return ob;\n+                }\n+            }\n         }\n         boolean hadStartArray = jp.isExpectedStartArrayToken();\n         String typeId = _locateTypeId(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n     {\n         // 02-Aug-2013, tatu: May need to use native type ids\n         if (jp.canReadTypeId()) {\n-            return _deserializeWithNativeTypeId(jp, ctxt);\n+            Object typeId = jp.getTypeId();\n+            if (typeId != null) {\n+                Object ob = _deserializeWithNativeTypeId(jp, ctxt, typeId);\n+                if (ob != null) {\n+                    return ob;\n+                }\n+            }\n         }\n         \n         // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n     {\n         // 02-Aug-2013, tatu: May need to use native type ids\n         if (jp.canReadTypeId()) {\n-            return _deserializeWithNativeTypeId(jp, ctxt);\n+            Object typeId = jp.getTypeId();\n+            if (typeId != null) {\n+                return _deserializeWithNativeTypeId(jp, ctxt, typeId);\n+            }\n         }\n \n         // first, sanity checks\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n     /**********************************************************\n      */\n \n-    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n-            String typeId)\n-        throws IOException, JsonProcessingException\n+    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId)\n+        throws IOException\n     {\n         JsonDeserializer<Object> deser;\n \n         return deser;\n     }\n \n-    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n     {\n         /* 06-Feb-2013, tatu: As per [Issue#148], consider default implementation value of\n          *   {@link NoClass} to mean \"serialize as null\"; as well as DeserializationFeature\n      * \n      * @since 2.3\n      */\n-    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        final Object typeId0 = jp.getTypeId();\n+    @Deprecated\n+    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n+    }\n+\n+    /**\n+     * Helper method called when {@link JsonParser} indicates that it can use\n+     * so-called native type ids, and such type id has been found.\n+     * \n+     * @since 2.4\n+     */\n+    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId)\n+            throws IOException\n+    {\n         JsonDeserializer<Object> deser;\n-        if (typeId0 == null) {\n-            if (_defaultImpl != null) {\n-                deser = _findDefaultImplDeserializer(ctxt);\n-            } else {\n+        if (typeId == null) {\n+            /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n+             *   for \"try to deserialize with native tpye id\"?\n+             */\n+            if (_defaultImpl == null) {\n                 throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n             }\n+            deser = _findDefaultImplDeserializer(ctxt);\n         } else {\n-            String typeId = (typeId0 instanceof String) ? (String) typeId0 : String.valueOf(typeId0);\n-            deser = _findDeserializer(ctxt, typeId);\n-        }\n-        /* 02-Aug-2013, tatu: What if type id is marked as \"visible\"? Should we try to\n-         *  inject it in, as with non-native type ids? For now, let's not.\n-         */\n+            String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n+            deser = _findDeserializer(ctxt, typeIdStr);\n+        }\n         return deser.deserialize(jp, ctxt);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ContainerBuilder.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.reflect.Array;\n+import java.util.*;\n+\n+/**\n+ * Helper class used for constructing \"untyped\" {@link java.util.List},\n+ * {@link java.util.Map} and <code>Object[]</code> values.\n+ * \n+ * @since 2.4\n+ */\n+public final class ContainerBuilder\n+{\n+    private final static int MAX_BUF = 1000;\n+\n+    /**\n+     * Buffer in which contents are being buffered (except for cases where\n+     * size has grown too big to bother with separate buffer)\n+     */\n+    private Object[] b;\n+\n+    /**\n+     * Pointer to the next available slot in temporary buffer.\n+     */\n+    private int tail;\n+\n+    /**\n+     * When building potentailly multiple containers, we need to keep track of\n+     * the starting pointer for the current container.\n+     */\n+    private int start;\n+\n+    /**\n+     * In cases where size of buffered contents has grown big enough that buffering\n+     * does not make sense, an actual {@link java.util.List} will be constructed\n+     * earlier and used instead of buffering.\n+     */\n+    private List<Object> list;\n+\n+    /**\n+     * Similar to <code>list</code>, we may sometimes eagerly construct result\n+     * {@link java.util.Map} and skip actual buffering.\n+     */\n+    private Map<String,Object> map;\n+    \n+    public ContainerBuilder(int bufSize) {\n+        b = new Object[bufSize & ~1];\n+    }\n+\n+    public boolean canReuse() {\n+        return (list == null) && (map == null);\n+    }\n+    \n+    public int bufferLength() {\n+        return b.length;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public int start() {\n+        if (list != null || map != null) {\n+            throw new IllegalStateException();\n+        }\n+        final int prevStart = start;\n+        start = tail;\n+        return prevStart;\n+    }\n+\n+    public int startList(Object value) {\n+        if (list != null || map != null) {\n+            throw new IllegalStateException();\n+        }\n+        final int prevStart = start;\n+        start = tail;\n+        add(value);\n+        return prevStart;\n+    }\n+\n+    public int startMap(String key, Object value) {\n+        if (list != null || map != null) {\n+            throw new IllegalStateException();\n+        }\n+        final int prevStart = start;\n+        start = tail;\n+        put(key, value);\n+        return prevStart;\n+    }\n+    \n+    public void add(Object value) {\n+        if (list != null) {\n+            list.add(value);\n+        } else if (tail >= b.length) {\n+            _expandList(value);\n+        } else {\n+            b[tail++] = value;\n+        }\n+    }\n+\n+    public void put(String key, Object value) {\n+        if (map != null) {\n+            map.put(key, value);\n+        } else if ((tail + 2) > b.length) {\n+            _expandMap(key, value);\n+        } else {\n+            b[tail++] = key;\n+            b[tail++] = value;\n+        }\n+    }\n+\n+    public List<Object> finishList(int prevStart)\n+    {\n+        List<Object> l = list;\n+        if (l == null) {\n+            l = _buildList(true);\n+        } else {\n+            list = null;\n+        }\n+        start = prevStart;\n+        return l;\n+    }\n+\n+    public Object[] finishArray(int prevStart)\n+    {\n+        Object[] result;\n+        if (list == null) {\n+            result = Arrays.copyOfRange(b, start, tail);\n+        } else {\n+            result = list.toArray(new Object[tail - start]);\n+            list = null;\n+        }\n+        start = prevStart;\n+        return result;\n+    }\n+\n+    public <T> Object[] finishArray(int prevStart, Class<T> elemType)\n+    {\n+        final int size = tail-start;\n+        @SuppressWarnings(\"unchecked\")\n+        T[] result = (T[]) Array.newInstance(elemType, size);\n+\n+        if (list == null) {\n+            System.arraycopy(b, start, result, 0, size);\n+        } else {\n+            result = list.toArray(result);\n+            list = null;\n+        }\n+        start = prevStart;\n+        return result;\n+    }\n+    \n+    public Map<String,Object> finishMap(int prevStart)\n+    {\n+        Map<String,Object> m = map;\n+        \n+        if (m == null) {\n+            m = _buildMap(true);\n+        } else {\n+            map = null;\n+        }\n+        start = prevStart;\n+        return m;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    private void _expandList(Object value) {\n+        if (b.length < MAX_BUF) { // can still expand\n+            b = Arrays.copyOf(b, b.length << 1);\n+            b[tail++] = value;\n+        } else {\n+            list = _buildList(false);\n+            list.add(value);\n+        }\n+    }\n+    \n+    private List<Object> _buildList(boolean isComplete)\n+    {\n+        int currLen = tail - start;\n+        if (isComplete) {\n+            if (currLen < 2) {\n+                currLen = 2;\n+            }\n+        } else {\n+            if (currLen < 20) {\n+                currLen = 20;\n+            } else if (currLen < MAX_BUF) {\n+                currLen += (currLen>>1);\n+            } else {\n+                currLen += (currLen>>2);\n+            }\n+        }\n+        List<Object> l = new ArrayList<Object>(currLen);\n+        for (int i = start; i < tail; ++i) {\n+            l.add(b[i]);\n+        }\n+        tail = start; // reset buffered entries\n+        return l;\n+    }\n+\n+    private void _expandMap(String key, Object value) {\n+        if (b.length < MAX_BUF) { // can still expand\n+            b = Arrays.copyOf(b, b.length << 1);\n+            b[tail++] = key;\n+            b[tail++] = value;\n+        } else {\n+            map = _buildMap(false);\n+            map.put(key, value);\n+        }\n+    }\n+    \n+    private Map<String,Object> _buildMap(boolean isComplete)\n+    {\n+        int size = (tail - start) >> 1;\n+        if (isComplete) { // when complete, optimize to smallest size\n+            if (size <= 3) { // 3 or fewer entries, hash table of 4\n+                size = 4; \n+            } else if (size <= 40) {\n+                size += (size>>1);\n+            } else {\n+                size += (size>>2) + (size>>4); // * 1.3125\n+            }\n+        } else {\n+            if (size < 10) {\n+                size = 16;\n+            } else if (size < MAX_BUF) {\n+                size += (size>>1);\n+            } else {\n+                size += (size/3);\n+            }\n+        }\n+        Map<String,Object> m = new LinkedHashMap<String,Object>(size, 0.8f);\n+        for (int i = start; i < tail; i += 2) {\n+            m.put((String) b[i], b[i+1]);\n+        }\n+        tail = start; // reset buffered entries\n+        return m;\n+    }\n+}", "timestamp": 1399254560, "metainfo": ""}