{"sha": "f0e232d14f4085bac5b5c40eb5efae2aaad5fbec", "log": "Sync with core, now that JsonNode is part of mapper", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.TreeNode;\n+\n+/**\n+ * Base class for all JSON nodes, which form the basis of JSON\n+ * Tree Model that Jackson implements.\n+ * One way to think of these nodes is to consider them\n+ * similar to DOM nodes in XML DOM trees.\n+ *<p>\n+ * As a general design rule, most accessors (\"getters\") are included\n+ * in this base class, to allow for traversing structure without\n+ * type casts. Most mutators, however, need to be accessed through\n+ * specific sub-classes (such as <code>ObjectNode</code>\n+ * and <code>ArrayNode</code>).\n+ * This seems sensible because proper type\n+ * information is generally available when building or modifying\n+ * trees, but less often when reading a tree (newly built from\n+ * parsed JSON content).\n+ *<p>\n+ * Actual concrete sub-classes can be found from package\n+ * {@link com.fasterxml.jackson.databind.node}.\n+ */\n+public abstract class JsonNode\n+    implements TreeNode, Iterable<JsonNode>\n+{\n+    protected final static List<JsonNode> NO_NODES = Collections.emptyList();\n+    protected final static List<String> NO_STRINGS = Collections.emptyList();\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, related\n+    /**********************************************************\n+     */\n+    \n+    protected JsonNode() { }\n+\n+    /**\n+     * Method that can be called to get a node that is guaranteed\n+     * not to allow changing of this node through mutators on\n+     * this node or any of its children.\n+     * This means it can either make a copy of this node (and all\n+     * mutable children and grand children nodes), or node itself\n+     * if it is immutable.\n+     *<p>\n+     * Note: return type is guaranteed to have same type as the\n+     * node method is called on; which is why method is declared\n+     * with local generic type.\n+     * \n+     * @since 2.0\n+     * \n+     * @return Node that is either a copy of this node (and all non-leaf\n+     *    children); or, for immutable leaf nodes, node itself.\n+     */\n+    public abstract <T extends JsonNode> T deepCopy();\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, type introspection\n+    /**********************************************************\n+     */\n+\n+    // // First high-level division between values, containers and \"missing\"\n+\n+    /**\n+     * Method that returns true for all value nodes: ones that \n+     * are not containers, and that do not represent \"missing\" nodes\n+     * in the path. Such value nodes represent String, Number, Boolean\n+     * and null values from JSON.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isValueNode() { return false; }\n+\n+    /**\n+     * Method that returns true for container nodes: Arrays and Objects.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isContainerNode() { return false; }\n+\n+    /**\n+     * Method that returns true for \"virtual\" nodes which represent\n+     * missing entries constructed by path accessor methods when\n+     * there is no actual node matching given criteria.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isMissingNode() { return false; }\n+\n+    // // Then more specific type introspection\n+    // // (along with defaults to be overridden)\n+\n+    /**\n+     * @return True if this node represents JSON Array\n+     */\n+    public boolean isArray() { return false; }\n+\n+    /**\n+     * @return True if this node represents JSON Object\n+     */\n+    public boolean isObject() { return false; }\n+\n+    /**\n+     * Method that can be used to check if the node is a wrapper\n+     * for a POJO (\"Plain Old Java Object\" aka \"bean\".\n+     * Returns true only for\n+     * instances of <code>POJONode</code>.\n+     *\n+     * @return True if this node wraps a POJO\n+     */\n+    public boolean isPojo() { return false; }\n+\n+    /**\n+     * @return True if this node represents a numeric JSON\n+     *   value\n+     */\n+    public boolean isNumber() { return false; }\n+\n+    /**\n+     * \n+     * @return True if this node represents an integral (integer)\n+     *   numeric JSON value\n+     */\n+    public boolean isIntegralNumber() { return false; }\n+\n+    /**\n+     * @return True if this node represents a non-integral\n+     *   numeric JSON value\n+     */\n+    public boolean isFloatingPointNumber() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether contained value\n+     * is a number represented as Java <code>int</code>.\n+     * Note, however, that even if this method returns false, it\n+     * is possible that conversion would be possible from other numeric\n+     * types -- to check if this is possible, use\n+     * {@link #canConvertToInt()} instead.\n+     * \n+     * @return True if the value contained by this node is stored as Java int\n+     */\n+    public boolean isInt() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether contained value\n+     * is a number represented as Java <code>long</code>.\n+     * Note, however, that even if this method returns false, it\n+     * is possible that conversion would be possible from other numeric\n+     * types -- to check if this is possible, use\n+     * {@link #canConvertToInt()} instead.\n+     * \n+     * @return True if the value contained by this node is stored as Java <code>long</code>\n+     */\n+    public boolean isLong() { return false; }\n+\n+    public boolean isDouble() { return false; }\n+    public boolean isBigDecimal() { return false; }\n+    public boolean isBigInteger() { return false; }\n+\n+    public boolean isTextual() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * JSON boolean value (literals \"true\" and \"false\").\n+     */\n+    public boolean isBoolean() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * JSON literal null value.\n+     */\n+    public boolean isNull() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node represents\n+     * binary data (Base64 encoded). Although this will be externally\n+     * written as JSON String value, {@link #isTextual} will\n+     * return false if this method returns true.\n+     *\n+     * @return True if this node represents base64 encoded binary data\n+     */\n+    public boolean isBinary() { return false; }\n+\n+    /**\n+     * Method that can be used for efficient type detection\n+     * when using stream abstraction for traversing nodes.\n+     * Will return the first {@link JsonToken} that equivalent\n+     * stream event would produce (for most nodes there is just\n+     * one token but for structured/container types multiple)\n+     */\n+    public abstract JsonToken asToken();\n+\n+    /**\n+     * If this node is a numeric type (as per {@link #isNumber}),\n+     * returns native type that node uses to store the numeric value;\n+     * otherwise returns null.\n+     * \n+     * @return Type of number contained, if any; or null if node does not\n+     *  contain numeric value.\n+     */\n+    public abstract JsonParser.NumberType numberType();\n+\n+    /**\n+     * Method that can be used to check whether this node is a numeric\n+     * node ({@link #isNumber} would return true) AND its value fits\n+     * within Java's 32-bit signed integer type, <code>int</code>.\n+     * Note that floating-point numbers are convertible if the integral\n+     * part fits without overflow (as per standard Java coercion rules)\n+     * \n+     * @since 2.0\n+     */\n+    public boolean canConvertToInt() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether this node is a numeric\n+     * node ({@link #isNumber} would return true) AND its value fits\n+     * within Java's 64-bit signed integer type, <code>long</code>.\n+     * Note that floating-point numbers are convertible if the integral\n+     * part fits without overflow (as per standard Java coercion rules)\n+     * \n+     * @since 2.0\n+     */\n+    public boolean canConvertToLong() { return false; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, straight value access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to use for accessing String values.\n+     * Does <b>NOT</b> do any conversions for non-String value nodes;\n+     * for non-String values (ones for which {@link #isTextual} returns\n+     * false) null will be returned.\n+     * For String values, null is never returned (but empty Strings may be)\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   JSON node (comes from JSON String value entry)\n+     */\n+    public String textValue() { return null; }\n+\n+    /**\n+     * Method to use for accessing binary content of binary nodes (nodes\n+     * for which {@link #isBinary} returns true); or for Text Nodes\n+     * (ones for which {@link #textValue} returns non-null value),\n+     * to read decoded base64 data.\n+     * For other types of nodes, returns null.\n+     *\n+     * @return Binary data this node contains, iff it is a binary\n+     *   node; null otherwise\n+     */\n+    public byte[] binaryValue() throws IOException\n+    {\n+        return null;\n+    }\n+\n+    /**\n+     * Method to use for accessing JSON boolean values (value\n+     * literals 'true' and 'false').\n+     * For other types, always returns false.\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   json node (comes from JSON String value entry)\n+     */\n+    public boolean booleanValue() { return false; }\n+\n+    /**\n+     * Returns numeric value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true); otherwise\n+     * returns null\n+     *\n+     * @return Number value this node contains, if any (null for non-number\n+     *   nodes).\n+     */\n+    public Number numberValue() { return null; }\n+\n+    /**\n+     * Returns integer value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true). For other\n+     * types returns 0.\n+     * For floating-point numbers, value is truncated using default\n+     * Java coercion, similar to how cast from double to int operates.\n+     *\n+     * @return Integer value this node contains, if any; 0 for non-number\n+     *   nodes.\n+     */\n+    public int intValue() { return 0; }\n+\n+    public long longValue() { return 0L; }\n+    public double doubleValue() { return 0.0; }\n+    public BigDecimal decimalValue() { return BigDecimal.ZERO; }\n+    public BigInteger bigIntegerValue() { return BigInteger.ZERO; }\n+\n+    /**\n+     * Method for accessing value of the specified element of\n+     * an array node. For other nodes, null is always returned.\n+     *<p>\n+     * For array nodes, index specifies\n+     * exact location within array and allows for efficient iteration\n+     * over child elements (underlying storage is guaranteed to\n+     * be efficiently indexable, i.e. has random-access to elements).\n+     * If index is less than 0, or equal-or-greater than\n+     * <code>node.size()</code>, null is returned; no exception is\n+     * thrown for any index.\n+     *\n+     * @return Node that represent value of the specified element,\n+     *   if this node is an array and has specified element.\n+     *   Null otherwise.\n+     */\n+    public JsonNode get(int index) { return null; }\n+\n+    /**\n+     * Method for accessing value of the specified field of\n+     * an object node. If this node is not an object (or it\n+     * does not have a value for specified field name), or\n+     * if there is no field with such name, null is returned.\n+     *\n+     * @return Node that represent value of the specified field,\n+     *   if this node is an object and has value for the specified\n+     *   field. Null otherwise.\n+     */\n+    public JsonNode get(String fieldName) { return null; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, value access with conversion(s)/coercion(s)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will return valid String representation of\n+     * the container value, if the node is a value node\n+     * (method {@link #isValueNode} returns true), otherwise\n+     * empty String.\n+     */\n+    public abstract String asText();\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public int asInt() {\n+        return asInt(0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public int asInt(int defaultValue) {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an long (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public long asLong() {\n+        return asLong(0L);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an long (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public long asLong(long defaultValue) {\n+        return defaultValue;\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0.0</b> will be returned; no exceptions are thrown.\n+     */\n+    public double asDouble() {\n+        return asDouble(0.0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public double asDouble(double defaultValue) {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>false</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean asBoolean() {\n+        return asBoolean(false);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean asBoolean(boolean defaultValue) {\n+        return defaultValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, value find / existence check methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that allows checking whether this node is JSON Object node\n+     * and contains value for specified property. If this is the case\n+     * (including properties with explicit null values), returns true;\n+     * otherwise returns false.\n+     *<p>\n+     * This method is equivalent to:\n+     *<pre>\n+     *   node.get(fieldName) != null\n+     *</pre>\n+     * (since return value of get() is node, not value node contains)\n+     *\n+     * @param fieldName Name of element to check\n+     * \n+     * @return True if this node is a JSON Object node, and has a property\n+     *   entry with specified name (with any value, including null value)\n+     */\n+    public boolean has(String fieldName) {\n+        return get(fieldName) != null;\n+    }\n+\n+    /**\n+     * Method that allows checking whether this node is JSON Array node\n+     * and contains a value for specified index\n+     * If this is the case\n+     * (including case of specified indexing having null as value), returns true;\n+     * otherwise returns false.\n+     *<p>\n+     * Note: array element indexes are 0-based.\n+     *<p>\n+     * This method is equivalent to:\n+     *<pre>\n+     *   node.get(index) != null\n+     *</pre>\n+     *\n+     * @param index Index to check\n+     * \n+     * @return True if this node is a JSON Object node, and has a property\n+     *   entry with specified name (with any value, including null value)\n+     */\n+    public boolean has(int index) {\n+        return get(index) != null;\n+    }\n+\n+    /**\n+     * Method for finding a JSON Object field with specified name in this\n+     * node or its child nodes, and returning value it has.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public abstract JsonNode findValue(String fieldName);\n+\n+    /**\n+     * Method for finding JSON Object fields with specified name, and returning\n+     * found ones as a List. Note that sub-tree search ends if a field is found,\n+     * so possible children of result nodes are <b>not</b> included.\n+     * If no matching fields are found in this node or its descendants, returns\n+     * an empty List.\n+     * \n+     * @param fieldName Name of field to look for\n+     */\n+    public final List<JsonNode> findValues(String fieldName)\n+    {\n+        List<JsonNode> result = findValues(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Similar to {@link #findValues}, but will additionally convert\n+     * values into Strings, calling {@link #asText}.\n+     */\n+    public final List<String> findValuesAsText(String fieldName)\n+    {\n+        List<String> result = findValuesAsText(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Method similar to {@link #findValue}, but that will return a\n+     * \"missing node\" instead of null if no field is found. Missing node\n+     * is a specific kind of node for which {@link #isMissingNode}\n+     * returns true; and all value access methods return empty or\n+     * missing value.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found; or if not found, a\n+     *    \"missing node\" (non-null instance that has no value)\n+     */\n+    public abstract JsonNode findPath(String fieldName);\n+    \n+    /**\n+     * Method for finding a JSON Object that contains specified field,\n+     * within this node or its descendants.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public abstract JsonNode findParent(String fieldName);\n+\n+    /**\n+     * Method for finding a JSON Object that contains specified field,\n+     * within this node or its descendants.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public final List<JsonNode> findParents(String fieldName)\n+    {\n+        List<JsonNode> result = findParents(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar);\n+    public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar);\n+    public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar);\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, container access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns number of child nodes this node contains:\n+     * for Array nodes, number of child elements, for Object nodes,\n+     * number of fields, and for all other nodes 0.\n+     *\n+     * @return For non-container nodes returns 0; for arrays number of\n+     *   contained elements, and for objects number of fields.\n+     */\n+    public int size() { return 0; }\n+\n+    /**\n+     * Same as calling {@link #elements}; implemented so that\n+     * convenience \"for-each\" loop can be used for looping over elements\n+     * of JSON Array constructs.\n+     */\n+    @Override\n+    public final Iterator<JsonNode> iterator() { return elements(); }\n+\n+    /**\n+     * Method for accessing all value nodes of this Node, iff\n+     * this node is a JSON Array or Object node. In case of Object node,\n+     * field names (keys) are not included, only values.\n+     * For other types of nodes, returns empty iterator.\n+     */\n+    public Iterator<JsonNode> elements() { return NO_NODES.iterator(); }\n+\n+    /**\n+     * Method for accessing names of all fields for this Node, iff\n+     * this node is a JSON Object node.\n+     */\n+    public Iterator<String> fieldNames() { return NO_STRINGS.iterator(); }\n+\n+    /**\n+     * @return Iterator that can be used to traverse all key/value pairs for\n+     *   object nodes; empty iterator (no contents) for other types\n+     */\n+    public Iterator<Map.Entry<String, JsonNode>> fields() {\n+        Collection<Map.Entry<String, JsonNode>> coll = Collections.emptyList();\n+        return coll.iterator();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, path handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This method is similar to {@link #get(String)}, except\n+     * that instead of returning null if no such value exists (due\n+     * to this node not being an object, or object not having value\n+     * for the specified field),\n+     * a \"missing node\" (node that returns true for\n+     * {@link #isMissingNode}) will be returned. This allows for\n+     * convenient and safe chained access via path calls.\n+     */\n+    public abstract JsonNode path(String fieldName);\n+\n+    /**\n+     * This method is similar to {@link #get(int)}, except\n+     * that instead of returning null if no such element exists (due\n+     * to index being out of range, or this node not being an array),\n+     * a \"missing node\" (node that returns true for\n+     * {@link #isMissingNode}) will be returned. This allows for\n+     * convenient and safe chained access via path calls.\n+     */\n+    public abstract JsonNode path(int index);\n+\n+    /**\n+     * Method that can be called on object nodes, to access a property\n+     * that has object value; or if no such property exists, to create and\n+     * return such object node.\n+     * If node method is called on is not Object node,\n+     * or if property exists and has value that is not object node,\n+     * {@link UnsupportedOperationException} is thrown\n+     */\n+    public JsonNode with(String propertyName) {\n+        throw new UnsupportedOperationException(\"JsonNode not of type ObjectNode (but \"\n+                +getClass().getName()+\"), can not call with() on it\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API: converting to/from Streaming API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a {@link JsonParser} instance for\n+     * iterating over contents of the tree that this\n+     * node is root of.\n+     * Functionally equivalent to first serializing tree using\n+     * {@link com.fasterxml.jackson.core.ObjectCodec} and then re-parsing but\n+     * more efficient.\n+     */\n+    public abstract JsonParser traverse();\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     *<p>\n+     * Note: marked as abstract to ensure all implementation\n+     * classes define it properly.\n+     */\n+    @Override\n+    public abstract String toString();\n+\n+    /**\n+     * Equality for node objects is defined as full (deep) value\n+     * equality. This means that it is possible to compare complete\n+     * JSON trees for equality by comparing equality of root nodes.\n+     *<p>\n+     * Note: marked as abstract to ensure all implementation\n+     * classes define it properly and not rely on definition\n+     * from {@link java.lang.Object}.\n+     */\n+    @Override\n+    public abstract boolean equals(Object o);\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * value event, not container).\n      */\n     @Override\n-    public JsonNode readTree(JsonParser jp)\n+    public <T extends TreeNode> T readTree(JsonParser jp)\n         throws IOException, JsonProcessingException\n     {\n         /* 02-Mar-2009, tatu: One twist; deserialization provider\n             }\n         }\n         JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n-        return (n == null) ? getNodeFactory().nullNode() : n;\n+        if (n == null) {\n+            n = getNodeFactory().nullNode();\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        T result = (T) n;\n+        return result;\n     }\n \n     /**\n      * Method to serialize given JSON Tree, using generator\n      * provided.\n      */\n-    @Override\n     public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n         throws IOException, JsonProcessingException\n     {\n      * @param n Root node of the tree that resulting parser will read from\n      */\n     @Override\n-    public JsonParser treeAsTokens(JsonNode n)\n-    {\n-        return new TreeTraversingParser(n, this);\n+    public JsonParser treeAsTokens(TreeNode n)\n+    {\n+        return new TreeTraversingParser((JsonNode) n, this);\n     }\n \n     /**\n      *</pre>\n      */\n     @Override\n-    public <T> T treeToValue(JsonNode n, Class<T> valueType)\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n         throws JsonProcessingException\n     {\n         try {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n+\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n      * Note: if an object was specified with {@link #withValueToUpdate}, it\n      * will be ignored.\n      */\n-    @Override\n-    public JsonNode readTree(JsonParser jp)\n-        throws IOException, JsonProcessingException\n-    {\n-        return _bindAsTree(jp);\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends TreeNode> T readTree(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAsTree(jp);\n     }\n \n     /**\n     }\n \n     @Override\n-    public JsonParser treeAsTokens(JsonNode n) {\n-        return new TreeTraversingParser(n, this);\n-    }\n-\n-    @Override\n-    public <T> T treeToValue(JsonNode n, Class<T> valueType)\n+    public JsonParser treeAsTokens(TreeNode n) {\n+        return new TreeTraversingParser((JsonNode) n, this);\n+    }\n+\n+    @Override\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n         throws JsonProcessingException\n     {\n         try {\n         }\n     }\n \n-    /**\n-     * NOTE: NOT implemented for {@link ObjectReader}.\n-     */\n-    @Override\n-    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException\n+    @Override\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n     {\n         throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n-\n-    @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n-        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.util.*;\n import java.util.concurrent.*;\n \n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n \n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.ArrayType;\n-import com.fasterxml.jackson.databind.type.CollectionLikeType;\n-import com.fasterxml.jackson.databind.type.CollectionType;\n-import com.fasterxml.jackson.databind.type.MapLikeType;\n-import com.fasterxml.jackson.databind.type.MapType;\n+import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n  *   mostly to make it possible to support Scala Maps (which are NOT JDK\n  *   Map compatible).\n  *  </li>\n- * <li>For Tree Model ({@link com.fasterxml.jackson.core.JsonNode}) properties there is\n+ * <li>For Tree Model ({@link com.fasterxml.jackson.databind.JsonNode}) properties there is\n  *    {@link #createTreeDeserializer}\n  * <li>For enumerated types ({@link java.lang.Enum}) there is\n  *    {@link #createEnumDeserializer}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     /**\n      * Method called to locate deserializer for specified JSON tree node type.\n      * \n-     * @param nodeType Specific type of JSON tree nodes to deserialize (subtype of {@link com.fasterxml.jackson.core.JsonNode})\n+     * @param nodeType Specific type of JSON tree nodes to deserialize\n+     *  (subtype of {@link com.fasterxml.jackson.databind.JsonNode})\n      * @param config Configuration in effect\n      * @param property Property that contains value  (null for root values)\n      * \n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n \n-import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Container for a logical JSON Schema instance.\n  * Internally schema data is stored as a JSON Tree\n- * (instance of {@link com.fasterxml.jackson.core.JsonNode} is the root\n+ * (instance of {@link JsonNode} is the root\n  * of schema document)\n  *\n  * @author Ryan Heaton\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n-import com.fasterxml.jackson.core.JsonNode;\n-\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n \n \n /**\n  * Marker interface for schema-aware serializers.\n- *\n- * @author Ryan Heaton\n  */\n public interface SchemaAware\n {\n      * @param typeHint A hint about the type.\n      * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n      */\n-    JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-            throws JsonMappingException;\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n package com.fasterxml.jackson.databind.module;\n \n import java.util.*;\n-\n-import com.fasterxml.jackson.core.JsonNode;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n import java.util.List;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-\n \n /**\n  * Numeric node that contains simple 64-bit integer values.\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n import java.util.NoSuchElementException;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n  * This intermediate base class is used for all container nodes,\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n  * Helper class used by {@link TreeTraversingParser} to keep track\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * Node that maps to JSON Object structures in JSON content.\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+\n import com.fasterxml.jackson.databind.DatabindVersion;\n+import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n  * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * This intermediate base class is used for all leaf nodes, that is,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n-\n \n /**\n  * Special bogus \"serializer\" that will throw\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n \n \n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonNode;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonNode;\n-\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n  * String serializer.\n  */\n @JacksonStdImpl\n-\n public class StringCollectionSerializer\n     extends StaticListSerializerBase<Collection<String>>\n     implements ResolvableSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+\n import com.fasterxml.jackson.databind.DatabindVersion;\n \n /**\n     }\n \n     @Override\n-    public void writeTree(JsonNode rootNode)\n+    public void writeTree(TreeNode rootNode)\n         throws IOException, JsonProcessingException\n     {\n         /* 31-Dec-2009, tatu: no need to convert trees either is there?\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n \n import static org.junit.Assert.*;\n \n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n+\n import com.fasterxml.jackson.databind.ObjectMapper;\n+\n import com.fasterxml.jackson.test.BaseTest;\n \n public abstract class BaseMapTest\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n-import com.fasterxml.jackson.core.JsonNode;\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n             if (i == 0) {\n                 assertToken(JsonToken.START_ARRAY, jp.nextToken());\n             }\n-            JsonNode root = jp.readValueAsTree();\n+            JsonNode root = (JsonNode) jp.readValueAsTree();\n             jp.close();\n             assertTrue(root.isArray());\n             assertEquals(3, root.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n \n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForArrays.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForArrays.java\n package com.fasterxml.jackson.databind.jsontype;\n \n-\n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n         public Leaf deserialize(JsonParser jp, DeserializationContext ctxt)\n                 throws IOException, JsonProcessingException\n         {\n-            JsonNode tree = jp.readValueAsTree();\n+            JsonNode tree = (JsonNode) jp.readValueAsTree();\n             Leaf leaf = new Leaf();\n             leaf.value = tree.get(\"value\").intValue();\n             return leaf;\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestFindMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestFindMethods.java\n \n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNodeFactoryConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNodeFactoryConfig.java\n package com.fasterxml.jackson.databind.node;\n \n-\n-\n-import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n-import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.BaseMapTest;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n /**\n  * Basic tests for {@link JsonNode} implementations that\n  * contain numeric values.\n  */\n-public class TestNumberNodes extends BaseMapTest\n+public class TestNumberNodes extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     public void testInt()\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n import java.math.BigDecimal;\n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n-import com.fasterxml.jackson.databind.node.NullNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.node.TextNode;\n \n /**\n  * Additional tests for {@link ObjectNode} container class.\n--- a/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeDeserialization.java\n package com.fasterxml.jackson.databind.tree;\n-\n \n import java.io.*;\n \n-\n-import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.node.*;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperMaps.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperMaps.java\n package com.fasterxml.jackson.databind.tree;\n-\n \n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.test.BaseTest;", "timestamp": 1327884268, "metainfo": ""}