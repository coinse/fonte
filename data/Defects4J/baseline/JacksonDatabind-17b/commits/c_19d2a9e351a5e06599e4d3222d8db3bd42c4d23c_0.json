{"sha": "19d2a9e351a5e06599e4d3222d8db3bd42c4d23c", "log": "Fixing timezone handling for custom Date deserializers as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n+import java.util.Locale;\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n /**\n  * Container class for core JDK date/time type deserializers.\n          */\n         protected final DateFormat _customFormat;\n \n+        /**\n+         * Let's also keep format String for reference, to use for error messages\n+         */\n+        protected final String _formatString;\n+        \n         protected DateBasedDeserializer(Class<?> clz) {\n             super(clz);\n             _customFormat = null;\n+            _formatString = null;\n         }\n \n         protected DateBasedDeserializer(DateBasedDeserializer<T> base,\n-                DateFormat format) {\n+                DateFormat format, String formatStr) {\n             super(base._valueClass);\n             _customFormat = format;\n-        }\n-\n-        protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df);\n+            _formatString = formatStr;\n+        }\n+\n+        protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df, String formatStr);\n         \n         @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n             if (property != null) {\n                 JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat(property.getMember());\n                 if (format != null) {\n+                    TimeZone tz = format.getTimeZone();\n+                    // First: fully custom pattern?\n                     String pattern = format.getPattern();\n                     if (pattern.length() > 0){\n-                        SimpleDateFormat df = new SimpleDateFormat(pattern, ctxt.getLocale());\n-                        df.setTimeZone(ctxt.getTimeZone());\n-                        return withDateFormat(df);\n+                        Locale loc = format.getLocale();\n+                        if (loc == null) {\n+                            loc = ctxt.getLocale();\n+                        }\n+                        SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n+                        if (tz == null) {\n+                            tz = ctxt.getTimeZone();\n+                        }\n+                        df.setTimeZone(tz);\n+                        return withDateFormat(df, pattern);\n+                    }\n+                    // But if not, can still override timezone\n+                    if (tz != null) {\n+                        DateFormat df = ctxt.getConfig().getDateFormat();\n+                        // one shortcut: with our custom format, can simplify handling a bit\n+                        if (df.getClass() == StdDateFormat.class) {\n+                            df = ((StdDateFormat) df).withTimeZone(tz);\n+                        } else {\n+                            // otherwise need to clone, re-set timezone:\n+                            df = (DateFormat) df.clone();\n+                            df.setTimeZone(tz);\n+                        }\n+                        return withDateFormat(df, pattern);\n                     }\n                 }\n             }\n                     try {\n                         return _customFormat.parse(str);\n                     } catch (ParseException e) {\n-                        throw new IllegalArgumentException(\"Failed to parse Date value '\"+str+\"': \"+e.getMessage());\n+                        throw new IllegalArgumentException(\"Failed to parse Date value '\"+str\n+                                +\"' (format: \\\"\"+_formatString+\"\\\"): \"+e.getMessage());\n                     }\n                 }\n             }\n             _calendarClass = cc;\n         }\n \n-        public CalendarDeserializer(CalendarDeserializer src, DateFormat df) {\n-            super(src, df);\n+        public CalendarDeserializer(CalendarDeserializer src, DateFormat df, String formatString) {\n+            super(src, df, formatString);\n             _calendarClass = src._calendarClass;\n         }\n \n         @Override\n-        protected CalendarDeserializer withDateFormat(DateFormat df) {\n-            return new CalendarDeserializer(this, df);\n+        protected CalendarDeserializer withDateFormat(DateFormat df, String formatString) {\n+            return new CalendarDeserializer(this, df, formatString);\n         }\n         \n         @Override\n         extends DateBasedDeserializer<Date>\n     {\n         public DateDeserializer() { super(Date.class); }\n-        public DateDeserializer(DateDeserializer base, DateFormat df) {\n-            super(base, df);\n-        }\n-\n-        @Override\n-        protected DateDeserializer withDateFormat(DateFormat df) {\n-            return new DateDeserializer(this, df);\n+        public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) {\n+            super(base, df, formatString);\n+        }\n+\n+        @Override\n+        protected DateDeserializer withDateFormat(DateFormat df, String formatString) {\n+            return new DateDeserializer(this, df, formatString);\n         }\n         \n         @Override\n         extends DateBasedDeserializer<java.sql.Date>\n     {\n         public SqlDateDeserializer() { super(java.sql.Date.class); }\n-        public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df) {\n-            super(src, df);\n-        }\n-\n-        @Override\n-        protected SqlDateDeserializer withDateFormat(DateFormat df) {\n-            return new SqlDateDeserializer(this, df);\n+        public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df, String formatString) {\n+            super(src, df, formatString);\n+        }\n+\n+        @Override\n+        protected SqlDateDeserializer withDateFormat(DateFormat df, String formatString) {\n+            return new SqlDateDeserializer(this, df, formatString);\n         }\n         \n         @Override\n         extends DateBasedDeserializer<Timestamp>\n     {\n         public TimestampDeserializer() { super(Timestamp.class); }\n-        public TimestampDeserializer(TimestampDeserializer src, DateFormat df) {\n-            super(src, df);\n-        }\n-\n-        @Override\n-        protected TimestampDeserializer withDateFormat(DateFormat df) {\n-            return new TimestampDeserializer(this, df);\n+        public TimestampDeserializer(TimestampDeserializer src, DateFormat df, String formatString) {\n+            super(src, df, formatString);\n+        }\n+\n+        @Override\n+        protected TimestampDeserializer withDateFormat(DateFormat df, String formatString) {\n+            return new TimestampDeserializer(this, df, formatString);\n         }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n      */\n \n     public StdDateFormat() { }\n-\n+    public StdDateFormat(TimeZone tz) {\n+        _timezone = tz;\n+    }\n+\n+    public StdDateFormat withTimeZone(TimeZone tz) {\n+        return new StdDateFormat(tz);\n+    }\n+    \n     @Override\n     public StdDateFormat clone() {\n         /* Although there is that much state to share, we do need to\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n     {\n         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\";yyyy/MM/dd;\")\n         public Calendar cal;\n+    }\n+\n+    static class DateInCETBean {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd,HH\", timezone=\"CET\")\n+        public Date date;\n     }\n     \n     /*\n \n     public void testCustomCalendarWithAnnotation() throws Exception\n     {\n-        CalendarAsStringBean cbean = MAPPER.readValue(\"{\\\"cal\\\":\\\";2007/07/13;\\\"}\", CalendarAsStringBean.class);\n+        CalendarAsStringBean cbean = MAPPER.readValue(\"{\\\"cal\\\":\\\";2007/07/13;\\\"}\",\n+                CalendarAsStringBean.class);\n         assertNotNull(cbean);\n         assertNotNull(cbean.cal);\n-        // not sure why this is actually needed but...\n         Calendar c = cbean.cal;\n-//        Calendar c = gmtCalendar(cbean.cal.getTimeInMillis());\n         assertEquals(2007, c.get(Calendar.YEAR));\n         assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n         assertEquals(13, c.get(Calendar.DAY_OF_MONTH));\n     }\n-    \n+\n+    public void testCustomCalendarWithTimeZone() throws Exception\n+    {\n+        // And then with different TimeZone: CET is +01:00 from GMT -- read as CET\n+        DateInCETBean cet = MAPPER.readValue(\"{\\\"date\\\":\\\"2001-01-01,10\\\"}\",\n+                DateInCETBean.class);\n+        Calendar c = Calendar.getInstance(getUTCTimeZone());\n+        c.setTimeInMillis(cet.date.getTime());\n+        // so, going to UTC/GMT should reduce hour by one\n+        assertEquals(2001, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));\n+        assertEquals(1, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(9, c.get(Calendar.HOUR_OF_DAY));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods", "timestamp": 1330065777, "metainfo": ""}