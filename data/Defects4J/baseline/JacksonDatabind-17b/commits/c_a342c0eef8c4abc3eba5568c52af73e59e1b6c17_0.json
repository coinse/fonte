{"sha": "a342c0eef8c4abc3eba5568c52af73e59e1b6c17", "log": "Yet more clean up", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n-import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n-\n \n /**\n  * Basic container for information gathered by {@link ClassIntrospector} to\n     /**\n      * Method for resolving given JDK type, using this bean as the\n      * generic type resolution context.\n-     * \n-     * @since 1.9\n      */\n     public abstract JavaType resolveType(java.lang.reflect.Type jdkType);\n     \n     /**\n      * Method for accessing collection of annotations the bean\n      * class has.\n-     * \n-     * @since 1.7\n      */\n     public abstract Annotations getClassAnnotations();\n     \n     /**\n      * @return Ordered Map with logical property name as key, and\n      *    matching getter method as value.\n-     *    \n-     * @since 1.9\n      */\n     public abstract List<BeanPropertyDefinition> findProperties();\n \n-    /**\n-     * @since 1.9\n-     */\n     public abstract Map<Object, AnnotatedMember> findInjectables();\n     \n-    /**\n-     * @since 1.9\n-     */\n     public abstract AnnotatedMethod findAnyGetter();\n \n-    /**\n-     * @since 1.9\n-     */\n     public abstract AnnotatedMethod findAnySetter();\n \n-    /**\n-     * @since 1.9\n-     */\n     public abstract AnnotatedMethod findJsonValueMethod();\n \n-    /**\n-     * @since 1.9\n-     */\n     public abstract AnnotatedConstructor findDefaultConstructor();\n     \n-    /**\n-     * @since 1.9\n-     */\n     public abstract Set<String> getIgnoredPropertyNames();\n-\n-    /*\n-    /**********************************************************\n-    /* Deprecated methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * @deprecated Since 1.9 use {@link #findProperties}\n-     */\n-    @Deprecated\n-    public abstract LinkedHashMap<String,AnnotatedMethod> findGetters(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties);\n-\n-    /**\n-     * @deprecated Since 1.9 use {@link #findProperties}\n-     */\n-    @Deprecated\n-    public abstract LinkedHashMap<String,AnnotatedMethod> findSetters(VisibilityChecker<?> visibilityChecker);\n-\n-    /**\n-     * @deprecated Since 1.9 use {@link #findProperties}\n-     */\n-    @Deprecated\n-    public abstract LinkedHashMap<String,AnnotatedField> findDeserializableFields(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties);\n-\n-    /**\n-     * @deprecated Since 1.9 use the non-deprecated version\n-     */\n-    @Deprecated\n-    public abstract Map<String,AnnotatedField> findSerializableFields(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties);\n-\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.databind.type.SimpleType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n import org.codehaus.jackson.*;\n import org.codehaus.jackson.node.*;\n      *  {@link org.codehaus.jackson.node.ObjectNode}\n      * @param fromValue Bean value to convert\n      * @return Root node of the resulting JSON tree\n-     * \n-     * @since 1.6\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T extends JsonNode> T valueToTree(Object fromValue)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n-\n \n /**\n  * Abstract factory base class that can provide deserializers for standard\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.JavaType;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JsonCachable;\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n-\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Deserializer class that can deserialize instances of\n      * values for creator method need to be buffered, first; and \n      * due to non-guaranteed ordering possibly some other properties\n      * as well.\n-     *\n-     * @since 1.2\n      */\n     protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n  * Builder class used for aggregating deserialization information about\n  * a POJO, in order to build a {@link JsonDeserializer} for deserializing\n  * intances.\n- * \n- * @since 1.7\n  */\n public class BeanDeserializerBuilder\n {\n         }\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public void addInjectable(String propertyName, JavaType propertyType,\n             Annotations contextAnnotations, AnnotatedMember member,\n             Object valueId)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n import java.lang.reflect.Member;\n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n         _canFixAccess = canFixAccess;\n     }\n \n-    /**\n-     * @since 1.9.0\n-     */\n     public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n     {\n         StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n import java.util.Collection;\n import java.util.HashMap;\n \n-import org.codehaus.jackson.JsonParser;\n+import com.fasterxml.jackson.core.JsonParser;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValue.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValue.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n import java.io.IOException;\n-import org.codehaus.jackson.JsonProcessingException;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n \n import com.fasterxml.jackson.databind.deser.SettableAnyProperty;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n-import org.codehaus.jackson.JsonParser;\n+import com.fasterxml.jackson.core.JsonParser;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.deser.SettableAnyProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/UnwrappedPropertyHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/UnwrappedPropertyHandler.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n-\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Object that is responsible for handling acrobatics related to\n  * deserializing \"unwrapped\" values; sets of properties that are\n  * embedded (inlined) as properties of parent JSON object.\n- *\n- * @since 1.9\n  */\n public class UnwrappedPropertyHandler\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ValueInjector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ValueInjector.java\n \n import java.io.IOException;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n  * deserialization of a POJO. Details include information needed to find\n  * injectable value (logical id) as well as method used for assigning\n  * value (setter or field)\n- * \n- * @since 1.9\n  */\n public class ValueInjector\n     extends BeanProperty.Std\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CalendarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CalendarDeserializer.java\n import java.util.Calendar;\n import java.util.Date;\n \n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonProcessingException;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n \n import java.io.IOException;\n \n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n \n-/**\n- * \n- * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.StdDeserializer#ClassDeserializer')\n- */\n @JacksonStdImpl\n public class ClassDeserializer\n     extends StdScalarDeserializer<Class<?>>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import java.io.IOException;\n import java.lang.reflect.Method;\n \n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n import java.io.IOException;\n import java.util.*;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n import java.util.*;\n import java.util.regex.Pattern;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n import java.math.BigInteger;\n import java.util.*;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonToken;\n-import org.codehaus.jackson.io.NumberInput;\n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n  * Base class for common deserializers. Contains shared\n  * base functionality for dealing with primitive values, such\n  * as (re)parsing from String.\n- * \n- * @since 1.9 (moved from higher-level package)\n  */\n public abstract class StdDeserializer<T>\n     extends JsonDeserializer<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import java.lang.reflect.Method;\n import java.util.UUID;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.io.NumberInput;\n-\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n \n import java.io.IOException;\n \n-import org.codehaus.jackson.*;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/TimestampDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TimestampDeserializer.java\n import java.io.IOException;\n import java.sql.Timestamp;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n  * One way to customize Timestamp formats accepted is to override method\n  * {@link DeserializationContext#parseDate} that this basic\n  * deserializer calls.\n- *\n- * @since 1.9 (moved from higher-level package)\n  */\n public class TimestampDeserializer\n     extends StdScalarDeserializer<Timestamp>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n \n import java.io.IOException;\n \n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.util.TokenBuffer;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * We also want to directly support deserialization of\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.io.IOException;\n import java.util.*;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n import javax.xml.datatype.XMLGregorianCalendar;\n import javax.xml.namespace.QName;\n \n-import org.codehaus.jackson.JsonGenerationException;\n-import org.codehaus.jackson.JsonGenerator;\n-import org.codehaus.jackson.JsonNode;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n  * Note: since many of classes defined are abstract, caller must take\n  * care not to just use straight equivalency check but rather consider\n  * subclassing as well.\n- *\n- * @since 1.4\n  */\n public class CoreXMLSerializers\n     implements Provider<Map.Entry<Class<?>,JsonSerializer<?>>>\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n-import org.codehaus.jackson.*;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public static class DateMidnightDeserializer\n         extends JodaDeserializer<DateMidnight>\n     {\n         }\n     }\n \n-    /**\n-     * @since 1.9.2\n-     */\n     public static class PeriodDeserializer\n         extends JodaDeserializer<ReadablePeriod>\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n-import org.codehaus.jackson.*;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n import java.util.Collection;\n import java.util.Map;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n         }\n         return results;\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Deprecated methods from BeanDescription\n-    /**********************************************************\n-     */\n-    \n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public LinkedHashMap<String,AnnotatedMethod> findGetters(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties)\n-    {\n-        LinkedHashMap<String,AnnotatedMethod> results = new LinkedHashMap<String,AnnotatedMethod>();\n-        for (BeanPropertyDefinition property : _properties) {\n-            AnnotatedMethod m = property.getGetter();\n-            if (m != null) {\n-                String name = property.getName();\n-                if (ignoredProperties != null) {\n-                    if (ignoredProperties.contains(name)) {\n-                        continue;\n-                    }\n-                }\n-                results.put(name, m);\n-            }\n-        }\n-        return results;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public LinkedHashMap<String,AnnotatedMethod> findSetters(VisibilityChecker<?> visibilityChecker)\n-    {\n-        LinkedHashMap<String,AnnotatedMethod> results = new LinkedHashMap<String,AnnotatedMethod>();\n-        for (BeanPropertyDefinition property : _properties) {\n-            AnnotatedMethod m = property.getSetter();\n-            if (m != null) {\n-                results.put(property.getName(), m);\n-            }\n-        }\n-        return results;\n-    }\n-    \n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public LinkedHashMap<String,AnnotatedField> findSerializableFields(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties)\n-    {\n-        return _findPropertyFields(ignoredProperties, true);\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public LinkedHashMap<String,AnnotatedField> findDeserializableFields(VisibilityChecker<?> visibilityChecker,\n-            Collection<String> ignoredProperties)\n-    {\n-        return _findPropertyFields(ignoredProperties, false);\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n \n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.util.*;\n \n import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n \n public class BasicClassIntrospector\n     extends ClassIntrospector<BasicBeanDescription>\n         LONG_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(Long.TYPE), ac);\n     }\n \n-    \n     // // // Then static filter singletons\n     \n-    /**\n-     * @since 1.8\n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public final static GetterMethodFilter DEFAULT_GETTER_FILTER = new GetterMethodFilter();\n-\n-    /**\n-     * @since 1.8\n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public final static SetterMethodFilter DEFAULT_SETTER_FILTER = new SetterMethodFilter();\n-\n-    /**\n-     * @since 1.8\n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public final static SetterAndGetterMethodFilter DEFAULT_SETTER_AND_GETTER_FILTER = new SetterAndGetterMethodFilter();\n-\n     protected final static MethodFilter MINIMAL_FILTER = new MinimalMethodFilter();\n     \n     /*\n             return LONG_DESC;\n         }\n         return null;\n-    }\n-    \n-    /**\n-     * Helper method for getting access to filter that only guarantees\n-     * that methods used for serialization are to be included.\n-     * \n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    protected MethodFilter getSerializationMethodFilter(SerializationConfig cfg)\n-    {\n-    \treturn DEFAULT_GETTER_FILTER;\n-    }\n-\n-    /**\n-     * Helper method for getting access to filter that only guarantees\n-     * that methods used for deserialization are to be included.\n-     * \n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    protected MethodFilter getDeserializationMethodFilter(DeserializationConfig cfg)\n-    {\n-        /* [JACKSON-88]: may also need to include getters (at least for\n-         * Collection and Map types)\n-         */\n-        if (cfg.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n-            return DEFAULT_SETTER_AND_GETTER_FILTER;\n-            \n-        }\n-    \treturn DEFAULT_SETTER_FILTER;\n     }\n \n     /*\n             return (pcount <= 2);\n         }\n     }\n-    \n-    /**\n-     * Filter used to only include methods that have signature that is\n-     * compatible with \"getters\": take no arguments, are non-static,\n-     * and return something.\n-     * \n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public static class GetterMethodFilter\n-        implements MethodFilter\n-    {\n-        private GetterMethodFilter() { }\n-    \n-        @Override\n-        public boolean includeMethod(Method m)\n-        {\n-            return ClassUtil.hasGetterSignature(m);\n-        }\n-    }\n-\n-    /**\n-     * Filter used to only include methods that have signature that is\n-     * compatible with \"setters\": take one and only argument and\n-     * are non-static.\n-     *<p>\n-     * Actually, also need to include 2-arg  methods to support\n-     * \"any setters\"; as well as 0-arg getters as long as they\n-     * return Collection or Map type.\n-     * \n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public static class SetterMethodFilter\n-        implements MethodFilter\n-    {\n-        @Override\n-        public boolean includeMethod(Method m)\n-        {\n-            // First: we can't use static methods\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                return false;\n-            }\n-            int pcount = m.getParameterTypes().length;\n-            // Ok; multiple acceptable parameter counts:\n-            switch (pcount) {\n-            case 1:\n-                // Regular setters take just one param, so include:\n-                return true;\n-            case 2:\n-                /* 2-arg version only for \"AnySetters\"; they are not\n-                 * auto-detected, and need to have an annotation.\n-                 * However, due to annotation inheritance we do, we\n-                 * don't yet know if sub-classes might have annotations...\n-                 * so shouldn't leave out any methods quite yet.\n-                 */\n-                //if (m.getAnnotation(JsonAnySetter.class) != null) { ... }\n-\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-    \n-    /**\n-     * Filter used if some getters (namely, once needed for \"setterless\n-     * collection injection\") are also needed, not just setters.\n-     * \n-     * @deprecated Since 1.9 just don't use\n-     */\n-    @Deprecated\n-    public final static class SetterAndGetterMethodFilter\n-        extends SetterMethodFilter\n-    {\n-        @SuppressWarnings(\"deprecation\")\n-        @Override\n-        public boolean includeMethod(Method m)\n-        {\n-            if (super.includeMethod(m)) {\n-                return true;\n-            }\n-            if (!ClassUtil.hasGetterSignature(m)) {\n-                return false;\n-            }\n-            // but furthermore, only accept Collections & Maps, for now\n-            Class<?> rt = m.getReturnType();\n-            if (Collection.class.isAssignableFrom(rt)\n-                || Map.class.isAssignableFrom(rt)) {\n-                return true; \n-            }\n-            return false;\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.codehaus.jackson.annotate.*;\n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.*;\n     @Override\n     public Object findSerializer(Annotated a)\n     {\n-        /* 21-May-2009, tatu: Slight change; primary annotation is now\n-         *    @JsonSerialize; @JsonUseSerializer is deprecated\n-         */\n         JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.using();\n         return null;\n     }\n     \n-    @SuppressWarnings(\"deprecation\")\n     @Override\n     public JsonSerialize.Inclusion findSerializationInclusion(Annotated a, JsonSerialize.Inclusion defValue)\n     {\n         JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n         if (ann != null) {\n             return ann.include();\n-        }\n-        /* 23-May-2009, tatu: Will still support now-deprecated (as of 1.1)\n-         *   legacy annotation too:\n-         */\n-        JsonWriteNullProperties oldAnn = a.getAnnotation(JsonWriteNullProperties.class);\n-        if (oldAnn != null) {\n-            boolean writeNulls = oldAnn.value();\n-            return writeNulls ? JsonSerialize.Inclusion.ALWAYS : JsonSerialize.Inclusion.NON_NULL;\n         }\n         return defValue;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n \n import java.lang.annotation.Annotation;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.BeanUtil;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n package com.fasterxml.jackson.databind.introspect;\n-\n-import org.codehaus.jackson.annotate.JsonAutoDetect;\n-import org.codehaus.jackson.annotate.JsonAutoDetect.Visibility;\n-import org.codehaus.jackson.annotate.JsonMethod;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Member;\n import java.lang.reflect.Method;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n /**\n  * Interface for object used for determine which property elements\n  *<p>\n  * Note on type declaration: funky recursive type is necessary to\n  * support builder/fluent pattern.\n- *<p>\n- * Note on compatibility: 1.9 introduced overloaded \"with\" method\n- * (which takes {@link Visibility} as value to assign); which could\n- * be potential issue, but assumption here is that all custom implementations\n- * are based on \"Std\" base class\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public interface VisibilityChecker<T extends VisibilityChecker<T>>\n {\n      *     mapper.getVisibilityChecker().with(Visibility.NONE));\n      *</pre>\n      * (which would basically disable all auto-detection)\n-     *\n-     * @since 1.9\n      */\n     public T with(Visibility v);\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.core.util.JsonParserSequence;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Type deserializer used with {@link As#PROPERTY}\n  * {@link As#WRAPPER_ARRAY} works.\n  * Latter is used if JSON representation is polymorphic\n  * \n- * @since 1.5\n  * @author tatu\n  */\n public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n-import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/MinimalClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/MinimalClassNameIdResolver.java\n package com.fasterxml.jackson.databind.jsontype.impl;\n \n-import org.codehaus.jackson.type.JavaType;\n-import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n-\n \n /**\n  * Default {@link TypeResolverBuilder} implementation.\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n package com.fasterxml.jackson.databind.jsontype.impl;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.annotate.JsonTypeInfo;\n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n import java.lang.reflect.Modifier;\n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.AbstractTypeResolver;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.JsonNode;\n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.*;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.ClassKey;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.codehaus.jackson.Version;\n+import com.fasterxml.jackson.core.Version;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.ArrayType;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.type.JavaType;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumValues;\n-\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Factory class that can provide serializers for standard JDK classes,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n \n import java.util.*;\n \n-import org.codehaus.jackson.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n-import org.codehaus.jackson.JsonGenerationException;\n-import org.codehaus.jackson.JsonGenerator;\n-import org.codehaus.jackson.JsonNode;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.TypeSerializer;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * We also want to directly support serialization of {@link TokenBuffer};\n  * and since it is part of core package, it can not implement\n  * {@link com.fasterxml.jackson.databind.JsonSerializable}\n  * (which is only included in the mapper package)\n- *\n- * @since 1.5\n  */\n @JacksonStdImpl\n public class TokenBufferSerializer\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.json.JsonReadContext;\n+import com.fasterxml.jackson.core.json.JsonWriteContext;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+\n+/**\n+ * Utility class used for efficient storage of {@link JsonToken}\n+ * sequences, needed for temporary buffering.\n+ * Space efficient for different sequence lengths (especially so for smaller\n+ * ones; but not significantly less efficient for larger), highly efficient\n+ * for linear iteration and appending. Implemented as segmented/chunked\n+ * linked list of tokens; only modifications are via appends.\n+ *<p>\n+ * Note that before version 2.0, this class was located in the \"core\"\n+ * bundle, not data-binding; but since it was only used by data binding,\n+ * was moved here to reduce size of core package\n+ */\n+public class TokenBuffer\n+/* Won't use JsonGeneratorBase, to minimize overhead for validity\n+ * checking\n+ */\n+    extends JsonGenerator\n+{\n+    protected final static int DEFAULT_PARSER_FEATURES = JsonParser.Feature.collectDefaults();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     */\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * are enabled.\n+     *<p>\n+     * NOTE: most features have no effect on this class\n+     */\n+    protected int _generatorFeatures;\n+\n+    protected boolean _closed;\n+    \n+    /*\n+    /**********************************************************\n+    /* Token buffering state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First segment, for contents this buffer has\n+     */\n+    protected Segment _first;\n+\n+    /**\n+     * Last segment of this buffer, one that is used\n+     * for appending more tokens\n+     */\n+    protected Segment _last;\n+    \n+    /**\n+     * Offset within last segment, \n+     */\n+    protected int _appendOffset;\n+\n+    /*\n+    /**********************************************************\n+    /* Output state\n+    /**********************************************************\n+     */\n+\n+    protected JsonWriteContext _writeContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param codec Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     */\n+    public TokenBuffer(ObjectCodec codec)\n+    {\n+        _objectCodec = codec;\n+        _generatorFeatures = DEFAULT_PARSER_FEATURES;\n+        _writeContext = JsonWriteContext.createRootContext();\n+        // at first we have just one segment\n+        _first = _last = new Segment();\n+        _appendOffset = 0;\n+    }\n+    \n+    /**\n+     * Method used to create a {@link JsonParser} that can read contents\n+     * stored in this buffer. Will use default <code>_objectCodec</code> for\n+     * object conversions.\n+     *<p>\n+     * Note: instances are not synchronized, that is, they are not thread-safe\n+     * if there are concurrent appends to the underlying buffer.\n+     * \n+     * @return Parser that can be used for reading contents stored in this buffer\n+     */\n+    public JsonParser asParser()\n+    {\n+        return asParser(_objectCodec);\n+    }\n+\n+    /**\n+     * Method used to create a {@link JsonParser} that can read contents\n+     * stored in this buffer.\n+     *<p>\n+     * Note: instances are not synchronized, that is, they are not thread-safe\n+     * if there are concurrent appends to the underlying buffer.\n+     *\n+     * @param codec Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     * \n+     * @return Parser that can be used for reading contents stored in this buffer\n+     */\n+    public JsonParser asParser(ObjectCodec codec)\n+    {\n+        return new Parser(_first, codec);\n+    }\n+\n+    /**\n+     * @param src Parser to use for accessing source information\n+     *    like location, configured codec\n+     */\n+    public JsonParser asParser(JsonParser src)\n+    {\n+        Parser p = new Parser(_first, src.getCodec());\n+        p.setLocation(src.getTokenLocation());\n+        return p;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other custom methods not needed for implementing interfaces\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that will write all contents of this buffer\n+     * using given {@link JsonGenerator}.\n+     *<p>\n+     * Note: this method would be enough to implement\n+     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n+     * but we can not have upwards\n+     * references (from core to mapper package); and as such we also\n+     * can not take second argument.\n+     */\n+    public void serialize(JsonGenerator jgen)\n+        throws IOException, JsonGenerationException\n+    {\n+        Segment segment = _first;\n+        int ptr = -1;\n+\n+        while (true) {\n+            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n+                ptr = 0;\n+                segment = segment.next();\n+                if (segment == null) break;\n+            }\n+            JsonToken t = segment.type(ptr);\n+            if (t == null) break;\n+\n+            // Note: copied from 'copyCurrentEvent'...\n+            switch (t) {\n+            case START_OBJECT:\n+                jgen.writeStartObject();\n+                break;\n+            case END_OBJECT:\n+                jgen.writeEndObject();\n+                break;\n+            case START_ARRAY:\n+                jgen.writeStartArray();\n+                break;\n+            case END_ARRAY:\n+                jgen.writeEndArray();\n+                break;\n+            case FIELD_NAME:\n+            {\n+                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n+                Object ob = segment.get(ptr);\n+                if (ob instanceof SerializableString) {\n+                    jgen.writeFieldName((SerializableString) ob);\n+                } else {\n+                    jgen.writeFieldName((String) ob);\n+                }\n+            }\n+                break;\n+            case VALUE_STRING:\n+                {\n+                    Object ob = segment.get(ptr);\n+                    if (ob instanceof SerializableString) {\n+                        jgen.writeString((SerializableString) ob);\n+                    } else {\n+                        jgen.writeString((String) ob);\n+                    }\n+                }\n+                break;\n+            case VALUE_NUMBER_INT:\n+                {\n+                    Number n = (Number) segment.get(ptr);\n+                    if (n instanceof BigInteger) {\n+                        jgen.writeNumber((BigInteger) n);\n+                    } else if (n instanceof Long) {\n+                        jgen.writeNumber(n.longValue());\n+                    } else {\n+                        jgen.writeNumber(n.intValue());\n+                    }\n+                }\n+                break;\n+            case VALUE_NUMBER_FLOAT:\n+                {\n+                    Object n = segment.get(ptr);\n+                    if (n instanceof BigDecimal) {\n+                        jgen.writeNumber((BigDecimal) n);\n+                    } else if (n instanceof Float) {\n+                        jgen.writeNumber(((Float) n).floatValue());\n+                    } else if (n instanceof Double) {\n+                        jgen.writeNumber(((Double) n).doubleValue());\n+                    } else if (n == null) {\n+                        jgen.writeNull();\n+                    } else if (n instanceof String) {\n+                        jgen.writeNumber((String) n);\n+                    } else {\n+                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n+                    }\n+                }\n+                break;\n+            case VALUE_TRUE:\n+                jgen.writeBoolean(true);\n+                break;\n+            case VALUE_FALSE:\n+                jgen.writeBoolean(false);\n+                break;\n+            case VALUE_NULL:\n+                jgen.writeNull();\n+                break;\n+            case VALUE_EMBEDDED_OBJECT:\n+                jgen.writeObject(segment.get(ptr));\n+                break;\n+            default:\n+                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        // Let's print up to 100 first tokens...\n+        final int MAX_COUNT = 100;\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[TokenBuffer: \");\n+        JsonParser jp = asParser();\n+        int count = 0;\n+\n+        while (true) {\n+            JsonToken t;\n+            try {\n+                t = jp.nextToken();\n+            } catch (IOException ioe) { // should never occur\n+                throw new IllegalStateException(ioe);\n+            }\n+            if (t == null) break;\n+            if (count < MAX_COUNT) {\n+                if (count > 0) {\n+                    sb.append(\", \");\n+                }\n+                sb.append(t.toString());\n+            }\n+            ++count;\n+        }\n+\n+        if (count >= MAX_COUNT) {\n+            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+        \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: configuration\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonGenerator enable(Feature f) {\n+        _generatorFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator disable(Feature f) {\n+        _generatorFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    //public JsonGenerator configure(Feature f, boolean state) { }\n+\n+    @Override\n+    public boolean isEnabled(Feature f) {\n+        return (_generatorFeatures & f.getMask()) != 0;\n+    }\n+\n+    @Override\n+    public JsonGenerator useDefaultPrettyPrinter() {\n+        // No-op: we don't indent\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator setCodec(ObjectCodec oc) {\n+        _objectCodec = oc;\n+        return this;\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() { return _objectCodec; }\n+\n+    @Override\n+    public final JsonWriteContext getOutputContext() { return _writeContext; }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void flush() throws IOException { /* NOP */ }\n+\n+    @Override\n+    public void close() throws IOException {\n+        _closed = true;\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.START_ARRAY);\n+        _writeContext = _writeContext.createChildArrayContext();\n+    }\n+\n+    @Override\n+    public final void writeEndArray()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.END_ARRAY);\n+        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n+        JsonWriteContext c = _writeContext.getParent();\n+        if (c != null) {\n+            _writeContext = c;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeStartObject()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.START_OBJECT);\n+        _writeContext = _writeContext.createChildObjectContext();\n+    }\n+\n+    @Override\n+    public final void writeEndObject()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.END_OBJECT);\n+        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n+        JsonWriteContext c = _writeContext.getParent();\n+        if (c != null) {\n+            _writeContext = c;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeFieldName(String name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name);\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name.getValue());\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name.getValue());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException {\n+        if (text == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_STRING, text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        writeString(new String(text, offset, len));\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        if (text == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_STRING, text);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, primitive types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(int i) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n+    }\n+\n+    @Override\n+    public void writeNumber(long l) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n+    }\n+\n+    @Override\n+    public void writeNumber(double d) throws IOException,JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n+    }\n+\n+    @Override\n+    public void writeNumber(float f) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n+        if (dec == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n+        if (v == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_NUMBER_INT, v);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n+        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n+         *   identity as long as possible\n+         */\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n+        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NULL);\n+    }\n+\n+    /*\n+    /***********************************************************\n+    /* JsonGenerator implementation: write methods for POJOs/trees\n+    /***********************************************************\n+     */\n+\n+    @Override\n+    public void writeObject(Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        // embedded means that no conversions should be done...\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n+    }\n+\n+    @Override\n+    public void writeTree(JsonNode rootNode)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 31-Dec-2009, tatu: no need to convert trees either is there?\n+         *  (note: may need to re-evaluate at some point)\n+         */\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, rootNode);\n+    }\n+\n+    /*\n+    /***********************************************************\n+    /* JsonGenerator implementation; binary\n+    /***********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n+         *   now, let's try to limit number of conversions.\n+         *   The only (?) tricky thing is that of whether to preserve variant,\n+         *   seems pointless, so let's not worry about it unless there's some\n+         *   compelling reason to.\n+         */\n+        byte[] copy = new byte[len];\n+        System.arraycopy(data, offset, copy, 0, len);\n+        writeObject(copy);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation; pass-through copy\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case START_OBJECT:\n+            writeStartObject();\n+            break;\n+        case END_OBJECT:\n+            writeEndObject();\n+            break;\n+        case START_ARRAY:\n+            writeStartArray();\n+            break;\n+        case END_ARRAY:\n+            writeEndArray();\n+            break;\n+        case FIELD_NAME:\n+            writeFieldName(jp.getCurrentName());\n+            break;\n+        case VALUE_STRING:\n+            if (jp.hasTextCharacters()) {\n+                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            } else {\n+                writeString(jp.getText());\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            switch (jp.getNumberType()) {\n+            case INT:\n+                writeNumber(jp.getIntValue());\n+                break;\n+            case BIG_INTEGER:\n+                writeNumber(jp.getBigIntegerValue());\n+                break;\n+            default:\n+                writeNumber(jp.getLongValue());\n+            }\n+            break;\n+        case VALUE_NUMBER_FLOAT:\n+            switch (jp.getNumberType()) {\n+            case BIG_DECIMAL:\n+                writeNumber(jp.getDecimalValue());\n+                break;\n+            case FLOAT:\n+                writeNumber(jp.getFloatValue());\n+                break;\n+            default:\n+                writeNumber(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            writeBoolean(true);\n+            break;\n+        case VALUE_FALSE:\n+            writeBoolean(false);\n+            break;\n+        case VALUE_NULL:\n+            writeNull();\n+            break;\n+        case VALUE_EMBEDDED_OBJECT:\n+            writeObject(jp.getEmbeddedObject());\n+            break;\n+        default:\n+            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n+        }\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+        JsonToken t = jp.getCurrentToken();\n+\n+        // Let's handle field-name separately first\n+        if (t == JsonToken.FIELD_NAME) {\n+            writeFieldName(jp.getCurrentName());\n+            t = jp.nextToken();\n+            // fall-through to copy the associated value\n+        }\n+\n+        switch (t) {\n+        case START_ARRAY:\n+            writeStartArray();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndArray();\n+            break;\n+        case START_OBJECT:\n+            writeStartObject();\n+            while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndObject();\n+            break;\n+        default: // others are simple:\n+            copyCurrentEvent(jp);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    protected final void _append(JsonToken type) {\n+        Segment next = _last.append(_appendOffset, type);\n+        if (next == null) {\n+            ++_appendOffset;\n+        } else {\n+            _last = next;\n+            _appendOffset = 1; // since we added first at 0\n+        }\n+    }\n+\n+    protected final void _append(JsonToken type, Object value) {\n+        Segment next = _last.append(_appendOffset, type, value);\n+        if (next == null) {\n+            ++_appendOffset;\n+        } else {\n+            _last = next;\n+            _appendOffset = 1;\n+        }\n+    }\n+    \n+    protected void _reportUnsupportedOperation() {\n+        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Supporting classes\n+    /**********************************************************\n+     */\n+\n+    protected final static class Parser\n+        extends ParserMinimalBase\n+    {\n+        protected ObjectCodec _codec;\n+\n+        /*\n+        /**********************************************************\n+        /* Parsing state\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Currently active segment\n+         */\n+        protected Segment _segment;\n+\n+        /**\n+         * Pointer to current token within current segment\n+         */\n+        protected int _segmentPtr;\n+\n+        /**\n+         * Information about parser context, context in which\n+         * the next token is to be parsed (root, array, object).\n+         */\n+        protected JsonReadContext _parsingContext;\n+        \n+        protected boolean _closed;\n+\n+        protected transient ByteArrayBuilder _byteBuilder;\n+\n+        protected JsonLocation _location = null;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction, init\n+        /**********************************************************\n+         */\n+        \n+        public Parser(Segment firstSeg, ObjectCodec codec)\n+        {\n+            super(0);\n+            _segment = firstSeg;\n+            _segmentPtr = -1; // not yet read\n+            _codec = codec;\n+            _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+        }\n+\n+        public void setLocation(JsonLocation l) {\n+            _location = l;\n+        }\n+        \n+        @Override\n+        public ObjectCodec getCodec() { return _codec; }\n+\n+        @Override\n+        public void setCodec(ObjectCodec c) { _codec = c; }\n+\n+        /*\n+        /**********************************************************\n+        /* Extended API beyond JsonParser\n+        /**********************************************************\n+         */\n+        \n+        public JsonToken peekNextToken()\n+            throws IOException, JsonParseException\n+        {\n+            // closed? nothing more to peek, either\n+            if (_closed) return null;\n+            Segment seg = _segment;\n+            int ptr = _segmentPtr+1;\n+            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n+                ptr = 0;\n+                seg = (seg == null) ? null : seg.next();\n+            }\n+            return (seg == null) ? null : seg.type(ptr);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Closeable implementation\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (!_closed) {\n+                _closed = true;\n+            }\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, traversal\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public JsonToken nextToken() throws IOException, JsonParseException\n+        {\n+            // If we are closed, nothing more to do\n+            if (_closed || (_segment == null)) return null;\n+\n+            // Ok, then: any more tokens?\n+            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n+                _segmentPtr = 0;\n+                _segment = _segment.next();\n+                if (_segment == null) {\n+                    return null;\n+                }\n+            }\n+            _currToken = _segment.type(_segmentPtr);\n+            // Field name? Need to update context\n+            if (_currToken == JsonToken.FIELD_NAME) {\n+                Object ob = _currentObject();\n+                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n+                _parsingContext.setCurrentName(name);\n+            } else if (_currToken == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+            } else if (_currToken == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            } else if (_currToken == JsonToken.END_OBJECT\n+                    || _currToken == JsonToken.END_ARRAY) {\n+                // Closing JSON Object/Array? Close matching context\n+                _parsingContext = _parsingContext.getParent();\n+                // but allow unbalanced cases too (more close markers)\n+                if (_parsingContext == null) {\n+                    _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+                }\n+            }\n+            return _currToken;\n+        }\n+\n+        @Override\n+        public boolean isClosed() { return _closed; }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, token accessors\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public JsonStreamContext getParsingContext() { return _parsingContext; }\n+\n+        @Override\n+        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n+\n+        @Override\n+        public JsonLocation getCurrentLocation() {\n+            return (_location == null) ? JsonLocation.NA : _location;\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, text\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public String getText()\n+        {\n+            // common cases first:\n+            if (_currToken == JsonToken.VALUE_STRING\n+                    || _currToken == JsonToken.FIELD_NAME) {\n+                Object ob = _currentObject();\n+                if (ob instanceof String) {\n+                    return (String) ob;\n+                }\n+                return (ob == null) ? null : ob.toString();\n+            }\n+            if (_currToken == null) {\n+                return null;\n+            }\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                Object ob = _currentObject();\n+                return (ob == null) ? null : ob.toString();\n+            }\n+            return _currToken.asString();\n+        }\n+\n+        @Override\n+        public char[] getTextCharacters() {\n+            String str = getText();\n+            return (str == null) ? null : str.toCharArray();\n+        }\n+\n+        @Override\n+        public int getTextLength() {\n+            String str = getText();\n+            return (str == null) ? 0 : str.length();\n+        }\n+\n+        @Override\n+        public int getTextOffset() { return 0; }\n+\n+        @Override\n+        public boolean hasTextCharacters() {\n+            // We never have raw buffer available, so:\n+            return false;\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, numeric\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof BigInteger) {\n+                return (BigInteger) n;\n+            }\n+            switch (getNumberType()) {\n+            case BIG_DECIMAL:\n+                return ((BigDecimal) n).toBigInteger();\n+            }\n+            // int/long is simple, but let's also just truncate float/double:\n+            return BigInteger.valueOf(n.longValue());\n+        }\n+\n+        @Override\n+        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof BigDecimal) {\n+                return (BigDecimal) n;\n+            }\n+            switch (getNumberType()) {\n+            case INT:\n+            case LONG:\n+                return BigDecimal.valueOf(n.longValue());\n+            case BIG_INTEGER:\n+                return new BigDecimal((BigInteger) n);\n+            }\n+            // float or double\n+            return BigDecimal.valueOf(n.doubleValue());\n+        }\n+\n+        @Override\n+        public double getDoubleValue() throws IOException, JsonParseException {\n+            return getNumberValue().doubleValue();\n+        }\n+\n+        @Override\n+        public float getFloatValue() throws IOException, JsonParseException {\n+            return getNumberValue().floatValue();\n+        }\n+\n+        @Override\n+        public int getIntValue() throws IOException, JsonParseException\n+        {\n+            // optimize common case:\n+            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+                return ((Number) _currentObject()).intValue();\n+            }\n+            return getNumberValue().intValue();\n+        }\n+\n+        @Override\n+        public long getLongValue() throws IOException, JsonParseException {\n+            return getNumberValue().longValue();\n+        }\n+\n+        @Override\n+        public NumberType getNumberType() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof Integer) return NumberType.INT;\n+            if (n instanceof Long) return NumberType.LONG;\n+            if (n instanceof Double) return NumberType.DOUBLE;\n+            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n+            if (n instanceof Float) return NumberType.FLOAT;\n+            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n+            return null;\n+        }\n+\n+        @Override\n+        public final Number getNumberValue() throws IOException, JsonParseException {\n+            _checkIsNumber();\n+            return (Number) _currentObject();\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, other\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public Object getEmbeddedObject()\n+        {\n+            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                return _currentObject();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n+        {\n+            // First: maybe we some special types?\n+            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                // Embedded byte array would work nicely...\n+                Object ob = _currentObject();\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n+                // fall through to error case\n+            }\n+            if (_currToken != JsonToken.VALUE_STRING) {\n+                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n+            }\n+            final String str = getText();\n+            if (str == null) {\n+                return null;\n+            }\n+            ByteArrayBuilder builder = _byteBuilder;\n+            if (builder == null) {\n+                _byteBuilder = builder = new ByteArrayBuilder(100);\n+            }\n+            _decodeBase64(str, builder, b64variant);\n+            return builder.toByteArray();\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Internal methods\n+        /**********************************************************\n+         */\n+\n+        protected final Object _currentObject() {\n+            return _segment.get(_segmentPtr);\n+        }\n+\n+        protected final void _checkIsNumber() throws JsonParseException\n+        {\n+            if (_currToken == null || !_currToken.isNumeric()) {\n+                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n+            }\n+        }\n+\n+        @Override\n+        protected void _handleEOF() throws JsonParseException {\n+            _throwInternal();\n+        }\n+    }\n+    \n+    /**\n+     * Individual segment of TokenBuffer that can store up to 16 tokens\n+     * (limited by 4 bits per token type marker requirement).\n+     * Current implementation uses fixed length array; could alternatively\n+     * use 16 distinct fields and switch statement (slightly more efficient\n+     * storage, slightly slower access)\n+     */\n+    protected final static class Segment \n+    {\n+        public final static int TOKENS_PER_SEGMENT = 16;\n+        \n+        /**\n+         * Static array used for fast conversion between token markers and\n+         * matching {@link JsonToken} instances\n+         */\n+        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n+        static {\n+            // ... here we know that there are <= 16 values in JsonToken enum\n+            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n+            JsonToken[] t = JsonToken.values();\n+            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n+        }\n+\n+        // // // Linking\n+        \n+        protected Segment _next;\n+        \n+        // // // State\n+\n+        /**\n+         * Bit field used to store types of buffered tokens; 4 bits per token.\n+         * Value 0 is reserved for \"not in use\"\n+         */\n+        protected long _tokenTypes;\n+\n+        \n+        // Actual tokens\n+\n+        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n+\n+        public Segment() { }\n+\n+        // // // Accessors\n+\n+        public JsonToken type(int index)\n+        {\n+            long l = _tokenTypes;\n+            if (index > 0) {\n+                l >>= (index << 2);\n+            }\n+            int ix = ((int) l) & 0xF;\n+            return TOKEN_TYPES_BY_INDEX[ix];\n+        }\n+        \n+        public Object get(int index) {\n+            return _tokens[index];\n+        }\n+\n+        public Segment next() { return _next; }\n+        \n+        // // // Mutators\n+\n+        public Segment append(int index, JsonToken tokenType)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType);\n+            return _next;\n+        }\n+\n+        public Segment append(int index, JsonToken tokenType, Object value)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType, value);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType, value);\n+            return _next;\n+        }\n+        \n+        public void set(int index, JsonToken tokenType)\n+        {\n+            long typeCode = tokenType.ordinal();\n+            /* Assumption here is that there are no overwrites, just appends;\n+             * and so no masking is needed\n+             */\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+        }\n+\n+        public void set(int index, JsonToken tokenType, Object value)\n+        {\n+            _tokens[index] = value;\n+            long typeCode = tokenType.ordinal();\n+            /* Assumption here is that there are no overwrites, just appends;\n+             * and so no masking is needed\n+             */\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+        }\n+    }\n+}", "timestamp": 1324658316, "metainfo": ""}