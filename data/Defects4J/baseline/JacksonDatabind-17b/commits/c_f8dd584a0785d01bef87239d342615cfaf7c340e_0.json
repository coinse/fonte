{"sha": "f8dd584a0785d01bef87239d342615cfaf7c340e", "log": "Rewrote [Issue#15] implementation to work with datatypes that require custom mapper (like XML)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.format.DataFormatDetector;\n-import com.fasterxml.jackson.core.format.DataFormatMatcher;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.deser.DataFormatReaders;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n      * \n      * @since 2.1\n      */\n-    protected final DataFormatDetector _dataFormatDetector;\n+    protected final DataFormatReaders _dataFormatReaders;\n     \n     /*\n     /**********************************************************\n         _unwrapRoot = config.useRootWrapping();\n \n         _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n-        _dataFormatDetector = null;        \n+        _dataFormatReaders = null;        \n     }\n     \n     /**\n     protected ObjectReader(ObjectReader base, DeserializationConfig config,\n             JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n             FormatSchema schema, InjectableValues injectableValues,\n-            DataFormatDetector dataFormatDetector)\n+            DataFormatReaders dataFormatReaders)\n     {\n         _config = config;\n         _context = base._context;\n         _schema = schema;\n         _injectableValues = injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n-        _dataFormatDetector = dataFormatDetector;\n+        _dataFormatReaders = dataFormatReaders;\n     }\n \n     /**\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n-        _dataFormatDetector = base._dataFormatDetector;\n+        _dataFormatReaders = base._dataFormatReaders;\n     }\n \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n         _unwrapRoot = base._unwrapRoot;\n-        _dataFormatDetector = base._dataFormatDetector;\n+        _dataFormatReaders = base._dataFormatReaders;\n     }\n     \n     /**\n     /**********************************************************\n      */\n \n+    public ObjectReader with(DeserializationConfig config) {\n+        return _with(config);\n+    }    \n+    \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n         }\n         return new ObjectReader(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n-                _schema, injectableValues, _dataFormatDetector);\n+                _schema, injectableValues, _dataFormatReaders);\n     }\n \n     /**\n             return this;\n         }\n         return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n-                schema, _injectableValues, _dataFormatDetector);\n-    }\n-    \n+                schema, _injectableValues, _dataFormatReaders);\n+    }\n+\n     /**\n      * Method for constructing a new reader instance that is configured\n      * to data bind into specified type.\n      */\n     public ObjectReader withType(JavaType valueType)\n     {\n-        if (valueType != null && valueType.equals(_valueType)) return this;\n+        if (valueType != null && valueType.equals(_valueType)) {\n+            return this;\n+        }\n         JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n         // type is stored here, no need to make a copy of config\n-        return new ObjectReader(this, _config, valueType, rootDeser, _valueToUpdate,\n-                _schema, _injectableValues, _dataFormatDetector);\n+        DataFormatReaders det = _dataFormatReaders;\n+        if (det != null) {\n+            det = det.withType(valueType);\n+        }\n+        return new ObjectReader(this, _config, valueType, rootDeser,\n+                _valueToUpdate, _schema, _injectableValues, det);\n     }    \n \n     /**\n             t = _valueType;\n         }\n         return new ObjectReader(this, _config, t, _rootDeserializer, value,\n-                _schema, _injectableValues, _dataFormatDetector);\n+                _schema, _injectableValues, _dataFormatReaders);\n     }\n \n     /**\n     /**\n      * Fluent factory method for constructing a reader that will try to\n      * auto-detect underlying data format, using specified list of\n-     * {@link JsonFactory} instances, and default {@link DataFormatDetector} settings\n-     * (for customized {@link DataFormatDetector}, you can construct instance yourself).\n+     * {@link JsonFactory} instances, and default {@link DataFormatReaders} settings\n+     * (for customized {@link DataFormatReaders}, you can construct instance yourself).\n      * to construct appropriate {@link JsonParser} for actual parsing.\n      *<p>\n-     * NOTE: since format detection only works with byte sources, it is possible to\n+     * Note: since format detection only works with byte sources, it is possible to\n      * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n      * (enough) detected as one of specified types, an exception will be thrown.\n+     *<p>\n+     * Note: not all {@link JsonFactory} types can be passed: specifically, ones that\n+     * require \"custom codec\" (like XML factory) will not work. Instead, use\n+     * method that takes {@link ObjectReader} instances instead of factories.\n      * \n-     * @param factories Data formats accepted, in decreasing order of priority (that is,\n+     * @param readers Data formats accepted, in decreasing order of priority (that is,\n      *   matches checked in listed order, first match wins)\n      * \n      * @return Newly configured writer instance\n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(JsonFactory... factories)\n-    {\n-        return withFormatDetection(new DataFormatDetector(factories));\n+    public ObjectReader withFormatDetection(ObjectReader... readers)\n+    {\n+        return withFormatDetection(new DataFormatReaders(readers));\n     }\n \n     /**\n      * Fluent factory method for constructing a reader that will try to\n      * auto-detect underlying data format, using specified\n-     * {@link DataFormatDetector}.\n+     * {@link DataFormatReaders}.\n      *<p>\n      * NOTE: since format detection only works with byte sources, it is possible to\n      * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n      * (enough) detected as one of specified types, an exception will be thrown.\n      * \n-     * @param detector DataFormatDetector to use for detecting underlying format.\n+     * @param readers DataFormatReaders to use for detecting underlying format.\n      * \n      * @return Newly configured writer instance\n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(DataFormatDetector detector)\n+    public ObjectReader withFormatDetection(DataFormatReaders readers)\n     {\n         return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n-                _schema, _injectableValues, detector);\n+                _schema, _injectableValues, readers);\n     }\n     \n     /*\n     public <T> T readValue(JsonParser jp)\n         throws IOException, JsonProcessingException\n     {\n-        return (T) _bind(jp);\n+        return (T) _bind(jp, _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(InputStream src)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n-            return (T) _bindAndClose(_detect(src));\n-        }\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        if (_dataFormatReaders != null) {\n+            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n+        }\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(Reader src)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n     \n     /**\n     public <T> T readValue(String src)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(byte[] src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser p = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src, 0, src.length);\n-        return (T) _bindAndClose(p);\n+        if (_dataFormatReaders != null) {\n+            return (T) _detectBindAndClose(src, 0, src.length);\n+        }\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(byte[] src, int offset, int length)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser p = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src, offset, length) : _detect(src, offset, length);\n-        return (T) _bindAndClose(p);\n+        if (_dataFormatReaders != null) {\n+            return (T) _detectBindAndClose(src, offset, length);\n+        }\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src, offset, length), _valueToUpdate);\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(File src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser p = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src);\n-        return (T) _bindAndClose(p);\n+        if (_dataFormatReaders != null) {\n+            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n+        }\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(URL src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser p = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src);\n-        return (T) _bindAndClose(p);\n+        if (_dataFormatReaders != null) {\n+            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n+        }\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> T readValue(JsonNode src)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        return (T) _bindAndClose(treeAsTokens(src));\n+        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n     }\n     \n     /**\n     public JsonNode readTree(InputStream in)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser p = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(in) : _detect(in);\n-        return _bindAndCloseAsTree(p);\n+        if (_dataFormatReaders != null) {\n+            return _detectBindAndCloseAsTree(in);\n+        }\n+        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(in));\n     }\n     \n     /**\n     public JsonNode readTree(Reader r)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(r);\n         }\n         return _bindAndCloseAsTree(_jsonFactory.createJsonParser(r));\n     public JsonNode readTree(String json)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n         return _bindAndCloseAsTree(_jsonFactory.createJsonParser(json));\n     public <T> MappingIterator<T> readValues(InputStream src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt, \n-                _findRootDeserializer(ctxt, _valueType),\n-                true, _valueToUpdate);\n-    }\n-\n+        if (_dataFormatReaders != null) {\n+            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n+        }\n+        return _bindAndReadValues(_jsonFactory.createJsonParser(src), _valueToUpdate);\n+    }\n+    \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n      */\n     public <T> MappingIterator<T> readValues(Reader src)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n         JsonParser jp = _jsonFactory.createJsonParser(src);\n     public <T> MappingIterator<T> readValues(String json)\n         throws IOException, JsonProcessingException\n     {\n-        if (_dataFormatDetector != null) {\n+        if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n         JsonParser jp = _jsonFactory.createJsonParser(json);\n     public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src, offset, length) : _detect(src, offset, length);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n+        if (_dataFormatReaders != null) {\n+            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n+        }\n+        return _bindAndReadValues(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> MappingIterator<T> readValues(File src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n+        if (_dataFormatReaders != null) {\n+            return _detectBindAndReadValues(\n+                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n+        }\n+        return _bindAndReadValues(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /**\n     public <T> MappingIterator<T> readValues(URL src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = (_dataFormatDetector == null) ?\n-                _jsonFactory.createJsonParser(src) : _detect(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n+        if (_dataFormatReaders != null) {\n+            return _detectBindAndReadValues(\n+                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n+        }\n+        return _bindAndReadValues(_jsonFactory.createJsonParser(src), _valueToUpdate);\n     }\n \n     /*\n     /**\n      * Actual implementation of value reading+binding operation.\n      */\n-    protected Object _bind(JsonParser jp)\n+    protected Object _bind(JsonParser jp, Object valueToUpdate)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n         /* First: may need to read the next token, to initialize state (either\n         Object result;\n         JsonToken t = _initForReading(jp);\n         if (t == JsonToken.VALUE_NULL) {\n-            if (_valueToUpdate == null) {\n+            if (valueToUpdate == null) {\n                 DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                 result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n             } else {\n-                result = _valueToUpdate;\n+                result = valueToUpdate;\n             }\n         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n-            result = _valueToUpdate;\n+            result = valueToUpdate;\n         } else { // pointing to event other than null\n             DeserializationContext ctxt = createDeserializationContext(jp, _config);\n             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n             if (_unwrapRoot) {\n                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n             } else {\n-                if (_valueToUpdate == null) {\n+                if (valueToUpdate == null) {\n                     result = deser.deserialize(jp, ctxt);\n                 } else {\n-                    deser.deserialize(jp, ctxt, _valueToUpdate);\n-                    result = _valueToUpdate;\n+                    deser.deserialize(jp, ctxt, valueToUpdate);\n+                    result = valueToUpdate;\n                 }\n             }\n         }\n         return result;\n     }\n     \n-    protected Object _bindAndClose(JsonParser jp)\n+    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n         if (_schema != null) {\n             Object result;\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n-                if (_valueToUpdate == null) {\n+                if (valueToUpdate == null) {\n                     DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                     result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                 } else {\n-                    result = _valueToUpdate;\n+                    result = valueToUpdate;\n                 }\n             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n-                result = _valueToUpdate;\n+                result = valueToUpdate;\n             } else {\n                 DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                 JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                 if (_unwrapRoot) {\n                     result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                 } else {\n-                    if (_valueToUpdate == null) {\n+                    if (valueToUpdate == null) {\n                         result = deser.deserialize(jp, ctxt);\n                     } else {\n-                        deser.deserialize(jp, ctxt, _valueToUpdate);\n-                        result = _valueToUpdate;                    \n+                        deser.deserialize(jp, ctxt, valueToUpdate);\n+                        result = valueToUpdate;                    \n                     }\n                 }\n             }\n                 jp.close();\n             } catch (IOException ioe) { }\n         }\n+    }\n+    \n+    /**\n+     * @since 2.1\n+     */\n+    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p,\n+            Object valueToUpdate)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return new MappingIterator<T>(_valueType, p, ctxt, \n+                _findRootDeserializer(ctxt, _valueType),\n+                true, _valueToUpdate);\n     }\n     \n     protected static JsonToken _initForReading(JsonParser jp)\n     /**********************************************************\n      */\n     \n-    protected JsonParser _detect(InputStream in) throws IOException {\n-        return _detectAndCreateParser(_dataFormatDetector.findFormat(in), false);\n-    }\n-\n-    protected JsonParser _detect(File src) throws IOException {\n-        InputStream in = new FileInputStream(src);\n-        return _detectAndCreateParser(_dataFormatDetector.findFormat(in), true);\n-    }\n-\n-    protected JsonParser _detect(URL src) throws IOException {\n-        InputStream in = src.openStream();\n-        return _detectAndCreateParser(_dataFormatDetector.findFormat(in), true);\n-    }\n-    \n-    protected JsonParser _detect(byte[] src, int offset, int length) throws IOException\n-    {\n-        DataFormatMatcher matcher = _dataFormatDetector.findFormat(src, offset, length);\n-        if (!matcher.hasMatch()) {\n-            _reportUnkownFormat(_dataFormatDetector, matcher);\n-        }\n-        return matcher.createParserWithMatch();\n-    }\n-\n-    protected JsonParser _detectAndCreateParser(DataFormatMatcher matcher, boolean forceClosing)\n+    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException\n+    {\n+        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n+        if (!match.hasMatch()) {\n+            _reportUnkownFormat(_dataFormatReaders, match);\n+        }\n+        JsonParser jp = match.createParserWithMatch();\n+        return match.getReader()._bindAndClose(jp, _valueToUpdate);\n+    }\n+\n+    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing)\n         throws IOException\n     {\n-        if (!matcher.hasMatch()) {\n-            _reportUnkownFormat(_dataFormatDetector, matcher);\n-        }\n-        JsonParser jp = matcher.createParserWithMatch();\n+        if (!match.hasMatch()) {\n+            _reportUnkownFormat(_dataFormatReaders, match);\n+        }\n+        JsonParser p = match.createParserWithMatch();\n         // One more thing: we Own the input stream now; and while it's \n         // not super clean way to do it, we must ensure closure so:\n         if (forceClosing) {\n-            jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n-        }\n-        return jp;\n+            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        }\n+        // important: use matching ObjectReader (may not be 'this')\n+        return match.getReader()._bindAndClose(p, _valueToUpdate);\n+    }\n+\n+    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (!match.hasMatch()) {\n+            _reportUnkownFormat(_dataFormatReaders, match);\n+        }\n+        JsonParser p = match.createParserWithMatch();\n+        // One more thing: we Own the input stream now; and while it's \n+        // not super clean way to do it, we must ensure closure so:\n+        if (forceClosing) {\n+            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        }\n+        // important: use matching ObjectReader (may not be 'this')\n+        return match.getReader()._bindAndReadValues(p, _valueToUpdate);\n+    }\n+    \n+    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n+    {\n+        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n+        if (!match.hasMatch()) {\n+            _reportUnkownFormat(_dataFormatReaders, match);\n+        }\n+        JsonParser p = match.createParserWithMatch();\n+        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        return match.getReader()._bindAndCloseAsTree(p);\n     }\n     \n     /**\n      * Method called to indicate that format detection failed to detect format\n      * of given input\n      */\n-    protected void _reportUnkownFormat(DataFormatDetector detector, DataFormatMatcher match) throws JsonProcessingException\n+    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n     {\n         throw new JsonParseException(\"Can not detect format from input, does not look like any of detectable formats \"\n                 +detector.toString(),\n     }\n     \n     protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) return this;\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        if (_dataFormatReaders != null) {\n+            return new ObjectReader(this, newConfig)\n+                .withFormatDetection(_dataFormatReaders.with(newConfig));\n+        }\n         return new ObjectReader(this, newConfig);\n     }\n \n                 +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n                 JsonLocation.NA);\n     }\n+\n+    protected InputStream _inputStream(URL src) throws IOException {\n+        return src.openStream();\n+    }\n+\n+    protected InputStream _inputStream(File f) throws IOException {\n+        return new FileInputStream(f);\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.*;\n+import com.fasterxml.jackson.core.io.MergedStream;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Alternative to {@link DataFormatDetector} that needs to be used when\n+ * using data-binding.\n+ * \n+ * @since 2.1\n+ */\n+public class DataFormatReaders\n+{\n+    /**\n+     * By default we will look ahead at most 64 bytes; in most cases,\n+     * much less (4 bytes or so) is needed, but we will allow bit more\n+     * leniency to support data formats that need more complex heuristics.\n+     */\n+    public final static int DEFAULT_MAX_INPUT_LOOKAHEAD = 64;\n+    \n+    /**\n+     * Ordered list of readers which both represent data formats to\n+     * detect (in precedence order, starting with highest) and contain\n+     * factories used for actual detection.\n+     */\n+    protected final ObjectReader[] _readers;\n+\n+    /**\n+     * Strength of match we consider to be good enough to be used\n+     * without checking any other formats.\n+     * Default value is {@link MatchStrength#SOLID_MATCH}, \n+     */\n+    protected final MatchStrength _optimalMatch;\n+\n+    /**\n+     * Strength of minimal match we accept as the answer, unless\n+     * better matches are found. \n+     * Default value is {@link MatchStrength#WEAK_MATCH}, \n+     */\n+    protected final MatchStrength _minimalMatch;\n+\n+    /**\n+     * Maximum number of leading bytes of the input that we can read\n+     * to determine data format.\n+     *<p>\n+     * Default value is {@link #DEFAULT_MAX_INPUT_LOOKAHEAD}.\n+     */\n+    protected final int _maxInputLookahead;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    public DataFormatReaders(ObjectReader... detectors) {\n+        this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH,\n+            DEFAULT_MAX_INPUT_LOOKAHEAD);\n+    }\n+\n+    public DataFormatReaders(Collection<ObjectReader> detectors) {\n+        this(detectors.toArray(new ObjectReader[detectors.size()]));\n+    }\n+\n+    private DataFormatReaders(ObjectReader[] detectors,\n+            MatchStrength optMatch, MatchStrength minMatch,\n+            int maxInputLookahead)\n+    {\n+        _readers = detectors;\n+        _optimalMatch = optMatch;\n+        _minimalMatch = minMatch;\n+        _maxInputLookahead = maxInputLookahead;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Fluent factories for changing match settings\n+    /**********************************************************\n+     */\n+    \n+    public DataFormatReaders withOptimalMatch(MatchStrength optMatch) {\n+        if (optMatch == _optimalMatch) {\n+            return this;\n+        }\n+        return new DataFormatReaders(_readers, optMatch, _minimalMatch, _maxInputLookahead);\n+    }\n+\n+    public DataFormatReaders withMinimalMatch(MatchStrength minMatch) {\n+        if (minMatch == _minimalMatch) {\n+            return this;\n+        }\n+        return new DataFormatReaders(_readers, _optimalMatch, minMatch, _maxInputLookahead);\n+    }\n+\n+    public DataFormatReaders with(ObjectReader[] readers) {\n+        return new DataFormatReaders(readers, _optimalMatch, _minimalMatch, _maxInputLookahead);\n+    }\n+    \n+    public DataFormatReaders withMaxInputLookahead(int lookaheadBytes)\n+    {\n+        if (lookaheadBytes == _maxInputLookahead) {\n+            return this;\n+        }\n+        return new DataFormatReaders(_readers, _optimalMatch, _minimalMatch, lookaheadBytes);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Fluent factories for changing underlying readers\n+    /**********************************************************\n+     */\n+\n+    public DataFormatReaders with(DeserializationConfig config)\n+    {\n+        final int len = _readers.length;\n+        ObjectReader[] r = new ObjectReader[len];\n+        for (int i = 0; i < len; ++i) {\n+            r[i] = _readers[i].with(config);\n+        }\n+        return new DataFormatReaders(r, _optimalMatch, _minimalMatch, _maxInputLookahead);\n+    }\n+\n+    public DataFormatReaders withType(JavaType type)\n+    {\n+        final int len = _readers.length;\n+        ObjectReader[] r = new ObjectReader[len];\n+        for (int i = 0; i < len; ++i) {\n+            r[i] = _readers[i].withType(type);\n+        }\n+        return new DataFormatReaders(r, _optimalMatch, _minimalMatch, _maxInputLookahead);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to call to find format that content (accessible via given\n+     * {@link InputStream}) given has, as per configuration of this detector\n+     * instance.\n+     * \n+     * @return Matcher object which contains result; never null, even in cases\n+     *    where no match (with specified minimal match strength) is found.\n+     */\n+    public Match findFormat(InputStream in) throws IOException\n+    {\n+        return _findFormat(new AccessorForReader(in, new byte[_maxInputLookahead]));\n+    }\n+\n+    /**\n+     * Method to call to find format that given content (full document)\n+     * has, as per configuration of this detector instance.\n+     * \n+     * @return Matcher object which contains result; never null, even in cases\n+     *    where no match (with specified minimal match strength) is found.\n+     */\n+    public Match findFormat(byte[] fullInputData) throws IOException\n+    {\n+        return _findFormat(new AccessorForReader(fullInputData));\n+    }\n+\n+    /**\n+     * Method to call to find format that given content (full document)\n+     * has, as per configuration of this detector instance.\n+     * \n+     * @return Matcher object which contains result; never null, even in cases\n+     *    where no match (with specified minimal match strength) is found.\n+     * \n+     * @since 2.1\n+     */\n+    public Match findFormat(byte[] fullInputData, int offset, int len) throws IOException\n+    {\n+        return _findFormat(new AccessorForReader(fullInputData, offset, len));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        final int len = _readers.length;\n+        if (len > 0) {\n+            sb.append(_readers[0].getFactory().getFormatName());\n+            for (int i = 1; i < len; ++i) {\n+                sb.append(\", \");\n+                sb.append(_readers[i].getFactory().getFormatName());\n+            }\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private Match _findFormat(AccessorForReader acc) throws IOException\n+    {\n+        ObjectReader bestMatch = null;\n+        MatchStrength bestMatchStrength = null;\n+        for (ObjectReader f : _readers) {\n+            acc.reset();\n+            MatchStrength strength = f.getFactory().hasFormat(acc);\n+            // if not better than what we have so far (including minimal level limit), skip\n+            if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) {\n+                continue;\n+            }\n+            // also, needs to better match than before\n+            if (bestMatch != null) {\n+                if (bestMatchStrength.ordinal() >= strength.ordinal()) {\n+                    continue;\n+                }\n+            }\n+            // finally: if it's good enough match, we are done\n+            bestMatch = f;\n+            bestMatchStrength = strength;\n+            if (strength.ordinal() >= _optimalMatch.ordinal()) {\n+                break;\n+            }\n+        }\n+        return acc.createMatcher(bestMatch, bestMatchStrength);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We need sub-class here as well, to be able to access efficiently.\n+     */\n+    protected class AccessorForReader extends InputAccessor.Std\n+    {\n+        public AccessorForReader(InputStream in, byte[] buffer) {\n+            super(in, buffer);\n+        }\n+        public AccessorForReader(byte[] inputDocument) {\n+            super(inputDocument);\n+        }\n+        public AccessorForReader(byte[] inputDocument, int start, int len) {\n+            super(inputDocument, start, len);\n+        }\n+\n+        public Match createMatcher(ObjectReader match, MatchStrength matchStrength)\n+        {\n+            return new Match(_in, _buffer, _bufferedStart, (_bufferedEnd - _bufferedStart),\n+                    match, matchStrength);\n+        }\n+    }\n+    \n+    /**\n+     * Result class, similar to {@link DataFormatMatcher}\n+     */\n+    public static class Match\n+    {\n+        protected final InputStream _originalStream;\n+\n+        /**\n+         * Content read during format matching process\n+         */\n+        protected final byte[] _bufferedData;\n+\n+        /**\n+         * Pointer to the first byte in buffer available for reading\n+         */\n+        protected final int _bufferedStart;\n+        \n+        /**\n+         * Number of bytes available in buffer.\n+         */\n+        protected final int _bufferedLength;\n+\n+        /**\n+         * Factory that produced sufficient match (if any)\n+         */\n+        protected final ObjectReader _match;\n+\n+        /**\n+         * Strength of match with {@link #_match}\n+         */\n+        protected final MatchStrength _matchStrength;\n+        \n+        protected Match(InputStream in, byte[] buffered,\n+                int bufferedStart, int bufferedLength,\n+                ObjectReader match, MatchStrength strength)\n+        {\n+            _originalStream = in;\n+            _bufferedData = buffered;\n+            _bufferedStart = bufferedStart;\n+            _bufferedLength = bufferedLength;\n+            _match = match;\n+            _matchStrength = strength;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, simple accessors\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Accessor to use to see if any formats matched well enough with\n+         * the input data.\n+         */\n+        public boolean hasMatch() { return _match != null; }\n+\n+        /**\n+         * Method for accessing strength of the match, if any; if no match,\n+         * will return {@link MatchStrength#INCONCLUSIVE}.\n+         */\n+        public MatchStrength getMatchStrength() {\n+            return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength;\n+        }\n+\n+        /**\n+         * Accessor for {@link JsonFactory} that represents format that data matched.\n+         */\n+        public ObjectReader getReader() { return _match; }\n+\n+        /**\n+         * Accessor for getting brief textual name of matched format if any (null\n+         * if none). Equivalent to:\n+         *<pre>\n+         *   return hasMatch() ? getMatch().getFormatName() : null;\n+         *</pre>\n+         */\n+        public String getMatchedFormatName() {\n+            return _match.getFactory().getFormatName();\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, factory methods\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Convenience method for trying to construct a {@link JsonParser} for\n+         * parsing content which is assumed to be in detected data format.\n+         * If no match was found, returns null.\n+         */\n+        public JsonParser createParserWithMatch() throws IOException\n+        {\n+            if (_match == null) {\n+                return null;\n+            }\n+            JsonFactory jf = _match.getFactory();\n+            if (_originalStream == null) {\n+                return jf.createParser(_bufferedData, _bufferedStart, _bufferedLength);\n+            }\n+            return jf.createParser(getDataStream());\n+        }\n+        \n+        /**\n+         * Method to use for accessing input for which format detection has been done.\n+         * This <b>must</b> be used instead of using stream passed to detector\n+         * unless given stream itself can do buffering.\n+         * Stream will return all content that was read during matching process, as well\n+         * as remaining contents of the underlying stream.\n+         */\n+        public InputStream getDataStream() {\n+            if (_originalStream == null) {\n+                return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n+            }\n+            return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n+        }        \n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n package com.fasterxml.jackson.databind.interop;\n \n-import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.*;\n \n public class TestFormatDetection extends BaseMapTest\n {\n     private final ObjectReader READER = objectReader();\n-\n-    private final JsonFactory JSON_FACTORY = new JsonFactory();\n \n     static class POJO {\n         public int x, y;\n     \n     public void testSimpleWithJSON() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class).withFormatDetection(JSON_FACTORY);\n+        ObjectReader detecting = READER.withType(POJO.class);\n+        detecting = detecting.withFormatDetection(detecting);\n         POJO pojo = detecting.readValue(utf8Bytes(\"{\\\"x\\\":1}\"));\n         assertNotNull(pojo);\n         assertEquals(1, pojo.x);\n \n     public void testInvalid() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class).withFormatDetection(JSON_FACTORY);\n+        ObjectReader detecting = READER.withType(POJO.class);\n+        detecting = detecting.withFormatDetection(detecting);\n         try {\n             detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\"));\n             fail(\"Should have failed\");", "timestamp": 1346305442, "metainfo": ""}