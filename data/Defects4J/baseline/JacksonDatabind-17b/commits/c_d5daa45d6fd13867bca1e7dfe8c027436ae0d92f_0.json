{"sha": "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f", "log": "Working on #124, serializer converters", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n     /**********************************************************\n      */\n \n-//  @Override\n+    @Override\n     public abstract Version version();\n     \n     /*\n     /* Serialization: general annotations\n     /**********************************************************\n      */\n-\n+    \n     /**\n      * Method for getting a serializer definition on specified method\n      * or field. Type of definition is either instance (of type\n      * @return Typing mode to use, if annotation is found; null otherwise\n      */\n     public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding {@link Converter} that annotated entity\n+     * (property or class) has indicated to be used as part of\n+     * serialization. If not null, either has to be actual\n+     * {@link Converter} instance, or class for such converter;\n+     * and resulting converter will be used first to convert property\n+     * value to converter target type, and then serializer for that\n+     * type is used for actual serialization.\n+     *<p>\n+     * This feature is typically used to convert internal values into types\n+     * that Jackson can convert.\n+     *<p>\n+     * Note also that this feature does not necessarily work well with polymorphic\n+     * type handling, or object identity handling; if such features are needed\n+     * an explicit serializer is usually better way to handle serialization.\n+     * \n+     * @param a Annotated property (field, method) or class to check for\n+     *   annotations\n+     *   \n+     * @since 2.2\n+     */\n+    public Object findSerializationConverter(Annotated a) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding {@link Converter} that annotated property\n+     * has indicated needs to be used for values of container type\n+     * (this also means that method should only be called for properties\n+     * of container types, List/Map/array properties).\n+     *<p>\n+     * If not null, either has to be actual\n+     * {@link Converter} instance, or class for such converter;\n+     * and resulting converter will be used first to convert property\n+     * value to converter target type, and then serializer for that\n+     * type is used for actual serialization.\n+     *<p>\n+     * Other notes are same as those for {@link #findSerializationConverter}\n+     * \n+     * @param a Annotated property (field, method) to check.\n+     *   \n+     * @since 2.2\n+     */\n+    public Object findSerializationContentConverter(AnnotatedMember a) {\n         return null;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n     /**\n      * @since 2.1\n      */\n-    @SuppressWarnings(\"deprecation\")\n     protected JsonSerializer<Object> _createUntypedSerializer(JavaType type)\n         throws JsonMappingException\n     {\n-        /* 30-Sep-2012, tatu: For now need to call the deprecated method; for 2.2,\n-         *   convert to using new one. But note that we do NOT pass 'property' along.\n-         */\n-        return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type, null);\n+        // 17-Feb-2013, tatu: Used to call deprecated method (that passed property)\n+        return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n                 return deserializeWithObjectId(jp, ctxt);\n             }\n             return deserializeFromObject(jp, ctxt);\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n+        default:\n+            throw ctxt.mappingException(getBeanClass());\n+        }\n     }\n \n     protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n     }\n \n     @Override\n+    public Object findSerializationConverter(Annotated a)\n+    {\n+        Object ob = _primary.findSerializationConverter(a);\n+        if (ob == null) {\n+            ob = _secondary.findSerializationConverter(a);\n+        }\n+        return ob;\n+    }\n+\n+    @Override\n+    public Object findSerializationContentConverter(AnnotatedMember a)\n+    {\n+        Object ob = _primary.findSerializationContentConverter(a);\n+        if (ob == null) {\n+            ob = _secondary.findSerializationContentConverter(a);\n+        }\n+        return ob;\n+    }\n+\n+    @Override\n     public Class<?>[] findViews(Annotated a)\n     {\n         /* Theoretically this could be trickier, if multiple introspectors\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n+import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n     }\n \n     @Override\n+    public Object findSerializationConverter(Annotated a) {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<?> def = ann.converter();\n+            if (def != Converter.None.class) {\n+                return def;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object findSerializationContentConverter(AnnotatedMember a) {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<?> def = ann.contentConverter();\n+            if (def != Converter.None.class) {\n+                return def;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n     public Class<?>[] findViews(Annotated a)\n     {\n         JsonView ann = a.getAnnotation(JsonView.class);\n     @Override\n     public Class<?> findPOJOBuilder(AnnotatedClass ac)\n     {\n-    \tJsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class);\n-    \treturn ((ann == null) || (ann.builder() == NoClass.class)) ?\n-    \t\t\tnull : ann.builder();\n+        JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class);\n+        return ((ann == null) || (ann.builder() == NoClass.class)) ?\n+                null : ann.builder();\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n         });\n         return (b != null) && b.booleanValue();\n     }\n-    \n+\n     @Override\n     public ObjectIdInfo findObjectIdInfo() {\n         return fromMemberAnnotations(new WithMember<ObjectIdInfo>() {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import com.fasterxml.jackson.databind.ser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.EnumValues;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n         if (serDef == null) {\n             return null;\n         }\n-        return prov.serializerInstance(a, serDef);\n-    }\n-\n+        JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n+        // One more thing however: may need to also apply a converter:\n+        Converter<Object,Object> conv = findConverterFromAnnotation(prov, a);\n+        if (conv != null) {\n+            TypeFactory tf = prov.getTypeFactory();\n+            JavaType converterType = tf.constructType(conv.getClass());\n+            JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n+            if (params == null || params.length != 2) {\n+                throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                        +converterType);\n+            }\n+            JavaType delegateType = params[1];\n+            return new StdDelegatingSerializer(conv, delegateType, ser);\n+        }\n+        return ser;\n+    }\n+\n+    protected Converter<Object,Object> findConverterFromAnnotation(SerializerProvider prov,\n+            Annotated a)\n+        throws JsonMappingException\n+    {\n+        Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n+        if (convDef != null) {\n+            return prov.converterInstance(a, convDef);\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Factory methods, container types:\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n-import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n         if (ser instanceof SchemaAware) {\n             schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n         } else {  \n-            schemaNode = JsonSchema.getDefaultSchemaNode(); \n+            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n         }\n         propertiesNode.put(getName(), schemaNode);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         if (origType.isContainerType()) {\n             if (!staticTyping) {\n                 staticTyping = usesStaticTyping(config, beanDesc, null);\n-                // [JACKSON-822]: Need to figure out how to force passed parameterization\n+                // [Issue#23]: Need to figure out how to force passed parameterization\n                 //  to stick...\n                 /*\n                 if (property == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Intermediate base class for serializers used for serializing\n         }\n         return false;\n     }\n+\n+    /**\n+     * Helper method that can be used to see if specified property has annotation\n+     * indicating that a converter is to be used for contained values.\n+     * \n+     * @param existingSerializer (optional) configured content\n+     *    serializer if one already exists.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n+            BeanProperty prop, JsonSerializer<?> existingSerializer)\n+        throws JsonMappingException\n+    {\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        if (intr != null && prop != null) {\n+            Object convDef = intr.findSerializationContentConverter(prop.getMember());\n+            if (convDef != null) {\n+                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                TypeFactory tf = provider.getTypeFactory();\n+                JavaType converterType = tf.constructType(conv.getClass());\n+                JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n+                if (params == null || params.length != 2) {\n+                    throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                            +converterType);\n+                }\n+                JavaType delegateType = params[1];\n+                if (existingSerializer == null) {\n+                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n+                }\n+                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n+            }\n+        }\n+        return existingSerializer;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n      * to <code>createContextual</code> of content serializer, if\n      * known statically.\n      */\n-//  @Override\n+    @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n         if (ser == null) {\n             ser = _elementSerializer;\n         }\n+        // 18-Feb-2013, tatu: May have a content converter:\n+        ser = findConvertingContentSerializer(provider, property, ser);\n         if (ser == null) {\n-            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n-            //   we can consider it a static case as well.\n-            if (_elementType != null) {\n-                if (_staticTyping || hasContentTypeAnnotation(provider, property)) {\n-                    ser = provider.findValueSerializer(_elementType, property);\n-                }\n-            }\n-        } else if (ser instanceof ContextualSerializer) {\n-            ser = ((ContextualSerializer) ser).createContextual(provider, property);\n+            if (ser == null) {\n+                // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n+                //   we can consider it a static case as well.\n+                if (_elementType != null) {\n+                    if (_staticTyping || hasContentTypeAnnotation(provider, property)) {\n+                        ser = provider.findValueSerializer(_elementType, property);\n+                    }\n+                }\n+            }\n+        } else {\n+            if (ser instanceof ContextualSerializer) {\n+                ser = ((ContextualSerializer) ser).createContextual(provider, property);\n+            }\n         }\n         if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) {\n             return withResolved(property, typeSer, ser);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n      * We need to implement {@link ResolvableSerializer} to be able to\n      * properly handle cyclic type references.\n      */\n-//  @Override\n+    @Override\n     public void resolve(SerializerProvider provider)\n         throws JsonMappingException\n     {\n             if (prop.hasSerializer()) {\n                 continue;\n             }\n-            // Was the serialization type hard-coded? If so, use it\n-            JavaType type = prop.getSerializationType();\n-            \n-            /* It not, we can use declared return type if and only if\n-             * declared type is final -- if not, we don't really know\n-             * the actual type until we get the instance.\n-             */\n-            if (type == null) {\n-                type = provider.constructType(prop.getGenericPropertyType());\n-                if (!type.isFinal()) {\n-                    /* 18-Feb-2010, tatus: But even if it is non-final, we may\n-                     *   need to retain some of type information so that we can\n-                     *   accurately handle contained types\n-                     */\n-                    if (type.isContainerType() || type.containedTypeCount() > 0) {\n-                        prop.setNonTrivialBaseType(type);\n+            // [Issue#124]: allow use of converters\n+            JsonSerializer<Object> ser = findConvertingSerializer(provider, prop);  \n+            if (ser == null) {\n+                // Was the serialization type hard-coded? If so, use it\n+                JavaType type = prop.getSerializationType();\n+                \n+                // It not, we can use declared return type if and only if declared type is final:\n+                // if not, we don't really know the actual type until we get the instance.\n+                if (type == null) {\n+                    type = provider.constructType(prop.getGenericPropertyType());\n+                    if (!type.isFinal()) {\n+                        if (type.isContainerType() || type.containedTypeCount() > 0) {\n+                            prop.setNonTrivialBaseType(type);\n+                        }\n+                        continue;\n                     }\n-                    continue;\n-                }\n-            }\n-            \n-            JsonSerializer<Object> ser = provider.findValueSerializer(type, prop);\n-            /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n-             *   too, earlier; if so, it's time to connect the dots here:\n-             */\n-            if (type.isContainerType()) {\n-                TypeSerializer typeSer = type.getContentType().getTypeHandler();\n-                if (typeSer != null) {\n-                    // for now, can do this only for standard containers...\n-                    if (ser instanceof ContainerSerializer<?>) {\n-                        // ugly casts... but necessary\n-                        @SuppressWarnings(\"unchecked\")\n-                        JsonSerializer<Object> ser2 = (JsonSerializer<Object>)((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer);\n-                        ser = ser2;\n+                }\n+                ser = provider.findValueSerializer(type, prop);\n+                /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n+                 *   too, earlier; if so, it's time to connect the dots here:\n+                 */\n+                if (type.isContainerType()) {\n+                    TypeSerializer typeSer = type.getContentType().getTypeHandler();\n+                    if (typeSer != null) {\n+                        // for now, can do this only for standard containers...\n+                        if (ser instanceof ContainerSerializer<?>) {\n+                            // ugly casts... but necessary\n+                            @SuppressWarnings(\"unchecked\")\n+                            JsonSerializer<Object> ser2 = (JsonSerializer<Object>)((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer);\n+                            ser = ser2;\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n-//  @Override\n+    /**\n+     * Helper method that can be used to see if specified property is annotated\n+     * to indicate use of a converter for property value (in case of container types,\n+     * it is container type itself, not key or content type).\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n+            BeanPropertyWriter prop)\n+        throws JsonMappingException\n+    {\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        if (intr != null) {\n+            Object convDef = intr.findSerializationConverter(prop.getMember());\n+            if (convDef != null) {\n+                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                TypeFactory tf = provider.getTypeFactory();\n+                JavaType converterType = tf.constructType(conv.getClass());\n+                JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n+                if (params == null || params.length != 2) {\n+                    throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                            +converterType);\n+                }\n+                JavaType delegateType = params[1];\n+                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                return new StdDelegatingSerializer(conv, delegateType, ser);\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n         if (ser == null) {\n             ser = _elementSerializer;\n         }\n+        // 18-Feb-2013, tatu: May have a content converter:\n+        ser = findConvertingContentSerializer(provider, property, ser);\n         if (ser == null) {\n             // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n             //   we can consider it a static case as well.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n      * Default implementation simply claims type is \"string\"; usually\n      * overriden by custom serializers.\n      */\n-//  @Override\n+    @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n     {\n      * Default implementation simply claims type is \"string\"; usually\n      * overriden by custom serializers.\n      */\n-//    @Override\n+    @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n         throws JsonMappingException\n     {\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n     {\n-    \tvisitor.expectAnyFormat(typeHint);\n+        visitor.expectAnyFormat(typeHint);\n     }\n             \n     /*\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.util.Converter;\n+\n+public class TestConvertingSerializer\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    @JsonSerialize(converter=ConvertingBeanConverter.class)\n+    static class ConvertingBean\n+    {\n+        public int x, y;\n+\n+        public ConvertingBean(int v1, int v2) {\n+            x = v1;\n+            y = v2;\n+        }\n+    }\n+\n+    static class Point\n+    {\n+        public int x, y;\n+\n+        public Point(int v1, int v2) {\n+            x = v1;\n+            y = v2;\n+        }\n+    }\n+    \n+    static class ConvertingBeanContainer\n+    {\n+        public List<ConvertingBean> values;\n+        \n+        public ConvertingBeanContainer(ConvertingBean... beans) {\n+            values = Arrays.asList(beans);\n+        }\n+    }\n+\n+    static class ConvertingBeanConverter implements Converter<ConvertingBean, int[]>\n+    {\n+        @Override\n+        public int[] convert(ConvertingBean value) {\n+            return new int[] { value.x, value.y };\n+        }\n+    }\n+\n+    static class PointConverter implements Converter<Point, int[]>\n+    {\n+        @Override public int[] convert(Point value) {\n+            return new int[] { value.x, value.y };\n+        }\n+    }\n+    \n+    static class PointWrapper {\n+        @JsonSerialize(converter=PointConverter.class)\n+        public Point value;\n+\n+        public PointWrapper(int x, int y) {\n+            value = new Point(x, y);\n+        }\n+    }\n+\n+    static class PointListWrapperArray {\n+        @JsonSerialize(contentConverter=PointConverter.class)\n+        public Point[] values;\n+\n+        public PointListWrapperArray(int x, int y) {\n+            values = new Point[] { new Point(x, y), new Point(y, x) };\n+        }\n+    }\n+\n+    static class PointListWrapperList {\n+        @JsonSerialize(contentConverter=PointConverter.class)\n+        public List<Point> values;\n+\n+        public PointListWrapperList(int x, int y) {\n+            values = Arrays.asList(new Point[] { new Point(x, y), new Point(y, x) });\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testClassAnnotationSimple() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new ConvertingBean(1, 2));\n+        assertEquals(\"[1,2]\", json);\n+    }\n+\n+    public void testClassAnnotationForLists() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new ConvertingBeanContainer(new ConvertingBean(3, 4)));\n+        assertEquals(\"{\\\"values\\\":[1,2]}\", json);\n+    }\n+\n+    public void testPropertyAnnotationSimple() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new PointWrapper(3, 4));\n+        assertEquals(\"{\\\"value\\\":[3,4]}\", json);\n+    }\n+\n+    public void testPropertyAnnotationForArrays() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new PointListWrapperArray(4, 5));\n+        assertEquals(\"{\\\"values\\\":[[4,5],[5,4]]}\", json);\n+    }\n+\n+    public void testPropertyAnnotationForLists() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8));\n+System.err.println(\"JSON -> \"+json);\n+        \n+        assertEquals(\"{\\\"values\\\":[[7,8],[8,7]]}\", json);\n+    }\n+}", "timestamp": 1361251517, "metainfo": ""}