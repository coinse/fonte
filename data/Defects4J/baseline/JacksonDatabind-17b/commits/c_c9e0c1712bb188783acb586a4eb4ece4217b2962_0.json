{"sha": "c9e0c1712bb188783acb586a4eb4ece4217b2962", "log": "Prune some unneeded methods from ObjectMapper", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     {\n         DeserializationConfig config = getDeserializationConfig();\n         DeserializationContext ctxt = _createDeserializationContext(jp, config);\n-        JsonDeserializer<?> deser = _findRootDeserializer(config, valueType);\n+        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n         // false -> do NOT close JsonParser (since caller passed it)\n         return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                 false, null);\n     /* (mapping from JSON to Java types)\n     /**********************************************************\n      */\n-    \n-    /**\n-     * Method to deserialize JSON content into a non-container\n-     * type (it can be an array type, however): typically a bean, array\n-     * or a wrapper type (like {@link java.lang.Boolean}).\n-     *<p>\n-     * Note: this method should NOT be used if the result type is a\n-     * container ({@link java.util.Collection} or {@link java.util.Map}.\n-     * The reason is that due to type erasure, key and value types\n-     * can not be introspected when using this method.\n-     *\n-     * @param cfg Specific deserialization configuration to use for\n-     *   this operation. Note that not all config settings can\n-     *   be changed on per-operation basis: some changeds only take effect\n-     *   before calling the operation for the first time (for the mapper\n-     *   instance)\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T readValue(JsonParser jp, Class<T> valueType, \n-                           DeserializationConfig cfg)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-     // !!! TODO\n-//    \t_setupClassLoaderForDeserialization(valueType);\n-        return (T) _readValue(cfg, jp, _typeFactory.constructType(valueType));\n-    } \n-\n-    /**\n-     * Method to deserialize JSON content into a Java type, reference\n-     * to which is passed as argument. Type is passed using so-called\n-     * \"super type token\" (see )\n-     * and specifically needs to be used if the root type is a \n-     * parameterized (generic) container type.\n-     *\n-     * @param cfg Specific deserialization configuration to use for\n-     *   this operation. Note that not all config settings can\n-     *   be changed on per-operation basis: some changeds only take effect\n-     *   before calling the operation for the first time (for the mapper\n-     *   instance)\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef,\n-                           DeserializationConfig cfg)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        return (T) _readValue(cfg, jp, _typeFactory.constructType(valueTypeRef));\n-    } \n-\n-    /**\n-     * Method to deserialize JSON content into a Java type, reference\n-     * to which is passed as argument. Type is passed using \n-     * Jackson specific type; instance of which can be constructed using\n-     * {@link TypeFactory}.\n-     *\n-     * @param cfg Specific deserialization configuration to use for\n-     *   this operation. Note that not all config settings can\n-     *   be changed on per-operation basis: some changeds only take effect\n-     *   before calling the operation for the first time (for the mapper\n-     *   instance)\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T readValue(JsonParser jp, JavaType valueType,\n-                           DeserializationConfig cfg)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        return (T) _readValue(cfg, jp, valueType);\n-    } \n-\n-    /**\n-     * Method to deserialize JSON content as tree expressed\n-     * using set of {@link JsonNode} instances. Returns\n-     * root of the resulting tree (where root can consist\n-     * of just a single node if the current event is a\n-     * value event, not container).\n-     *\n-     * @param cfg Specific deserialization configuration to use for\n-     *   this operation. Note that not all config settings can\n-     *   be changed on per-operation basis: some changeds only take effect\n-     *   before calling the operation for the first time (for the mapper\n-     *   instance)\n-     */\n-    public JsonNode readTree(JsonParser jp, DeserializationConfig cfg)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n-        return (n == null) ? NullNode.instance : n;\n-    }\n \n     /**\n      * Method to deserialize JSON content as tree expressed\n     }\n \n     /**\n-     * Method that can be used to serialize any Java value as\n-     * JSON output, using provided {@link JsonGenerator},\n-     * configured as per passed configuration object.\n-     */\n-    public void writeValue(JsonGenerator jgen, Object value, SerializationConfig config)\n-        throws IOException, JsonGenerationException, JsonMappingException\n-    {\n-        // [JACKSON-282] Consider java.util.Closeable\n-        if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n-            _writeCloseableValue(jgen, value, config);\n-        } else {\n-            _serializerProvider.serializeValue(config, jgen, value, _serializerFactory);\n-            if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n-                jgen.flush();\n-            }\n-        }\n-    }\n-\n-    /**\n      * Method to serialize given JSON Tree, using generator\n      * provided.\n      */\n         SerializationConfig config = getSerializationConfig();\n         _serializerProvider.serializeValue(config, jgen, rootNode, _serializerFactory);\n         if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n-            jgen.flush();\n-        }\n-    }\n-\n-    /**\n-     * Method to serialize given Json Tree, using generator\n-     * provided.\n-     */\n-    public void writeTree(JsonGenerator jgen, JsonNode rootNode,\n-                          SerializationConfig cfg)\n-        throws IOException, JsonProcessingException\n-    {\n-        _serializerProvider.serializeValue(cfg, jgen, rootNode, _serializerFactory);\n-        if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n             jgen.flush();\n         }\n     }\n         return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), valueType);\n     } \n     \n-    /**\n-     * Convenience method for converting results from given JSON tree into given\n-     * value type. Basically short-cut for:\n-     *<pre>\n-     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n-     *</pre>\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T readValue(JsonNode root, Class<T> valueType)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-     // !!! TODO\n-//    \t_setupClassLoaderForDeserialization(valueType);\n-        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueType));\n-    } \n-\n-    /**\n-     * Convenience method for converting results from given JSON tree into given\n-     * value type. Basically short-cut for:\n-     *<pre>\n-     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n-     *</pre>\n-     */\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    public <T> T readValue(JsonNode root, TypeReference valueTypeRef)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueTypeRef));\n-    } \n-    \n-    /**\n-     * Convenience method for converting results from given JSON tree into given\n-     * value type. Basically short-cut for:\n-     *<pre>\n-     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n-     *</pre>\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T readValue(JsonNode root, JavaType valueType)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), valueType);\n-    } \n-    \n     /*\n     /**********************************************************\n     /* Extended Public API: serialization\n-    /* (mapping from Java types to Json)\n+    /* (mapping from Java types to JSON)\n     /**********************************************************\n      */\n \n             final DeserializationConfig deserConfig = getDeserializationConfig();\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n-                result = _findRootDeserializer(deserConfig, toValueType).getNullValue();\n+                DeserializationContext ctxt = _createDeserializationContext(jp, deserConfig);\n+                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                 result = null;\n             } else { // pointing to event other than null\n                 DeserializationContext ctxt = _createDeserializationContext(jp, deserConfig);\n-                JsonDeserializer<Object> deser = _findRootDeserializer(deserConfig, toValueType);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                 // note: no handling of unwarpping\n                 result = deser.deserialize(jp, ctxt);\n             }\n         JsonToken t = _initForReading(jp);\n         if (t == JsonToken.VALUE_NULL) {\n             // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n-            result = _findRootDeserializer(cfg, valueType).getNullValue();\n+            DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n+            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n             result = null;\n         } else { // pointing to event other than null\n             DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n-            JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n             // ok, let's get the value\n             if (cfg.useRootWrapping()) {\n                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n                 // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n-                result = _findRootDeserializer(getDeserializationConfig(), valueType).getNullValue();\n+                DeserializationContext ctxt = _createDeserializationContext(jp,\n+                        getDeserializationConfig());\n+                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                 result = null;\n             } else {\n                 DeserializationConfig cfg = getDeserializationConfig();\n                 DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n-                JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                 if (cfg.useRootWrapping()) {\n                     result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                 } else {\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n-    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationConfig cfg, JavaType valueType)\n+    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n+            JavaType valueType)\n         throws JsonMappingException\n     {\n         // First: have we already seen it?\n             return deser;\n         }\n         // Nope: need to ask provider to resolve it\n-        deser = _deserializerProvider.findTypedValueDeserializer(cfg, valueType, null);\n+        deser = ctxt.findTypedValueDeserializer(valueType, null);\n         if (deser == null) { // can this happen?\n             throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.core.JsonNode;\n-import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.*;\n \n /**\n  * for other providers; in former case returned deserializer is used for handling of\n  * instances of specified type.\n  *<p>\n- * Unlike with {@link Serializers}, multiple different methods are used since different\n- * kinds of types typically require different kinds of inputs.\n+ * Unlike with {@link com.fasterxml.jackson.databind.ser.Serializers},\n+ * multiple different methods are used since different kinds of types typically\n+ * require different kinds of inputs.\n  */\n public interface Deserializers\n {\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n         Root r1 = mapper.treeToValue(root, Root.class);\n         assertNotNull(r1);\n         assertEquals(13, r1.leaf.value);\n-        Root r2 = mapper.readValue(root, Root.class);\n-        assertEquals(13, r2.leaf.value);\n     }\n \n     // Test for [JACKSON-631]\n         byte[] inputData = new byte[] { 1, 2, 3 };\n         ObjectNode node = mapper.createObjectNode();\n         node.put(\"data\", inputData);\n-        Issue709Bean result = mapper.readValue(node, Issue709Bean.class);\n+        Issue709Bean result = mapper.treeToValue(node, Issue709Bean.class);\n         String json = mapper.writeValueAsString(node);\n         Issue709Bean resultFromString = mapper.readValue(json, Issue709Bean.class);\n         Issue709Bean resultFromConvert = mapper.convertValue(node, Issue709Bean.class);", "timestamp": 1327432137, "metainfo": ""}