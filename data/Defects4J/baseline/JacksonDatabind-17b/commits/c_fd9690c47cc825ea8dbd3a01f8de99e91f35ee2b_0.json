{"sha": "fd9690c47cc825ea8dbd3a01f8de99e91f35ee2b", "log": "Start work on [JACKSON-754], \"annotation bundles\"", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n     /**\n      * Similar to {@link #findValueSerializer(Class,BeanProperty)}, but takes full generics-aware\n      * type instead of raw class.\n+     * \n+     * @param property When creating secondary serializers, property for which\n+     *   serializer is needed: annotations of the property (or bean that contains it)\n+     *   may be checked to create contextual serializers.\n      */\n     public abstract JsonSerializer<Object> findValueSerializer(JavaType serializationType,\n             BeanProperty property)\n      * \n      * @param valueType Type for purpose of locating a serializer; usually dynamic\n      *   runtime type, but can also be static declared type, depending on configuration\n-     * \n      * @param cache Whether resulting value serializer should be cached or not; this is just\n      *    a hint\n+     * @param property When creating secondary serializers, property for which\n+     *   serializer is needed: annotations of the property (or bean that contains it)\n+     *   may be checked to create contextual serializers.\n      */\n     public abstract JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n             boolean cache, BeanProperty property)\n      * @param valueType Declared type of value being serialized (which may not\n      *    be actual runtime type); used for finding both value serializer and\n      *    type serializer to use for adding polymorphic type (if any)\n-     * \n      * @param cache Whether resulting value serializer should be cached or not; this is just\n      *    a hint \n+     * @param property When creating secondary serializers, property for which\n+     *   serializer is needed: annotations of the property (or bean that contains it)\n+     *   may be checked to create contextual serializers.\n      */\n     public abstract JsonSerializer<Object> findTypedValueSerializer(JavaType valueType,\n             boolean cache, BeanProperty property)\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n import java.lang.reflect.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\n import com.fasterxml.jackson.databind.util.Annotations;\n     /**********************************************************\n      */\n \n-    /**\n-     * @return 1.7\n-     */\n     public Annotations getAnnotations() { return _classAnnotations; }\n     \n     public boolean hasAnnotations() { return _classAnnotations.size() > 0; }\n             _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n         }\n         // first, annotations from the class itself:\n-        for (Annotation a : _class.getDeclaredAnnotations()) {\n-            if (_annotationIntrospector.isHandled(a)) {\n-                _classAnnotations.addIfNotPresent(a);\n-            }\n-        }\n+        _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n \n         // and then from super types\n         for (Class<?> cls : _superTypes) {\n             // and mix mix-in annotations in-between\n             _addClassMixIns(_classAnnotations, cls);\n-            for (Annotation a : cls.getDeclaredAnnotations()) {\n-                if (_annotationIntrospector.isHandled(a)) {\n-                    _classAnnotations.addIfNotPresent(a);\n-                }\n-            }\n+            _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n         }\n \n         /* and finally... any annotations there might be for plain\n          */\n         _addClassMixIns(_classAnnotations, Object.class);\n     }\n-\n+    \n     /**\n      * Initialization method that will find out all constructors\n      * and potential static factory methods the class has.\n-     *<p>\n-     * Starting with 1.2, it will also apply mix-in annotations,\n-     * as per [JACKSON-76]\n      *\n      * @param includeAll If true, includes all creator methods; if false,\n      *   will only include the no-arguments \"default\" constructor\n      * and combining annotations (to implement method-annotation inheritance)\n      * \n      * @param methodFilter Filter used to determine which methods to include\n-     * \n-     * @since 1.9\n      */\n     public void resolveMemberMethods(MethodFilter methodFilter)\n     {\n      * Method that will collect all member (non-static) fields\n      * that are either public, or have at least a single annotation\n      * associated with them.\n-     * \n-     * @since 1.9\n      */\n     public void resolveFields()\n     {\n             return;\n         }\n         // Ok, first: annotations from mix-in class itself:\n-        for (Annotation a : mixin.getDeclaredAnnotations()) {\n-            if (_annotationIntrospector.isHandled(a)) {\n-                annotations.addIfNotPresent(a);\n-            }\n-        }\n+        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n+\n         /* And then from its supertypes, if any. But note that we will\n          *  only consider super-types up until reaching the masked\n          * class (if found); this because often mix-in class\n          * as that would inverse precedence of annotations.\n          */\n         for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n-            for (Annotation a : parent.getDeclaredAnnotations()) {\n-                if (_annotationIntrospector.isHandled(a)) {\n-                    annotations.addIfNotPresent(a);\n-                }\n-            }\n+            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n         }\n     }\n \n             // anything to mask? (if not, quietly ignore)\n             AnnotatedField maskedField = fields.get(name);\n             if (maskedField != null) {\n-                for (Annotation a : mixinField.getDeclaredAnnotations()) {\n-                    if (_annotationIntrospector.isHandled(a)) {\n-                        maskedField.addOrOverride(a);\n-                    }\n-                }\n+                _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n             }\n         }\n     }\n         }\n         return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n     }\n-\n-    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n-    {\n-        int len = anns.length;\n-        AnnotationMap[] result = new AnnotationMap[len];\n-        for (int i = 0; i < len; ++i) {\n-            result[i] = _collectRelevantAnnotations(anns[i]);\n-        }\n-        return result;\n-    }\n-\n-    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n-    {\n-        AnnotationMap annMap = new AnnotationMap();\n-        if (anns != null) {\n-            for (Annotation a : anns) {\n-                if (_annotationIntrospector.isHandled(a)) {\n-                    annMap.add(a);\n-                }\n-            }\n-        }\n-        return annMap;\n-    }\n  \n     private AnnotationMap _emptyAnnotationMap() {\n         return new AnnotationMap();\n     /**********************************************************\n      */\n \n+    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n+    {\n+        int len = anns.length;\n+        AnnotationMap[] result = new AnnotationMap[len];\n+        for (int i = 0; i < len; ++i) {\n+            result[i] = _collectRelevantAnnotations(anns[i]);\n+        }\n+        return result;\n+    }\n+\n+    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n+    {\n+        AnnotationMap annMap = new AnnotationMap();\n+        _addAnnotationsIfNotPresent(annMap, anns);\n+        return annMap;\n+    }\n+    \n+    /* Helper method used to add all applicable annotations from given set.\n+     * Takes into account possible \"annotation bundles\" (meta-annotations to\n+     * include instead of main-level annotation)\n+     */\n+    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n+    {\n+        if (anns != null) {\n+            List<Annotation[]> bundles = null;\n+            for (Annotation ann : anns) { // first: direct annotations\n+                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                    if (bundles == null) {\n+                        bundles = new LinkedList<Annotation[]>();\n+                    }\n+                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n+                } else { // note: we will NOT filter out non-Jackson anns any more\n+                    result.addIfNotPresent(ann);\n+                }\n+            }\n+            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n+                _addAnnotationsIfNotPresent(result, bundles.toArray(new Annotation[bundles.size()]));\n+            }\n+        }\n+    }\n+\n+    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n+    {\n+        if (anns != null) {\n+            List<Annotation[]> bundles = null;\n+            for (Annotation ann : anns) { // first: direct annotations\n+                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                    if (bundles == null) {\n+                        bundles = new LinkedList<Annotation[]>();\n+                    }\n+                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n+                } else { // note: we will NOT filter out non-Jackson anns any more\n+                    target.addIfNotPresent(ann);\n+                }\n+            }\n+            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n+                _addAnnotationsIfNotPresent(target, bundles.toArray(new Annotation[bundles.size()]));\n+            }\n+        }\n+    }\n+    \n+    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n+    {\n+        if (anns != null) {\n+            List<Annotation[]> bundles = null;\n+            for (Annotation ann : anns) { // first: direct annotations\n+                if (ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null) {\n+                    if (bundles == null) {\n+                        bundles = new LinkedList<Annotation[]>();\n+                    }\n+                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n+                } else { // note: no filtering by jackson-annotations\n+                    target.addOrOverride(ann);\n+                }\n+            }\n+            if (bundles != null) { // and then bundles, if any: important for precedence\n+                _addOrOverrideAnnotations(target, bundles.toArray(new Annotation[bundles.size()]));\n+            }\n+        }\n+    }\n+    \n     /**\n      * @param addParamAnnotations Whether parameter annotations are to be\n      *   added as well\n     protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n             boolean addParamAnnotations)\n     {\n-        for (Annotation a : mixin.getDeclaredAnnotations()) {\n-            if (_annotationIntrospector.isHandled(a)) {\n-                target.addOrOverride(a);\n-            }\n-        }\n+        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n         if (addParamAnnotations) {\n             Annotation[][] pa = mixin.getParameterAnnotations();\n             for (int i = 0, len = pa.length; i < len; ++i) {\n     protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n             boolean addParamAnnotations)\n     {\n-        for (Annotation a : mixin.getDeclaredAnnotations()) {\n-            if (_annotationIntrospector.isHandled(a)) {\n-                target.addOrOverride(a);\n-            }\n-        }\n+        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n         if (addParamAnnotations) {\n             Annotation[][] pa = mixin.getParameterAnnotations();\n             for (int i = 0, len = pa.length; i < len; ++i) {\n      * Method that will add annotations from specified source method to target method,\n      * but only if target does not yet have them.\n      */\n-    protected void _addMixUnders(Method src, AnnotatedMethod target)\n-    {\n-        for (Annotation a : src.getDeclaredAnnotations()) {\n-            if (_annotationIntrospector.isHandled(a)) {\n-                target.addIfNotPresent(a);\n-            }\n-        }\n+    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n+        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n     }\n \n     /*\n         return \"[AnnotedClass \"+_class.getName()+\"]\";\n     }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n     @Override\n     public AnnotatedField withAnnotations(AnnotationMap ann) {\n         return new AnnotatedField(_field, ann);\n-    }\n-    \n-    /**\n-     * Method called to override an annotation, usually due to a mix-in\n-     * annotation masking or overriding an annotation 'real' constructor\n-     * has.\n-     */\n-    public void addOrOverride(Annotation a)\n-    {\n-        _annotations.add(a);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n package com.fasterxml.jackson.databind.introspect;\n \n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Member;\n \n import com.fasterxml.jackson.databind.util.ClassUtil;\n  * constructors in addition to fields and methods.\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public abstract class AnnotatedMember extends Annotated\n {\n     @Override\n     protected AnnotationMap getAllAnnotations() {\n         return _annotations;\n+    }\n+\n+    /**\n+     * Method called to override an annotation, usually due to a mix-in\n+     * annotation masking or overriding an annotation 'real' constructor\n+     * has.\n+     */\n+    public final void addOrOverride(Annotation a) {\n+        _annotations.add(a);\n+    }\n+\n+    /**\n+     * Method called to augment annotations, by adding specified\n+     * annotation if and only if it is not yet present in the\n+     * annotation map we have.\n+     */\n+    public final void addIfNotPresent(Annotation a) {\n+        _annotations.addIfNotPresent(a);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n             return this;\n         }\n         return _owner.replaceParameterAnnotations(_index, ann);\n-    }\n-    \n-    public void addOrOverride(Annotation a)\n-    {\n-        _annotations.add(a);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n     }\n \n     /**\n-     * Method called to override a class annotation, usually due to a mix-in\n-     * annotation masking or overriding an annotation 'real' class\n-     */\n-    public final void addOrOverride(Annotation a)\n-    {\n-        _annotations.add(a);\n-    }\n-\n-    /**\n      * Method called to override a method parameter annotation,\n      * usually due to a mix-in\n      * annotation masking or overriding an annotation 'real' method\n     }\n \n     /**\n-     * Method called to augment annotations, by adding specified\n-     * annotation if and only if it is not yet present in the\n-     * annotation map we have.\n-     */\n-    public final void addIfNotPresent(Annotation a)\n-    {\n-        _annotations.addIfNotPresent(a);\n-    }\n-\n-    \n-    /**\n      * Method called by parameter object when an augmented instance is created;\n      * needs to replace parameter with new instance\n-     * \n-     * @since 1.9\n      */\n     protected AnnotatedParameter replaceParameterAnnotations(int index, AnnotationMap ann)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Annotations.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Annotations.java\n  * Interface that defines interface for collection of annotations.\n  *<p>\n  * Standard mutable implementation is {@link com.fasterxml.jackson.databind.introspect.AnnotationMap}\n- * \n- * @since 1.7\n  */\n public interface Annotations\n {", "timestamp": 1326763473, "metainfo": ""}