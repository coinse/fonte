{"sha": "64a27bc8e5fd38a48c0c70eddf864542f7198acb", "log": "Yet some more tweaking of #506", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java\n         JsonToken t;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = valueDes.getNullValue();\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                Object value;\n+                \n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = valueDes.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                tmp.add(value);\n             }\n-            tmp.add(value);\n+        } catch (Exception e) {\n+            throw JsonMappingException.wrapWithPath(e, tmp, tmp.size());\n         }\n         if (result0 != null) {\n             result0.addAll(tmp);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n             } catch (UnresolvedForwardReference reference) {\n                 if (referringAccumulator == null) {\n                     throw JsonMappingException\n-                            .from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+                            .from(jp, \"Unresolved forward reference but no identity info\", reference);\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            // note: pass Object.class, not Object[].class, as we need element type for error info\n-            throw JsonMappingException.wrapWithPath(e, Object.class, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n         }\n \n         Object[] result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n             boolean[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                // whether we should allow truncating conversions?\n-                boolean value = _parseBooleanPrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    // whether we should allow truncating conversions?\n+                    boolean value = _parseBooleanPrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             byte[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                // whether we should allow truncating conversions?\n-                byte value;\n-                if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                    // should we catch overflow exceptions?\n-                    value = jp.getByteValue();\n-                } else {\n-                    // [JACKSON-79]: should probably accept nulls as 0\n-                    if (t != JsonToken.VALUE_NULL) {\n-                        throw ctxt.mappingException(_valueClass.getComponentType());\n-                    }\n-                    value = (byte) 0;\n-                }\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                    // whether we should allow truncating conversions?\n+                    byte value;\n+                    if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                        // should we catch overflow exceptions?\n+                        value = jp.getByteValue();\n+                    } else {\n+                        // [JACKSON-79]: should probably accept nulls as 0\n+                        if (t != JsonToken.VALUE_NULL) {\n+                            throw ctxt.mappingException(_valueClass.getComponentType());\n+                        }\n+                        value = (byte) 0;\n+                    }\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             short[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                short value = _parseShortPrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    short value = _parseShortPrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             int[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                // whether we should allow truncating conversions?\n-                int value = _parseIntPrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    // whether we should allow truncating conversions?\n+                    int value = _parseIntPrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             long[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                long value = _parseLongPrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    long value = _parseLongPrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             float[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                // whether we should allow truncating conversions?\n-                float value = _parseFloatPrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    // whether we should allow truncating conversions?\n+                    float value = _parseFloatPrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n             double[] chunk = builder.resetAndStart();\n             int ix = 0;\n \n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                double value = _parseDoublePrimitive(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = builder.appendCompletedChunk(chunk, ix);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n+            try {\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    double value = _parseDoublePrimitive(jp, ctxt);\n+                    if (ix >= chunk.length) {\n+                        chunk = builder.appendCompletedChunk(chunk, ix);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = value;\n+                }\n+            } catch (Exception e) {\n+                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            // note: pass String.class, not String[].class, as we need element type for error info\n-            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n         }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);", "timestamp": 1407958119, "metainfo": ""}