{"sha": "7d6f62ae47f92c457446492084e9374889205d92", "log": "Merge pull request #706 from ciderale/jsonschema-support-jsonunwrapped  support json schema generation for @JsonUnwrapped (#271)", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonFormatVisitorNullWrapper.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.*;\n+\n+/**\n+ * Default \"empty\" implementation, useful as the base to start on; especially as\n+ * it is guaranteed to implement all the method of the interface, even if new\n+ * methods are getting added.\n+ */\n+class JsonFormatVisitorNullWrapper implements JsonFormatVisitorWrapper {\n+\tprotected SerializerProvider _provider;\n+\n+\tpublic JsonFormatVisitorNullWrapper() {\n+\t}\n+\n+\tpublic JsonFormatVisitorNullWrapper(SerializerProvider p) {\n+\t\t_provider = p;\n+\t}\n+\n+\t@Override\n+\tpublic SerializerProvider getProvider() {\n+\t\treturn _provider;\n+\t}\n+\n+\t@Override\n+\tpublic void setProvider(SerializerProvider p) {\n+\t\t_provider = p;\n+\t}\n+\n+\t@Override\n+\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonStringFormatVisitor expectStringFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonNullFormatVisitor expectNullFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonMapFormatVisitor expectMapFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+};\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n import java.util.Iterator;\n import java.util.Map.Entry;\n \n-import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n     /**********************************************************\n      */\n \n-    // TODO: if/how to change this? Base class has this\n-/*    \n-    @Override\n-    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n-        throws JsonMappingException\n-    {\n-        if (objectVisitor != null) {\n-            if (isRequired()) {\n-                objectVisitor.property(this); \n-            } else {\n-                objectVisitor.optionalProperty(this);\n-            }\n-        }\n-    }\n-    */\n+    @Override\n+    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor)\n+            throws JsonMappingException {\n+        SerializerProvider provider = visitor.getProvider();\n+        JsonSerializer<Object> ser = provider\n+                .findValueSerializer(this.getType(), this)\n+                .unwrappingSerializer(_nameTransformer);\n+        \n+        if (ser.isUnwrappingSerializer()) {\n+            ser.acceptJsonFormatVisitor(new JsonFormatVisitorNullWrapper(provider) {\n+                // an unwrapping serializer will always expect ObjectFormat,\n+                // hence, the other cases do not have to be implemented\n+                @Override\n+                public JsonObjectFormatVisitor expectObjectFormat(JavaType type)\n+                        throws JsonMappingException {\n+                    return visitor;\n+                }\n+            }, this.getType());\n+        } else {\n+            super.depositSchemaProperty(visitor);\n+        }\n+    }\n     \n     // Override needed to support legacy JSON Schema generator\n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n \n     @Override\n     public String asText() {\n-        return NumberOutput.toString(_value);\n+        // As per [jackson-core#179]\n+//        return NumberOutput.toString(_value);\n+        return Float.toString(_value);\n     }\n \n     @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n     // @since 2.2\n     public void testFloat()\n     {\n-        FloatNode n = FloatNode.valueOf(0.25f);\n+        FloatNode n = FloatNode.valueOf(0.45f);\n         assertStandardEquals(n);\n         assertTrue(0 != n.hashCode());\n         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n         assertEquals(JsonParser.NumberType.FLOAT, n.numberType());\n         assertEquals(0, n.intValue());\n-        assertEquals(0.25, n.doubleValue());\n-        assertEquals(0.25f, n.floatValue());\n+        \n+        // NOTE: conversion to double NOT as simple as with exact numbers like 0.25:\n+        assertEquals(0.45f, n.floatValue());\n+        assertEquals(\"0.45\", n.asText());\n+\n+        // so; as double we'll get more complex number; however, should round-trip\n+        // to something that gets printed the same way. But not exact value, alas, hence:\n+        assertEquals(\"0.45\",  String.valueOf((float) n.doubleValue()));\n+\n         assertNotNull(n.decimalValue());\n+        // possibly surprisingly, however, this will produce same output:\n         assertEquals(BigInteger.ZERO, n.bigIntegerValue());\n-        assertEquals(\"0.25\", n.asText());\n+        assertEquals(\"0.45\", n.asText());\n \n         // 1.6:\n         assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f);", "timestamp": 1424206411, "metainfo": ""}