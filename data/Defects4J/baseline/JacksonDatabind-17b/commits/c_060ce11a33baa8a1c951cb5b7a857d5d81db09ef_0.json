{"sha": "060ce11a33baa8a1c951cb5b7a857d5d81db09ef", "log": "Implemented [JACKSON-776], refactoring of DeserializationContext", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n  * Context for the process of deserialization a single root-level value.\n  * Used to allow passing in configuration settings and reusable temporary\n  * objects (scrap arrays, containers).\n+ *<p>\n+ * Instance life-cycle is such that an partially configured \"blueprint\" object\n+ * is registered with {@link ObjectMapper} (and {@link ObjectReader},\n+ * and when an actual instance is needed for deserialization,\n+ * a fully configured instance will\n+ * be created using {@link #createInstance}.\n+ * Each instance is guaranteed to only be used from single-threaded context;\n+ * instances may be reused iff no configuration has changed.\n+ *<p>\n+ * Defined as abstract class so that implementations must define methods\n+ * for reconfiguring blueprints and creating instances.\n  */\n-public class DeserializationContext\n+public abstract class DeserializationContext\n {\n     /**\n      * Let's limit length of error messages, for cases where underlying data\n      * may be very large -- no point in spamming logs with megs of meaningless\n      * data.\n      */\n-    final static int MAX_ERROR_STR_LEN = 500;\n-\n-    // // // Configuration\n-    \n+    private final static int MAX_ERROR_STR_LEN = 500;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, immutable\n+    /**********************************************************\n+     */\n+    \n+    protected final DeserializerCache _cache;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, changeable via fluent factories\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Read-only factory instance; exposed to let\n+     * owners (<code>ObjectMapper</code>, <code>ObjectReader</code>)\n+     * access it.\n+     */\n+    public final DeserializerFactory _factory;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration that gets set for instances (not blueprints)\n+    /**********************************************************\n+     */\n+\n     protected final DeserializationConfig _config;\n-\n+    \n     protected final int _featureFlags;\n \n     protected final Class<?> _view;\n      * when content is buffered.\n      */\n     protected JsonParser _parser;\n-\n-    protected final DeserializerCache _deserCache;\n-\n-    protected final DeserializerFactory _factory;\n     \n     protected final InjectableValues _injectableValues;\n     \n-    // // // Helper object recycling\n+    /*\n+    /**********************************************************\n+    /* Per-operation reusable helper objects (not for blueprints)\n+    /**********************************************************\n+     */\n \n     protected ArrayBuilders _arrayBuilders;\n \n     /* Life-cycle\n     /**********************************************************\n      */\n-    \n-    public DeserializationContext(DeserializationConfig config, JsonParser jp,\n-            DeserializerCache cache, InjectableValues injectableValues)\n-    {\n+\n+    protected DeserializationContext(DeserializerFactory df) {\n+        this(df, null);\n+    }\n+    \n+    protected DeserializationContext(DeserializerFactory df,\n+            DeserializerCache cache)\n+    {\n+        if (df == null) {\n+            throw new IllegalArgumentException(\"Can not pass null DeserializerFactory\");\n+        }\n+        _factory = df;\n+        _cache = (cache == null) ? new DeserializerCache() : cache;\n+        \n+        _featureFlags = 0;\n+        _config = null;\n+        _injectableValues = null;\n+        _view = null;\n+    }\n+\n+    protected DeserializationContext(DeserializationContext src,\n+            DeserializerFactory factory)\n+    {\n+        _cache = src._cache;\n+        _factory = factory;\n+        \n+        _config = src._config;\n+        _featureFlags = src._featureFlags;\n+        _view = src._view;\n+        _parser = src._parser;\n+        _injectableValues = src._injectableValues;\n+    }\n+    \n+    protected DeserializationContext(DeserializationContext src,\n+            DeserializationConfig config, JsonParser jp,\n+            InjectableValues injectableValues)\n+    {\n+        _cache = src._cache;\n+        _factory = src._factory;\n+        \n         _config = config;\n         _featureFlags = config.getDeserializationFeatures();\n         _view = config.getActiveView();\n         _parser = jp;\n-        _deserCache = cache;\n         _injectableValues = injectableValues;\n-        _factory = cache.getDeserializerFactory();\n-    }\n-\n+    }\n+\n+    /**\n+     * Fluent factory method used for constructing a blueprint instance\n+     * with different factory\n+     */\n+    public abstract DeserializationContext with(DeserializerFactory factory);\n+    \n+    /**\n+     * Method called to create actual usable per-deserialization\n+     * context instance.\n+     */\n+    public abstract DeserializationContext createInstance(DeserializationConfig config,\n+            JsonParser jp, InjectableValues values);\n+    \n     /*\n     /**********************************************************\n     /* Public API, accessors\n     \n     public final AnnotationIntrospector getAnnotationIntrospector() {\n         return _config.getAnnotationIntrospector();\n-    }\n-    \n-    public final DeserializerCache getDeserializerCache() {\n-        return _deserCache;\n     }\n \n     /**\n         return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);\n     }\n \n+    /**\n+     * Accessor for locating currently active view, if any;\n+     * returns null if no view has been set.\n+     */\n     public final Class<?> getActiveView() {\n         return _view;\n     }\n-    \n+\n+    /**\n+     * Convenience method, functionally equivalent to:\n+     *<pre>\n+     *  getConfig().canOverrideAccessModifiers();\n+     * </pre>\n+     */\n     public final boolean canOverrideAccessModifiers() {\n         return _config.canOverrideAccessModifiers();\n     }\n         return _config.getBase64Variant();\n     }\n \n+    /**\n+     * Convenience method, functionally equivalent to:\n+     *<pre>\n+     *  getConfig().getNodeFactory();\n+     * </pre>\n+     */\n     public final JsonNodeFactory getNodeFactory() {\n         return _config.getNodeFactory();\n     }\n \n+    /**\n+     * Convenience method, functionally equivalent to:\n+     *<pre>\n+     *  getConfig().constructType(cls);\n+     * </pre>\n+     */\n     public final JavaType constructType(Class<?> cls) {\n         return _config.constructType(cls);\n     }\n \n+    /**\n+     * Convenience method, functionally equivalent to:\n+     *<pre>\n+     *  getConfig().getTypeFactory();\n+     * </pre>\n+     */\n     public final TypeFactory getTypeFactory() {\n         return _config.getTypeFactory();\n     }\n \n-\n     /*\n     /**********************************************************\n     /* Public API, pass-through to DeserializerCache\n     /**********************************************************\n      */\n \n+    /**\n+     * Method for checking whether we could find a deserializer\n+     * for given type.\n+     */\n+    public boolean hasValueDeserializerFor(JavaType type) {\n+        return _cache.hasValueDeserializerFor(this, _factory, type);\n+    }\n+    \n+    \n     /**\n      * Method for finding a value deserializer, and creating a contextual\n      * version if necessary, for value reached via specified property.\n     public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type,\n             BeanProperty property) throws JsonMappingException\n     {\n-        JsonDeserializer<Object> deser = _deserCache.findValueDeserializer(this, type);\n+        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,\n+                _factory, type);\n         if (deser != null) {\n             if (deser instanceof ContextualDeserializer) {\n                 deser = (JsonDeserializer<Object>)((ContextualDeserializer) deser).createContextual(this, property);\n     public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type)\n             throws JsonMappingException\n     {\n-        JsonDeserializer<Object> deser = _deserCache.findValueDeserializer(this, type);\n+        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,\n+                _factory, type);\n         if (deser == null) { // can this occur?\n             return null;\n         }\n      */\n     public final KeyDeserializer findKeyDeserializer(JavaType keyType,\n             BeanProperty property) throws JsonMappingException {\n-        KeyDeserializer kd = _deserCache.findKeyDeserializer(this, keyType);\n+        KeyDeserializer kd = _cache.findKeyDeserializer(this,\n+                _factory, keyType);\n         // Second: contextualize?\n         if (kd instanceof ContextualKeyDeserializer) {\n             kd = ((ContextualKeyDeserializer) kd).createContextual(this, property);\n      * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s\n      * of an unrecognized property.\n      */\n-    public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName)\n+    public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser,\n+            Object instanceOrClass, String propName)\n         throws IOException, JsonProcessingException\n     {\n         LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n         if (h != null) {\n-            /* 04-Jan-2009, tatu: Ugh. Need to mess with currently active parser\n-             *   since parser is not explicitly passed to handler... that was a mistake\n-             */\n-            JsonParser oldParser = _parser;\n-            _parser = jp;\n-            try {\n-                while (h != null) {\n-                    // Can bail out if it's handled\n-                    if (h.value().handleUnknownProperty(this, deser, instanceOrClass, propName)) {\n-                        return true;\n-                    }\n-                    h = h.next();\n+            while (h != null) {\n+                // Can bail out if it's handled\n+                if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) {\n+                    return true;\n                 }\n-            } finally {\n-                _parser = oldParser;\n+                h = h.next();\n             }\n         }\n         return false;\n         }\n         return desc;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Standard implementation, used if no custom context is\n+     * implemented.\n+     */\n+    public final static class Std extends DeserializationContext\n+    {\n+        /**\n+         * Default constructor for a blueprint object, which will use the standard\n+         * {@link DeserializerCache}, given factory.\n+         */\n+        public Std(DeserializerFactory df) {\n+            this(df, null);\n+        }\n+\n+        /**\n+         * Constructor that will pass specified deserializer factory and\n+         * cache: cache may be null (in which case default implementation\n+         * will be used), factory can not be null\n+         */\n+        public Std(DeserializerFactory df, DeserializerCache cache) {\n+            super(df, cache);\n+        }\n+        \n+        protected Std(Std src, DeserializationConfig config,\n+                JsonParser jp, InjectableValues values) {\n+            super(src, config, jp, values);\n+        }\n+\n+        protected Std(Std src, DeserializerFactory factory) {\n+            super(src, factory);\n+        }\n+        \n+        @Override\n+        public Std createInstance(DeserializationConfig config,\n+                JsonParser jp, InjectableValues values) {\n+            return new Std(this, config, jp, values);\n+        }\n+\n+        @Override\n+        public Std with(DeserializerFactory factory) {\n+            return new Std(this, factory);\n+        }\n+    \n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     protected DeserializationConfig _deserializationConfig;\n \n     /**\n-     * Object that manages access to deserializers used for deserializing\n-     * JSON content into Java objects, including caching\n-     * of the deserializers. It contains a reference to\n-     * {@link DeserializerFactory} to use for constructing acutal deserializers.\n-     */\n-    protected DeserializerCache _deserializerCache;\n+     * Blueprint context object; stored here to allow custom\n+     * sub-classes. Contains references to objects needed for\n+     * deserialization construction (cache, factory).\n+     */\n+    protected DeserializationContext _deserializationContext;\n \n     /*\n     /**********************************************************\n      * \n      * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n      * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n-     * @param dp DeserializerCache to use\n+     * @param dc Blueprint deserialization context instance to use for creating\n+     *    actual context objects; if null, will construct standard\n+     *    {@link DeserializationContext}\n      */\n     public ObjectMapper(JsonFactory jf,\n-            SerializerProvider sp, DeserializerCache dp)\n+            SerializerProvider sp, DeserializationContext dc)\n     {\n         /* 02-Mar-2009, tatu: Important: we MUST default to using\n          *   the mapping factory, otherwise tree serialization will\n         _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _serializerProvider = (sp == null) ? new SerializerProvider.Impl() : sp;\n-        _deserializerCache = (dp == null) ? new DeserializerCache(BeanDeserializerFactory.instance) : dp;\n+        _deserializationContext = (dc == null) ?\n+                new DeserializationContext.Std(BeanDeserializerFactory.instance) : dc;\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n                 return mapper.isEnabled(f);\n             }\n             \n-            // // // Methods for registering handlers: deserializers, serializers\n+            // // // Methods for registering handlers: deserializers\n             \n             @Override\n             public void addDeserializers(Deserializers d) {\n-                mapper._deserializerCache = mapper._deserializerCache.withAdditionalDeserializers(d);\n+                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n+                mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n \n             @Override\n             public void addKeyDeserializers(KeyDeserializers d) {\n-                mapper._deserializerCache = mapper._deserializerCache.withAdditionalKeyDeserializers(d);\n-            }\n+                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n+                mapper._deserializationContext = mapper._deserializationContext.with(df);\n+            }\n+\n+            @Override\n+            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n+                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n+                mapper._deserializationContext = mapper._deserializationContext.with(df);\n+            }\n+            \n+            // // // Methods for registering handlers: serializers\n             \n             @Override\n             public void addSerializers(Serializers s) {\n                 mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n             }\n \n-            @Override\n-            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n-                mapper._deserializerCache = mapper._deserializerCache.withDeserializerModifier(modifier);\n-            }\n-\n             // // // Methods for registering handlers: other\n             \n             @Override\n             public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n-                mapper._deserializerCache = mapper._deserializerCache.withAbstractTypeResolver(resolver);\n+                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n+                mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n \n             @Override\n \n             @Override\n             public void addValueInstantiators(ValueInstantiators instantiators) {\n-                mapper._deserializerCache = mapper._deserializerCache.withValueInstantiators(instantiators);\n+                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n+                mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n             \n             @Override\n      */\n     public boolean canDeserialize(JavaType type)\n     {\n-        DeserializationContext ctxt = createDeserializationContext(null,\n-                getDeserializationConfig());\n-        return _deserializerCache.hasValueDeserializerFor(ctxt, type);\n+        return createDeserializationContext(null,\n+                getDeserializationConfig()).hasValueDeserializerFor(type);\n     }\n \n     /*\n      * for deserializing a single root value.\n      * Can be overridden if a custom context is needed.\n      */\n-    protected DeserializationContext createDeserializationContext(JsonParser jp,\n+    protected final DeserializationContext createDeserializationContext(JsonParser jp,\n             DeserializationConfig cfg)\n     {\n-        return new DeserializationContext(cfg, jp, _deserializerCache,\n-                _injectableValues);\n+        return _deserializationContext.createInstance(cfg,\n+                jp, _injectableValues);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n     protected final DeserializationConfig _config;\n \n     /**\n+     * Blueprint instance of deserialization context; used for creating\n+     * actual instance when needed.\n+     */\n+    protected final DeserializationContext _context;\n+\n+    /**\n+     * Factory used for constructing {@link JsonGenerator}s\n+     */\n+    protected final JsonFactory _jsonFactory;\n+    \n+    /**\n      * Flag that indicates whether root values are expected to be unwrapped or not\n      */\n     protected final boolean _unwrapRoot;\n-    \n-    /**\n-     * Root-level cached deserializers\n-     */\n-    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n-   \n-    protected final DeserializerCache _deserializerCache;\n-\n-    /**\n-     * Factory used for constructing {@link JsonGenerator}s\n-     */\n-    protected final JsonFactory _jsonFactory;\n-\n-    /**\n-     * Cache for root names used when root-wrapping is enabled.\n-     */\n-    protected final RootNameLookup _rootNames;\n     \n     /*\n     /**********************************************************\n      * Values that can be injected during deserialization, if any.\n      */\n     protected final InjectableValues _injectableValues;\n+\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Root-level cached deserializers\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n+\n+    /**\n+     * Cache for root names used when root-wrapping is enabled.\n+     */\n+    protected final RootNameLookup _rootNames;\n     \n     /*\n     /**********************************************************\n             InjectableValues injectableValues)\n     {\n         _config = config;\n+        _context = mapper._deserializationContext;\n         _rootDeserializers = mapper._rootDeserializers;\n-        _deserializerCache = mapper._deserializerCache;\n         _jsonFactory = mapper._jsonFactory;\n         _rootNames = mapper._rootNames;\n         _valueType = valueType;\n             InjectableValues injectableValues)\n     {\n         _config = config;\n+        _context = base._context;\n \n         _rootDeserializers = base._rootDeserializers;\n-        _deserializerCache = base._deserializerCache;\n         _jsonFactory = base._jsonFactory;\n         _rootNames = base._rootNames;\n \n     protected ObjectReader(ObjectReader base, DeserializationConfig config)\n     {\n         _config = config;\n+        _context = base._context;\n \n         _rootDeserializers = base._rootDeserializers;\n-        _deserializerCache = base._deserializerCache;\n         _jsonFactory = base._jsonFactory;\n         _rootNames = base._rootNames;\n \n     \n     /*\n     /**********************************************************\n-    /* Helper methods, overridable\n+    /* Helper methods\n     /**********************************************************\n      */\n \n      * for deserializing a single root value.\n      * Can be overridden if a custom context is needed.\n      */\n-    protected DeserializationContext createDeserializationContext(JsonParser jp,\n+    protected final DeserializationContext createDeserializationContext(JsonParser jp,\n             DeserializationConfig cfg) {\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n-        return new DeserializationContext(cfg, jp, _deserializerCache, _injectableValues);\n+        return _context.createInstance(cfg, jp, _injectableValues);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n \n import java.io.IOException;\n \n+import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n      *   has been instantiated so far); or Class that indicates type that\n      *   will be instantiated (if no instantiation done yet: for example\n      *   when bean uses non-default constructors)\n+     * @param jp Parser to use for handling problematic content\n      * \n      * @return True if the problem was succesfully resolved (and content available\n      *    used or skipped); false if listen\n      */\n-    public boolean handleUnknownProperty(DeserializationContext ctxt, JsonDeserializer<?> deserializer,\n-                                         Object beanOrClass, String propertyName)\n+    public boolean handleUnknownProperty(DeserializationContext ctxt, JsonParser jp,\n+            JsonDeserializer<?> deserializer, Object beanOrClass, String propertyName)\n         throws IOException, JsonProcessingException\n     {\n         return false;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Class that defines caching layer between callers (like\n+ * {@link ObjectMapper},\n+ * {@link com.fasterxml.jackson.databind.DeserializationContext})\n+ * and classes that construct deserializers\n+ * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n+ */\n+public final class DeserializerCache\n+{\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will also cache some dynamically constructed deserializers;\n+     * specifically, ones that are expensive to construct.\n+     * This currently means bean and Enum deserializers; array, List and Map\n+     * deserializers will not be cached.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+\n+    /**\n+     * During deserializer construction process we may need to keep track of partially\n+     * completed deserializers, to resolve cyclic dependencies. This is the\n+     * map used for storing deserializers before they are fully complete.\n+     */\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public DeserializerCache() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Access to caching aspects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many deserializers this\n+     * provider is caching currently \n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of deserializers get cached;\n+     * default implementation caches only dynamically constructed deserializers,\n+     * but not eagerly constructed standard deserializers (which is different\n+     * from how serializer provider works).\n+     *<p>\n+     * The main use case for this method is to allow conditional flushing of\n+     * deserializer cache, if certain number of entries is reached.\n+     */\n+    public int cachedDeserializersCount() {\n+        return _cachedDeserializers.size();\n+    }\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     */\n+    public void flushCachedDeserializers() {\n+        _cachedDeserializers.clear();       \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General deserializer locating method\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a deserializer for a value of given type;\n+     * or if no such deserializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for value types; not for keys.\n+     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *<p>\n+     * Note also that deserializer returned is guaranteed to be resolved\n+     * (if it is of type {@link ResolvableDeserializer}), but\n+     * not contextualized (wrt {@link ContextualDeserializer}): caller\n+     * has to handle latter if necessary.\n+     *\n+     * @param ctxt Deserialization context\n+     * @param propertyType Declared type of the value to deserializer (obtained using\n+     *   'setter' method signature and/or type annotations\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType propertyType)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, need to request factory to construct (or recycle)\n+        deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n+        if (deser == null) {\n+            /* Should we let caller handle it? Let's have a helper method\n+             * decide it; can throw an exception, or return a valid\n+             * deserializer\n+             */\n+            deser = _handleUnknownValueDeserializer(propertyType);\n+        }\n+        return deser;\n+    }\n+\n+    /**\n+     * Method called to get hold of a deserializer to use for deserializing\n+     * keys for {@link java.util.Map}.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable key deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n+        if (kd == null) { // if none found, need to use a placeholder that'll fail\n+            return _handleUnknownKeyDeserializer(type);\n+        }\n+        // First: need to resolve?\n+        if (kd instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) kd).resolve(ctxt);\n+        }\n+        return kd;\n+    }\n+\n+    /**\n+     * Method called to find out whether provider would be able to find\n+     * a deserializer for given type, using a root reference (i.e. not\n+     * through fields or membership in an array or collection)\n+     */\n+    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+    {\n+        /* Note: mostly copied from findValueDeserializer, except for\n+         * handling of unknown types\n+         */\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+        if (deser == null) {\n+            try {\n+                deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return (deser != null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods that handle cache lookups\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Null JavaType passed\");\n+        }\n+        return _cachedDeserializers.get(type);\n+    }\n+\n+    /**\n+     * Method that will try to create a deserializer for given type,\n+     * and resolve and cache it if necessary\n+     * \n+     * @param config Configuration\n+     * @param type Type of property to deserializer\n+     * @param property Property (field, setter, ctor arg) to use deserializer for\n+     */\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Only one thread to construct deserializers at any given point in time;\n+         * limitations necessary to ensure that only completely initialized ones\n+         * are visible and used.\n+         */\n+        synchronized (_incompleteDeserializers) {\n+            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n+            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+            if (deser != null) {\n+                return deser;\n+            }\n+            int count = _incompleteDeserializers.size();\n+            // Or perhaps being resolved right now?\n+            if (count > 0) {\n+                deser = _incompleteDeserializers.get(type);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+            // Nope: need to create and possibly cache\n+            try {\n+                return _createAndCache2(ctxt, factory, type);\n+            } finally {\n+                // also: any deserializers that have been created are complete by now\n+                if (count == 0 && _incompleteDeserializers.size() > 0) {\n+                    _incompleteDeserializers.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that handles actual construction (via factory) and caching (both\n+     * intermediate and eventual)\n+     */\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser;\n+        try {\n+            deser = _createDeserializer(ctxt, factory, type);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+        if (deser == null) {\n+            return null;\n+        }\n+        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n+         * (but can be re-defined for sub-classes by using @JsonCachable!)\n+         */\n+        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n+        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n+        boolean addToCache = deser.isCachable();\n+\n+        /* we will temporarily hold on to all created deserializers (to\n+         * handle cyclic references, and possibly reuse non-cached\n+         * deserializers (list, map))\n+         */\n+        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n+         *   resolution of a reference -- couple of ways to prevent this;\n+         *   either not add Lists or Maps, or clear references eagerly.\n+         *   Let's actually do both; since both seem reasonable.\n+         */\n+        /* Need to resolve? Mostly done for bean deserializers; required for\n+         * resolving cyclic references.\n+         */\n+        if (isResolvable) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer)deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n+        if (addToCache) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for actual construction of deserializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that does the heavy lifting of checking for per-type annotations,\n+     * find out full type, and figure out which actual factory method\n+     * to call.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        // First things first: do we need to use abstract type mapping?\n+        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n+            type = factory.mapAbstractType(config, type);\n+        }\n+        BeanDescription beanDesc = config.introspect(type);\n+        // Then: does type define explicit deserializer to use, with annotation(s)?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n+                beanDesc.getClassInfo());\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // If not, may have further type-modification annotations to check:\n+        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n+        if (newType != type) {\n+            type = newType;\n+            beanDesc = config.introspect(newType);\n+        }\n+\n+        // If not, let's see which factory method to use:\n+        if (type.isEnumType()) {\n+            return (JsonDeserializer<Object>) factory.createEnumDeserializer(ctxt,\n+                    type, beanDesc);\n+        }\n+        if (type.isContainerType()) {\n+            if (type.isArrayType()) {\n+                return (JsonDeserializer<Object>) factory.createArrayDeserializer(ctxt,\n+                        (ArrayType) type, beanDesc);\n+            }\n+            if (type.isMapLikeType()) {\n+                MapLikeType mlt = (MapLikeType) type;\n+                if (mlt.isTrueMapType()) {\n+                    return (JsonDeserializer<Object>) factory.createMapDeserializer(ctxt,\n+                            (MapType) mlt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createMapLikeDeserializer(ctxt,\n+                        mlt, beanDesc);\n+            }\n+            if (type.isCollectionLikeType()) {\n+                CollectionLikeType clt = (CollectionLikeType) type;\n+                if (clt.isTrueCollectionType()) {\n+                    return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n+                            (CollectionType) clt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n+                        clt, beanDesc);\n+            }\n+        }\n+\n+        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n+        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n+            return (JsonDeserializer<Object>) factory.createTreeDeserializer(config, type, beanDesc);\n+        }\n+        return (JsonDeserializer<Object>) factory.createBeanDeserializer(ctxt, type, beanDesc);\n+    }\n+\n+    /**\n+     * Helper method called to check if a class or method\n+     * has annotation that tells which class to use for deserialization.\n+     * Returns null if no such annotation found.\n+     */\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n+            Annotated ann)\n+        throws JsonMappingException\n+    {\n+        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        return ctxt.deserializerInstance(ann, deserDef);\n+    }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, JavaType type)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type);\n+        if (subclass != null) {\n+            try {\n+                type = type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                    if (kd != null) {\n+                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n+                }\n+            }            \n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n+            if (cc != null) {\n+                try {\n+                    type = type.narrowContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            // ... as well as deserializer for contents:\n+            JavaType contentType = type.getContentType();\n+            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+                Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = ctxt.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = type.withContentValueHandler(cd);\n+                    }\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable error reporting methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Let's try to figure out the reason, to give better error\n+         * messages\n+         */\n+        Class<?> rawClass = type.getRawClass();\n+        if (!ClassUtil.isConcrete(rawClass)) {\n+            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n+        }\n+        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n+    }\n+\n+    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n      */\n     private ReadOnlyClassToSerializerMap _readOnlyMap = null;\n \n-    public SerializerCache() {\n-    }\n+    public SerializerCache() { }\n \n     /**\n      * Method that can be called to get a read-only instance populated from the\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(0, mapper._deserializerCache.cachedDeserializersCount());\n+        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n         Bean bean = mapper.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n         assertNotNull(bean);\n-        assertEquals(1, mapper._deserializerCache.cachedDeserializersCount());\n-        mapper._deserializerCache.flushCachedDeserializers();\n-        assertEquals(0, mapper._deserializerCache.cachedDeserializersCount());\n+        assertEquals(1, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        mapper._deserializationContext._cache.flushCachedDeserializers();\n+        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n         extends DeserializationProblemHandler\n     {\n         @Override\n-        public boolean handleUnknownProperty(DeserializationContext ctxt, JsonDeserializer<?> deserializer,\n-                                             Object bean, String propertyName)\n+        public boolean handleUnknownProperty(DeserializationContext ctxt,\n+                JsonParser jp, JsonDeserializer<?> deserializer,\n+                Object bean, String propertyName)\n             throws IOException, JsonProcessingException\n         {\n-            JsonParser jp = ctxt.getParser();\n             // very simple, just to verify that we do see correct token type\n             ((TestBean) bean).markUnknown(propertyName+\":\"+jp.getCurrentToken().toString());\n             // Yup, we are good to go; must skip whatever value we'd have:", "timestamp": 1328163489, "metainfo": ""}