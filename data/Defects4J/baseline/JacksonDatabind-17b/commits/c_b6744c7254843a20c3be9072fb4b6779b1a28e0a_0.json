{"sha": "b6744c7254843a20c3be9072fb4b6779b1a28e0a", "log": "trying to optimize allocation for lists, maps", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n     {\n         // Minor optimization to handle small lists (default size for ArrayList is 10)\n         if (jp.nextToken()  == JsonToken.END_ARRAY) {\n-            return new ArrayList<Object>(4);\n+            return new ArrayList<Object>(2);\n+        }\n+        Object value = deserialize(jp, ctxt);\n+        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n+            ArrayList<Object> l = new ArrayList<Object>(2);\n+            l.add(value);\n+            return l;\n         }\n         ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n         Object[] values = buffer.resetAndStart();\n         int ptr = 0;\n-        int totalSize = 0;\n+        values[ptr++] = value;\n+        int totalSize = ptr;\n         do {\n-            Object value = deserialize(jp, ctxt);\n+            value = deserialize(jp, ctxt);\n             ++totalSize;\n             if (ptr >= values.length) {\n                 values = buffer.appendCompletedChunk(values);\n             }\n             values[ptr++] = value;\n         } while (jp.nextToken() != JsonToken.END_ARRAY);\n-        // let's create almost full array, with 1/8 slack\n-        ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1);\n+        // let's create full array then\n+        ArrayList<Object> result = new ArrayList<Object>(totalSize);\n         buffer.completeAndClearBuffer(values, ptr, result);\n         return result;\n     }\n         if (t == JsonToken.START_OBJECT) {\n             t = jp.nextToken();\n         }\n-        // 1.6: minor optimization; let's handle 1 and 2 entry cases separately\n-        if (t != JsonToken.FIELD_NAME) { // and empty one too\n+        // minor optimization; let's handle 1 and 2 entry cases separately\n+        if (t == JsonToken.END_OBJECT) { // and empty one too\n             // empty map might work; but caller may want to modify... so better just give small modifiable\n-            return new LinkedHashMap<String,Object>(4);\n+            return new LinkedHashMap<String,Object>(2);\n         }\n         String field1 = jp.getText();\n         jp.nextToken();\n         Object value1 = deserialize(jp, ctxt);\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) { // single entry; but we want modifiable\n-            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n+        if (jp.nextToken() == JsonToken.END_OBJECT) { // single entry; but we want modifiable\n+            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n             result.put(field1, value1);\n             return result;\n         }\n         String field2 = jp.getText();\n         jp.nextToken();\n         Object value2 = deserialize(jp, ctxt);\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+        if (jp.nextToken() == JsonToken.END_OBJECT) {\n             LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n             result.put(field1, value1);\n             result.put(field2, value2);", "timestamp": 1398032987, "metainfo": ""}