{"sha": "d5fc827d5bb9ed8d48780ca092f146376dc5a7ef", "log": "Fix #119 for 2.2", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializerWrapper.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+\n+/**\n+ * Helper class used in cases where we caller has to override source\n+ * for type identifier, for example when serializing a value using\n+ * a delegate or surrogate value, in which case type id is to be based\n+ * on the original value, but serialization done using surrogate.\n+ * \n+ * @since 2.2\n+ */\n+public class TypeSerializerWrapper\n+    extends TypeSerializer\n+{\n+    /**\n+     * Actual TypeSerializer to use\n+     */\n+    protected final TypeSerializer _delegate;\n+\n+    protected final Object _value;\n+    \n+    public TypeSerializerWrapper(TypeSerializer delegate, Object value)\n+    {\n+        _delegate = delegate;\n+        _value = value;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* TypeSerializer implementation, metadata\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public TypeSerializer forProperty(BeanProperty prop) {\n+        TypeSerializer d2 = _delegate.forProperty(prop);\n+        if (d2 == _delegate) {\n+            return this;\n+        }\n+        return new TypeSerializerWrapper(d2, _value);\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() {\n+        return _delegate.getTypeInclusion();\n+    }\n+\n+    @Override\n+    public String getPropertyName() {\n+        return _delegate.getPropertyName();\n+    }\n+\n+    @Override\n+    public TypeIdResolver getTypeIdResolver() {\n+        return _delegate.getTypeIdResolver();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* TypeSerializer implementation, actual write methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypePrefixForScalar(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypePrefixForObject(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypePrefixForArray(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypeSuffixForScalar(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypeSuffixForObject(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException {\n+        _delegate.writeTypeSuffixForArray(_value, jgen);\n+    }\n+\n+    @Override\n+    public void writeCustomTypePrefixForScalar(Object value,\n+            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {\n+        _delegate.writeCustomTypePrefixForScalar(_value, jgen, typeId);\n+    }\n+\n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value,\n+            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {\n+        _delegate.writeCustomTypePrefixForObject(_value, jgen, typeId);\n+    }\n+\n+    @Override\n+    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen,\n+            String typeId) throws IOException, JsonProcessingException {\n+        _delegate.writeCustomTypePrefixForArray(_value, jgen, typeId);\n+    }\n+\n+    @Override\n+    public void writeCustomTypeSuffixForScalar(Object value,\n+            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {\n+        _delegate.writeCustomTypeSuffixForScalar(_value, jgen, typeId);\n+    }\n+\n+    @Override\n+    public void writeCustomTypeSuffixForObject(Object value,\n+            JsonGenerator jgen, String typeId) throws IOException,\n+            JsonProcessingException {\n+        _delegate.writeCustomTypeSuffixForObject(_value, jgen, typeId);\n+    }\n+\n+    @Override\n+    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen,\n+            String typeId) throws IOException, JsonProcessingException {\n+        _delegate.writeCustomTypeSuffixForArray(_value, jgen, typeId);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n      * @param type The type for which to generate schema\n      */\n     @SuppressWarnings(\"deprecation\")\n-    public JsonSchema generateJsonSchema(Class<?> type)\n+    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type)\n         throws JsonMappingException\n     {\n         if (type == null) {\n          */\n         JsonSerializer<Object> ser = findValueSerializer(type, null);\n         JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                ((SchemaAware) ser).getSchema(this, null) : JsonSchema.getDefaultSchemaNode();\n+                ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n         if (!(schemaNode instanceof ObjectNode)) {\n             throw new IllegalArgumentException(\"Class \" + type.getName()\n                     +\" would not be serialized as a JSON object and therefore has no schema\");\n         }\n-        return new JsonSchema((ObjectNode) schemaNode);\n+        return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializerWrapper;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n     public JsonValueSerializer(JsonValueSerializer src, BeanProperty property,\n             JsonSerializer<?> ser, boolean forceTypeInfo)\n     {\n-        super(Object.class);\n+        super(_notNullClass(src.handledType()));\n         _accessorMethod = src._accessorMethod;\n         _valueSerializer = (JsonSerializer<Object>) ser;\n         _property = property;\n         _forceTypeInformation = forceTypeInfo;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    private final static Class<Object> _notNullClass(Class<?> cls) {\n+        return (cls == null) ? Object.class : (Class<Object>) cls;\n+    }\n+    \n     public JsonValueSerializer withResolved(BeanProperty property,\n             JsonSerializer<?> ser, boolean forceTypeInfo)\n     {\n \n     @Override\n     public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n+            TypeSerializer typeSer0)\n         throws IOException, JsonProcessingException\n     {\n         // Regardless of other parts, first need to find value to serialize:\n                  *    this (note: type is for the wrapper type, not enclosed value!)\n                  */\n                 if (_forceTypeInformation) {\n-                    typeSer.writeTypePrefixForScalar(bean, jgen);\n+                    typeSer0.writeTypePrefixForScalar(bean, jgen);\n                 } \n-                ser.serializeWithType(value, jgen, provider, typeSer);\n+                ser.serializeWithType(value, jgen, provider, typeSer0);\n                 if (_forceTypeInformation) {\n-                    typeSer.writeTypeSuffixForScalar(bean, jgen);\n+                    typeSer0.writeTypeSuffixForScalar(bean, jgen);\n                 } \n                 return;\n             }\n             Class<?> c = value.getClass();\n             ser = provider.findTypedValueSerializer(c, true, _property);\n             // note: now we have bundled type serializer, so should NOT call with typed version\n-            ser.serialize(value, jgen, provider);\n+            TypeSerializer typeSer = new TypeSerializerWrapper(typeSer0, bean);\n+            ser.serializeWithType(value, jgen, provider, typeSer);\n         } catch (IOException ioe) {\n             throw ioe;\n         } catch (Exception e) {\n     {\n         return (_valueSerializer instanceof SchemaAware) ?\n                 ((SchemaAware) _valueSerializer).getSchema(provider, null) :\n-                JsonSchema.getDefaultSchemaNode();\n+                    com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n     }\n     \n     @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n                 defaultImpl = String.class)\n         @JsonSubTypes({\n             @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n-            @JsonSubTypes.Type(value = String.class, name = \"\")\n+            @JsonSubTypes.Type(value = AsValueThingy.class, name = \"thingy\")\n         })\n         public Object value;\n \n \n     // for [Issue#119]\n     static class AsValueThingy {\n-        public int stuff = 3;\n-        \n-        @JsonValue public int serialization() {\n-            return stuff+1;\n+        public long rawDate;\n+\n+        public AsValueThingy(long l) { rawDate = l; }\n+        public AsValueThingy() { }\n+        \n+        @JsonValue public Date serialization() {\n+            return new Date(rawDate);\n         }\n     }\n     \n     // For [Issue#119]\n     public void testWithAsValue() throws Exception\n     {\n-        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy());\n+        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));\n         String json = MAPPER.writeValueAsString(input);\n         assertNotNull(json);\n-        String className = getClass().getSimpleName() + \"$\" + AsValueThingy.class.getSimpleName();\n-        assertEquals(json, \"{\\\"value\\\":4,\\\"type\\\":\\\"\"+className+\"\\\"}\");\n+        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n+\n+        // and get it back too:\n+        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(AsValueThingy.class, result.value.getClass());\n+        assertEquals(12345L, ((AsValueThingy) result.value).rawDate);\n     }\n }", "timestamp": 1354596647, "metainfo": ""}