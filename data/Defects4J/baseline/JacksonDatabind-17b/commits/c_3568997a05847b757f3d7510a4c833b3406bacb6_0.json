{"sha": "3568997a05847b757f3d7510a4c833b3406bacb6", "log": "yet more refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n-    public final static AtomicBooleanDeserializer instance = new AtomicBooleanDeserializer();\n+    public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n \n-    public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n-    \n     @Override\n     public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        // 16-Dec-2010, tatu: Should we actually convert null to null AtomicBoolean?\n         return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt));\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n         this(referencedType, null, null);\n     }\n     \n-    public AtomicReferenceDeserializer(JavaType referencedType,\n-            TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n+    public AtomicReferenceDeserializer(JavaType referencedType, TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super(AtomicReference.class);\n         _referencedType = referencedType;\n         _valueTypeDeserializer = typeDeser;\n     }\n \n-    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser,\n-            JsonDeserializer<?> valueDeser)\n-    {\n-        return new AtomicReferenceDeserializer(_referencedType,\n-                typeDeser, valueDeser);\n+    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {\n+        return new AtomicReferenceDeserializer(_referencedType, typeDeser, valueDeser);\n     }\n     \n     // Added in 2.3\n     }\n \n     @Override\n-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-            BeanProperty property) throws JsonMappingException\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n     {\n         JsonDeserializer<?> deser = _valueDeserializer;\n         TypeDeserializer typeDeser = _valueTypeDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ByteBufferDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ByteBufferDeserializer.java\n     protected ByteBufferDeserializer() { super(ByteBuffer.class); }\n \n     @Override\n-    public ByteBuffer deserialize(JsonParser parser, DeserializationContext cx)\n-        throws IOException, JsonProcessingException\n-    {\n+    public ByteBuffer deserialize(JsonParser parser, DeserializationContext cx) throws IOException {\n         byte[] b = parser.getBinaryValue();\n         return ByteBuffer.wrap(b);\n     }\n \n     @Override\n-    public ByteBuffer deserialize(JsonParser jp, DeserializationContext ctxt,\n-            ByteBuffer intoValue)\n-        throws IOException, JsonProcessingException\n-    {\n+    public ByteBuffer deserialize(JsonParser jp, DeserializationContext ctxt, ByteBuffer intoValue) throws IOException {\n         // Let's actually read in streaming manner...\n         OutputStream out = new ByteBufferBackedOutputStream(intoValue);\n         jp.readBinaryValue(ctxt.getBase64Variant(), out);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CharsetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CharsetDeserializer.java\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n-public class CharsetDeserializer\n-    extends FromStringDeserializer<Charset>\n+public class CharsetDeserializer extends FromStringDeserializer<Charset>\n {\n     private static final long serialVersionUID = 1L;\n \n     public CharsetDeserializer() { super(Charset.class); }\n \n     @Override\n-    protected Charset _deserialize(String value, DeserializationContext ctxt)\n-        throws IOException\n-    {\n+    protected Charset _deserialize(String value, DeserializationContext ctxt) throws IOException {\n         return Charset.forName(value);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n @JacksonStdImpl\n-public class ClassDeserializer\n-    extends StdScalarDeserializer<Class<?>>\n+public class ClassDeserializer extends StdScalarDeserializer<Class<?>>\n {\n     private static final long serialVersionUID = 1L;\n-\n-    public final static ClassDeserializer instance = new ClassDeserializer();\n     \n     public ClassDeserializer() { super(Class.class); }\n \n     @Override\n-    public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         JsonToken curr = jp.getCurrentToken();\n         // Currently will only accept if given simple class name\n         if (curr == JsonToken.VALUE_STRING) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n             return new CharsetDeserializer();\n         }\n         if (rawType == Class.class) {\n-            return ClassDeserializer.instance;\n+            return new ClassDeserializer();\n         }\n         if (rawType == StackTraceElement.class) {\n-            return StackTraceElementDeserializer.instance;\n+            return new StackTraceElementDeserializer();\n         }\n         if (rawType == AtomicBoolean.class) {\n             // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n-            return AtomicBooleanDeserializer.instance;\n+            return new AtomicBooleanDeserializer();\n         }\n         if (rawType == ByteBuffer.class) {\n             return new ByteBufferDeserializer();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n+\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonMappingException;\n \n {\n     private static final long serialVersionUID = 1L;\n \n-    public final static StackTraceElementDeserializer instance = new StackTraceElementDeserializer();\n-\n     public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n \n     @Override\n-    public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         // Must get an Object\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n      */\n     \n     @Override\n-    public Class<?> handledType() {\n-        return _valueClass;\n-    }\n+    public Class<?> handledType() { return _valueClass; }\n     \n     /*\n     /**********************************************************\n      * this method if they are to handle type information.\n      */\n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n+        throws IOException\n     {\n         return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n      */\n \n     protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) {\n     }\n \n     protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) {\n     }\n \n     protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+            throws IOException\n     {\n         if (jp.getNumberType() == NumberType.LONG) {\n             return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;\n     }\n \n     protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n     }\n     \n     protected Short _parseShort(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n     }\n \n     protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         int value = _parseIntPrimitive(jp, ctxt);\n         // So far so good: but does it fit?\n     }\n     \n     protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n \n     }\n \n     protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n         throw ctxt.mappingException(_valueClass, t);\n     }\n \n-    protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n     \n     }\n \n     protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n     }\n     \n     protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // We accept couple of different types; obvious ones first:\n         JsonToken t = jp.getCurrentToken();\n     }\n \n     protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         \n     }\n \n     protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         \n     }\n \n     protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // We accept couple of different types; obvious ones first:\n         JsonToken t = jp.getCurrentToken();\n     }\n \n     protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n      * @since 2.1\n      */\n     protected final String _parseString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         String value = jp.getValueAsString();\n         if (value != null) {\n      *   If null, will assume type is what {@link #getValueClass} returns.\n      * @param propName Name of the property that can not be mapped\n      */\n-    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,\n-            Object instanceOrClass, String propName)\n-        throws IOException, JsonProcessingException\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName)\n+        throws IOException\n     {\n         if (instanceOrClass == null) {\n             instanceOrClass = handledType();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n-    protected StdScalarDeserializer(Class<?> vc) {\n-        super(vc);\n-    }\n-\n-    protected StdScalarDeserializer(JavaType valueType) {\n-        super(valueType);\n-    }\n+    protected StdScalarDeserializer(Class<?> vc) { super(vc); }\n+    protected StdScalarDeserializer(JavaType valueType) { super(valueType); }\n     \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n         return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n     }\n }", "timestamp": 1388559018, "metainfo": ""}