{"sha": "3829949e6b248e9df27775e78ce30ff4758d6f38", "log": "Merge pull request #464 from q3aiml/location-in-more-errors  include JsonLocation in more mapping exceptions", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n      * null or empty List.\n      */\n     public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\"; no default creator found\");\n     }\n \n      * a non-empty List of arguments.\n      */\n     public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" with arguments\");\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" with arguments\");\n     }\n \n     /**\n      * an intermediate \"delegate\" value to pass to createor method\n      */\n     public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" using delegate\");\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" using delegate\");\n     }\n     \n     /*\n     }\n \n     public Object createFromInt(DeserializationContext ctxt, int value) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", int)\");\n     }\n \n     public Object createFromLong(DeserializationContext ctxt, long value) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", long)\");\n     }\n \n     public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Floating-point number (\"+value+\", double)\");\n     }\n     \n     public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Boolean value (\"+value+\")\");\n     }\n \n                 return null;\n             }\n         }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n                 +\" from String value ('\"+value+\"'); no single-String constructor/factory method\");\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n         } catch (ExceptionInInitializerError e) {\n             throw wrapException(e);\n         }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n                 +\" from Integral number (\"+value+\"); no single-int-arg constructor/factory method\");\n     }\n \n         } catch (ExceptionInInitializerError e) {\n             throw wrapException(e);\n         }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n                 +\" from Long integral number (\"+value+\"); no single-long-arg constructor/factory method\");\n     }\n \n         } catch (ExceptionInInitializerError e) {\n             throw wrapException(e);\n         }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n                 +\" from Floating-point number (\"+value+\"); no one-double/Double-arg constructor/factory method\");\n     }\n \n         } catch (ExceptionInInitializerError e) {\n             throw wrapException(e);\n         }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+        throw ctxt.mappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n                 +\" from Boolean value (\"+value+\"); no single-boolean/Boolean-arg constructor/factory method\");\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n         public CtorValueBean(String d) { _desc = d; }\n         public CtorValueBean(int value) { _desc = String.valueOf(value); }\n         public CtorValueBean(long value) { _desc = String.valueOf(value); }\n+        public CtorValueBean(double value) { _desc = String.valueOf(value); }\n \n         @Override\n         public void serialize(JsonGenerator jgen, SerializerProvider provider)\n         public static FactoryValueBean valueOf(long v) { return new FactoryValueBean(String.valueOf(v), 0); }\n \n         @Override public String toString() { return _desc; }\n+    }\n+\n+    static class OtherBean {\n+        SomeIncompatibleType o;\n+\n+        protected OtherBean(SomeIncompatibleType o) {\n+            this.o = o;\n+        }\n+\n+        static class SomeIncompatibleType { }\n     }\n \n     /**\n     {\n         CtorValueBean result = MAPPER.readValue(\"13\", CtorValueBean.class);\n         assertEquals(\"13\", result.toString());\n+\n+        try {\n+            OtherBean otherResult = MAPPER.readValue(\"13\", OtherBean.class);\n+            fail(\"Expected an exception, but got result value: \"+otherResult.o);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"from Integral number\", \"no single-int-arg constructor/factory method\");\n+            assertValidLocation(e.getLocation());\n+        }\n     }\n \n     public void testFromLongCtor() throws Exception\n         long value = 12345678901244L;\n         CtorValueBean result = MAPPER.readValue(\"\"+value, CtorValueBean.class);\n         assertEquals(\"\"+value, result.toString());\n+\n+        try {\n+            OtherBean otherResult = MAPPER.readValue(\"\"+value, OtherBean.class);\n+            fail(\"Expected an exception, but got result value: \"+otherResult.o);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"from Long integral number\", \"no single-long-arg constructor/factory method\");\n+            assertValidLocation(e.getLocation());\n+        }\n+    }\n+\n+    public void testFromDoubleCtor() throws Exception\n+    {\n+        CtorValueBean result = MAPPER.readValue(\"13.5\", CtorValueBean.class);\n+        assertEquals(\"13.5\", result.toString());\n+\n+        try {\n+            OtherBean otherResult = MAPPER.readValue(\"13.5\", OtherBean.class);\n+            fail(\"Expected an exception, but got result value: \"+otherResult.o);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"from Floating-point number\", \"no one-double/Double-arg constructor/factory method\");\n+            assertValidLocation(e.getLocation());\n+        }\n     }\n \n     public void testFromStringFactory() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n             fail(\"Should not accept Empty String for POJO\");\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"from String value\");\n+            assertValidLocation(e.getLocation());\n         }\n \n         // should be ok to enable dynamically:\n--- a/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n         }\n     }\n \n+    protected void assertValidLocation(JsonLocation location) {\n+        assertNotNull(\"Should have non-null location\", location);\n+        assertTrue(\"Should have positive line number\", location.getLineNr() > 0);\n+    }\n+\n     protected void verifyException(Throwable e, String... matches)\n     {\n         String msg = e.getMessage();\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n     public abstract String asText();\n \n     /**\n+     * Method similar to {@link #asText()}, except that it will return\n+     * <code>defaultValue</code> in cases where null value would be returned;\n+     * either for missing nodes (trying to access missing property, or element\n+     * at invalid item for array) or explicit nulls.\n+     * \n+     * @since 2.4\n+     */\n+    public String asText(String defaultValue) {\n+        String str = asText();\n+        return (str == null) ? defaultValue : str;\n+    }\n+    \n+    /**\n      * Method that will try to convert value of this node to a Java <b>int</b>.\n      * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n      * and 1 (true), and Strings are parsed using default Java language integer\n     public int asInt() {\n         return asInt(0);\n     }\n-    \n+\n     /**\n      * Method that will try to convert value of this node to a Java <b>int</b>.\n      * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         }\n         // Is there an annotation that specifies exact deserializer?\n         JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n-        // As per [Issue#462] need to ensure we contextualize deserializer too\n-        if (deser != null) {\n-            deser = ctxt.handlePrimaryContextualization(deser, property);\n-        }\n-        \n+\n         // If yes, we are mostly done:\n         type = modifyTypeByAnnotation(ctxt, param, type);\n \n                 typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                 metadata);\n         if (deser != null) {\n+            // As per [Issue#462] need to ensure we contextualize deserializer before passing it on\n+            deser = ctxt.handlePrimaryContextualization(deser, prop);\n             prop = prop.withValueDeserializer(deser);\n         }\n         return prop;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n \n     public boolean couldDeserialize() { return getMutator() != null; }\n     public boolean couldSerialize() { return getAccessor() != null; }\n-    \n+\n     /*\n     /**********************************************************\n     /* Access to accessors (fields, methods etc)\n     /**********************************************************\n      */\n-    \n+\n     public abstract boolean hasGetter();\n     public abstract boolean hasSetter();\n     public abstract boolean hasField();\n     public abstract boolean hasConstructorParameter();\n-    \n+\n     public abstract AnnotatedMethod getGetter();\n     public abstract AnnotatedMethod getSetter();\n     public abstract AnnotatedField getField();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n     /* Life-cycle\n     /**********************************************************\n      */\n-    \n+\n     protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization,\n             JavaType type, AnnotatedClass classDef, String mutatorPrefix)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n     /* BeanPropertyDefinition implementation, accessor access\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean hasGetter() { return _getters != null; }\n \n \n     @Override\n     public boolean hasConstructorParameter() { return _ctorParameters != null; }\n+\n+    @Override\n+    public boolean couldDeserialize() {\n+        return (_ctorParameters != null) || (_setters != null) || (_fields != null);\n+    }\n \n     @Override\n     public boolean couldSerialize() {\n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n-     *   this method simply passes 'true' for it.\n+     *   this method assumes the name is explicit if it is non-null.\n      */\n     @Deprecated\n     public void addField(AnnotatedField a, String name, boolean visible, boolean ignored) {\n-        addField(a, _propName(name), true, visible, ignored);\n+        addField(a, _propName(name), name != null, visible, ignored);\n     }\n \n     @Deprecated\n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n-     *   this method simply passes 'true' for it.\n+     *   this method assumes the name is explicit if it is non-null.\n      */\n     @Deprecated\n     public void addCtor(AnnotatedParameter a, String name, boolean visible, boolean ignored) {\n-        addCtor(a, _propName(name), true, visible, ignored);\n+        addCtor(a, _propName(name), name != null, visible, ignored);\n     }\n     @Deprecated\n     public void addCtor(AnnotatedParameter a, String name, boolean explName, boolean visible, boolean ignored) {\n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n-     *   this method simply passes 'true' for it.\n+     *   this method assumes the name is explicit if it is non-null.\n      */\n     @Deprecated\n     public void addGetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n-        addGetter(a, _propName(name), true, visible, ignored);\n+        addGetter(a, _propName(name), name != null, visible, ignored);\n     }\n     @Deprecated\n     public void addGetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n-     *   this method simply passes 'true' for it.\n+     *   this method assumes the name is explicit if it is non-null.\n      */\n     @Deprecated\n     public void addSetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n-        addSetter(a, _propName(name), true, visible, ignored);\n+        addSetter(a, _propName(name), name != null, visible, ignored);\n     }\n     @Deprecated\n     public void addSetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n \n     @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n \n-    @Override\n-    public String asText() { return \"\"; }\n+    @Override public String asText() { return \"\"; }\n \n+    @Override public String asText(String defaultValue) { return defaultValue; }\n+    \n     // // Note: not a numeric node, hence default 'asXxx()' are fine:\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java\n \n     @Override public JsonToken asToken() { return JsonToken.VALUE_NULL; }\n \n-    @Override\n-    public String asText() {\n-        return \"null\";\n-    }\n+    @Override public String asText(String defaultValue) { return defaultValue; }\n+    @Override public String asText() { return \"null\"; }\n \n     // as with MissingNode, not considered number node; hence defaults are returned if provided\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n      */\n \n     @Override\n-    public String asText() {\n-        return (_value == null) ? \"null\" : _value.toString();\n+    public String asText() { return (_value == null) ? \"null\" : _value.toString(); }\n+\n+    @Override public String asText(String defaultValue) {\n+        return (_value == null) ? defaultValue : _value.toString();\n     }\n-\n+    \n     @Override\n     public boolean asBoolean(boolean defaultValue)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-\n \n /**\n  * Value node that contains a text value.\n public class TextNode\n     extends ValueNode\n {\n-    final static int INT_SPACE = ' ';\n-\n     final static TextNode EMPTY_STRING_NODE = new TextNode(\"\");\n \n-    final String _value;\n+    protected final String _value;\n \n     public TextNode(String v) { _value = v; }\n \n     }\n \n     @Override\n-    public JsonNodeType getNodeType()\n-    {\n+    public JsonNodeType getNodeType() {\n         return JsonNodeType.STRING;\n     }\n \n      * base64 encoded; if so, they are decoded and resulting binary\n      * data is returned.\n      */\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         @SuppressWarnings(\"resource\")\n         ByteArrayBuilder builder = new ByteArrayBuilder(100);\n                 if (ptr >= len) {\n                     break main_loop;\n                 }\n-            } while (ch <= INT_SPACE);\n+            } while (ch <= ' ');\n             int bits = b64variant.decodeBase64Char(ch);\n             if (bits < 0) {\n                 _reportInvalidBase64(b64variant, ch, 0);\n     }\n \n     @Override\n-    public byte[] binaryValue() throws IOException\n-    {\n+    public byte[] binaryValue() throws IOException {\n         return getBinaryValue(Base64Variants.getDefaultVariant());\n     }\n     \n         return _value;\n     }\n \n+    @Override\n+    public String asText(String defaultValue) {\n+        return (_value == null) ? defaultValue : _value;\n+    }\n+    \n     // note: neither fast nor elegant, but these work for now:\n \n     @Override\n      */\n     \n     @Override\n-    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n-        throws IOException, JsonProcessingException\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException\n     {\n         if (_value == null) {\n             jg.writeNull();\n         throws JsonParseException\n     {\n         String base;\n-        if (ch <= INT_SPACE) {\n+        if (ch <= ' ') {\n             base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n         } else if (b64variant.usesPaddingChar(ch)) {\n             base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n         throw new JsonParseException(base, JsonLocation.NA);\n     }\n \n-    protected void _reportBase64EOF()\n-        throws JsonParseException\n-    {\n+    protected void _reportBase64EOF() throws JsonParseException {\n         throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n      */\n \n     @Override\n-    public final JsonNode get(int index)\n-    {\n-        return null;\n-    }\n+    public final JsonNode get(int index) { return null; }\n \n     @Override\n-    public final JsonNode path(int index)\n-    {\n-        return MissingNode.getInstance();\n-    }\n+    public final JsonNode path(int index) { return MissingNode.getInstance(); }\n \n     @Override\n-    public final boolean has(int index)\n-    {\n-        return false;\n-    }\n+    public final boolean has(int index) { return false; }\n \n     @Override\n-    public final boolean hasNonNull(int index)\n-    {\n-        return false;\n-    }\n+    public final boolean hasNonNull(int index) { return false; }\n \n     @Override\n-    public final JsonNode get(String fieldName)\n-    {\n-        return null;\n-    }\n+    public final JsonNode get(String fieldName) { return null; }\n \n     @Override\n-    public final JsonNode path(String fieldName)\n-    {\n-        return MissingNode.getInstance();\n-    }\n+    public final JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n \n     @Override\n-    public final boolean has(String fieldName)\n-    {\n-        return false;\n-    }\n+    public final boolean has(String fieldName) { return false; }\n \n     @Override\n-    public final boolean hasNonNull(String fieldName)\n-    {\n-        return false;\n-    }\n+    public final boolean hasNonNull(String fieldName) { return false; }\n \n     /*\n      **********************************************************************\n      */\n \n     @Override\n-    public final JsonNode findValue(String fieldName)\n-    {\n+    public final JsonNode findValue(String fieldName) {\n         return null;\n     }\n \n     // note: co-variant return type\n     @Override\n-    public final ObjectNode findParent(String fieldName)\n-    {\n+    public final ObjectNode findParent(String fieldName) {\n         return null;\n     }\n \n     @Override\n-    public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n-    {\n+    public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) {\n         return foundSoFar;\n     }\n \n     @Override\n-    public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n-    {\n+    public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {\n         return foundSoFar;\n     }\n \n     @Override\n-    public final List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n-    {\n+    public final List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {\n         return foundSoFar;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = new NumberSerializers.NumberSerializer();\n+        final JsonSerializer<?> ns = NumberSerializer.instance;\n         _concrete.put(BigInteger.class.getName(), ns);\n         _concrete.put(BigDecimal.class.getName(), ns);\n \n             return ToStringSerializer.instance;\n         }\n         if (Number.class.isAssignableFrom(raw)) {\n-            return NumberSerializers.NumberSerializer.instance;\n+            // 21-May-2014, tatu: Couple of alternatives actually\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null) {\n+                switch (format.getShape()) {\n+                case STRING:\n+                    return ToStringSerializer.instance;\n+                case OBJECT: // need to bail out to let it be serialized as POJO\n+                case ARRAY: // or, I guess ARRAY; otherwise no point in speculating\n+                    return null;\n+                default:\n+                }\n+            }\n+            return NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n             return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+\n+/**\n+ * As a fallback, we may need to use this serializer for other\n+ * types of {@link Number}s: both custom types and \"big\" numbers\n+ * like {@link BigInteger} and {@link BigDecimal}.\n+ */\n+@JacksonStdImpl\n+public final class NumberSerializer\n+    extends StdScalarSerializer<Number>\n+{\n+    public final static NumberSerializer instance = new NumberSerializer();\n+\n+    public NumberSerializer() { super(Number.class); }\n+\n+    @Override\n+    public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (value instanceof BigDecimal) {\n+            jgen.writeNumber((BigDecimal) value);\n+        } else if (value instanceof BigInteger) {\n+            jgen.writeNumber((BigInteger) value);\n+            \n+        /* These shouldn't match (as there are more specific ones),\n+         * but just to be sure:\n+         */\n+        } else if (value instanceof Integer) {\n+            jgen.writeNumber(value.intValue());\n+        } else if (value instanceof Long) {\n+            jgen.writeNumber(value.longValue());\n+        } else if (value instanceof Double) {\n+            jgen.writeNumber(value.doubleValue());\n+        } else if (value instanceof Float) {\n+            jgen.writeNumber(value.floatValue());\n+        } else if ((value instanceof Byte) || (value instanceof Short)) {\n+            jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n+        } else {\n+            // We'll have to use fallback \"untyped\" number write method\n+            jgen.writeNumber(value.toString());\n+        }\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+        return createSchemaNode(\"number\", true);\n+    }\n+    \n+    @Override\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n+    {\n+        // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n+        // to ensure no information is lost? But probably won't work that well...\n+        JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+        if (v2 != null) {\n+            v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n \n     /*\n     /**********************************************************\n-    /* Concrete serializers, numerics\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    public final static class ShortSerializer\n-        extends StdScalarSerializer<Short>\n-    {\n-        final static ShortSerializer instance = new ShortSerializer();\n-    \n-        public ShortSerializer() { super(Short.class); }\n-        \n-        @Override\n-        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            jgen.writeNumber(value.shortValue());\n-        }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\t\t// msteiger: maybe \"integer\" or \"short\" ?\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+    /* Shared base class\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class Base<T> extends StdScalarSerializer<T>\n+        implements ContextualSerializer\n+    {\n+        protected final JsonParser.NumberType _numberType;\n+        protected final String _schemaType;\n+\n+        protected Base(Class<T> cls, JsonParser.NumberType numberType, String schemaType) {\n+            super(cls);\n+            _numberType = numberType;\n+            _schemaType = schemaType;\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+            return createSchemaNode(_schemaType, true);\n+        }\n+\n+        @Override\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\t\t\t// should be SHORT\n+                v2.numberType(_numberType);\n             }\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> createContextual(SerializerProvider prov,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            if (property != null) {\n+                JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n+                if (format != null) {\n+                    switch (format.getShape()) {\n+                    case STRING:\n+                        return ToStringSerializer.instance;\n+                    default:\n+                    }\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, numerics\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public final static class ShortSerializer extends Base<Short>\n+    {\n+        final static ShortSerializer instance = new ShortSerializer();\n+    \n+        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, \"number\"); }\n+\n+        @Override\n+        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeNumber(value.shortValue());\n         }\n     }\n     \n      * included on serialization (unlike for most scalar types as of 1.5)\n      */\n     @JacksonStdImpl\n-    public final static class IntegerSerializer\n-        extends NonTypedScalarSerializerBase<Integer>\n-    {\n-        public IntegerSerializer() { super(Integer.class); }\n-    \n-        @Override\n-        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n-        {\n+    public final static class IntegerSerializer extends Base<Integer>\n+    {\n+        public IntegerSerializer() { super(Integer.class, JsonParser.NumberType.INT ,\"integer\"); }\n+    \n+        @Override\n+        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.intValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"integer\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n-        {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\n-            }\n+        \n+        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n+        @Override\n+        public void serializeWithType(Integer value, JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n+            // no type info, just regular serialization\n+            serialize(value, jgen, provider);            \n         }\n     }\n \n      * by calling {@link java.lang.Number#intValue}.\n      */\n     @JacksonStdImpl\n-    public final static class IntLikeSerializer\n-        extends StdScalarSerializer<Number>\n+    public final static class IntLikeSerializer extends Base<Number>\n     {\n         final static IntLikeSerializer instance = new IntLikeSerializer();\n     \n-        public IntLikeSerializer() { super(Number.class); }\n+        public IntLikeSerializer() {\n+            super(Number.class, JsonParser.NumberType.INT, \"integer\");\n+        }\n         \n         @Override\n         public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.intValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"integer\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\n-            }\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class LongSerializer\n-        extends StdScalarSerializer<Long>\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongSerializer extends Base<Long>\n     {\n         final static LongSerializer instance = new LongSerializer();\n     \n-        public LongSerializer() { super(Long.class); }\n-        \n-        @Override\n-        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n-        {\n+        public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, \"number\"); }\n+        \n+        @Override\n+        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.longValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.LONG);\n-            }\n-        }\n-    }\n-    \n-    @JacksonStdImpl\n-    public final static class FloatSerializer\n-        extends StdScalarSerializer<Float>\n+    }\n+    \n+    @JacksonStdImpl\n+    public final static class FloatSerializer extends Base<Float>\n     {\n         final static FloatSerializer instance = new FloatSerializer();\n     \n-        public FloatSerializer() { super(Float.class); }\n+        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, \"number\"); }\n         \n         @Override\n         public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.floatValue());\n-        }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.FLOAT);\n-            }\n         }\n     }\n \n      * included on serialization (unlike for most scalar types as of 1.5)\n      */\n     @JacksonStdImpl\n-    public final static class DoubleSerializer\n-        extends NonTypedScalarSerializerBase<Double>\n+    public final static class DoubleSerializer extends Base<Double>\n     {\n         final static DoubleSerializer instance = new DoubleSerializer();\n     \n-        public DoubleSerializer() { super(Double.class); }\n+        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, \"number\"); }\n     \n         @Override\n         public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.doubleValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.DOUBLE);\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * As a fallback, we may need to use this serializer for other\n-     * types of {@link Number}s (custom types).\n-     */\n-    @JacksonStdImpl\n-    public final static class NumberSerializer\n-        extends StdScalarSerializer<Number>\n-    {\n-        public final static NumberSerializer instance = new NumberSerializer();\n-    \n-        public NumberSerializer() { super(Number.class); }\n-    \n-        @Override\n-        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n-            if (value instanceof BigDecimal) {\n-                // 07-Jul-2013, tatu: Should be handled by propagating setting to JsonGenerator\n-                //    so this should not be needed:\n-                /*\n-                if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-                    // [Issue#232]: Ok, rather clumsy, but let's try to work around the problem with:\n-                    if (!(jgen instanceof TokenBuffer)) {\n-                        jgen.writeNumber(((BigDecimal) value).toPlainString());\n-                        return;\n-                    }\n-                }\n-                */\n-                jgen.writeNumber((BigDecimal) value);\n-            } else if (value instanceof BigInteger) {\n-                jgen.writeNumber((BigInteger) value);\n-                \n-            /* These shouldn't match (as there are more specific ones),\n-             * but just to be sure:\n-             */\n-            } else if (value instanceof Integer) {\n-                jgen.writeNumber(value.intValue());\n-            } else if (value instanceof Long) {\n-                jgen.writeNumber(value.longValue());\n-            } else if (value instanceof Double) {\n-                jgen.writeNumber(value.doubleValue());\n-            } else if (value instanceof Float) {\n-                jgen.writeNumber(value.floatValue());\n-            } else if ((value instanceof Byte) || (value instanceof Short)) {\n-                jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n-            } else {\n-                // We'll have to use fallback \"untyped\" number write method\n-                jgen.writeNumber(value.toString());\n-            }\n-        }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n-        {\n-            // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n-            // to ensure no information is lost? But probably won't work that well...\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n-            }\n+\n+        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n+        @Override\n+        public void serializeWithType(Double value, JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n+            // no type info, just regular serialization\n+            serialize(value, jgen, provider);            \n         }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/big/TestBiggerData.java\n+package com.fasterxml.jackson.databind.big;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestBiggerData extends BaseMapTest\n+{\n+\tstatic class Citm\n+\t{\n+\t\tpublic Map<Integer,String> areaNames;\n+\t\tpublic Map<Integer,String> audienceSubCategoryNames;\n+\t\tpublic Map<Integer,String> blockNames;\n+\t\tpublic Map<Integer,String> seatCategoryNames;\n+\t\tpublic Map<Integer,String> subTopicNames;\n+\t\tpublic Map<Integer,String> subjectNames;\n+\t\tpublic Map<Integer,String> topicNames;\n+\t\tpublic Map<Integer,int[]> topicSubTopics;\n+\t\tpublic Map<String,String> venueNames;\n+\n+\t\tpublic Map<Integer,Event> events;\n+\t\tpublic List<Performance> performances;\n+\t}\n+\n+\tstatic class Event\n+\t{\n+\t\tpublic int id;\n+\t\tpublic String name;\n+\t\tpublic String description;\n+\t\tpublic String subtitle;\n+\t\tpublic String logo;\n+\t\tpublic int subjectCode;\n+\t\tpublic int[] topicIds;\n+\t\tpublic LinkedHashSet<Integer> subTopicIds;\n+\t}\n+\n+\tstatic class Performance\n+\t{\n+\t\tpublic int id;\n+\t\tpublic int eventId;\n+\t\tpublic String name;\n+\t\tpublic String description;\n+\t\tpublic String logo;\n+\n+\t\tpublic List<Price> prices;\n+\t\tpublic List<SeatCategory> seatCategories;\n+\n+\t\tpublic long start;\n+\t\tpublic String seatMapImage;\n+\t\tpublic String venueCode;\n+}\n+\n+\tstatic class Price {\n+\t\tpublic int amount;\n+\t\tpublic int audienceSubCategoryId;\n+\t\tpublic int seatCategoryId;\n+\t}\n+\n+\tstatic class SeatCategory {\n+\t\tpublic int seatCategoryId;\n+\t\tpublic List<Area> areas;\n+\t}\n+\n+\tstatic class Area {\n+\t\tpublic int areaId;\n+\t\tpublic int[] blockIds;\n+\t}\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+\tpublic void testReading() throws Exception\n+\t{\n+\t\tObjectMapper mapper = objectMapper();\n+\t\tCitm citm = mapper.readValue(getClass().getResourceAsStream(\"/data/citm_catalog.json\"),\n+\t\t\t\tCitm.class);\n+\t\tassertNotNull(citm);\n+\t\tassertNotNull(citm.areaNames);\n+\t\tassertEquals(17, citm.areaNames.size());\n+\t\tassertNotNull(citm.events);\n+\t\tassertEquals(184, citm.events.size());\n+\n+\t\tassertNotNull(citm.seatCategoryNames);\n+\t\tassertEquals(64, citm.seatCategoryNames.size());\n+\t\tassertNotNull(citm.subTopicNames);\n+\t\tassertEquals(19, citm.subTopicNames.size());\n+\t\tassertNotNull(citm.subjectNames);\n+\t\tassertEquals(0, citm.subjectNames.size());\n+\t\tassertNotNull(citm.topicNames);\n+\t\tassertEquals(4, citm.topicNames.size());\n+\t\tassertNotNull(citm.topicSubTopics);\n+\t\tassertEquals(4, citm.topicSubTopics.size());\n+\t\tassertNotNull(citm.venueNames);\n+\t\tassertEquals(1, citm.venueNames.size());\n+\t}\n+\n+\tpublic void testRoundTrip() throws Exception\n+\t{\n+\t\tObjectMapper mapper = objectMapper();\n+\t\tCitm citm = mapper.readValue(getClass().getResourceAsStream(\"/data/citm_catalog.json\"),\n+\t\t\t\tCitm.class);\n+\n+\t\tObjectWriter w = mapper.writerWithDefaultPrettyPrinter();\n+\t\t\n+\t\tString json1 = w.writeValueAsString(citm);\n+\t\tCitm citm2 = mapper.readValue(json1, Citm.class);\n+\t\tString json2 = w.writeValueAsString(citm2);\n+\n+\t\tassertEquals(json1, json2);\n+\t}\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n         assertEquals(value, n.asLong());\n         \n         // and then with non-numeric input\n-        assertNodeNumbersForNonNumeric(TextNode.valueOf(\"foobar\"));\n+        n = TextNode.valueOf(\"foobar\");\n+        assertNodeNumbersForNonNumeric(n);\n \n+        assertEquals(\"foobar\", n.asText(\"barf\"));\n+        assertEquals(\"\", empty.asText(\"xyz\"));\n     }\n \n     public void testBoolean()\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java\n         assertEquals(4, n.asInt(4));\n         assertEquals(5L, n.asLong(5));\n         assertEquals(0.25, n.asDouble(0.25));\n+\n+        assertEquals(\"foo\", n.asText(\"foo\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java\n         assertFalse(n.has(\"field\"));\n         assertFalse(n.has(3));\n \n-        // 1.6:\n         assertNodeNumbersForNonNumeric(n);\n+\n+        // 2.4\n+        assertEquals(\"foo\", n.asText(\"foo\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n         assertEquals(BigDecimal.ONE, n.decimalValue());\n         assertEquals(BigInteger.ONE, n.bigIntegerValue());\n         assertEquals(\"1\", n.asText());\n-\n+        // 2.4\n+        assertEquals(\"1\", n.asText(\"foo\"));\n+        \n         assertNodeNumbers(n, 1, 1.0);\n \n         assertTrue(IntNode.valueOf(0).canConvertToInt());\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n     \n     private final ObjectMapper MAPPER = objectMapper();\n \n+    public void testSimpleObject() throws Exception\n+    {\n+        String JSON = \"{ \\\"key\\\" : 1, \\\"b\\\" : \\\"x\\\" }\";\n+        JsonNode root = MAPPER.readTree(JSON);\n+\n+        // basic properties first:\n+        assertFalse(root.isValueNode());\n+        assertTrue(root.isContainerNode());\n+        assertFalse(root.isArray());\n+        assertTrue(root.isObject());\n+        assertEquals(2, root.size());\n+\n+        // Related to [JACKSON-50]:\n+        Iterator<JsonNode> it = root.iterator();\n+        assertNotNull(it);\n+        assertTrue(it.hasNext());\n+        JsonNode n = it.next();\n+        assertNotNull(n);\n+        assertEquals(IntNode.valueOf(1), n);\n+\n+        assertTrue(it.hasNext());\n+        n = it.next();\n+        assertNotNull(n);\n+        assertEquals(TextNode.valueOf(\"x\"), n);\n+\n+        assertFalse(it.hasNext());\n+\n+        // Ok, then, let's traverse via extended interface\n+        ObjectNode obNode = (ObjectNode) root;\n+        Iterator<Map.Entry<String,JsonNode>> fit = obNode.fields();\n+        // we also know that LinkedHashMap is used, i.e. order preserved\n+        assertTrue(fit.hasNext());\n+        Map.Entry<String,JsonNode> en = fit.next();\n+        assertEquals(\"key\", en.getKey());\n+        assertEquals(IntNode.valueOf(1), en.getValue());\n+\n+        assertTrue(fit.hasNext());\n+        en = fit.next();\n+        assertEquals(\"b\", en.getKey());\n+        assertEquals(TextNode.valueOf(\"x\"), en.getValue());\n+\n+        // Plus: we should be able to modify the node via iterator too:\n+        fit.remove();\n+        assertEquals(1, obNode.size());\n+        assertEquals(IntNode.valueOf(1), root.get(\"key\"));\n+        assertNull(root.get(\"b\"));\n+    }    \n     // for [Issue#346]\n     public void testEmptyNodeAsValue() throws Exception\n     {\n         assertTrue(ob1.equals(ob2));\n         assertTrue(ob2.equals(ob1));\n     }\n+\n+    public void testSimplePath() throws Exception\n+    {\n+        JsonNode root = MAPPER.readTree(\"{ \\\"results\\\" : { \\\"a\\\" : 3 } }\");\n+        assertTrue(root.isObject());\n+        JsonNode rnode = root.path(\"results\");\n+        assertNotNull(rnode);\n+        assertTrue(rnode.isObject());\n+        assertEquals(3, rnode.path(\"a\").intValue());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n \n import org.w3c.dom.Element;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n- * Test for verifying [JACKSON-238]\n- *\n- * @author Pablo Lalloni <plalloni@gmail.com>\n- * @author tatu\n+ * Tests for verifying various issues with custom serializers.\n  */\n-public class TestCustomSerializers\n-    extends com.fasterxml.jackson.databind.BaseMapTest\n+public class TestCustomSerializers extends BaseMapTest\n {\n     /*\n     /**********************************************************\n             return null;\n         }\n     }\n-    \n+\n+    @JsonFormat(shape=JsonFormat.Shape.OBJECT)\n+    static class LikeNumber extends Number {\n+        private static final long serialVersionUID = 1L;\n+\n+        public int x;\n+\n+        public LikeNumber(int value) { x = value; }\n+        \n+        @Override\n+        public double doubleValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public float floatValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public long longValue() {\n+            return x;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n     /**********************************************************\n     */\n-    \n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n                 mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n+    \n+    public void testNumberSubclass() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'x':42}\"),\n+                MAPPER.writeValueAsString(new LikeNumber(42)));\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests for verifying serialization of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestNumbers extends BaseMapTest\n+{\n+    private final ObjectMapper MAPPER = objectMapper();\n+\n+    private static class IntAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public int value = 3;\n+    }\n+\n+    private static class LongAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public long value = 4;\n+    }\n+    \n+    private static class DoubleAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public double value = -0.5;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testDouble() throws Exception\n+    {\n+        double[] values = new double[] {\n+            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        };\n+        for (double d : values) {\n+            String expected = String.valueOf(d);\n+            if (Double.isNaN(d) || Double.isInfinite(d)) {\n+                expected = \"\\\"\"+d+\"\\\"\";\n+            }\n+            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n+        }\n+    }\n+\n+    public void testBigInteger() throws Exception\n+    {\n+        BigInteger[] values = new BigInteger[] {\n+                BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,\n+                BigInteger.valueOf(1234567890L),\n+                new BigInteger(\"123456789012345678901234568\"),\n+                new BigInteger(\"-1250000124326904597090347547457\")\n+                };\n+\n+        for (BigInteger value : values) {\n+            String expected = value.toString();\n+            assertEquals(expected, MAPPER.writeValueAsString(value));\n+        }\n+    }\n+\n+    public void testNumbersAsString() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'value':'3'}\"), MAPPER.writeValueAsString(new IntAsString()));\n+        assertEquals(aposToQuotes(\"{'value':'4'}\"), MAPPER.writeValueAsString(new LongAsString()));\n+        assertEquals(aposToQuotes(\"{'value':'-0.5'}\"), MAPPER.writeValueAsString(new DoubleAsString()));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n package com.fasterxml.jackson.databind.ser;\n-\n-import java.math.BigInteger;\n-\n \n import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.databind.BaseMapTest;\n         }\n     }\n \n-    public void testDouble() throws Exception\n-    {\n-        double[] values = new double[] {\n-            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n-        };\n-        for (double d : values) {\n-            String expected = String.valueOf(d);\n-            if (Double.isNaN(d) || Double.isInfinite(d)) {\n-                expected = \"\\\"\"+d+\"\\\"\";\n-            }\n-            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n-        }\n-    }\n-\n-    public void testBigInteger() throws Exception\n-    {\n-        BigInteger[] values = new BigInteger[] {\n-                BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,\n-                BigInteger.valueOf(1234567890L),\n-                new BigInteger(\"123456789012345678901234568\"),\n-                new BigInteger(\"-1250000124326904597090347547457\")\n-                };\n-\n-        for (BigInteger value : values) {\n-            String expected = value.toString();\n-            assertEquals(expected, MAPPER.writeValueAsString(value));\n-        }\n-    }\n-    \n     public void testClass() throws Exception\n     {\n         String result = MAPPER.writeValueAsString(java.util.List.class);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedMap171.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+// Tests for [#171]\n+public class TestUnwrappedMap171 extends BaseMapTest\n+{\n+    static class MapUnwrap {\n+\n+        public MapUnwrap() { }\n+        public MapUnwrap(String key, Object value) {\n+            map = Collections.singletonMap(key, value);\n+        }\n+\n+        @JsonUnwrapped(prefix=\"map.\")\n+        public Map<String, Object> map;\n+    }\n+    \n+    // // // Reuse mapper to keep tests bit faster\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Tests, serialization\n+    /**********************************************************\n+     */\n+\n+    public void testMapUnwrapSerialize() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new MapUnwrap(\"test\", 6));\n+        assertEquals(\"{\\\"map.test\\\": 6}\", json);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    public void testMapUnwrapDeserialize() throws Exception\n+    {\n+        MapUnwrap root = MAPPER.readValue(\"{\\\"map.test\\\": 6}\", MapUnwrap.class);\n+\n+        assertEquals(1, root.map.size());\n+        assertEquals(6, ((Number)root.map.get(\"test\")).intValue());\n+    }\n+}", "timestamp": 1401232733, "metainfo": ""}