{"sha": "557bcd3d55fa779e40251506d159468bfe96fe04", "log": "Fix: ensure that scope gets pass to ObjectIdGenerators", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n     /**********************************************************\n      */\n \n-    @SuppressWarnings(\"unchecked\")\n-    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n             Object deserDef)\n-        throws JsonMappingException\n-    {\n-        if (deserDef == null) {\n-            return null;\n-        }\n-        JsonDeserializer<?> deser;\n-        \n-        if (deserDef instanceof JsonDeserializer) {\n-            deser = (JsonDeserializer<?>) deserDef;\n-        } else {\n-            /* Alas, there's no way to force return type of \"either class\n-             * X or Y\" -- need to throw an exception after the fact\n-             */\n-            if (!(deserDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n-            }\n-            Class<?> deserClass = (Class<?>)deserDef;\n-            // there are some known \"no class\" markers to consider too:\n-            if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) {\n-                return null;\n-            }\n-            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n-            }\n-            HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            if (hi != null) {\n-                deser = hi.deserializerInstance(_config, annotated, deserClass);\n-            } else {\n-                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n-                        _config.canOverrideAccessModifiers());\n-            }\n-        }\n-        // First: need to resolve\n-        if (deser instanceof ResolvableDeserializer) {\n-            ((ResolvableDeserializer) deser).resolve(this);\n-        }\n-        return (JsonDeserializer<Object>) deser;\n-    }\n-\n-    public final KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+        throws JsonMappingException;\n+\n+    public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated,\n             Object deserDef)\n-        throws JsonMappingException\n-    {\n-        if (deserDef == null) {\n-            return null;\n-        }\n-\n-        KeyDeserializer deser;\n-        \n-        if (deserDef instanceof KeyDeserializer) {\n-            deser = (KeyDeserializer) deserDef;\n-        } else {\n-            if (!(deserDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n-                        +deserDef.getClass().getName()\n-                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n-            }\n-            Class<?> deserClass = (Class<?>)deserDef;\n-            // there are some known \"no class\" markers to consider too:\n-            if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) {\n-                return null;\n-            }\n-            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n-                        +\"; expected Class<KeyDeserializer>\");\n-            }\n-            HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            if (hi != null) {\n-                deser = hi.keyDeserializerInstance(_config, annotated, deserClass);\n-            } else {\n-                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n-                        _config.canOverrideAccessModifiers());\n-            }\n-        }\n-        // First: need to resolve\n-        if (deser instanceof ResolvableDeserializer) {\n-            ((ResolvableDeserializer) deser).resolve(this);\n-        }\n-        return deser;\n-    }\n-\n-    public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n-            Class<?> implClass)\n-        throws JsonMappingException\n-    {\n-        HandlerInstantiator hi = _config.getHandlerInstantiator();\n-\n-        if (hi != null) {\n-            return hi.objectIdGeneratorInstance(_config, annotated, implClass);\n-        }\n-        return (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n-                    _config.canOverrideAccessModifiers());\n-    }\n+        throws JsonMappingException;\n+\n+    public abstract ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n+            ObjectIdInfo objectIdInfo)\n+        throws JsonMappingException;\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.ser.impl.*;\n      * @param annotated Annotated entity that contained definition\n      * @param serDef Serializer definition: either an instance or class\n      */\n-    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n+    public abstract JsonSerializer<Object> serializerInstance(Annotated annotated,\n             Object serDef)\n-        throws JsonMappingException\n-    {\n-        if (serDef == null) {\n-            return null;\n-        }\n-        JsonSerializer<?> ser;\n-        \n-        if (serDef instanceof JsonSerializer) {\n-            ser = (JsonSerializer<?>) serDef;\n-        } else {\n-            /* Alas, there's no way to force return type of \"either class\n-             * X or Y\" -- need to throw an exception after the fact\n-             */\n-            if (!(serDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n-                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n-            }\n-            Class<?> serClass = (Class<?>)serDef;\n-            // there are some known \"no class\" markers to consider too:\n-            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n-                return null;\n-            }\n-            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n-                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n-            }\n-            HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            if (hi != null) {\n-                ser = hi.serializerInstance(_config, annotated, serClass);\n-            } else {\n-                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n-                        _config.canOverrideAccessModifiers());\n-            }\n-        }\n-        return (JsonSerializer<Object>) _handleResolvable(ser);\n-    }\n-\n-    public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n-            Class<?> implClass)\n-        throws JsonMappingException\n-    {\n-        HandlerInstantiator hi = _config.getHandlerInstantiator();\n-\n-        if (hi != null) {\n-            return hi.objectIdGeneratorInstance(_config, annotated, implClass);\n-        }\n-        return (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n-                    _config.canOverrideAccessModifiers());\n-    }\n+        throws JsonMappingException;\n+\n+    public abstract ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n+            ObjectIdInfo objectIdInfo)\n+        throws JsonMappingException;\n     \n     /*\n     /********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n             if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                 ObjectIdGenerator<?> idGen;\n-                Class<?> implClass = objectIdInfo.getGenerator();\n+                Class<?> implClass = objectIdInfo.getGeneratorType();\n                 JavaType type = ctxt.constructType(implClass);\n                 JavaType idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                 // Property-based generator is trickier\n                     idGen = null;\n                     if (true) throw new IllegalStateException(\"Not yet implemented!\");\n                 } else { // other types need to be simpler\n-                    idGen = ctxt.objectIdGeneratorInstance(accessor, implClass);\n+                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n                 }\n                 JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                 oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n             return null;\n         }\n         ObjectIdGenerator<?> gen;\n-        Class<?> implClass = oidInfo.getGenerator();\n+        Class<?> implClass = oidInfo.getGeneratorType();\n         JavaType type = ctxt.constructType(implClass);\n         // Could require type to be passed explicitly, but we should be able to find it too:\n         JavaType idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n             gen = null;\n             if (true) throw new IllegalStateException(\"Not yet implemented!\");\n         } else { // other types need to be simpler\n-            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), implClass);\n+            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), oidInfo);\n         }\n         return ObjectIdReader.construct(idType, oidInfo.getPropertyName(), gen, deser);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Default {@link DeserializationContext} implementation that adds\n \n     /*\n     /**********************************************************\n-    /* Abstract methods impls\n+    /* Abstract methods impls, Object Id\n     /**********************************************************\n      */\n \n         ReadableObjectId entry = new ReadableObjectId(id);\n         _objectIds.put(key, entry);\n         return entry;\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n+            ObjectIdInfo objectIdInfo)\n+        throws JsonMappingException\n+    {\n+        Class<?> implClass = objectIdInfo.getGeneratorType();\n+        HandlerInstantiator hi = _config.getHandlerInstantiator();\n+        ObjectIdGenerator<?> gen;\n+\n+        if (hi != null) {\n+            gen = hi.objectIdGeneratorInstance(_config, annotated, implClass);\n+        } else {\n+            gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n+                    _config.canOverrideAccessModifiers());\n+        }\n+        return gen.forScope(objectIdInfo.getScope());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Abstract methods impls, other factory methods\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+            Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        JsonDeserializer<?> deser;\n+        \n+        if (deserDef instanceof JsonDeserializer) {\n+            deser = (JsonDeserializer<?>) deserDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.deserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        return (JsonDeserializer<Object>) deser;\n+    }\n+\n+    @Override\n+    public final KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+            Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+\n+        KeyDeserializer deser;\n+        \n+        if (deserDef instanceof KeyDeserializer) {\n+            deser = (KeyDeserializer) deserDef;\n+        } else {\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n+                        +deserDef.getClass().getName()\n+                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n+                        +\"; expected Class<KeyDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.keyDeserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        return deser;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n \n     public String getPropertyName() { return _propertyName; }\n     public Class<?> getScope() { return _scope; }\n-    public Class<? extends ObjectIdGenerator<?>> getGenerator() { return _generator; }\n+    public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             BeanDescription beanDesc, List<BeanPropertyWriter> props)\n         throws JsonMappingException\n     {\n-        ObjectIdInfo oidInfo = beanDesc.getObjectIdInfo();\n-        if (oidInfo == null) {\n+        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n+        if (objectIdInfo == null) {\n             return null;\n         }\n         ObjectIdGenerator<?> gen;\n-        Class<?> implClass = oidInfo.getGenerator();\n+        Class<?> implClass = objectIdInfo.getGeneratorType();\n         JavaType idType;\n \n         // Just one special case: Property-based generator is trickier\n         if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n-            String propName = oidInfo.getPropertyName();\n+            String propName = objectIdInfo.getPropertyName();\n             BeanPropertyWriter idProp = null;\n \n             for (int i = 0, len = props.size() ;; ++i) {\n                 }\n             }\n             idType = idProp.getType();\n-            gen = new PropertyBasedObjectIdGenerator(oidInfo, idProp);\n+            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n             // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n             return ObjectIdWriter.construct(idType, null, gen);\n             \n         JavaType type = prov.constructType(implClass);\n         // Could require type to be passed explicitly, but we should be able to find it too:\n         idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n-        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), implClass);\n-        return ObjectIdWriter.construct(idType, oidInfo.getPropertyName(), gen);\n+        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n+        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Standard implementation used by {@link ObjectMapper}:\n      */\n \n     @Override\n+    public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated,\n+            ObjectIdInfo objectIdInfo)\n+        throws JsonMappingException\n+    {\n+        Class<?> implClass = objectIdInfo.getGeneratorType();\n+        HandlerInstantiator hi = _config.getHandlerInstantiator();\n+        ObjectIdGenerator<?> gen;\n+\n+        if (hi != null) {\n+            gen =  hi.objectIdGeneratorInstance(_config, annotated, implClass);\n+        } else {\n+            gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass,\n+                    _config.canOverrideAccessModifiers());\n+        }\n+        return gen.forScope(objectIdInfo.getScope());\n+    }\n+    \n+    @Override\n     public WritableObjectId findObjectId(Object forPojo,\n             ObjectIdGenerator<?> generatorType)\n     {\n             }\n         }\n         if (generator == null) {\n-            generator = generatorType.newForSerialization();\n+            generator = generatorType.newForSerialization(this);\n         }\n         WritableObjectId oid = new WritableObjectId(generator);\n         _seenObjectIds.put(forPojo, oid);\n         return oid;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Factory method impls\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n+            Object serDef)\n+        throws JsonMappingException\n+    \n+    {\n+        if (serDef == null) {\n+            return null;\n+        }\n+        JsonSerializer<?> ser;\n+        \n+        if (serDef instanceof JsonSerializer) {\n+            ser = (JsonSerializer<?>) serDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n+                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>)serDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                ser = hi.serializerInstance(_config, annotated, serClass);\n+            } else {\n+                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        return (JsonSerializer<Object>) _handleResolvable(ser);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper classes\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n     }\n \n     @Override\n-    public ObjectIdGenerator<Object> newForSerialization() {\n+    public ObjectIdGenerator<Object> newForSerialization(Object context) {\n         // No state, can return this\n         return this;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                  * really belongs)\n                  */\n                 ObjectIdGenerator<?> gen;\n-                Class<?> implClass = objectIdInfo.getGenerator();\n+                Class<?> implClass = objectIdInfo.getGeneratorType();\n                 JavaType type = provider.constructType(implClass);\n                 JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                 // Property-based generator is trickier\n                     gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                     oiw = ObjectIdWriter.construct(idType, null, gen);\n                 } else { // other types need to be simpler\n-                    gen = provider.objectIdGeneratorInstance(accessor, implClass);\n+                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                     oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen);\n                 }\n             }", "timestamp": 1328895891, "metainfo": ""}