{"sha": "65c410c0c40724f763e0b4bce2db6d43bf078818", "log": "refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n \n     /*\n     /*****************************************************\n-    /* More refined access to features\n+    /* More refined access to configuration features\n+    /* (usually based on annotations)\n     /*****************************************************\n      */\n     \n     /**\n      * Method used to find View-inclusion definitions for the property.\n      */\n-    public abstract Class<?>[] getViews();\n+    public Class<?>[] findViews() { return null; }\n+\n+    /**\n+     * Method used to find whether property is part of a bi-directional\n+     * reference.\n+     */\n+    public AnnotationIntrospector.ReferenceProperty findReferenceType() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n             }\n             if (prop != null) {\n                 // one more thing before adding to builder: copy any metadata\n-                prop.setViews(propDef.getViews());\n+                prop.setViews(propDef.findViews());\n                 builder.addProperty(prop);\n             }\n         }\n             prop = prop.withValueDeserializer(propDeser);\n         }\n         // [JACKSON-235]: need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(mutator);\n+        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n      */\n     protected final String _internalName;\n \n-    protected Node<AnnotatedField> _fields;\n-    \n-    protected Node<AnnotatedParameter> _ctorParameters;\n-    \n-    protected Node<AnnotatedMethod> _getters;\n-\n-    protected Node<AnnotatedMethod> _setters;\n+    protected Linked<AnnotatedField> _fields;\n+    \n+    protected Linked<AnnotatedParameter> _ctorParameters;\n+    \n+    protected Linked<AnnotatedMethod> _getters;\n+\n+    protected Linked<AnnotatedMethod> _setters;\n     \n     public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector,\n             boolean forSerialization)\n         }\n         // If multiple, verify that they do not conflict...\n         AnnotatedMethod getter = _getters.value;\n-        Node<AnnotatedMethod> next = _getters.next;\n+        Linked<AnnotatedMethod> next = _getters.next;\n         for (; next != null; next = next.next) {\n             /* [JACKSON-255] Allow masking, i.e. report exception only if\n              *   declarations in same class, or there's no inheritance relationship\n         }\n         // If multiple, verify that they do not conflict...\n         AnnotatedMethod setter = _setters.value;\n-        Node<AnnotatedMethod> next = _setters.next;\n+        Linked<AnnotatedMethod> next = _setters.next;\n         for (; next != null; next = next.next) {\n             /* [JACKSON-255] Allow masking, i.e. report exception only if\n              *   declarations in same class, or there's no inheritance relationship\n         }\n         // If multiple, verify that they do not conflict...\n         AnnotatedField field = _fields.value;\n-        Node<AnnotatedField> next = _fields.next;\n+        Linked<AnnotatedField> next = _fields.next;\n         for (; next != null; next = next.next) {\n             AnnotatedField nextField = next.value;\n             Class<?> fieldClass = field.getDeclaringClass();\n          * if none, first factory method. And don't check for dups, if we must,\n          * can start checking for them later on.\n          */\n-        Node<AnnotatedParameter> curr = _ctorParameters;\n+        Linked<AnnotatedParameter> curr = _ctorParameters;\n         do {\n             if (curr.value.getOwner() instanceof AnnotatedConstructor) {\n                 return curr.value;\n      * Method that will try to find JSON View inclusion information\n      * for this property.\n      */\n-    public Class<?>[] getViews()\n-    {\n-        if (_annotationIntrospector != null) {\n-            AnnotatedMember m;\n-            if (_forSerialization) {\n-                m = getAccessor();\n-            } else {\n-                m = getMutator();\n-                // one kink: may use \"getter-as-setter\"...\n-                if (m == null) {\n-                    m = getGetter();\n-                }\n-            }\n-            if (m != null) {\n-                return _annotationIntrospector.findViews(m);\n-            }\n-        }\n-        return null;\n+    @Override\n+    public Class<?>[] findViews() {\n+        return fromMemberAnnotation(new WithMember<Class<?>[]>() {\n+            @Override public Class<?>[] withMember(AnnotatedMember member) {\n+                return _annotationIntrospector.findViews(member);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public AnnotationIntrospector.ReferenceProperty findReferenceType() {\n+        return fromMemberAnnotation(new WithMember<AnnotationIntrospector.ReferenceProperty>() {\n+            @Override public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {\n+                return _annotationIntrospector.findReferenceType(member);\n+            }\n+        });\n     }\n     \n     /*\n      */\n     \n     public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored) {\n-        _fields = new Node<AnnotatedField>(a, _fields, ename, visible, ignored);\n+        _fields = new Linked<AnnotatedField>(a, _fields, ename, visible, ignored);\n     }\n \n     public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored) {\n-        _ctorParameters = new Node<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored);\n+        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored);\n     }\n \n     public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n-        _getters = new Node<AnnotatedMethod>(a, _getters, ename, visible, ignored);\n+        _getters = new Linked<AnnotatedMethod>(a, _getters, ename, visible, ignored);\n     }\n \n     public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n-        _setters = new Node<AnnotatedMethod>(a, _setters, ename, visible, ignored);\n+        _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored);\n     }\n \n     /**\n         _setters = merge(_setters, src._setters);\n     }\n \n-    private static <T> Node<T> merge(Node<T> chain1, Node<T> chain2)\n+    private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2)\n     {\n         if (chain1 == null) {\n             return chain2;\n         }\n     }\n \n-    private AnnotationMap _mergeAnnotations(int index, Node<? extends AnnotatedMember>... nodes)\n+    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)\n     {\n         AnnotationMap ann = nodes[index].value.getAllAnnotations();\n         ++index;\n         return ann;\n     }\n     \n-    private <T> Node<T> _removeIgnored(Node<T> node)\n+    private <T> Linked<T> _removeIgnored(Linked<T> node)\n     {\n         if (node == null) {\n             return node;\n         return node.withoutIgnored();\n     }\n \n-    private <T> Node<T> _removeNonVisible(Node<T> node)\n+    private <T> Linked<T> _removeNonVisible(Linked<T> node)\n     {\n         if (node == null) {\n             return node;\n         return node.withoutNonVisible();\n     }\n \n-    private <T> Node<T> _trimByVisibility(Node<T> node)\n+    private <T> Linked<T> _trimByVisibility(Linked<T> node)\n     {\n         if (node == null) {\n             return node;\n                 ;\n     }\n \n-    private <T> boolean _anyExplicitNames(Node<T> n)\n+    private <T> boolean _anyExplicitNames(Linked<T> n)\n     {\n         for (; n != null; n = n.next) {\n             if (n.explicitName != null && n.explicitName.length() > 0) {\n         ;\n     }\n \n-    private <T> boolean _anyVisible(Node<T> n)\n+    private <T> boolean _anyVisible(Linked<T> n)\n     {\n         for (; n != null; n = n.next) {\n             if (n.isVisible) {\n         ;\n     }\n \n-    private <T> boolean _anyIgnorals(Node<T> n)\n+    private <T> boolean _anyIgnorals(Linked<T> n)\n     {\n         for (; n != null; n = n.next) {\n             if (n.isMarkedIgnored) {\n      */\n     public String findNewName()\n     {\n-        Node<? extends AnnotatedMember> renamed = null;\n+        Linked<? extends AnnotatedMember> renamed = null;\n         renamed = findRenamed(_fields, renamed);\n         renamed = findRenamed(_getters, renamed);\n         renamed = findRenamed(_setters, renamed);\n         return (renamed == null) ? null : renamed.explicitName;\n     }\n \n-    private Node<? extends AnnotatedMember> findRenamed(Node<? extends AnnotatedMember> node,\n-            Node<? extends AnnotatedMember> renamed)\n+    private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node,\n+            Linked<? extends AnnotatedMember> renamed)\n     {\n         for (; node != null; node = node.next) {\n             String explName = node.explicitName;\n     \n     /*\n     /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used for finding annotation values\n+     */\n+    protected <T> T fromMemberAnnotation(WithMember<T> func)\n+    {\n+        T result = null;\n+        if (_annotationIntrospector != null) {\n+            if (_forSerialization) {\n+                if (_getters != null) {\n+                    result = func.withMember(_getters.value);\n+                }\n+            } else {\n+                if (_ctorParameters != null) {\n+                    result = func.withMember(_ctorParameters.value);\n+                }\n+                if (result == null && _setters != null) {\n+                    result = func.withMember(_setters.value);\n+                }\n+            }\n+            if (result == null && _fields != null) {\n+                result = func.withMember(_fields.value);\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Helper classes\n     /**********************************************************\n      */\n \n+    private interface WithMember<T>\n+    {\n+        public T withMember(AnnotatedMember member);\n+    }\n+    \n     /**\n      * Node used for creating simple linked lists to efficiently store small sets\n      * of things.\n      */\n-    private final static class Node<T>\n+    private final static class Linked<T>\n     {\n         public final T value;\n-        public final Node<T> next;\n+        public final Linked<T> next;\n \n         public final String explicitName;\n         public final boolean isVisible;\n         public final boolean isMarkedIgnored;\n         \n-        public Node(T v, Node<T> n,\n+        public Linked(T v, Linked<T> n,\n                 String explName, boolean visible, boolean ignored)\n         {\n             value = v;\n             isMarkedIgnored = ignored;\n         }\n \n-        public Node<T> withValue(T newValue)\n+        public Linked<T> withValue(T newValue)\n         {\n             if (newValue == value) {\n                 return this;\n             }\n-            return new Node<T>(newValue, next, explicitName, isVisible, isMarkedIgnored);\n+            return new Linked<T>(newValue, next, explicitName, isVisible, isMarkedIgnored);\n         }\n         \n-        public Node<T> withNext(Node<T> newNext) {\n+        public Linked<T> withNext(Linked<T> newNext) {\n             if (newNext == next) {\n                 return this;\n             }\n-            return new Node<T>(value, newNext, explicitName, isVisible, isMarkedIgnored);\n+            return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored);\n         }\n         \n-        public Node<T> withoutIgnored()\n+        public Linked<T> withoutIgnored()\n         {\n             if (isMarkedIgnored) {\n                 return (next == null) ? null : next.withoutIgnored();\n             }\n             if (next != null) {\n-                Node<T> newNext = next.withoutIgnored();\n+                Linked<T> newNext = next.withoutIgnored();\n                 if (newNext != next) {\n                     return withNext(newNext);\n                 }\n             return this;\n         }\n         \n-        public Node<T> withoutNonVisible()\n+        public Linked<T> withoutNonVisible()\n         {\n-            Node<T> newNext = (next == null) ? null : next.withoutNonVisible();\n+            Linked<T> newNext = (next == null) ? null : next.withoutNonVisible();\n             return isVisible ? withNext(newNext) : newNext;\n         }\n \n          * Method called to append given node(s) at the end of this\n          * node chain.\n          */\n-        private Node<T> append(Node<T> appendable) \n+        private Linked<T> append(Linked<T> appendable) \n         {\n             if (next == null) {\n                 return withNext(appendable);\n             return withNext(next.append(appendable));\n         }\n         \n-        public Node<T> trimByVisibility()\n+        public Linked<T> trimByVisibility()\n         {\n             if (next == null) {\n                 return this;\n             }\n-            Node<T> newNext = next.trimByVisibility();\n+            Linked<T> newNext = next.trimByVisibility();\n             if (explicitName != null) { // this already has highest; how about next one?\n                 if (newNext.explicitName == null) { // next one not, drop it\n                     return withNext(null);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/WithMember.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+public interface WithMember<T>\n+{\n+    public T withMember(AnnotatedMember member);\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         }\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n-        _includeInViews = propDef.getViews();\n+        _includeInViews = propDef.findViews();\n \n         // this will be resolved later on, unless nulls are to be suppressed\n         _nullSerializer = null;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         throws JsonMappingException\n     {\n         List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n-        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n         final SerializationConfig config = prov.getConfig();\n \n         // [JACKSON-429]: ignore specified types\n         for (BeanPropertyDefinition property : properties) {\n             AnnotatedMember accessor = property.getAccessor();\n             // [JACKSON-235]: suppress writing of back references\n-            AnnotationIntrospector.ReferenceProperty prop = intr.findReferenceType(accessor);\n-            if (prop != null && prop.isBackReference()) {\n+            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n+            if (refType != null && refType.isBackReference()) {\n                 continue;\n             }\n             if (accessor instanceof AnnotatedMethod) {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n         }\n         return acc;\n     }\n-\n-    /*\n-    /*****************************************************\n-    /* More refined access to features\n-    /*****************************************************\n-     */\n-\n-    /* Hmmh. Should we actually consider defining this in future?\n-     * Should either pass views via construction, or pass\n-     * <code>AnnotationIntrospector</code>, call dynamically.\n-     */\n-    public Class<?>[] getViews() {\n-        return null;\n-    }\n }", "timestamp": 1327725885, "metainfo": ""}