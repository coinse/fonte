{"sha": "9036ebc9fe0cad9cabc8506629f6ec2d5f3d225a", "log": "Implement #335", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n      * for which no explicit is defined should be alphabetically (lexicograpically)\n      * ordered\n      */\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        return null;\n+    }\n+\n+    @Deprecated // since 2.4\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n      * ordered\n      */\n     @Override\n+    @Deprecated\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         Boolean result = _primary.findSerializationSortAlphabetically(ac);\n         if (result == null) {\n         return result;            \n     }\n \n+    @Override\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        Boolean result = _primary.findSerializationSortAlphabetically(ann);\n+        if (result == null) {\n+            result = _secondary.findSerializationSortAlphabetically(ann);\n+        }\n+        return result;            \n+    }\n+    \n     // // // Serialization: property annotations\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     }\n \n     @Override\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        return _findSortAlpha(ann);\n+    }\n+\n+    @Override\n+    @Deprecated\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        return _findSortAlpha(ac);\n+    }\n+\n+    private final Boolean _findSortAlpha(Annotated ann) {\n+        JsonPropertyOrder order = ann.getAnnotation(JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Serialization: property annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n         // Then how about explicit ordering?\n         AnnotationIntrospector intr = _annotationIntrospector;\n         boolean sort;\n-        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n+        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically((Annotated) _classDef);\n         \n         if (alpha == null) {\n             sort = _config.shouldSortPropertiesAlphabetically();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonMapFormatVisitor;\n      */\n     protected final Object _filterId;\n \n+    /**\n+     * Flag set if output is forced to be sorted by keys (usually due\n+     * to annotation).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _sortKeys;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n         _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n         _property = null;\n         _filterId = null;\n+        _sortKeys = false;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = property;\n         _filterId = src._filterId;\n+        _sortKeys = src._sortKeys;\n     }\n \n     protected MapSerializer(MapSerializer src, TypeSerializer vts)\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = src._property;\n         _filterId = src._filterId;\n-    }\n-\n-    protected MapSerializer(MapSerializer src, Object filterId)\n+        _sortKeys = src._sortKeys;\n+    }\n+\n+    protected MapSerializer(MapSerializer src, Object filterId, boolean sortKeys)\n     {\n         super(Map.class, false);\n         _ignoredEntries = src._ignoredEntries;\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = src._property;\n         _filterId = filterId;\n-    }\n-    \n-    @Override\n-    public MapSerializer _withValueTypeSerializer(TypeSerializer vts)\n-    {\n+        _sortKeys = sortKeys;\n+    }\n+    \n+    @Override\n+    public MapSerializer _withValueTypeSerializer(TypeSerializer vts) {\n         return new MapSerializer(this, vts);\n     }\n \n+    @Deprecated // since 2.3\n+    public MapSerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) {\n+        return withResolved(property, keySerializer, valueSerializer, ignored, _sortKeys);\n+    }\n+\n+    /**\n+     * @since 2.4\n+     */\n     public MapSerializer withResolved(BeanProperty property,\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n-            HashSet<String> ignored)\n-    {\n-        return new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n-    }\n-\n+            HashSet<String> ignored, boolean sortKeys)\n+    {\n+        MapSerializer ser = new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n+        if (sortKeys != ser._sortKeys) {\n+            ser = new MapSerializer(ser, _filterId, sortKeys);\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n-        return (_filterId == filterId) ? this : new MapSerializer(this, filterId);\n+        return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n     }\n \n     /**\n          */\n         JsonSerializer<?> ser = null;\n         JsonSerializer<?> keySer = null;\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n \n         // First: if we have a property, may have property-annotation overrides\n-        if (property != null) {\n-            AnnotatedMember m = property.getMember();\n-            if (m != null) {\n-                Object serDef;\n-                final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-                serDef = intr.findKeySerializer(m);\n-                if (serDef != null) {\n-                    keySer = provider.serializerInstance(m, serDef);\n-                }\n-                serDef = intr.findContentSerializer(m);\n-                if (serDef != null) {\n-                    ser = provider.serializerInstance(m, serDef);\n-                }\n+        if (propertyAcc != null && intr != null) {\n+            Object serDef = intr.findKeySerializer(propertyAcc);\n+            if (serDef != null) {\n+                keySer = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            serDef = intr.findContentSerializer(propertyAcc);\n+            if (serDef != null) {\n+                ser = provider.serializerInstance(propertyAcc, serDef);\n             }\n         }\n         if (ser == null) {\n         } else {\n             keySer = provider.handleSecondaryContextualization(keySer, property);\n         }\n-        HashSet<String> ignored = this._ignoredEntries;\n-        AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-        if (intr != null && property != null) {\n-            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n+        HashSet<String> ignored = _ignoredEntries;\n+        boolean sortKeys = false;\n+        if (intr != null && propertyAcc != null) {\n+            String[] moreToIgnore = intr.findPropertiesToIgnore(propertyAcc);\n             if (moreToIgnore != null) {\n                 ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                 for (String str : moreToIgnore) {\n                     ignored.add(str);\n                 }\n             }\n-        }\n-        MapSerializer mser =  withResolved(property, keySer, ser, ignored);\n+            Boolean b = intr.findSerializationSortAlphabetically(propertyAcc);\n+            sortKeys = (b != null) && b.booleanValue();\n+        }\n+        MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n                         findPropertyFilter(provider, _filterId, value));\n                 return;\n             }\n-            if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n             if (_valueSerializer != null) {\n     {\n         typeSer.writeTypePrefixForObject(value, jgen);\n         if (!value.isEmpty()) {\n-            if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n             if (_valueSerializer != null) {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n     /* Unit tests\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n     \n     public void testSimpleRefs() throws Exception\n     {\n         SimpleTreeNode root = new SimpleTreeNode(\"root\");\n         SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.child = child;\n         child.parent = root;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        SimpleTreeNode resultNode = mapper.readValue(json, SimpleTreeNode.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n         assertEquals(\"root\", resultNode.name);\n         SimpleTreeNode resultChild = resultNode.child;\n         assertNotNull(resultChild);\n     {\n         SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n         SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.child = child;\n         child.parent = root;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        SimpleTreeNode2 resultNode = mapper.readValue(json, SimpleTreeNode2.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n         assertEquals(\"root\", resultNode.name);\n         SimpleTreeNode2 resultChild = resultNode.child;\n         assertNotNull(resultChild);\n         FullTreeNode root = new FullTreeNode(\"root\");\n         FullTreeNode child1 = new FullTreeNode(\"kid1\");\n         FullTreeNode child2 = new FullTreeNode(\"kid2\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.firstChild = child1;\n         child1.parent = root;\n         child1.next = child2;\n         child2.prev = child1;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n         assertEquals(\"root\", resultNode.name);\n         FullTreeNode resultChild = resultNode.firstChild;\n         assertNotNull(resultChild);\n         ArrayNode node1 = new ArrayNode(\"a\");\n         ArrayNode node2 = new ArrayNode(\"b\");\n         root.nodes = new ArrayNode[] { node1, node2 };\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeArray result = mapper.readValue(json, NodeArray.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n         ArrayNode[] kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.length);\n         NodeForList node1 = new NodeForList(\"a\");\n         NodeForList node2 = new NodeForList(\"b\");\n         root.nodes = Arrays.asList(node1, node2);\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeList result = mapper.readValue(json, NodeList.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n         List<NodeForList> kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.size());\n         nodes.put(\"a1\", node1);\n         nodes.put(\"b2\", node2);\n         root.nodes = nodes;\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeMap result = mapper.readValue(json, NodeMap.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n         Map<String,NodeForMap> kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.size());\n         child.prev = parent;\n \n         // serialization ought to be ok\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(parent);\n-\n-        AbstractNode root = mapper.readValue(json, AbstractNode.class);\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n \n         assertEquals(ConcreteNode.class, root.getClass());\n         assertEquals(\"p\", root.id);\n         Parent parent = new Parent();\n         parent.addChild(new Child(\"foo\"));\n         parent.addChild(new Child(\"bar\"));\n-        ObjectMapper mapper = new ObjectMapper();\n-        byte[] bytes = mapper.writeValueAsBytes(parent);\n-        Parent value = mapper.readValue(bytes, Parent.class); \n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n         for (Child child : value.children) {\n             assertEquals(value, child.getParent());\n         }\n \n     public void testIssue708() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Advertisement708 ad = mapper.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n         assertNotNull(ad);\n     }   \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n         }\n     }\n     \n+    // [#335]\n+    static class MapOrderingBean {\n+        @JsonPropertyOrder(alphabetic=true)\n+        public LinkedHashMap<String,Integer> map;\n+        \n+        public MapOrderingBean(String... keys) {\n+            map = new LinkedHashMap<String,Integer>();\n+            int ix = 1;\n+            for (String key : keys) {\n+                map.put(key, ix++);\n+            }\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = new ObjectMapper();\n+    final ObjectMapper MAPPER = objectMapper();\n     \n     // Test [JACKSON-220]\n     public void testMapSerializer() throws IOException\n         // but can be changed\n         assertEquals(\"{\\\"a\\\":6,\\\"b\\\":3}\", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));\n     }\n+\n+    // [#335[\n+    public void testOrderByKeyViaProperty() throws IOException\n+    {\n+        MapOrderingBean input = new MapOrderingBean(\"c\", \"b\", \"a\");\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'map':{'a':3,'b':2,'c':1}}\"), json);\n+    }        \n }", "timestamp": 1394859659, "metainfo": ""}