{"sha": "2f823444ac34d14ab976b15e70ac82f2168ac7f8", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n \n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.LinkedNode;\n \n-import org.codehaus.jackson.node.JsonNodeFactory;\n \n /**\n  * Object that contains baseline configuration for deserialization\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n \n-import org.codehaus.jackson.node.JsonNodeFactory;\n \n /**\n  * Context for deserialization process. Used to allow passing in configuration\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n      * indicate that <b>no deserializer is configured</b>.\n      *<p>\n      * Specifically, this class is to be used as the marker for\n-     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonDeserialize}\n+     * annotation {@link com.fasterxml.jackson.databind.annotation.JsonDeserialize}\n      */\n     public abstract static class None\n         extends JsonDeserializer<Object> { }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n      * indicate that <b>no serializer is configured</b>.\n      *<p>\n      * Specifically, this class is to be used as the marker for\n-     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonSerialize}.\n+     * annotation {@link com.fasterxml.jackson.databind.annotation.JsonSerialize}.\n      */\n     public abstract static class None\n         extends JsonSerializer<Object> { }\n--- a/src/main/java/com/fasterxml/jackson/databind/KeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/KeyDeserializer.java\n      * indicate that <b>no deserializer is configured</b>.\n      *<p>\n      * Specifically, this class is to be used as the marker for\n-     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonDeserialize}.\n+     * annotation {@link com.fasterxml.jackson.databind.annotation.JsonDeserialize}.\n      *\n      * @since 1.3\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.type.SimpleType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n-import org.codehaus.jackson.node.*;\n \n /**\n  * This mapper (or, data binder, or codec) provides functionality for\n      * more efficient.\n      * \n      * @param <T> Actual node type; usually either basic {@link JsonNode} or\n-     *  {@link org.codehaus.jackson.node.ObjectNode}\n+     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n      * @param fromValue Bean value to convert\n      * @return Root node of the resulting JSON tree\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.VersionUtil;\n import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.NullNode;\n+import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n import com.fasterxml.jackson.databind.type.SimpleType;\n \n-import org.codehaus.jackson.node.JsonNodeFactory;\n-import org.codehaus.jackson.node.NullNode;\n-import org.codehaus.jackson.node.TreeTraversingParser;\n \n /**\n  * Builder object that can be used for per-serialization configuration of\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize.Inclusion;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JacksonStdImpl.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Marker interface used to indicate implementation classes\n+ * (serializers, deserializers etc) that are standard ones Jackson\n+ * uses; not custom ones that application has added. It can be\n+ * added in cases where certain optimizations can be made if\n+ * default instances are uses; for example when handling conversions\n+ * of \"natural\" JSON types like Strings, booleans and numbers.\n+ * \n+ * @since 1.6\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JacksonStdImpl {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonCachable.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Marker annotation used to denote whether given instance\n+ * (currently only used with {@link com.fasterxml.jackson.databind.JsonDeserializer})\n+ * can be cached.\n+ *<p>\n+ * Default action to take in absence of annotation depends\n+ * on object using annotation; with deserializers default is\n+ * to assume instances are not cachable.\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonCachable\n+{\n+    /**\n+     * Default value is true, giving semantics for parameterless tag instance\n+     * such that empty instance indicates that instances of annotated class\n+     * are indeed cachable.\n+     */\n+    boolean value() default true;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonDeserialize.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+\n+/**\n+ * Annotation use for configuring deserialization aspects, by attaching\n+ * to \"setter\" methods or fields, or to value classes.\n+ * When annotating value classes, configuration is used for instances\n+ * of the value class but can be overridden by more specific annotations\n+ * (ones that attach to methods or fields).\n+ *<p>\n+ * An example annotation would be:\n+ *<pre>\n+ *  &#64;JsonDeserialize(using=MySerializer.class,\n+ *    as=MyHashMap.class,\n+ *    keyAs=MyHashKey.class,\n+ *    contentAs=MyHashValue.class\n+ *  )\n+ *</pre>\n+ *<p>\n+ * NOTE: since version 1.2, annotation has also been applicable\n+ * to (constructor) parameters\n+ *\n+ * @since 1.1\n+ */\n+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonDeserialize\n+{\n+    // // // Annotations for explicitly specifying deserializer\n+\n+    /**\n+     * Deserializer class to use for deserializing associated value.\n+     * Depending on what is annotated,\n+     * value is either an instance of annotated class (used globablly\n+     * anywhere where class deserializer is needed); or only used for\n+     * deserializing property access via a setter method.\n+     */\n+    public Class<? extends JsonDeserializer<?>> using()\n+        default JsonDeserializer.None.class;\n+\n+    /**\n+     * Deserializer class to use for deserializing contents (elements\n+     * of a Collection/array, values of Maps) of annotated property.\n+     * Can only be used on instances (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.3\n+     */\n+    public Class<? extends JsonDeserializer<?>> contentUsing()\n+        default JsonDeserializer.None.class;\n+\n+    /**\n+     * Deserializer class to use for deserializing Map keys\n+     * of annotated property.\n+     * Can only be used on instances (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.3\n+     */\n+    public Class<? extends KeyDeserializer> keyUsing()\n+        default KeyDeserializer.None.class;\n+\n+    // // // Annotations for explicitly specifying deserialization type\n+    // // // (which is used for choosing deserializer, if not explicitly\n+    // // // specified\n+\n+    /**\n+     * Concrete type to deserialize values as, instead of type otherwise\n+     * declared. Must be a subtype of declared type; otherwise an\n+     * exception may be thrown by deserializer.\n+     *<p>\n+     * Bogus type {@link NoClass} can be used to indicate that declared\n+     * type is used as is (i.e. this annotation property has no setting);\n+     * this since annotation properties are not allowed to have null value.\n+     *<p>\n+     * Note: if {@link #using} is also used it has precedence\n+     * (since it directly specified\n+     * deserializer, whereas this would only be used to locate the\n+     * deserializer)\n+     * and value of this annotation property is ignored.\n+     */\n+    public Class<?> as() default NoClass.class;\n+\n+    /**\n+     * Concrete type to deserialize keys of {@link java.util.Map} as,\n+     * instead of type otherwise declared.\n+     * Must be a subtype of declared type; otherwise an exception may be\n+     * thrown by deserializer.\n+     */\n+    public Class<?> keyAs() default NoClass.class;\n+\n+    /**\n+     * Concrete type to deserialize content (elements\n+     * of a Collection/array, values of Maps) values as,\n+     * instead of type otherwise declared.\n+     * Must be a subtype of declared type; otherwise an exception may be\n+     * thrown by deserializer.\n+     */\n+    public Class<?> contentAs() default NoClass.class;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonSerialize.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Annotation used for configuring serialization aspects, by attaching\n+ * to \"getter\" methods or fields, or to value classes.\n+ * When annotating value classes, configuration is used for instances\n+ * of the value class but can be overridden by more specific annotations\n+ * (ones that attach to methods or fields).\n+ *<p>\n+ * An example annotation would be:\n+ *<pre>\n+ *  &#64;JsonSerialize(using=MySerializer.class,\n+ *    as=MySubClass.class,\n+ *    include=JsonSerialize.Inclusion.NON_NULL,\n+ *    typing=JsonSerialize.Typing.STATIC\n+ *  )\n+ *</pre>\n+ * (which would be redundant, since some properties block others:\n+ * specifically, 'using' has precedence over 'as', which has precedence\n+ * over 'typing' setting)\n+ *<p>\n+ * NOTE: since version 1.2, annotation has also been applicable\n+ * to (constructor) parameters\n+ *\n+ * @since 1.1\n+ */\n+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonSerialize\n+{\n+    // // // Annotations for explicitly specifying deserializer\n+\n+    /**\n+     * Serializer class to use for\n+     * serializing associated value. Depending on what is annotated,\n+     * value is either an instance of annotated class (used globablly\n+     * anywhere where class serializer is needed); or only used for\n+     * serializing property access via a getter method.\n+     */\n+    public Class<? extends JsonSerializer<?>> using() default JsonSerializer.None.class;\n+\n+    /**\n+     * Serializer class to use for serializing contents (elements\n+     * of a Collection/array, values of Maps) of annotated property.\n+     * Can only be used on properties (methods, fields, constructors),\n+     * and not value classes themselves (as they are typically generic)\n+     *\n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> contentUsing()\n+        default JsonSerializer.None.class;\n+\n+    /**\n+     * Serializer class to use for serializing Map keys\n+     * of annotated property.\n+     * Can only be used on properties (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> keyUsing()\n+        default JsonSerializer.None.class;\n+    \n+    // // // Annotations for type handling, explicit declaration\n+    // // // (type used for choosing deserializer, if not explicitly\n+    // // // specified)\n+\n+    /**\n+     * Supertype (of declared type, which itself is supertype of runtime type)\n+     * to use as type when locating serializer to use.\n+     *<p>\n+     * Bogus type {@link NoClass} can be used to indicate that declared\n+     * type is used as is (i.e. this annotation property has no setting);\n+     * this since annotation properties are not allowed to have null value.\n+     *<p>\n+     * Note: if {@link #using} is also used it has precedence\n+     * (since it directly specifies\n+     * serializer, whereas this would only be used to locate the\n+     * serializer)\n+     * and value of this annotation property is ignored.\n+     */\n+    public Class<?> as() default NoClass.class;\n+\n+    /**\n+     * Concrete type to serialize keys of {@link java.util.Map} as,\n+     * instead of type otherwise declared.\n+     * Must be a supertype of declared type; otherwise an exception may be\n+     * thrown by serializer.\n+     */\n+    public Class<?> keyAs() default NoClass.class;\n+\n+    /**\n+     * Concrete type to serialize content value (elements\n+     * of a Collection/array, values of Maps) as,\n+     * instead of type otherwise declared.\n+     * Must be a supertype of declared type; otherwise an exception may be\n+     * thrown by serializer.\n+     */\n+    public Class<?> contentAs() default NoClass.class;\n+    \n+    /**\n+     * Whether type detection used is dynamic or static: that is,\n+     * whether actual runtime type is used (dynamic), or just the\n+     * declared type (static).\n+     *\n+     * @since 1.2\n+     */\n+    public Typing typing() default Typing.DYNAMIC;\n+\n+    // // // Annotation(s) for inclusion criteria\n+\n+    /**\n+     * Which properties of annotated Bean are\n+     * to be included in serialization (has no effect on other types\n+     * like enums, primitives or collections).\n+     * Choices are \"all\", \"properties that have value other than null\"\n+     * and \"properties that have non-default value\" (i.e. default value\n+     * being property setting for a Bean constructed with default no-arg\n+     * constructor, often null).\n+     *\n+     */\n+    public Inclusion include() default Inclusion.ALWAYS;\n+    \n+    /*\n+    /**********************************************************\n+    /* Value enumerations needed\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Enumeration used with {@link JsonSerialize#include} property\n+     * to define which properties\n+     * of Java Beans are to be included in serialization\n+     *\n+     * @since 1.1\n+     */\n+    public enum Inclusion\n+    {\n+        /**\n+         * Value that indicates that properties are to be always included,\n+         * independent of value\n+         */\n+        ALWAYS,\n+\n+        /**\n+         * Value that indicates that only properties with non-null\n+         * values are to be included.\n+         */\n+        NON_NULL,\n+\n+        /**\n+         * Value that indicates that only properties that have values\n+         * that differ from default settings (meaning values they have\n+         * when Bean is constructed with its no-arguments constructor)\n+         * are to be included. Value is generally not useful with\n+         * {@link java.util.Map}s, since they have no default values;\n+         * and if used, works same as {@link #ALWAYS}.\n+         */\n+        NON_DEFAULT,\n+\n+        /**\n+         * Value that indicates that only properties that have values\n+         * that values that are null or what is considered empty are\n+         * not to be included.\n+         * Emptiness is defined for following type:\n+         *<ul>\n+         * <li>For {@link java.util.Collection}s and {@link java.util.Map}s,\n+         *    method <code>isEmpty()</code> is called;\n+         *   </li>\n+         * <li>For Java arrays, empty arrays are ones with length of 0\n+         *   </li>\n+         * <li>For Java {@link java.lang.String}s, <code>length()</code> is called,\n+         *   and return value of 0 indicates empty String (note that <code>String.isEmpty()</code>\n+         *   was added in Java 1.6 and as such can not be used by Jackson\n+         *   </li>\n+         * <ul>\n+         *  For other types, non-null values are to be included.\n+         * \n+         * @since 1.9\n+         */\n+        NON_EMPTY\n+        ;\n+    }\n+\n+    /**\n+     * Enumeration used with {@link JsonSerialize#typing} property\n+     * to define whether type detection is based on dynamic runtime\n+     * type (DYNAMIC) or declared type (STATIC).\n+     * \n+     * @since 1.1\n+     */\n+    public enum Typing\n+    {\n+        /**\n+         * Value that indicates that the actual dynamic runtime type is to\n+         * be used.\n+         */\n+        DYNAMIC,\n+\n+        /**\n+         * Value that indicates that the static declared type is to\n+         * be used.\n+         */\n+        STATIC\n+        ;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Annotation that can be used to plug a custom type identifier handler\n+ * ({@link TypeIdResolver})\n+ * to be used by\n+ * {@link com.fasterxml.jackson.databind.jsontype.TypeSerializer}s\n+ * and {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer}s\n+ * for converting between java types and type id included in JSON content.\n+ * In simplest cases this can be a simple class with static mapping between\n+ * type names and matching classes.\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonTypeIdResolver\n+{\n+    /**\n+     * Defines implementation class of {@link TypeIdResolver} to use for\n+     * converting between external type id (type name) and actual\n+     * type of object.\n+     */\n+    public Class<? extends TypeIdResolver> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.*;\n+\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Annotation that can be used to explicitly define custom resolver\n+ * used for handling serialization and deserialization of type information,\n+ * needed for handling of polymorphic types (or sometimes just for linking\n+ * abstract types to concrete types)\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonTypeResolver\n+{\n+    /**\n+     * Defines implementation class of {@link TypeResolverBuilder} which is used to construct\n+     * actual {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer} and {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer}\n+     * instances that handle reading and writing addition type information needed to support polymorphic\n+     * deserialization.\n+     */\n+    public Class<? extends TypeResolverBuilder<?>> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonValueInstantiator.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+\n+/**\n+ * Annotation that can be used to indicate a {@link ValueInstantiator} to use\n+ * for creating instances of specified type.\n+ * \n+ * @since 1.9\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonValueInstantiator\n+{\n+    /**\n+     * @return  {@link ValueInstantiator} to use for annotated type\n+     */\n+    public Class<? extends ValueInstantiator> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+/**\n+ * Marker class used with annotations to indicate \"no class\". This is\n+ * a silly but necessary work-around -- annotations can not take nulls\n+ * as either default or explicit values. Hence for class values we must\n+ * explicitly use a bogus placeholder to denote equivalent of\n+ * \"no class\" (for which 'null' is usually the natural choice).\n+ *<p>\n+ * Note before version 1.4, this marker class was under\n+ * \"org.codehaus.jackson.annotate\". However, since it is only used\n+ * by annotations in \"org.codehaus.jackson.map.annotate\" (and not externally\n+ * exposed), it was moved to that package as of version 1.5.\n+ */\n+public final class NoClass\n+{\n+    private NoClass() { }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/package-info.java\n+/**\n+ * Annotations that directly depend on classes in databinding bundle\n+ * (not just Jackson core) and can not be included\n+ * in Jackson core annotations package (because it can not have any\n+ * external dependencies).\n+ */\n+package com.fasterxml.jackson.databind.annotation;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JsonCachable;\n+import com.fasterxml.jackson.databind.annotation.JsonCachable;\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CalendarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CalendarDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n @JacksonStdImpl\n public class CalendarDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n @JacksonStdImpl\n public class ClassDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.annotate.JsonCachable;\n+import com.fasterxml.jackson.databind.annotation.JsonCachable;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-\n-import org.codehaus.jackson.node.*;\n+import com.fasterxml.jackson.databind.node.*;\n+\n \n /**\n  * Deserializer that can build instances of {@link JsonNode} from any\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ArrayType;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n import com.fasterxml.jackson.core.io.NumberInput;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n @JacksonStdImpl\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.*;\n+import com.fasterxml.jackson.databind.annotation.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize.Typing;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize.Typing;\n \n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n import com.fasterxml.jackson.annotation.JsonValue;\n \n import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n-import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.node.JsonNodeFactory;\n \n /**\n  * A {@link org.codehaus.jackson.JsonNode} that represents a JSON-Schema instance.\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+\n+/**\n+ * Node class that represents Arrays mapped from Json content.\n+ */\n+public final class ArrayNode\n+    extends ContainerNode\n+{\n+    protected ArrayList<JsonNode> _children;\n+\n+    public ArrayNode(JsonNodeFactory nc) { super(nc); }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementation of core JsonNode API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.START_ARRAY; }\n+\n+    @Override\n+    public boolean isArray() { return true; }\n+\n+    @Override\n+    public int size()\n+    {\n+        return (_children == null) ? 0 : _children.size();\n+    }\n+\n+    @Override\n+    public Iterator<JsonNode> getElements()\n+    {\n+        return (_children == null) ? NoNodesIterator.instance() : _children.iterator();\n+    }\n+\n+    @Override\n+    public JsonNode get(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.get(index);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JsonNode get(String fieldName) { return null; }\n+\n+    @Override\n+    public JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n+\n+    @Override\n+    public JsonNode path(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.get(index);\n+        }\n+        return MissingNode.getInstance();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeStartArray();\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+                 *   extend BaseJsonNode? Or if not, at least implement\n+                 *   JsonSerializable? Let's start with former, change if\n+                 *   we must.\n+                 */\n+                ((BaseJsonNode)n).serialize(jg, provider);\n+            }\n+        }\n+        jg.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForArray(this, jg);\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                ((BaseJsonNode)n).serialize(jg, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForArray(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                JsonNode value = node.findValue(fieldName);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findValues(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                JsonNode parent = node.findParent(fieldName);\n+                if (parent != null) {\n+                    return (ObjectNode) parent;\n+                }\n+            }\n+        }\n+        return null;        \n+    }\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findParents(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will set specified field, replacing old value,\n+     * if any.\n+     *\n+     * @param value to set field to; if null, will be converted\n+     *   to a {@link NullNode} first  (to remove field entry, call\n+     *   {@link #remove} instead)\n+     *\n+     * @return Old value of the field, if any; null if there was no\n+     *   old value.\n+     */\n+    public JsonNode set(int index, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _set(index, value);\n+    }\n+\n+    public void add(JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        _add(value);\n+    }\n+\n+    /**\n+     * Method for adding all child nodes of given Array, appending to\n+     * child nodes this array contains\n+     * \n+     * @param other Array to add contents from\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode addAll(ArrayNode other)\n+    {\n+        int len = other.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new ArrayList<JsonNode>(len+2);\n+            }\n+            other.addContentsTo(_children);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding given nodes as child nodes of this array node.\n+     * \n+     * @param nodes Nodes to add\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode addAll(Collection<JsonNode> nodes)\n+    {\n+        int len = nodes.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new ArrayList<JsonNode>(nodes);\n+            } else {\n+                _children.addAll(nodes);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for inserting specified child node as an element\n+     * of this Array. If index is 0 or less, it will be inserted as\n+     * the first element; if >= size(), appended at the end, and otherwise\n+     * inserted before existing element in specified index.\n+     * No exceptions are thrown for any index.\n+     */\n+    public void insert(int index, JsonNode value)\n+    {\n+        if (value == null) {\n+            value = nullNode();\n+        }\n+        _insert(index, value);\n+    }\n+\n+    /**\n+     * Method for removing an entry from this ArrayNode.\n+     * Will return value of the entry at specified index, if entry existed;\n+     * null if not.\n+     */\n+    public JsonNode remove(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.remove(index);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ArrayNode removeAll()\n+    {\n+        _children = null;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, generic; addXxx()/insertXxx()\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will construct an ArrayNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ArrayNode\n+     */\n+    public ArrayNode addArray()\n+    {\n+        ArrayNode n  = arrayNode();\n+        _add(n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it at the end\n+     * of this array node.\n+     *\n+     * @return Newly constructed ObjectNode\n+     */\n+    public ObjectNode addObject()\n+    {\n+        ObjectNode n  = objectNode();\n+        _add(n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct a POJONode and add it at the end\n+     * of this array node.\n+     */\n+    public void addPOJO(Object value)\n+    {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(POJONode(value));\n+        }\n+    }\n+\n+    public void addNull()\n+    {\n+        _add(nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(int v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Integer value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(long v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Long value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(float v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Float value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(double v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Double value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.doubleValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(BigDecimal v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void add(String v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void add(boolean v) { _add(booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Boolean value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void add(byte[] v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(binaryNode(v));\n+        }\n+    }\n+\n+    public ArrayNode insertArray(int index)\n+    {\n+        ArrayNode n  = arrayNode();\n+        _insert(index, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it at the end\n+     * of this array node.\n+     *\n+     * @return Newly constructed ObjectNode\n+     */\n+    public ObjectNode insertObject(int index)\n+    {\n+        ObjectNode n  = objectNode();\n+        _insert(index, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct a POJONode and add it at the end\n+     * of this array node.\n+     */\n+    public void insertPOJO(int index, Object value)\n+    {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, POJONode(value));\n+        }\n+    }\n+\n+    public void insertNull(int index)\n+    {\n+        _insert(index, nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, int v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Integer value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, long v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Long value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, float v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Float value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, double v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Double value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.doubleValue()));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, BigDecimal v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void insert(int index, String v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void insert(int index, boolean v) { _insert(index, booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Boolean value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void insert(int index, byte[] v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, binaryNode(v));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Package methods (for other node classes to use)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.6\n+     */\n+    protected void addContentsTo(List<JsonNode> dst)\n+    {\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                dst.add(n);\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        ArrayNode other = (ArrayNode) o;\n+        if (_children == null || _children.size() == 0) {\n+            return other.size() == 0;\n+        }\n+        return other._sameChildren(_children);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        int hash;\n+        if (_children == null) {\n+            hash = 1;\n+        } else {\n+            hash = _children.size();\n+            for (JsonNode n : _children) {\n+                if (n != null) {\n+                    hash ^= n.hashCode();\n+                }\n+            }\n+        }\n+        return hash;\n+    }\n+\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(16 + (size() << 4));\n+        sb.append('[');\n+        if (_children != null) {\n+            for (int i = 0, len = _children.size(); i < len; ++i) {\n+                if (i > 0) {\n+                    sb.append(',');\n+                }\n+                sb.append(_children.get(i).toString());\n+            }\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    public JsonNode _set(int index, JsonNode value)\n+    {\n+        if (_children == null || index < 0 || index >= _children.size()) {\n+            throw new IndexOutOfBoundsException(\"Illegal index \"+index+\", array size \"+size());\n+        }\n+        return _children.set(index, value);\n+    }\n+\n+    private void _add(JsonNode node)\n+    {\n+        if (_children == null) {\n+            _children = new ArrayList<JsonNode>();\n+        }\n+        _children.add(node);\n+    }\n+\n+    private void _insert(int index, JsonNode node)\n+    {\n+        if (_children == null) {\n+            _children = new ArrayList<JsonNode>();\n+            _children.add(node);\n+            return;\n+        }\n+        if (index < 0) {\n+            _children.add(0, node);\n+        } else if (index >= _children.size()) {\n+            _children.add(node);\n+        } else {\n+            _children.add(index, node);\n+        }\n+    }\n+\n+    /**\n+     * Note: this method gets called iff <code>otherChildren</code>\n+     * is non-empty\n+     */\n+    private boolean _sameChildren(ArrayList<JsonNode> otherChildren)\n+    {\n+        int len = otherChildren.size();\n+        if (this.size() != len) { // important: call size() to handle case of null list...\n+            return false;\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            if (!_children.get(i).equals(otherChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonSerializable;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+\n+/**\n+ * Abstract base class common to all standard {@link JsonNode}\n+ * implementations.\n+ * The main addition here is that we declare that sub-classes must\n+ * implement {@link JsonSerializableWithType}.\n+ * This simplifies object mapping\n+ * aspects a bit, as no external serializers are needed.\n+ */\n+public abstract class BaseJsonNode\n+    extends JsonNode\n+    implements JsonSerializable\n+{\n+    protected BaseJsonNode() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Basic definitions for non-container types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonNode findValue(String fieldName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public final JsonNode findPath(String fieldName)\n+    {\n+        JsonNode value = findValue(fieldName);\n+        if (value == null) {\n+            return MissingNode.getInstance();\n+        }\n+        return value;\n+    }\n+    \n+    // note: co-variant return type\n+    @Override\n+    public ObjectNode findParent(String fieldName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) {\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Support for traversal-as-stream\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonParser traverse() {\n+        return new TreeTraversingParser(this);\n+    }\n+\n+    /**\n+     * Method that can be used for efficient type detection\n+     * when using stream abstraction for traversing nodes.\n+     * Will return the first {@link JsonToken} that equivalent\n+     * stream event would produce (for most nodes there is just\n+     * one token but for structured/container types multiple)\n+     *\n+     * @since 1.3\n+     */\n+    @Override\n+    public abstract JsonToken asToken();\n+\n+    /**\n+     * @since 1.3\n+     */\n+    @Override\n+    public JsonParser.NumberType getNumberType() {\n+        // most types non-numeric, so:\n+        return null; \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonSerializable\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to serialize node instances using given generator.\n+     */\n+    @Override\n+    public abstract void serialize(JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Type information is needed, even if JsonNode instances are \"plain\" JSON,\n+     * since they may be mixed with other types.\n+     */\n+    @Override\n+    public abstract void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException;\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 64-bit integer values.\n+ */\n+public final class BigIntegerNode\n+    extends NumericNode\n+{\n+    final protected BigInteger _value;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public BigIntegerNode(BigInteger v) { _value = v; }\n+\n+    public static BigIntegerNode valueOf(BigInteger v) { return new BigIntegerNode(v); }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_INTEGER; }\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isBigInteger() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return _value;\n+    }\n+\n+    @Override\n+    public int getIntValue() { return _value.intValue(); }\n+\n+    @Override\n+    public long getLongValue() { return _value.longValue(); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return _value.doubleValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return new BigDecimal(_value); }\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public String asText() {\n+        return _value.toString();\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return !BigInteger.ZERO.equals(_value);\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((BigIntegerNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _value.hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains Base64 encoded binary value, which will be\n+ * output and stored as Json String value.\n+ */\n+public final class BinaryNode\n+    extends ValueNode\n+{\n+    final static BinaryNode EMPTY_BINARY_NODE = new BinaryNode(new byte[0]);\n+\n+    final byte[] _data;\n+\n+    public BinaryNode(byte[] data)\n+    {\n+        _data = data;\n+    }\n+\n+    public BinaryNode(byte[] data, int offset, int length)\n+    {\n+        if (offset == 0 && length == data.length) {\n+            _data = data;\n+        } else {\n+            _data = new byte[length];\n+            System.arraycopy(data, offset, _data, 0, length);\n+        }\n+    }\n+\n+    public static BinaryNode valueOf(byte[] data)\n+    {\n+        if (data == null) {\n+            return null;\n+        }\n+        if (data.length == 0) {\n+            return EMPTY_BINARY_NODE;\n+        }\n+        return new BinaryNode(data);\n+    }\n+\n+    public static BinaryNode valueOf(byte[] data, int offset, int length)\n+    {\n+        if (data == null) {\n+            return null;\n+        }\n+        if (length == 0) {\n+            return EMPTY_BINARY_NODE;\n+        }\n+        return new BinaryNode(data, offset, length);\n+    }\n+\n+    @Override\n+    public JsonToken asToken() {\n+        /* No distinct type; could use one for textual values,\n+         * but given that it's not in text form at this point,\n+         * embedded-object is closest\n+         */\n+        return JsonToken.VALUE_EMBEDDED_OBJECT;\n+    }\n+\n+    @Override\n+    public boolean isBinary() { return true; }\n+\n+    /**\n+     *<p>\n+     * Note: caller is not to modify returned array in any way, since\n+     * it is not a copy but reference to the underlying byte array.\n+     */\n+    @Override\n+    public byte[] getBinaryValue() { return _data; }\n+\n+    /**\n+     * Hmmh. This is not quite as efficient as using {@link #serialize},\n+     * but will work correctly.\n+     */\n+    @Override\n+    public String asText() {\n+        return Base64Variants.getDefaultVariant().encode(_data, false);\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeBinary(_data);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return Arrays.equals(((BinaryNode) o)._data, _data);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (_data == null) ? -1 : _data.length;\n+    }\n+\n+    /**\n+     * Different from other values, since contents need to be surrounded\n+     * by (double) quotes.\n+     */\n+    @Override\n+    public String toString()\n+    {\n+        return Base64Variants.getDefaultVariant().encode(_data, true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * This concrete value class is used to contain boolean (true / false)\n+ * values. Only two instances are ever created, to minimize memory\n+ * usage\n+ */\n+public final class BooleanNode\n+    extends ValueNode\n+{\n+    // // Just need two instances...\n+\n+    public final static BooleanNode TRUE = new BooleanNode();\n+    public final static BooleanNode FALSE = new BooleanNode();\n+\n+    private BooleanNode() { }\n+\n+    public static BooleanNode getTrue() { return TRUE; }\n+    public static BooleanNode getFalse() { return FALSE; }\n+\n+    public static BooleanNode valueOf(boolean b) { return b ? TRUE : FALSE; }\n+\n+    // Interesting... two choices...\n+    @Override public JsonToken asToken() {\n+        return (this == TRUE) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;\n+    }\n+\n+    @Override\n+    public boolean isBoolean() { return true; }\n+\n+    @Override\n+    public boolean getBooleanValue() {\n+        return (this == TRUE);\n+    }\n+\n+    @Override\n+    public String asText() {\n+        return (this == TRUE) ? \"true\" : \"false\";\n+    }\n+\n+    @Override\n+    public boolean asBoolean() {\n+        return (this == TRUE);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return (this == TRUE);\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return (this == TRUE) ? 1 : 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return (this == TRUE) ? 1L : 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return (this == TRUE) ? 1.0 : 0.0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeBoolean(this == TRUE);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        /* Since there are only ever two instances in existence\n+         * can do identity comparison\n+         */\n+        return (o == this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * This intermediate base class is used for all container nodes,\n+ * specifically, array and object nodes.\n+ */\n+public abstract class ContainerNode\n+    extends BaseJsonNode\n+{\n+    /**\n+     * We will keep a reference to the Object (usually TreeMapper)\n+     * that can construct instances of nodes to add to this container\n+     * node.\n+     */\n+    JsonNodeFactory _nodeFactory;\n+\n+    protected ContainerNode(JsonNodeFactory nc)\n+    {\n+        _nodeFactory = nc;\n+    }\n+\n+    @Override\n+    public boolean isContainerNode() { return true; }\n+\n+    @Override\n+    public abstract JsonToken asToken();\n+    \n+    @Override\n+    public String asText() { return \"\"; }\n+\n+    /*\n+    /**********************************************************\n+    /* Find methods; made abstract again to ensure implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract JsonNode findValue(String fieldName);\n+    \n+    @Override\n+    public abstract ObjectNode findParent(String fieldName);\n+\n+    @Override\n+    public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar);\n+    \n+    @Override\n+    public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar);\n+\n+    @Override\n+    public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods reset as abstract to force real implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract int size();\n+\n+    @Override\n+    public abstract JsonNode get(int index);\n+\n+    @Override\n+    public abstract JsonNode get(String fieldName);\n+\n+    /*\n+    /**********************************************************\n+    /* NodeCreator implementation, just dispatch to\n+    /* the real creator\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method that constructs and returns an empty {@link ArrayNode}\n+     * Construction is done using registered {@link JsonNodeFactory}.\n+     */\n+    public final ArrayNode arrayNode() { return _nodeFactory.arrayNode(); }\n+\n+    /**\n+     * Factory method that constructs and returns an empty {@link ObjectNode}\n+     * Construction is done using registered {@link JsonNodeFactory}.\n+     */\n+    public final ObjectNode objectNode() { return _nodeFactory.objectNode(); }\n+\n+    public final NullNode nullNode() { return _nodeFactory.nullNode(); }\n+\n+    public final BooleanNode booleanNode(boolean v) { return _nodeFactory.booleanNode(v); }\n+\n+    public final NumericNode numberNode(byte v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(short v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(int v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(long v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(float v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(double v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(BigDecimal v) { return (_nodeFactory.numberNode(v)); }\n+\n+    public final TextNode textNode(String text) { return _nodeFactory.textNode(text); }\n+\n+    public final BinaryNode binaryNode(byte[] data) { return _nodeFactory.binaryNode(data); }\n+    public final BinaryNode binaryNode(byte[] data, int offset, int length) { return _nodeFactory.binaryNode(data, offset, length); }\n+\n+    public final POJONode POJONode(Object pojo) { return _nodeFactory.POJONode(pojo); }\n+\n+    /*\n+    /**********************************************************\n+    /* Common mutators\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for removing all children container has (if any)\n+     *\n+     * @return Container node itself (to allow method call chaining)\n+     *\n+     * @since 1.3\n+     */\n+    public abstract ContainerNode removeAll();\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    protected static class NoNodesIterator\n+        implements Iterator<JsonNode>\n+    {\n+        final static NoNodesIterator instance = new NoNodesIterator();\n+\n+        private NoNodesIterator() { }\n+\n+        public static NoNodesIterator instance() { return instance; }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public JsonNode next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() {\n+            // could as well throw IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    protected static class NoStringsIterator\n+        implements Iterator<String>\n+    {\n+        final static NoStringsIterator instance = new NoStringsIterator();\n+\n+        private NoStringsIterator() { }\n+\n+        public static NoStringsIterator instance() { return instance; }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public String next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() {\n+            // could as well throw IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains values that do not fit in simple\n+ * integer (int, long) or floating point (double) values.\n+ */\n+public final class DecimalNode\n+    extends NumericNode\n+{\n+    final protected BigDecimal _value;\n+\n+    /* \n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public DecimalNode(BigDecimal v) { _value = v; }\n+\n+    public static DecimalNode valueOf(BigDecimal d) { return new DecimalNode(d); }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_DECIMAL; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isFloatingPointNumber() { return true; }\n+    \n+    @Override\n+    public boolean isBigDecimal() { return true; }\n+    \n+    @Override\n+    public Number getNumberValue() { return _value; }\n+\n+    @Override\n+    public int getIntValue() { return _value.intValue(); }\n+\n+    @Override\n+    public long getLongValue() { return _value.longValue(); }\n+\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return _value.toBigInteger(); }\n+\n+    @Override\n+    public double getDoubleValue() { return _value.doubleValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return _value; }\n+\n+    @Override\n+    public String asText() {\n+        return _value.toString();\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((DecimalNode) o)._value.equals(_value);\n+    }\n+\n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains 64-bit (\"double precision\")\n+ * floating point values simple 32-bit integer values.\n+ */\n+public final class DoubleNode\n+    extends NumericNode\n+{\n+    protected final double _value;\n+\n+    /* \n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public DoubleNode(double v) { _value = v; }\n+\n+    public static DoubleNode valueOf(double v) { return new DoubleNode(v); }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.DOUBLE; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isFloatingPointNumber() { return true; }\n+\n+    @Override\n+    public boolean isDouble() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Double.valueOf(_value);\n+    }\n+\n+    @Override\n+        public int getIntValue() { return (int) _value; }\n+\n+    @Override\n+        public long getLongValue() { return (long) _value; }\n+\n+    @Override\n+        public double getDoubleValue() { return _value; }\n+\n+    @Override\n+        public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() {\n+        return getDecimalValue().toBigInteger();\n+    }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((DoubleNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        // same as hashCode Double.class uses\n+        long l = Double.doubleToLongBits(_value);\n+        return ((int) l) ^ (int) (l >> 32);\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 32-bit integer values.\n+ */\n+public final class IntNode\n+    extends NumericNode\n+{\n+    // // // Let's cache small set of common value\n+\n+    final static int MIN_CANONICAL = -1;\n+    final static int MAX_CANONICAL = 10;\n+\n+    private final static IntNode[] CANONICALS;\n+    static {\n+        int count = MAX_CANONICAL - MIN_CANONICAL + 1;\n+        CANONICALS = new IntNode[count];\n+        for (int i = 0; i < count; ++i) {\n+            CANONICALS[i] = new IntNode(MIN_CANONICAL + i);\n+        }\n+    }\n+\n+    /**\n+     * Integer value this node contains\n+     */\n+    final int _value;\n+\n+    /* \n+    ************************************************\n+    * Construction\n+    ************************************************\n+    */\n+\n+    public IntNode(int v) { _value = v; }\n+\n+    public static IntNode valueOf(int i) {\n+        if (i > MAX_CANONICAL || i < MIN_CANONICAL) return new IntNode(i);\n+        return CANONICALS[i - MIN_CANONICAL];\n+    }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.INT; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isInt() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Integer.valueOf(_value);\n+    }\n+\n+    @Override\n+    public int getIntValue() { return _value; }\n+\n+    @Override\n+    public long getLongValue() { return (long) _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return (double) _value; }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return _value != 0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((IntNode) o)._value == _value;\n+    }\n+\n+    @Override\n+        public int hashCode() { return _value; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * Base class that specifies methods for getting access to\n+ * Node instances (newly constructed, or shared, depending\n+ * on type), as well as basic implementation of the methods. \n+ * Designed to be sub-classed if extended functionality (additions\n+ * to behavior of node types, mostly) is needed.\n+ */\n+public class JsonNodeFactory\n+{\n+    /**\n+     * Default singleton instance that construct \"standard\" node instances:\n+     * given that this class is stateless, a globally shared singleton\n+     * can be used.\n+     */\n+    public final static JsonNodeFactory instance = new JsonNodeFactory();\n+\n+    protected JsonNodeFactory() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for literal values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for getting an instance of JSON boolean value\n+     * (either literal 'true' or 'false')\n+     */\n+    public BooleanNode booleanNode(boolean v) {\n+        return v ? BooleanNode.getTrue() : BooleanNode.getFalse();\n+    }\n+\n+    /**\n+     * Factory method for getting an instance of JSON null node (which\n+     * represents literal null value)\n+     */\n+    public NullNode nullNode() { return NullNode.getInstance(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for numeric values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 8-bit value\n+     */\n+    public NumericNode numberNode(byte v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Byte value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 16-bit integer value\n+     */\n+    public NumericNode numberNode(short v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Short value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.shortValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 32-bit integer value\n+     */\n+    public NumericNode numberNode(int v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Integer value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 64-bit integer value\n+     */\n+    public NumericNode numberNode(long v) { return LongNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Long value) {\n+        return (value == null) ? nullNode() : LongNode.valueOf(value.longValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given unlimited range integer value\n+     */\n+    public NumericNode numberNode(BigInteger v) { return BigIntegerNode.valueOf(v); }\n+\n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 32-bit floating point value\n+     */\n+    public NumericNode numberNode(float v) { return DoubleNode.valueOf((double) v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Float value) {\n+        return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 64-bit floating point value\n+     */\n+    public NumericNode numberNode(double v) { return DoubleNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Double value) {\n+        return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given unlimited precision floating point value\n+     */\n+    public NumericNode numberNode(BigDecimal v) { return DecimalNode.valueOf(v); }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for textual values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for constructing a node that represents JSON\n+     * String value\n+     */\n+    public TextNode textNode(String text) { return TextNode.valueOf(text); }\n+\n+    /**\n+     * Factory method for constructing a node that represents given\n+     * binary data, and will get serialized as equivalent base64-encoded\n+     * String value\n+     */\n+    public BinaryNode binaryNode(byte[] data) { return BinaryNode.valueOf(data); }\n+\n+    /**\n+     * Factory method for constructing a node that represents given\n+     * binary data, and will get serialized as equivalent base64-encoded\n+     * String value\n+     */\n+    public BinaryNode binaryNode(byte[] data, int offset, int length) {\n+        return BinaryNode.valueOf(data, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory method for structured values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for constructing an empty JSON Array node\n+     */\n+    public ArrayNode arrayNode() { return new ArrayNode(this); }\n+\n+    /**\n+     * Factory method for constructing an empty JSON Object (\"struct\") node\n+     */\n+    public ObjectNode objectNode() { return new ObjectNode(this); }\n+\n+    /**\n+     * Factory method for constructing a wrapper for POJO\n+     * (\"Plain Old Java Object\") objects; these will get serialized\n+     * using data binding, usually as JSON Objects, but in some\n+     * cases as JSON Strings or other node types.\n+     */\n+    public POJONode POJONode(Object pojo) { return new POJONode(pojo); }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 64-bit integer values.\n+ */\n+public final class LongNode\n+    extends NumericNode\n+{\n+    final long _value;\n+\n+    /* \n+    ************************************************\n+    * Construction\n+    ************************************************\n+    */\n+\n+    public LongNode(long v) { _value = v; }\n+\n+    public static LongNode valueOf(long l) { return new LongNode(l); }\n+\n+    /* \n+    ************************************************\n+    * Overrridden JsonNode methods\n+    ************************************************\n+    */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.LONG; }\n+\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isLong() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Long.valueOf(_value);\n+    }\n+\n+    @Override\n+    public int getIntValue() { return (int) _value; }\n+\n+    @Override\n+    public long getLongValue() { return _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return (double) _value; }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return _value != 0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((LongNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return ((int) _value) ^ (int) (_value >> 32);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+\n+/**\n+ * This singleton node class is generated to denote \"missing nodes\"\n+ * along paths that do not exist. For example, if a path via\n+ * element of an array is requested for an element outside range\n+ * of elements in the array; or for a non-array value, result\n+ * will be reference to this node.\n+ *<p>\n+ * In most respects this placeholder node will act as {@link NullNode};\n+ * for example, for purposes of value conversions, value is considered\n+ * to be null and represented as value zero when used for numeric\n+ * conversions. \n+ */\n+public final class MissingNode\n+    extends BaseJsonNode\n+{\n+    private final static MissingNode instance = new MissingNode();\n+\n+    private MissingNode() { }\n+\n+    public static MissingNode getInstance() { return instance; }\n+\n+    @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n+\n+    @Override\n+    public boolean isMissingNode() { return true; }\n+\n+    @Override\n+    public String asText() { return null; }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return 0.0;\n+    }\n+    \n+    @Override\n+    public JsonNode path(String fieldName) { return this; }\n+\n+    @Override\n+    public JsonNode path(int index) { return this; }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Nothing to output... should we signal an error tho?\n+         * Chances are, this is an erroneous call. For now, let's\n+         * not do that.\n+         */\n+        jg.writeNull();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNull();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        /* Hmmh. Since there's just a singleton instance, this\n+         * fails in all cases but with identity comparison.\n+         * However: if this placeholder value was to be considered\n+         * similar to Sql NULL, it shouldn't even equal itself?\n+         * That might cause problems when dealing with collections\n+         * like Sets... so for now, let's let identity comparison\n+         * return true.\n+         */\n+        return (o == this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        // toString() should never return null\n+        return \"\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Helper class used by {@link TreeTraversingParser} to keep track\n+ * of current location within traversed JSON tree.\n+ */\n+abstract class NodeCursor\n+    extends JsonStreamContext\n+{\n+    /**\n+     * Parent cursor of this cursor, if any; null for root\n+     * cursors.\n+     */\n+    protected final NodeCursor _parent;\n+\n+    public NodeCursor(int contextType, NodeCursor p)\n+    {\n+        super();\n+        _type = contextType;\n+        _index = -1;\n+        _parent = p;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonStreamContext impl\n+    /**********************************************************\n+     */\n+\n+    // note: co-variant return type\n+    @Override\n+    public final NodeCursor getParent() { return _parent; }\n+\n+    @Override\n+    public abstract String getCurrentName();\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public abstract JsonToken nextToken();\n+    public abstract JsonToken nextValue();\n+    public abstract JsonToken endToken();\n+\n+    public abstract JsonNode currentNode();\n+    public abstract boolean currentHasChildren();\n+\n+    /**\n+     * Method called to create a new context for iterating all\n+     * contents of the current structured value (JSON array or object)\n+     */\n+    public final NodeCursor iterateChildren() {\n+        JsonNode n = currentNode();\n+        if (n == null) throw new IllegalStateException(\"No current node\");\n+        if (n.isArray()) { // false since we have already returned START_ARRAY\n+            return new Array(n, this);\n+        }\n+        if (n.isObject()) {\n+            return new Object(n, this);\n+        }\n+        throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete implementations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Context matching root-level value nodes (i.e. anything other\n+     * than JSON Object and Array).\n+     * Note that context is NOT created for leaf values.\n+     */\n+    protected final static class RootValue\n+        extends NodeCursor\n+    {\n+        JsonNode _node;\n+\n+        protected boolean _done = false;\n+\n+        public RootValue(JsonNode n, NodeCursor p) {\n+            super(JsonStreamContext.TYPE_ROOT, p);\n+            _node = n;\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return null; }\n+\n+        @Override\n+        public JsonToken nextToken() {\n+            if (!_done) {\n+                _done = true;\n+                return _node.asToken();\n+            }\n+            _node = null;\n+            return null;\n+        }\n+        \n+        @Override\n+        public JsonToken nextValue() { return nextToken(); }\n+        @Override\n+        public JsonToken endToken() { return null; }\n+        @Override\n+        public JsonNode currentNode() { return _node; }\n+        @Override\n+        public boolean currentHasChildren() { return false; }\n+    }\n+\n+    /**\n+     * Cursor used for traversing non-empty JSON Array nodes\n+     */\n+    protected final static class Array\n+        extends NodeCursor\n+    {\n+        Iterator<JsonNode> _contents;\n+\n+        JsonNode _currentNode;\n+\n+        public Array(JsonNode n, NodeCursor p) {\n+            super(JsonStreamContext.TYPE_ARRAY, p);\n+            _contents = n.getElements();\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return null; }\n+\n+        @Override\n+        public JsonToken nextToken()\n+        {\n+            if (!_contents.hasNext()) {\n+                _currentNode = null;\n+                return null;\n+            }\n+            _currentNode = _contents.next();\n+            return _currentNode.asToken();\n+        }\n+\n+        @Override\n+        public JsonToken nextValue() { return nextToken(); }\n+        @Override\n+        public JsonToken endToken() { return JsonToken.END_ARRAY; }\n+\n+        @Override\n+        public JsonNode currentNode() { return _currentNode; }\n+        @Override\n+        public boolean currentHasChildren() {\n+            // note: ONLY to be called for container nodes\n+            return ((ContainerNode) currentNode()).size() > 0;\n+        }\n+    }\n+\n+    /**\n+     * Cursor used for traversing non-empty JSON Object nodes\n+     */\n+    protected final static class Object\n+        extends NodeCursor\n+    {\n+        Iterator<Map.Entry<String, JsonNode>> _contents;\n+        Map.Entry<String, JsonNode> _current;\n+\n+        boolean _needEntry;\n+        \n+        public Object(JsonNode n, NodeCursor p)\n+        {\n+            super(JsonStreamContext.TYPE_OBJECT, p);\n+            _contents = ((ObjectNode) n).getFields();\n+            _needEntry = true;\n+        }\n+\n+        @Override\n+        public String getCurrentName() {\n+            return (_current == null) ? null : _current.getKey();\n+        }\n+\n+        @Override\n+        public JsonToken nextToken()\n+        {\n+            // Need a new entry?\n+            if (_needEntry) {\n+                if (!_contents.hasNext()) {\n+                    _current = null;\n+                    return null;\n+                }\n+                _needEntry = false;\n+                _current = _contents.next();\n+                return JsonToken.FIELD_NAME;\n+            }\n+            _needEntry = true;\n+            return _current.getValue().asToken();\n+        }\n+\n+        @Override\n+        public JsonToken nextValue()\n+        {\n+            JsonToken t = nextToken();\n+            if (t == JsonToken.FIELD_NAME) {\n+                t = nextToken();\n+            }\n+            return t;\n+        }\n+\n+        @Override\n+        public JsonToken endToken() { return JsonToken.END_OBJECT; }\n+\n+        @Override\n+        public JsonNode currentNode() {\n+            return (_current == null) ? null : _current.getValue();\n+        }\n+        @Override\n+        public boolean currentHasChildren() {\n+            // note: ONLY to be called for container nodes\n+            return ((ContainerNode) currentNode()).size() > 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * This singleton value class is used to contain explicit JSON null\n+ * value.\n+ */\n+public final class NullNode\n+    extends ValueNode\n+{\n+    // // Just need a fly-weight singleton\n+\n+    public final static NullNode instance = new NullNode();\n+\n+    private NullNode() { }\n+\n+    public static NullNode getInstance() { return instance; }\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NULL; }\n+\n+    @Override\n+    public boolean isNull() { return true; }\n+\n+    @Override\n+    public String asText() {\n+        return \"null\";\n+    }\n+\n+    @Override\n+    public int asInt(int defaultValue) {\n+        return 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return 0.0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNull();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        return (o == this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+\n+/**\n+ * Intermediate value node used for numeric nodes.\n+ */\n+public abstract class NumericNode\n+    extends ValueNode\n+{\n+    protected NumericNode() { }\n+\n+    @Override\n+    public final boolean isNumber() { return true; }\n+\n+    // // // Let's re-abstract so sub-classes handle them\n+\n+    @Override\n+    public abstract JsonParser.NumberType getNumberType();\n+\n+    @Override\n+    public abstract Number getNumberValue();\n+    @Override\n+    public abstract int getIntValue();\n+    @Override\n+    public abstract long getLongValue();\n+    @Override\n+    public abstract double getDoubleValue();\n+    @Override\n+    public abstract BigDecimal getDecimalValue();\n+    @Override\n+    public abstract BigInteger getBigIntegerValue();\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public abstract String asText();\n+\n+    @Override\n+    public int asInt() {\n+        return getIntValue();\n+    }\n+    @Override\n+    public int asInt(int defaultValue) {\n+        return getIntValue();\n+    }\n+\n+    @Override\n+    public long asLong() {\n+        return getLongValue();\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return getLongValue();\n+    }\n+    \n+    @Override\n+    public double asDouble() {\n+        return getDoubleValue();\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return getDoubleValue();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+\n+/**\n+ * Node that maps to JSON Object structures in JSON content.\n+ */\n+public class ObjectNode\n+    extends ContainerNode\n+{\n+    protected LinkedHashMap<String, JsonNode> _children = null;\n+\n+    public ObjectNode(JsonNodeFactory nc) { super(nc); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Implementation of core JsonNode API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n+\n+    @Override\n+    public boolean isObject() { return true; }\n+\n+    @Override\n+    public int size() {\n+        return (_children == null) ? 0 : _children.size();\n+    }\n+\n+    @Override\n+    public Iterator<JsonNode> getElements()\n+    {\n+        return (_children == null) ? NoNodesIterator.instance() : _children.values().iterator();\n+    }\n+\n+    @Override\n+    public JsonNode get(int index) { return null; }\n+\n+    @Override\n+    public JsonNode get(String fieldName)\n+    {\n+        if (_children != null) {\n+            return _children.get(fieldName);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Iterator<String> getFieldNames()\n+    {\n+        return (_children == null) ? NoStringsIterator.instance() : _children.keySet().iterator();\n+    }\n+\n+    @Override\n+    public JsonNode path(int index)\n+    {\n+        return MissingNode.getInstance();\n+    }\n+\n+    @Override\n+    public JsonNode path(String fieldName)\n+    {\n+        if (_children != null) {\n+            JsonNode n = _children.get(fieldName);\n+            if (n != null) {\n+                return n;\n+            }\n+        }\n+        return MissingNode.getInstance();\n+    }\n+\n+    /**\n+     * Method to use for accessing all fields (with both names\n+     * and values) of this JSON Object.\n+     */\n+    @Override\n+    public Iterator<Map.Entry<String, JsonNode>> getFields()\n+    {\n+        if (_children == null) {\n+            return NoFieldsIterator.instance;\n+        }\n+        return _children.entrySet().iterator();\n+    }\n+\n+    @Override\n+    public ObjectNode with(String propertyName)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>();\n+        } else {\n+            JsonNode n = _children.get(propertyName);\n+            if (n != null) {\n+                if (n instanceof ObjectNode) {\n+                    return (ObjectNode) n;\n+                }\n+                throw new UnsupportedOperationException(\"Property '\"+propertyName\n+                        +\"' has value that is not of type ObjectNode (but \"\n+                        +n.getClass().getName()+\")\");\n+            }\n+        }\n+        ObjectNode result = objectNode();\n+        _children.put(propertyName, result);\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    return entry.getValue();\n+                }\n+                JsonNode value = entry.getValue().findValue(fieldName);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<JsonNode>();\n+                    }\n+                    foundSoFar.add(entry.getValue());\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<String>();\n+                    }\n+                    foundSoFar.add(entry.getValue().asText());\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    return this;\n+                }\n+                JsonNode value = entry.getValue().findParent(fieldName);\n+                if (value != null) {\n+                    return (ObjectNode) value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<JsonNode>();\n+                    }\n+                    foundSoFar.add(this);\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findParents(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to serialize this node and\n+     * all of its descendants using specified JSON generator.\n+     */\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeStartObject();\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                jg.writeFieldName(en.getKey());\n+                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+                 *   extend BaseJsonNode? Or if not, at least implement\n+                 *   JsonSerializable? Let's start with former, change if\n+                 *   we must.\n+                 */\n+                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n+            }\n+        }\n+        jg.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForObject(this, jg);\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                jg.writeFieldName(en.getKey());\n+                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(this, jg);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, generic\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will set specified field, replacing old value,\n+     * if any.\n+     *\n+     * @param value to set field to; if null, will be converted\n+     *   to a {@link NullNode} first  (to remove field entry, call\n+     *   {@link #remove} instead)\n+     *\n+     * @return Old value of the field, if any; null if there was no\n+     *   old value.\n+     */\n+    public JsonNode put(String fieldName, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _put(fieldName, value);\n+    }\n+\n+    /**\n+     * Method for removing field entry from this ObjectNode.\n+     * Will return value of the field, if such field existed;\n+     * null if not.\n+     */\n+    public JsonNode remove(String fieldName)\n+    {\n+        if (_children != null) {\n+            return _children.remove(fieldName);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Method for removing specified field properties out of\n+     * this ObjectNode.\n+     * \n+     * @param fieldNames Names of fields to remove\n+     * \n+     * @return This ObjectNode after removing entries\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode remove(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            for (String fieldName : fieldNames) {\n+                _children.remove(fieldName);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for removing all field properties, such that this\n+     * ObjectNode will contain no properties after call.\n+     */\n+    @Override\n+    public ObjectNode removeAll()\n+    {\n+        _children = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding given properties to this object node, overriding\n+     * any existing values for those properties.\n+     * \n+     * @param properties Properties to add\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode putAll(Map<String,JsonNode> properties)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>(properties);\n+        } else {\n+            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {\n+                JsonNode n = en.getValue();\n+                if (n == null) {\n+                    n = nullNode();\n+                }\n+                _children.put(en.getKey(), n);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding all properties of the given Object, overriding\n+     * any existing values for those properties.\n+     * \n+     * @param other Object of which properties to add to this object\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode putAll(ObjectNode other)\n+    {\n+        int len = other.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new LinkedHashMap<String, JsonNode>(len);\n+            }\n+            other.putContentsTo(_children);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing all field properties out of this ObjectNode\n+     * <b>except</b> for ones specified in argument.\n+     * \n+     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n+     * \n+     * @return This ObjectNode (to allow call chaining)\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode retain(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            Iterator<Map.Entry<String,JsonNode>> entries = _children.entrySet().iterator();\n+            while (entries.hasNext()) {\n+                Map.Entry<String, JsonNode> entry = entries.next();\n+                if (!fieldNames.contains(entry.getKey())) {\n+                    entries.remove();\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing all field properties out of this ObjectNode\n+     * <b>except</b> for ones specified in argument.\n+     * \n+     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n+     * \n+     * @return This ObjectNode (to allow call chaining)\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode retain(String... fieldNames) {\n+        return retain(Arrays.asList(fieldNames));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, typed\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will construct an ArrayNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ArrayNode (NOT the old value,\n+     *   which could be of any type)\n+     */\n+    public ArrayNode putArray(String fieldName)\n+    {\n+        ArrayNode n  = arrayNode();\n+        _put(fieldName, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ObjectNode (NOT the old value,\n+     *   which could be of any type)\n+     */\n+    public ObjectNode putObject(String fieldName)\n+    {\n+        ObjectNode n  = objectNode();\n+        _put(fieldName, n);\n+        return n;\n+    }\n+\n+    public void putPOJO(String fieldName, Object pojo)\n+    {\n+        _put(fieldName, POJONode(pojo));\n+    }\n+\n+    public void putNull(String fieldName)\n+    {\n+        _put(fieldName, nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, int v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Integer value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, long v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Long value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, float v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Float value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, double v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Double value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.doubleValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, BigDecimal v) {\n+        if (v == null) {\n+            putNull(fieldName);\n+        } else {\n+            _put(fieldName, numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void put(String fieldName, String v) {\n+        if (v == null) {\n+            putNull(fieldName);\n+        } else {\n+            _put(fieldName, textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void put(String fieldName, boolean v) { _put(fieldName, booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Boolean value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void put(String fieldName, byte[] v) {\n+        if (v == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, binaryNode(v));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Package methods (for other node classes to use)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.6\n+     */\n+    protected void putContentsTo(Map<String,JsonNode> dst)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String,JsonNode> en : _children.entrySet()) {\n+                dst.put(en.getKey(), en.getValue());\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) {\n+            return false;\n+        }\n+        ObjectNode other = (ObjectNode) o;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                String key = en.getKey();\n+                JsonNode value = en.getValue();\n+\n+                JsonNode otherValue = other.get(key);\n+\n+                if (otherValue == null || !otherValue.equals(value)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return (_children == null) ? -1 : _children.hashCode();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(32 + (size() << 4));\n+        sb.append(\"{\");\n+        if (_children != null) {\n+            int count = 0;\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                if (count > 0) {\n+                    sb.append(\",\");\n+                }\n+                ++count;\n+                TextNode.appendQuoted(sb, en.getKey());\n+                sb.append(':');\n+                sb.append(en.getValue().toString());\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private final JsonNode _put(String fieldName, JsonNode value)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>();\n+        }\n+        return _children.put(fieldName, value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * For efficiency, let's share the \"no fields\" iterator...\n+     */\n+    protected static class NoFieldsIterator\n+        implements Iterator<Map.Entry<String, JsonNode>>\n+    {\n+        final static NoFieldsIterator instance = new NoFieldsIterator();\n+\n+        private NoFieldsIterator() { }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public Map.Entry<String,JsonNode> next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() { // or IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains a wrapped POJO, to be serialized as\n+ * a JSON constructed through data mapping (usually done by\n+ * calling {@link com.fasterxml.jackson.databind.ObjectMapper}).\n+ */\n+public final class POJONode\n+    extends ValueNode\n+{\n+    protected final Object _value;\n+\n+    public POJONode(Object v) { _value = v; }\n+\n+    /*\n+    /**********************************************************\n+    /* Base class overrides\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }\n+\n+    @Override\n+    public boolean isPojo() { return true; }\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String asText() {\n+        return (_value == null) ? \"null\" : _value.toString();\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue)\n+    {\n+        if (_value != null && _value instanceof Boolean) {\n+            return ((Boolean) _value).booleanValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).intValue();\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public long asLong(long defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).longValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public double asDouble(double defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).doubleValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_value == null) {\n+            jg.writeNull();\n+        } else {\n+            jg.writeObject(_value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to access the POJO this node wraps.\n+     */\n+    public Object getPojo() { return _value; }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        POJONode other = (POJONode) o;\n+        if (_value == null) {\n+            return other._value == null;\n+        }\n+        return _value.equals(other._value);\n+    }\n+\n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return String.valueOf(_value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains a text value.\n+ */\n+public final class TextNode\n+    extends ValueNode\n+{\n+    final static int INT_SPACE = ' ';\n+\n+    final static TextNode EMPTY_STRING_NODE = new TextNode(\"\");\n+\n+    final String _value;\n+\n+    public TextNode(String v) { _value = v; }\n+\n+    /**\n+     * Factory method that should be used to construct instances.\n+     * For some common cases, can reuse canonical instances: currently\n+     * this is the case for empty Strings, in future possible for\n+     * others as well. If null is passed, will return null.\n+     *\n+     * @return Resulting {@link TextNode} object, if <b>v</b>\n+     *   is NOT null; null if it is.\n+     */\n+    public static TextNode valueOf(String v)\n+    {\n+        if (v == null) {\n+            return null;\n+        }\n+        if (v.length() == 0) {\n+            return EMPTY_STRING_NODE;\n+        }\n+        return new TextNode(v);\n+    }\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_STRING; }\n+\n+    /**\n+     * Yes indeed it is textual\n+     */\n+    @Override\n+    public boolean isTextual() { return true; }\n+\n+    @Override\n+    public String getTextValue() {\n+        return _value;\n+    }\n+\n+    /**\n+     * Method for accessing textual contents assuming they were\n+     * base64 encoded; if so, they are decoded and resulting binary\n+     * data is returned.\n+     */\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException\n+    {\n+        ByteArrayBuilder builder = new ByteArrayBuilder(100);\n+        final String str = _value;\n+        int ptr = 0;\n+        int len = str.length();\n+\n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+        return builder.toByteArray();\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue() throws IOException\n+    {\n+        return getBinaryValue(Base64Variants.getDefaultVariant());\n+    }\n+    \n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String asText() {\n+        return _value;\n+    }\n+\n+    // note: neither fast nor elegant, but these work for now:\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        if (_value != null) {\n+            if (\"true\".equals(_value.trim())) {\n+                return true;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return NumberInput.parseAsInt(_value, defaultValue);\n+    }\n+\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return NumberInput.parseAsLong(_value, defaultValue);\n+    }\n+    \n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return NumberInput.parseAsDouble(_value, defaultValue);\n+    }\n+    \n+    /* \n+    /**********************************************************\n+    /* Serialization\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_value == null) {\n+            jg.writeNull();\n+        } else {\n+            jg.writeString(_value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((TextNode) o)._value.equals(_value);\n+    }\n+    \n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+\n+    /**\n+     * Different from other values, Strings need quoting\n+     */\n+    @Override\n+    public String toString()\n+    {\n+        int len = _value.length();\n+        len = len + 2 + (len >> 4);\n+        StringBuilder sb = new StringBuilder(len);\n+        appendQuoted(sb, _value);\n+        return sb.toString();\n+    }\n+\n+    protected static void appendQuoted(StringBuilder sb, String content)\n+    {\n+        sb.append('\"');\n+        CharTypes.appendQuoted(sb, content);\n+        sb.append('\"');\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex)\n+        throws JsonParseException\n+    {\n+        _reportInvalidBase64(b64variant, ch, bindex, null);\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new JsonParseException(base, JsonLocation.NA);\n+    }\n+\n+    protected void _reportBase64EOF()\n+        throws JsonParseException\n+    {\n+        throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+\n+/**\n+ * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n+ * accessing contents of JSON tree in alternate form (stream of tokens).\n+ * Useful when a streaming source is expected by code, such as data binding\n+ * functionality.\n+ * \n+ * @author tatu\n+ */\n+public class TreeTraversingParser extends ParserMinimalBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Traversal context within tree\n+     */\n+    protected NodeCursor _nodeCursor;\n+\n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Sometimes parser needs to buffer a single look-ahead token; if so,\n+     * it'll be stored here. This is currently used for handling \n+     */\n+    protected JsonToken _nextToken;\n+\n+    /**\n+     * Flag needed to handle recursion into contents of child\n+     * Array/Object nodes.\n+     */\n+    protected boolean _startContainer;\n+    \n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public TreeTraversingParser(JsonNode n) { this(n, null); }\n+\n+    public TreeTraversingParser(JsonNode n, ObjectCodec codec)\n+    {\n+        super(0);\n+        _objectCodec = codec;\n+        if (n.isArray()) {\n+            _nextToken = JsonToken.START_ARRAY;\n+            _nodeCursor = new NodeCursor.Array(n, null);\n+        } else if (n.isObject()) {\n+            _nextToken = JsonToken.START_OBJECT;\n+            _nodeCursor = new NodeCursor.Object(n, null);\n+        } else { // value node\n+            _nodeCursor = new NodeCursor.RootValue(n, null);\n+        }\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Closeable implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            _nodeCursor = null;\n+            _currToken = null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        if (_nextToken != null) {\n+            _currToken = _nextToken;\n+            _nextToken = null;\n+            return _currToken;\n+        }\n+        // are we to descend to a container child?\n+        if (_startContainer) {\n+            _startContainer = false;\n+            // minor optimization: empty containers can be skipped\n+            if (!_nodeCursor.currentHasChildren()) {\n+                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n+                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+                return _currToken;\n+            }\n+            _nodeCursor = _nodeCursor.iterateChildren();\n+            _currToken = _nodeCursor.nextToken();\n+            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+                _startContainer = true;\n+            }\n+            return _currToken;\n+        }\n+        // No more content?\n+        if (_nodeCursor == null) {\n+            _closed = true; // if not already set\n+            return null;\n+        }\n+        // Otherwise, next entry from current cursor\n+        _currToken = _nodeCursor.nextToken();\n+        if (_currToken != null) {\n+            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+                _startContainer = true;\n+            }\n+            return _currToken;\n+        }\n+        // null means no more children; need to return end marker\n+        _currToken = _nodeCursor.endToken();\n+        _nodeCursor = _nodeCursor.getParent();\n+        return _currToken;\n+    }\n+    \n+    // default works well here:\n+    //public JsonToken nextValue() throws IOException, JsonParseException\n+\n+    @Override\n+    public JsonParser skipChildren() throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.START_OBJECT) {\n+            _startContainer = false;\n+            _currToken = JsonToken.END_OBJECT;\n+        } else if (_currToken == JsonToken.START_ARRAY) {\n+            _startContainer = false;\n+            _currToken = JsonToken.END_ARRAY;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getCurrentName() {\n+        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n+    }\n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return _nodeCursor;\n+    }\n+\n+    @Override\n+    public JsonLocation getTokenLocation() {\n+        return JsonLocation.NA;\n+    }\n+\n+    @Override\n+    public JsonLocation getCurrentLocation() {\n+        return JsonLocation.NA;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to textual content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText()\n+    {\n+        if (_closed) {\n+            return null;\n+        }\n+        // need to separate handling a bit...\n+        switch (_currToken) {\n+        case FIELD_NAME:\n+            return _nodeCursor.getCurrentName();\n+        case VALUE_STRING:\n+            return currentNode().getTextValue();\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+            return String.valueOf(currentNode().getNumberValue());\n+        case VALUE_EMBEDDED_OBJECT:\n+            JsonNode n = currentNode();\n+            if (n != null && n.isBinary()) {\n+                // this will convert it to base64\n+                return n.asText();\n+            }\n+        }\n+\n+        return (_currToken == null) ? null : _currToken.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        return getText().toCharArray();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        return getText().length();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean hasTextCharacters() {\n+        // generally we do not have efficient access as char[], hence:\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, typed non-text access\n+    /**********************************************************\n+     */\n+\n+    //public byte getByteValue() throws IOException, JsonParseException\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException {\n+        JsonNode n = currentNumericNode();\n+        return (n == null) ? null : n.getNumberType();\n+    }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        return currentNumericNode().getBigIntegerValue();\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getDecimalValue();\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getDoubleValue();\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException {\n+        return (float) currentNumericNode().getDoubleValue();\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getLongValue();\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getIntValue();\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getNumberValue();\n+    }\n+\n+    @Override\n+    public Object getEmbeddedObject()\n+    {\n+        if (!_closed) {\n+            JsonNode n = currentNode();\n+            if (n != null) {\n+                if (n.isPojo()) {\n+                    return ((POJONode) n).getPojo();\n+                }\n+                if (n.isBinary()) {\n+                    return ((BinaryNode) n).getBinaryValue();\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, typed binary (base64) access\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        // Multiple possibilities...\n+        JsonNode n = currentNode();\n+        if (n != null) { // binary node?\n+            byte[] data = n.getBinaryValue();\n+            // (or TextNode, which can also convert automatically!)\n+            if (data != null) {\n+                return data;\n+            }\n+            // Or maybe byte[] as POJO?\n+            if (n.isPojo()) {\n+                Object ob = ((POJONode) n).getPojo();\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n+            }\n+        }\n+        // otherwise return null to mark we have no binary content\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonNode currentNode() {\n+        if (_closed || _nodeCursor == null) {\n+            return null;\n+        }\n+        return _nodeCursor.currentNode();\n+    }\n+\n+    protected JsonNode currentNumericNode()\n+        throws JsonParseException\n+    {\n+        JsonNode n = currentNode();\n+        if (n == null || !n.isNumber()) {\n+            JsonToken t = (n == null) ? null : n.asToken();\n+            throw _constructError(\"Current token (\"+t+\") not numeric, can not use numeric value accessors\");\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    protected void _handleEOF() throws JsonParseException {\n+        _throwInternal(); // should never get called\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+\n+/**\n+ * This intermediate base class is used for all leaf nodes, that is,\n+ * all non-container (array or object) nodes, except for the\n+ * \"missing node\".\n+ */\n+public abstract class ValueNode\n+    extends BaseJsonNode\n+{\n+    protected ValueNode() { }\n+\n+    @Override\n+    public boolean isValueNode() { return true; }\n+\n+    @Override\n+    public abstract JsonToken asToken();\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForScalar(this, jg);\n+        serialize(jg, provider);\n+        typeSer.writeTypeSuffixForScalar(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Public API, path handling\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n+\n+    @Override\n+    public JsonNode path(int index) { return MissingNode.getInstance(); }\n+\n+    /*\n+    /**********************************************************************\n+    /* Base impls for standard methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public String toString() { return asText(); }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/package-info.java\n+/**\n+ * Contains concrete {@link org.codehaus.jackson.JsonNode} implementations\n+ * Jackson uses for the Tree model.\n+ * These classes are public since concrete type will be needed\n+ * for most operations that modify node trees. For read-only access concrete\n+ * types are usually not needed.\n+ */\n+package com.fasterxml.jackson.databind.node;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n-import com.fasterxml.jackson.databind.annotate.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize.Inclusion;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.*;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.FailingSerializer;\n import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.SerializerCache;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.std.NonTypedScalarSerializerBase;\n import com.fasterxml.jackson.databind.ser.std.ScalarSerializerBase;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.*;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n \n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n  * Standard serializer for {@link java.util.Calendar}.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n \n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n  * For efficiency, we will serialize Dates as longs, instead of\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.JsonNodeFactory;\n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n \n-import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.node.ArrayNode;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n @JacksonStdImpl\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n     /**\n      * @param ser Explicit serializer to use, if caller knows it (which\n      *            occurs if and only if the \"value method\" was annotated with\n-     *            {@link com.fasterxml.jackson.databind.annotate.JsonSerialize#using}), otherwise\n+     *            {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}), otherwise\n      *            null\n      */\n     public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser, BeanProperty property)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n  * This is a simple dummy serializer that will just output literal\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.ArrayType;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n-import org.codehaus.jackson.node.JsonNodeFactory;\n-import org.codehaus.jackson.node.ObjectNode;\n \n /**\n  * Base class used by all standard serializers. Provides some convenience\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n \n import com.fasterxml.jackson.core.JsonNode;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Intermediate base class for Lists, Collections and Arrays\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n \n import com.fasterxml.jackson.core.*;\n \n-import org.codehaus.jackson.node.ObjectNode;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n  * This is the special serializer for regular {@link java.lang.String}s.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n      * {@link #instance} which is stateless and fully thread-safe. However,\n      * there are cases where constructor is needed; for example,\n      * when using explicit serializer annotations like\n-     * {@link com.fasterxml.jackson.databind.annotate.JsonSerialize#using}.\n+     * {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}.\n      */\n     public ToStringSerializer() { super(Object.class); }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n ", "timestamp": 1324700727, "metainfo": ""}