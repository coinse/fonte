{"sha": "fa535ea3ffaeea9a614515e99d4fd6b76d53abee", "log": "yet more refactoring, hopefully done for now", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n      * Method used for setting \"any\" properties, along with annotation\n      * information. Retained to allow contextualization of any properties.\n      */\n-    final protected BeanProperty _property;\n+    protected final BeanProperty _property;\n     \n     /**\n      * Physical JDK object used for assigning properties.\n     \n     /*\n     /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    // TODO (2.3): handle restoring of reference to any-setter method\n+    \n+/*\n+    Object readResolve() {\n+        return new SettableAnyProperty(this, _annotated.getAnnotated());\n+    }\n+    */\n+    \n+    /*\n+    /**********************************************************\n     /* Public API, accessors\n     /**********************************************************\n      */\n      * context), and set it using appropriate method (a setter method).\n      */\n     public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                                        Object instance, String propName)\n-        throws IOException, JsonProcessingException\n+            Object instance, String propName)\n+        throws IOException\n     {\n         try {\n             set(instance, propName, deserialize(jp, ctxt));\n         }\n     }\n \n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NULL) {\n         return _valueDeserializer.deserialize(jp, ctxt);\n     }\n \n-    public void set(Object instance, String propName, Object value)\n-        throws IOException\n+    public void set(Object instance, String propName, Object value) throws IOException\n     {\n         try {\n             _setter.invoke(instance, propName, value);\n             _parent.set(_pojo, _propName, value);\n         }\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* JDK serialization handling\n-    /**********************************************************\n-     */\n-\n-    // TODO (2.3): handle restoring of reference to any-setter method\n-    \n-/*\n-    Object readResolve() {\n-        return new SettableAnyProperty(this, _annotated.getAnnotated());\n-    }\n-    */\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n     private ObjectIdResolver _resolver;\n \n     @Deprecated\n-    public ReadableObjectId(Object id)\n-    {\n+    public ReadableObjectId(Object id) {\n         this.id = id;\n         _key = null;\n     }\n \n-    public ReadableObjectId(IdKey key)\n-    {\n+    public ReadableObjectId(IdKey key) {\n         _key = key;\n         id = key.key;\n     }\n \n-    public void setResolver(ObjectIdResolver resolver)\n-    {\n+    public void setResolver(ObjectIdResolver resolver) {\n         _resolver = resolver;\n     }\n \n-    public IdKey getKey()\n-    {\n+    public IdKey getKey() {\n         return _key;\n     }\n \n         public Class<?> getBeanType() { return _beanType; }\n \n         public abstract void handleResolvedForwardReference(Object id, Object value) throws IOException;\n-        public final boolean hasId(Object id) {\n+        public boolean hasId(Object id) {\n             return id.equals(_reference.getUnresolvedId());\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n             if (_accumulator.isEmpty()) {\n                 _result.add(value);\n             } else {\n-                CollectionReferring unresolvedId = _accumulator.get(_accumulator.size() - 1);\n-                unresolvedId._next.add(value);\n+                CollectionReferring ref = _accumulator.get(_accumulator.size() - 1);\n+                ref.next.add(value);\n             }\n         }\n \n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Collection<Object> previous = _result;\n             while (iterator.hasNext()) {\n-                CollectionReferring unresolvedId = iterator.next();\n-                if (unresolvedId.hasId(id)) {\n+                CollectionReferring ref = iterator.next();\n+                if (ref.hasId(id)) {\n                     iterator.remove();\n                     previous.add(value);\n-                    previous.addAll(unresolvedId._next);\n+                    previous.addAll(ref.next);\n                     return;\n                 }\n-                previous = unresolvedId._next;\n+                previous = ref.next;\n             }\n \n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n     /**\n      * Helper class to maintain processing order of value. The resolved\n      * object associated with {@link #_id} comes before the values in\n-     * {@link _next}.\n+     * {@link #next}.\n      */\n     private final static class CollectionReferring extends Referring {\n         private final CollectionReferringAccumulator _parent;\n-        private final List<Object> _next = new ArrayList<Object>();\n+        public final List<Object> next = new ArrayList<Object>();\n         \n         private CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         }\n     }\n \n-    // note: copied form BeanDeserializer; should try to share somehow...\n+    // note: copied from BeanDeserializer; should try to share somehow...\n     protected void wrapAndThrow(Throwable t, Object ref)\n         throws IOException\n     {\n             if (_accumulator.isEmpty()) {\n                 _result.put(key, value);\n             } else {\n-                MapReferring unresolvedId = _accumulator.get(_accumulator.size() - 1);\n-                unresolvedId._next.put(key, value);\n+                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n+                ref.next.put(key, value);\n             }\n         }\n \n         public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n             Iterator<MapReferring> iterator = _accumulator.iterator();\n-            // Resolve ordering after resolution of an id. This mean either:\n+            // Resolve ordering after resolution of an id. This means either:\n             // 1- adding to the result map in case of the first unresolved id.\n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Map<Object,Object> previous = _result;\n             while (iterator.hasNext()) {\n-                MapReferring unresolvedId = iterator.next();\n-                if (unresolvedId.hasId(id)) {\n+                MapReferring ref = iterator.next();\n+                if (ref.hasId(id)) {\n                     iterator.remove();\n-                    previous.put(unresolvedId._key, value);\n-                    previous.putAll(unresolvedId._next);\n+                    previous.put(ref.key, value);\n+                    previous.putAll(ref.next);\n                     return;\n                 }\n-                previous = unresolvedId._next;\n+                previous = ref.next;\n             }\n \n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n      */\n     private final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n-        private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n-        private final Object _key;\n+\n+        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n+        public final Object key;\n         \n         private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n             _parent = parent;\n-            _key = key;\n+            this.key = key;\n         }\n \n         @Override", "timestamp": 1394855378, "metainfo": ""}