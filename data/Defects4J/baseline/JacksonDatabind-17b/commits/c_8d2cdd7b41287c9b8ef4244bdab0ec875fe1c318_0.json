{"sha": "8d2cdd7b41287c9b8ef4244bdab0ec875fe1c318", "log": "Implememented [Issue#42], allow defining Base64 default variant to use for databinding", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     public DeserializationConfig with(TimeZone tz) {\n         return _withBase(_base.with(tz));\n     }\n+\n+    @Override\n+    public DeserializationConfig with(Base64Variant base64) {\n+        return _withBase(_base.with(base64));\n+    }\n     \n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n         return _problemHandlers;\n     }\n-    \n-    /**\n-     * Method called during deserialization if Base64 encoded content\n-     * needs to be decoded. Default version just returns default Jackson\n-     * uses, which is modified-mime which does not add linefeeds (because\n-     * those would have to be escaped in JSON strings).\n-     */\n-    public Base64Variant getBase64Variant() {\n-        return Base64Variants.getDefaultVariant();\n-    }\n \n     public final JsonNodeFactory getNodeFactory() {\n         return _nodeFactory;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n             null, StdDateFormat.instance, null,\n             Locale.getDefault(),\n //            TimeZone.getDefault()\n-            TimeZone.getTimeZone(\"GMT\")\n+            TimeZone.getTimeZone(\"GMT\"),\n+            Base64Variants.getDefaultVariant() // 2.1\n             );\n     \n     /*\n \n     /**\n      * Method for setting defalt POJO property inclusion strategy for serialization.\n-     * Equivalent to:\n-     *<pre>\n-     *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));\n-     *</pre>\n      */\n     public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n         _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n         return this;\n     }\n-   \n+    \n     /*\n     /**********************************************************\n     /* Type information configuration (1.5+)\n     public ObjectWriter writer(FormatSchema schema) {\n         return new ObjectWriter(this, getSerializationConfig(), schema);\n     }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * use specified Base64 encoding variant for Base64-encoded binary data.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectWriter writer(Base64Variant defaultBase64) {\n+        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+    }\n     \n     /*\n     /**********************************************************\n      */\n     public ObjectReader readerWithView(Class<?> view) {\n         return new ObjectReader(this, getDeserializationConfig().withView(view));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified Base64 encoding variant for Base64-encoded binary data.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectReader reader(Base64Variant defaultBase64) {\n+        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectReader with(DeserializationFeature feature) \n-    {\n-        DeserializationConfig newConfig = _config.with(feature);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader with(DeserializationFeature feature) {\n+        return _with(_config.with(feature));\n     }    \n \n     /**\n     public ObjectReader with(DeserializationFeature first,\n             DeserializationFeature... other)\n     {\n-        DeserializationConfig newConfig = _config.with(first, other);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.with(first, other));\n     }    \n \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader withFeatures(DeserializationFeature... features)\n-    {\n-        DeserializationConfig newConfig = _config.withFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader withFeatures(DeserializationFeature... features) {\n+        return _with(_config.withFeatures(features));\n     }    \n     \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n-    public ObjectReader without(DeserializationFeature feature) \n-    {\n-        DeserializationConfig newConfig = _config.without(feature);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader without(DeserializationFeature feature) {\n+        return _with(_config.without(feature)); \n     }    \n \n     /**\n     public ObjectReader without(DeserializationFeature first,\n             DeserializationFeature... other)\n     {\n-        DeserializationConfig newConfig = _config.without(first, other);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.without(first, other));\n     }    \n \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader withoutFeatures(DeserializationFeature... features)\n-    {\n-        DeserializationConfig newConfig = _config.withoutFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n+        return _with(_config.withoutFeatures(features));\n     }    \n     \n     /**\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader with(JsonNodeFactory f)\n-    {\n-        DeserializationConfig newConfig = _config.with(f);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public ObjectReader with(JsonNodeFactory f) {\n+        return _with(_config.with(f));\n     }\n \n     /**\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withRootName(String rootName)\n-    {\n-        DeserializationConfig newConfig = _config.withRootName(rootName);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public ObjectReader withRootName(String rootName) {\n+        return _with(_config.withRootName(rootName));\n     }\n     \n     /**\n      * rather construct and returns a newly configured instance.\n      */\n     public ObjectReader withView(Class<?> activeView) {\n-        DeserializationConfig newConfig = _config.withView(activeView);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.withView(activeView));\n     }\n \n     public ObjectReader with(Locale l) {\n-        DeserializationConfig newConfig = _config.with(l);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(l));\n     }\n \n     public ObjectReader with(TimeZone tz) {\n-        DeserializationConfig newConfig = _config.with(tz);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(tz));\n     }\n \n     public ObjectReader withHandler(DeserializationProblemHandler h) {\n-        DeserializationConfig newConfig = _config.withHandler(h);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withHandler(h));\n+    }\n+\n+    public ObjectReader with(Base64Variant defaultBase64) {\n+        return _with(_config.with(defaultBase64));\n+    }\n+\n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) return this;\n+        return new ObjectReader(this, newConfig);\n     }\n     \n     /*\n         return t;\n     }\n \n-    \n-static int col = 0;\n+//static int col = 0;\n \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n     public SerializationConfig with(TimeZone tz) {\n         return _withBase(_base.with(tz));\n     }\n+\n+    @Override\n+    public SerializationConfig with(Base64Variant base64) {\n+        return _withBase(_base.with(base64));\n+    }\n     \n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n      * {@link #_dateFormat} of this object.\n      */\n     protected final TimeZone _timeZone;\n+\n+    /**\n+     * Explicitly default {@link Base64Variant} to use for handling\n+     * binary data (<code>byte[]</code>), used with data formats\n+     * that use base64 encoding (like JSON, CSV).\n+     * \n+     * @since 2.1\n+     */\n+    protected final Base64Variant _defaultBase64;\n     \n     /*\n     /**********************************************************\n     public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai,\n             VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n             TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi,\n-            Locale locale, TimeZone tz)\n+            Locale locale, TimeZone tz, Base64Variant defaultBase64)\n     {\n         _classIntrospector = ci;\n         _annotationIntrospector = ai;\n         _handlerInstantiator = hi;\n         _locale = locale;\n         _timeZone = tz;\n+        _defaultBase64 = defaultBase64;\n     }\n \n     /*\n      */\n     \n     public BaseSettings withClassIntrospector(ClassIntrospector ci) {\n+        if (_classIntrospector == ci) {\n+            return this;\n+        }\n         return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        if (_annotationIntrospector == ai) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n     }\n     \n     public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n+        if (_visibilityChecker == vc) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                 _visibilityChecker.withVisibility(forMethod, visibility),\n                 _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        if (_propertyNamingStrategy == pns) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withTypeFactory(TypeFactory tf) {\n+        if (_typeFactory == tf) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n+        if (_typeResolverBuilder == typer) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                typer, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                typer, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n+        if (_dateFormat == df) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n+        if (_handlerInstantiator == hi) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, hi, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings with(Locale l) {\n+        if (_locale == l) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,\n+                _timeZone, _defaultBase64);\n     }\n \n     /**\n         }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                 _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale, tz);\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n+                tz, _defaultBase64);\n+    }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    public BaseSettings with(Base64Variant base64) {\n+        if (base64 == _defaultBase64) {\n+            return this;\n+        }\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n+                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, base64);\n     }\n     \n     /*\n         return _annotationIntrospector;\n     }\n \n-\n     public VisibilityChecker<?> getVisibilityChecker() {\n         return _visibilityChecker;\n     }\n     public TimeZone getTimeZone() {\n         return _timeZone;\n     }\n+\n+    public Base64Variant getBase64Variant() {\n+        return _defaultBase64;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * Accessor for finding currently active view, if any (null if none)\n      */\n     public abstract Class<?> getActiveView();\n+\n+    /**\n+     * Method called during deserialization if Base64 encoded content\n+     * needs to be decoded. Default version just returns default Jackson\n+     * uses, which is modified-mime which does not add linefeeds (because\n+     * those would have to be escaped in JSON strings); but this can\n+     * be configured on {@link ObjectWriter}.\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return _base.getBase64Variant();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.MapperFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n     protected final SubtypeResolver _subtypeResolver;\n \n     /**\n-     * Explicitly definite root name to use, if any; if empty\n+     * Explicitly defined root name to use, if any; if empty\n      * String, will disable root-name wrapping; if null, will\n      * use defaults\n      */\n      * default {@link java.util.TimeZone} to use for formatting of date values.\n      */\n     public abstract T with(TimeZone tz);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * default {@link Base64Variant} to use with base64-encoded binary values.\n+     */\n+    public abstract T with(Base64Variant base64);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n     public final void serialize(JsonGenerator jg, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n-        jg.writeBinary(_data);\n+        jg.writeBinary(provider.getConfig().getBase64Variant(),\n+                _data, 0, _data.length);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n         public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            jgen.writeBinary(value);\n+            jgen.writeBinary(provider.getConfig().getBase64Variant(),\n+                    value, 0, value.length);\n         }\n \n         @Override\n             throws IOException, JsonGenerationException\n         {\n             typeSer.writeTypePrefixForScalar(value, jgen);\n-            jgen.writeBinary(value);\n+            jgen.writeBinary(provider.getConfig().getBase64Variant(),\n+                    value, 0, value.length);\n             typeSer.writeTypeSuffixForScalar(value, jgen);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n \n     /**\n      * Object codec to use for stream-based object\n-     *   conversion through parser/generator interfaces. If null,\n-     *   such methods can not be used.\n+     * conversion through parser/generator interfaces. If null,\n+     * such methods can not be used.\n      */\n     protected ObjectCodec _objectCodec;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n import java.net.URL;\n import java.net.URI;\n import java.util.*;\n+\n+import org.junit.Assert;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         }\n     }\n \n+    // as per [Issue#42], allow Base64 variant use as well\n+    public void testBase64Variants() throws Exception\n+    {\n+        final byte[] INPUT = \"abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X\".getBytes(\"UTF-8\");\n+        \n+        // default encoding is \"MIME, no linefeeds\", so:\n+        Assert.assertArrayEquals(INPUT, MAPPER.readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                byte[].class));\n+        ObjectReader reader = MAPPER.reader(byte[].class);\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+\n+        // but others should be slightly different\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\\\ndnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA\"\n+        )));\n+        // PEM mandates 64 char lines:\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+    }    \n     /*\n     /**********************************************************\n     /* Simple non-primitive types\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n import java.math.BigInteger;\n \n \n+import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n public class TestSimpleTypes\n     extends BaseMapTest\n {\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testBoolean() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"true\", serializeAsString(mapper, Boolean.TRUE));\n-        assertEquals(\"false\", serializeAsString(mapper, Boolean.FALSE));\n+        assertEquals(\"true\", serializeAsString(MAPPER, Boolean.TRUE));\n+        assertEquals(\"false\", serializeAsString(MAPPER, Boolean.FALSE));\n     }\n \n     public void testBooleanArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[true,false]\", serializeAsString(mapper, new boolean[] { true, false} ));\n-        assertEquals(\"[true,false]\", serializeAsString(mapper, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));\n+        assertEquals(\"[true,false]\", serializeAsString(MAPPER, new boolean[] { true, false} ));\n+        assertEquals(\"[true,false]\", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));\n     }\n \n     public void testByteArray() throws Exception\n         for (int i = 0; i < data.length; ++i) {\n             data2[i] = data[i]; // auto-boxing\n         }\n-        ObjectMapper mapper = new ObjectMapper();\n         // For this we need to deserialize, to get base64 codec\n-        String str1 = serializeAsString(mapper, data);\n-        String str2 = serializeAsString(mapper, data2);\n-        assertArrayEquals(data, mapper.readValue(str1, byte[].class));\n-        assertArrayEquals(data2, mapper.readValue(str2, Byte[].class));\n+        String str1 = serializeAsString(MAPPER, data);\n+        String str2 = serializeAsString(MAPPER, data2);\n+        assertArrayEquals(data, MAPPER.readValue(str1, byte[].class));\n+        assertArrayEquals(data2, MAPPER.readValue(str2, Byte[].class));\n     }\n \n+    // as per [Issue#42], allow Base64 variant use as well\n+    public void testBase64Variants() throws Exception\n+    {\n+        final byte[] INPUT = \"abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X\".getBytes(\"UTF-8\");\n+        \n+        // default encoding is \"MIME, no linefeeds\", so:\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"), MAPPER.writeValueAsString(INPUT));\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.MIME_NO_LINEFEEDS).writeValueAsString(INPUT));\n+\n+        // but others should be slightly different\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\\\ndnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.MIME).writeValueAsString(INPUT));\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA\"), // no padding or LF\n+                MAPPER.writer(Base64Variants.MODIFIED_FOR_URL).writeValueAsString(INPUT));\n+        // PEM mandates 64 char lines:\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.PEM).writeValueAsString(INPUT));\n+    }\n+    \n     public void testShortArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[0,1]\", serializeAsString(mapper, new short[] { 0, 1 }));\n-        assertEquals(\"[2,3]\", serializeAsString(mapper, new Short[] { 2, 3 }));\n+        assertEquals(\"[0,1]\", serializeAsString(MAPPER, new short[] { 0, 1 }));\n+        assertEquals(\"[2,3]\", serializeAsString(MAPPER, new Short[] { 2, 3 }));\n     }\n \n     public void testIntArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[0,-3]\", serializeAsString(mapper, new int[] { 0, -3 }));\n-        assertEquals(\"[13,9]\", serializeAsString(mapper, new Integer[] { 13, 9 }));\n+        assertEquals(\"[0,-3]\", serializeAsString(MAPPER, new int[] { 0, -3 }));\n+        assertEquals(\"[13,9]\", serializeAsString(MAPPER, new Integer[] { 13, 9 }));\n     }\n \n     /* Note: dealing with floating-point values is tricky; not sure if\n         double[] values = new double[] {\n             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n         };\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         for (double d : values) {\n            float f = (float) d;\n     \t   String expected = String.valueOf(f);\n            if (Float.isNaN(f) || Float.isInfinite(f)) {\n                expected = \"\\\"\"+expected+\"\\\"\";\n        \t   }\n-           assertEquals(expected,serializeAsString(mapper, Float.valueOf(f)));\n+           assertEquals(expected,serializeAsString(MAPPER, Float.valueOf(f)));\n         }\n     }\n \n         double[] values = new double[] {\n             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n         };\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         for (double d : values) {\n             String expected = String.valueOf(d);\n             if (Double.isNaN(d) || Double.isInfinite(d)) {\n                 expected = \"\\\"\"+d+\"\\\"\";\n             }\n-            assertEquals(expected,serializeAsString(mapper, Double.valueOf(d)));\n+            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n         }\n     }\n \n                 new BigInteger(\"123456789012345678901234568\"),\n                 new BigInteger(\"-1250000124326904597090347547457\")\n                 };\n-        ObjectMapper mapper = new ObjectMapper();\n \n         for (BigInteger value : values) {\n             String expected = value.toString();\n-            assertEquals(expected,serializeAsString(mapper, value));\n+            assertEquals(expected, MAPPER.writeValueAsString(value));\n         }\n     }\n     \n     public void testClass() throws Exception\n     {\n-        String result = serializeAsString(java.util.List.class);\n+        String result = MAPPER.writeValueAsString(java.util.List.class);\n         assertEquals(\"\\\"java.util.List\\\"\", result);\n     }\n }", "timestamp": 1344924651, "metainfo": ""}