{"sha": "bd17ded7413e34fa26b8acb0ef37456408189de2", "log": "Some more fixes for UUID handling, to allow use of Base64 encoding as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.DataInputStream;\n import java.io.IOException;\n import java.util.Arrays;\n import java.util.UUID;\n \n+import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationContext;\n \n     }\n \n     public final static UUIDDeserializer instance = new UUIDDeserializer();\n-    \n+\n     public UUIDDeserializer() { super(UUID.class); }\n \n     @Override\n         // Adapted from java-uuid-generator (https://github.com/cowtowncoder/java-uuid-generator)\n         // which is 5x faster than UUID.fromString(value), as oper \"ManualReadPerfWithUUID\"\n         if (id.length() != 36) {\n+            /* 14-Sep-2013, tatu: One trick we do allow, Base64-encoding, since we know\n+             *   length it must have...\n+             */\n+            if (id.length() == 24) {\n+                byte[] stuff = Base64Variants.getDefaultVariant().decode(id);\n+                return _fromBytes(stuff, ctxt);\n+            }\n             _badFormat(id);\n         }\n \n \n         return new UUID(hi, lo);\n     }\n+    \n+    @Override\n+    protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (ob instanceof byte[]) {\n+            return _fromBytes((byte[]) ob, ctxt);\n+        }\n+        super._deserializeEmbedded(ob, ctxt);\n+        return null; // never gets here\n+    }\n \n+    private void _badFormat(String uuidStr) {\n+        throw new NumberFormatException(\"UUID has to be represented by the standard 36-char representation\");\n+    }\n+    \n     static int intFromChars(String str, int index) {\n         return (byteFromChars(str, index) << 24)\n                 +(byteFromChars(str, index+2) << 16)\n         throw new NumberFormatException(\"Non-hex character '\"+c+\"', not valid character for a UUID String\"\n                 +\"' (value 0x\"+Integer.toHexString(c)+\") for UUID String \\\"\"+uuidStr+\"\\\"\");\n     }\n-\n-    private void _badFormat(String uuidStr) {\n-        throw new NumberFormatException(\"UUID has to be represented by the standard 36-char representation\");\n-    }\n     \n-    @Override\n-    protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        if (ob instanceof byte[]) {\n-            byte[] bytes = (byte[]) ob;\n-            if (bytes.length != 16) {\n-                ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n-            }\n-            // clumsy, but should work for now...\n-            DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n-            long l1 = in.readLong();\n-            long l2 = in.readLong();\n-            return new UUID(l1, l2);\n+        if (bytes.length != 16) {\n+            ctxt.mappingException(\"Can only construct UUIDs from byte[16]; got \"+bytes.length+\" bytes\");\n         }\n-        super._deserializeEmbedded(ob, ctxt);\n-        return null; // never gets here\n+        return new UUID(_long(bytes, 0), _long(bytes, 8));\n+    }\n+\n+    private static long _long(byte[] b, int offset)\n+    {\n+        long l1 = ((long) _int(b, offset)) << 32;\n+        long l2 = _int(b, offset+4);\n+        // faster to just do it than check if it has sign\n+        l2 = (l2 << 32) >>> 32; // to get rid of sign\n+        return l1 | l2;\n+    }\n+\n+    private static int _int(byte[] b, int offset)\n+    {\n+        return (b[offset] << 24)\n+                | ((b[offset+1] & 0xFF) << 16)\n+                | ((b[offset+2] & 0xFF) << 8)\n+                | (b[offset+3] & 0xFF)\n+                ;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n     public void serialize(UUID value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        // UUID.toString() works ok but we can make it go faster...\n+        // First: perhaps we could serialize it as raw binary data?\n+        if (jgen.canWriteBinaryNatively()) {\n+            jgen.writeBinary(_asBytes(value));\n+            return;\n+        }\n+        \n+        // UUID.toString() works ok functionally, but we can make it go much faster\n+        // (by 4x with micro-benchmark)\n \n         final char[] ch = new char[36];\n         final long msb = value.getMostSignificantBits();\n         ch[++offset] = HEX_CHARS[bits  & 0xF];\n \n     }\n+\n+    private final static byte[] _asBytes(UUID uuid)\n+    {\n+        byte[] buffer = new byte[16];\n+        long hi = uuid.getMostSignificantBits();\n+        long lo = uuid.getLeastSignificantBits();\n+        _appendInt((int) (hi >> 32), buffer, 0);\n+        _appendInt((int) hi, buffer, 4);\n+        _appendInt((int) (lo >> 32), buffer, 8);\n+        _appendInt((int) lo, buffer, 12);\n+        return buffer;\n+    }\n+\n+    private final static void _appendInt(int value, byte[] buffer, int offset)\n+    {\n+        buffer[offset] = (byte) (value >> 24);\n+        buffer[++offset] = (byte) (value >> 16);\n+        buffer[++offset] = (byte) (value >> 8);\n+        buffer[++offset] = (byte) value;\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n \n     public void testUUID() throws Exception\n     {\n+        final String NULL_UUID = \"00000000-0000-0000-0000-000000000000\";\n         // first, couple of generated UUIDs:\n         for (String value : new String[] {\n                 \"76e6d183-5f68-4afa-b94a-922c1fdb83f8\",\n                 \"82994ac2-7b23-49f2-8cc5-e24cf6ed77be\",\n                 \"00000007-0000-0000-0000-000000000000\"\n         }) {\n-            assertEquals(UUID.fromString(value),\n+            UUID uuid = UUID.fromString(value);\n+            assertEquals(uuid,\n                     MAPPER.readValue(quote(value), UUID.class));\n         }\n         // then use templating; note that these are not exactly valid UUIDs\n         // wrt spec (type bits etc), but JDK UUID should deal ok\n-        final String TEMPL = \"00000000-0000-0000-0000-000000000000\";\n+        final String TEMPL = NULL_UUID;\n         final String chars = \"123456789abcdefABCDEF\";\n \n         for (int i = 0; i < chars.length(); ++i) {\n             assertEquals(UUID.fromString(value).toString(),\n                     MAPPER.readValue(quote(value), UUID.class).toString());\n         }\n+\n+        // also: see if base64 encoding works as expected\n+        String base64 = Base64Variants.getDefaultVariant().encode(new byte[16]);\n+        assertEquals(UUID.fromString(NULL_UUID),\n+                MAPPER.readValue(quote(base64), UUID.class));\n     }\n \n     public void testUUIDAux() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n             // and bring it back\n             UUID out = mapper.readValue(buf.asParser(), UUID.class);\n             assertEquals(uuid.toString(), out.toString());\n+\n+            // second part: ensure it's written as binary...\n+            JsonParser jp = buf.asParser();\n+            assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());\n+            byte[] raw = jp.getBinaryValue();\n+            assertEquals(16, raw.length);\n+            jp.close();\n         }\n     }\n     ", "timestamp": 1379191219, "metainfo": ""}