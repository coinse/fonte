{"sha": "0d3a32657ccd3f38c76a5e51328741fb5b4b7afe", "log": "Merge pull request #455 from UnquietCode/jackson-databind-81  skip writing type info for unwrapped properties", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n      */\n     WRAP_EXCEPTIONS(true),\n \n+\t/**\n+\t * Feature that determines what happens when an object which\n+\t * normally has type information included by Jackson is used\n+\t * in conjunction with {@link com.fasterxml.jackson.annotation.JsonUnwrapped}.\n+\t * In the default (enabled) state, an error will be thrown when\n+\t * an unwrapped object has type information. When disabled, the\n+\t * object will be unwrapped and the type information discarded.\n+\t *<p>\n+\t * Feature is enabled by default.\n+\t *\n+\t * @since 2.4\n+\t */\n+\tFAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS(true),\n+\n+\n     /*\n     /******************************************************\n     /* Output life cycle features\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n-import java.io.IOException;\n-\n-import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+import java.io.IOException;\n \n public class UnwrappingBeanSerializer\n     extends BeanSerializerBase\n         }\n     }\n     \n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+\t    if (provider.isEnabled(SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS)) {\n+\t\t    throw new JsonGenerationException(\"Unwrapped property contains type information.\");\n+\t    }\n+\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            return;\n+        }\n+\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Standard methods\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestUnwrappedWithTypeInfo.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import org.junit.Test;\n+\n+// Tests for [#81]\n+public class TestUnwrappedWithTypeInfo extends BaseMapTest\n+{\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, property=\"@type\")\n+\t@JsonTypeName(\"OuterType\")\n+\tstatic class Outer {\n+\n+\t\tprivate @JsonProperty String p1;\n+\t\tpublic String getP1() { return p1; }\n+\t\tpublic void setP1(String p1) { this.p1 = p1; }\n+\n+\n+\t\tprivate Inner inner;\n+\t\tpublic void setInner(Inner inner) { this.inner = inner; }\n+\n+\t\t@JsonUnwrapped\n+\t\tpublic Inner getInner() {\n+\t\t\treturn inner;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, property=\"@type\")\n+\t@JsonTypeName(\"InnerType\")\n+\tstatic class Inner {\n+\n+\t\tprivate @JsonProperty String p2;\n+\t\tpublic String getP2() { return p2; }\n+\t\tpublic void setP2(String p2) { this.p2 = p2; }\n+\n+\t}\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests, serialization\n+    /**********************************************************\n+     */\n+\n+    public void testDefaultUnwrappedWithTypeInfo() throws Exception\n+    {\n+\t    Outer outer = new Outer();\n+\t    outer.setP1(\"101\");\n+\n+\t    Inner inner = new Inner();\n+\t    inner.setP2(\"202\");\n+\t    outer.setInner(inner);\n+\n+\t    ObjectMapper mapper = new ObjectMapper();\n+\n+        try {\n+\t        mapper.writeValueAsString(outer);\n+        } catch (JsonGenerationException ex) {\n+\t        return; // expected\n+        }\n+\n+\t    fail(\"Expected exception to be thrown.\");\n+    }\n+\n+\tpublic void testUnwrappedWithTypeInfoAndFeatureDisabled() throws Exception\n+\t{\n+\t\tOuter outer = new Outer();\n+\t\touter.setP1(\"101\");\n+\n+\t\tInner inner = new Inner();\n+\t\tinner.setP2(\"202\");\n+\t\touter.setInner(inner);\n+\n+\t\tObjectMapper mapper = new ObjectMapper();\n+\t\tmapper = mapper.disable(SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS);\n+\n+\t\tString json = mapper.writeValueAsString(outer);\n+\t\tassertEquals(\"{\\\"@type\\\":\\\"OuterType\\\",\\\"p1\\\":\\\"101\\\",\\\"p2\\\":\\\"202\\\"}\", json);\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n @SuppressWarnings(\"serial\")\n public abstract class AnnotationIntrospector\n     implements Versioned, java.io.Serializable\n-{    \n+{\n     /*\n     /**********************************************************\n     /* Helper types\n     public Integer findPropertyIndex(Annotated ann) { return null; }\n \n     /**\n-     * Method for finding parameter name used in source code, and typically\n-     * not indicated by an annotation (which is ironic considering the context).\n-     * The reason for including method here is that of convenience; while\n-     * it is not part of annotation handling, it is closely related to\n-     * property introspection project. {@link AnnotationIntrospector} handling\n-     * is also one of limited number of truly pluggable extension points, making\n-     * it ideal from developer perspective; even at the expense of strict\n-     * naming consistency.\n+     * Method for finding implicit name for a property that given annotated\n+     * member (field, method, creator parameter) may represent.\n+     * This is different from explicit, annotation-based property name, in that\n+     * it is \"weak\" and does not either proof that a property exists (for example,\n+     * if visibility is not high enough), or override explicit names.\n+     * In practice this method is used to introspect optional names for creator\n+     * parameters (which may or may not be available and can not be detected\n+     * by standard databind); or to provide alternate name mangling for\n+     * fields, getters and/or setters.\n      * \n      * @since 2.4\n      */\n-    public String findParameterSourceName(AnnotatedParameter param) { return null; }\n+    public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     extends DatabindContext\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -7727373309391091315L;\n+    private static final long serialVersionUID = -4290063686213707727L;\n \n     /**\n      * Let's limit length of error messages, for cases where underlying data\n      * Helper method for indicating that the current token was expected to be another\n      * token.\n      */\n-    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg) {\n-        return JsonMappingException.from(p, \"Unexpected token (\"+p.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n+    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg0) {\n+        String msg = \"Unexpected token (\"+p.getCurrentToken()+\"), expected \"+expToken;\n+        if (msg0 != null) {\n+            msg = msg + \": \"+msg0;\n+        }\n+        return JsonMappingException.from(p, msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /**\n      * Method for overriding default TimeZone to use for formatting.\n-     * Default value used is {@link TimeZone#getDefault()}.\n+     * Default value used is UTC (NOT local timezone).\n      */\n     public ObjectMapper setTimeZone(TimeZone tz) {\n         _deserializationConfig = _deserializationConfig.with(tz);\n     {\n         String expName = config.getRootName();\n         if (expName == null) {\n-            SerializableString sstr = _rootNames.findRootName(rootType, config);\n-            expName = sstr.getValue();\n+            PropertyName pname = _rootNames.findRootName(rootType, config);\n+            expName = pname.getSimpleName();\n         }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     {\n         String expName = _config.getRootName();\n         if (expName == null) {\n-            SerializableString sstr = _rootNames.findRootName(rootType, _config);\n-            expName = sstr.getValue();\n+            PropertyName pname = _rootNames.findRootName(rootType, _config);\n+            expName = pname.getSimpleName();\n         }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n             throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n package com.fasterxml.jackson.databind;\n \n+import com.fasterxml.jackson.core.SerializableString;\n+import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.util.InternCache;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Simple value class used for containing names of properties as defined\n      */\n     protected final String _namespace;\n \n+    /**\n+     * Lazily-constructed efficient representation of the simple name.\n+     *<p>\n+     * NOTE: not defined as volatile to avoid performance problem with\n+     * concurrent access in multi-core environments; due to statelessness\n+     * of {@link SerializedString} at most leads to multiple instantiations.\n+     * \n+     * @since 2.4\n+     */\n+    protected SerializableString _encodedSimple;\n+    \n     public PropertyName(String simpleName) {\n         this(simpleName, null);\n     }\n         return _simpleName;\n     }\n \n+    /**\n+     * Accessor that may be used to get lazily-constructed efficient\n+     * representation of the simple name.\n+     * \n+     * @since 2.4\n+     */\n+    public SerializableString simpleAsEncoded(MapperConfig<?> config) {\n+        SerializableString sstr = _encodedSimple;\n+        if (sstr == null) {\n+            sstr = config.compileString(_simpleName);\n+            _encodedSimple = sstr;\n+        }\n+        return sstr;\n+    }\n+    \n     public String getNamespace() {\n         return _namespace;\n     }\n     public boolean isEmpty() {\n         return (_namespace == null) && (_simpleName.isEmpty());\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Std method overrides\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             /* 14-Apr-2014, tatu: Need to also consider possible implicit name\n             *   (for JDK8, or via paranamer)\n             */\n-            String str = intr.findParameterSourceName(param);\n+            String str = intr.findImplicitPropertyName(param);\n             if (str != null && !str.isEmpty()) {\n                 return new PropertyName(str);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n         _beanDesc = src._beanDesc;\n         _defaultViewInclusion = src._defaultViewInclusion;\n \n-        _anySetter = src._anySetter;\n-        _ignoreAllUnknown = src._ignoreAllUnknown;\n-\n         // let's make copy of properties\n         _properties.putAll(src._properties);\n+        _injectables = _copy(src._injectables);\n         _backRefProperties = _copy(src._backRefProperties);\n         // Hmmh. Should we create defensive copies here? For now, not yet\n         _ignorableProps = src._ignorableProps;        \n         _valueInstantiator = src._valueInstantiator;\n         _objectIdReader = src._objectIdReader;\n         \n+        _anySetter = src._anySetter;\n+        _ignoreAllUnknown = src._ignoreAllUnknown;\n+        \n         _buildMethod = src._buildMethod;\n         _builderConfig = src._builderConfig;\n     }\n \n-    private static HashMap<String, SettableBeanProperty> _copy(HashMap<String, SettableBeanProperty> src)\n-    {\n-        if (src == null) {\n-            return null;\n-        }\n-        return new HashMap<String, SettableBeanProperty>(src);\n+    private static HashMap<String, SettableBeanProperty> _copy(HashMap<String, SettableBeanProperty> src) {\n+        return (src == null) ? null\n+                : new HashMap<String, SettableBeanProperty>(src);\n+    }\n+\n+    private static <T> List<T> _copy(List<T> src) {\n+        return (src == null) ? null : new ArrayList<T>(src);\n     }\n     \n     /*\n     /**\n      * Method for adding a new property or replacing a property.\n      */\n-    public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride)\n-    {\n+    public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride) {\n         _properties.put(prop.getName(), prop);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n      * This method is called if {@link #getFromObjectArguments} returns\n      * null or empty List.\n      */\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException {\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\"; no default creator found\");\n     }\n      * This method is called if {@link #getFromObjectArguments} returns\n      * a non-empty List of arguments.\n      */\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException {\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" with arguments\");\n     }\n \n      * Method to called to create value instance from JSON Object using\n      * an intermediate \"delegate\" value to pass to createor method\n      */\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException {\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" using delegate\");\n     }\n     \n     /**********************************************************\n      */\n     \n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n-                +getValueTypeDesc()+\" from String value '\"+value+\"'\");\n-    }\n-    \n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException {\n+        return _createFromStringFallbacks(ctxt, value);\n+    }\n+\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", int)\");\n     }\n \n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", long)\");\n     }\n \n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Floating-point number (\"+value+\", double)\");\n     }\n     \n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Boolean value (\"+value+\")\");\n     }\n      * this method may return null .\n      */\n     public AnnotatedWithParams getDefaultCreator() { return null; }\n-    \n+\n     /**\n      * Method that can be called to try to access member (constructor,\n      * static factory method) that is used as the \"delegate creator\".\n      * needs further annotation to help make the creator complete.\n      */\n     public AnnotatedParameter getIncompleteParameter() { return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.4 (demoted from <code>StdValueInstantiator)\n+     */\n+    protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value)\n+            throws IOException, JsonProcessingException\n+    {\n+        /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy\n+         *   systems that expect conversions in some cases, let's just add a minimal\n+         *   patch (note: same could conceivably be used for numbers too).\n+         */\n+        if (canCreateFromBoolean()) {\n+            String str = value.trim();\n+            if (\"true\".equals(str)) {\n+                return createFromBoolean(ctxt, true);\n+            }\n+            if (\"false\".equals(str)) {\n+                return createFromBoolean(ctxt, false);\n+            }\n+        }\n+        // also, empty Strings might be accepted as null Object...\n+        if (value.length() == 0) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                return null;\n+            }\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from String value ('\"+value+\"'); no single-String constructor/factory method\");\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n+import java.io.IOException;\n import java.lang.reflect.Member;\n import java.util.*;\n \n-\n import com.fasterxml.jackson.databind.BeanDescription;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n \n     public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n     {\n-        StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType());\n-\n         JavaType delegateType;\n-\n-        if (_delegateCreator == null) {\n+        boolean maybeVanilla = _delegateCreator == null;\n+        \n+        if (maybeVanilla) {\n             delegateType = null;\n         } else {\n             // need to find type...\n             TypeBindings bindings = _beanDesc.bindingsForBeanType();\n             delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix));\n         }\n-        \n+\n+        final JavaType type = _beanDesc.getType();\n+\n+        // Any non-standard creator will prevent; with one exception: int-valued constructor\n+        // that standard containers container can be ignored\n+        maybeVanilla &= (_propertyBasedCreator == null)\n+                && (_delegateCreator == null)\n+                && (_stringCreator == null)\n+                && (_longCreator == null)\n+                && (_doubleCreator == null)\n+                && (_booleanCreator == null)\n+                ;\n+\n+        if (maybeVanilla) {\n+        /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n+         *   of \"well-known\" types, can create a non-reflection-based instantiator.\n+         */\n+            final Class<?> rawType = type.getRawClass();\n+            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n+                return new Vanilla(Vanilla.TYPE_COLLECTION);\n+            }\n+            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n+                return new Vanilla(Vanilla.TYPE_MAP);\n+            }\n+            if (rawType == HashMap.class) {\n+                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n+            }\n+        }\n+        \n+        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n         inst.configureFromObjectSettings(_defaultConstructor,\n                 _delegateCreator, delegateType, _delegateArgs,\n                 _propertyBasedCreator, _propertyBasedArgs);\n     public boolean hasDefaultCreator() {\n         return _defaultConstructor != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n         }\n         return _fixAccess(newOne);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper class(es)\n+    /**********************************************************\n+     */\n+\n+    protected final static class Vanilla\n+        extends ValueInstantiator\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static int TYPE_COLLECTION = 1;\n+        public final static int TYPE_MAP = 2;\n+        public final static int TYPE_HASH_MAP = 3;\n+\n+        private final int _type;\n+        \n+        public Vanilla(int t) {\n+            _type = t;\n+        }\n+        \n+        \n+        @Override\n+        public String getValueTypeDesc() {\n+            switch (_type) {\n+            case TYPE_COLLECTION: return ArrayList.class.getName();\n+            case TYPE_MAP: return LinkedHashMap.class.getName();\n+            case TYPE_HASH_MAP: return HashMap.class.getName();\n+            }\n+            return Object.class.getName();\n+        }\n+\n+        @Override\n+        public boolean canInstantiate() { return true; }\n+\n+        @Override\n+        public boolean canCreateUsingDefault() {  return true; }\n+\n+        @Override\n+        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n+            switch (_type) {\n+            case TYPE_COLLECTION: return new ArrayList<Object>();\n+            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n+            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n+            }\n+            throw new IllegalStateException(\"Unknown type \"+_type);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.DeserializationFeature;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n     public boolean isCachable() { return true; }\n     \n     @Override\n-    public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken curr = jp.getCurrentToken();\n         \n             String name = jp.getText();\n             Enum<?> result = _resolver.findEnum(name);\n             if (result == null) {\n-                name = name.trim();\n-                if (name.length() == 0) {\n-                    if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                        return null;\n-                    }\n-                } else {\n-                    // [#149]: Allow use of 'String' indexes as well\n-                    char c = name.charAt(0);\n-                    if (c >= '0' && c <= '9') {\n-                        try {\n-                            int ix = Integer.parseInt(name);\n-                            result = _resolver.getEnum(ix);\n-                            if (result != null) {\n-                                return result;\n-                            }\n-                        } catch (NumberFormatException e) {\n-                            // fine, ignore, was not an integer\n-                        }\n-                    }\n-                }\n-                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                    throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n-                            \"value not one of declared Enum instance names: \"+_resolver.getEnums());\n-                }\n+                return _deserializeAltString(jp, ctxt, name);\n             }\n             return result;\n         }\n         // But let's consider int acceptable as well (if within ordinal range)\n         if (curr == JsonToken.VALUE_NUMBER_INT) {\n-            /* ... unless told not to do that. :-)\n-             * (as per [JACKSON-412]\n-             */\n+            // ... unless told not to do that. :-) (as per [JACKSON-412]\n             if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n                 throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n             }\n             }\n             return result;\n         }\n-        \n+        return _deserializeOther(jp, ctxt);\n+    }\n+\n+    private final Enum<?> _deserializeAltString(JsonParser jp, DeserializationContext ctxt,\n+            String name) throws IOException\n+    {\n+        name = name.trim();\n+        if (name.length() == 0) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                return null;\n+            }\n+        } else {\n+            // [#149]: Allow use of 'String' indexes as well\n+            char c = name.charAt(0);\n+            if (c >= '0' && c <= '9') {\n+                try {\n+                    int ix = Integer.parseInt(name);\n+                    Enum<?> result = _resolver.getEnum(ix);\n+                    if (result != null) {\n+                        return result;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // fine, ignore, was not an integer\n+                }\n+            }\n+        }\n+        if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+            throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n+                    \"value not one of declared Enum instance names: \"+_resolver.getEnums());\n+        }\n+        return null;\n+    }\n+\n+    private final Enum<?> _deserializeOther(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n         // Issue#381\n         if (curr == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             }\n             return parsed;\n         }\n-\n         throw ctxt.mappingException(_resolver.getEnumClass());\n     }\n-\n+    \n     /*\n     /**********************************************************\n-    /* Default JsonDeserializer implementation\n+    /* Additional helper classes\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n      * \n      * @since 2.1\n      */\n-    protected final String _parseString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        // Issue#381\n-        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+    protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_STRING) {\n+            return jp.getText();\n+        }\n+        \n+        // Issue#381\n+        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final String parsed = _parseString(jp, ctxt);\n             if (jp.nextToken() != JsonToken.END_ARRAY) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n  * Creator methods that can be indicated by standard Jackson\n  * annotations.\n  */\n+@JacksonStdImpl\n public class StdValueInstantiator\n     extends ValueInstantiator\n     implements java.io.Serializable\n     /**********************************************************\n      */\n \n-    protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n-    {\n-        /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy\n-         *   systems that expect conversions in some cases, let's just add a minimal\n-         *   patch (note: same could conceivably be used for numbers too).\n-         */\n-        if (_fromBooleanCreator != null) {\n-            String str = value.trim();\n-            if (\"true\".equals(str)) {\n-                return createFromBoolean(ctxt, true);\n-            }\n-            if (\"false\".equals(str)) {\n-                return createFromBoolean(ctxt, false);\n-            }\n-        }\n-        \n-        // and finally, empty Strings might be accepted as null Object...\n-        if (value.length() == 0) {\n-            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                return null;\n-            }\n-        }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n-                +\" from String value ('\"+value+\"'); no single-String constructor/factory method\");\n-    }\n-    \n     protected JsonMappingException wrapException(Throwable t)\n     {\n         while (t.getCause() != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         return new StringCollectionDeserializer(_collectionType,\n                 _valueInstantiator, delegateDeser, valueDeser);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing\n \n     @Override\n     public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,\n-                                          Collection<String> result)\n+            Collection<String> result)\n         throws IOException\n     {\n         // Ok: must point to START_ARRAY\n         JsonToken t;\n \n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt));\n+            String value;\n+            if (t == JsonToken.VALUE_STRING) {\n+                value = jp.getText();\n+            } else if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else {\n+                value = _parseString(jp, ctxt);\n+            }\n+            result.add(value);\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n     @Override\n     public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n+        JsonToken curr = jp.getCurrentToken();\n+        if (curr == JsonToken.VALUE_STRING) {\n+            return jp.getText();\n+        }\n+\n         // Issue#381\n-        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+        if (curr == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final String parsed = _parseString(jp, ctxt);\n             if (jp.nextToken() != JsonToken.END_ARRAY) {\n             }            \n             return parsed;            \n         }\n-        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n-        String text = jp.getValueAsString();\n-        if (text != null) {\n-            return text;\n-        }\n         // [JACKSON-330]: need to gracefully handle byte[] data, as base64\n-        JsonToken curr = jp.getCurrentToken();\n         if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n             Object ob = jp.getEmbeddedObject();\n             if (ob == null) {\n             // otherwise, try conversion using toString()...\n             return ob.toString();\n         }\n+        // allow coercions for other scalar types\n+        String text = jp.getValueAsString();\n+        if (text != null) {\n+            return text;\n+        }\n         throw ctxt.mappingException(_valueClass, curr);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n     }\n     \n     @Override\n-    public String findParameterSourceName(AnnotatedParameter param) {\n-        String r = _primary.findParameterSourceName(param);\n-        return (r == null) ? _secondary.findParameterSourceName(param) : r;\n+    public String findImplicitPropertyName(AnnotatedMember param) {\n+        String r = _primary.findImplicitPropertyName(param);\n+        return (r == null) ? _secondary.findImplicitPropertyName(param) : r;\n     }\n \n     // // // Serialization: class annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n     {\n     \tPropertyName name = _annotationIntrospector.findNameForDeserialization(param);\n     \tif (name == null || name.isEmpty()) {\n-    \t\tString str = _annotationIntrospector.findParameterSourceName(param);\n+    \t\tString str = _annotationIntrospector.findImplicitPropertyName(param);\n     \t\tif (str != null && !str.isEmpty()) {\n     \t\t\tname = new PropertyName(str);\n     \t\t}\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n      * to use; override is needed if a custom sub-class is to be used.\n      */\n     protected POJOPropertiesCollector constructPropertyCollector(MapperConfig<?> config,\n-            AnnotatedClass ac, JavaType type,\n-            boolean forSerialization, String mutatorPrefix)\n+            AnnotatedClass ac, JavaType type, boolean forSerialization, String mutatorPrefix)\n     {\n         return new POJOPropertiesCollector(config, forSerialization, type, ac, mutatorPrefix);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-\n \n /**\n  * Helper class used to introspect features of POJO value classes\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         if (ann == null) {\n             return null;\n         }\n-        return new PropertyName(ann.value());\n+        String ns = ann.namespace();\n+        if (ns != null && ns.length() == 0) {\n+            ns = null;\n+        }\n+        return PropertyName.construct(ann.value(), ns);\n     }\n \n     @Override\n     }\n \n     @Override\n-    public String findParameterSourceName(AnnotatedParameter param) {\n-        // not known by default (until JDK8); but leave explicit:\n+    public String findImplicitPropertyName(AnnotatedMember param) {\n+        // not known by default (until JDK8) for creators; default \n+        //\n         return null;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n         return null;\n     }\n \n+    /**\n+     * Accessor for set of properties that are explicitly marked to be ignored\n+     * via per-property markers (but NOT class annotations).\n+     */\n     public Set<String> getIgnoredPropertyNames() {\n         return _ignoredPropertyNames;\n     }\n         final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);\n         \n         for (AnnotatedField f : _classDef.fields()) {\n-            String implName = f.getName();\n+            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);\n+            if (implName == null) {\n+                implName = f.getName();\n+            }\n+            \n             PropertyName pn;\n \n             if (ai == null) {\n     protected void _addCreatorParam(AnnotatedParameter param)\n     {\n         // JDK 8, paranamer can give implicit name\n-        String impl = _annotationIntrospector.findParameterSourceName(param);\n+        String impl = _annotationIntrospector.findImplicitPropertyName(param);\n         if (impl == null) {\n             impl = \"\";\n         }\n         PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n         boolean nameExplicit = (pn != null);\n \n-        if (!nameExplicit) { // no explicit name; must follow naming convention\n-            implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+        if (!nameExplicit) { // no explicit name; must consider implicit\n+            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n+            if (implName == null) {\n+                implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+            }\n             if (implName == null) { // if not, must skip\n                 implName = BeanUtil.okNameForIsGetter(m, m.getName());\n                 if (implName == null) {\n             }\n         } else { // explicit indication of inclusion, but may be empty\n             // we still need implicit name to link with other pieces\n-            implName = BeanUtil.okNameForGetter(m);\n+            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n+            if (implName == null) {\n+                implName = BeanUtil.okNameForGetter(m);\n+            }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n                 implName = m.getName();\n         PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);\n         boolean nameExplicit = (pn != null);\n         if (!nameExplicit) { // no explicit name; must follow naming convention\n-            implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n+            if (implName == null) {\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            }\n             if (implName == null) { // if not, must skip\n             \treturn;\n             }\n             visible = _visibilityChecker.isSetterVisible(m);\n         } else { // explicit indication of inclusion, but may be empty\n             // we still need implicit name to link with other pieces\n-            implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n+            if (implName == null) {\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n                 implName = m.getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n     protected final boolean _forSerialization;\n \n     protected final AnnotationIntrospector _annotationIntrospector;\n-    \n+\n     /**\n      * External name of logical property; may change with\n      * renaming (by new instance being constructed using\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n             }\n         }\n \n-        // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n-        // Challenge here is that EnumSerializer does not know how to produce\n-        // POJO style serialization, so we must handle that special case separately;\n-        // otherwise pass it to EnumSerializer.\n         if (ser == null) {\n+            // We may also want to use serialize Collections \"as beans\", if (and only if)\n+            // this is specified with `@JsonFormat(shape=Object)`\n             JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n             if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                 return null;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n+                PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+                PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n+                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName((rootType == null)\n+                PropertyName pname = (rootType == null)\n                         ? _rootNames.findRootName(value.getClass(), _config)\n-                        : _rootNames.findRootName(rootType, _config));\n+                        : _rootNames.findRootName(rootType, _config);\n+                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n package com.fasterxml.jackson.databind.util;\n \n-import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n      * For efficient operation, let's try to minimize number of times we\n      * need to introspect root element name to use.\n      */\n-    protected transient LRUMap<ClassKey,SerializableString> _rootNames;\n+    protected transient LRUMap<ClassKey,PropertyName> _rootNames;\n \n     public RootNameLookup() {\n-        _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);\n+        _rootNames = new LRUMap<ClassKey,PropertyName>(20, 200);\n    }\n \n-    public SerializableString findRootName(JavaType rootType, MapperConfig<?> config) {\n+    public PropertyName findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     }\n \n-    public SerializableString findRootName(Class<?> rootType, MapperConfig<?> config)\n+    public PropertyName findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         ClassKey key = new ClassKey(rootType);\n-        SerializableString name = _rootNames.get(key);\n+        PropertyName name = _rootNames.get(key); \n         if (name != null) {\n             return name;\n         }\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         AnnotatedClass ac = beanDesc.getClassInfo();\n-        PropertyName pname = intr.findRootName(ac);\n-        String nameStr;\n+        name = intr.findRootName(ac);\n         // No answer so far? Let's just default to using simple class name\n-        if (pname == null || !pname.hasSimpleName()) {\n+        if (name == null || !name.hasSimpleName()) {\n             // Should we strip out enclosing class tho? For now, nope:\n-            nameStr = rootType.getSimpleName();\n-        } else {\n-            nameStr = pname.getSimpleName();\n+            name = new PropertyName(rootType.getSimpleName());\n         }\n-        name = config.compileString(nameStr);\n         _rootNames.put(key, name);\n         return name;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n \n             // First, as regular double value\n             if (NAN_STRING != str) {\n-            \tresult = MAPPER.readValue(new StringReader(str), Double.class);\n+                result = MAPPER.readValue(str, Double.class);\n             \tassertEquals(exp, result);\n             }\n             // and then as coerced String:\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestUnknownPropertyDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestUnknownPropertyDeserialization.java\n         @JsonIgnoreProperties(\"x\")\n         public Map<String,Integer> values;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(Integer.valueOf(2), result.values.get(\"y\"));\n     }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n package com.fasterxml.jackson.failing;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.*;\n \n /**\n  * Tests Scala-style JVM naming patterns for properties.\n  */\n public class TestScalaLikeImplicitProperties extends BaseMapTest\n {\n+    static class NameMangler extends JacksonAnnotationIntrospector\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember member) {\n+            String name = null;\n+            if (member instanceof AnnotatedField) {\n+                name = member.getName();\n+            }\n+            if (name != null) {\n+                if (name.endsWith(\"\u203f\")) {                    \n+                    return name.substring(0, name.length()-1);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+    \n     static class ValProperty\n     {\n         public final String prop\u203f;\n         // getProp/setProp pairs.\n     }\n \n-\n     public void testValProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n+        ObjectMapper m = manglingMapper();\n \n         // TODO: Activate whatever handler implements the property detection style\n \n \n     public void testValWithBeanProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n+        ObjectMapper m = manglingMapper();\n \n         // TODO: Activate whatever handler implements the property detection style\n \n \n     public void testVarProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n+        ObjectMapper m = manglingMapper();\n \n         // TODO: Activate whatever handler implements the property detection style\n \n \n     public void testVarWithBeanProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n+        ObjectMapper m = manglingMapper();\n \n         // TODO: Activate whatever handler implements the property detection style\n \n \n     public void testGetterSetterProperty() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n+        ObjectMapper m = manglingMapper();\n \n         // TODO: Activate whatever handler implements the property detection style\n \n         GetterSetterProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", GetterSetterProperty.class);\n         assertEquals(\"read\", result.prop());\n     }\n+\n+    private ObjectMapper manglingMapper()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.setAnnotationIntrospector(new NameMangler());\n+        return m;\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for checking handling of unknown properties\n+ */\n+public class TestUnknownProperty426 extends BaseMapTest\n+{\n+    // For [Issue#426]\n+    @JsonIgnoreProperties({ \"userId\"})\n+    public class User {\n+        Integer userId; \n+\n+        void setUserId(String id) {\n+            setUserId(new Integer(id));\n+        }\n+    \n+        public Integer getUserId() {\n+            return userId;\n+        }\n+    \n+        public void setUserId(Integer v) {\n+            this.userId = v;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testIssue426() throws Exception\n+    {\n+        String jsonString = \"{id: 9, firstName: \\\"Mike\\\" }\";\n+        User result = MAPPER.reader( User.class ).readValue(jsonString);\n+        assertNotNull(result);\n+    }\n+}\n+", "timestamp": 1400281283, "metainfo": ""}