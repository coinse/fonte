{"sha": "c7906ba19b9d69c62b29fd648e921c853bc2655f", "log": "Fixing #486", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     }\n \n     protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n-            JsonToken t)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (t == null) {\n-            return _missingToken(jp, ctxt);\n-        }\n+            JsonToken t) throws IOException\n+    {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n         case VALUE_NUMBER_FLOAT:\n \t    return deserializeFromDouble(jp, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return jp.getEmbeddedObject();\n+            return deserializeFromEmbedded(jp, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n             return deserializeFromBoolean(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      */\n     @SuppressWarnings(\"resource\") // TokenBuffers don't need close, nor parser thereof\n     protected Object _convertObjectId(JsonParser jp, DeserializationContext ctxt,\n-            Object rawId, JsonDeserializer<Object> idDeser)\n-        throws IOException, JsonProcessingException\n+            Object rawId, JsonDeserializer<Object> idDeser) throws IOException\n     {\n         TokenBuffer buf = new TokenBuffer(jp);\n         if (rawId instanceof String) {\n             buf.writeNumber(((Integer) rawId).intValue());\n         } else {\n             // should we worry about UUIDs? They should be fine, right?\n+            // 07-Aug-2014, tatu: Maybe, but not necessarily; had issues with\n+            //   Smile format; [Smile#19], possibly related.\n             buf.writeObject(rawId);\n         }\n         JsonParser bufParser = buf.asParser();\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         return deserializeFromObject(jp, ctxt);\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n     }\n \n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+            DeserializationContext ctxt) throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n         throws IOException, JsonProcessingException;\n \n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n         throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n     }\n \n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n      * number.\n      */\n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         switch (jp.getNumberType()) {\n         case FLOAT: // no separate methods for taking float...\n     /**\n      * Method called to deserialize POJO value from a JSON boolean value (true, false)\n      */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n         return _valueInstantiator.createFromBoolean(ctxt, value);\n     }\n \n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             try {\n             return value;\n         }\n         throw ctxt.mappingException(getBeanClass());\n+    }\n+\n+    public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // First things first: id Object Id is used, most likely that's it; specifically,\n+        // true for UUIDs when written as binary (with Smile, other binary formats)\n+        if (_objectIdReader != null) {\n+            return deserializeFromObjectId(jp, ctxt);\n+        }\n+\n+        // TODO: maybe add support for ValueInstantiator, embedded?\n+        \n+        return jp.getEmbeddedObject();\n     }\n     \n     /*", "timestamp": 1407479249, "metainfo": ""}