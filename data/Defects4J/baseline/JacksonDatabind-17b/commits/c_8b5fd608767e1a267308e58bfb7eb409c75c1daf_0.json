{"sha": "8b5fd608767e1a267308e58bfb7eb409c75c1daf", "log": "Add support for polymorphic deserialization using native type ids: initially needed by YAML module", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     private final Object _deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n+        // 02-Aug-2013, tatu: May need to use native type ids\n+        if (jp.canReadTypeId()) {\n+            return _deserializeWithNativeTypeId(jp, ctxt);\n+        }\n         boolean hadStartArray = jp.isExpectedStartArrayToken();\n         String typeId = _locateTypeId(jp, ctxt);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n     public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n+        // 02-Aug-2013, tatu: May need to use native type ids\n+        if (jp.canReadTypeId()) {\n+            return _deserializeWithNativeTypeId(jp, ctxt);\n+        }\n+        \n         // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n  * the same, regardless of structure used for actual value: wrapping\n  * is done using a single-element JSON Object where type id is the key,\n  * and actual object data as the value.\n- * \n- * @author tatu\n  */\n public class AsWrapperTypeDeserializer\n     extends TypeDeserializerBase\n     private final Object _deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n+        // 02-Aug-2013, tatu: May need to use native type ids\n+        if (jp.canReadTypeId()) {\n+            return _deserializeWithNativeTypeId(jp, ctxt);\n+        }\n+\n         // first, sanity checks\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n             throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT,\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n             return _defaultImplDeserializer;\n         }\n     }\n+\n+    /**\n+     * Helper method called when {@link JsonParser} indicates that it can use\n+     * so-called native type ids. Assumption from there is that only native\n+     * type ids are to be used.\n+     * \n+     * @since 2.3\n+     */\n+    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final String typeId = jp.getTypeId();\n+        JsonDeserializer<Object> deser;\n+        if (typeId == null) {\n+            if (_defaultImpl != null) {\n+                deser = _findDefaultImplDeserializer(ctxt);\n+            } else {\n+                throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n+            }\n+        } else {\n+            deser = _findDeserializer(ctxt, typeId);\n+        }\n+        /* 02-Aug-2013, tatu: What if type id is marked as \"visible\"? Should we try to\n+         *  inject it in, as with non-native type ids? For now, let's not.\n+         */\n+        return deser.deserialize(jp, ctxt);\n+    }\n }", "timestamp": 1375562488, "metainfo": ""}