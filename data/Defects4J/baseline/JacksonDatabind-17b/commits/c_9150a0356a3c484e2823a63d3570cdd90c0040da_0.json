{"sha": "9150a0356a3c484e2823a63d3570cdd90c0040da", "log": "Refactoring; move more std deserializers out of JdkDeserializers container", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n+import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n             } else {\n                 referencedType = params[0];\n             }\n-            return new JdkDeserializers.AtomicReferenceDeserializer(referencedType);\n+            return new AtomicReferenceDeserializer(referencedType);\n         }\n         return findOptionalStdDeserializer(ctxt, type, beanDesc);\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+public class AtomicBooleanDeserializer\n+    extends StdScalarDeserializer<AtomicBoolean>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static AtomicBooleanDeserializer instance = new AtomicBooleanDeserializer();\n+\n+    public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n+    \n+    @Override\n+    public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // 16-Dec-2010, tatu: Should we actually convert null to null AtomicBoolean?\n+        return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+\n+public class AtomicReferenceDeserializer\n+    extends StdScalarDeserializer<AtomicReference<?>>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Type of value that we reference\n+     */\n+    protected final JavaType _referencedType;\n+    \n+    protected final JsonDeserializer<?> _valueDeserializer;\n+    \n+    /**\n+     * @param referencedType Parameterization of this reference\n+     */\n+    public AtomicReferenceDeserializer(JavaType referencedType) {\n+        this(referencedType, null);\n+    }\n+    \n+    public AtomicReferenceDeserializer(JavaType referencedType,\n+            JsonDeserializer<?> deser)\n+    {\n+        super(AtomicReference.class);\n+        _referencedType = referencedType;\n+        _valueDeserializer = deser;\n+    }\n+    \n+    @Override\n+    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonDeserializer<?> deser = _valueDeserializer;\n+        if (deser != null) {\n+            return this;\n+        }\n+        return new AtomicReferenceDeserializer(_referencedType,\n+                ctxt.findContextualValueDeserializer(_referencedType, property));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CharsetDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+// [JACKSON-789]\n+public class CharsetDeserializer\n+    extends FromStringDeserializer<Charset>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static CharsetDeserializer instance = new CharsetDeserializer();\n+\n+    public CharsetDeserializer() { super(Charset.class); }\n+\n+    @Override\n+    protected Charset _deserialize(String value, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return Charset.forName(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/InetAddressDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+/**\n+ * As per [JACKSON-484], also need special handling for InetAddress...\n+ */\n+class InetAddressDeserializer\n+    extends FromStringDeserializer<InetAddress>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static InetAddressDeserializer instance = new InetAddressDeserializer();\n+\n+    public InetAddressDeserializer() { super(InetAddress.class); }\n+\n+    @Override\n+    protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return InetAddress.getByName(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/InetSocketAddressDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+\n+/**\n+ * Deserializer for {@link InetSocketAddress}.\n+ *\n+ * @see <a href=\"https://github.com/FasterXML/jackson-databind/issues/48\">Issue 48</a>\n+ */\n+public class InetSocketAddressDeserializer\n+    extends FromStringDeserializer<InetSocketAddress>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static InetSocketAddressDeserializer instance = new InetSocketAddressDeserializer();\n+\n+    public InetSocketAddressDeserializer() { super(InetSocketAddress.class); }\n+\n+    @Override\n+    protected InetSocketAddress _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+    {\n+        if (value.startsWith(\"[\")) {\n+            // bracketed IPv6 (with port number)\n+\n+            int i = value.lastIndexOf(']');\n+            if (i == -1) {\n+                throw new InvalidFormatException(\n+                        \"Bracketed IPv6 address must contain closing bracket.\",\n+                        value, InetSocketAddress.class);\n+            }\n+\n+            int j = value.indexOf(':', i);\n+            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+            return new InetSocketAddress(value.substring(0, i + 1), port);\n+        } else {\n+            int i = value.indexOf(':');\n+            if (i != -1 && value.indexOf(':', i + 1) == -1) {\n+                // host:port\n+                int port = Integer.parseInt(value.substring(i));\n+                return new InetSocketAddress(value.substring(0, i), port);\n+            } else {\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import java.nio.charset.Charset;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n import java.util.regex.Pattern;\n \n-import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n-import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n \n /**\n  * Container class that contains serializers for JDK types that\n         }\n     }\n \n-    /**\n-     * @deprecated Since 2.2 -- use {@link #find} instead.\n-     */\n-    @Deprecated\n-    public static StdDeserializer<?>[] all()\n-    {\n-        return new StdDeserializer[] {\n-            // from String types:\n-            UUIDDeserializer.instance,\n-            URLDeserializer.instance,\n-            URIDeserializer.instance,\n-            FileDeserializer.instance,\n-            CurrencyDeserializer.instance,\n-            PatternDeserializer.instance,\n-            LocaleDeserializer.instance,\n-            InetAddressDeserializer.instance,\n-            InetSocketAddressDeserializer.instance,\n-            CharsetDeserializer.instance,\n-            \n-            // other types:\n-\n-            // (note: AtomicInteger/Long work due to single-arg constructor;\n-            AtomicBooleanDeserializer.instance,\n-            ClassDeserializer.instance,\n-            StackTraceElementDeserializer.instance\n-        };\n-    }\n-\n     public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n     {\n         if (!_classNames.contains(clsName)) {\n         }\n     }\n     \n-    /**\n-     * As per [JACKSON-484], also need special handling for InetAddress...\n-     */\n-    protected static class InetAddressDeserializer\n-        extends FromStringDeserializer<InetAddress>\n-    {\n-        public final static InetAddressDeserializer instance = new InetAddressDeserializer();\n-\n-        public InetAddressDeserializer() { super(InetAddress.class); }\n-    \n-        @Override\n-        protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return InetAddress.getByName(value);\n-        }\n-    }\n-\n-    /**\n-     * Deserializer for {@link InetSocketAddress}.\n-     *\n-     * @see <a href=\"https://github.com/FasterXML/jackson-databind/issues/48\">Issue 48</a>\n-     */\n-    protected static class InetSocketAddressDeserializer\n-            extends FromStringDeserializer<InetSocketAddress>\n-    {\n-        public final static InetSocketAddressDeserializer instance = new InetSocketAddressDeserializer();\n-\n-        public InetSocketAddressDeserializer() { super(InetSocketAddress.class); }\n-\n-        @Override\n-        protected InetSocketAddress _deserialize(String value, DeserializationContext ctxt)\n-                throws IOException\n-        {\n-            if (value.startsWith(\"[\")) {\n-                // bracketed IPv6 (with port number)\n-\n-                int i = value.lastIndexOf(']');\n-                if (i == -1) {\n-                    throw new InvalidFormatException(\n-                            \"Bracketed IPv6 address must contain closing bracket.\",\n-                            value, InetSocketAddress.class);\n-                }\n-\n-                int j = value.indexOf(':', i);\n-                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n-            } else {\n-                int i = value.indexOf(':');\n-                if (i != -1 && value.indexOf(':', i + 1) == -1) {\n-                    // host:port\n-                    int port = Integer.parseInt(value.substring(i));\n-                    return new InetSocketAddress(value.substring(0, i), port);\n-                } else {\n-                    // host or unbracketed IPv6, without port number\n-                    return new InetSocketAddress(value, 0);\n-                }\n-            }\n-        }\n-    }\n-\n-    // [JACKSON-789]\n-    protected static class CharsetDeserializer\n-        extends FromStringDeserializer<Charset>\n-    {\n-        public final static CharsetDeserializer instance = new CharsetDeserializer();\n-\n-        public CharsetDeserializer() { super(Charset.class); }\n-    \n-        @Override\n-        protected Charset _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return Charset.forName(value);\n-        }\n-    }\n-\n     public static class FileDeserializer\n         extends FromStringDeserializer<File>\n     {\n             return new File(value);\n         }\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* AtomicXxx types\n-    /**********************************************************\n-     */\n-    \n-    public static class AtomicReferenceDeserializer\n-        extends StdScalarDeserializer<AtomicReference<?>>\n-        implements ContextualDeserializer\n-    {\n-        /**\n-         * Type of value that we reference\n-         */\n-        protected final JavaType _referencedType;\n-        \n-        protected final JsonDeserializer<?> _valueDeserializer;\n-        \n-        /**\n-         * @param referencedType Parameterization of this reference\n-         */\n-        public AtomicReferenceDeserializer(JavaType referencedType) {\n-            this(referencedType, null);\n-        }\n-        \n-        public AtomicReferenceDeserializer(JavaType referencedType,\n-                JsonDeserializer<?> deser)\n-        {\n-            super(AtomicReference.class);\n-            _referencedType = referencedType;\n-            _valueDeserializer = deser;\n-        }\n-        \n-        @Override\n-        public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n-        }\n-        \n-        @Override\n-        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-                BeanProperty property) throws JsonMappingException\n-        {\n-            JsonDeserializer<?> deser = _valueDeserializer;\n-            if (deser != null) {\n-                return this;\n-            }\n-            return new AtomicReferenceDeserializer(_referencedType,\n-                    ctxt.findContextualValueDeserializer(_referencedType, property));\n-        }\n-    }\n-\n-    public static class AtomicBooleanDeserializer\n-        extends StdScalarDeserializer<AtomicBoolean>\n-    {\n-        public final static AtomicBooleanDeserializer instance = new AtomicBooleanDeserializer();\n-\n-        public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n-        \n-        @Override\n-        public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            // 16-Dec-2010, tatu: Should we actually convert null to null AtomicBoolean?\n-            return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt));\n-        }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Deserializers for other JDK types\n-    /**********************************************************\n-     */\n-\n-    public static class StackTraceElementDeserializer\n-        extends StdScalarDeserializer<StackTraceElement>\n-    {\n-        public final static StackTraceElementDeserializer instance = new StackTraceElementDeserializer();\n-\n-        public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n-    \n-        @Override\n-        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            // Must get an Object\n-            if (t == JsonToken.START_OBJECT) {\n-                String className = \"\", methodName = \"\", fileName = \"\";\n-                int lineNumber = -1;\n-    \n-                while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {\n-                    String propName = jp.getCurrentName();\n-                    if (\"className\".equals(propName)) {\n-                        className = jp.getText();\n-                    } else if (\"fileName\".equals(propName)) {\n-                        fileName = jp.getText();\n-                    } else if (\"lineNumber\".equals(propName)) {\n-                        if (t.isNumeric()) {\n-                            lineNumber = jp.getIntValue();\n-                        } else {\n-                            throw JsonMappingException.from(jp, \"Non-numeric token (\"+t+\") for property 'lineNumber'\");\n-                        }\n-                    } else if (\"methodName\".equals(propName)) {\n-                        methodName = jp.getText();\n-                    } else if (\"nativeMethod\".equals(propName)) {\n-                        // no setter, not passed via constructor: ignore\n-                    } else {\n-                        handleUnknownProperty(jp, ctxt, _valueClass, propName);\n-                    }\n-                }\n-                return new StackTraceElement(className, methodName, fileName, lineNumber);\n-            }\n-            throw ctxt.mappingException(_valueClass, t);\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+public class StackTraceElementDeserializer\n+    extends StdScalarDeserializer<StackTraceElement>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static StackTraceElementDeserializer instance = new StackTraceElementDeserializer();\n+\n+    public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n+\n+    @Override\n+    public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        // Must get an Object\n+        if (t == JsonToken.START_OBJECT) {\n+            String className = \"\", methodName = \"\", fileName = \"\";\n+            int lineNumber = -1;\n+\n+            while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {\n+                String propName = jp.getCurrentName();\n+                if (\"className\".equals(propName)) {\n+                    className = jp.getText();\n+                } else if (\"fileName\".equals(propName)) {\n+                    fileName = jp.getText();\n+                } else if (\"lineNumber\".equals(propName)) {\n+                    if (t.isNumeric()) {\n+                        lineNumber = jp.getIntValue();\n+                    } else {\n+                        throw JsonMappingException.from(jp, \"Non-numeric token (\"+t+\") for property 'lineNumber'\");\n+                    }\n+                } else if (\"methodName\".equals(propName)) {\n+                    methodName = jp.getText();\n+                } else if (\"nativeMethod\".equals(propName)) {\n+                    // no setter, not passed via constructor: ignore\n+                } else {\n+                    handleUnknownProperty(jp, ctxt, _valueClass, propName);\n+                }\n+            }\n+            return new StackTraceElement(className, methodName, fileName, lineNumber);\n+        }\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+}", "timestamp": 1373431259, "metainfo": ""}