{"sha": "1013b3708da8c52b32bbe251b6d11b0737ff270e", "log": "Merge remote-tracking branch 'jackson/master'  Mostly updated imports and writes on old schema parsing Conflicts: \tsrc/main/java/com/fasterxml/jackson/databind/ObjectMapper.java \tsrc/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java \tsrc/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java \tsrc/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     /**\n      * Method called by framework to determine whether given annotation\n      * is handled by this introspector.\n-     */\n+     *\n+     * @deprecated Not used since 2.0; deprecated sicne 2.1\n+     */\n+    @Deprecated\n     public boolean isHandled(Annotation ann) {\n         return false;\n     }\n      *    class, if any; or null if none found.\n      */\n     public Object findFilterId(AnnotatedClass ac) {\n+        return null;\n+    }\n+    \n+    /**\n+     * Method for finding {@link PropertyNamingStrategy} for given\n+     * class, if any specified by annotations; and if so, either return\n+     * a {@link PropertyNamingStrategy} instance, or Class to use for\n+     * creating instance\n+     * \n+     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n+     *   is specified for given class; null if not.\n+     * \n+     * @since 2.1\n+     */\n+    public Object findNamingStrategy(AnnotatedClass ac) {\n         return null;\n     }\n     \n         \n         // // // Generic annotation properties, lookup\n         \n+        @Deprecated\n         @Override\n         public boolean isHandled(Annotation ann) {\n             return _primary.isHandled(ann) || _secondary.isHandled(ann);\n                 id = _secondary.findFilterId(ac);\n             }\n             return id;\n+        }\n+\n+        @Override\n+        public Object findNamingStrategy(AnnotatedClass ac)\n+        {\n+            Object str = _primary.findNamingStrategy(ac);\n+            if (str == null) {\n+                str = _secondary.findNamingStrategy(ac);\n+            }\n+            return str;\n         }\n         \n         /*\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n package com.fasterxml.jackson.databind;\n \n+import java.io.IOException;\n import java.io.Serializable;\n import java.util.*;\n \n     }\n \n     /**\n+     * Factory method used when \"upgrading\" an {@link IOException} into\n+     * {@link JsonMappingException}: usually only needed to comply with\n+     * a signature.\n+     * \n+     * @since 2.1\n+     */\n+    public static JsonMappingException fromUnexpectedIOE(IOException src)\n+    {\n+        return new JsonMappingException(\"Unexpected IOException (of type \"\n+                +src.getClass().getName()+\"): \"+src.getMessage(), (JsonLocation)null, src);\n+    }\n+    \n+    /**\n      * Method that can be called to either create a new JsonMappingException\n      * (if underlying exception is not a JsonMappingException), or augment\n      * given exception with given path/reference information.\n         jme.prependPath(ref);\n         return jme;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Accessors/mutators\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n \n /**\n  * Sub-class of {@link JsonFactory} that will create a proper\n- * {@link ObjectCodec} to allow seamless conversions between\n- * Json content and Java objects (POJOs).\n+ * {@link ObjectCodec} to allow seam-less conversions between\n+ * JSON content and Java objects (POJOs).\n  * The only addition to regular {@link JsonFactory} currently\n  * is that {@link ObjectMapper} is constructed and passed as\n  * the codec to use.\n     @Override\n     public final ObjectMapper getCodec() { return (ObjectMapper) _objectCodec; }\n \n+    // @since 2.1\n+    @Override\n+    public JsonFactory copy()\n+    {\n+        _checkInvalidCopy(MappingJsonFactory.class);\n+        // note: as with base class, must NOT copy mapper reference\n+        return new MappingJsonFactory(null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Format detection functionality (since 1.8)\n     @Override\n     public MatchStrength hasFormat(InputAccessor acc) throws IOException\n     {\n-        return hasJSONFormat(acc);\n+        if (getClass() == MappingJsonFactory.class) {\n+            return hasJSONFormat(acc);\n+        }\n+        return null;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n-import com.fasterxml.jackson.annotation.JsonAutoDetect;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n-import com.fasterxml.jackson.annotation.PropertyAccessor;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.ser.*;\n-import com.fasterxml.jackson.databind.type.ClassKey;\n-import com.fasterxml.jackson.databind.type.SimpleType;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.type.TypeModifier;\n+import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n import com.fasterxml.jackson.databind.util.StdDateFormat;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n     protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n \n+    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n+    \n     /**\n      * Base settings contain defaults used for all {@link ObjectMapper}\n      * instances.\n     }\n \n     /**\n+     * Copy-constructor, mostly used to support {@link #copy}.\n+     * \n+     * @since 2.1\n+     */\n+    protected ObjectMapper(ObjectMapper src)\n+    {\n+        _jsonFactory = src._jsonFactory.copy();\n+        _jsonFactory.setCodec(this);\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootNames = new RootNameLookup();\n+        _typeFactory = src._typeFactory;\n+        _serializationConfig = src._serializationConfig;\n+        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixInAnnotations);\n+        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixInAnnotations);\n+        _serializerProvider = src._serializerProvider;\n+        _deserializationContext = src._deserializationContext;\n+\n+        // Default serializer factory is stateless, can just assign\n+        _serializerFactory = src._serializerFactory;\n+    }\n+    \n+    /**\n      * Constructs instance that uses specified {@link JsonFactory}\n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s, and uses given providers for accessing\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n+    }\n+\n+    /**\n+     * Method for creating a new {@link ObjectMapper} instance that\n+     * has same initial configuration as this instance. Note that this\n+     * also requires making a copy of the underlying {@link JsonFactory}\n+     * instance.\n+     *<p>\n+     * Method is typically\n+     * used when multiple, differently configured mappers are needed.\n+     * Although configuration is shared, cached serializers and deserializers\n+     * are NOT shared, which means that the new instance may be re-configured\n+     * before use; meaning that it behaves the same way as if an instance\n+     * was constructed from scratch.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectMapper copy()\n+    {\n+        _checkInvalidCopy(ObjectMapper.class);\n+        return new ObjectMapper(this);\n+    }\n+\n+    /**\n+     * @since 2.1\n+     * @param exp\n+     */\n+    protected void _checkInvalidCopy(Class<?> exp)\n+    {\n+        if (getClass() != exp) {\n+            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n+                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n+        }\n     }\n     \n     /*\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig config = getSerializationConfig();\n+        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n+        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n         if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n      * a String. Functionally equivalent to calling\n      * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n      * and constructing String, but more efficient.\n+     *<p>\n+     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n      */\n     public String writeValueAsString(Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws JsonProcessingException\n     {        \n         // alas, we have to pull the recycler directly here...\n         SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n-        _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        try {\n+            _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n+            throw e;\n+        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n+            throw JsonMappingException.fromUnexpectedIOE(e);\n+        }\n         return sw.getAndClear();\n     }\n     \n      * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n      * and getting bytes, but more efficient.\n      * Encoding used will be UTF-8.\n+     *<p>\n+     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n      */\n     public byte[] writeValueAsBytes(Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n-    {        \n+        throws JsonProcessingException\n+    {\n         ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n-        _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        try {\n+            _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n+            throw e;\n+        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n+            throw JsonMappingException.fromUnexpectedIOE(e);\n+        }\n         byte[] result = bb.toByteArray();\n         bb.release();\n         return result;\n      * to use default pretty printer.\n      */\n     protected PrettyPrinter _defaultPrettyPrinter() {\n-        return new DefaultPrettyPrinter();\n+        return _defaultPrettyPrinter;\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.core.util.Instantiatable;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n      * as well\n      */\n     protected final PrettyPrinter _prettyPrinter;\n-\n+    \n     /**\n      * When using data format that uses a schema, schema is passed\n      * to generator.\n     public void writeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        // 10-Aug-2012, tatu: As per [Issue#12], may need to force PrettyPrinter settings, so:\n+        _configureJsonGenerator(jgen);\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)\n+                && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, _config);\n         } else {\n             if (_rootType == null) {\n             }\n         }\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Serialization methods, others\n      * a String. Functionally equivalent to calling\n      * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n      * and constructing String, but more efficient.\n+     *<p>\n+     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n      */\n     public String writeValueAsString(Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws JsonProcessingException\n     {        \n         // alas, we have to pull the recycler directly here...\n         SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n-        _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        try {\n+            _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n+            throw e;\n+        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n+            throw JsonMappingException.fromUnexpectedIOE(e);\n+        }\n         return sw.getAndClear();\n     }\n     \n      * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n      * and getting bytes, but more efficient.\n      * Encoding used will be UTF-8.\n+     *<p>\n+     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n      */\n     public byte[] writeValueAsBytes(Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n-    {        \n+        throws JsonProcessingException\n+    {\n         ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n-        _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        try {\n+            _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n+            throw e;\n+        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n+            throw JsonMappingException.fromUnexpectedIOE(e);\n+        }\n         byte[] result = bb.toByteArray();\n         bb.release();\n         return result;\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_prettyPrinter != null) {\n-            PrettyPrinter pp = _prettyPrinter;\n-            jgen.setPrettyPrinter((pp == NULL_PRETTY_PRINTER) ? null : pp);\n-        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [JACKSON-520]: add support for pass-through schema:\n-        if (_schema != null) {\n-            jgen.setSchema(_schema);\n-        }\n+        _configureJsonGenerator(jgen);\n         // [JACKSON-282]: consider Closeable\n         if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n-            _configAndWriteCloseable(jgen, value, _config);\n+            _writeCloseable(jgen, value, _config);\n             return;\n         }\n         boolean closed = false;\n      * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n-    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+    private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         Closeable toClose = (Closeable) value;\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n                 _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n-            }\n-            // [JACKSON-520]: add support for pass-through schema:\n-            if (_schema != null) {\n-                jgen.setSchema(_schema);\n             }\n             JsonGenerator tmpJgen = jgen;\n             jgen = null;\n     }\n     \n     /**\n-     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n+     * Helper method used when value to serialize is {@link java.util.Closeable}\n+     * and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n             return null;\n         }\n     }\n+    \n+    /**\n+     * Helper method called to set or override settings of passed-in\n+     * {@link JsonGenerator}\n+     * \n+     * @since 2.1\n+     */\n+    private final void _configureJsonGenerator(JsonGenerator jgen)\n+    {\n+        if (_prettyPrinter != null) {\n+            PrettyPrinter pp = _prettyPrinter;\n+            if (pp == NULL_PRETTY_PRINTER) {\n+                jgen.setPrettyPrinter(null);\n+            } else {\n+                /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n+                 *   like the DefaultPrettyPrinter.\n+                 */\n+                if (pp instanceof Instantiatable<?>) {\n+                    pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n+                }\n+                jgen.setPrettyPrinter(pp);\n+            }\n+        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n+        // [JACKSON-520]: add support for pass-through schema:\n+        if (_schema != null) {\n+            jgen.setSchema(_schema);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected SerializationConfig(SerializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.*;\n+\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+\n+/**\n+ * Annotation that can be used to indicate a {@link PropertyNamingStrategy}\n+ * to use for annotated class. Overrides the global (default) strategy.\n+ * \n+ * @since 2.1\n+ */\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonNaming\n+{\n+    public Class<? extends PropertyNamingStrategy> value();\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n             Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n+\n+    /**\n+     * Method called to construct a NamingStrategy instance used for specified\n+     * class.\n+     * \n+     * @since 2.1\n+     */\n+    public PropertyNamingStrategy namingStrategyInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n         _rootName = src._rootName;\n         _view = view;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src);\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+        _view = src._view;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         // Any transformation we may need to apply?\n         JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n         _serializationShape = (format == null) ? null : format.getShape();\n-        \n+\n         _needViewProcesing = hasViews;\n         _vanillaProcessing = !_nonStandardCreation\n                 && (_injectables == null)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n     }\n \n     @Override\n-    protected BuilderBasedDeserializer asArrayDeserializer() {\n-        /* 17-Jul-2012, tatu: Should be doable, but for now let's just not\n-         *   support this combination, and instead wait for an RFE to see\n-         *   if anyone cares.\n-         */\n-        throw new UnsupportedOperationException(\"Can not combine serialization-as-Array with Builder style construction\");\n+    protected BeanAsArrayBuilderDeserializer asArrayDeserializer() {\n+        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n+        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);\n     }\n     \n     /*\n      */\n     \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-    \t\tthrows IOException\n+            throws IOException\n     {\n         try {\n-    \t\treturn _buildMethod.getMember().invoke(builder);\n+            return _buildMethod.getMember().invoke(builder);\n     \t} catch (Exception e) {\n-    \t\twrapInstantiationProblem(e, ctxt);\n-    \t\treturn null;\n-\t\t}\n+    \t    wrapInstantiationProblem(e, ctxt);\n+    \t    return null;\n+    \t}\n     }\n     \n     /**\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             return finishBuild(ctxt, deserializeFromObject(jp, ctxt));\n-\t\t}\n+        }\n         throw ctxt.mappingException(getBeanClass());\n     }\n \n                         continue; // never gets here\n                     }\n                     //  polymorphic?\n-        \t\t    if (bean.getClass() != _beanType.getRawClass()) {\n-        \t\t        return handlePolymorphic(jp, ctxt, bean, unknown);\n-        \t\t    }\n-        \t\t    if (unknown != null) { // nope, just extra unknown stuff...\n-        \t\t        bean = handleUnknownProperties(ctxt, bean, unknown);\n-        \t\t    }\n-        \t\t    // or just clean?\n-        \t\t    return _deserialize(jp, ctxt, bean);\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                    }\n+                    if (unknown != null) { // nope, just extra unknown stuff...\n+                        bean = handleUnknownProperties(ctxt, bean, unknown);\n+                    }\n+                    // or just clean?\n+                    return _deserialize(jp, ctxt, bean);\n                 }\n                 continue;\n             }\n         // We hit END_OBJECT, so:\n         Object bean;\n         try {\n-            bean =  creator.build(ctxt, buffer);\n+            bean = creator.build(ctxt, buffer);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n                         mlt, beanDesc);\n             }\n             if (type.isCollectionLikeType()) {\n-                CollectionLikeType clt = (CollectionLikeType) type;\n-                if (clt.isTrueCollectionType()) {\n-                    return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n-                            (CollectionType) clt, beanDesc);\n-                }\n-                return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n-                        clt, beanDesc);\n+                /* 03-Aug-2012, tatu: As per [Issue#40], one exception is if shape\n+                 *   is to be Shape.OBJECT. Ideally we'd determine it bit later on\n+                 *   (to allow custom handler checks), but that won't work for other\n+                 *   reasons. So do it here.\n+                 */\n+                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n+                    CollectionLikeType clt = (CollectionLikeType) type;\n+                    if (clt.isTrueCollectionType()) {\n+                        return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n+                                (CollectionType) clt, beanDesc);\n+                    }\n+                    return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n+                            clt, beanDesc);\n+                }\n             }\n         }\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+public class BeanAsArrayBuilderDeserializer\n+    extends BeanDeserializerBase\n+{\n+    /**\n+     * Deserializer we delegate operations that we can not handle.\n+     */\n+    protected final BeanDeserializerBase _delegate;\n+\n+    /**\n+     * Properties in order expected to be found in JSON array.\n+     */\n+    protected final SettableBeanProperty[] _orderedProperties;\n+\n+    protected final AnnotatedMethod _buildMethod;\n+        \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Main constructor used both for creating new instances (by\n+     * {@link BeanDeserializer#asArrayDeserializer}) and for\n+     * creating copies with different delegate.\n+     */\n+    public BeanAsArrayBuilderDeserializer(BeanDeserializerBase delegate,\n+            SettableBeanProperty[] ordered,\n+            AnnotatedMethod buildMethod)\n+    {\n+        super(delegate);\n+        _delegate = delegate;\n+        _orderedProperties = ordered;\n+        _buildMethod = buildMethod;\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n+    {\n+        /* We can't do much about this; could either replace _delegate\n+         * with unwrapping instance, or just replace this one. Latter seems\n+         * more sensible.\n+         */\n+        return _delegate.unwrappingDeserializer(unwrapper);\n+    }\n+\n+    @Override\n+    public BeanAsArrayBuilderDeserializer withObjectIdReader(ObjectIdReader oir) {\n+        return new BeanAsArrayBuilderDeserializer(_delegate.withObjectIdReader(oir),\n+                _orderedProperties, _buildMethod);\n+    }\n+\n+    @Override\n+    public BeanAsArrayBuilderDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n+        return new BeanAsArrayBuilderDeserializer(_delegate.withIgnorableProperties(ignorableProps),\n+                _orderedProperties, _buildMethod);\n+    }\n+\n+    @Override\n+    protected BeanAsArrayBuilderDeserializer asArrayDeserializer() {\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n+            throws IOException\n+    {\n+        try {\n+            return _buildMethod.getMember().invoke(builder);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null;\n+        }\n+    }\n+    \n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n+        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        }\n+        if (!_vanillaProcessing) {\n+            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+        }\n+        Object builder = _valueInstantiator.createUsingDefault(ctxt);\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return finishBuild(ctxt, builder);\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return finishBuild(ctxt, builder);\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* No good way to verify that we have an array... although could I guess\n+         * check via JsonParser. So let's assume everything is working fine, for now.\n+         */\n+        if (_injectables != null) {\n+            injectValues(ctxt, builder);\n+        }\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return finishBuild(ctxt, builder);\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n+        \n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return finishBuild(ctxt, builder);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, non-standard creation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Alternate deserialization method that has to check many more configuration\n+     * aspects than the \"vanilla\" processing.\n+     * Note: should NOT resolve builder; caller will do that\n+     * \n+     * @return Builder object in use.\n+     */\n+    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_nonStandardCreation) {\n+            return _deserializeWithCreator(jp, ctxt);\n+        }\n+        Object builder = _valueInstantiator.createUsingDefault(ctxt);\n+        if (_injectables != null) {\n+            injectValues(ctxt, builder);\n+        }\n+        Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return builder;\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            ++i;\n+            if (prop != null) { // normal case\n+                if (activeView == null || prop.visibleInView(activeView)) {\n+                    try {\n+                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                    }\n+                    continue;\n+                }\n+            }\n+            // otherwise, skip it (view-filtered, no prop etc)\n+            jp.skipChildren();\n+        }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return builder;\n+    }\n+    \n+    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt,\n+                    _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+\n+    /**\n+     * Method called to deserialize bean using \"property-based creator\":\n+     * this means that a non-default constructor or factory method is\n+     * called, and then possibly other setters. The trick is that\n+     * values for creator method need to be buffered, first; and \n+     * due to non-guaranteed ordering possibly some other properties\n+     * as well.\n+     */\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+            final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        final int propCount = props.length;\n+        int i = 0;\n+        Object builder = null;\n+        \n+        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+            SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n+            if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // if we have already constructed POJO, things are simple:\n+            if (builder != null) {\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, prop.getName(), ctxt);\n+                }\n+                continue;\n+            }\n+            final String propName = prop.getName();\n+            // if not yet, maybe we got a creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n+                    try {\n+                        builder = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    //  polymorphic?\n+                    if (builder.getClass() != _beanType.getRawClass()) {\n+                        /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n+                         *   supported (since ordering of elements may not be guaranteed);\n+                         *   but make explicitly non-supported for now.\n+                         */\n+                        throw ctxt.mappingException(\"Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: \"\n+                                +\"nominal type \"+_beanType.getRawClass().getName()+\", actual type \"+builder.getClass().getName());\n+                    }\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+        }\n+\n+        // In case we didn't quite get all the creator properties, we may have to do this:\n+        if (builder == null) {\n+            try {\n+                builder = creator.build(ctxt, buffer);\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+                return null; // never gets here\n+            }\n+        }\n+        return builder;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, error reporting\n+    /**********************************************************\n+     */\n+\n+    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        // Let's start with failure\n+        throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n+                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\"): type/property designed to be serialized as JSON Array\");\n+        // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n+        //return _delegate.deserialize(jp, ctxt);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n     /**\n      * @deprecated since 2.1, use {@link #setDefaultCreator} instead.\n      */\n+    @Deprecated\n     public void setDefaultConstructor(AnnotatedConstructor ctor) {\n         _defaultConstructor = _fixAccess(ctor);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n     {\n         return new BasicBeanDescription(config, type,\n                 ac, Collections.<BeanPropertyDefinition>emptyList());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Limited modifications by core databind functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to prune unwanted properties, during\n+     * construction of serializers and deserializers.\n+     * Use with utmost care, if at all...\n+     * \n+     * @since 2.1\n+     */\n+    public boolean removeProperty(String propName)\n+    {\n+        Iterator<BeanPropertyDefinition> it = _properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition prop = it.next();\n+            if (prop.getName().equals(propName)) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         }\n         return null;\n     }\n+\n+    @Override\n+    public Object findNamingStrategy(AnnotatedClass ac)\n+    {\n+        JsonNaming ann = ac.getAnnotation(JsonNaming.class);\n+        return (ann == null) ? null : ann.value();\n+    }\n     \n     /*\n     /**********************************************************\n         if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n             return null;\n         }\n-        return new ObjectIdInfo(info.property(), info.scope(), info.generator());\n+        return new ObjectIdInfo(info.property(), info.scope(), info.generator(),\n+                info.firstAsId());\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n     protected final String _propertyName;\n     protected final Class<? extends ObjectIdGenerator<?>> _generator;\n     protected final Class<?> _scope;\n+    protected final boolean _firstAsId;\n+\n+    /**\n+     * @deprecated Since 2.1 use the constructor that takes 4 arguments.\n+     */\n+    @Deprecated\n+    public ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen) {\n+        this(prop, scope, gen, false);\n+    }\n     \n-    public ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen)\n+    public ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n+            boolean firstAsId)\n     {\n         _propertyName = prop;\n         _generator = gen;\n         _scope = scope;\n+        _firstAsId = firstAsId;\n     }\n \n     public String getPropertyName() { return _propertyName; }\n     public Class<?> getScope() { return _scope; }\n     public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; }\n+    public boolean getFirstAsId() { return _firstAsId; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n \n import java.util.*;\n \n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.util.BeanUtil;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Helper class used for aggregating information about all possible\n \n         // Rename remaining properties\n         _renameProperties();\n+\n         // And use custom naming strategy, if applicable...\n-        PropertyNamingStrategy naming = _config.getPropertyNamingStrategy();\n+        PropertyNamingStrategy naming = _findNamingStrategy();\n         if (naming != null) {\n             _renameUsing(naming);\n         }\n         }\n         return prop;\n     }\n+\n+    private PropertyNamingStrategy _findNamingStrategy()\n+    {\n+        Object namingDef = (_annotationIntrospector == null)? null\n+                : _annotationIntrospector.findNamingStrategy(_classDef);\n+        if (namingDef == null) {\n+            return _config.getPropertyNamingStrategy();\n+        }\n+        if (namingDef instanceof PropertyNamingStrategy) {\n+            return (PropertyNamingStrategy) namingDef;\n+        }\n+        /* Alas, there's no way to force return type of \"either class\n+         * X or Y\" -- need to throw an exception after the fact\n+         */\n+        if (!(namingDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned PropertyNamingStrategy definition of type \"\n+                    +namingDef.getClass().getName()+\"; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead\");\n+        }\n+        Class<?> namingClass = (Class<?>)namingDef;\n+        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                    +namingClass.getName()+\"; expected Class<PropertyNamingStrategy>\");\n+        }\n+        HandlerInstantiator hi = _config.getHandlerInstantiator();\n+        if (hi != null) {\n+            return hi.namingStrategyInstance(_config, _classDef, namingClass);\n+        }\n+        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,\n+                    _config.canOverrideAccessModifiers());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * Method for removing field entry from this ObjectNode.\n      * Will return value of the field, if such field existed;\n      * null if not.\n+     * \n+     * @return Value of specified field, if it existed; null if not\n      */\n     public JsonNode remove(String fieldName)\n     {\n     /**\n      * Method for removing all field properties, such that this\n      * ObjectNode will contain no properties after call.\n+     * \n+     * @return This ObjectNode after removing all entries\n      */\n     @Override\n     public ObjectNode removeAll()\n     /**\n      * Method that will construct an ArrayNode and add it as a\n      * field of this ObjectNode, replacing old value, if any.\n+     *<p>\n+     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n+     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n+     * <b>newly created</b> <code>ArrayNode</code> instance.\n      *\n      * @return Newly constructed ArrayNode (NOT the old value,\n      *   which could be of any type)\n     /**\n      * Method that will construct an ObjectNode and add it as a\n      * field of this ObjectNode, replacing old value, if any.\n+     *<p>\n+     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n+     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n+     * <b>newly created</b> <code>ObjectNode</code> instance.\n      *\n      * @return Newly constructed ObjectNode (NOT the old value,\n      *   which could be of any type)\n         return n;\n     }\n \n+    /**\n+     * @return This <code>ObjectNode</code>\n+     */\n     public ObjectNode putPOJO(String fieldName, Object pojo) {\n         _put(fieldName, POJONode(pojo));\n         return this;\n     }\n \n+    /**\n+     * @return This <code>ObjectNode</code>\n+     */\n     public ObjectNode putNull(String fieldName)\n     {\n         _put(fieldName, nullNode());\n \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, int v) {\n         _put(fieldName, numberNode(v));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, Integer value) {\n         if (value == null) {\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, long v) {\n         _put(fieldName, numberNode(v));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, Long value) {\n         if (value == null) {\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, float v) {\n         _put(fieldName, numberNode(v));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, Float value) {\n         if (value == null) {\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, double v) {\n         _put(fieldName, numberNode(v));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, Double value) {\n         if (value == null) {\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, BigDecimal v) {\n         if (v == null) {\n \n     /**\n      * Method for setting value of a field to specified String value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, String v) {\n         if (v == null) {\n \n     /**\n      * Method for setting value of a field to specified String value.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, boolean v) {\n         _put(fieldName, booleanNode(v));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, Boolean value) {\n         if (value == null) {\n     \n     /**\n      * Method for setting value of a field to specified binary value\n+     * \n+     * @return This <code>ObjectNode</code>\n      */\n     public ObjectNode put(String fieldName, byte[] v) {\n         if (v == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.net.InetAddress;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n         }\n         return b.buildTypeSerializer(config, baseType, subtypes);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Additional API for other core classes\n             return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n-            @SuppressWarnings(\"unchecked\")\n-            Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n-            return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc);\n+            /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+             * Challenge here is that EnumSerializer does not know how to produce\n+             * POJO style serialization, so we must handle that special case separately;\n+             * otherwise pass it to EnumSerializer.\n+             */\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n+                // one special case: suppress serialization of \"getDeclaringClass()\"...\n+                ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n+            } else {\n+                @SuppressWarnings(\"unchecked\")\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n+                return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc, format);\n+            }\n         }\n         if (Calendar.class.isAssignableFrom(raw)) {\n             return CalendarSerializer.instance;\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n             if (clt.isTrueCollectionType()) { // only have custom ones, if any:\n-                return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, property, staticTyping,\n-                        elementTypeSerializer, elementValueSerializer);\n-            }\n-            // Only custom variants for this:\n-            for (Serializers serializers : customSerializers()) {\n-                JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n-                        (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                if (ser != null) {\n-                    return ser;\n-                }\n-            }\n-            return null;\n+                CollectionType trueCT = (CollectionType) clt;\n+                // Module-provided custom collection serializers?\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n+                            trueCT, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+\n+                // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+                // Challenge here is that EnumSerializer does not know how to produce\n+                // POJO style serialization, so we must handle that special case separately;\n+                // otherwise pass it to EnumSerializer.\n+                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+\n+                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n+                    return buildCollectionSerializer(config, trueCT, beanDesc, property, staticTyping,\n+                            elementTypeSerializer, elementValueSerializer);\n+                }\n+            } else {\n+                // Only custom variants for this:\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n+                            (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+                // fall through either way (whether shape dictates serialization as POJO or not)\n+                return null;\n+            }\n         }\n         if (type.isArrayType()) {\n             return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n         throws JsonMappingException\n     {\n-        // Module-provided custom collection serializers?\n-        for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n-                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                return ser;\n-            }\n-        }\n         Class<?> raw = type.getRawClass();\n         if (EnumSet.class.isAssignableFrom(raw)) {\n             // this may or may not be available (Class doesn't; type of field/method does)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n         // if not, bit more work:\n         oid.serializer = w.serializer;\n         oid.id = id = oid.generator.generateId(bean);\n+        // possibly. Or maybe not:\n+        if (w.firstAsId) { \n+            oid.serializer.serialize(id, jgen, provider);\n+            return;\n+        }\n         // If not, need to inject the id:\n         jgen.writeStartObject();\n         SerializedString name = w.propertyName;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                 }\n                 */\n             }\n-            return (JsonSerializer<Object>) buildContainerSerializer(prov,\n-                    type, beanDesc, property, staticTyping);\n-        }\n-\n-        // Modules may provide serializers of POJO types:\n-        for (Serializers serializers : customSerializers()) {\n-            ser = serializers.findSerializer(config, type, beanDesc);\n+            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n+            ser =  buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n             if (ser != null) {\n                 return (JsonSerializer<Object>) ser;\n+            }\n+        } else {\n+            // Modules may provide serializers of POJO types:\n+            for (Serializers serializers : customSerializers()) {\n+                ser = serializers.findSerializer(config, type, beanDesc);\n+                if (ser != null) {\n+                    return (JsonSerializer<Object>) ser;\n+                }\n             }\n         }\n         \n     {\n         // First things first: we know some types are not beans...\n         if (!isPotentialBeanType(type.getRawClass())) {\n-            return null;\n+            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n+            //   as per [Issue#24]\n+            if (!type.isEnumType()) {\n+                return null;\n+            }\n         }\n         JsonSerializer<Object> serializer = constructBeanSerializer(prov, beanDesc, property);\n         // [JACKSON-440] Need to allow overriding actual serializer, as well...\n             JavaType idType = idProp.getType();\n             gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n             // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n-            return ObjectIdWriter.construct(idType, null, gen);\n+            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getFirstAsId());\n             \n         } \n         // other types are simpler\n         // Could require type to be passed explicitly, but we should be able to find it too:\n         JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n         gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n-        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen);\n+        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n+                objectIdInfo.getFirstAsId());\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n      * Serializer used for serializing id values.\n      */\n     public final JsonSerializer<Object> serializer;\n+\n+    /**\n+     * Marker that indicates what the first reference is to be\n+     * serialized as full POJO, or as Object Id (other references\n+     * will always be serialized as Object Id)\n+     * \n+     * @since 2.1\n+     */\n+    public final boolean firstAsId;\n     \n     /*\n     /**********************************************************\n      */\n \n     @SuppressWarnings(\"unchecked\")\n-    protected ObjectIdWriter(JavaType t, SerializedString propName, ObjectIdGenerator<?> gen,\n-            JsonSerializer<?> ser)\n+    protected ObjectIdWriter(JavaType t, SerializedString propName,\n+            ObjectIdGenerator<?> gen, JsonSerializer<?> ser, boolean firstAsId)\n     {\n         idType = t;\n         propertyName = propName;\n         generator = gen;\n         serializer = (JsonSerializer<Object>) ser;\n+        this.firstAsId = firstAsId;\n     }\n \n     /**\n      * for which serializer is being built.\n      */\n     public static ObjectIdWriter construct(JavaType idType, String propName,\n-            ObjectIdGenerator<?> generator)\n+            ObjectIdGenerator<?> generator, boolean firstAsId)\n     {\n         SerializedString serName = (propName == null) ? null : new SerializedString(propName);\n-        return new ObjectIdWriter(idType, serName, generator, null);\n+        return new ObjectIdWriter(idType, serName, generator, null, firstAsId);\n     }\n \n     public ObjectIdWriter withSerializer(JsonSerializer<?> ser) {\n-        return new ObjectIdWriter(idType, propertyName, generator, ser);\n+        return new ObjectIdWriter(idType, propertyName, generator, ser, firstAsId);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n import com.fasterxml.jackson.databind.ser.*;\n \n public class PropertyBasedObjectIdGenerator\n-\textends ObjectIdGenerators.PropertyGenerator\n+    extends ObjectIdGenerators.PropertyGenerator\n {\n     protected final BeanPropertyWriter _property;\n     \n     {\n         super(scope);\n         _property = prop;\n+    }\n+\n+    /**\n+     * We must override this method, to prevent errors when scopes are the same,\n+     * but underlying class (on which to access property) is different.\n+     */\n+    @Override\n+    public boolean canUseFor(ObjectIdGenerator<?> gen) {\n+        if (gen.getClass() == getClass()) {\n+            PropertyBasedObjectIdGenerator other = (PropertyBasedObjectIdGenerator) gen;\n+            if (other.getScope() == _scope) {\n+                /* 26-Jul-2012, tatu: This is actually not enough, because the property\n+                 *   accessor within BeanPropertyWriter won't work for other property fields\n+                 *  (see [https://github.com/FasterXML/jackson-module-jaxb-annotations/issues/9]\n+                 *  for details).\n+                 *  So we need to verify that underlying property is actually the same.\n+                 */\n+                return (other._property == _property);\n+            }\n+        }\n+        return false;\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n         // if not, bit more work:\n         oid.serializer = w.serializer;\n         oid.id = id = oid.generator.generateId(bean);\n-        // If not, need to inject the id:\n+        // possibly. Or maybe not:\n+        if (w.firstAsId) { \n+            oid.serializer.serialize(id, jgen, provider);\n+            return;\n+        }\n+        \n         jgen.writeStartObject();\n         SerializedString name = w.propertyName;\n         if (name != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                     }\n                     idType = idProp.getType();\n                     gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n-                    oiw = ObjectIdWriter.construct(idType, null, gen);\n+                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getFirstAsId());\n                 } else { // other types need to be simpler\n                     gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n-                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen);\n+                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n+                            objectIdInfo.getFirstAsId());\n                 }\n             }\n         }\n              *   have many stack frames to spare... just one or two; can't\n              *   make many calls.\n              */\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n         return (value == null) ? false : value.booleanValue();\n     }\n     \n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import java.util.HashSet;\n import java.util.Set;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n /**\n @JacksonStdImpl\n public class EnumSerializer\n     extends StdScalarSerializer<Enum<?>>\n+    implements ContextualSerializer\n {\n     /**\n      * This map contains pre-resolved values (since there are ways\n      */\n     protected final EnumValues _values;\n \n+    /**\n+     * Flag that is set if we statically know serialization choice\n+     * between index and textual format (null if it needs to be dynamically\n+     * checked).\n+     * \n+     * @since 2.1\n+     */\n+    protected final Boolean _serializeAsIndex;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 2.1\n+     */\n+    @Deprecated\n     public EnumSerializer(EnumValues v) {\n+        this(v, null);\n+    }\n+\n+    public EnumSerializer(EnumValues v, Boolean serializeAsIndex)\n+    {\n         super(Enum.class, false);\n         _values = v;\n-    }\n-\n+        _serializeAsIndex = serializeAsIndex;\n+    }\n+    \n+    /**\n+     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}\n+     * for constructing serializer instance of Enum types.\n+     * \n+     * @since 2.1\n+     */\n     public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n-            BeanDescription beanDesc)\n+            BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n             ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n-        return new EnumSerializer(v);\n-    }\n+        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n+        return new EnumSerializer(v, serializeAsIndex);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.1 use the variant that takes in <code>format</code> argument.\n+     */\n+    @Deprecated\n+    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+            BeanDescription beanDesc)\n+    {\n+        return construct(enumClass, config, beanDesc, beanDesc.findExpectedFormat(null));\n+    }\n+\n+    /**\n+     * To support some level of per-property configuration, we will need\n+     * to make things contextual. We are limited to \"textual vs index\"\n+     * choice here, however.\n+     */\n+    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        if (property != null) {\n+            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n+            if (format != null) {\n+                Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false);\n+                if (serializeAsIndex != _serializeAsIndex) {\n+                    return new EnumSerializer(_values, serializeAsIndex);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API for Jackson databind core\n+    /**********************************************************\n+     */\n+    \n+    public EnumValues getEnumValues() { return _values; }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(provider)) {\n             jgen.writeNumber(en.ordinal());\n             return;\n         }\n     \t}\n     }\n \n-    public EnumValues getEnumValues() { return _values; }\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final boolean _serializeAsIndex(SerializerProvider provider)\n+    {\n+        if (_serializeAsIndex != null) {\n+            return _serializeAsIndex.booleanValue();\n+        }\n+        return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n+        \n+    }\n+\n+    /**\n+     * Helper method called to check whether \n+     */\n+    protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass,\n+            JsonFormat.Value format, boolean fromClass)\n+    {\n+        JsonFormat.Shape shape = (format == null) ? null : format.getShape();\n+        if (shape == null) {\n+            return null;\n+        }\n+        if (shape == Shape.ANY || shape == Shape.SCALAR) { // i.e. \"default\", check dynamically\n+            return null;\n+        }\n+        if (shape == Shape.STRING) {\n+            return Boolean.FALSE;\n+        }\n+        if (shape.isNumeric()) {\n+            return Boolean.TRUE;\n+        }\n+        throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n+                    +\", not supported as \"\n+                    + (fromClass? \"class\" : \"property\")\n+                    +\" annotation\");\n+    }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n         AnnotatedClass ac = beanDesc.getClassInfo();\n         String nameStr = intr.findRootName(ac);\n         // No answer so far? Let's just default to using simple class name\n-        if (nameStr == null) {\n+        if (nameStr == null || nameStr.length() == 0) {\n             // Should we strip out enclosing class tho? For now, nope:\n             nameStr = rootType.getSimpleName();\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonNaming;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n \n /**\n- * Unit tests to verify functioning of {@link PropertyNamingStrategy} which\n- * was added in Jackson 1.8, as per [JACKSON-178].\n+ * Unit tests to verify functioning of {@link PropertyNamingStrategy}.\n  */\n public class TestNamingStrategy extends BaseMapTest\n {\n         // intentionally odd name, to be renamed by naming strategy\n         public List<String> getTheVALUEs() { return THEvalues; }\n     }\n+\n+    // [Issue#45]: Support @JsonNaming\n+    @JsonNaming(PrefixStrategy.class)\n+    static class BeanWithPrefixNames\n+    {\n+        protected int a = 3;\n+        \n+        public int getA() { return a; }\n+        public void setA(int value) { a = value; }\n+    }\n     \n     /*\n     /**********************************************************************\n         assertEquals(1, foo.getTheVALUEs().size());\n         assertEquals(\"a\", foo.getTheVALUEs().get(0));\n     }\n+\n+    // @JsonNaming / [Issue#45]\n+    public void testPerClassAnnotation() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new LcStrategy());\n+        BeanWithPrefixNames input = new BeanWithPrefixNames();\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"Get-a\\\":3}\", json);\n+\n+        BeanWithPrefixNames output = mapper.readValue(\"{\\\"Set-a\\\":7}\",\n+                BeanWithPrefixNames.class);\n+        assertEquals(7, output.a);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n         \n         public void setX(int v) { value = v; }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    final static ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testProps()\n     {\n \n     public void testSupport()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.canSerialize(String.class));\n-\n-        assertTrue(m.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n+        assertTrue(MAPPER.canSerialize(String.class));\n+        assertTrue(MAPPER.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n     }\n \n     public void testTreeRead() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         String JSON = \"{ }\";\n-        JsonNode n = m.readTree(JSON);\n+        JsonNode n = MAPPER.readTree(JSON);\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new StringReader(JSON));\n+        n = MAPPER.readTree(new StringReader(JSON));\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n         assertTrue(n instanceof ObjectNode);\n     }\n \n     public void testJsonFactoryLinkage()\n     {\n         // first, implicit factory, giving implicit linkage\n-        ObjectMapper m = new ObjectMapper();\n-        assertSame(m, m.getJsonFactory().getCodec());\n+        assertSame(MAPPER, MAPPER.getJsonFactory().getCodec());\n \n         // and then explicit factory, which should also be implicitly linked\n         JsonFactory f = new JsonFactory();\n-        m = new ObjectMapper(f);\n+        ObjectMapper m = new ObjectMapper(f);\n         assertSame(f, m.getJsonFactory());\n         assertSame(m, f.getCodec());\n     }\n      */\n     public void testProviderConfig() throws Exception   \n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        ObjectMapper m = new ObjectMapper();\n+\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = mapper.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n         assertNotNull(bean);\n-        assertEquals(1, mapper._deserializationContext._cache.cachedDeserializersCount());\n-        mapper._deserializationContext._cache.flushCachedDeserializers();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n+        m._deserializationContext._cache.flushCachedDeserializers();\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+    }\n+    \n+    // [Issue#28]: ObjectMapper.copy()\n+    public void testCopy() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // // First: verify that handling of features is decoupled:\n+        \n+        ObjectMapper m2 = m.copy();\n+        assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        // but should NOT change the original\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // nor vice versa:\n+        assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+\n+        // // Also, underlying JsonFactory instances should be distinct\n+        \n+        assertNotSame(m.getJsonFactory(), m2.getJsonFactory());\n+\n+        // ... anything else? (probably should do more tests, add as needed)\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n         public int a = 3;\n     }\n     \n+    @JsonRootName(\"\")\n+    static class RootBeanWithEmpty {\n+        public int a = 2;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", json);\n         Bean bean = mapper.readValue(json, Bean.class);\n         assertNotNull(bean);\n+\n+        // also same with explicitly \"not defined\"...\n+        json = mapper.writeValueAsString(new RootBeanWithEmpty());\n+        assertEquals(\"{\\\"RootBeanWithEmpty\\\":{\\\"a\\\":2}}\", json);\n+        RootBeanWithEmpty bean2 = mapper.readValue(json, RootBeanWithEmpty.class);\n+        assertNotNull(bean2);\n+        assertEquals(2, bean2.a);\n     }\n \n     public void testRootViaWriterAndReader() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n     \t}\n     }\n \n-\t// // 3-property value, with more varied builder\n+    // // 3-property value, with more varied builder\n \t\n-\t@JsonDeserialize(builder=BuildABC.class)\n-\tstatic class ValueClassABC\n-\t{\n-\t\tfinal int a, b, c;\n-\n-\t\tprotected ValueClassABC(int a, int b, int c) {\n-\t\t\tthis.a = a;\n-\t\t\tthis.b = b;\n-\t\t\tthis.c = c;\n-\t\t}\n-\t}\n+    @JsonDeserialize(builder=BuildABC.class)\n+    static class ValueClassABC\n+    {\n+        final int a, b, c;\n+\n+        protected ValueClassABC(int a, int b, int c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n \n     static class BuildABC\n     {\n     \n     // And then with custom naming:\n \n-\t@JsonDeserialize(builder=BuildFoo.class)\n-\tstatic class ValueFoo\n-\t{\n-\t\tfinal int value;\n-\t\tprotected ValueFoo(int v) { value = v; }\n-\t}\n-\n-\t@JsonPOJOBuilder(withPrefix=\"foo\", buildMethodName=\"construct\")\n+    @JsonDeserialize(builder=BuildFoo.class)\n+    static class ValueFoo\n+    {\n+        final int value;\n+        protected ValueFoo(int v) { value = v; }\n+    }\n+\n+    @JsonPOJOBuilder(withPrefix=\"foo\", buildMethodName=\"construct\")\n     static class BuildFoo {\n         private int value;\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n     }\n     \n     @JsonFilter(\"filteredBean\")\n-    private static class FilteredBean {\n+    protected static class FilteredBean {\n     \t\n     \t@JsonProperty\n     \tprivate String secret = \"secret\";\n     }\n     \n     public static FilterProvider secretFilterProvider = new SimpleFilterProvider()\n-    .addFilter(\"filteredBean\", SimpleBeanPropertyFilter.filterOutAllExcept(new String[]{\"obvious\"}));\n-    /** */\n+        .addFilter(\"filteredBean\", SimpleBeanPropertyFilter.filterOutAllExcept(new String[]{\"obvious\"}));\n+\n     public void testGeneratingJsonSchemaWithFilters() throws Exception {\n     \tObjectMapper mapper = new ObjectMapper();\n     \tmapper.setFilters(secretFilterProvider);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestKeyDeserializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestKeyDeserializers extends BaseMapTest\n+{\n+    static class FooKeyDeserializer extends KeyDeserializer\n+    {\n+        @Override\n+        public Foo deserializeKey(String key, DeserializationContext ctxt)\n+        {\n+            return new Foo(key);\n+        }\n+    }\n+    \n+    static class Foo {\n+        public String value;\n+        \n+        public Foo(String v) { value = v; }\n+    }\n+    \n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testKeyDeserializers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        mod.addKeyDeserializer(Foo.class, new FooKeyDeserializer());\n+        mapper.registerModule(mod);\n+        Map<Foo,Integer> map = mapper.readValue(\"{\\\"a\\\":3}\",\n+                new TypeReference<Map<Foo,Integer>>() {} );\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        Foo foo = map.keySet().iterator().next();\n+        assertEquals(\"a\", foo.value);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n         public String[] empty = new String[0];\n     }\n \n-    // [JACKSIN-689]\n+    // [JACKSON-689]\n     static class BeanWithIterable {\n         private final ArrayList<String> values = new ArrayList<String>();\n         {\n \n         public Iterable<String> getValues() { return values; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.io.StringWriter;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n         private int getY() { return 2; }\n     }\n \n+    static class Indentable {\n+        public int a = 3;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Main tests\n     /**********************************************************\n      */\n \n+    final static ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testDefaults()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SerializationConfig cfg = m.getSerializationConfig();\n+        SerializationConfig cfg = MAPPER.getSerializationConfig();\n \n         // First, defaults:\n         assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n \n     public void testOverrideIntrospectors()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SerializationConfig cfg = m.getSerializationConfig();\n+        SerializationConfig cfg = MAPPER.getSerializationConfig();\n         // and finally, ensure we could override introspectors\n         cfg = cfg.with((ClassIntrospector) null); // no way to verify tho\n         cfg = cfg.with((AnnotationIntrospector) null);\n \n     public void testIndentation() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationFeature.INDENT_OUTPUT, true);\n         Map<String,Integer> map = new HashMap<String,Integer>();\n         map.put(\"a\", Integer.valueOf(2));\n-        String result = serializeAsString(m, map).trim();\n+        String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT)\n+                .writeValueAsString(map);\n         // 02-Jun-2009, tatu: not really a clean way but...\n-        String lf = System.getProperty(\"line.separator\");\n+        String lf = getLF();\n         assertEquals(\"{\"+lf+\"  \\\"a\\\" : 2\"+lf+\"}\", result);\n     }\n \n     public void testAnnotationsDisabled() throws Exception\n     {\n         // first: verify that annotation introspection is enabled by default\n-        ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperFeature.USE_ANNOTATIONS));\n-        Map<String,Object> result = writeAndMap(m, new AnnoBean());\n+        assertTrue(MAPPER.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        Map<String,Object> result = writeAndMap(MAPPER, new AnnoBean());\n         assertEquals(2, result.size());\n \n-        m = new ObjectMapper();\n-        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n-        result = writeAndMap(m, new AnnoBean());\n+        ObjectMapper m2 = new ObjectMapper();\n+        m2.configure(MapperFeature.USE_ANNOTATIONS, false);\n+        result = writeAndMap(m2, new AnnoBean());\n         assertEquals(1, result.size());\n     }\n \n         assertEquals(0, prov.cachedSerializersCount());\n     }\n \n+    // Test for [Issue#12]\n+    public void testIndentWithPassedGenerator() throws Exception\n+    {\n+        Indentable input = new Indentable();\n+        assertEquals(\"{\\\"a\\\":3}\", MAPPER.writeValueAsString(input));\n+        String LF = getLF();\n+        String INDENTED = \"{\"+LF+\"  \\\"a\\\" : 3\"+LF+\"}\";\n+        final ObjectWriter indentWriter = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT);\n+        assertEquals(INDENTED, indentWriter.writeValueAsString(input));\n+\n+        // [Issue#12]\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = MAPPER.getJsonFactory().createGenerator(sw);\n+        indentWriter.writeValue(jgen, input);\n+        jgen.close();\n+        assertEquals(INDENTED, sw.toString());\n+\n+        // and also with ObjectMapper itself\n+        sw = new StringWriter();\n+        ObjectMapper m2 = new ObjectMapper();\n+        m2.enable(SerializationFeature.INDENT_OUTPUT);\n+        jgen = m2.getJsonFactory().createGenerator(sw);\n+        m2.writeValue(jgen, input);\n+        jgen.close();\n+        assertEquals(INDENTED, sw.toString());\n+    }\n+\n+    private final static String getLF() {\n+        return System.getProperty(\"line.separator\");\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n \n         OK(String key) { this.key = key; }\n     }\n     \n+    // Types for [https://github.com/FasterXML/jackson-databind/issues/24]\n+    // (Enums as JSON Objects)\n+\n+    @JsonFormat(shape=JsonFormat.Shape.OBJECT)\n+    static enum PoNUM {\n+        A(\"a1\"), B(\"b2\");\n+\n+        @JsonProperty\n+        protected final String value;\n+        \n+        private PoNUM(String v) { value = v; }\n+\n+        public String getValue() { return value; }\n+    }\n+\n+    static class PoNUMContainer {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public OK text = OK.V1;\n+    }\n+    \n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n+    static enum BrokenPoNum\n+    {\n+        A, B;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Tests\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(OK.V1));\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(NOT_OK.V1));\n         assertEquals(quote(\"V2\"), mapper.writeValueAsString(NOT_OK2.V2));\n+    }\n+\n+    // Tests for [issue#24]\n+\n+    public void testEnumAsObjectValid() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"a1\\\"}\", mapper.writeValueAsString(PoNUM.A));\n+    }\n+\n+    public void testEnumAsIndexViaAnnotations() throws Exception {\n+        assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n+    }\n+    \n+    public void testEnumAsObjectBroken() throws Exception\n+    {\n+        try {\n+            String json = mapper.writeValueAsString(BrokenPoNum.A);\n+            fail(\"Should not have succeeded, produced: \"+json);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unsupported serialization shape\");\n+        }\n     }\n }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestFormatForCollections.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestFormatForCollections extends BaseMapTest\n+{\n+    // [issue#40]: Allow serialization 'as POJO' (resulting in JSON Object) \n+    @JsonPropertyOrder({ \"size\", \"value\" })\n+    @JsonFormat(shape=Shape.OBJECT)\n+    @JsonIgnoreProperties({ \"empty\" }) // from 'isEmpty()'\n+    static class CollectionAsPOJO\n+        extends ArrayList<String>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        @JsonProperty(\"size\")\n+        public int foo() { return size(); }\n+        \n+        public List<String> getValues() {\n+            return new ArrayList<String>(this);\n+        }\n+\n+        public void setValues(List<String> v) {\n+            addAll(v);\n+        }\n+        \n+        // bogus setter to handle \"size\" property\n+        public void setSize(int i) { }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();    \n+\n+\n+    // [Issue#40]\n+    public void testListAsObject() throws Exception\n+    {\n+        // First, serialize a \"POJO-List\"\n+        CollectionAsPOJO list = new CollectionAsPOJO();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        String json = MAPPER.writeValueAsString(list);\n+        assertEquals(\"{\\\"size\\\":2,\\\"values\\\":[\\\"a\\\",\\\"b\\\"]}\", json);\n+\n+        // and then bring it back!\n+        CollectionAsPOJO result = MAPPER.readValue(json, CollectionAsPOJO.class);\n+        assertEquals(2, result.size());\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdSerialization.java\n package com.fasterxml.jackson.databind.struct;\n \n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n \n import com.fasterxml.jackson.databind.*;\n         }\n     }\n \n+    // For [https://github.com/FasterXML/jackson-annotations/issues/4]\n+    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class,\n+            property=\"id\", firstAsId=true)\n+    static class AlwaysAsId\n+    {\n+        public int value;\n+        \n+        public AlwaysAsId() { this(0); }\n+        public AlwaysAsId(int v) {\n+            value = v;\n+        }\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class AlwaysContainer\n+    {\n+        public AlwaysAsId a = new AlwaysAsId(13);\n+        \n+        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class,\n+                property=\"id\", firstAsId=true)\n+        public Value b = new Value();\n+    }\n+\n+    static class Value {\n+        public int x = 3;\n+    }\n+    \n     // // Let's also have one 'broken' test\n \n     // no \"id\" property\n \n     private final static String EXP_SIMPLE_INT_CLASS = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n     \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     public void testSimpleSerializationClass() throws Exception\n     {\n         src.next = src;\n         \n         // First, serialize:\n-        String json = mapper.writeValueAsString(src);\n+        String json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_SIMPLE_INT_CLASS, json);\n \n         // and ensure that state is cleared in-between as well:\n-        json = mapper.writeValueAsString(src);\n+        json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_SIMPLE_INT_CLASS, json);\n     }\n     \n         src.node.next = src;\n         \n         // First, serialize:\n-        String json = mapper.writeValueAsString(src);\n+        String json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_SIMPLE_INT_PROP, json);\n         // and second time too, for a good measure\n-        json = mapper.writeValueAsString(src);\n+        json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_SIMPLE_INT_PROP, json);\n     }\n \n         src.next = src;\n         \n         // First, serialize:\n-        String json = mapper.writeValueAsString(src);\n+        String json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_CUSTOM_PROP, json);\n \n         // and ensure that state is cleared in-between as well:\n-        json = mapper.writeValueAsString(src);\n+        json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_CUSTOM_PROP, json);\n     }\n \n         src.node.next = src;\n         \n         // First, serialize:\n-        String json = mapper.writeValueAsString(src);\n+        String json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_CUSTOM_PROP_VIA_REF, json);\n         // and second time too, for a good measure\n-        json = mapper.writeValueAsString(src);\n+        json = MAPPER.writeValueAsString(src);\n         assertEquals(EXP_CUSTOM_PROP_VIA_REF, json);\n     }\n \n+    public void testAlwaysAsId() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new AlwaysContainer());\n+        assertEquals(json, \"{\\\"a\\\":1,\\\"b\\\":2}\");\n+    }\n+    \n     /*\n     /*****************************************************\n     /* Unit tests, error handling\n     public void testInvalidProp() throws Exception\n     {\n         try {\n-            mapper.writeValueAsString(new Broken());\n+            MAPPER.writeValueAsString(new Broken());\n             fail(\"Should have thrown an exception\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"can not find property with name 'id'\");\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Unit tests for \"POJO as array\" feature using Builder-style\n+ * POJO construction.\n+ */\n+public class TestPOJOAsArrayWithBuilder extends BaseMapTest\n+{\n+    @JsonDeserialize(builder=SimpleBuilderXY.class)\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class ValueClassXY\n+    {\n+        final int _x, _y;\n+\n+        protected ValueClassXY(int x, int y) {\n+            _x = x+1;\n+            _y = y+1;\n+        }\n+    }\n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    static class SimpleBuilderXY\n+    {\n+        public int x, y;\n+        \n+        public SimpleBuilderXY withX(int x) {\n+            this.x = x;\n+            return this;\n+        }\n+\n+        public SimpleBuilderXY withY(int y) {\n+            this.y = y;\n+            return this;\n+        }\n+\n+        public ValueClassXY build() {\n+            return new ValueClassXY(x, y);\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Basic tests\n+    /*****************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testSimpleBuilder() throws Exception\n+    {\n+        // Ok, first, ensure that serializer will \"black out\" filtered properties\n+        ValueClassXY value = MAPPER.readValue(\"[1,2]\", ValueClassXY.class);\n+        assertEquals(2, value._x);\n+        assertEquals(3, value._y);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.introspect.*;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n      * pass specific schema object to {@link JsonParser} used for\n      * reading content.\n      * \n-     * @param schema Schema to pass to parser\n+     * @param schema JsonSchema to pass to parser\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         return new ObjectReader(this, getDeserializationConfig(), null, null,\n \n     /*\n     /**********************************************************\n-    /* Extended Public API: JSON Schema generation\n+    /* Extended Public API: JSON JsonSchema generation\n     /**********************************************************\n      */\n \n      * instance for specified class.\n      *\n      * @param t The class to generate schema for\n-     * @return Constructed JSON schema.\n-     */\n-    public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n-        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n+     */\n+    public void acceptJsonFormatVisitor(Class<?> t, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n+    \tif (t == null) {\n+    \t\tthrow new IllegalArgumentException(\"class must be provided\");\n+    \t}\n+    \t\n+    \tif (visitor == null) {\n+    \t\treturn;\n+    \t}\n+    \tDefaultSerializerProvider provider = _serializerProvider(getSerializationConfig());\n+        visitor.setProvider(provider);\n+    \tprovider.acceptJsonFormatVisitor(t, visitor);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n package com.fasterxml.jackson.databind.ext;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n             CalendarSerializer.instance.serialize(value.toGregorianCalendar(), jgen, provider);\n         }\n \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n-            return CalendarSerializer.instance.getSchema(provider, typeHint);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {\n+            CalendarSerializer.instance.acceptJsonFormatVisitor(visitor, null);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n package com.fasterxml.jackson.databind.ext;\n \n import java.io.IOException;\n+\n import org.w3c.dom.Node;\n import  org.w3c.dom.bootstrap.DOMImplementationRegistry;\n import  org.w3c.dom.ls.DOMImplementationLS;\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n public class DOMSerializer\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        // Well... it is serialized as String\n-        return createSchemaNode(\"string\", true);\n+        visitor.expectAnyFormat(typeHint);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonAnyFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+public interface JsonAnyFormatVisitor {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+\n+public interface JsonArrayFormatVisitor extends JsonFormatVisitorWithSerializerProvider {\n+\n+\tvoid itemsFormat(JavaType contentType);\n+\n+\tvoid itemsFormat(SchemaType format);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonBooleanFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+public interface JsonBooleanFormatVisitor extends JsonValueFormatVisitor {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorAware.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * Marker interface for schema-aware serializers.\n+ */\n+public interface JsonFormatVisitorAware\n+{\n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     * @param typeHint TODO\n+     *\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWithSerializerProvider.java\n+/**\n+ * \n+ */\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+/**\n+ * @author jphelan\n+ *\n+ */\n+public interface JsonFormatVisitorWithSerializerProvider {\n+\n+\tpublic SerializerProvider getProvider();\n+\tpublic abstract void setProvider(SerializerProvider provider);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+public interface JsonFormatVisitorWrapper extends JsonFormatVisitorWithSerializerProvider{\n+\n+\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType);\n+\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType);\n+\tpublic JsonStringFormatVisitor expectStringFormat(JavaType convertedType);\n+\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType);\n+\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType);\n+\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType);\n+\tpublic JsonNullFormatVisitor expectNullFormat(JavaType convertedType);\n+\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType);\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonIntegerFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+public interface JsonIntegerFormatVisitor extends JsonValueFormatVisitor {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonNullFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+public interface JsonNullFormatVisitor {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonNumberFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+\n+public interface JsonNumberFormatVisitor extends JsonValueFormatVisitor{\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonObjectFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+\n+public interface JsonObjectFormatVisitor extends JsonFormatVisitorWithSerializerProvider {\n+\n+\tpublic void property(BeanPropertyWriter writer);\n+\n+\tpublic void optionalProperty(BeanPropertyWriter writer);\n+\n+\tpublic void property(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint);\n+\n+\tpublic void optionalProperty(String name, JsonFormatVisitorAware handler,\n+\t\t\tJavaType propertyTypeHint);\n+\n+\tpublic void property(String name);\n+\t\n+\tpublic void optionalProperty(String name);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonStringFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+public interface JsonStringFormatVisitor extends JsonValueFormatVisitor {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormatVisitor.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n+\n+public interface JsonValueFormatVisitor {\n+\n+\tvoid format(JsonValueFormat format);\n+\n+\tvoid enumTypes(Set<String> enums);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/AnySchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonAnyFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.AnySchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+\n+public class AnySchemaFactory extends SchemaFactory implements\n+\t\tJsonAnyFormatVisitor {\n+\n+\tprotected SchemaFactory parent;\n+\tprotected AnySchema anySchema;\n+\t\n+\tpublic AnySchemaFactory(SchemaFactory parent) {\n+\t\tthis.parent = parent;\n+\t\tsetProvider(parent.getProvider());\n+\t\tanySchema = new AnySchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic AnySchemaFactory(SerializerProvider provider) {\n+\t\tparent = null;\n+\t\tsetProvider(provider);\n+\t\tanySchema = new AnySchema();\n+\t}\n+\n+\tpublic JsonSchema getSchema() {\n+\t\treturn anySchema;\n+\t}\n+\t\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ArraySchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonschema.types.ArraySchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+\n+public class ArraySchemaFactory extends SchemaFactory \n+\timplements JsonArrayFormatVisitor {\n+\n+\tprotected SchemaFactory parent; \n+\tprotected ArraySchema arraySchema;\n+\tprotected BeanProperty _property;\n+\t\n+\tpublic ArraySchemaFactory(SchemaFactory parent, BeanProperty property) {\n+\t\tthis.parent = parent;\n+\t\tsetProvider(parent.getProvider());\n+\t\tarraySchema = new ArraySchema();\n+\t}\n+\n+\tpublic ArraySchemaFactory(SchemaFactory schemaFactory) {\n+\t\tthis(schemaFactory, null);\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic ArraySchemaFactory(SerializerProvider provider) {\n+\t\tparent = null;\n+\t\tsetProvider(provider);\n+\t\tarraySchema = new ArraySchema();\n+\t}\n+\n+\tpublic void itemsFormat(JavaType contentType) {\n+\t\t// An array of object matches any values, thus we leave the schema empty.\n+        if (contentType.getRawClass() != Object.class) {\n+        \t\n+            JsonSerializer<Object> ser;\n+\t\t\ttry {\n+\t\t\t\tser = getProvider().findValueSerializer(contentType, _property);\n+\t\t\t\tif (ser instanceof JsonFormatVisitorAware) {\n+\t            \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+\t            \tvisitor.setProvider(provider);\n+\t                ((JsonFormatVisitorAware) ser).acceptJsonFormatVisitor(visitor, contentType);\n+\t                arraySchema.setItemsSchema(visitor.finalSchema());\n+\t            }\n+\t\t\t} catch (JsonMappingException e) {\n+\t\t\t\t//TODO: log error\n+\t\t\t}   \n+        }\n+\t}\n+\t\n+\tpublic void itemsFormat(SchemaType format) {\n+\t\tarraySchema.setItemsSchema(JsonSchema.minimalForFormat(format));\n+\t}\n+\n+\tpublic JsonSchema getSchema() {\n+\t\treturn arraySchema;\n+\t}\n+\t\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/BooleanSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonBooleanFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.BooleanSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n+\n+public class BooleanSchemaFactory extends ValueTypeSchemaFactory implements\n+\tJsonBooleanFormatVisitor {\n+\n+\tprotected BooleanSchema booleanSchema;\n+\t\n+\tpublic BooleanSchemaFactory(SchemaFactory parent) {\n+\t\tsuper(parent);\n+\t\tbooleanSchema = new BooleanSchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic BooleanSchemaFactory(SerializerProvider provider) {\n+\t\tsuper(provider);\n+\t\tbooleanSchema = new BooleanSchema();\n+\t}\n+\n+\tpublic ValueTypeSchema getValueSchema() {\n+\t\treturn booleanSchema;\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/IntegerSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.IntegerSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n+\n+public class IntegerSchemaFactory extends ValueTypeSchemaFactory implements\n+\t\tJsonIntegerFormatVisitor {\n+\n+\tprotected IntegerSchema integerSchema;\n+\t\n+\tpublic IntegerSchemaFactory(SchemaFactory parent) {\n+\t\tsuper(parent);\n+\t\tintegerSchema = new IntegerSchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic IntegerSchemaFactory(SerializerProvider provider) {\n+\t\tsuper(provider);\n+\t\tintegerSchema = new IntegerSchema();\n+\t}\n+\n+\tpublic ValueTypeSchema getValueSchema() {\n+\t\treturn integerSchema;\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NullSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNullFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.NullSchema;\n+\n+public class NullSchemaFactory extends SchemaFactory implements\n+\t\tJsonNullFormatVisitor {\n+\n+\tprotected SchemaFactory parent;\n+\tprotected NullSchema nullSchema;\n+\t\n+\tpublic NullSchemaFactory(SchemaFactory parent) {\n+\t\tthis.parent = parent;\n+\t\tsetProvider(parent.getProvider());\n+\t\tnullSchema = new NullSchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic NullSchemaFactory(SerializerProvider provider) {\n+\t\tparent = null;\n+\t\tsetProvider(provider);\n+\t\tnullSchema = new NullSchema();\n+\t}\n+\n+\tpublic JsonSchema getSchema() {\n+\t\treturn nullSchema;\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NumberSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.NumberSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n+\n+public class NumberSchemaFactory extends ValueTypeSchemaFactory implements\n+\t\tJsonNumberFormatVisitor {\n+\n+\tprotected NumberSchema numberSchema;\n+\t\n+\tpublic NumberSchemaFactory(SchemaFactory parent) {\n+\t\tsuper(parent);\n+\t\tthis.parent = parent;\n+\t\tnumberSchema = new NumberSchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic NumberSchemaFactory(SerializerProvider provider) {\n+\t\tsuper(provider);\n+\t\tnumberSchema = new NumberSchema();\n+\t}\n+\n+\t@Override\n+\tprotected ValueTypeSchema getValueSchema() {\n+\t\treturn numberSchema;\n+\t}\n+\t\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ObjectSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+\n+public class ObjectSchemaFactory extends SchemaFactory \n+\timplements JsonObjectFormatVisitor {\n+\n+\tprotected SchemaFactory parent;\n+\tprotected ObjectSchema objectSchema;\n+\t\n+\tpublic ObjectSchemaFactory(SchemaFactory parent) {\n+\t\tthis.parent = parent;\n+\t\tsetProvider(parent.getProvider());\n+\t\tobjectSchema = new ObjectSchema();\n+\t}\n+\t\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic ObjectSchemaFactory(SerializerProvider provider) {\n+\t\tparent = null;\n+\t\tsetProvider(provider);\n+\t\tobjectSchema = new ObjectSchema();\n+\t}\n+\n+\tpublic JsonSchema getSchema() {\n+\t\treturn objectSchema;\n+\t}\n+\n+\tprivate JsonSerializer<Object> getSer(BeanPropertyWriter writer) {\n+\t\tJsonSerializer<Object> ser = writer.getSerializer();\n+\t\tif (ser == null) {\n+\t\t\tClass<?>\tserType = writer.getPropertyType();\n+\t\t\ttry {\n+\t\t\t\treturn getProvider().findValueSerializer(serType, writer);\n+\t\t\t} catch (JsonMappingException e) {\n+\t\t\t\t// TODO: log error\n+\t\t\t}\n+\t\t}\n+\t\treturn ser;\n+\t}\t\n+\t\n+\tprotected JsonSchema propertySchema(BeanPropertyWriter writer) {\n+\t\tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+\t\tvisitor.setProvider(provider);\n+\t\tJsonSerializer<Object> ser = getSer(writer);\n+\t\tif (ser != null && ser instanceof JsonFormatVisitorAware) {\n+\t\t\t((JsonFormatVisitorAware)ser).acceptJsonFormatVisitor(visitor, writer.getType());\n+\t\t} else {\n+\t\t\tvisitor.expectAnyFormat(writer.getType());\n+\t\t}\n+\t\treturn visitor.finalSchema();\n+\t}\n+\t\n+\tprotected JsonSchema propertySchema(JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n+\t\tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+\t\tvisitor.setProvider(provider);\n+\t\thandler.acceptJsonFormatVisitor(visitor, propertyTypeHint);\n+\t\treturn visitor.finalSchema();\n+\t}\n+\t\n+\tpublic void property(BeanPropertyWriter writer) {\n+\t\tobjectSchema.putProperty(writer.getName(), propertySchema(writer));\n+\t}\n+\n+\tpublic void optionalProperty(BeanPropertyWriter writer) {\n+\t\tobjectSchema.putOptionalProperty(writer.getName(), propertySchema(writer));\n+\t}\n+\t\n+\tpublic void property(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n+\t\tobjectSchema.putProperty(name, propertySchema(handler, propertyTypeHint));\n+\t}\n+\t\n+\tpublic void optionalProperty(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n+\t\tobjectSchema.putOptionalProperty(name, propertySchema(handler, propertyTypeHint));\n+\t}\n+\t\n+\tpublic void property(String name) {\n+\t\tobjectSchema.putProperty(name, JsonSchema.minimalForFormat(SchemaType.ANY));\n+\t}\n+\t\n+\tpublic void optionalProperty(String name) {\n+\t\tobjectSchema.putOptionalProperty(name, JsonSchema.minimalForFormat(SchemaType.ANY));\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+\n+public abstract class SchemaFactory {\n+\n+\t\n+\tprotected SerializerProvider provider;\n+\t\n+\n+\t/**\n+\t * {@link SchemaFactory#provider}\n+\t * @param provider the provider to set\n+\t */\n+\tpublic void setProvider(SerializerProvider provider) {\n+\t\tthis.provider = provider;\n+\t}\n+\t\n+\tpublic SerializerProvider getProvider() {\n+\t\treturn provider;\n+\t}\n+\n+\tpublic abstract JsonSchema getSchema();\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactoryProvider.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonAnyFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonBooleanFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNullFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.factories.*;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+\n+/**\n+ * @author jphelan\n+ *\n+ */\n+public class SchemaFactoryProvider implements JsonFormatVisitorWrapper{\n+\n+\tprotected SerializerProvider provider;\n+\tprivate SchemaFactory delegate;\n+\t\n+\t/**\n+\t * {@link SchemaFactory#provider}\n+\t * @param provider the provider to set\n+\t */\n+\tpublic void setProvider(SerializerProvider provider) {\n+\t\tthis.provider = provider;\n+\t}\n+\t\n+\tpublic SerializerProvider getProvider() {\n+\t\treturn provider;\n+\t}\n+\t\n+\t\n+\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType) {\n+\t\tdelegate = new AnySchemaFactory(provider);\n+\t\treturn (JsonAnyFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType) {\n+\t\tdelegate = new ArraySchemaFactory(provider);\n+\t\treturn (JsonArrayFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType) {\n+\t\tdelegate = new BooleanSchemaFactory(provider);\n+\t\treturn (JsonBooleanFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonSchema finalSchema() {\n+\t\tassert delegate != null : \"SchemaFactory must envoke a delegate method before it can return a JsonSchema.\";\n+\t\tif (delegate == null) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\treturn delegate.getSchema();\n+\t\t}\n+\n+\t}\n+\t\n+\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType) {\n+\t\tdelegate = new IntegerSchemaFactory(provider);\n+\t\treturn (JsonIntegerFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonNullFormatVisitor expectNullFormat(JavaType convertedType) {\n+\t\tdelegate = new NullSchemaFactory(provider);\n+\t\treturn (JsonNullFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType) {\n+\t\tdelegate = new NumberSchemaFactory(provider);\n+\t\treturn (JsonNumberFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType) {\n+\t\tdelegate = new ObjectSchemaFactory(provider);\n+\t\treturn (JsonObjectFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonStringFormatVisitor expectStringFormat(JavaType convertedType) {\n+\t\tdelegate = new StringSchemaFactory(provider);\n+\t\treturn (JsonStringFormatVisitor) delegate;\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/StringSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.StringSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n+\n+public class StringSchemaFactory extends ValueTypeSchemaFactory \n+\timplements JsonStringFormatVisitor{\n+\n+\tprotected StringSchema stringSchema;\n+\t\n+\tpublic StringSchemaFactory(SchemaFactory parent) {\n+\t\tsuper(parent);\n+\t\tstringSchema = new StringSchema();\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic StringSchemaFactory(SerializerProvider provider) {\n+\t\tsuper(provider);\n+\t\tstringSchema = new StringSchema();\n+\t}\n+\n+\tpublic ValueTypeSchema getValueSchema() {\n+\t\treturn stringSchema;\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ValueTypeSchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema.factories;\n+\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n+import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n+\n+public abstract class ValueTypeSchemaFactory extends SchemaFactory implements\n+\tJsonValueFormatVisitor {\n+\n+\tprotected SchemaFactory parent; \n+\t\n+\tprotected ValueTypeSchemaFactory(SchemaFactory parent) {\n+\t\tthis.parent = parent;\n+\t\tsetProvider(parent.getProvider());\n+\t}\n+\n+\t/**\n+\t * @param provider\n+\t */\n+\tpublic ValueTypeSchemaFactory(SerializerProvider provider) {\n+\t\tparent = null;\n+\t\tsetProvider(provider);\n+\t}\n+\n+\tpublic JsonSchema getSchema() {\n+\t\treturn getValueSchema();\n+\t}\n+\tprotected abstract ValueTypeSchema getValueSchema();\n+\t\n+\tpublic void format(JsonValueFormat format) {\n+\t\tgetValueSchema().setFormat(format);\n+\n+\t}\n+\n+\tpublic void enumTypes(Set<String> enums) {\n+\t\tgetValueSchema().setEnums(enums);\n+\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents a {@link JsonSchema} of type any\n+ * @author jphelan\n+ *\n+ */\n+public class AnySchema extends SimpleTypeSchema {\n+\t\n+\t/**\n+\t * This provides an enumeration of all possible values that are valid\n+\t   for the instance property.  This MUST be an array, and each item in\n+\t   the array represents a possible value for the instance value.  If\n+\t   this attribute is defined, the instance value MUST be one of the\n+\t   values in the array in order for the schema to be valid.  Comparison\n+\t   of enum values uses the same algorithm as defined in \"uniqueItems\"\n+\t   (Section 5.15).\n+\t */\n+\t@JsonProperty\n+\tprivate Set<String> enums;\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.ANY;\n+\t\n+\t//instance initializer block\n+\t{\n+\t\tenums = new HashSet<String>();\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asAnySchema()\n+\t */\n+\t@Override\n+\tpublic AnySchema asAnySchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof AnySchema) {\n+\t\t\tAnySchema that = ((AnySchema)obj);\n+\t\t\treturn super.equals(obj) && \n+\t\t\t\t\tenums == null ? that.enums == null : enums.equals(that.enums);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isAnySchema()\n+\t */\n+\t@Override\n+\tpublic boolean isAnySchema() { return true; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+/*\n+ * This attribute defines the allowed items in an instance array, and\n+   MUST be a jsonSchema or an array of jsonSchemas.  The default value is an\n+   empty jsonSchema which allows any value for items in the instance array.\n+ */\n+public class ArraySchema extends ContainerTypeSchema {\n+\t\n+\t\n+\t/**\n+\t * see {@link AdditionalItems}\n+\t */\n+\t@JsonProperty\n+\tprivate ArraySchema.AdditionalItems additionalItems;\n+\t\n+\t/**\n+\t * see {@link Items}\n+\t */\n+\t@JsonProperty\n+\tprivate ArraySchema.Items items;\n+\t\n+\t/**This attribute defines the maximum number of values in an array*/\n+\t@JsonProperty\n+\tprivate Integer maxItems;\n+\t\n+\t/**This attribute defines the minimum number of values in an array*/\n+\t@JsonProperty\n+\tprivate Integer minItems;\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.ARRAY;\n+\t\n+\t/**\n+\t * This attribute indicates that all items in an array instance MUST be\n+\t   unique (contains no two identical values).\n+\t\n+\t   Two instance are consider equal if they are both of the same type\n+\t   and:\n+\t\n+\t      are null; or are booleans/numbers/strings and have the same value; or\n+\t\n+\t      are arrays, contains the same number of items, and each item in\n+\t      the array is equal to the corresponding item in the other array;\n+\t      or\n+\t\n+\t      are objects, contains the same property names, and each property\n+\t      in the object is equal to the corresponding property in the other\n+\t      object.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean uniqueItems = null;\n+\t\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asArraySchema()\n+\t */\n+\t@Override\n+\tpublic ArraySchema asArraySchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ArraySchema) {\n+\t\t\tArraySchema that = (ArraySchema) obj;\n+\t\t\treturn getAdditionalItems() == null ? that.getAdditionalItems() == null : \n+\t\t\t\t\t\tgetAdditionalItems().equals(that.getAdditionalItems()) &&\n+\t\t\t\t\tgetItems() == null ? that.getItems() == null : \n+\t\t\t\t\t\tgetItems().equals(that.getItems()) &&\n+\t\t\t\t\tgetMaxItems() == null ? that.getMaxItems() == null :\n+\t\t\t\t\t\tgetMaxItems().equals(that.getMaxItems()) &&\n+\t\t\t\t\tgetMinItems() == null ? that.getMinItems() == null :\n+\t\t\t\t\t\tgetMinItems().equals(that.getMinItems()) &&\n+\t\t\t\t\tgetUniqueItems() == null ? that.getUniqueItems() == null :\n+\t\t\t\t\t\tgetUniqueItems().equals(that.getUniqueItems()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#additionalItems}\n+\t * @return the additionalItems\n+\t */\n+\tpublic ArraySchema.AdditionalItems getAdditionalItems() {\n+\t\treturn additionalItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#items}\n+\t * @return the items\n+\t */\n+\tpublic ArraySchema.Items getItems() {\n+\t\treturn items;\n+\t}\n+\t/**\n+\t * {@link ArraySchema#maxItems}\n+\t * @return the maxItems\n+\t */\n+\tpublic Integer getMaxItems() {\n+\t\treturn maxItems;\n+\t}\n+\n+\t\n+\t/**\n+\t * {@link ArraySchema#minItems}\n+\t * @return the minItems\n+\t */\n+\tpublic Integer getMinItems() {\n+\t\treturn minItems;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#uniqueItems}\n+\t * @return the uniqueItems\n+\t */\n+\tpublic Boolean getUniqueItems() {\n+\t\treturn uniqueItems;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isArraySchema()\n+\t */\n+\t@Override\n+\tpublic boolean isArraySchema() { return true; }\n+\t\n+\t/**\n+\t * {@link ArraySchema#additionalItems}\n+\t * @param additionalItems the additionalItems to set\n+\t */\n+\tpublic void setAdditionalItems(ArraySchema.AdditionalItems additionalItems) {\n+\t\tthis.additionalItems = additionalItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#items}\n+\t * @param items the items to set\n+\t */\n+\tpublic void setItems(ArraySchema.Items items) {\n+\t\tthis.items = items;\n+\t}\n+\t\n+\t/**\n+\t * Convenience method to set the json schema for the {@link ArraySchema#items}\n+\t * field\n+\t * @param jsonSchema\n+\t */\n+\tpublic void setItemsSchema(JsonSchema jsonSchema) {\n+\t\titems = new SingleItems(jsonSchema);\n+\t}\n+\t/**\n+\t * {@link ArraySchema#maxItems}\n+\t * @param maxItems the maxItems to set\n+\t */\n+\tpublic void setMaxItems(Integer maxItems) {\n+\t\tthis.maxItems = maxItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#minItems}\n+\t * @param minItems the minItems to set\n+\t */\n+\tpublic void setMinItems(Integer minItems) {\n+\t\tthis.minItems = minItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#uniqueItems}\n+\t * @param uniqueItems the uniqueItems to set\n+\t */\n+\tpublic void setUniqueItems(Boolean uniqueItems) {\n+\t\tthis.uniqueItems = uniqueItems;\n+\t}\n+\t\n+\t/**\n+\t * This provides a definition for additional items in an array instance\n+   when tuple definitions of the items is provided.\n+\t */\n+\tpublic static abstract class AdditionalItems {\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic static Items jsonCreator(Map<String,Object> props) {\n+\t\t\t// not implemented for jsonSchema\n+\t\t\treturn null;\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * When this attribute value is an array of jsonSchemas and the instance\n+\t   value is an array, each position in the instance array MUST conform\n+\t   to the jsonSchema in the corresponding position for this array.  This\n+\t   called tuple typing.  When tuple typing is used, additional items are\n+\t   allowed, disallowed, or constrained by the \"additionalItems\"\n+\t */\n+\tpublic static class ArrayItems extends ArraySchema.Items {\n+\t\t@JsonProperty\n+\t\tprivate JsonSchema[] jsonSchemas;\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#asArrayItems()\n+\t\t */\n+\t\t@Override\n+\t\tpublic ArrayItems asArrayItems() { return this; }\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof Items) {\n+\t\t\t\tArrayItems that = (ArrayItems) obj;\n+\t\t\t\treturn getJsonSchemas() == null ? that.getJsonSchemas() == null :\n+\t\t\t\t\tgetJsonSchemas().equals(that.getJsonSchemas());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ArraySchema.ArrayItems#jsonSchemas}\n+\t\t * @return the jsonSchemas\n+\t\t */\n+\t\tpublic JsonSchema[] getJsonSchemas() {\n+\t\t\treturn jsonSchemas;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#isArrayItems()\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean isArrayItems() { return true; }\n+\t\t\n+\t}\n+\t\n+\t/**\n+\t * This attribute defines the allowed items in an instance array, and\n+\t   MUST be a jsonSchema or an array of jsonSchemas.  The default value is an\n+\t   empty jsonSchema which allows any value for items in the instance array.\n+\t */\n+\tpublic static abstract class Items {\n+\t\t\n+\t\t@JsonIgnore\n+\t\tpublic boolean isSingleItems() { return false; }\n+\t\t\n+\t\t@JsonIgnore\n+\t\tpublic boolean isArrayItems() { return false; }\n+\t\t\n+\t\tpublic SingleItems asSingleItems() { return null; }\n+\t\tpublic ArrayItems asArrayItems() { return null; }\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic static Items jsonCreator(Map<String,Object> props) {\n+\t\t\t//for now only support deserialization of singleItems\n+\t\t\tObject typeFound = props.get(\"type\");\n+\t\t\tif (typeFound == null || ! (typeFound instanceof String)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tString type = (String) typeFound;\n+\t\t\tJsonSchema schema = JsonSchema.minimalForFormat(SchemaType.forValue(type));\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\t//only deserialize items as minimal schema for type\n+\t\t\treturn new SingleItems(schema);\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\t/**\n+\t *  This can be false\n+   \t\tto indicate additional items in the array are not allowed\n+\t */\n+\tpublic static class NoAdditionalItems extends AdditionalItems {\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof NoAdditionalItems;\n+\t\t}\n+\t\t@JsonValue\n+\t\tpublic Boolean value() { return false; }\n+\t}\n+\t\n+\t/**\n+\t * or it can\n+   \t\tbe a jsonSchema that defines the jsonSchema of the additional items.\n+\t */\n+\tpublic static class SchemaAdditionalItems extends AdditionalItems {\n+\t\t\n+\t\t@JsonIgnore\n+\t\tprivate JsonSchema jsonSchema;\n+\t\t\n+\t\tpublic SchemaAdditionalItems(JsonSchema schema) {\n+\t\t\tjsonSchema = schema;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SchemaAdditionalItems &&\n+\t\t\t\t\tgetJsonSchema() == null ? ((SchemaAdditionalItems)obj).getJsonSchema() == null :\n+\t\t\t\t\t\tgetJsonSchema().equals(((SchemaAdditionalItems)obj).getJsonSchema());\n+\t\t}\n+\t\t\n+\t\t@JsonValue\n+\t\tpublic JsonSchema getJsonSchema() {\n+\t\t\treturn jsonSchema;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * When this attribute value is a jsonSchema and the instance value is an\n+\t   array, then all the items in the array MUST be valid according to the\n+\t   jsonSchema.\n+\t */\n+\tpublic static class SingleItems extends ArraySchema.Items {\n+\t\t@JsonIgnore\n+\t\tprivate JsonSchema jsonSchema;\n+\t\t\t\n+\t\tpublic SingleItems(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SingleItems &&\n+\t\t\t\t\tgetSchema() == null ? ((SingleItems)obj).getSchema() == null :\n+\t\t\t\t\t\tgetSchema().equals(((SingleItems)obj).getSchema());\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ArraySchema.SingleItems#jsonSchema}\n+\t\t * @return the jsonSchema\n+\t\t */\n+\t\t@JsonValue\n+\t\tpublic JsonSchema getSchema() {\n+\t\t\treturn jsonSchema;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ArraySchema.SingleItems#jsonSchema}\n+\t\t * @param jsonSchema the jsonSchema to set\n+\t\t */\n+\t\tpublic void setSchema(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#isSingleItems()\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean isSingleItems() { return true; }\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#asSingleItems()\n+\t\t */\n+\t\t@Override\n+\t\tpublic SingleItems asSingleItems() { return this; }\n+\t}\n+\n+ }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/BooleanSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+/**\n+ * This class represents a {@link JsonSchema} of type boolean\n+ * @author jphelan\n+ *\n+ */\n+public class BooleanSchema extends ValueTypeSchema {\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.BOOLEAN;\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isBooleanSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isBooleanSchema() { return true; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asBooleanSchema()\n+\t */\n+\t@Override\n+\tpublic BooleanSchema asBooleanSchema() { return this; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class encapsulates the functionality of container type {@link JsonSchema}\n+ * Array and Object\n+ * @author jphelan\n+ *\n+ */\n+public abstract class ContainerTypeSchema extends SimpleTypeSchema {\n+\t/**\n+\t * This provides an enumeration of all possible values that are valid\n+\t   for the instance property.  This MUST be an array, and each item in\n+\t   the array represents a possible value for the instance value.  If\n+\t   this attribute is defined, the instance value MUST be one of the\n+\t   values in the array in order for the schema to be valid.  Comparison\n+\t   of enum values uses the same algorithm as defined in \"uniqueItems\"\n+\t   (Section 5.15).\n+\t */\n+\t@JsonProperty(required = true)\n+\tprivate Set<String> enums;\n+\t\n+\t//instance initializer block \n+\t{\n+\t\tenums = new HashSet<String>();\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asContainerSchema()\n+\t */\n+\t@Override\n+\tpublic ContainerTypeSchema asContainerSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.SimpleTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ContainerTypeSchema) {\n+\t\t\tContainerTypeSchema that = (ContainerTypeSchema)obj;\n+\t\t\treturn getEnums() == null ? that.getEnums() == null :\n+\t\t\t\tgetEnums().equals(that.getEnums()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t/**\n+\t * {@link ContainerTypeSchema#enums}\n+\t * @return the enums\n+\t */\n+\tpublic Set<String> getEnums() {\n+\t\treturn enums;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isContainerTypeSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isContainerTypeSchema() { return true; }\n+\t\n+\t/**\n+\t * {@link ContainerTypeSchema#enums}\n+\t * @param enums the enums to set\n+\t */\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/HyperSchema.java\n+ package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents the HyperSchema portion of a {@link JsonSchema}\n+ * It is a skeleton intended as a starting point for customization.\n+ * @author jphelan\n+ *\n+ */\n+public class HyperSchema extends JsonSchema {\n+\t\n+\t\n+\t/**\n+\t * This attribute indicates that the instance property SHOULD NOT be\n+\t   changed.  Attempts by a user agent to modify the value of this\n+\t   property are expected to be rejected by a server.\n+\t */\n+\t@JsonProperty\n+\tprivate String readOnly;\n+\t\n+\t/**\n+\t * If the instance property value is a string, this attribute defines\n+\t   that the string SHOULD be interpreted as binary data and decoded\n+\t   using the encoding named by this jsonSchema property.  RFC 2045, Sec 6.1\n+\t   [RFC2045] lists the possible values for this property.\n+\t */\n+\t@JsonProperty\n+\tprivate String contentEncoding;\n+\t\n+\t\n+\t/**\n+\t * This attribute is a URI that defines what the instance's URI MUST\n+\t   start with in order to validate.  The value of the \"pathStart\"\n+\t   attribute MUST be resolved as per RFC 3986, Sec 5 [RFC3986], and is\n+\t   relative to the instance's URI.\n+\t\n+\t   When multiple schemas have been referenced for an instance, the user\n+\t   agent can determine if this jsonSchema is applicable for a particular\n+\t   instance by determining if the URI of the instance begins with the\n+\t   the value of the \"pathStart\" attribute.  If the URI of the instance\n+\t   does not start with this URI, or if another jsonSchema specifies a\n+\t   starting URI that is longer and also matches the instance, this\n+\t   jsonSchema SHOULD NOT be applied to the instance.  Any jsonSchema that does\n+\t   not have a pathStart attribute SHOULD be considered applicable to all\n+\t   the instances for which it is referenced.\n+\t */\n+\t@JsonProperty\n+\tprivate String pathStart;\n+\t\n+\t/**\n+\t * This attribute defines the media type of the instance representations\n+\t\tthat this jsonSchema is defining.\n+\t */\n+\t@JsonProperty\n+\tprivate String mediaType;\n+\t\n+\t/**\n+\t * This property indicates the fragment resolution protocol to use for\n+\t   resolving fragment identifiers in URIs within the instance\n+\t   representations.  This applies to the instance object URIs and all\n+\t   children of the instance object's URIs.  The default fragment\n+\t   resolution protocol is \"slash-delimited\", which is defined below.\n+\t   Other fragment resolution protocols MAY be used, but are not defined\n+\t   in this document.\n+\t\n+\t   The fragment identifier is based on RFC 2396, Sec 5 [RFC2396], and\n+\t   defines the mechanism for resolving references to entities within a\n+\t   document.\n+\t */\n+\t@JsonProperty\n+\tprivate String fragmentResolution;\n+\t/**\n+\t * 6.2.1.  slash-delimited fragment resolution\n+\n+\t\t   With the slash-delimited fragment resolution protocol, the fragment\n+\t\t   identifier is interpreted as a series of property reference tokens\n+\t\t   that start with and are delimited by the \"/\" character (\\x2F).  Each\n+\t\t   property reference token is a series of unreserved or escaped URI\n+\t\t   characters.  Each property reference token SHOULD be interpreted,\n+\t\t   starting from the beginning of the fragment identifier, as a path\n+\t\t   reference in the target JSON structure.  The final target value of\n+\t\t   the fragment can be determined by starting with the root of the JSON\n+\t\t   structure from the representation of the resource identified by the\n+\t\t   pre-fragment URI.  If the target is a JSON object, then the new\n+\t\t   target is the value of the property with the name identified by the\n+\t\t   next property reference token in the fragment.  If the target is a\n+\t\t   JSON array, then the target is determined by finding the item in\n+\t\t   array the array with the index defined by the next property reference\n+\t\t   token (which MUST be a number).  The target is successively updated\n+\t\t   for each property reference token, until the entire fragment has been \n+\t\t   traversed.\n+\t\t\n+\t\t   Property names SHOULD be URI-encoded.  In particular, any \"/\" in a\n+\t\t   property name MUST be encoded to avoid being interpreted as a\n+\t\t   property delimiter.\n+\t\t\n+\t\t   For example, for the following JSON representation:\n+\t\t\n+\t\t   {\n+\t\t     \"foo\":{\n+\t\t       \"anArray\":[\n+\t\t         {\"prop\":44}\n+\t\t       ],\n+\t\t       \"another prop\":{\n+\t\t         \"baz\":\"A string\"\n+\t\t       }\n+\t\t     }\n+\t\t   }\n+\t\t\n+\t\t   The following fragment identifiers would be resolved:\n+\t\t\n+\t\t   fragment identifier      resolution\n+\t\t   -------------------      ----------\n+\t\t   #                        self, the root of the resource itself\n+\t\t   #/foo                    the object referred to by the foo property\n+\t\t   #/foo/another%20prop     the object referred to by the \"another prop\"\n+\t\t                            property of the object referred to by the\n+\t\t                            \"foo\" property\n+\t\t   #/foo/another%20prop/baz the string referred to by the value of \"baz\"\n+\t\t                            property of the \"another prop\" property of\n+\t\t                            the object referred to by the \"foo\" property\n+\t\t   #/foo/anArray/0          the first object in the \"anArray\" array\n+\t\t\n+\t\t6.2.2.  dot-delimited fragment resolution\n+\t\t\n+\t\t   The dot-delimited fragment resolution protocol is the same as slash-\n+\t\t   delimited fragment resolution protocol except that the \".\" character\n+\t\t   (\\x2E) is used as the delimiter between property names (instead of\n+\t\t   \"/\") and the path does not need to start with a \".\".  For example,\n+\t\t   #.foo and #foo are a valid fragment identifiers for referencing the\n+\t\t   value of the foo propery.\n+\t*/\n+\t\n+\t@JsonProperty\n+\tprivate LinkDescriptionObject[] links;\n+\t\n+\t/**\n+\t *  A link description object is used to describe link relations.  In the\n+\t   context of a jsonSchema, it defines the link relations of the instances\n+\t   of the jsonSchema, and can be parameterized by the instance values.  The\n+\t   link description format can be used on its own in regular (non-jsonSchema\n+\t   documents), and use of this format can be declared by referencing the\n+\t   normative link description jsonSchema as the the jsonSchema for the data\n+\t   structure that uses the links.\n+\t */\n+\tpublic class LinkDescriptionObject {\n+\t\t\n+\t\t/**\n+\t\t * The value of the \"href\" link description property indicates the\n+\t\t   target URI of the related resource.  The value of the instance\n+\t\t   property SHOULD be resolved as a URI-Reference per RFC 3986 [RFC3986]\n+\t\t   and MAY be a relative URI.  The base URI to be used for relative\n+\t\t   resolution SHOULD be the URI used to retrieve the instance object\n+\t\t   (not the jsonSchema) when used within a jsonSchema.  Also, when links are\n+\t\t   used within a jsonSchema, the URI SHOULD be parametrized by the property\n+\t\t   values of the instance object, if property values exist for the\n+\t\t   corresponding variables in the template (otherwise they MAY be\n+\t\t   provided from alternate sources, like user input).\n+\t\t\n+\t\t   Instance property values SHOULD be substituted into the URIs where\n+\t\t   matching braces ('{', '}') are found surrounding zero or more\n+\t\t   characters, creating an expanded URI.  Instance property value\n+\t\t   substitutions are resolved by using the text between the braces to\n+\t\t   denote the property name from the instance to get the value to\n+\t\t   substitute.  For example, if an href value is defined:\n+\t\t\n+\t\t   http://somesite.com/{id}\n+\t\t\n+\t\t   Then it would be resolved by replace the value of the \"id\" property\n+\t\t   value from the instance object.  If the value of the \"id\" property\n+\t\t   was \"45\", the expanded URI would be:\n+\n+\t\t   http://somesite.com/45\n+\t \t\n+\t\t   If matching braces are found with the string \"@\" (no quotes) between\n+\t\t   the braces, then the actual instance value SHOULD be used to replace\n+\t\t   the braces, rather than a property value.  This should only be used\n+\t\t   in situations where the instance is a scalar (string, boolean, or\n+\t\t   number), and not for objects or arrays.\n+\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate String href;\n+\t\t\n+\t\t/**\n+\t\t * The value of the \"rel\" property indicates the name of the relation to\n+\t\t   the target resource.  The relation to the target SHOULD be\n+\t\t   interpreted as specifically from the instance object that the jsonSchema\n+\t\t   (or sub-jsonSchema) applies to, not just the top level resource that\n+\t\t   contains the object within its hierarchy.  If a resource JSON\n+\t\t   representation contains a sub object with a property interpreted as a\n+\t\t   link, that sub-object holds the relation with the target.  A relation\n+\t\t   to target from the top level resource MUST be indicated with the\n+\t\t   jsonSchema describing the top level JSON representation.\n+\t\t\n+\t\t   Relationship definitions SHOULD NOT be media type dependent, and\n+\t\t   users are encouraged to utilize existing accepted relation\n+\t\t   definitions, including those in existing relation registries (see RFC\n+\t\t   4287 [RFC4287]).  However, we define these relations here for clarity\n+\t\t   of normative interpretation within the context of JSON hyper jsonSchema\n+\t\t   defined relations:\n+\t\t\n+\t\t   self  If the relation value is \"self\", when this property is\n+\t\t      encountered in the instance object, the object represents a\n+\t\t      resource and the instance object is treated as a full\n+\t\t      representation of the target resource identified by the specified\n+\t\t      URI.\n+\t\t\n+\t\t   full  This indicates that the target of the link is the full\n+\t\t      representation for the instance object.  The object that contains\n+\t\t      this link possibly may not be the full representation.\n+\t\t\n+\t\t   describedby  This indicates the target of the link is the jsonSchema for\n+\t\t      the instance object.  This MAY be used to specifically denote the\n+\t\t      schemas of objects within a JSON object hierarchy, facilitating\n+\t\t      polymorphic type data structures.\n+\t\t\n+\t\t   root  This relation indicates that the target of the link SHOULD be\n+\t\t      treated as the root or the body of the representation for the\n+\t\t      purposes of user agent interaction or fragment resolution.  All\n+\t\t      other properties of the instance objects can be regarded as meta-\n+\t\t       data descriptions for the data.\n+\n+\t\t   The following relations are applicable for schemas (the jsonSchema as the\n+\t\t   \"from\" resource in the relation):\n+\t\t\n+\t\t   instances  This indicates the target resource that represents\n+\t\t      collection of instances of a jsonSchema.\n+\t\t\n+\t\t   create  This indicates a target to use for creating new instances of\n+\t\t      a jsonSchema.  This link definition SHOULD be a submission link with a\n+\t\t      non-safe method (like POST).\n+\t\t\n+\t\t   For example, if a jsonSchema is defined:\n+\t\t\n+\t\t   {\n+\t\t     \"links\": [\n+\t\t       {\n+\t\t         \"rel\": \"self\"\n+\t\t         \"href\": \"{id}\"\n+\t\t       },\n+\t\t       {\n+\t\t         \"rel\": \"up\"\n+\t\t         \"href\": \"{upId}\"\n+\t\t       },\n+\t\t       {\n+\t\t         \"rel\": \"children\"\n+\t\t         \"href\": \"?upId={id}\"\n+\t\t       }\n+\t\t     ]\n+\t\t   }\n+\t\t\n+\t\t   And if a collection of instance resource's JSON representation was\n+\t\t   retrieved:\n+\t\t\n+\t\t   GET /Resource/\n+\t\t\n+\t\t   [\n+\t\t     {\n+\t\t       \"id\": \"thing\",\n+\t\t       \"upId\": \"parent\"\n+\t\t     },\n+\t\t     {\n+\t\t       \"id\": \"thing2\",\n+\t\t       \"upId\": \"parent\"\n+\t\t     }\n+\t\t   ]\n+\t\t\n+\t\t   This would indicate that for the first item in the collection, its\n+\t\t   own (self) URI would resolve to \"/Resource/thing\" and the first\n+\t\t   item's \"up\" relation SHOULD be resolved to the resource at\n+\t\t   \"/Resource/parent\".  The \"children\" collection would be located at\n+\t\t   \"/Resource/?upId=thing\".\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate String rel;\n+\t\t\n+\t\t/**\n+\t\t * This property value is a jsonSchema that defines the expected structure\n+\t\t\tof the JSON representation of the target of the link.\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate JsonSchema targetSchema;\n+\t\t\n+\t\t/**\n+\t\t * This attribute defines which method can be used to access the target\n+\t\t   resource.  In an HTTP environment, this would be \"GET\" or \"POST\"\n+\t\t   (other HTTP methods such as \"PUT\" and \"DELETE\" have semantics that\n+\t\t   are clearly implied by accessed resources, and do not need to be\n+\t\t   defined here).  This defaults to \"GET\".\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate String method;\n+\t\t\n+\t\t/**\n+\t\t *  If present, this property indicates a query media type format that\n+\t\t   the server supports for querying or posting to the collection of\n+\t\t   instances at the target resource.  The query can be suffixed to the\n+\t\t   target URI to query the collection with property-based constraints on\n+\t\t   the resources that SHOULD be returned from the server or used to post\n+\t\t   data to the resource (depending on the method).  For example, with\n+\t\t   the following jsonSchema:\n+\t\t\n+\t\t   {\n+\t\t    \"links\":[\n+\t\t      {\n+\t\t        \"enctype\":\"application/x-www-form-urlencoded\",\n+\t\t        \"method\":\"GET\",\n+\t\t        \"href\":\"/Product/\",\n+\t\t        \"properties\":{\n+\t\t           \"name\":{\"description\":\"name of the product\"}\n+\t\t        }\n+\t\t      }\n+\t\t    ]\n+\t\t   }\n+\t\t   This indicates that the client can query the server for instances\n+\t\t   that have a specific name:\n+\t\t\n+\t\t   /Product/?name=Slinky\n+\t\t\n+\t\t   If no enctype or method is specified, only the single URI specified\n+\t\t   by the href property is defined.  If the method is POST,\n+\t\t   \"application/json\" is the default media type.\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate String enctype;\n+\t\t\n+\t\t/**\n+\t\t * This attribute contains a jsonSchema which defines the acceptable\n+\t\t   structure of the submitted request (for a GET request, this jsonSchema\n+\t\t   would define the properties for the query string and for a POST\n+\t\t   request, this would define the body).\n+\t\t */\n+\t\t@JsonProperty\n+\t\tprivate JsonSchema jsonSchema;\n+\t\t\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn null;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents a {@link JsonSchema} as an integer type\n+ * @author jphelan\n+ *\n+ */\n+public class IntegerSchema extends NumberSchema {\n+\t\n+\t/**\n+\t * This attribute defines what value the number instance must be\n+\t   divisible by with no remainder (the result of the division must be an\n+\t   integer.)  The value of this attribute SHOULD NOT be 0.\n+\t */\n+\t@JsonProperty\n+\tprivate Integer divisibleBy;\n+\t\n+\t@JsonProperty(required = true)\n+\tpublic final SchemaType type = SchemaType.INTEGER;\n+\t\n+\t@Override\n+\tpublic IntegerSchema asIntegerSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.NumberSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof IntegerSchema) {\n+\t\t\tIntegerSchema that = (IntegerSchema)obj;\n+\t\t\treturn getDivisibleBy() == null ? that.getDivisibleBy() == null :\n+\t\t\t\tgetDivisibleBy().equals(that.getDivisibleBy()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n+\t/**\n+\t * {@link IntegerSchema#divisibleBy}\n+\t * @return the divisibleBy\n+\t */\n+\tpublic Integer getDivisibleBy() {\n+\t\treturn divisibleBy;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isIntegerSchema() { return true; }\n+\t\n+\t/**\n+\t * {@link IntegerSchema#divisibleBy}\n+\t * @param divisibleBy the divisibleBy to set\n+\t */\n+\tpublic void setDivisibleBy(Integer divisibleBy) {\n+\t\tthis.divisibleBy = divisibleBy;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/JsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * The type wraps the json schema specification at :\n+ * <a href=\"http://tools.ietf.org/id/draft-zyp-json-schema-03.txt\"> Json JsonSchema\n+ * Draft </a> <blockquote> JSON (JavaScript Object Notation) JsonSchema defines the\n+ * media type \"application/schema+json\", a JSON based format for defining the\n+ * structure of JSON data. JSON JsonSchema provides a contract for what JSON data is\n+ * required for a given application and how to interact with it. JSON JsonSchema is\n+ * intended to define validation, documentation, hyperlink navigation, and\n+ * interaction control of JSON data. </blockquote>\n+ * \n+ * <blockquote> JSON (JavaScript Object Notation) JsonSchema is a JSON media type\n+ * for defining the structure of JSON data. JSON JsonSchema provides a contract for\n+ * what JSON data is required for a given application and how to interact with\n+ * it. JSON JsonSchema is intended to define validation, documentation, hyperlink\n+ * navigation, and interaction control of JSON data. </blockquote>\n+ * \n+ * An example JSON JsonSchema provided by the JsonSchema draft:\n+ * \n+ * <pre>\n+ * \t{\n+ * \t  \"name\":\"Product\",\n+ * \t  \"properties\":{\n+ * \t    \"id\":{\n+ * \t      \"type\":\"number\",\n+ * \t      \"description\":\"Product identifier\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"name\":{\n+ * \t      \"description\":\"Name of the product\",\n+ * \t      \"type\":\"string\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"price\":{\n+ * \t      \"required\":true,\n+ * \t      \"type\": \"number\",\n+ * \t      \"minimum\":0,\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"tags\":{\n+ * \t      \"type\":\"array\",\n+ * \t      \"items\":{\n+ * \t        \"type\":\"string\"\n+ * \t      }\n+ * \t    }\n+ * \t  },\n+ * \t  \"links\":[\n+ * \t    {\n+ * \t      \"rel\":\"full\",\n+ * \t      \"href\":\"{id}\"\n+ * \t    },\n+ * \t    {\n+ * \t      \"rel\":\"comments\",\n+ * \t      \"href\":\"comments/?id={id}\"\n+ * \t    }\n+ * \t  ]\n+ * \t}\n+ * </pre>\n+ * \n+ * @author jphelan\n+ */\n+@JsonInclude(Include.NON_EMPTY)\n+@JsonTypeInfo(use = Id.CUSTOM, include = As.PROPERTY, property = \"type\")\n+@JsonTypeIdResolver(JsonSchema.JsonSchemaIdResolver.class)\n+public abstract class JsonSchema {\n+\n+\t/**\n+\t * This attribute defines a URI of a schema that contains the full\n+\t * representation of this schema. When a validator encounters this\n+\t * attribute, it SHOULD replace the current schema with the schema\n+\t * referenced by the value's URI (if known and available) and re- validate\n+\t * the instance. This URI MAY be relative or absolute, and relative URIs\n+\t * SHOULD be resolved against the URI of the current schema.\n+\t */\n+\t@JsonProperty\n+\tprivate String $ref;\n+\n+\t/**\n+\t * This attribute defines a URI of a JSON JsonSchema that is the schema of the\n+\t * current schema. When this attribute is defined, a validator SHOULD use\n+\t * the schema referenced by the value's URI (if known and available) when\n+\t * resolving Hyper JsonSchema (Section 6) links (Section 6.1).\n+\t * \n+\t * A validator MAY use this attribute's value to determine which version of\n+\t * JSON JsonSchema the current schema is written in, and provide the appropriate\n+\t * validation features and behavior. Therefore, it is RECOMMENDED that all\n+\t * schema authors include this attribute in their schemas to prevent\n+\t * conflicts with future JSON JsonSchema specification changes.\n+\t */\n+\t@JsonProperty\n+\tprivate String $schema;\n+\n+\t/**\n+\t * This attribute takes the same values as the \"type\" attribute, however if\n+\t * the instance matches the type or if this value is an array and the\n+\t * instance matches any type or schema in the array, then this instance is\n+\t * not valid.\n+\t */\n+\t@JsonProperty\n+\tprivate JsonSchema[] disallow;\n+\t/**\n+\t * The value of this property MUST be another schema which will provide a\n+\t * base schema which the current schema will inherit from. The inheritance\n+\t * rules are such that any instance that is valid according to the current\n+\t * schema MUST be valid according to the referenced schema. This MAY also be\n+\t * an array, in which case, the instance MUST be valid for all the schemas\n+\t * in the array. A schema that extends another schema MAY define additional\n+\t * attributes, constrain existing attributes, or add other constraints.\n+\t * \n+\t * Conceptually, the behavior of extends can be seen as validating an\n+\t * instance against all constraints in the extending schema as well as the\n+\t * extended schema(s). More optimized implementations that merge schemas are\n+\t * possible, but are not required. An example of using \"extends\":\n+\t * \n+\t * { \"description\":\"An adult\", \"properties\":{\"age\":{\"minimum\": 21}},\n+\t * \"extends\":\"person\" } { \"description\":\"Extended schema\",\n+\t * \"properties\":{\"deprecated\":{\"type\": \"boolean\"}},\n+\t * \"extends\":\"http://json-schema.org/draft-03/schema\" }\n+\t */\n+\t@JsonIgnore\n+\tprivate JsonSchema[] extendsextends;\n+\t/**\n+\t * This attribute defines the current URI of this schema (this attribute is\n+\t * effectively a \"self\" link). This URI MAY be relative or absolute. If the\n+\t * URI is relative it is resolved against the current URI of the parent\n+\t * schema it is contained in. If this schema is not contained in any parent\n+\t * schema, the current URI of the parent schema is held to be the URI under\n+\t * which this schema was addressed. If id is missing, the current URI of a\n+\t * schema is defined to be that of the parent schema. The current URI of the\n+\t * schema is also used to construct relative references such as for $ref.\n+\t */\n+\t@JsonProperty\n+\tprivate String id;\n+\t/**\n+\t * This attribute indicates if the instance must have a value, and not be\n+\t * undefined. This is false by default, making the instance optional.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean required = null;\n+\n+\t\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link AnySchema}\n+\t * @return this as an AnySchema if possible, or null otherwise\n+\t */\n+\tpublic AnySchema asAnySchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link ArraySchema}\n+\t * @return this as an ArraySchema if possible, or null otherwise\n+\t */\n+\tpublic ArraySchema asArraySchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link BooleanSchema}\n+\t * @return this as a BooleanSchema if possible, or null otherwise\n+\t */\n+\tpublic BooleanSchema asBooleanSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link ContainerTypeSchema}\n+\t * @return this as an ContainerTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic ContainerTypeSchema asContainerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link IntegerSchema}\n+\t * @return this as an IntegerSchema if possible, or null otherwise\n+\t */\n+\tpublic IntegerSchema asIntegerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link NullSchema}\n+\t * @return this as a NullSchema if possible, or null otherwise\n+\t */\n+\tpublic NullSchema asNullSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link NumberSchema}\n+\t * @return this as a NumberSchema if possible, or null otherwise\n+\t */\n+\tpublic NumberSchema asNumberSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link ObjectSchema}\n+\t * @return this as an ObjectSchema if possible, or null otherwise\n+\t */\n+\tpublic ObjectSchema asObjectSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link SimpleTypeSchema}\n+\t * @return this as a SimpleTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic SimpleTypeSchema asSimpleTypeSchema() {\n+\t\treturn null;\n+\t}\n+\t\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link StringSchema}\n+\t * @return this as a StringSchema if possible, or null otherwise\n+\t */\n+\tpublic StringSchema asStringSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link UnionTypeSchema}\n+\t * @return this as a UnionTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic UnionTypeSchema asUnionTypeSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link ValueTypeSchema}\n+\t * @return this as a ValueTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic ValueTypeSchema asValueSchemaSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t\n+\t/* (non-Javadoc)\n+\t * @see java.lang.Object#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof JsonSchema) {\n+\t\t\tJsonSchema that = ((JsonSchema)obj);\n+\t\t\treturn that.getType() == getType() &&\n+\t\t\t\t\tgetRequired() == null ? that.getRequired() == null : \n+\t\t\t\t\t\tgetRequired().equals(that.getRequired()) &&\n+\t\t\t\t\tget$ref() == null ? that.get$ref() == null : \n+\t\t\t\t\t\tget$ref().equals(that.get$ref()) &&\n+\t\t\t\t\tget$schema() == null ? that.get$schema() == null : \n+\t\t\t\t\t\tget$schema().equals(that.get$schema()) &&\n+\t\t\t\t\tgetDisallow() == null ? that.getDisallow() == null : \n+\t\t\t\t\t\tgetDisallow().equals(that.getDisallow()) &&\n+\t\t\t\t\tgetExtends() == null ? that.getExtends() == null : \n+\t\t\t\t\t\tgetExtends().equals(that.getExtends());\n+\t\t} \n+\t\treturn false;\n+\t}\n+\t\n+\t/**\n+\t * {@link JsonSchema#$ref}\n+\t * \n+\t * @return the $ref\n+\t */\n+\tpublic String get$ref() {\n+\t\treturn $ref;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$schema}\n+\t * \n+\t * @return the $schema\n+\t */\n+\tpublic String get$schema() {\n+\t\treturn $schema;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#disallow}\n+\t * \n+\t * @return the disallow\n+\t */\n+\tpublic JsonSchema[] getDisallow() {\n+\t\treturn disallow;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#extendsextends}\n+\t * \n+\t * @return the extendsextends\n+\t */\n+\t@JsonGetter(\"extends\")\n+\tpublic JsonSchema[] getExtends() {\n+\t\treturn extendsextends;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#id}\n+\t * \n+\t * @return the id\n+\t */\n+\tpublic String getId() {\n+\t\treturn id;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#required}\n+\t * \n+\t * @return the required\n+\t */\n+\tpublic Boolean getRequired() {\n+\t\treturn required;\n+\t}\n+\n+\t@JsonIgnore\n+\tpublic abstract SchemaType getType();\n+\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link AnySchema}.\n+\t *\n+\t * @return true if this JsonSchema is an AnySchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isAnySchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ArraySchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ArraySchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isArraySchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link BooleanSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an BooleanSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isBooleanSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ContainerTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ContainerTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isContainerTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link IntegerSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an IntegerSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isIntegerSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link NullSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an NullSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isNullSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link NumberSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an NumberSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isNumberSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ObjectSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ObjectSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isObjectSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link SimpleTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an SimpleTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isSimpleTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link StringSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an StringSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isStringSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link UnionTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an UnionTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isUnionTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ValueTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ValueTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isValueTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$ref}\n+\t * \n+\t * @param $ref\n+\t *            the $ref to set\n+\t */\n+\tpublic void set$ref(String $ref) {\n+\t\tthis.$ref = $ref;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$schema}\n+\t * \n+\t * @param $schema\n+\t *            the $schema to set\n+\t */\n+\tpublic void set$schema(String $schema) {\n+\t\tthis.$schema = $schema;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#disallow}\n+\t * \n+\t * @param disallow\n+\t *            the disallow to set\n+\t */\n+\tpublic void setDisallow(JsonSchema[] disallow) {\n+\t\tthis.disallow = disallow;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#extendsextends}\n+\t * \n+\t * @param extendsextends\n+\t *            the extendsextends to set\n+\t */\n+\t@JsonSetter(\"extends\")\n+\tpublic void setExtends(JsonSchema[] extendsextends) {\n+\t\tthis.extendsextends = extendsextends;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#id}\n+\t * \n+\t * @param id\n+\t *            the id to set\n+\t */\n+\tpublic void setId(String id) {\n+\t\tthis.id = id;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#required}\n+\t * \n+\t * @param required\n+\t *            the required to set\n+\t */\n+\tpublic void setRequired(Boolean required) {\n+\t\tthis.required = required;\n+\t}\n+\n+\t/**\n+\t * Create a schema which verifies only that an object is of the given format.\n+\t * @param format the format to expect\n+\t * @return the schema verifying the given format\n+\t */\n+\tpublic static JsonSchema minimalForFormat(SchemaType format) {\n+\t\tswitch (format) {\n+\t\tcase ARRAY:\n+\t\t\treturn new ArraySchema();\n+\t\tcase OBJECT:\n+\t\t\treturn new ObjectSchema();\n+\t\tcase BOOLEAN:\n+\t\t\treturn new BooleanSchema();\n+\t\tcase INTEGER:\n+\t\t\treturn new IntegerSchema();\n+\t\tcase NUMBER:\n+\t\t\treturn new NumberSchema();\n+\t\tcase STRING:\n+\t\t\treturn new StringSchema();\n+\t\tcase NULL:\n+\t\t\treturn new NullSchema();\n+\n+\t\tdefault:\n+\t\t\treturn new AnySchema();\n+\t\t}\n+\t}\n+\t\n+\tpublic static class JsonSchemaIdResolver implements TypeIdResolver {\n+\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromValue(java.lang.Object)\n+\t\t */\n+\t\tpublic String idFromValue(Object value) {\n+\t\t\tif ( value instanceof JsonSchema) {\n+\t\t\t\treturn ((JsonSchema)value).getType().value();\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromValueAndType(java.lang.Object, java.lang.Class)\n+\t\t */\n+\t\tpublic String idFromValueAndType(Object value, Class<?> suggestedType) {\n+\t\t\treturn idFromValue(value);\n+\t\t}\n+\t\t\n+\t\tprivate static JavaType any = TypeFactory.defaultInstance().constructType(AnySchema.class);\n+\t\tprivate static JavaType array = TypeFactory.defaultInstance().constructType(ArraySchema.class);\n+\t\tprivate static JavaType booleanboolean = TypeFactory.defaultInstance().constructType(BooleanSchema.class);\n+\t\tprivate static JavaType integer = TypeFactory.defaultInstance().constructType(IntegerSchema.class);\n+\t\tprivate static JavaType nullnull = TypeFactory.defaultInstance().constructType(NullSchema.class);\n+\t\tprivate static JavaType number = TypeFactory.defaultInstance().constructType(NumberSchema.class);\n+\t\tprivate static JavaType object = TypeFactory.defaultInstance().constructType(ObjectSchema.class);\n+\t\tprivate static JavaType string = TypeFactory.defaultInstance().constructType(StringSchema.class);\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#typeFromId(java.lang.String)\n+\t\t */\n+\t\tpublic JavaType typeFromId(String id) {\n+\t\t\tswitch (SchemaType.forValue(id)) {\n+\t\t\tcase ANY: \t\treturn any;\n+\t\t\tcase ARRAY: \treturn array;\n+\t\t\tcase BOOLEAN:\treturn booleanboolean;\n+\t\t\tcase INTEGER:\treturn integer;\n+\t\t\tcase NULL:\t\treturn nullnull;\n+\t\t\tcase NUMBER:\treturn number;\n+\t\t\tcase OBJECT:\treturn object;\n+\t\t\tcase STRING:\treturn string;\n+\t\t\tdefault:\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#getMechanism()\n+\t\t */\n+\t\tpublic Id getMechanism() {\n+\t\t\treturn Id.CUSTOM;\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#init(com.fasterxml.jackson.databind.JavaType)\n+\t\t */\n+\t\tpublic void init(JavaType baseType) { }\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromBaseType()\n+\t\t */\n+\t\tpublic String idFromBaseType() {\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/JsonValueFormat.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+/**\n+ * This enum represents the encoded format for a jsonSchema value type\n+ * @author jphelan\n+ *\n+ */\n+public enum JsonValueFormat {\n+\t/**\n+\t * This SHOULD be a date in ISO 8601 format of YYYY-MM-\n+      DDThh:mm:ssZ in UTC time.  This is the recommended form of date/\n+      timestamp.\n+\t */\n+\tDATE_TIME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"date-time\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a date in the format of YYYY-MM-DD.  It is\n+      recommended that you use the \"date-time\" format instead of \"date\"\n+      unless you need to transfer only the date part.\n+\t */\n+\tDATE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"date\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a time in the format of hh:mm:ss.  It is\n+      recommended that you use the \"date-time\" format instead of \"time\"\n+      unless you need to transfer only the time part.\n+\t */\n+\tTIME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"time\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be the difference, measured in\n+      milliseconds, between the specified time and midnight, 00:00 of\n+      January 1, 1970 UTC.  The value SHOULD be a number (integer or\n+      float).\n+\t */\n+\tUTC_MILLISEC {\n+\t\t@Override\n+\t\tpublic String toString() { return \"utc-millisec\"; }\n+\t},\n+\t\n+\t/**\n+\t * A regular expression, following the regular expression\n+  \t  specification from ECMA 262/Perl 5.\n+\t */\n+\tREGEX {\n+\t\t@Override\n+\t\tpublic String toString() { return \"regex\"; }\n+\t},\n+\t\n+\t/**\n+\t * This is a CSS color (like \"#FF0000\" or \"red\"), based on CSS\n+  \t\t2.1 [W3C.CR-CSS21-20070719].\n+\t */\n+\tCOLOR {\n+\t\t@Override\n+\t\tpublic String toString() { return \"color\"; }\n+\t},\n+\t\n+\t/**\n+\t * This is a CSS style definition (like \"color: red; background-\n+  \t\tcolor:#FFF\"), based on CSS 2.1 [W3C.CR-CSS21-20070719].\n+\t */\n+\tSTYLE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"style\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a phone number (format MAY follow E.123).\n+\t */\n+\tPHONE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"phone\"; }\n+\t},\n+\t\n+\t/**\n+\t * This value SHOULD be a URI..\n+\t */\n+\tURI {\n+\t\t@Override\n+\t\tpublic String toString() { return \"uri\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be an email address.\n+\t */\n+\tEMAIL {\n+\t\t@Override\n+\t\tpublic String toString() { return \"email\"; }\n+\t},\n+\t/**\n+\t * This SHOULD be an ip version 4 address.\n+\t */\n+\tIP_ADDRESS {\n+\t\t@Override\n+\t\tpublic String toString() { return \"ip-address\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be an ip version 6 address.\n+\t */\n+\tIPV6 {\n+\t\t@Override\n+\t\tpublic String toString() { return \"ipv6\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a host-name.\n+\t */\n+\tHOST_NAME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"host-name\"; }\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NullSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+/**\n+ * This class represents a {@link JsonSchema} as a null type\n+ * @author jphelan\n+ */\n+public class NullSchema extends SimpleTypeSchema {\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.NULL;\n+\t\n+\t@Override\n+\tpublic NullSchema asNullSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\treturn (obj instanceof NullSchema && super.equals(obj));\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\t@Override\n+\tpublic boolean isNullSchema() { return true; }\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents a {@link JsonSchema} as a number type\n+ * @author jphelan\n+ *\n+ */\n+public class NumberSchema extends ValueTypeSchema {\n+\t\n+\t/**\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"maximum\" attribute.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean exclusiveMaximum;\n+\t\n+\t/**\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"minimum\" attribute.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean exclusiveMinimum;\n+\t\n+\t/**This attribute defines the maximum value of the instance property*/\n+\t@JsonProperty\n+\tprivate Double maximum = null;\n+\t\n+\t/**This attribute defines the minimum value of the instance property*/\n+\t@JsonProperty\n+\tprivate Double minimum = null;\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.NUMBER;\n+\t\n+\t@Override\n+\tpublic NumberSchema asNumberSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof NumberSchema) {\n+\t\t\tNumberSchema that = (NumberSchema)obj;\n+\t\t\treturn getExclusiveMaximum() == null ? that.getExclusiveMaximum() == null :\n+\t\t\t\tgetExclusiveMaximum().equals(that.getExclusiveMaximum()) &&\n+\t\t\t\tgetExclusiveMinimum() == null ? that.getExclusiveMinimum() == null :\n+\t\t\t\t\tgetExclusiveMinimum().equals(that.getExclusiveMinimum()) &&\n+\t\t\t\tgetMaximum() == null ? that.getMaximum() == null :\n+\t\t\t\t\tgetMaximum().equals(that.getMaximum()) &&\n+\t\t\t\tgetMinimum() == null ? that.getMinimum() == null :\n+\t\t\t\t\tgetMinimum().equals(that.getMinimum()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n+\t/**\n+\t * {@link NumberSchema#exclusiveMaximum}\n+\t * @return the exclusiveMaximum\n+\t */\n+\tpublic Boolean getExclusiveMaximum() {\n+\t\treturn exclusiveMaximum;\n+\t}\n+\t\n+\t/**\n+\t * {@link NumberSchema#exclusiveMinimum}\n+\t * @return the exclusiveMinimum\n+\t */\n+\tpublic Boolean getExclusiveMinimum() {\n+\t\treturn exclusiveMinimum;\n+\t}\n+\t/**\n+\t * {@link NumberSchema#maximum}\n+\t * @return the maximum\n+\t */\n+\tpublic Double getMaximum() {\n+\t\treturn maximum;\n+\t}\n+\t/**\n+\t * {@link NumberSchema#minimum}\n+\t * @return the minimum\n+\t */\n+\tpublic Double getMinimum() {\n+\t\treturn minimum;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\t@Override\n+\tpublic boolean isNumberSchema() { return true; }\n+\t/**\n+\t * {@link NumberSchema#exclusiveMaximum}\n+\t * @param exclusiveMaximum the exclusiveMaximum to set\n+\t */\n+\tpublic void setExclusiveMaximum(Boolean exclusiveMaximum) {\n+\t\tthis.exclusiveMaximum = exclusiveMaximum;\n+\t}\n+\t/**\n+\t * {@link NumberSchema#exclusiveMinimum}\n+\t * @param exclusiveMinimum the exclusiveMinimum to set\n+\t */\n+\tpublic void setExclusiveMinimum(Boolean exclusiveMinimum) {\n+\t\tthis.exclusiveMinimum = exclusiveMinimum;\n+\t}\n+\n+\t/**\n+\t * {@link NumberSchema#maximum}\n+\t * @param maximum the maximum to set\n+\t */\n+\tpublic void setMaximum(Double maximum) {\n+\t\tthis.maximum = maximum;\n+\t}\n+\t\n+\t/**\n+\t * {@link NumberSchema#minimum}\n+\t * @param minimum the minimum to set\n+\t */\n+\tpublic void setMinimum(Double minimum) {\n+\t\tthis.minimum = minimum;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+/**\n+ * This type represents a {@link JsonSchema} as an object type\n+ * @author jphelan\n+ *\n+ */\n+public class ObjectSchema extends ContainerTypeSchema {\n+\n+\t/**\n+\t * This attribute defines a jsonSchema for all properties that are not\n+\t * explicitly defined in an object type definition. If specified, the value\n+\t * MUST be a jsonSchema or a boolean. If false is provided, no additional\n+\t * properties are allowed beyond the properties defined in the jsonSchema. The\n+\t * default value is an empty jsonSchema which allows any value for additional\n+\t * properties.\n+\t */\n+\t@JsonProperty\n+\tprivate AdditionalProperties additionalProperties;\n+\n+\t/**\n+\t * This attribute is an object that defines the requirements of a property\n+\t * on an instance object. If an object instance has a property with the same\n+\t * name as a property in this attribute's object, then the instance must be\n+\t * valid against the attribute's property value\n+\t */\n+\t@JsonProperty\n+\tprivate List<Dependency> dependencies;\n+\n+\t/**\n+\t * \n+\t This attribute is an object that defines the jsonSchema for a set of property\n+\t * names of an object instance. The name of each property of this\n+\t * attribute's object is a regular expression pattern in the ECMA 262/Perl 5\n+\t * format, while the value is a jsonSchema. If the pattern matches the name of a\n+\t * property on the instance object, the value of the instance's property\n+\t * MUST be valid against the pattern name's jsonSchema value.\n+\t */\n+\t@JsonProperty\n+\tprivate Map<String, JsonSchema> patternProperties;\n+\n+\t/**\n+\t * This attribute is an object with property definitions that define the\n+\t * valid values of instance object property values. When the instance value\n+\t * is an object, the property values of the instance object MUST conform to\n+\t * the property definitions in this object. In this object, each property\n+\t * definition's value MUST be a jsonSchema, and the property's name MUST be the\n+\t * name of the instance property that it defines. The instance property\n+\t * value MUST be valid according to the jsonSchema from the property definition.\n+\t * Properties are considered unordered, the order of the instance properties\n+\t * MAY be in any order.\n+\t */\n+\t@JsonProperty\n+\tprivate Map<String, JsonSchema> properties;\n+\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.OBJECT;\n+\n+\t// instance initializer block\n+\t{\n+\t\tdependencies = new ArrayList<Dependency>();\n+\t\tpatternProperties = new HashMap<String, JsonSchema>();\n+\t\tproperties = new HashMap<String, JsonSchema>();\n+\t}\n+\n+\tpublic boolean addSchemaDependency(String depender, JsonSchema parentMustMatch) {\n+\t\treturn dependencies\n+\t\t\t\t.add(new SchemaDependency(depender, parentMustMatch));\n+\t}\n+\n+\tpublic boolean addSimpleDependency(String depender, String dependsOn) {\n+\t\treturn dependencies.add(new SimpleDependency(depender, dependsOn));\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asObjectSchema()\n+\t */\n+\t@Override\n+\tpublic ObjectSchema asObjectSchema() {\n+\t\treturn this;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ObjectSchema) {\n+\t\t\tObjectSchema that = (ObjectSchema) obj;\n+\t\t\treturn getAdditionalProperties() == null ? that.getAdditionalProperties() == null :\n+\t\t\t\t\t\tgetAdditionalProperties().equals(that.getAdditionalProperties()) &&\n+\t\t\t\t\tgetDependencies() == null ? that.getDependencies() == null :\n+\t\t\t\t\t\tgetDependencies().equals(that.getDependencies()) &&\n+\t\t\t\t\tgetPatternProperties() == null ? that.getPatternProperties() == null :\n+\t\t\t\t\t\tgetPatternProperties().equals(that.getPatternProperties()) &&\n+\t\t\t\t\tgetProperties() == null ? that.getProperties() == null :\n+\t\t\t\t\t\tgetProperties().equals(that.getProperties()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\t\n+\t/**\n+\t * {@link ObjectSchema#additionalProperties}\n+\t * \n+\t * @return the additionalProperties\n+\t */\n+\tpublic AdditionalProperties getAdditionalProperties() {\n+\t\treturn additionalProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#dependencies}\n+\t * \n+\t * @return the dependencies\n+\t */\n+\tpublic List<Dependency> getDependencies() {\n+\t\treturn dependencies;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#patternProperties}\n+\t * \n+\t * @return the patternProperties\n+\t */\n+\tpublic Map<String, JsonSchema> getPatternProperties() {\n+\t\treturn patternProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#properties}\n+\t * \n+\t * @return the properties\n+\t */\n+\tpublic Map<String, JsonSchema> getProperties() {\n+\t\treturn properties;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isObjectSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isObjectSchema() {\n+\t\treturn true;\n+\t}\n+\n+\tpublic void putOptionalProperty(String name, JsonSchema jsonSchema) {\n+\t\tproperties.put(name, jsonSchema);\n+\t}\n+\n+\tpublic JsonSchema putPatternProperty(String regex, JsonSchema value) {\n+\t\treturn patternProperties.put(regex, value);\n+\t}\n+\n+\tpublic JsonSchema putProperty(String name, JsonSchema value) {\n+\t\tvalue.setRequired(true);\n+\t\treturn properties.put(name, value);\n+\t}\n+\n+\tpublic void rejectAdditionalProperties() {\n+\t\tadditionalProperties = NoAdditionalProperties.instance;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#additionalProperties}\n+\t * \n+\t * @param additionalProperties\n+\t *            the additionalProperties to set\n+\t */\n+\tpublic void setAdditionalProperties(\n+\t\t\tAdditionalProperties additionalProperties) {\n+\t\tthis.additionalProperties = additionalProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#dependencies}\n+\t * \n+\t * @param dependencies\n+\t *            the dependencies to set\n+\t */\n+\tpublic void setDependencies(List<Dependency> dependencies) {\n+\t\tthis.dependencies = dependencies;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#patternProperties}\n+\t * \n+\t * @param patternProperties\n+\t *            the patternProperties to set\n+\t */\n+\tpublic void setPatternProperties(Map<String, JsonSchema> patternProperties) {\n+\t\tthis.patternProperties = patternProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#properties}\n+\t * \n+\t * @param properties\n+\t *            the properties to set\n+\t */\n+\tpublic void setProperties(Map<String, JsonSchema> properties) {\n+\t\tthis.properties = properties;\n+\t}\n+\n+\tpublic static abstract class AdditionalProperties {\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic AdditionalProperties jsonCreator() {\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic static abstract class Dependency {\n+\t\t@JsonCreator\n+\t\tpublic Dependency jsonCreator() {\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic static class NoAdditionalProperties extends AdditionalProperties {\n+\t\tpublic final Boolean schema = false;\n+\n+\t\tprotected NoAdditionalProperties() {\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof NoAdditionalProperties;\n+\t\t}\n+\n+\t\t@JsonValue\n+\t\tpublic Boolean value() {\n+\t\t\treturn schema;\n+\t\t}\n+\n+\t\tpublic static final NoAdditionalProperties instance = new NoAdditionalProperties();\n+\t}\n+\n+\tpublic static class SchemaAdditionalProperties extends AdditionalProperties {\n+\n+\t\t@JsonProperty\n+\t\tprivate JsonSchema jsonSchema;\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SchemaAdditionalProperties &&\n+\t\t\t\t\tgetJsonSchema() == null ? ((SchemaAdditionalProperties)obj).getJsonSchema() == null :\n+\t\t\t\t\t\tgetJsonSchema().equals(((SchemaAdditionalProperties)obj).getJsonSchema());\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaAdditionalProperties#jsonSchema}\n+\t\t * @return the jsonSchema\n+\t\t */\n+\t\tpublic JsonSchema getJsonSchema() {\n+\t\t\treturn jsonSchema;\n+\t\t}\n+\t\t\n+\t\tpublic SchemaAdditionalProperties(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * JsonSchema Dependency If the dependency value is a jsonSchema, then the instance\n+\t * object MUST be valid against the jsonSchema.\n+\t */\n+\tpublic static class SchemaDependency extends Dependency {\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate String depender;\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate JsonSchema parentMustMatch;\n+\n+\t\tpublic SchemaDependency(String depender, JsonSchema parentMustMatch) {\n+\t\t\tthis.depender = depender;\n+\t\t\tthis.parentMustMatch = parentMustMatch;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof SchemaDependency) {\n+\t\t\t\tSchemaDependency that = (SchemaDependency) obj;\n+\t\t\t\treturn getDepender() == null ? that.getDepender() == null :\n+\t\t\t\t\t\tgetDepender().equals(that.getDepender()) &&\n+\t\t\t\t\tgetParentMustMatch() == null ? that.getParentMustMatch() == null :\n+\t\t\t\t\t\tgetParentMustMatch().equals(that.getParentMustMatch());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaDependency#depender}\n+\t\t * @return the depender\n+\t\t */\n+\t\tpublic String getDepender() {\n+\t\t\treturn depender;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaDependency#parentMustMatch}\n+\t\t * @return the parentMustMatch\n+\t\t */\n+\t\tpublic JsonSchema getParentMustMatch() {\n+\t\t\treturn parentMustMatch;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Simple Dependency If the dependency value is a string, then the instance\n+\t * object MUST have a property with the same name as the dependency value.\n+\t * If the dependency value is an array of strings, then the instance object\n+\t * MUST have a property with the same name as each string in the dependency\n+\t * value's array.\n+\t */\n+\tpublic static class SimpleDependency extends Dependency {\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate String depender;\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate String dependsOn;\n+\n+\t\tpublic SimpleDependency(String depender, String dependsOn) {\n+\t\t\tthis.depender = depender;\n+\t\t\tthis.dependsOn = dependsOn;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof SchemaDependency) {\n+\t\t\t\tSimpleDependency that = (SimpleDependency) obj;\n+\t\t\t\treturn getDepender() == null ? that.getDepender() == null :\n+\t\t\t\t\t\tgetDepender().equals(that.getDepender()) &&\n+\t\t\t\t\tgetDependsOn() == null ? that.getDependsOn() == null :\n+\t\t\t\t\t\tgetDependsOn().equals(that.getDependsOn());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SimpleDependency#depender}\n+\t\t * @return the depender\n+\t\t */\n+\t\tpublic String getDepender() {\n+\t\t\treturn depender;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SimpleDependency#dependsOn}\n+\t\t * @return the dependsOn\n+\t\t */\n+\t\tpublic String getDependsOn() {\n+\t\t\treturn dependsOn;\n+\t\t}\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SchemaType.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum SchemaType {\n+\t\n+\tSTRING,\n+\tNUMBER,\n+\tINTEGER,\n+\tBOOLEAN,\n+\tOBJECT,\n+\tARRAY,\n+\tNULL,\n+\tANY;\n+\t\n+\t\n+\t@JsonValue\n+\tpublic String value() {\n+\t\treturn this.name().toLowerCase();\n+\t}\n+\t\n+\t@JsonCreator\n+\tpublic static SchemaType forValue(String s) {\n+\t\treturn valueOf(s.toUpperCase());\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+\n+/**\n+ * This class encapsulates the functionality of {@link JsonSchema} simple types\n+ * @author jphelan\n+ *\n+ */\n+public abstract class SimpleTypeSchema extends JsonSchema {\n+\n+\t/**\n+\t * This attribute defines the default value of the instance when the\n+\t * instance is undefined.\n+\t */\n+\t@JsonIgnore\n+\tprivate String defaultdefault;\n+\t/**\n+\t * This attribute is a string that provides a full description of the of\n+\t * purpose the instance property.\n+\t */\n+\t@JsonProperty\n+\tprivate String description;\n+\t/**\n+\t * This attribute is a string that provides a short description of the\n+\t * instance property.\n+\t */\n+\t@JsonProperty\n+\tprivate String title;\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asSimpleTypeSchema()\n+\t */\n+\t@Override\n+\tpublic SimpleTypeSchema asSimpleTypeSchema() {\n+\t\treturn this;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof SimpleTypeSchema) {\n+\t\t\tSimpleTypeSchema that = (SimpleTypeSchema)obj;\n+\t\t\treturn getDefault() == null ? that.getDefault() == null :\n+\t\t\t\tgetDefault().equals(that.getDefault()) &&\n+\t\t\t\tgetDescription() == null ? that.getDescription() == null :\n+\t\t\t\t\tgetDescription().equals(that.getDescription()) &&\n+\t\t\t\tgetTitle() == null ? that.getTitle() == null :\n+\t\t\t\t\tgetTitle().equals(that.getTitle()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n+\t/**\n+\t * {@link SimpleTypeSchema#defaultdefault}\n+\t * \n+\t * @return the defaultdefault\n+\t */\n+\t@JsonGetter(\"default\")\n+\tpublic String getDefault() {\n+\t\treturn defaultdefault;\n+\t}\n+\n+\t/**\n+\t * {@link SimpleTypeSchema#description}\n+\t * \n+\t * @return the description\n+\t */\n+\tpublic String getDescription() {\n+\t\treturn description;\n+\t}\n+\n+\t/**\n+\t * {@link SimpleTypeSchema#title}\n+\t * \n+\t * @return the title\n+\t */\n+\tpublic String getTitle() {\n+\t\treturn title;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isSimpleTypeSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isSimpleTypeSchema() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@link SimpleTypeSchema#defaultdefault}\n+\t * \n+\t * @param defaultdefault\n+\t *            the defaultdefault to set\n+\t */\n+\t@JsonSetter(\"default\")\n+\tpublic void setDefault(String defaultdefault) {\n+\t\tthis.defaultdefault = defaultdefault;\n+\t}\n+\n+\t/**\n+\t * {@link SimpleTypeSchema#description}\n+\t * \n+\t * @param description\n+\t *            the description to set\n+\t */\n+\tpublic void setDescription(String description) {\n+\t\tthis.description = description;\n+\t}\n+\n+\t/**\n+\t * {@link SimpleTypeSchema#title}\n+\t * \n+\t * @param title\n+\t *            the title to set\n+\t */\n+\tpublic void setTitle(String title) {\n+\t\tthis.title = title;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This represents a {@link JsonSchema} as a String\n+ * @author jphelan\n+ *\n+ */\n+public class StringSchema extends ValueTypeSchema {\n+\n+\t/** this defines the maximum length of the string. */\n+\t@JsonProperty\n+\tprivate Integer maxLength;\n+\n+\t/** this defines the minimum length of the string. */\n+\t@JsonProperty\n+\tprivate Integer minLength;\n+\t/**\n+\t * this provides a regular expression that a string instance MUST match in\n+\t * order to be valid. Regular expressions SHOULD follow the regular\n+\t * expression specification from ECMA 262/Perl 5\n+\t */\n+\t@JsonProperty\n+\tprivate String pattern;\n+\t\n+\t@JsonIgnore\n+\tprivate final SchemaType type = SchemaType.STRING;\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asStringSchema()\n+\t */\n+\t@Override\n+\tpublic StringSchema asStringSchema() {\n+\t\treturn this;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof StringSchema) {\n+\t\t\tStringSchema that = (StringSchema)obj;\n+\t\t\treturn getMaxLength() == null ? that.getMaxLength() == null :\n+\t\t\t\tgetMaxLength().equals(that.getMaxLength()) &&\n+\t\t\t\tgetMinLength() == null ? that.getMinLength() == null :\n+\t\t\t\t\tgetMinLength().equals(that.getMinLength()) &&\n+\t\t\t\tgetPattern() == null ? that.getPattern() == null :\n+\t\t\t\t\tgetPattern().equals(that.getPattern()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\n+\t/**\n+\t * {@link StringSchema#maxLength}\n+\t * \n+\t * @return the maxLength\n+\t */\n+\tpublic Integer getMaxLength() {\n+\t\treturn maxLength;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#minLength}\n+\t * \n+\t * @return the minLength\n+\t */\n+\tpublic Integer getMinLength() {\n+\t\treturn minLength;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#pattern}\n+\t * \n+\t * @return the pattern\n+\t */\n+\tpublic String getPattern() {\n+\t\treturn pattern;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn type;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isStringSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isStringSchema() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#maxLength}\n+\t * \n+\t * @param maxLength\n+\t *            the maxLength to set\n+\t */\n+\tpublic void setMaxLength(Integer maxLength) {\n+\t\tthis.maxLength = maxLength;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#minLength}\n+\t * \n+\t * @param minLength\n+\t *            the minLength to set\n+\t */\n+\tpublic void setMinLength(Integer minLength) {\n+\t\tthis.minLength = minLength;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#pattern}\n+\t * \n+\t * @param pattern\n+\t *            the pattern to set\n+\t */\n+\tpublic void setPattern(String pattern) {\n+\t\tthis.pattern = pattern;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents a {@link JsonSchema} as a Union Type Schema:\n+ * \"An array of two or more simple type definitions.  Each\n+      item in the array MUST be a simple type definition or a schema.\n+      The instance value is valid if it is of the same type as one of\n+      the simple type definitions, or valid by one of the schemas, in\n+      the array.\"\n+\n+ * @author jphelan\n+ *\n+ */\n+public class UnionTypeSchema extends JsonSchema {\n+\n+\t@JsonProperty\n+\tprivate ValueTypeSchema[] elements;\n+\n+\t@Override\n+\tpublic UnionTypeSchema asUnionTypeSchema() {\n+\t\treturn this;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof UnionTypeSchema) {\n+\t\t\tUnionTypeSchema that = (UnionTypeSchema) obj;\n+\t\t\treturn getElements() == null ? that.getElements() == null :\n+\t\t\t\tgetElements().equals(that.getElements()) && \n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * {@link UnionTypeSchema#elements}\n+\t * \n+\t * @return the elements\n+\t */\n+\tpublic ValueTypeSchema[] getElements() {\n+\t\treturn elements;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n+\t */\n+\t@Override\n+\tpublic SchemaType getType() {\n+\t\treturn null;\n+\t}\n+\t\n+\t@Override\n+\tpublic boolean isUnionTypeSchema() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@link UnionTypeSchema#elements}\n+\t * \n+\t * @param elements\n+\t *            the elements to set\n+\t */\n+\tpublic void setElements(ValueTypeSchema[] elements) {\n+\t\tassert elements.length >= 2 : \"Union Type Schemas must contain two or more Simple Type Schemas\";\n+\t\tthis.elements = elements;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * This class represents a {@link JsonSchema} \n+ * A primitive type. \n+ */\n+public abstract class ValueTypeSchema extends SimpleTypeSchema {\n+\t\t\t\n+\t/**\n+\t * This provides an enumeration of all possible values that are valid\n+\t   for the instance property.  This MUST be an array, and each item in\n+\t   the array represents a possible value for the instance value.  If\n+\t   this attribute is defined, the instance value MUST be one of the\n+\t   values in the array in order for the schema to be valid.  Comparison\n+\t   of enum values uses the same algorithm as defined in \"uniqueItems\"\n+\t   (Section 5.15).\n+\t */\n+\t@JsonProperty\n+\tprivate Set<String> enums;\n+\t\n+\t/**\n+\t * This property defines the type of data, content type, or microformat to\n+\t * be expected in the instance property values. A format attribute MAY be\n+\t * one of the values listed below, and if so, SHOULD adhere to the semantics\n+\t * describing for the format. A format SHOULD only be used to give meaning\n+\t * to primitive types (string, integer, number, or boolean). Validators MAY\n+\t * (but are not required to) validate that the instance values conform to a\n+\t * format.\n+\t * \n+\t * Additional custom formats MAY be created. These custom formats MAY be\n+\t * expressed as an URI, and this URI MAY reference a schema of that\n+\t */\n+\t@JsonProperty\n+\tprivate JsonValueFormat format;\n+\t\n+\t//instance initializer block\n+\t{\n+\t\tenums = new HashSet<String>();\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asValueSchemaSchema()\n+\t */\n+\t@Override\n+\tpublic ValueTypeSchema asValueSchemaSchema() { return this; }\n+\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ValueTypeSchema) {\n+\t\t\tValueTypeSchema that = (ValueTypeSchema) obj;\n+\t\t\treturn getEnums() == null ? that.getEnums() == null :\n+\t\t\t\t\t\tgetEnums().equals(that.getEnums()) &&\n+\t\t\t\t\tgetFormat() == null ? that.getFormat() == null :\n+\t\t\t\t\t\tgetFormat().equals(that.getFormat()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t}\t\n+\t\treturn false;\n+\t}\n+\t\n+\t/**\n+\t * {@link ValueTypeSchema#enums}\n+\t * @return the enums\n+\t */\n+\tpublic Set<String> getEnums() {\n+\t\treturn enums;\n+\t}\n+\t/**\n+\t * {@link ValueTypeSchema#format}\n+\t * @return the format\n+\t */\n+\tpublic JsonValueFormat getFormat() {\n+\t\treturn format;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isValueTypeSchema()\n+\t */\n+\t@Override\n+\tpublic boolean isValueTypeSchema() { return true; }\n+\t\n+\t/**\n+\t * {@link ValueTypeSchema#enums}\n+\t * @param enums the enums to set\n+\t */\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n+\t\n+\t/**\n+\t * {@link ValueTypeSchema#format}\n+\t * @param format the format to set\n+\t */\n+\tpublic void setFormat(JsonValueFormat format) {\n+\t\tthis.format = format;\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n      * \tprocessing\n      *\n      */\n-    public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode,\n+    public void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor,\n     \t\tSerializerProvider provider);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n     \n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n-     * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n-     * given type.\n+\t\tTODO:fillme\n      *\n      * @param type The type for which to generate schema\n      */\n-    public JsonSchema generateJsonSchema(Class<?> type)\n+    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n         throws JsonMappingException\n     {\n         if (type == null) {\n          * type information it needs is accessible via \"untyped\" serializer)\n          */\n         JsonSerializer<Object> ser = findValueSerializer(type, null);\n-        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                ((SchemaAware) ser).getSchema(this, null) : \n-                JsonSchema.getDefaultSchemaNode();\n-        if (!(schemaNode instanceof ObjectNode)) {\n-            throw new IllegalArgumentException(\"Class \" + type.getName() +\n-                    \" would not be serialized as a JSON object and therefore has no schema\");\n-        }\n-        return new JsonSchema((ObjectNode) schemaNode);\n-    }\n-\n+        if (ser instanceof JsonFormatVisitorAware) {\n+        \t((JsonFormatVisitorAware) ser).acceptJsonFormatVisitor(visitor, constructType(type));\n+        } else {\n+        \tvisitor.expectAnyFormat(constructType(type));\n+        }\n+    }\n     /**\n      * Method that can be called to see if this serializer provider\n      * can find a serializer for an instance of given class.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n /**\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return null;\n+        ;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n         \n     }\n \n-    @Override protected JsonNode contentSchema() {\n-        return createSchemaNode(\"string\", true);\n-    }\n+\t@Override\n+\tprotected void acceptContentVisitor(JsonArrayFormatVisitor visitor) {\n+\t\tvisitor.itemsFormat(SchemaType.STRING);\n+\t\t\n+\t}\n \n     /*\n     /**********************************************************\n             wrapAndThrow(provider, e, value, i);\n         }\n     }\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n \t\t}\n \t\t\n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n+\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n \t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n \t\t\t}\n \t\t}\n \t}\n \t\t}\n \n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n+\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n \t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n \t\t\t}\n \t\t}\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        ObjectNode o = createSchemaNode(\"array\", true);\n-        o.put(\"items\", createSchemaNode(\"string\"));\n-        return o;\n+    \tvisitor.expectArrayFormat(null).itemsFormat(SchemaType.STRING);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n         _serializer = (JsonSerializer<String>) ser;\n     }        \n     \n-    @Override protected JsonNode contentSchema() {\n-        return createSchemaNode(\"string\", true);\n-    }\n+\t@Override\n+\tprotected void acceptContentVisitor(JsonArrayFormatVisitor visitor) {\n+\t\tvisitor.itemsFormat(SchemaType.STRING);\n+\t\t\n+\t}\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n-        return null;\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) { \n+    \tvisitor.expectAnyFormat(typeHint);\n     }\n \n     protected void failForEmpty(Object value) throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n \n /**\n  * Intermediate base class for serializers used for various\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n         throws IOException, JsonGenerationException;\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         /* 15-Jan-2010, tatu: This should probably be rewritten, given that\n          *    more information about content type is actually being explicitly\n          *    passed. So there should be less need to try to re-process that\n          *    information.\n          */\n-        ObjectNode o = createSchemaNode(\"array\", true);\n+        //ObjectNode o = createSchemaNode(\"array\", true);\n+        JsonArrayFormatVisitor arrayVisitor = \n+        \t\tvisitor.expectArrayFormat(typeHint);\n         JavaType contentType = null;\n         if (typeHint != null) {\n-            JavaType javaType = provider.constructType(typeHint);\n-            contentType = javaType.getContentType();\n+            contentType = typeHint.getContentType();\n             if (contentType == null) { // could still be parametrized (Iterators)\n                 if (typeHint instanceof ParameterizedType) {\n                     Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n                     if (typeArgs.length == 1) {\n-                        contentType = provider.constructType(typeArgs[0]);\n+                        contentType = visitor.getProvider().constructType(typeArgs[0]);\n                     }\n                 }\n             }\n         }\n         if (contentType != null) {\n             JsonNode schemaNode = null;\n-            // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n-            if (contentType.getRawClass() != Object.class) {\n-                JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property);\n-                if (ser instanceof SchemaAware) {\n-                    schemaNode = ((SchemaAware) ser).getSchema(provider, null);\n-                }\n-            }\n-            if (schemaNode == null) {\n-                schemaNode = JsonSchema.getDefaultSchemaNode();\n-            }\n-            o.put(\"items\", schemaNode);\n-        }\n-        return o;\n+            arrayVisitor.itemsFormat(contentType);\n+        }\n     }\n \n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.AnyGetterWriter;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerBuilder;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n public abstract class BeanSerializerBase\n     extends StdSerializer<Object>\n     implements ContextualSerializer, ResolvableSerializer,\n-        SchemaAware\n+        JsonFormatVisitorAware\n {\n     final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n \n         return filter;\n     }\n     \n-    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        ObjectNode o = createSchemaNode(\"object\", true);\n-        // [JACKSON-813]: Add optional JSON Schema id attribute, if found\n-        // NOTE: not optimal, does NOT go through AnnotationIntrospector etc:\n-        JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class);\n-        if (ann != null) {\n-            String id = ann.id();\n-            if (id != null && id.length() > 0) {\n-                o.put(\"id\", id);\n-            }\n-        }\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+    \t//deposit your output format \n+    \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n  \n-        //todo: should the classname go in the title?\n-        //o.put(\"title\", _className);\n-        ObjectNode propertiesNode = o.objectNode();\n-        final BeanPropertyFilter filter;\n         if (_propertyFilterId != null) {\n-        \tfilter = findFilter(provider);\n-        } else {\n-        \tfilter = null;\n-        }\n+        \ttry {\n+        \t\tBeanPropertyFilter filter = findFilter(visitor.getProvider());\n+\t\t\t\tfor (int i = 0; i < _props.length; i++) {\n+\t\t            BeanPropertyWriter prop = _props[i];\n+\t\t            filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n+\t\t        }\n+\t\t\t\treturn;\n+\t\t\t} catch (JsonMappingException e) {\n+\t\t\t\t// TODO Auto-generated catch block\n+\n+\t\t\t}\n+        } \n         \t\t\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n-            if (filter != null) {\n-            \tfilter.depositSchemaProperty(prop, propertiesNode, provider);\n-            \t continue;\n-            }\n-            depositSchemaProperty(prop, propertiesNode, provider);\n-\n-        }\n-        o.put(\"properties\", propertiesNode);\n-        return o;\n-    }\n-\n-    /**\n+\n+            JavaType propType = prop.getSerializationType();\n+            BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);\n+        }\n+    }\n+\n+    /**\n+\t * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n+\t * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n+\t * \n+\t * @param writer Bean property serializer to use to create schema value\n+     * @param propertiesNode Node which the given property would exist within\n+\t */\n+\tpublic static void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor) {\n+\t\tif (isPropertyRequired(writer, objectVisitor.getProvider())) {\n+\t\t\tobjectVisitor.property(writer); \n+\t\t} else {\n+\t\t\tobjectVisitor.optionalProperty(writer);\n+\t\t}\n+\t}\n+\n+\t/**\n      * Determines if a bean property is required, as determined by\n      * {@link com.fasterxml.jackson.databind.AnnotationIntrospector#hasRequiredMarker}.\n      *<p>\n         return (value == null) ? false : value.booleanValue();\n     }\n     \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n-     * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param propertiesNode Node which the given property would exist within\n-     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n-     * \tprocessing\n-     * \t\n-     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider)\n-    {\n-        JavaType propType = writer.getSerializationType();\n-\n-        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n-        Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n-        JsonNode schemaNode;\n-        // Maybe it already has annotated/statically configured serializer?\n-        JsonSerializer<Object> ser = writer.getSerializer();\n-\n-        try {\n-            if (ser == null) { // nope\n-                Class<?> serType = writer.getRawSerializationType();\n-                if (serType == null) {\n-                    serType = writer.getPropertyType();\n-                }\n-                ser = provider.findValueSerializer(serType, writer);\n-            }\n-            boolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n-            if (ser instanceof SchemaAware) {\n-                schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n-            } else {  \n-                schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            }\n-        } catch (JsonMappingException e) {\n-            schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            // TODO: handle in better way (why not throw?)\n-        }\n-        propertiesNode.put(writer.getName(), schemaNode);\n-    }\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * Serializer used for primitive boolean, as well as java.util.Boolean\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"boolean\", !_forPrimitive);\n+        visitor.expectBooleanFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import java.text.DateFormat;\n import java.util.Calendar;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n import java.util.Collection;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n \n import java.io.IOException;\n import java.text.DateFormat;\n-import java.util.*;\n+import java.util.Date;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.Locale;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n \n     protected abstract long _timestamp(T value);\n     \n-    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         //todo: (ryan) add a format for the date in the schema?\n         boolean asNumber = _useTimestamp;\n         if (!asNumber) {\n             if (_customFormat == null) {\n-                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+                asNumber = visitor.getProvider().isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n             }\n         }\n-        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n+        if (asNumber) {\n+        \tvisitor.expectNumberFormat(typeHint).format(JsonValueFormat.UTC_MILLISEC);\n+        } else {\n+        \tvisitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n+        }\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.io.IOException;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.util.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n-\n-import com.fasterxml.jackson.databind.*;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        ObjectNode o = createSchemaNode(\"object\", true);\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+    \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n         if (typeHint instanceof ParameterizedType) {\n             Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n             if (typeArgs.length == 2) {\n-                JavaType enumType = provider.constructType(typeArgs[0]);\n-                JavaType valueType = provider.constructType(typeArgs[1]);\n+                JavaType enumType = visitor.getProvider().constructType(typeArgs[0]);\n+                JavaType valueType = visitor.getProvider().constructType(typeArgs[1]);\n                 ObjectNode propsNode = JsonNodeFactory.instance.objectNode();\n                 Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n                 for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n-                    JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property);\n-                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                            ((SchemaAware) ser).getSchema(provider, null) :\n-                            JsonSchema.getDefaultSchemaNode();\n-                    propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue), schemaNode);\n-                }\n-                o.put(\"properties\", propsNode);\n-            }\n-        }\n-        return o;\n+                \tJsonSerializer<Object> ser;\n+                \tString name = visitor.getProvider().getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue);\n+                \ttry {\n+                \t\tser = visitor.getProvider().findValueSerializer(valueType.getRawClass(), _property);\n+                \t\tif (ser instanceof JsonFormatVisitorAware)  {\n+                \t\t\tobjectVisitor.property(name, (JsonFormatVisitorAware) ser, valueType);\n+                \t\t} \n+                \t\tcontinue;\n+                \t} catch (JsonMappingException e) {\n+                \t\t//TODO: log error\n+                \t}\n+                \tobjectVisitor.property(name);\n+                }\n+            }\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n-import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n-\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (_serializeAsIndex(provider)) {\n-            return createSchemaNode(\"integer\", true);\n-        }\n-        ObjectNode objectNode = createSchemaNode(\"string\", true);\n-        if (typeHint != null) {\n-            JavaType type = provider.constructType(typeHint);\n-            if (type.isEnumType()) {\n-                ArrayNode enumNode = objectNode.putArray(\"enum\");\n-                for (SerializedString value : _values.values()) {\n-                    enumNode.add(value.getValue());\n-                }\n-            }\n-        }\n-        return objectNode;\n+    \tif (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+    \t\tvisitor.expectIntegerFormat(typeHint);\n+    \t} else {\n+    \t\tJsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);\n+    \t\tif (typeHint != null) {\n+    \t\t\tif (typeHint.isEnumType()) {\n+    \t\t\t\tSet<String> enums = new HashSet<String>();\n+    \t\t\t\tfor (SerializedString value : _values.values()) {\n+    \t\t\t\t\tenums.add(value.getValue());\n+    \t\t\t\t}\n+    \t\t\t\tstringVisitor.enumTypes(enums);\n+    \t\t\t}\n+    \t\t}\n+    \t}\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n import java.io.IOException;\n import java.util.EnumSet;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n public class EnumSetSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n import java.io.IOException;\n import java.net.InetAddress;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-\n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n @JacksonStdImpl\n public class JsonValueSerializer\n     extends StdSerializer<Object>\n-    implements ContextualSerializer, SchemaAware\n+    implements ContextualSerializer, JsonFormatVisitorAware\n {\n     protected final Method _accessorMethod;\n \n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        return (_valueSerializer instanceof SchemaAware) ?\n-                ((SchemaAware) _valueSerializer).getSchema(provider, null) :\n-                JsonSchema.getDefaultSchemaNode();\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+    \tif (_valueSerializer instanceof JsonFormatVisitorAware) {\n+    \t\t((JsonFormatVisitorAware) _valueSerializer).acceptJsonFormatVisitor(visitor, null); \n+    \t} else {\n+    \t\tvisitor.expectAnyFormat(typeHint);\n+    \t}\n     }\n \n     protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n-\n-import com.fasterxml.jackson.databind.*;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n-        ObjectNode o = createSchemaNode(\"object\", true);\n-        //(ryan) even though it's possible to statically determine the \"value\" type of the map,\n-        // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n-        return o;\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+    \tvisitor.expectObjectFormat(null);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import java.lang.reflect.Type;\n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * This is a simple dummy serializer that will just output literal\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"null\");\n+    \tvisitor.expectNullFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Map;\n \n-import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"integer\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectIntegerFormat(typeHint);\n         }\n     }\n \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"integer\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectIntegerFormat(typeHint);\n         }\n     }\n \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectNumberFormat(typeHint);\n         }\n     }\n     \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectNumberFormat(typeHint);\n         }\n     }\n \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectNumberFormat(typeHint);\n         }\n     }\n     \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectNumberFormat(typeHint);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Type;\n-\n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n-import com.fasterxml.jackson.databind.type.ArrayType;\n \n /**\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        ObjectNode o = createSchemaNode(\"array\", true);\n-        if (typeHint != null) {\n-            JavaType javaType = provider.constructType(typeHint);\n-            if (javaType.isArrayType()) {\n-                Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass();\n-                // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n-                if (componentType == Object.class) {\n-                    o.put(\"items\", JsonSchema.getDefaultSchemaNode());\n-                } else {\n-                    JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property);\n-                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                            ((SchemaAware) ser).getSchema(provider, null) :\n-                            JsonSchema.getDefaultSchemaNode();\n-                    o.put(\"items\", schemaNode);\n-                }\n-            }\n-        }\n-        return o;\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+    \tvisitor.expectArrayFormat(typeHint).itemsFormat(_elementType);\n     }\n \n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import java.lang.reflect.Type;\n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        // type not really known, but since it is a JSON string:\n-        return createSchemaNode(\"string\", true);\n+        visitor.expectStringFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import com.fasterxml.jackson.core.*;\n-\n-\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Generic handler for types that implement {@link JsonSerializable}.\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        ObjectNode objectNode = createObjectNode();\n-        String schemaType = \"any\";\n-        String objectProperties = null;\n-        String itemDefinition = null;\n-        if (typeHint != null) {\n-            Class<?> rawClass = TypeFactory.rawClass(typeHint);\n-            if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n-                JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n-                schemaType = schemaInfo.schemaType();\n-                if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) {\n-                    objectProperties = schemaInfo.schemaObjectPropertiesDefinition();\n-                }\n-                if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) {\n-                    itemDefinition = schemaInfo.schemaItemDefinition();\n-                }\n-            }\n-        }\n-        /* 19-Mar-2012, tatu: geez, this is butt-ugly abonimation of code...\n-         *    really, really should not require back ref to an ObjectMapper.\n-         */\n-        objectNode.put(\"type\", schemaType);\n-        if (objectProperties != null) {\n-            try {\n-                objectNode.put(\"properties\", _getObjectMapper().readTree(objectProperties));\n-            } catch (IOException e) {\n-                throw new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value\");\n-            }\n-        }\n-        if (itemDefinition != null) {\n-            try {\n-                objectNode.put(\"items\", _getObjectMapper().readTree(itemDefinition));\n-            } catch (IOException e) {\n-                throw new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaItemDefinition value\");\n-            }\n-        }\n-        // always optional, no need to specify:\n-        //objectNode.put(\"required\", false);\n-        return objectNode;\n+    \tvisitor.expectAnyFormat(typeHint);\n     }\n-    \n-    private final static synchronized ObjectMapper _getObjectMapper()\n-    {\n-        ObjectMapper mapper = _mapperReference.get();\n-        if (mapper == null) {\n-            mapper = new ObjectMapper();\n-            _mapperReference.set(mapper);\n-        }\n-        return mapper;\n     }\n-}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n \n /**\n  * Compared to regular {@link java.util.Date} serialization, we do use String\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        //todo: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(\"string\", true);\n+    \tvisitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n \n @JacksonStdImpl\n public class SqlTimeSerializer\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"string\", true);\n+    \tvisitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import java.lang.reflect.Type;\n-import java.util.*;\n+import java.util.Collection;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * Intermediate base class for Lists, Collections and Arrays\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        ObjectNode o = createSchemaNode(\"array\", true);\n-        o.put(\"items\", contentSchema());\n-        return o;\n+    \tacceptContentVisitor(visitor.expectArrayFormat(typeHint));\n     }\n \n     /*\n     /**********************************************************\n      */\n \n-    protected abstract JsonNode contentSchema();    \n+    protected abstract void acceptContentVisitor(JsonArrayFormatVisitor visitor);    \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.HashMap;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"boolean\"));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.BOOLEAN);\n         }\n     }\n \n         }\n         \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            ObjectNode itemSchema = createSchemaNode(\"string\"); //binary values written as strings?\n-            o.put(\"items\", itemSchema);\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.STRING);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            //no \"short\" type defined by json\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"integer\"));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.INTEGER);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            ObjectNode itemSchema = createSchemaNode(\"string\");\n-            itemSchema.put(\"type\", \"string\");\n-            o.put(\"items\", itemSchema);\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.STRING);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"integer\"));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.INTEGER);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\", true));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\"));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\"));\n-            return o;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer;\n import com.fasterxml.jackson.databind.ser.impl.IteratorSerializer;\n-import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n \n /**\n  * Dummy container class to group standard container serializers: serializers\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import java.io.*;\n-import java.lang.reflect.Type;\n-import java.util.*;\n-import java.util.concurrent.atomic.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;\n import com.fasterxml.jackson.databind.util.Provider;\n \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"boolean\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectBooleanFormat(typeHint);\n         }\n     }\n     \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"integer\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectIntegerFormat(typeHint);\n         }\n     }\n \n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"integer\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectIntegerFormat(typeHint);\n         }\n     }\n     \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"any\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectAnyFormat(typeHint);\n         }\n     }\n     \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"string\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectStringFormat(typeHint);\n         }\n     }\n \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"string\", true);\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        {\n+        \tvisitor.expectStringFormat(typeHint);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.Date;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * Specialized serializer that can be used as the generic key\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"string\");\n+    \tvisitor.expectStringFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n import java.util.Calendar;\n import java.util.Date;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n public abstract class StdScalarSerializer<T>\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"string\", true);\n+        visitor.expectAnyFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n-import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * Base class used by all standard serializers, and can also\n  * be used for custom serializers (in fact, this is the recommended\n  * base class to use).\n- * Provides convenience methods for implementing {@link SchemaAware}\n+ * Provides convenience methods for implementing {@link JsonFormatVisitorAware}\n  */\n public abstract class StdSerializer<T>\n     extends JsonSerializer<T>\n-    implements SchemaAware\n+    implements JsonFormatVisitorAware\n {\n     /**\n      * Nominal type supported, usually declared type of\n \n     /*\n     /**********************************************************\n-    /* Helper methods for JSON Schema generation\n+    /* Helper methods for JSON JsonSchema generation\n     /**********************************************************\n      */\n     \n     /**\n-     * Default implementation simply claims type is \"string\"; usually\n+     * Default implementation specifies no format. This behavior is usually\n      * overriden by custom serializers.\n      */\n //  @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        return createSchemaNode(\"string\");\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) { \n+    \tvisitor.expectAnyFormat(typeHint);\n     }\n-    \n-    /**\n-     * Default implementation simply claims type is \"string\"; usually\n-     * overriden by custom serializers.\n-     */\n-//    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n-        throws JsonMappingException\n-    {\n-    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n-    \tif (!isOptional) {\n-    \t\tschema.put(\"required\", !isOptional);\n-    \t}\n-        return schema;\n-    }\n-    \n-    protected ObjectNode createObjectNode() {\n-        return JsonNodeFactory.instance.objectNode();\n-    }\n-    \n-    protected ObjectNode createSchemaNode(String type)\n-    {\n-        ObjectNode schema = createObjectNode();\n-        schema.put(\"type\", type);\n-        return schema;\n-    }\n-    \n-    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n-    {\n-        ObjectNode schema = createSchemaNode(type);\n-        // as per [JACKSON-563]. Note that 'required' defaults to false\n-        if (!isOptional) {\n-            schema.put(\"required\", !isOptional);\n-        }\n-        return schema;\n-    }\n-    \n+            \n     /*\n     /**********************************************************\n     /* Helper methods for exception handling\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n /**\n  * This is the special serializer for regular {@link java.lang.String}s.\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"string\", true);\n+    \tvisitor.expectStringFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n import java.io.IOException;\n import java.util.TimeZone;\n \n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n-        return createSchemaNode(\"string\", true);\n+    \tvisitor.expectStringFormat(typeHint);\n     }\n     \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         /* 01-Jan-2010, tatu: Not 100% sure what we should say here:\n          *   type is basically not known. This seems closest\n          *   approximation\n          */\n-        return createSchemaNode(\"any\", true);\n+    \tvisitor.expectAnyFormat(typeHint);\n     }\n }    \n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n+import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactoryProvider;\n+import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n         private String property2;\n         private String[] property3;\n         private Collection<Float> property4;\n-        @JsonProperty(required=true)\n+        @JsonProperty(required = true)\n         private String property5;\n         \n         public int getProperty1()\n         public String name;\n     }\n \n-    @JsonSerializableSchema(id=\"myType\")\n+    //@JsonSerializableSchema(id=\"myType\")\n     public class BeanWithId {\n         public String value;\n     }\n     public void testGeneratingJsonSchema()\n         throws Exception\n     {\n-        JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+        ObjectMapper m = new ObjectMapper();\n+        SchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        m.acceptJsonFormatVisitor(SimpleBean.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n         \n         assertNotNull(jsonSchema);\n \n         assertFalse(jsonSchema.equals(null));\n         assertFalse(jsonSchema.equals(\"foo\"));\n \n-        // other basic things\n-        assertNotNull(jsonSchema.toString());\n-        assertNotNull(JsonSchema.getDefaultSchemaNode());\n-\n-\tObjectNode root = jsonSchema.getSchemaNode();\n-        assertEquals(\"object\", root.get(\"type\").asText());\n-        assertEquals(false, root.path(\"required\").booleanValue());\n-        JsonNode propertiesSchema = root.get(\"properties\");\n-        assertNotNull(propertiesSchema);\n-        JsonNode property1Schema = propertiesSchema.get(\"property1\");\n-        assertNotNull(property1Schema);\n-        assertEquals(\"integer\", property1Schema.get(\"type\").asText());\n-        assertEquals(false, property1Schema.path(\"required\").booleanValue());\n-        JsonNode property2Schema = propertiesSchema.get(\"property2\");\n-        assertNotNull(property2Schema);\n-        assertEquals(\"string\", property2Schema.get(\"type\").asText());\n-        assertEquals(false, property2Schema.path(\"required\").booleanValue());\n-        JsonNode property3Schema = propertiesSchema.get(\"property3\");\n-        assertNotNull(property3Schema);\n-        assertEquals(\"array\", property3Schema.get(\"type\").asText());\n-        assertEquals(false, property3Schema.path(\"required\").booleanValue());\n-        assertEquals(\"string\", property3Schema.get(\"items\").get(\"type\").asText());\n-        JsonNode property4Schema = propertiesSchema.get(\"property4\");\n-        assertNotNull(property4Schema);\n-        assertEquals(\"array\", property4Schema.get(\"type\").asText());\n-        assertEquals(false, property4Schema.path(\"required\").booleanValue());\n-        assertEquals(\"number\", property4Schema.get(\"items\").get(\"type\").asText());\n+        assertTrue(jsonSchema.isObjectSchema());\n+        ObjectSchema object = jsonSchema.asObjectSchema();\n+        assertNotNull(object);\n+        Map<String,JsonSchema> properties = object.getProperties();\n+        assertNotNull(properties);\n+        JsonSchema prop1 = properties.get(\"property1\");\n+        assertNotNull(prop1);\n+        assertTrue(prop1.isIntegerSchema());\n+        assertNull(prop1.getRequired());\n+        \n+        JsonSchema prop2 = properties.get(\"property2\");\n+        assertNotNull(prop2);\n+        assertTrue(prop2.isStringSchema());\n+        assertNull(prop2.getRequired());\n+        \n+        JsonSchema prop3 = properties.get(\"property3\");\n+        assertNotNull(prop3);\n+        assertTrue(prop3.isArraySchema());\n+        assertNull(prop3.getRequired());\n+        Items items = prop3.asArraySchema().getItems();\n+        assertTrue(items.isSingleItems());\n+        JsonSchema itemType = items.asSingleItems().getSchema();\n+        assertNotNull(itemType);\n+        assertTrue(itemType.isStringSchema());\n+        \n+        JsonSchema prop4 = properties.get(\"property4\");\n+        assertNotNull(prop4);\n+        assertTrue(prop4.isArraySchema());\n+        assertNull(prop4.getRequired());\n+        items = prop4.asArraySchema().getItems();\n+        assertTrue(items.isSingleItems());\n+        itemType = items.asSingleItems().getSchema();\n+        assertNotNull(itemType);\n+        assertTrue(itemType.isNumberSchema());\n+        \n+        JsonSchema prop5 = properties.get(\"property5\");\n+        assertNotNull(prop5);\n+        assertTrue(prop5.getRequired());\n+      \n     }\n     \n     @JsonFilter(\"filteredBean\")\n     public void testGeneratingJsonSchemaWithFilters() throws Exception {\n     \tObjectMapper mapper = new ObjectMapper();\n     \tmapper.setFilters(secretFilterProvider);\n-    \tJsonSchema schema = mapper.generateJsonSchema(FilteredBean.class);\n-    \tJsonNode node = schema.getSchemaNode().get(\"properties\");\n-    \tassertTrue(node.has(\"obvious\"));\n-    \tassertFalse(node.has(\"secret\"));\n+    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        mapper.acceptJsonFormatVisitor(FilteredBean.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n+    \tassertNotNull(jsonSchema);\n+    \tassertTrue(jsonSchema.isObjectSchema());\n+    \tObjectSchema object = jsonSchema.asObjectSchema();\n+    \tassertNotNull(object);\n+    \tMap<String, JsonSchema> properties = object.getProperties();\n+    \tassertNotNull(properties);\n+    \tJsonSchema obvious = properties.get(\"obvious\");\n+    \tassertNotNull(obvious);\n+    \tassertTrue(obvious.isStringSchema());\n+    \tassertNull(properties.get(\"secret\"));\n     }\n \n     /**\n     public void testSchemaSerialization()\n             throws Exception\n     {\n-        JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n-\tMap<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n-\tassertNotNull(result);\n-\t// no need to check out full structure, just basics...\n-\tassertEquals(\"object\", result.get(\"type\"));\n-\t// only add 'required' if it is true...\n-\tassertNull(result.get(\"required\"));\n-\tassertNotNull(result.get(\"properties\"));\n+    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        MAPPER.acceptJsonFormatVisitor(SimpleBean.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n+        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n+        assertNotNull(result);\n+        // no need to check out full structure, just basics...\n+        assertEquals(\"object\", result.get(\"type\"));\n+        // only add 'required' if it is true...\n+        assertNull(result.get(\"required\"));\n+        assertNotNull(result.get(\"properties\"));\n     }\n \n     public void testInvalidCall()\n     {\n         // not ok to pass null\n         try {\n-            MAPPER.generateJsonSchema(null);\n+        \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+            MAPPER.acceptJsonFormatVisitor(null, visitor);\n+            JsonSchema jsonSchema = visitor.finalSchema();\n             fail(\"Should have failed\");\n         } catch (IllegalArgumentException iae) {\n             verifyException(iae, \"class must be provided\");\n      */\n     public void testThatObjectsHaveNoItems() throws Exception\n     {\n-        JsonSchema jsonSchema = MAPPER.generateJsonSchema(TrivialBean.class);\n-        String json = jsonSchema.toString().replaceAll(\"\\\"\", \"'\");\n+    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        MAPPER.acceptJsonFormatVisitor(TrivialBean.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n+        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n         // can we count on ordering being stable? I think this is true with current ObjectNode impl\n         // as perh [JACKSON-563]; 'required' is only included if true\n-        assertEquals(\"{'type':'object','properties':{'name':{'type':'string'}}}\",\n-                json);\n-    }\n-\n-    public void testSchemaId() throws Exception\n-    {\n-        JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class);\n-        String json = jsonSchema.toString().replaceAll(\"\\\"\", \"'\");\n-        assertEquals(\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\",\n-                json);\n+        assertFalse(result.containsKey(\"items\"));\n+\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\", \"serial\" })\n+\tpublic void testSchemaId() throws Exception\n+    {\n+    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        MAPPER.acceptJsonFormatVisitor(BeanWithId.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n+        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n+        \n+        assertEquals(new HashMap() {{ \n+        \tput(\"type\", \"object\");\n+        \tput(\"properties\", \n+        \t\t\tnew HashMap(){{ put(\"value\", \n+        \t\t\t\t\tnew HashMap() {{ put(\"type\", \"string\");}}\n+        \t\t\t);}}\n+        \t);}}, result);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n+import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactoryProvider;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n \n /**\n  * Trivial test to ensure {@link JsonSchema} can be also deserialized\n     public void testDeserializeSimple() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        JsonSchema schema = mapper.generateJsonSchema(Schemable.class);\n-        assertNotNull(schema);\n+        SchemaFactoryProvider visitor = new SchemaFactoryProvider();\n+        mapper.acceptJsonFormatVisitor(Schemable.class, visitor);\n+        JsonSchema jsonSchema = visitor.finalSchema();\n+        assertNotNull(jsonSchema);\n \n-        String schemaStr = mapper.writeValueAsString(schema);\n+        String schemaStr = mapper.writeValueAsString(jsonSchema);\n         assertNotNull(schemaStr);\n         JsonSchema result = mapper.readValue(schemaStr, JsonSchema.class);\n-        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", schema, result);\n+        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", jsonSchema, result);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n package com.fasterxml.jackson.databind.module;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.util.*;\n \n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.module.SimpleSerializers;\n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n-            return null;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {\n+            visitor.expectAnyFormat(typeHint);\n         }\n     }\n     \n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n-            return null;\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {\n+            visitor.expectAnyFormat(typeHint);\n         }\n     }\n ", "timestamp": 1344732982, "metainfo": ""}