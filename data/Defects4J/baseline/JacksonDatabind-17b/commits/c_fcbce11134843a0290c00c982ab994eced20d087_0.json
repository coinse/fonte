{"sha": "fcbce11134843a0290c00c982ab994eced20d087", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n     \n     /*\n     /******************************************************\n-     *  Structural conversion features\n+    /* Structural conversion features\n     /******************************************************\n      */\n \n      * \n      * @since 2.0\n      */\n-    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false)\n+    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false),\n+\n+    /*\n+    /******************************************************\n+    /* Other\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether {@link ObjectReader} should\n+     * try to eagerly fetch necessary {@link JsonDeserializer} when\n+     * possible. This improves performance in cases where similarly\n+     * configured {@link ObjectReader} instance is used multiple\n+     * times; and should not significantly affect single-use cases.\n+     *<p>\n+     * Note that there should not be any need to normally disable this\n+     * feature: only consider that if there are actual perceived problems.\n+     *<p>\n+     * Feature is enabled by default.\n+     * \n+     * @since 2.1\n+     */\n+    EAGER_DESERIALIZER_FETCH(true)\n+    \n     ;\n \n     private final boolean _defaultState;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     protected final JavaType _valueType;\n \n     /**\n+     * We will find and (re)use deserializer as soon as {@link #_valueType}\n+     * is known; this allows avoiding further deserializer lookups\n+     * when readers are reused.\n+     * \n+     * @since 2.1\n+     */\n+    protected final JsonDeserializer<Object> _rootDeserializer;\n+    \n+    /**\n      * Instance to update with data binding; if any. If null,\n      * a new instance is created, if non-null, properties of\n      * this value object will be updated instead.\n         this(mapper, config, null, null, null, null);\n     }\n \n+    /**\n+     * Constructor called when a root deserializer should be fetched based\n+     * on other configuration.\n+     */\n     protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n-            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n-            InjectableValues injectableValues)\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues)\n     {\n         _config = config;\n         _context = mapper._deserializationContext;\n         _schema = schema;\n         _injectableValues = injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n+\n+        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n     }\n     \n     /**\n      * Copy constructor used for building variations.\n      */\n     protected ObjectReader(ObjectReader base, DeserializationConfig config,\n-            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n-            InjectableValues injectableValues)\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues)\n     {\n         _config = config;\n         _context = base._context;\n         _rootNames = base._rootNames;\n \n         _valueType = valueType;\n+        _rootDeserializer = rootDeser;\n         _valueToUpdate = valueToUpdate;\n         if (valueToUpdate != null && valueType.isArrayType()) {\n             throw new IllegalArgumentException(\"Can not update an array value\");\n         _rootNames = base._rootNames;\n \n         _valueType = base._valueType;\n+        _rootDeserializer = base._rootDeserializer;\n         _valueToUpdate = base._valueToUpdate;\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n     }\n-    \n+\n     /**\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues);\n     }\n \n         if (_schema == schema) {\n             return this;\n         }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues);\n     }\n     \n     public ObjectReader withType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) return this;\n+        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n         // type is stored here, no need to make a copy of config\n-        return new ObjectReader(this, _config, valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                valueType, rootDeser, _valueToUpdate,\n                 _schema, _injectableValues);\n     }    \n \n         if (value == null) {\n             throw new IllegalArgumentException(\"cat not update null value\");\n         }\n-        JavaType t = (_valueType == null) ? _config.constructType(value.getClass()) : _valueType;\n-        return new ObjectReader(this, _config, t, value,\n+        JavaType t;\n+        \n+        /* no real benefit from pre-fetching, as updating readers are much\n+         * less likely to be reused, and value type may also be forced\n+         * with a later chained call...\n+         */\n+        if (_valueType == null) {\n+            t = _config.constructType(value.getClass());\n+        } else {\n+            t = _valueType;\n+        }\n+        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues);\n     }\n \n         return t;\n     }\n \n+    \n+static int col = 0;\n+\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n-    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n+    protected final JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n             JavaType valueType)\n         throws JsonMappingException\n     {\n+        /*\n+if (++col > 76) { col = 0; System.out.println(); }\n+System.out.print((_rootDeserializer == null) ? '0' : '1');\n+*/\n+        \n+        if (_rootDeserializer != null) {\n+            return _rootDeserializer;\n+        }\n+\n         // Sanity check: must have actual type...\n         if (valueType == null) {\n             throw new JsonMappingException(\"No value type configured for ObjectReader\");\n         return deser;\n     }\n \n+    /**\n+     * Method called to locate deserializer ahead of time, if permitted\n+     * by configuration. Method also is NOT to throw an exception if\n+     * access fails.\n+     */\n+    protected final JsonDeserializer<Object> _prefetchRootDeserializer(\n+            DeserializationConfig config, JavaType valueType)\n+    {\n+        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n+            return null;\n+        }\n+        // already cached?\n+        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n+        if (deser == null) {\n+            try {\n+                // If not, need to resolve; for which we need a temporary context as well:\n+                DeserializationContext ctxt = createDeserializationContext(null, _config);\n+                deser = ctxt.findRootValueDeserializer(valueType);\n+                if (deser != null) {\n+                    _rootDeserializers.put(valueType, deser);\n+                }\n+                return deser;\n+                \n+            } catch (JsonProcessingException e) {\n+                // need to swallow?\n+            }\n+        }\n+        return deser;\n+    }\n+    \n     protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n             JavaType rootType, JsonDeserializer<Object> deser)\n         throws IOException, JsonParseException, JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n- * Default {@link DeserializationContext} implementation that adds\n+ * Complete {@link DeserializationContext} implementation that adds\n  * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n  * to call, as well as implements certain parts that base class\n  * has left abstract.\n+ * The remaining abstract methods ({@link #createInstance}, {@link #with})\n+ * are left so that custom implementations will properly implement them\n+ * to return intended subtype.\n  */\n public abstract class DefaultDeserializationContext\n     extends DeserializationContext\n     /**********************************************************\n      */\n \n+    /**\n+     * Actual full concrete implementation\n+     */\n     public final static class Impl extends DefaultDeserializationContext\n     {\n         /**", "timestamp": 1340919823, "metainfo": ""}