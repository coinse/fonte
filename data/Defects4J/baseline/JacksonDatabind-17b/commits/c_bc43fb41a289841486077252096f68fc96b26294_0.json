{"sha": "bc43fb41a289841486077252096f68fc96b26294", "log": "Implement #376", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n \n /**\n  * As a fallback, we may need to use this serializer for other\n- * types of {@link Number}s (custom types).\n+ * types of {@link Number}s: both custom types and \"big\" numbers\n+ * like {@link BigInteger} and {@link BigDecimal}.\n  */\n @JacksonStdImpl\n public final class NumberSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n import java.lang.reflect.Type;\n import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n \n     /*\n     /**********************************************************\n-    /* Concrete serializers, numerics\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    public final static class ShortSerializer\n-        extends StdScalarSerializer<Short>\n-    {\n-        final static ShortSerializer instance = new ShortSerializer();\n-    \n-        public ShortSerializer() { super(Short.class); }\n-        \n-        @Override\n-        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n-            jgen.writeNumber(value.shortValue());\n-        }\n-    \n+    /* Shared base class\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class Base<T> extends StdScalarSerializer<T>\n+        implements ContextualSerializer\n+    {\n+        protected final JsonParser.NumberType _numberType;\n+        protected final String _schemaType;\n+\n+        protected Base(Class<T> cls, JsonParser.NumberType numberType, String schemaType) {\n+            super(cls);\n+            _numberType = numberType;\n+            _schemaType = schemaType;\n+        }\n+\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n+            return createSchemaNode(_schemaType, true);\n+        }\n+\n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\n+                v2.numberType(_numberType);\n             }\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> createContextual(SerializerProvider prov,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            if (property != null) {\n+                JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n+                if (format != null) {\n+                    switch (format.getShape()) {\n+                    case STRING:\n+                        return ToStringSerializer.instance;\n+                    default:\n+                    }\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, numerics\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public final static class ShortSerializer extends Base<Short>\n+    {\n+        final static ShortSerializer instance = new ShortSerializer();\n+    \n+        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, \"number\"); }\n+\n+        @Override\n+        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeNumber(value.shortValue());\n         }\n     }\n     \n      * included on serialization (unlike for most scalar types as of 1.5)\n      */\n     @JacksonStdImpl\n-    public final static class IntegerSerializer\n-        extends NonTypedScalarSerializerBase<Integer>\n-    {\n-        public IntegerSerializer() { super(Integer.class); }\n+    public final static class IntegerSerializer extends Base<Integer>\n+    {\n+        public IntegerSerializer() { super(Integer.class, JsonParser.NumberType.INT ,\"integer\"); }\n     \n         @Override\n         public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.intValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"integer\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\n-            }\n+        \n+        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n+        @Override\n+        public void serializeWithType(Integer value, JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n+            // no type info, just regular serialization\n+            serialize(value, jgen, provider);            \n         }\n     }\n \n      * by calling {@link java.lang.Number#intValue}.\n      */\n     @JacksonStdImpl\n-    public final static class IntLikeSerializer\n-        extends StdScalarSerializer<Number>\n+    public final static class IntLikeSerializer extends Base<Number>\n     {\n         final static IntLikeSerializer instance = new IntLikeSerializer();\n     \n-        public IntLikeSerializer() { super(Number.class); }\n+        public IntLikeSerializer() {\n+            super(Number.class, JsonParser.NumberType.INT, \"integer\");\n+        }\n         \n         @Override\n         public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.intValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"integer\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\n-            }\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class LongSerializer\n-        extends StdScalarSerializer<Long>\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongSerializer extends Base<Long>\n     {\n         final static LongSerializer instance = new LongSerializer();\n     \n-        public LongSerializer() { super(Long.class); }\n-        \n-        @Override\n-        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n-        {\n+        public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, \"number\"); }\n+        \n+        @Override\n+        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.longValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.LONG);\n-            }\n-        }\n-    }\n-    \n-    @JacksonStdImpl\n-    public final static class FloatSerializer\n-        extends StdScalarSerializer<Float>\n+    }\n+    \n+    @JacksonStdImpl\n+    public final static class FloatSerializer extends Base<Float>\n     {\n         final static FloatSerializer instance = new FloatSerializer();\n     \n-        public FloatSerializer() { super(Float.class); }\n+        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, \"number\"); }\n         \n         @Override\n         public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.floatValue());\n-        }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.FLOAT);\n-            }\n         }\n     }\n \n      * included on serialization (unlike for most scalar types as of 1.5)\n      */\n     @JacksonStdImpl\n-    public final static class DoubleSerializer\n-        extends NonTypedScalarSerializerBase<Double>\n+    public final static class DoubleSerializer extends Base<Double>\n     {\n         final static DoubleSerializer instance = new DoubleSerializer();\n     \n-        public DoubleSerializer() { super(Double.class); }\n+        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, \"number\"); }\n     \n         @Override\n         public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.doubleValue());\n         }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n-        {\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.DOUBLE);\n-            }\n+\n+        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n+        @Override\n+        public void serializeWithType(Double value, JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n+            // no type info, just regular serialization\n+            serialize(value, jgen, provider);            \n         }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests for verifying serialization of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestNumbers extends BaseMapTest\n+{\n+    private final ObjectMapper MAPPER = objectMapper();\n+\n+    private static class IntAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public int value = 3;\n+    }\n+\n+    private static class LongAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public long value = 4;\n+    }\n+    \n+    private static class DoubleAsString {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING)\n+        public double value = -0.5;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testDouble() throws Exception\n+    {\n+        double[] values = new double[] {\n+            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        };\n+        for (double d : values) {\n+            String expected = String.valueOf(d);\n+            if (Double.isNaN(d) || Double.isInfinite(d)) {\n+                expected = \"\\\"\"+d+\"\\\"\";\n+            }\n+            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n+        }\n+    }\n+\n+    public void testBigInteger() throws Exception\n+    {\n+        BigInteger[] values = new BigInteger[] {\n+                BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,\n+                BigInteger.valueOf(1234567890L),\n+                new BigInteger(\"123456789012345678901234568\"),\n+                new BigInteger(\"-1250000124326904597090347547457\")\n+                };\n+\n+        for (BigInteger value : values) {\n+            String expected = value.toString();\n+            assertEquals(expected, MAPPER.writeValueAsString(value));\n+        }\n+    }\n+\n+    public void testNumbersAsString() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'value':'3'}\"), MAPPER.writeValueAsString(new IntAsString()));\n+        assertEquals(aposToQuotes(\"{'value':'4'}\"), MAPPER.writeValueAsString(new LongAsString()));\n+        assertEquals(aposToQuotes(\"{'value':'-0.5'}\"), MAPPER.writeValueAsString(new DoubleAsString()));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n package com.fasterxml.jackson.databind.ser;\n-\n-import java.math.BigInteger;\n-\n \n import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.databind.BaseMapTest;\n         }\n     }\n \n-    public void testDouble() throws Exception\n-    {\n-        double[] values = new double[] {\n-            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n-        };\n-        for (double d : values) {\n-            String expected = String.valueOf(d);\n-            if (Double.isNaN(d) || Double.isInfinite(d)) {\n-                expected = \"\\\"\"+d+\"\\\"\";\n-            }\n-            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n-        }\n-    }\n-\n-    public void testBigInteger() throws Exception\n-    {\n-        BigInteger[] values = new BigInteger[] {\n-                BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,\n-                BigInteger.valueOf(1234567890L),\n-                new BigInteger(\"123456789012345678901234568\"),\n-                new BigInteger(\"-1250000124326904597090347547457\")\n-                };\n-\n-        for (BigInteger value : values) {\n-            String expected = value.toString();\n-            assertEquals(expected, MAPPER.writeValueAsString(value));\n-        }\n-    }\n-    \n     public void testClass() throws Exception\n     {\n         String result = MAPPER.writeValueAsString(java.util.List.class);", "timestamp": 1400713640, "metainfo": ""}