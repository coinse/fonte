{"sha": "766dc878e14644301483f3ecff8b5af8579e5b86", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n-import com.fasterxml.jackson.core.util.VersionUtil;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n      */\n \n     @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n-    }\n+    public abstract Version version();\n     \n     /*\n     /**********************************************************\n      * Method called by framework to determine whether given annotation\n      * is handled by this introspector.\n      */\n-    public abstract boolean isHandled(Annotation ann);\n+    public boolean isHandled(Annotation ann) {\n+        return false;\n+    }\n \n     /**\n      * Method for checking whether given annotation is considered an\n      * is defined. Returns null if no declaration found; can return\n      * explicit empty String, which is usually ignored as well as null.\n      */\n-    public abstract String findRootName(AnnotatedClass ac);\n+    public String findRootName(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for finding list of properties to ignore for given class\n      * after other detection mechanisms, to filter out these specific\n      * properties from being serialized and deserialized.\n      */\n-    public abstract String[] findPropertiesToIgnore(AnnotatedClass ac);\n+    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether an annotation indicates that all unknown properties\n      */\n-    public abstract Boolean findIgnoreUnknownProperties(AnnotatedClass ac);\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether properties that have specified type\n      */\n \n     /**\n-     * Note: defined as non-abstract to reduce fragility between\n-     * versions.\n+     * Method for checking if given member indicates that it is part\n+     * of a reference (parent/child).\n      */\n     public ReferenceProperty findReferenceType(AnnotatedMember member) {\n         return null;\n         return null;\n     }\n \n+    /**\n+     * Method for checking if annotated property (represented by a field or\n+     * getter/setter method) has definitions for views it is to be included in.\n+     * If null is returned, no view definitions exist and property is always\n+     * included (or always excluded as per default view inclusion configuration);\n+     * otherwise it will only be included for views included in returned\n+     * array. View matches are checked using class inheritance rules (sub-classes\n+     * inherit inclusions of super-classes)\n+     * \n+     * @param a Annotated property (represented by a method, field or ctor parameter)\n+     * @return Array of views (represented by classes) that the property is included in;\n+     *    if null, always included (same as returning array containing <code>Object.class</code>)\n+     */\n+    public Class<?>[] findViews(Annotated a) {\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Serialization: general annotations\n      * <code>Class<JsonSerializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findSerializer(Annotated am);\n+    public Object findSerializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n      *\n      * @return Class to use instead of runtime type\n      */\n-    public abstract Class<?> findSerializationType(Annotated a);\n+    public Class<?> findSerializationType(Annotated a) {\n+        return null;\n+    }\n \n     /**\n      * Method for finding possible widening type definition that a property\n      *\n      * @return Typing mode to use, if annotation is found; null otherwise\n      */\n-    public abstract JsonSerialize.Typing findSerializationTyping(Annotated a);\n-\n-    /**\n-     * Method for checking if annotated serializable property (represented by\n-     * field or getter method) has definitions for views it is to be included\n-     * in. If null is returned, no view definitions exist and property is always\n-     * included; otherwise it will only be included for views included in returned\n-     * array. View matches are checked using class inheritance rules (sub-classes\n-     * inherit inclusions of super-classes)\n-     * \n-     * @param a Annotated serializable property (field or getter method)\n-     * @return Array of views (represented by classes) that the property is included in;\n-     *    if null, always included (same as returning array containing <code>Object.class</code>)\n-     */\n-    public abstract Class<?>[] findSerializationViews(Annotated a);\n+    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n      * Method for accessing defined property serialization order (which may be\n      * partial). May return null if no ordering is defined.\n      */\n-    public abstract String[] findSerializationPropertyOrder(AnnotatedClass ac);\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether an annotation indicates that serialized properties\n      * for which no explicit is defined should be alphabetically (lexicograpically)\n      * ordered\n      */\n-    public abstract Boolean findSerializationSortAlphabetically(AnnotatedClass ac);\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n      */\n-    public abstract String findSerializationName(AnnotatedMethod am);\n+    public String findSerializationName(AnnotatedMethod am) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether given method has an annotation\n      * @return True if such annotation is found (and is not disabled);\n      *   false if no enabled annotation is found\n      */\n-    public abstract boolean hasAsValueAnnotation(AnnotatedMethod am);\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n \n     /**\n      * Method for determining the String value to use for serializing\n      *\n      * @return Serialized enum value.\n      */\n-    public abstract String findEnumValue(Enum<?> value);\n+    public String findEnumValue(Enum<?> value) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n      */\n-    public abstract String findSerializationName(AnnotatedField af);\n+    public String findSerializationName(AnnotatedField af) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findDeserializer(Annotated am);\n+    public Object findDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a deserializer definition for keys of\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findKeyDeserializer(Annotated am);\n+    public Object findKeyDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a deserializer definition for content (values) of\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findContentDeserializer(Annotated am);\n+    public Object findContentDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing annotated type definition that a\n      *\n      * @return Class to use for deserialization instead of declared type\n      */\n-    public abstract Class<?> findDeserializationType(Annotated am, JavaType baseType,\n-            String propName);\n+    public Class<?> findDeserializationType(Annotated am, JavaType baseType,\n+            String propName) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing additional narrowing type definition that a\n      * @return Class specifying more specific type to use instead of\n      *   declared type, if annotation found; null if not\n      */\n-    public abstract Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n-            String propName);\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n+            String propName) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing additional narrowing type definition that a\n      * @return Class specifying more specific type to use instead of\n      *   declared type, if annotation found; null if not\n      */\n-    public abstract Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n-            String propName);\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n+            String propName) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n      */\n-    public abstract String findDeserializationName(AnnotatedMethod am);\n+    public String findDeserializationName(AnnotatedMethod am) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether given method has an annotation\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n      */\n-    public abstract String findDeserializationName(AnnotatedField af);\n+    public String findDeserializationName(AnnotatedField af) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * No actual parameter object can be passed since JDK offers no\n      * representation; just annotations.\n      */\n-    public abstract String findDeserializationName(AnnotatedParameter param);\n+    public String findDeserializationName(AnnotatedParameter param) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n         }\n \n         @Override\n-        public Class<?>[] findSerializationViews(Annotated a)\n+        public Class<?>[] findViews(Annotated a)\n         {\n             /* Theoretically this could be trickier, if multiple introspectors\n              * return non-null entries. For now, though, we'll just consider\n              * first one to return non-null to win.\n              */\n-            Class<?>[] result = _primary.findSerializationViews(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationViews(a);\n+            Class<?>[] result = _primary.findViews(a);\n+            if (result == null) {\n+                result = _secondary.findViews(a);\n             }\n             return result;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n             throws IOException, JsonProcessingException\n     {\n         // This method should never be called...\n-        throw ctxt.instantiationException(_baseType.getRawClass(), \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n+        throw ctxt.instantiationException(_baseType.getRawClass(),\n+                \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n     }\n \n     protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        /* As per [JACKSON-417], there is a chance we might be \"natular\" types\n+        /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Care must be taken to only return this if return type matches, however.\n          * Finally, we may have to consider possibility of custom handlers for\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n          * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n          * a bug. Alas, we can't really fix that...\n          */\n-        // Also: [JACKSON-767] (enum value constructors)\n+        // Also: [JACKSON-757] (enum value constructors)\n         AnnotationMap[] resolvedAnnotations = null;\n         if (paramCount != paramAnns.length) {\n             // Limits of the work-around (to avoid hiding real errors):\n             // first, only applicable for member classes and then either:\n \n             Class<?> dc = ctor.getDeclaringClass();\n-            if (dc.isMemberClass()) {\n-                // (a) just one annotation (for non-static inner classes)\n+            // (a) is enum, which have two extra hidden params (name, index)\n+            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n+                Annotation[][] old = paramAnns;\n+                paramAnns = new Annotation[old.length+2][];\n+                System.arraycopy(old, 0, paramAnns, 2, old.length);\n+                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n+            } else if (dc.isMemberClass()) {\n+                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                 if (paramCount == (paramAnns.length + 1)) {\n                     // hack attack: prepend a null entry to make things match\n                     Annotation[][] old = paramAnns;\n                     paramAnns = new Annotation[old.length+1][];\n                     System.arraycopy(old, 0, paramAnns, 1, old.length);\n-                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n-\n-                    // (b) or is enum, which have two extra hidden params (but not for annotations!)\n-                } else if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n-                    Annotation[][] old = paramAnns;\n-                    paramAnns = new Annotation[old.length+2][];\n-                    System.arraycopy(old, 0, paramAnns, 2, old.length);\n                     resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     }\n \n     @Override\n-    public Class<?>[] findSerializationViews(Annotated a)\n+    public Class<?>[] findViews(Annotated a)\n     {\n         JsonView ann = a.getAnnotation(JsonView.class);\n         return (ann == null) ? null : ann.value();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import java.lang.annotation.Annotation;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n \n-import com.fasterxml.jackson.core.Version;\n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.DatabindVersion;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.KeyDeserializer;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize.Typing;\n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n  * Can be used as is to suppress handling of annotations; or as a basis\n- * for simple complementary annotators\n+ * for simple configuration overrides (whether based on annotations or not).\n  */\n-public class NopAnnotationIntrospector\n+public abstract class NopAnnotationIntrospector\n     extends AnnotationIntrospector\n {\n     /**\n      * \"null\" introspector: one that never finds any annotation\n      * information.\n      */\n-    public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector();\n+    public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector() {\n+        @Override\n+        public Version version() {\n+            return DatabindVersion.instance.version();\n+        }\n+    };\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General annotation properties\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public boolean isHandled(Annotation ann) {\n-        return false;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findEnumValue(Enum<?> value) {\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* General Class annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findRootName(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General member (field, method/constructor) annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public boolean hasIgnoreMarker(AnnotatedMember member) {\n-        return false;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: general annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public Object findSerializer(Annotated am) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findSerializationType(Annotated a) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Typing findSerializationTyping(Annotated a) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?>[] findSerializationViews(Annotated a) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: class annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findSerializationName(AnnotatedMethod am) {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-    \n-    @Override\n-    public String findDeserializationName(AnnotatedField af) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationContentType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationKeyType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Object findDeserializer(Annotated am) { return null; }\n-\n-    @Override\n-    public Class<KeyDeserializer> findKeyDeserializer(Annotated am) { return null; }\n-\n-    @Override\n-    public Class<JsonDeserializer<?>> findContentDeserializer(Annotated am) { return null; }\n-\n-\n-    @Override\n-    public String findDeserializationName(AnnotatedParameter param) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String findSerializationName(AnnotatedField af) {\n-        return null;\n-    }\n-    \n-    @Override\n-    public String findDeserializationName(AnnotatedMethod am) {\n-        return null;\n+        return Version.unknownVersion();\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                         typeSer, contentTypeSer, accessor, staticTyping);\n         // how about views? (1.4+)\n         AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n-        pbw.setViews(intr.findSerializationViews(accessor));\n+        pbw.setViews(intr.findViews(accessor));\n         return pbw;\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n     public void testSimple() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, TestEnum.B);\n-        assertEquals(\"\\\"B\\\"\", sw.toString());\n+        assertEquals(\"\\\"B\\\"\", mapper.writeValueAsString(TestEnum.B));\n     }\n \n     public void testEnumSet() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         EnumSet<TestEnum> value = EnumSet.of(TestEnum.B);\n         mapper.writeValue(sw, value);\n      */\n     public void testEnumUsingToString() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         mapper.writeValue(sw, AnnotatedTestEnum.C2);\n         assertEquals(\"\\\"c2\\\"\", sw.toString());\n     // Test [JACKSON-214]\n     public void testSubclassedEnums() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"\\\"B\\\"\", mapper.writeValueAsString(EnumWithSubClass.B));\n     }\n \n     // [JACKSON-193]\n     public void testEnumsWithJsonValue() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"\\\"bar\\\"\", mapper.writeValueAsString(EnumWithJsonValue.B));\n     }\n \n     // also, for [JACKSON-193], needs to work via mix-ins\n     public void testEnumsWithJsonValueUsingMixin() throws Exception\n     {\n+        // can't share, as new mix-ins are added\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n         assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(TestEnum.B));\n      */\n     public void testSerializableEnum() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(\"\\\"foo\\\"\", mapper.writeValueAsString(SerializableEnum.A));\n     }\n \n     public void testToStringEnumWithEnumMap() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n         EnumMap<LowerCaseEnum,String> m = new EnumMap<LowerCaseEnum,String>(LowerCaseEnum.class);\n         m.put(LowerCaseEnum.C, \"value\");\n-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n         assertEquals(\"{\\\"c\\\":\\\"value\\\"}\", mapper.writeValueAsString(m));\n     }\n \n     {\n         MapBean bean = new MapBean();\n         bean.add(TestEnum.B, 3);\n-        String json = new ObjectMapper().writeValueAsString(bean);\n+        String json = mapper.writeValueAsString(bean);\n         assertEquals(\"{\\\"map\\\":{\\\"b\\\":3}}\", json);\n     }\n     \n     // [JACKSON-757]\n     public void testAnnotationsOnEnumCtor() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.writeValueAsString(OK.V1);\n-        mapper.writeValueAsString(NOT_OK.V1);\n+        assertEquals(quote(\"V1\"), mapper.writeValueAsString(OK.V1));\n+        assertEquals(quote(\"V1\"), mapper.writeValueAsString(NOT_OK.V1));\n+        assertEquals(quote(\"V2\"), mapper.writeValueAsString(NOT_OK2.V2));\n     }\n }\n+\n+// [JACKSON-757], non-inner enum\n+enum NOT_OK2 {\n+    V2(\"v2\"); \n+    protected String key;\n+    // any runtime-persistent annotation is fine\n+    NOT_OK2(@JsonProperty String key) { this.key = key; }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     /**\n      * Lazily constructed map used to contain deserializers needed\n      * for polymorphic subtypes.\n+     * Note that this is <b>only needed</b> for polymorphic types,\n+     * that is, when the actual type is not statically known.\n+     * For other types this remains null.\n      */\n     protected HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n     protected String _managedReferenceName;\n \n     /**\n+     * If property has associated view information (list of\n+     * Views in which property is to be included), this contains\n+     * those views; if not, will be null.\n+     */\n+    protected Class<?>[] _views;\n+    \n+    /**\n      * Index of property (within all property of a bean); assigned\n      * when all properties have been collected. Order of entries\n      * is arbitrary, but once indexes are assigned they are not\n         _managedReferenceName = n;\n     }\n     \n+    public void setViews(Class<?>[] views) {\n+        _views = views;\n+    }\n+    \n     /**\n      * Method used to assign index for property.\n      */\n     public JsonDeserializer<Object> getValueDeserializer() { return _valueDeserializer; }\n \n     public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n+\n+    public Class<?>[] getViews() { return _views; }\n+\n+    public boolean hasViews() { return _views != null; }\n     \n     /**\n      * Method for accessing unique index of this property; indexes are\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n /**\n  * Deserializer that builds on basic {@link BeanDeserializer} but\n  * override some aspects like instance construction.\n- *<p>\n- * Note that this deserializer was significantly changed in Jackson 1.7\n- * (due to massive changes in {@link BeanDeserializer}).\n  */\n public class ThrowableDeserializer\n     extends BeanDeserializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n \n /**\n- * Serializer class that can serialize arbitrary bean objects\n+ * Serializer class that can serialize Java objects that map\n+ * to JSON Object output. Internally handling is mostly dealt with\n+ * by a sequence of {@link BeanPropertyWriter}s that will handle\n+ * access value to serialize and call appropriate serializers to\n+ * write out JSON.\n  *<p>\n  * Implementation note: we will post-process resulting serializer,\n  * to figure out actual serializers for final types. This must be\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n      * definitions. Default implementation constructs filter that checks\n      * active view type to views property is to be included in.\n      */\n-    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews)\n+    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n+            Class<?>[] inViews)\n     {\n         return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n     }", "timestamp": 1327538704, "metainfo": ""}