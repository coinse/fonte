{"sha": "d34aab5caea0018944a6b7fd121aa95c51634345", "log": "Backport earlier fix wrt AsArraySerializerBase", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         // Maybe it already has annotated/statically configured serializer?\n         JsonSerializer<Object> ser = getSerializer();\n         if (ser == null) { // nope\n-            Class<?> serType = getRawSerializationType();\n-            if (serType == null) {\n-                serType = getPropertyType();\n-            }\n-            ser = provider.findValueSerializer(serType, this);\n+            ser = provider.findValueSerializer(getType(), this);\n         }\n         boolean isOptional = !isRequired();\n         if (ser instanceof SchemaAware) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n     {\n-        /* 15-Jan-2010, tatu: This should probably be rewritten, given that\n-         *    more information about content type is actually being explicitly\n-         *    passed. So there should be less need to try to re-process that\n-         *    information.\n-         */\n         ObjectNode o = createSchemaNode(\"array\", true);\n-        JavaType contentType = null;\n-        if (typeHint != null) {\n-            JavaType javaType = provider.constructType(typeHint);\n-            contentType = javaType.getContentType();\n-            if (contentType == null) { // could still be parametrized (Iterators)\n-                if (typeHint instanceof ParameterizedType) {\n-                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n-                    if (typeArgs.length == 1) {\n-                        contentType = provider.constructType(typeArgs[0]);\n-                    }\n-                }\n-            }\n-        }\n-        if (contentType == null && _elementType != null) {\n-            contentType = _elementType;\n-        }\n+        JavaType contentType = _elementType;\n         if (contentType != null) {\n             JsonNode schemaNode = null;\n             // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n     {\n         JsonArrayFormatVisitor arrayVisitor = (visitor == null) ? null : visitor.expectArrayFormat(typeHint);\n         if (arrayVisitor != null) {\n-            TypeFactory tf = visitor.getProvider().getTypeFactory();\n-            JavaType contentType = tf.moreSpecificType(_elementType, typeHint.getContentType());\n-            if (contentType == null) {\n-                throw new JsonMappingException(\"Could not resolve type\");\n-            }\n+            /* 01-Sep-2014, tatu: Earlier was trying to make use of 'typeHint' for some\n+             *   reason, causing NPE (as per https://github.com/FasterXML/jackson-module-jsonSchema/issues/34)\n+             *   if coupled with `@JsonValue`. But I can't see much benefit of trying to rely\n+             *   on TypeHint here so code is simplified like so:\n+             */\n             JsonSerializer<?> valueSer = _elementSerializer;\n             if (valueSer == null) {\n-                valueSer = visitor.getProvider().findValueSerializer(contentType, _property);\n-            }\n-            arrayVisitor.itemsFormat(valueSer, contentType);\n+                valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);\n+            }\n+            arrayVisitor.itemsFormat(valueSer, _elementType);\n         }\n     }\n ", "timestamp": 1409636375, "metainfo": ""}