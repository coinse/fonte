{"sha": "346dc38b18c72ff02e3c456e1f6f78ebdc3de1cd", "log": "Merge pull request #318 from christophercurrie/valueUpdate  Can't deserialize to a bean that has Creator props", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestValueUpdate.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestValueUpdate\n+    extends BaseTest\n+{\n+    static class Bean\n+    {\n+        private String a;\n+        private String b;\n+\n+        @JsonCreator\n+        public Bean(@JsonProperty(\"a\") String a, @JsonProperty(\"b\") String b)\n+        {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        String getA() {\n+            return a;\n+        }\n+\n+        void setA(String a) {\n+            this.a = a;\n+        }\n+\n+        String getB() {\n+            return b;\n+        }\n+\n+        void setB(String b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    public void testValueUpdateWithCreator() throws Exception\n+    {\n+        Bean bean = new Bean(\"abc\", \"def\");\n+        new ObjectMapper().reader(Bean.class).withValueToUpdate(bean).readValue(\"{\\\"a\\\":\\\"ghi\\\",\\\"b\\\":\\\"jkl\\\"}\");\n+        assertEquals(\"ghi\", bean.getA());\n+        assertEquals(\"jkl\", bean.getB());\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n     \n     /*\n     /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing attributes available in this context.\n+     * Per-call attributes have highest precedence; attributes set\n+     * via {@link ObjectReader} or {@link ObjectWriter} have lower\n+     * precedence.\n+     * \n+     * @param key Key of the attribute to get\n+     * @return Value of the attribute, if any; null otherwise\n+     * \n+     * @since 2.3\n+     */\n+    public abstract Object getAttribute(Object key);\n+\n+    /**\n+     * Method for setting per-call value of given attribute.\n+     * This will override any previously defined value for the\n+     * attribute within this context.\n+     * \n+     * @param key Key of the attribute to set\n+     * @param value Value to set attribute to\n+     * \n+     * @return This context object, to allow chaining\n+     * \n+     * @since 2.3\n+     */\n+    public abstract DatabindContext setAttribute(Object key, Object value);\n+\n+    /*\n+    /**********************************************************\n     /* Type instantiation/resolution\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, ContextAttributes attrs)\n+    {\n+        super(src, attrs);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n     \n     // for unit tests only:\n     protected BaseSettings getBaseSettings() { return _base; }\n     public DeserializationConfig with(Base64Variant base64) {\n         return _withBase(_base.with(base64));\n     }\n+\n+    @Override\n+    public DeserializationConfig with(ContextAttributes attrs) {\n+        return (attrs == _attributes) ? this : new DeserializationConfig(this, attrs);\n+    }\n     \n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n     protected transient ObjectBuffer _objectBuffer;\n \n     protected transient DateFormat _dateFormat;\n+\n+    /**\n+     * Lazily-constructed holder for per-call attributes.\n+     * \n+     * @since 2.3\n+     */\n+    protected transient ContextAttributes _attributes;\n     \n     /*\n     /**********************************************************\n         _config = null;\n         _injectableValues = null;\n         _view = null;\n+        _attributes = null;\n     }\n \n     protected DeserializationContext(DeserializationContext src,\n         _view = src._view;\n         _parser = src._parser;\n         _injectableValues = src._injectableValues;\n-    }\n-    \n+        _attributes = src._attributes;\n+    }\n+\n+    /**\n+     * Constructor used for creating actual per-call instances.\n+     */\n     protected DeserializationContext(DeserializationContext src,\n             DeserializationConfig config, JsonParser jp,\n             InjectableValues injectableValues)\n         _view = config.getActiveView();\n         _parser = jp;\n         _injectableValues = injectableValues;\n+        _attributes = config.getAttributes();\n     }\n \n     /*\n     @Override\n     public final TypeFactory getTypeFactory() {\n         return _config.getTypeFactory();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getAttribute(Object key) {\n+        return _attributes.getAttribute(key);\n+    }\n+\n+    @Override\n+    public DeserializationContext setAttribute(Object key, Object value)\n+    {\n+        _attributes = _attributes.withPerCallAttribute(key, value);\n+        return this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n         return writer().with(escapes);\n     }\n \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * use specified default attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public ObjectWriter writer(ContextAttributes attrs) {\n+        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n+    }\n     \n     /*\n     /**********************************************************\n         return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n     }\n \n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified default attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public ObjectReader reader(ContextAttributes attrs) {\n+        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import java.net.URL;\n import java.util.Iterator;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.TimeZone;\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.DataFormatReaders;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n         return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, _injectableValues, readers);\n     }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectReader with(ContextAttributes attrs) {\n+        DeserializationConfig newConfig = _config.with(attrs);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n+        DeserializationConfig newConfig = _config.withAttributes(attrs);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectReader withAttribute(Object key, Object value) {\n+        DeserializationConfig newConfig = _config.withAttribute(key, value);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectReader withoutAttribute(Object key) {\n+        DeserializationConfig newConfig = _config.withoutAttribute(key);\n+        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    }\n     \n     /*\n     /**********************************************************\n \n     public TypeFactory getTypeFactory() {\n         return _config.getTypeFactory();\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ContextAttributes getAttributes() {\n+        return _config.getAttributes();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import java.io.*;\n import java.text.DateFormat;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.Instantiatable;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n         }\n         return new ObjectWriter(this, f);\n     }    \n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter with(ContextAttributes attrs) {\n+        SerializationConfig newConfig = _config.with(attrs);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter withAttributes(Map<Object,Object> attrs) {\n+        SerializationConfig newConfig = _config.withAttributes(attrs);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter withAttribute(Object key, Object value) {\n+        SerializationConfig newConfig = _config.withAttribute(key, value);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter withoutAttribute(Object key) {\n+        SerializationConfig newConfig = _config.withoutAttribute(key);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Simple accessors\n      */\n     public boolean hasPrefetchedSerializer() {\n         return _rootSerializer != null;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ContextAttributes getAttributes() {\n+        return _config.getAttributes();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected SerializationConfig(SerializationConfig src, ContextAttributes attrs)\n+    {\n+        super(src, attrs);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n     public SerializationConfig with(Base64Variant base64) {\n         return _withBase(_base.with(base64));\n     }\n+\n+    @Override\n+    public SerializationConfig with(ContextAttributes attrs) {\n+        return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n+    }\n     \n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n     public FilterProvider getFilterProvider() {\n         return _filterProvider;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Introspection methods\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n     /*\n     /**********************************************************\n-    /* Helper objects for caching\n+    /* Helper objects for caching, reuse\n     /**********************************************************\n      */\n     \n      * Helper object for keeping track of introspected root names\n      */\n     final protected RootNameLookup _rootNames;\n+    \n+    /**\n+     * Lazily-constructed holder for per-call attributes.\n+     * \n+     * @since 2.3\n+     */\n+    protected transient ContextAttributes _attributes;\n     \n     /*\n     /**********************************************************\n         _rootNames = new RootNameLookup();\n \n         _serializationView = null;\n+        _attributes = null;\n \n         // not relevant for blueprint instance, could set either way:\n         _stdNullValueSerializer = true;\n         _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n \n         _serializationView = config.getActiveView();\n+        _attributes = config.getAttributes();\n     }\n     \n     /*\n      */\n     @Deprecated\n     public final Class<?> getSerializationView() { return _serializationView; }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getAttribute(Object key) {\n+        return _attributes.getAttribute(key);\n+    }\n+\n+    @Override\n+    public SerializerProvider setAttribute(Object key, Object value)\n+    {\n+        _attributes = _attributes.withPerCallAttribute(key, value);\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to general configuration\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.util.*;\n+\n+/**\n+ * Helper class used for storing and accessing per-call attributes.\n+ * Storage is two-layered: at higher precedence, we have actual per-call\n+ * attributes; and at lower precedence, default attributes that may be\n+ * defined for Object readers and writers.\n+ *<p>\n+ * Note that the way mutability is implemented differs between kinds\n+ * of attributes, to account for thread-safety: per-call attributes\n+ * are handled assuming that instances are never shared, whereas\n+ * changes to per-reader/per-writer attributes are made assuming\n+ * sharing, by creating new copies instead of modifying state.\n+ * This allows sharing of default values without per-call copying, but\n+ * requires two-level lookup on access.\n+ * \n+ * @since 2.3\n+ */\n+public abstract class ContextAttributes\n+{\n+    public static ContextAttributes getEmpty() {\n+        return Impl.getEmpty();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Per-reader/writer access\n+    /**********************************************************\n+     */\n+\n+    public abstract ContextAttributes withSharedAttribute(Object key, Object value);\n+\n+    public abstract ContextAttributes withSharedAttributes(Map<Object,Object> attributes);\n+    \n+    public abstract ContextAttributes withoutSharedAttribute(Object key);\n+    \n+    /*\n+    /**********************************************************\n+    /* Per-operation (serialize/deserialize) access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for value of specified attribute\n+     */\n+    public abstract Object getAttribute(Object key);\n+\n+    /**\n+     * Mutator used during call (via context) to set value of \"non-shared\"\n+     * part of attribute set.\n+     */\n+    public abstract ContextAttributes withPerCallAttribute(Object key, Object value);\n+\n+    /*\n+    /**********************************************************\n+    /* Default implementation\n+    /**********************************************************\n+     */\n+\n+    public static class Impl extends ContextAttributes\n+        implements java.io.Serializable // just so ObjectReader/ObjectWriter can retain configs\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected final static Impl EMPTY = new Impl(Collections.emptyMap());\n+\n+        protected final static Object NULL_SURROGATE = new Object();\n+        \n+        /**\n+         * Shared attributes that we can not modify in-place.\n+         */\n+        protected final Map<Object,Object> _shared;\n+\n+        /**\n+         * Per-call attributes that we can directly modify, since they are not\n+         * shared between threads.\n+         */\n+        protected transient Map<Object,Object> _nonShared;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction, factory methods\n+        /**********************************************************\n+         */\n+        \n+        protected Impl(Map<Object,Object> shared) {\n+            _shared = shared;\n+            _nonShared = null;\n+        }\n+\n+        protected Impl(Map<Object,Object> shared, Map<Object,Object> nonShared) {\n+            _shared = shared;\n+            _nonShared = nonShared;\n+        }\n+        \n+        public static ContextAttributes getEmpty() {\n+            return EMPTY;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Per-reader/writer mutant factories\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public ContextAttributes withSharedAttribute(Object key, Object value)\n+        {\n+            Map<Object,Object> m;\n+            // need to cover one special case, since EMPTY uses Immutable map:\n+            if (this == EMPTY) {\n+                m = new HashMap<Object,Object>(8);\n+            } else {\n+                m = _copy(_shared);\n+            }\n+            m.put(key, value);\n+            return new Impl(m);\n+        }\n+\n+        @Override\n+        public ContextAttributes withSharedAttributes(Map<Object, Object> shared) {\n+            return new Impl(shared);\n+        }\n+\n+        @Override\n+        public ContextAttributes withoutSharedAttribute(Object key)\n+        {\n+            // first couple of trivial optimizations\n+            if (_shared.isEmpty()) {\n+                return this;\n+            }\n+            if (_shared.containsKey(key)) {\n+                if (_shared.size() == 1) {\n+                    return EMPTY;\n+                }\n+            } else { // if we didn't have it anyway, return as-is\n+                return this;\n+            }\n+            // otherwise make copy, modify\n+            Map<Object,Object> m = _copy(_shared);\n+            m.remove(key);\n+            return new Impl(m);\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Per-call access\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public Object getAttribute(Object key)\n+        {\n+            if (_nonShared != null) {\n+                Object ob = _nonShared.get(key);\n+                if (ob != null) {\n+                    if (ob == NULL_SURROGATE) {\n+                        return null;\n+                    }\n+                    return ob;\n+                }\n+            }\n+            return _shared.get(key);\n+        }\n+        \n+        @Override\n+        public ContextAttributes withPerCallAttribute(Object key, Object value)\n+        {\n+            // First: null value may need masking\n+            if (value == null) {\n+                // need to mask nulls to ensure default values won't be showing\n+                if (_shared.containsKey(key)) {\n+                    value = NULL_SURROGATE;\n+                } else {\n+                    // except if non-mutable shared list has no entry, we don't care\n+                    return this;\n+                }\n+            }\n+\n+            // a special case: create non-shared instance if need be\n+            if (_nonShared == null) {\n+                return nonSharedInstance(key, value);\n+            }\n+            _nonShared.put(key, value);\n+            return this;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Internal methods\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Overridable method that creates initial non-shared instance,\n+         * with the first explicit set value.\n+         */\n+        protected ContextAttributes nonSharedInstance(Object key, Object value)\n+        {\n+            Map<Object,Object> m = new HashMap<Object,Object>();\n+            if (value == null) {\n+                value = NULL_SURROGATE;\n+            }\n+            m.put(key, value);\n+            return new Impl(_shared, m);\n+        }\n+        \n+        private Map<Object,Object> _copy(Map<Object,Object> src)\n+        {\n+            return new HashMap<Object,Object>(src);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n     public Base64Variant getBase64Variant() {\n         return _base.getBase64Variant();\n     }\n-    \n+\n+    /**\n+     * Method for accessing per-instance shared (baseline/default)\n+     * attribute values; these are used as the basis for per-call\n+     * attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public abstract ContextAttributes getAttributes();\n+\n     /*\n     /**********************************************************\n     /* Methods for instantiating handlers\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n     extends MapperConfig<T>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -8378230381628000111L;\n+    private static final long serialVersionUID = 6062961959359172474L;\n \n     private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperFeature.class);\n \n      * is defined), meaning that all properties are to be included.\n      */\n     protected final Class<?> _view;\n-    \n+\n+    /**\n+     * Contextual attributes accessible (get and set) during processing,\n+     * on per-call basis.\n+     * \n+     * @since 2.3\n+     */\n+    protected final ContextAttributes _attributes;\n+\n     /*\n     /**********************************************************\n     /* Construction\n         _subtypeResolver = str;\n         _rootName = null;\n         _view = null;\n+        // default to \"no attributes\"\n+        _attributes = ContextAttributes.getEmpty();\n     }\n     \n     /**\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, int mapperFeatures)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str) {\n         _subtypeResolver = str;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, String rootName) {\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, Class<?> view)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = view;\n+        _attributes = src._attributes;\n     }\n \n     /**\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, ContextAttributes attr)\n+    {\n+        super(src);\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+        _view = src._view;\n+        _attributes = attr;\n     }\n     \n     /*\n      * default {@link Base64Variant} to use with base64-encoded binary values.\n      */\n     public abstract T with(Base64Variant base64);\n+\n+    /**\n+     * Method for constructing an instance that has specified\n+     * contextual attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public abstract T with(ContextAttributes attrs);\n+\n+    /**\n+     * Method for constructing an instance that has only specified\n+     * attributes, removing any attributes that exist before the call.\n+     * \n+     * @since 2.3\n+     */\n+    public T withAttributes(Map<Object,Object> attributes) {\n+        return with(getAttributes().withSharedAttributes(attributes));\n+    }\n+    \n+    /**\n+     * Method for constructing an instance that has specified\n+     * value for attribute for given key.\n+     * \n+     * @since 2.3\n+     */\n+    public T withAttribute(Object key, Object value) {\n+        return with(getAttributes().withSharedAttribute(key, value));\n+    }\n+\n+    /**\n+     * Method for constructing an instance that has no\n+     * value for attribute for given key.\n+     * \n+     * @since 2.3\n+     */\n+    public T withoutAttribute(Object key) {\n+        return with(getAttributes().withoutSharedAttribute(key));\n+    }\n     \n     /*\n     /**********************************************************\n     public final Class<?> getActiveView() {\n         return _view;\n     }\n+\n+    @Override\n+    public final ContextAttributes getAttributes() {\n+        return _attributes;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n         // just for fun, let's also call hash code...\n         o.hashCode();\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Helper methods\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, serialization\n     /**********************************************************\n      */\n \n     {\n         String str = m.writeValueAsString(value);\n         return (Map<String,Object>) m.readValue(str, Map.class);\n-    }\n-\n-    protected <T> T readAndMapFromString(String input, Class<T> cls)\n-        throws IOException\n-    {\n-        return readAndMapFromString(SHARED_MAPPER, input, cls);\n-    }\n-    \n-    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n-        throws IOException\n-    {\n-        return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n     }\n     \n     protected String serializeAsString(ObjectMapper m, Object value)\n         return m.writeValueAsString(map);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, deserialization\n+    /**********************************************************\n+     */\n+    \n+    protected <T> T readAndMapFromString(String input, Class<T> cls)\n+        throws IOException\n+    {\n+        return readAndMapFromString(SHARED_MAPPER, input, cls);\n+    }\n+    \n+    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n+        throws IOException\n+    {\n+        return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, other\n+    /**********************************************************\n+     */\n+    \n     protected TimeZone getUTCTimeZone() {\n         return TimeZone.getTimeZone(\"GMT\");\n     }\n             throw new IllegalArgumentException(e);\n         }\n     }\n+\n+    protected String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n         public int getY() { return y; }\n         public void setY(int y) { this.y = y; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Tests for individual objects\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n+package com.fasterxml.jackson.databind.contextual;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n+\n+public class TestContextAttributeWithDeser extends BaseMapTest\n+{\n+    final static String KEY = \"foobar\";\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class PrefixStringDeserializer extends StdScalarDeserializer<String>\n+    {\n+        protected PrefixStringDeserializer() {\n+            super(String.class);\n+        }\n+\n+        @Override\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            Integer I = (Integer) ctxt.getAttribute(KEY);\n+            if (I == null) {\n+                I = Integer.valueOf(0);\n+            }\n+            int i = I.intValue();\n+            ctxt.setAttribute(KEY, Integer.valueOf(i + 1));\n+            return jp.getText()+\"/\"+i;\n+        }\n+\n+    }\n+\n+    static class TestPOJO\n+    {\n+        @JsonDeserialize(using=PrefixStringDeserializer.class)\n+        public String value;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimplePerCall() throws Exception\n+    {\n+        final String INPUT = aposToQuotes(\"[{'value':'a'},{'value':'b'}]\");\n+        TestPOJO[] pojos = MAPPER.reader(TestPOJO[].class).readValue(INPUT);\n+        assertEquals(2, pojos.length);\n+        assertEquals(\"a/0\", pojos[0].value);\n+        assertEquals(\"b/1\", pojos[1].value);\n+\n+        // and verify that state does not linger\n+        TestPOJO[] pojos2 = MAPPER.reader(TestPOJO[].class).readValue(INPUT);\n+        assertEquals(2, pojos2.length);\n+        assertEquals(\"a/0\", pojos2[0].value);\n+        assertEquals(\"b/1\", pojos2[1].value);\n+    }\n+\n+    public void testSimpleDefaults() throws Exception\n+    {\n+        final String INPUT = aposToQuotes(\"{'value':'x'}\");\n+        TestPOJO pojo = MAPPER.reader(TestPOJO.class)\n+                .withAttribute(KEY, Integer.valueOf(3))\n+                .readValue(INPUT);\n+        assertEquals(\"x/3\", pojo.value);\n+\n+        // as above, should not carry on state\n+        TestPOJO pojo2 = MAPPER.reader(TestPOJO.class)\n+                .withAttribute(KEY, Integer.valueOf(3))\n+                .readValue(INPUT);\n+        assertEquals(\"x/3\", pojo2.value);\n+    }\n+\n+    public void testHierarchic() throws Exception\n+    {\n+        final String INPUT = aposToQuotes(\"[{'value':'x'},{'value':'y'}]\");\n+        ObjectReader r = MAPPER.reader(TestPOJO[].class).withAttribute(KEY, Integer.valueOf(2));\n+        TestPOJO[] pojos = r.readValue(INPUT);\n+        assertEquals(2, pojos.length);\n+        assertEquals(\"x/2\", pojos[0].value);\n+        assertEquals(\"y/3\", pojos[1].value);\n+\n+        // and once more to verify transiency of per-call state\n+        TestPOJO[] pojos2 = r.readValue(INPUT);\n+        assertEquals(2, pojos2.length);\n+        assertEquals(\"x/2\", pojos2[0].value);\n+        assertEquals(\"y/3\", pojos2[1].value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithSer.java\n+package com.fasterxml.jackson.databind.contextual;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n+\n+public class TestContextAttributeWithSer extends BaseMapTest\n+{\n+    final static String KEY = \"foobar\";\n+    \n+    static class PrefixStringSerializer extends StdScalarSerializer<String>\n+    {\n+        protected PrefixStringSerializer() {\n+            super(String.class);\n+        }\n+\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen,\n+                SerializerProvider provider)\n+            throws IOException\n+        {\n+            Integer I = (Integer) provider.getAttribute(KEY);\n+            if (I == null) {\n+                I = Integer.valueOf(0);\n+            }\n+            int i = I.intValue();\n+            provider.setAttribute(KEY, Integer.valueOf(i + 1));\n+            jgen.writeString(\"\" +i+\":\"+value);\n+        }\n+    }\n+\n+    static class TestPOJO\n+    {\n+        @JsonSerialize(using=PrefixStringSerializer.class)\n+        public String value;\n+\n+        public TestPOJO(String str) { value = str; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimplePerCall() throws Exception\n+    {\n+        final String EXP = aposToQuotes(\"[{'value':'0:a'},{'value':'1:b'}]\");\n+        ObjectWriter w = MAPPER.writer();\n+        final TestPOJO[] INPUT = new TestPOJO[] {\n+                new TestPOJO(\"a\"), new TestPOJO(\"b\") };\n+        assertEquals(EXP, w.writeValueAsString(INPUT));\n+\n+        // also: ensure that we don't retain per-call state accidentally:\n+        assertEquals(EXP, w.writeValueAsString(INPUT));\n+    }\n+\n+    public void testSimpleDefaults() throws Exception\n+    {\n+        final String EXP = aposToQuotes(\"{'value':'3:xyz'}\");\n+        final TestPOJO INPUT = new TestPOJO(\"xyz\");\n+        String json = MAPPER.writer().withAttribute(KEY, Integer.valueOf(3))\n+                .writeValueAsString(INPUT);\n+        assertEquals(EXP, json);\n+\n+        String json2 = MAPPER.writer().withAttribute(KEY, Integer.valueOf(3))\n+                .writeValueAsString(INPUT);\n+        assertEquals(EXP, json2);\n+    }\n+\n+    public void testHierarchic() throws Exception\n+    {\n+        final TestPOJO[] INPUT = new TestPOJO[] { new TestPOJO(\"a\"), new TestPOJO(\"b\") };\n+        final String EXP = aposToQuotes(\"[{'value':'2:a'},{'value':'3:b'}]\");\n+        ObjectWriter w = MAPPER.writer().withAttribute(KEY, Integer.valueOf(2));\n+        assertEquals(EXP, w.writeValueAsString(INPUT));\n+\n+        // and verify state clearing:\n+        assertEquals(EXP, w.writeValueAsString(INPUT));\n+    }\n+}", "timestamp": 1381379442, "metainfo": ""}