{"sha": "85f4bafb73b876a58919164cb4926b633e69725c", "log": "Ugh. Accidentally checked in pojo-as-array code in 2.0... need to merge in 2.1 first", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         }\n     }\n \n+    /**\n+     * Alternative to {@link #serializeAsField} that is used when a POJO\n+     * is serialized as JSON Array; the difference is that no field names\n+     * are written.\n+     * \n+     * @since 2.1\n+     */\n+    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        if (value == null) { // nulls need specialized handling\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, jgen, prov);\n+            }\n+            return;\n+        }\n+        // otherwise find serializer to use\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        // and then see if we must suppress certain values (default, empty)\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n     }\n \n     @Override\n-    protected BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+    public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n         return new BeanSerializer(this, objectIdWriter);\n     }\n \n     @Override\n     protected BeanSerializer withIgnorals(String[] toIgnore) {\n         return new BeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * Implementation has to check whether as-array serialization\n+     * is possible reliably; if (and only if) so, will construct\n+     * a {@link BeanAsArraySerializer}, otherwise will return this\n+     * serializer as is.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer()\n+    {\n+        /* Can not:\n+         * \n+         * - have Object Id (may be allowed in future)\n+         * - have any getter\n+         * \n+         */\n+        if ((_objectIdWriter == null)\n+                && (_anyGetterWriter == null)\n+                && (_propertyFilterId == null)\n+                ) {\n+            return new BeanAsArraySerializer(this);\n+        }\n+        // already is one, so:\n+        return this;\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Specialized POJO serializer that differs from\n+ * {@link com.fasterxml.jackson.databind.ser.BeanSerializer}\n+ * in that instead of producing a JSON Object it will output\n+ * a JSON Array, omitting field names, and serializing values in\n+ * specified serialization order.\n+ * This behavior is usually triggered by using annotation\n+ * {@link com.fasterxml.jackson.annotation.JsonFormat} or its\n+ * equivalents.\n+ *<p>\n+ * This serializer can be used for \"simple\" instances; and will NOT\n+ * be used if one of following is true:\n+ *<ul>\n+ * <li>Unwrapping is used (no way to expand out array in JSON Object)\n+ *  </li>\n+ * <li>Type information (\"type id\") is to be used: while this could work\n+ *   for some embedding methods, it would likely cause conflicts.\n+ *  </li>\n+ * <li>Object Identity (\"object id\") is used: while references would work,\n+ *    the problem is inclusion of id itself.\n+ *  </li>\n+ *</ul>\n+ * Note that it is theoretically possible that last 2 issues could be addressed\n+ * (by reserving room in array, for example); and if so, support improved.\n+ *<p>\n+ * In cases where array-based output is not feasible, this serializer\n+ * can instead delegate to the original Object-based serializer; this\n+ * is why a reference is retained to the original serializer.\n+ * \n+ * @since 2.1\n+ */\n+public class BeanAsArraySerializer\n+    extends BeanSerializerBase\n+{\n+    /**\n+     * Serializer that would produce JSON Object version; used in\n+     * cases where array output can not be used.\n+     */\n+    protected final BeanSerializerBase _defaultSerializer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+\n+    public BeanAsArraySerializer(BeanSerializerBase src) {    \n+        super(src, (ObjectIdWriter) null);\n+        _defaultSerializer = src;\n+    }\n+\n+    protected BeanAsArraySerializer(BeanSerializerBase src, String[] toIgnore) {\n+        super(src, toIgnore);\n+        _defaultSerializer = src;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer(NameTransformer transformer) {\n+        /* If this gets called, we will just need delegate to the default\n+         * serializer, to \"undo\" as-array serialization\n+         */\n+        return _defaultSerializer.unwrappingSerializer(transformer);\n+    }\n+\n+    @Override\n+    public boolean isUnwrappingSerializer() {\n+        return false;\n+    }\n+\n+    @Override\n+    public BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+        // can't handle Object Ids, for now, so:\n+        return _defaultSerializer.withObjectIdWriter(objectIdWriter);\n+    }\n+\n+    @Override\n+    protected BeanAsArraySerializer withIgnorals(String[] toIgnore) {\n+        return new BeanAsArraySerializer(this, toIgnore);\n+    }\n+\n+    @Override\n+    protected BeanSerializerBase asArraySerializer() {\n+        // already is one, so:\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation that differs between impls\n+    /**********************************************************\n+     */\n+\n+    // Re-defined from base class...\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* Should not even get here; but let's be nice and re-routed\n+         * if need be.\n+         */\n+        _defaultSerializer.serializeWithType(bean, jgen, provider, typeSer);\n+    }\n+    \n+    /**\n+     * Main serialization method that will delegate actual output to\n+     * configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* note: it is assumed here that limitations (type id, object id,\n+         * any getter, filtering) have already been checked; so code here\n+         * is trivial.\n+         */\n+        jgen.writeStartArray();\n+        serializeAsArray(bean, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Field serialization methods\n+    /**********************************************************\n+     */\n+\n+    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n+                    jgen.writeNull();\n+                } else {\n+                    prop.serializeAsColumn(bean, jgen, provider);\n+                }\n+            }\n+            // NOTE: any getters can not be supported either\n+            //if (_anyGetterWriter != null) {\n+            //    _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            //}\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override public String toString() {\n+        return \"BeanAsArraySerializer for \"+handledType().getName();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n     }\n \n     @Override\n-    protected UnwrappingBeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+    public UnwrappingBeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n         return new UnwrappingBeanSerializer(this, objectIdWriter);\n     }\n \n     @Override\n     protected UnwrappingBeanSerializer withIgnorals(String[] toIgnore) {\n         return new UnwrappingBeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * JSON Array output can not be done if unwrapping operation is\n+     * requested; so implementation will simply return 'this'.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer() {\n+        return this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.core.*;\n      * \n      * @since 2.0\n      */\n-    protected abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n+    public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n \n     /**\n      * Fluent factory used for creating a new instance with additional\n      * @since 2.0\n      */\n     protected abstract BeanSerializerBase withIgnorals(String[] toIgnore);\n+\n+    /**\n+     * Fluent factory for creating a variant that output POJO as a\n+     * JSON Array. Implementations may ignore this request if output\n+     * as array is not possible (either at all, or reliably).\n+     * \n+     * @since 2.1\n+     */\n+    protected abstract BeanSerializerBase asArraySerializer();\n     \n     /**\n      * Copy-constructor that is useful for sub-classes that just want to\n         ObjectIdWriter oiw = _objectIdWriter;\n         String[] ignorals = null;\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n         \n         // First: may have an override for Object Id:\n         if (property != null && intr != null) {\n-            final AnnotatedMember accessor = property.getMember();\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n             if (objectIdInfo != null) {\n         if (ignorals != null && ignorals.length != 0) {\n             contextual = contextual.withIgnorals(ignorals);\n         }\n+        // One more thing: are we asked to serialize POJO as array?\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat(accessor);\n+\n+            if (format != null) {\n+                if (format.getShape() == JsonFormat.Shape.ARRAY) {\n+                    contextual = contextual.asArraySerializer();\n+                }\n+            }\n+        }\n         return contextual;\n     }\n     \n     /* Field serialization methods\n     /**********************************************************\n      */\n-    \n+\n     protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n         List<?> result = r.withType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n+\n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n+        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        // start with specific value case:\n+        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n+        // then lists\n+        list.add(new Issue822Impl());\n+        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+                .writeValueAsString(list);\n+        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n+    }\n+\n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+                new Issue822Interface[] { new Issue822Impl() }));\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArraySerialization.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPOJOAsArraySerialization extends BaseMapTest\n+{\n+    static class Pojo\n+    {\n+        @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+        public PojoValue value;\n+\n+        public Pojo() { }\n+        public Pojo(String name, int x, int y, boolean c) {\n+            value = new PojoValue(name, x, y, c);\n+        }\n+    }\n+\n+    // note: must be serialized/deserialized alphabetically; fields NOT declared in that order\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class PojoValue\n+    {\n+        public int x, y;\n+        public String name;\n+        public boolean complete;\n+\n+        public PojoValue() { }\n+        public PojoValue(String name, int x, int y, boolean c) {\n+            this.name = name;\n+            this.x = x;\n+            this.y = y;\n+            this.complete = c;\n+        }\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    static class FlatPojo\n+    {\n+        public int x, y;\n+        public String name;\n+        public boolean complete;\n+\n+        public FlatPojo() { }\n+        public FlatPojo(String name, int x, int y, boolean c) {\n+            this.name = name;\n+            this.x = x;\n+            this.y = y;\n+            this.complete = c;\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests\n+    /*****************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    /**\n+     * Test that verifies that property annotation works\n+     */\n+    public void testSimplePropertyValue() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new Pojo(\"Foobar\", 42, 13, true));\n+        // will have wrapper POJO, then POJO-as-array..\n+        assertEquals(\"{\\\"value\\\":[true,\\\"Foobar\\\",42,13]}\", json);\n+    }\n+\n+    /**\n+     * Test that verifies that Class annotation works\n+     */\n+    public void testSimpleRootValue() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new FlatPojo(\"Bubba\", 1, 2, false));\n+        // will have wrapper POJO, then POJO-as-array..\n+        assertEquals(\"[false,\\\"Bubba\\\",1,2]\", json);\n+    }\n+    \n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n     \n     /*\n     /******************************************************\n-     *  Structural conversion features\n+    /* Structural conversion features\n     /******************************************************\n      */\n \n      * \n      * @since 2.0\n      */\n-    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false)\n+    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false),\n+\n+    /*\n+    /******************************************************\n+    /* Other\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether {@link ObjectReader} should\n+     * try to eagerly fetch necessary {@link JsonDeserializer} when\n+     * possible. This improves performance in cases where similarly\n+     * configured {@link ObjectReader} instance is used multiple\n+     * times; and should not significantly affect single-use cases.\n+     *<p>\n+     * Note that there should not be any need to normally disable this\n+     * feature: only consider that if there are actual perceived problems.\n+     *<p>\n+     * Feature is enabled by default.\n+     * \n+     * @since 2.1\n+     */\n+    EAGER_DESERIALIZER_FETCH(true)\n+    \n     ;\n \n     private final boolean _defaultState;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     /**\n      * Method that returns the shared default {@link SerializationConfig}\n      * object that defines configuration settings for serialization.\n-     * Returned object is \"live\" meaning that changes will be used\n-     * for future serialization operations for this mapper when using\n-     * mapper's default configuration\n+     *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n      */\n     public SerializationConfig getSerializationConfig() {\n         return _serializationConfig;\n      * Method that returns\n      * the shared default {@link DeserializationConfig} object\n      * that defines configuration settings for deserialization.\n-     * Returned object is \"live\" meaning that changes will be used\n-     * for future deserialization operations for this mapper when using\n-     * mapper's default configuration\n+     *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n      */\n     public DeserializationConfig getDeserializationConfig() {\n         return _deserializationConfig;\n         _deserializationConfig = _deserializationConfig.with(ai);\n         return this;\n     }\n+\n+    /**\n+     * Method for changing {@link AnnotationIntrospector} instances used\n+     * by this mapper instance for serialization and deserialization,\n+     * specifying them separately so that different introspection can be\n+     * used for different aspects\n+     * \n+     * @since 2.1\n+     * \n+     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n+     *    serialization\n+     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n+     *    deserialization\n+     */\n+    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n+            AnnotationIntrospector deserializerAI) {\n+        _serializationConfig = _serializationConfig.with(serializerAI);\n+        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n+        return this;\n+    }\n     \n     /**\n      * Method for setting custom property naming strategy to use.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n  * deserialization parameters, such as root type to use or object\n  * to update (instead of constructing new instance).\n  *<p>\n- * Uses \"fluent\" (aka builder) pattern so that instances are immutable\n+ * Uses \"fluent\" (or, kind of, builder) pattern so that instances are immutable\n  * (and thus fully thread-safe with no external synchronization);\n  * new instances are constructed for different configurations.\n  * Instances are initially constructed by {@link ObjectMapper} and can be\n     protected final JavaType _valueType;\n \n     /**\n+     * We may pre-fetch deserializer as soon as {@link #_valueType}\n+     * is known, and if so, reuse it afterwards.\n+     * This allows avoiding further deserializer lookups and increases\n+     * performance a bit on cases where readers are reused.\n+     * \n+     * @since 2.1\n+     */\n+    protected final JsonDeserializer<Object> _rootDeserializer;\n+    \n+    /**\n      * Instance to update with data binding; if any. If null,\n      * a new instance is created, if non-null, properties of\n      * this value object will be updated instead.\n         this(mapper, config, null, null, null, null);\n     }\n \n+    /**\n+     * Constructor called when a root deserializer should be fetched based\n+     * on other configuration.\n+     */\n     protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n-            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n-            InjectableValues injectableValues)\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues)\n     {\n         _config = config;\n         _context = mapper._deserializationContext;\n         _schema = schema;\n         _injectableValues = injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n+\n+        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n     }\n     \n     /**\n      * Copy constructor used for building variations.\n      */\n     protected ObjectReader(ObjectReader base, DeserializationConfig config,\n-            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n-            InjectableValues injectableValues)\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues)\n     {\n         _config = config;\n         _context = base._context;\n         _rootNames = base._rootNames;\n \n         _valueType = valueType;\n+        _rootDeserializer = rootDeser;\n         _valueToUpdate = valueToUpdate;\n         if (valueToUpdate != null && valueType.isArrayType()) {\n             throw new IllegalArgumentException(\"Can not update an array value\");\n         _rootNames = base._rootNames;\n \n         _valueType = base._valueType;\n+        _rootDeserializer = base._rootDeserializer;\n         _valueToUpdate = base._valueToUpdate;\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n     }\n-    \n+\n     /**\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues);\n     }\n \n         if (_schema == schema) {\n             return this;\n         }\n-        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues);\n     }\n     \n     public ObjectReader withType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) return this;\n+        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n         // type is stored here, no need to make a copy of config\n-        return new ObjectReader(this, _config, valueType, _valueToUpdate,\n+        return new ObjectReader(this, _config,\n+                valueType, rootDeser, _valueToUpdate,\n                 _schema, _injectableValues);\n     }    \n \n         if (value == null) {\n             throw new IllegalArgumentException(\"cat not update null value\");\n         }\n-        JavaType t = (_valueType == null) ? _config.constructType(value.getClass()) : _valueType;\n-        return new ObjectReader(this, _config, t, value,\n+        JavaType t;\n+        \n+        /* no real benefit from pre-fetching, as updating readers are much\n+         * less likely to be reused, and value type may also be forced\n+         * with a later chained call...\n+         */\n+        if (_valueType == null) {\n+            t = _config.constructType(value.getClass());\n+        } else {\n+            t = _valueType;\n+        }\n+        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues);\n     }\n \n         return t;\n     }\n \n+    \n+static int col = 0;\n+\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n-    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n+    protected final JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n             JavaType valueType)\n         throws JsonMappingException\n     {\n+        /*\n+if (++col > 76) { col = 0; System.out.println(); }\n+System.out.print((_rootDeserializer == null) ? '0' : '1');\n+*/\n+        \n+        if (_rootDeserializer != null) {\n+            return _rootDeserializer;\n+        }\n+\n         // Sanity check: must have actual type...\n         if (valueType == null) {\n             throw new JsonMappingException(\"No value type configured for ObjectReader\");\n         return deser;\n     }\n \n+    /**\n+     * Method called to locate deserializer ahead of time, if permitted\n+     * by configuration. Method also is NOT to throw an exception if\n+     * access fails.\n+     */\n+    protected final JsonDeserializer<Object> _prefetchRootDeserializer(\n+            DeserializationConfig config, JavaType valueType)\n+    {\n+        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n+            return null;\n+        }\n+        // already cached?\n+        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n+        if (deser == null) {\n+            try {\n+                // If not, need to resolve; for which we need a temporary context as well:\n+                DeserializationContext ctxt = createDeserializationContext(null, _config);\n+                deser = ctxt.findRootValueDeserializer(valueType);\n+                if (deser != null) {\n+                    _rootDeserializers.put(valueType, deser);\n+                }\n+                return deser;\n+                \n+            } catch (JsonProcessingException e) {\n+                // need to swallow?\n+            }\n+        }\n+        return deser;\n+    }\n+    \n     protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n             JavaType rootType, JsonDeserializer<Object> deser)\n         throws IOException, JsonParseException, JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     protected final JavaType _rootType;\n \n     /**\n+     * We may pre-fetch serializer if {@link #_rootType}\n+     * is known, and if so, reuse it afterwards.\n+     * This allows avoiding further serializer lookups and increases\n+     * performance a bit on cases where readers are reused.\n+     * \n+     * @since 2.1\n+     */\n+    protected final JsonSerializer<Object> _rootSerializer;\n+    \n+    /**\n      * To allow for dynamic enabling/disabling of pretty printing,\n      * pretty printer can be optionally configured for writer\n      * as well\n         _rootType = rootType;\n         _prettyPrinter = pp;\n         _schema = null;\n-    }\n-\n-    /**\n-     * Alternative constructor for initial instantiation.\n+\n+        _rootSerializer = _prefetchRootSerializer(config, rootType);\n+    }\n+\n+    /**\n+     * Alternative constructor for initial instantiation by {@link ObjectMapper}\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n         _jsonFactory = mapper._jsonFactory;\n \n         _rootType = null;\n+        _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = null;\n     }\n \n     /**\n-     * Alternative constructor for initial instantiation.\n+     * Alternative constructor for initial instantiation by {@link ObjectMapper}\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config,\n             FormatSchema s)\n         _jsonFactory = mapper._jsonFactory;\n \n         _rootType = null;\n+        _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = s;\n     }\n      * Copy constructor used for building variations.\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n-            JavaType rootType, PrettyPrinter pp, FormatSchema s)\n+            JavaType rootType, JsonSerializer<Object> rootSer,\n+            PrettyPrinter pp, FormatSchema s)\n     {\n         _config = config;\n \n         _jsonFactory = base._jsonFactory;\n         \n         _rootType = rootType;\n+        _rootSerializer = rootSer;\n         _prettyPrinter = pp;\n         _schema = s;\n     }\n         _schema = base._schema;\n         \n         _rootType = base._rootType;\n+        _rootSerializer = base._rootSerializer;\n         _prettyPrinter = base._prettyPrinter;\n     }\n     \n         if (pp == null) {\n             pp = NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, _config, _rootType, pp, _schema);\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema);\n     }\n \n     /**\n     public ObjectWriter withSchema(FormatSchema schema)\n     {\n         return (_schema == schema) ? this :\n-            new ObjectWriter(this, _config, _rootType, _prettyPrinter, schema);\n+            new ObjectWriter(this, _config, _rootType, _rootSerializer, _prettyPrinter, schema);\n     }\n     \n     /**\n      */\n     public ObjectWriter withType(JavaType rootType)\n     {\n+        JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType);\n         return (rootType == _rootType) ? this\n         // type is stored here, no need to make a copy of config\n-            : new ObjectWriter(this, _config, rootType, _prettyPrinter, _schema);\n+            : new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema);\n     }    \n \n     /**\n             if (_rootType == null) {\n                 _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType);\n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             if (_rootType == null) {\n                 _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType);                \n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             closed = true;\n             jgen.close();\n             if (_rootType == null) {\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value);\n+                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             // [JACKSON-520]: add support for pass-through schema:\n             if (_schema != null) {\n             if (_rootType == null) {\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value, _rootType);\n+                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n     }\n+\n+    /**\n+     * Method called to locate (root) serializer ahead of time, if permitted\n+     * by configuration. Method also is NOT to throw an exception if\n+     * access fails.\n+     */\n+    protected final JsonSerializer<Object> _prefetchRootSerializer(\n+            SerializationConfig config, JavaType valueType)\n+    {\n+        if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n+            return null;\n+        }\n+        try {\n+            return _serializerProvider(config).findTypedValueSerializer(valueType, true, null);\n+        } catch (JsonProcessingException e) {\n+            // need to swallow?\n+            return null;\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n      \n     /*\n     /******************************************************\n-    /* Data type - specific serialization configuration\n+    /* Datatype-specific serialization configuration\n     /******************************************************\n      */\n \n      *<p>\n      * Feature is disabled by default.\n      */\n-    ORDER_MAP_ENTRIES_BY_KEYS(false)\n-        ;\n+    ORDER_MAP_ENTRIES_BY_KEYS(false),\n+\n+    /*\n+    /******************************************************\n+    /* Other\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether {@link ObjectWriter} should\n+     * try to eagerly fetch necessary {@link JsonSerializer} when\n+     * possible. This improves performance in cases where similarly\n+     * configured {@link ObjectWriter} instance is used multiple\n+     * times; and should not significantly affect single-use cases.\n+     *<p>\n+     * Note that there should not be any need to normally disable this\n+     * feature: only consider that if there are actual perceived problems.\n+     *<p>\n+     * Feature is enabled by default.\n+     * \n+     * @since 2.1\n+     */\n+    EAGER_SERIALIZER_FETCH(true)    \n+    ;\n \n     private final boolean _defaultState;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n- * Default {@link DeserializationContext} implementation that adds\n+ * Complete {@link DeserializationContext} implementation that adds\n  * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n  * to call, as well as implements certain parts that base class\n  * has left abstract.\n+ * The remaining abstract methods ({@link #createInstance}, {@link #with})\n+ * are left so that custom implementations will properly implement them\n+ * to return intended subtype.\n  */\n public abstract class DefaultDeserializationContext\n     extends DeserializationContext\n     /**********************************************************\n      */\n \n+    /**\n+     * Actual full concrete implementation\n+     */\n     public final static class Impl extends DefaultDeserializationContext\n     {\n         /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n @JacksonStdImpl\n public class CollectionDeserializer\n     extends ContainerDeserializerBase<Collection<Object>>\n-implements ContextualDeserializer\n+    implements ContextualDeserializer\n {\n     // // Configuration\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue();\n             }\n-            return jp.getIntValue();\n+            /* and as per [JACKSON-839], allow \"upgrade\" to bigger types: out-of-range\n+             * entries can not be produced without type, so this should \"just work\",\n+             * even if it is bit unclean\n+             */\n+            return jp.getNumberValue();\n \n         case VALUE_NUMBER_FLOAT:\n             // For [JACKSON-72], see above\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n      */\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException;\n+    \n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param isOptional Is the type optional\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n package com.fasterxml.jackson.databind.node;\n \n import java.io.IOException;\n+import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n         return null;\n     }\n \n+\n+    @Override\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n+            throws IOException, JsonParseException\n+    {\n+        byte[] data = getBinaryValue(b64variant);\n+        if (data != null) {\n+            out.write(data, 0, data.length);\n+            return data.length;\n+        }\n+        return 0;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n         throws JsonMappingException\n     {\n+         // Module-provided custom collection serializers?\n+         for (Serializers serializers : customSerializers()) {\n+             JsonSerializer<?> ser = serializers.findArraySerializer(config,\n+                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+             if (ser != null) {\n+                 return ser;\n+             }\n+         }\n         Class<?> raw = type.getRawClass();\n         // Important: do NOT use standard serializers if non-standard element value serializer specified\n         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             }\n         }\n \n-        // Modules may provide serializers of all types:\n-        for (Serializers serializers : _factoryConfig.serializers()) {\n-            ser = serializers.findSerializer(config, type, beanDesc);\n-            if (ser != null) {\n-                return (JsonSerializer<Object>) ser;\n-            }\n-        }\n-\n         // Then JsonSerializable, @JsonValue etc:\n         ser = findSerializerByAnnotations(prov, type, beanDesc);\n         if (ser != null) {\n             return (JsonSerializer<Object>) ser;\n         }\n         \n-        // Container types differ from non-container types:\n+        // Container types differ from non-container types\n+        // (note: called method checks for module-provided serializers)\n         if (origType.isContainerType()) {\n             if (!staticTyping) {\n                 staticTyping = usesStaticTyping(config, beanDesc, null, property);\n+                // [JACKSON-822]: Need to figure out how to force passed parameterization\n+                //  to stick...\n+                /*\n+                if (property == null) {\n+                    JavaType t = origType.getContentType();\n+                    if (t != null && !t.hasRawClass(Object.class)) {\n+                        staticTyping = true;\n+                    }\n+                }\n+                */\n             }\n             return (JsonSerializer<Object>) buildContainerSerializer(prov,\n                     type, beanDesc, property, staticTyping);\n+        }\n+\n+        // Modules may provide serializers of POJO types:\n+        for (Serializers serializers : customSerializers()) {\n+            ser = serializers.findSerializer(config, type, beanDesc);\n+            if (ser != null) {\n+                return (JsonSerializer<Object>) ser;\n+            }\n         }\n         \n         /* Otherwise, we will check \"primary types\"; both marker types that\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n  * as well as constructors.\n  *<p>\n  * Note that class is abstract just because it does not\n- * define\n+ * define {@link #createInstance} method.\n+ *<p>\n+ * Also note that all custom {@link SerializerProvider}\n+ * implementations must sub-class this class: {@link ObjectMapper}\n+ * requires this type, not basic provider type.\n  */\n public abstract class DefaultSerializerProvider extends SerializerProvider\n {\n     /**********************************************************\n      */\n \n+    /**\n+     * Per-serialization map Object Ids that have seen so far, iff\n+     * Object Id handling is enabled.\n+     */\n     protected IdentityHashMap<Object, WritableObjectId> _seenObjectIds;\n     \n     protected ArrayList<ObjectIdGenerator<?>> _objectIdGenerators;\n         throws IOException, JsonGenerationException\n     {\n         JsonSerializer<Object> ser;\n-        boolean wrap;\n-\n-        if (value == null) {\n-            // no type provided; must just use the default null serializer\n+        final boolean wrap;\n+\n+        if (value == null) { // no type provided; must just use the default null serializer\n             ser = getDefaultNullValueSerializer();\n             wrap = false; // no name to use for wrapping; can't do!\n         } else {\n             if (wrap) {\n                 jgen.writeEndObject();\n             }\n-        } catch (IOException ioe) {\n-            /* As per [JACKSON-99], should not wrap IOException or its\n-             * sub-classes (like JsonProcessingException, JsonMappingException)\n-             */\n+        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n-        } catch (Exception e) {\n-            // but others are wrapped\n+        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             String msg = e.getMessage();\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value,\n-            JavaType rootType)\n+    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonGenerationException\n     {\n-        boolean wrap;\n+        final boolean wrap;\n \n         JsonSerializer<Object> ser;\n         if (value == null) {\n         }\n     }\n \n+    /**\n+     * The method to be called by {@link ObjectWriter}\n+     * for serializing given value (assumed to be of specified root type,\n+     * instead of runtime type of value), when it may know specific\n+     * {@link JsonSerializer} to use.\n+     * \n+     * @param rootType Type to use for locating serializer to use, instead of actual\n+     *    runtime type, if no serializer is passed\n+     * @param ser Root Serializer to use, if not null\n+     * \n+     * @since 2.1\n+     */\n+    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final boolean wrap;\n+\n+        if (value == null) {\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (rootType != null) {\n+                if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                    _reportIncompatibleRootType(value, rootType);\n+                }\n+            }\n+            // root value, not reached via property:\n+            if (ser == null) {\n+                ser = findTypedValueSerializer(rootType, true, null);\n+            }\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+    \n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n      * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n             if (id != null && id.length() > 0) {\n                 o.put(\"id\", id);\n             }\n-        }        \n+        }\n+ \n         //todo: should the classname go in the title?\n         //o.put(\"title\", _className);\n         ObjectNode propertiesNode = o.objectNode();\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n             JavaType propType = prop.getSerializationType();\n+\n             // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n             Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n             // Maybe it already has annotated/statically configured serializer?\n                 }\n                 ser = provider.findValueSerializer(serType, prop);\n             }\n+            boolean isOptional = !isPropertyRequired(prop, provider);\n+            \n             JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                    ((SchemaAware) ser).getSchema(provider, hint) : \n+                    ((SchemaAware) ser).getSchema(provider, hint, isOptional) : \n                     JsonSchema.getDefaultSchemaNode();\n             propertiesNode.put(prop.getName(), schemaNode);\n         }\n         o.put(\"properties\", propertiesNode);\n         return o;\n     }\n+\n+    /**\n+     * Determines if a bean property is required, as determined by\n+     * {@link com.fasterxml.jackson.databind.AnnotationIntrospector#hasRequiredMarker}.\n+     *<p>\n+     * \n+     * \n+     * @param prop the bean property.\n+     * @return true if the property is optional, false otherwise.\n+     */\n+    private boolean isPropertyRequired(final BeanPropertyWriter prop, final SerializerProvider provider) {\n+        Boolean value = provider.getAnnotationIntrospector().hasRequiredMarker(prop.getMember());\n+        return (value == null) ? false : value.booleanValue();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n         return createSchemaNode(\"string\");\n     }\n     \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+//    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException\n+    {\n+    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n+    \tif (!isOptional) {\n+    \t\tschema.put(\"required\", !isOptional);\n+    \t}\n+        return schema;\n+    }\n+    \n     protected ObjectNode createObjectNode() {\n         return JsonNodeFactory.instance.objectNode();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n package com.fasterxml.jackson.databind.util;\n \n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n         writeObject(copy);\n     }\n \n+    /**\n+     * Although we could support this method, it does not necessarily make\n+     * sense: we can not make good use of streaming because buffer must\n+     * hold all the data. Because of this, currently this will simply\n+     * throw {@link UnsupportedOperationException}\n+     */\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonGenerator implementation; pass-through copy\n             return builder.toByteArray();\n         }\n \n+        @Override\n+        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException\n+        {\n+            byte[] data = getBinaryValue(b64variant);\n+            if (data != null) {\n+                out.write(data, 0, data.length);\n+                return data.length;\n+            }\n+            return 0;\n+        }\n+        \n         /*\n         /**********************************************************\n         /* Internal methods\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n         @Override\n         protected void _closeInput() throws IOException {\n         }\n+\n+        @Override\n+        public int readBinaryValue(Base64Variant b64variant, OutputStream out) {\n+            return 0;\n+        }\n     }\n \n     static class GeneratorWithSchema extends GeneratorBase\n         public void writeUTF8String(byte[] text, int offset, int length) { }\n \n         @Override\n-        public void writeStartArray() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeEndArray() throws IOException, JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeStartObject() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n-        }\n-\n-        @Override\n-        public void writeEndObject() throws IOException,\n-                JsonGenerationException {\n-            // TODO Auto-generated method stub\n-            \n+        public void writeStartArray() { }\n+\n+        @Override\n+        public void writeEndArray() throws IOException, JsonGenerationException { }\n+\n+        @Override\n+        public void writeStartObject() { }\n+\n+        @Override\n+        public void writeEndObject() { }\n+\n+        @Override\n+        public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n+            return -1;\n         }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n {\n     // Not a good to do this, but has to do, for now...\n     private final static int MAJOR_VERSION = 2;\n-    private final static int MINOR_VERSION = 0;\n+    private final static int MINOR_VERSION = 1;\n \n     private final static String GROUP_ID = \"com.fasterxml.jackson.core\";\n     private final static String ARTIFACT_ID = \"jackson-databind\";\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     static class XBean {\n         public int x;\n     }\n-\n-    // [JACKSON-822]\n-    static interface Issue822Interface {\n-        public int getA();\n-    }\n-\n-    // If this annotation is added, things will work:\n-    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n-    // but it should not be necessary when root type is passed\n-    static class Issue822Impl implements Issue822Interface {\n-        public int getA() { return 3; }\n-        public int getB() { return 9; }\n-    }\n     \n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testUntypedList() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get \"untyped\" default List, pass Object.class\n         String JSON = \"[ \\\"text!\\\", true, null, 23 ]\";\n \n-        /* Not a guaranteed cast theoretically, but will work:\n-         * (since we know that Jackson will construct an ArrayList here...)\n-         */\n-        Object value = mapper.readValue(JSON, Object.class);\n+        // Not a guaranteed cast theoretically, but will work:\n+        // (since we know that Jackson will construct an ArrayList here...)\n+        Object value = MAPPER.readValue(JSON, Object.class);\n         assertNotNull(value);\n         assertTrue(value instanceof ArrayList<?>);\n         List<?> result = (List<?>) value;\n \n     public void testExactStringCollection() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get typing, must use type reference\n         String JSON = \"[ \\\"a\\\", \\\"b\\\" ]\";\n-        List<String> result = mapper.readValue(JSON, new TypeReference<ArrayList<String>>() { });\n+        List<String> result = MAPPER.readValue(JSON, new TypeReference<ArrayList<String>>() { });\n \n         assertNotNull(result);\n         assertEquals(ArrayList.class, result.getClass());\n \n     public void testHashSet() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         String JSON = \"[ \\\"KEY1\\\", \\\"KEY2\\\" ]\";\n \n-        EnumSet<Key> result = mapper.readValue(JSON, new TypeReference<EnumSet<Key>>() { });\n+        EnumSet<Key> result = MAPPER.readValue(JSON, new TypeReference<EnumSet<Key>>() { });\n         assertNotNull(result);\n         assertTrue(EnumSet.class.isAssignableFrom(result.getClass()));\n         assertEquals(2, result.size());\n         assertFalse(result.contains(Key.WHATEVER));\n     }\n \n-    /**\n-     * Test to verify that @JsonDeserialize.using works as expected\n-     */\n+    /// Test to verify that @JsonDeserialize.using works as expected\n     public void testCustomDeserializer() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        CustomList result = mapper.readValue(quote(\"abc\"), CustomList.class);\n+        CustomList result = MAPPER.readValue(quote(\"abc\"), CustomList.class);\n         assertEquals(1, result.size());\n         assertEquals(\"abc\", result.get(0));\n     }\n \n-    /* Testing [JACKSON-526], \"implicit JSON array\" for single-element arrays,\n-     * mostly produced by Jettison, Badgerfish conversions (from XML)\n-     */\n+    // Testing [JACKSON-526], \"implicit JSON array\" for single-element arrays,\n+    // mostly produced by Jettison, Badgerfish conversions (from XML)\n     @SuppressWarnings(\"unchecked\")\n     public void testImplicitArrays() throws Exception\n     {\n+        // can't share mapper, custom configs (could create ObjectWriter tho)\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n \n     // [JACKSON-620]: allow \"\" to mean 'null' for Maps\n     public void testFromEmptyString() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n-        List<?> result = m.readValue(quote(\"\"), List.class);\n+        ObjectReader r = MAPPER.reader(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+        List<?> result = r.withType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n \n-    // 24-May-2012, tatu: Comment out for 2.0.x to keep tests green; leave for 2.1 to fix\n-    \n-    /*\n     // [JACKSON-822]: ensure that type can be coerced\n     public void testTypedLists() throws Exception\n     {\n         assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n                 new Issue822Interface[] { new Issue822Impl() }));\n     }\n-    */\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+/**\n+ * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * one that only uses core JDK types; wrappers, Maps and Lists.\n+ */\n+public class TestUntypedDeserialization\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSampleDoc()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* To get \"untyped\" Mapping (to Maps, Lists, instead of beans etc),\n+         * we'll specify plain old Object.class as the target.\n+         */\n+        Object root = new ObjectMapper().readValue(jf.createJsonParser(new StringReader(JSON)), Object.class);\n+\n+        assertType(root, Map.class);\n+        Map<?,?> rootMap = (Map<?,?>) root;\n+        assertEquals(1, rootMap.size());\n+        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();\n+        assertEquals(\"Image\", rootEntry.getKey());\n+        Object image = rootEntry.getValue();\n+        assertType(image, Map.class);\n+        Map<?,?> imageMap = (Map<?,?>) image;\n+        assertEquals(5, imageMap.size());\n+\n+        Object value = imageMap.get(\"Width\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);\n+\n+        value = imageMap.get(\"Height\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);\n+\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get(\"Title\"));\n+\n+        // Another Object, \"thumbnail\"\n+        value = imageMap.get(\"Thumbnail\");\n+        assertType(value, Map.class);\n+        Map<?,?> tnMap = (Map<?,?>) value;\n+        assertEquals(3, tnMap.size());\n+\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get(\"Height\"));\n+        // for some reason, width is textual, not numeric...\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get(\"Width\"));\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get(\"Url\"));\n+\n+        // And then number list, \"IDs\"\n+        value = imageMap.get(\"IDs\");\n+        assertType(value, List.class);\n+        List<Object> ids = (List<Object>) value;\n+        assertEquals(4, ids.size());\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));\n+\n+        // and that's all folks!\n+    }\n+\n+    // [JACKSON-839]: allow 'upgrade' of big integers into Long, BigInteger\n+    public void testObjectSerializeWithLong() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT, As.PROPERTY);\n+        final long VALUE = 1337800584532L;\n+\n+        String serialized = \"{\\\"timestamp\\\":\"+VALUE+\"}\";\n+        // works fine as node\n+        JsonNode deserialized = mapper.readTree(serialized);\n+        assertEquals(VALUE, deserialized.get(\"timestamp\").asLong());\n+        // and actually should work in Maps too\n+        Map<?,?> deserMap = mapper.readValue(serialized, Map.class);\n+        Number n = (Number) deserMap.get(\"timestamp\");\n+        assertNotNull(n);\n+        assertSame(Long.class, n.getClass());\n+        assertEquals(Long.valueOf(VALUE), n);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n         private String property2;\n         private String[] property3;\n         private Collection<Float> property4;\n-\n+        @JsonProperty(required=true)\n+        private String property5;\n+        \n         public int getProperty1()\n         {\n             return property1;\n         {\n             this.property4 = property4;\n         }\n+        \n+        public String getProperty5()\n+        {\n+            return property5;\n+        }\n+\n+        public void setProperty5(String property5)\n+        {\n+            this.property5 = property5;\n+        }\n     }\n \n     public class TrivialBean {\n         throws Exception\n     {\n         JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+        \n         assertNotNull(jsonSchema);\n \n         // test basic equality, and that equals() handles null, other obs\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n     /**********************************************************\n      */\n \n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testCollections()\n         throws IOException\n     {\n         // Let's try different collections, arrays etc\n         final int entryLen = 98;\n-        ObjectMapper mapper = new ObjectMapper();\n \n         for (int type = 0; type < 4; ++type) {\n             Object value;\n                 }\n                 value = c;\n             }\n-            StringWriter sw = new StringWriter();\n-            mapper.writeValue(sw, value);\n+            String json = MAPPER.writeValueAsString(value);\n             \n             // and then need to verify:\n-            JsonParser jp = new JsonFactory().createJsonParser(sw.toString());\n+            JsonParser jp = new JsonFactory().createJsonParser(json);\n             assertToken(JsonToken.START_ARRAY, jp.nextToken());\n             for (int i = 0; i < entryLen; ++i) {\n                 assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n         for (int i = 0; i <= COUNT; ++i) {\n             value.add(i);\n         }\n-        ObjectMapper mapper = new ObjectMapper();\n         // Let's test using 3 main variants...\n         for (int mode = 0; mode < 3; ++mode) {\n             JsonParser jp = null;\n             switch (mode) {\n             case 0:\n                 {\n-                    byte[] data = mapper.writeValueAsBytes(value);\n+                    byte[] data = MAPPER.writeValueAsBytes(value);\n                     jp = new JsonFactory().createJsonParser(data);\n                 }\n                 break;\n             case 1:\n                 {\n                     StringWriter sw = new StringWriter(value.size());\n-                    mapper.writeValue(sw, value);\n+                    MAPPER.writeValue(sw, value);\n                     jp = createParserUsingReader(sw.toString());\n                 }\n                 break;\n             case 2:\n                 {\n-                    String str = mapper.writeValueAsString(value);\n+                    String str = MAPPER.writeValueAsString(value);\n                     jp = createParserUsingReader(str);\n                 }\n                 break;\n     public void testEnumMap()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringWriter sw = new StringWriter();\n         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n         map.put(Key.B, \"xyz\");\n         map.put(Key.C, \"abc\");\n         // assuming EnumMap uses enum entry order, which I think is true...\n-        mapper.writeValue(sw, map);\n-        assertEquals(\"{\\\"B\\\":\\\"xyz\\\",\\\"C\\\":\\\"abc\\\"}\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(map);\n+        assertEquals(\"{\\\"B\\\":\\\"xyz\\\",\\\"C\\\":\\\"abc\\\"}\",json.trim());\n     }\n \n     public void testIterator()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         ArrayList<Integer> l = new ArrayList<Integer>();\n         l.add(1);\n         l.add(-9);\n         l.add(0);\n-        mapper.writeValue(sw, l.iterator());\n+        MAPPER.writeValue(sw, l.iterator());\n         assertEquals(\"[1,-9,0]\", sw.toString().trim());\n     }\n \n     public void testIterable()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));\n+        MAPPER.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));\n         assertEquals(\"[1,2,3]\", sw.toString().trim());\n     }\n \n         Collection<Object> x = new ArrayList<Object>();\n         x.add(\"foobar\");\n         CollectionBean cb = new CollectionBean(x);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, cb);\n+        Map<String,Object> result = writeAndMap(MAPPER, cb);\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"values\"));\n         Collection<Object> x2 = (Collection<Object>) result.get(\"values\");\n         throws IOException\n     {\n         CollectionBean cb = new CollectionBean(null);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, cb);\n+        Map<String,Object> result = writeAndMap(MAPPER, cb);\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"values\"));\n         assertNull(result.get(\"values\"));\n     {\n         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n         EnumMapBean b = new EnumMapBean(map);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, b);\n+        Map<String,Object> result = writeAndMap(MAPPER, b);\n \n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"map\"));\n         throws IOException\n     {\n         EnumMapBean b = new EnumMapBean(null);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, b);\n+        Map<String,Object> result = writeAndMap(MAPPER, b);\n \n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"map\"));\n     // Test [JACKSON-220]\n     public void testListSerializer() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertEquals(\"\\\"[ab, cd, ef]\\\"\", m.writeValueAsString(new PseudoList(\"ab\", \"cd\", \"ef\")));\n+        assertEquals(\"\\\"[ab, cd, ef]\\\"\",\n+                MAPPER.writeValueAsString(new PseudoList(\"ab\", \"cd\", \"ef\")));\n     }\n \n     // [JACKSON-254]\n         // by default, empty lists serialized normally\n         EmptyListBean list = new EmptyListBean();\n         EmptyArrayBean array = new EmptyArrayBean();\n+        assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n+        assertEquals(\"{\\\"empty\\\":[]}\", MAPPER.writeValueAsString(list));\n+        assertEquals(\"{\\\"empty\\\":[]}\", MAPPER.writeValueAsString(array));\n+\n+        // note: value of setting may be cached when constructing serializer, need a new instance\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n-        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(list));\n-        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(array));\n-\n-        // note: value of setting may be cached when constructing serializer, need a new instance\n-        m = new ObjectMapper();\n         m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);\n         assertEquals(\"{}\", m.writeValueAsString(list));\n         assertEquals(\"{}\", m.writeValueAsString(array));\n     // [JACKSON-689]\n     public void testWithIterable() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\", m.writeValueAsString(new BeanWithIterable()));\n+        assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\",\n+                MAPPER.writeValueAsString(new BeanWithIterable()));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonValue.java\n         @JsonValue\n         public int value() { return 13; }\n     }\n+\n+    static class IntExtBean {\n+        public List<Internal> values = new ArrayList<Internal>();\n+        \n+        public void add(int v) { values.add(new Internal(v)); }\n+    }\n+    \n+    static class Internal {\n+        public int value;\n+        \n+        public Internal(int v) { value = v; }\n+        \n+        @JsonValue\n+        public External asExternal() { return new External(this); }\n+    }\n+    \n+    static class External {\n+        public int i;\n+        \n+        External(Internal e) { i = e.value; }\n+    }\n     \n     /*\n     /*********************************************************\n     public void testWithList() throws Exception {\n         assertEquals(\"13\", MAPPER.writeValueAsString(new ListAsNumber()));\n     }\n+\n+    public void testInList() throws Exception {\n+        IntExtBean bean = new IntExtBean();\n+        bean.add(1);\n+        bean.add(2);\n+        String json = MAPPER.writeValueAsString(bean);\n+        assertEquals(json, \"{\\\"values\\\":[{\\\"i\\\":1},{\\\"i\\\":2}]}\");\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestUntypedSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tries verify simplest aspects of\n+ * \"Native\" java type mapper; basically that is can properly serialize\n+ * core JDK objects to JSON.\n+ */\n+public class TestUntypedSerialization\n+    extends BaseMapTest\n+{\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ArrayList<Object> doc = new ArrayList<Object>();\n+        doc.add(\"Elem1\");\n+        doc.add(Integer.valueOf(3));\n+        Map<String,Object> struct = new LinkedHashMap<String, Object>();\n+        struct.put(\"first\", Boolean.TRUE);\n+        struct.put(\"Second\", new ArrayList<Object>());\n+        doc.add(struct);\n+        doc.add(Boolean.FALSE);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f =  new JsonFactory();\n+\n+        // loop more than once, just to ensure caching works ok (during second round)\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            \n+            JsonParser jp = f.createJsonParser(str);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"Elem1\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(3, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"first\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"Second\", getAndVerifyText(jp));\n+            \n+            if (jp.nextToken() != JsonToken.START_ARRAY) {\n+                fail(\"Expected START_ARRAY: JSON == '\"+str+\"'\");\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+            \n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();\n+        JsonFactory f =  new JsonFactory();\n+\n+        doc.put(\"a1\", \"\\\"text\\\"\");\n+        doc.put(\"int\", Integer.valueOf(137));\n+        doc.put(\"foo bar\", Long.valueOf(1234567890L));\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            JsonParser jp = f.createJsonParser(str);\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"a1\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"\\\"text\\\"\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"int\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(137, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"foo bar\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1234567890L, jp.getLongValue());\n+            \n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestCollectionSerialization.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestCollectionSerialization extends BaseMapTest\n+{\n+    // [JACKSON-822]\n+    static interface Issue822Interface {\n+        public int getA();\n+    }\n+\n+    // If this annotation is added, things will work:\n+    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n+    // but it should not be necessary when root type is passed\n+    static class Issue822Impl implements Issue822Interface {\n+        public int getA() { return 3; }\n+        public int getB() { return 9; }\n+    }\n+\n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+                new Issue822Interface[] { new Issue822Impl() }));\n+    }\n+    \n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n+\n+        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        // start with specific value case:\n+        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n+\n+        // then lists\n+        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n+        list.add(new Issue822Impl());\n+        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+                .writeValueAsString(list);\n+        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/perf/ManualObjectReaderPerf.java\n+package perf;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Simple manually run micro-benchmark for checking effects of (de)serializer\n+ * pre-fetching\n+ */\n+public class ManualObjectReaderPerf\n+{\n+    protected int hash;\n+    \n+    private <T> void test(ObjectMapper mapper, T inputValue, Class<T> inputClass)\n+        throws Exception\n+    {\n+        final byte[] input = mapper.writeValueAsBytes(inputValue);\n+        \n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        final int REPS = (int) ((double) (8 * 1000 * 1000) / (double) input.length);\n+\n+        System.out.println(\"Read \"+input.length+\" bytes to hash; will do \"+REPS+\" repetitions\");\n+\n+        final ObjectReader cachingReader = mapper.reader(inputClass);\n+        final ObjectReader nonCachingReader = mapper.reader()\n+                .without(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n+                .withType(inputClass);\n+        \n+        int i = 0;\n+        int roundsDone = 0;\n+        final int TYPES = 2;\n+        final int WARMUP_ROUNDS = 5;\n+\n+        final long[] times = new long[TYPES];\n+        \n+        while (true) {\n+            try {  Thread.sleep(100L); } catch (InterruptedException ie) { }\n+            int round = (i++ % TYPES);\n+\n+            String msg;\n+            boolean lf = (round == 0);\n+\n+            long msecs;\n+            \n+            switch (round) {\n+            case 0:\n+                msg = \"Pre-fetch\";\n+                msecs = testDeser(REPS, input, cachingReader);\n+                break;\n+            case 1:\n+                msg = \"NO pre-fetch\";\n+                msecs = testDeser(REPS, input, nonCachingReader);\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            // skip first 5 rounds to let results stabilize\n+            if (roundsDone >= WARMUP_ROUNDS) {\n+                times[round] += msecs;\n+            }\n+            \n+            System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n+            if (lf) {\n+                ++roundsDone;\n+                if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                    double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                    System.out.printf(\"Averages after %d rounds (pre / no): %.1f / %.1f msecs\\n\",\n+                            (int) den,\n+                            times[0] / den, times[1] / den);\n+                            \n+                }\n+                System.out.println();\n+            }\n+            if ((i % 17) == 0) {\n+                System.out.println(\"[GC]\");\n+                Thread.sleep(100L);\n+                System.gc();\n+                Thread.sleep(100L);\n+            }\n+        }\n+    }\n+\n+    private final long testDeser(int REPS, byte[] input, ObjectReader reader) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        Object result = null;\n+        while (--REPS >= 0) {\n+            result = reader.readValue(input);\n+        }\n+        hash = result.hashCode();\n+        return System.currentTimeMillis() - start;\n+    }\n+\n+    public static void main(String[] args) throws Exception\n+    {\n+        if (args.length != 0) {\n+            System.err.println(\"Usage: java ...\");\n+            System.exit(1);\n+        }\n+        Record input = new Record(44, \"BillyBob\", \"Bumbler\", 'm', true);\n+        ObjectMapper m = new ObjectMapper();\n+        new ManualObjectReaderPerf().test(m, input, Record.class);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/ManualObjectWriterPerf.java\n+package perf;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class ManualObjectWriterPerf\n+{\n+    protected int hash;\n+    \n+    private <T> void test(ObjectMapper mapper, T inputValue, Class<T> inputClass)\n+        throws Exception\n+    {\n+        final int REPS;\n+        {\n+            final byte[] input = mapper.writeValueAsBytes(inputValue);\n+            \n+            // Let's try to guestimate suitable size, N megs of output\n+            REPS = (int) ((double) (9 * 1000 * 1000) / (double) input.length);\n+            System.out.println(\"Read \"+input.length+\" bytes to hash; will do \"+REPS+\" repetitions\");\n+        }\n+\n+        final ObjectWriter prefetching = mapper.writerWithType(inputClass);\n+        final ObjectWriter nonPrefetching = mapper.writer()\n+                .without(SerializationFeature.EAGER_SERIALIZER_FETCH)\n+                .withType(inputClass);\n+        \n+        int i = 0;\n+        int roundsDone = 0;\n+        final int TYPES = 2;\n+        final int WARMUP_ROUNDS = 5;\n+\n+        final long[] times = new long[TYPES];\n+\n+        while (true) {\n+            final NopOutputStream out = new NopOutputStream();\n+            try {  Thread.sleep(100L); } catch (InterruptedException ie) { }\n+            int round = (i++ % TYPES);\n+\n+            String msg;\n+            boolean lf = (round == 0);\n+\n+            long msecs;\n+            ObjectWriter writer;\n+            \n+            switch (round) {\n+            case 0:\n+                msg = \"Pre-fetch\";\n+                writer = prefetching;\n+                break;\n+            case 1:\n+                msg = \"NO pre-fetch\";\n+                writer = nonPrefetching;\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            msecs = testSer(REPS, inputValue, writer, out);\n+\n+            // skip first 5 rounds to let results stabilize\n+            if (roundsDone >= WARMUP_ROUNDS) {\n+                times[round] += msecs;\n+            }\n+            \n+            System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n+            if (lf) {\n+                ++roundsDone;\n+                if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                    double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                    System.out.printf(\"Averages after %d rounds (pre / no): %.1f / %.1f msecs\\n\",\n+                            (int) den,\n+                            times[0] / den, times[1] / den);\n+                            \n+                }\n+                System.out.println();\n+            }\n+            if ((i % 17) == 0) {\n+                System.out.println(\"[GC]\");\n+                Thread.sleep(100L);\n+                System.gc();\n+                Thread.sleep(100L);\n+            }\n+        }\n+    }\n+\n+    private final long testSer(int REPS, Object value, ObjectWriter writer, NopOutputStream out) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        while (--REPS >= 0) {\n+            writer.writeValue(out, value);\n+        }\n+        hash = out.size();\n+        return System.currentTimeMillis() - start;\n+    }\n+\n+    public static void main(String[] args) throws Exception\n+    {\n+        if (args.length != 0) {\n+            System.err.println(\"Usage: java ...\");\n+            System.exit(1);\n+        }\n+        Record input = new Record(44, \"BillyBob\", \"Bumbler\", 'm', true);\n+        ObjectMapper m = new ObjectMapper();\n+        new ManualObjectWriterPerf().test(m, input, Record.class);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/NopOutputStream.java\n+package perf;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+public class NopOutputStream extends OutputStream\n+{\n+    protected int size = 0;\n+    \n+    public NopOutputStream() { }\n+\n+    @Override\n+    public void write(int b) throws IOException { ++size; }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException { size += b.length; }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int len) throws IOException { size += len; }\n+\n+    public int size() { return size; }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/Record.java\n+package perf;\n+\n+/**\n+ * Simple test class \n+ */\n+final class Record\n+{\n+    public int age;\n+    public String firstName, lastName;\n+    public char gender;\n+    public boolean insured;\n+\n+    public Record() { }\n+    public Record(int a, String fn, String ln, char g, boolean ins)\n+    {\n+        age = a;\n+        firstName = fn;\n+        lastName = ln;\n+        gender = g;\n+        insured = ins;\n+    }\n+}", "timestamp": 1341015227, "metainfo": ""}