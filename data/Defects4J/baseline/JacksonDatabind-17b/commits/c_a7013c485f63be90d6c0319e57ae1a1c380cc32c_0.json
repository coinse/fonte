{"sha": "a7013c485f63be90d6c0319e57ae1a1c380cc32c", "log": "Work on full fix for [JACKSON-756], one more case to handle", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             // 'null' -> maps have no referring fields\n             contentDeser = p.findValueDeserializer(config, contentType, property);\n         }\n-        /* Value handling is identical for all,\n-         * but EnumMap requires special handling for keys\n-         */\n+        // Value handling is identical for all, but EnumMap requires special handling for keys\n         Class<?> mapClass = type.getRawClass();\n         if (EnumMap.class.isAssignableFrom(mapClass)) {\n             Class<?> kt = keyType.getRawClass();\n             if (kt == null || !kt.isEnum()) {\n                 throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n             }\n-            return new EnumMapDeserializer(constructEnumResolver(kt, config, _findJsonValueFor(config, keyType)),\n+            return new EnumMapDeserializer(keyType.getRawClass(),\n+                    createEnumDeserializer(config, p, keyType, property),\n                     contentDeser);\n         }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.JacksonDeserializers;\n+import com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n      */\n     private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n \n+    /**\n+     * Set of available key deserializers is currently limited\n+     * to standard types; and all known instances are storing\n+     * in this map.\n+     */\n+    final static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n+    \n     /*\n     /**********************************************************\n     /* Config class implementation\n                 }\n             }\n         }\n-        return null;\n+        // and if none found, standard ones:\n+        // No serializer needed if it's plain old String, or Object/untyped\n+        Class<?> raw = type.getRawClass();\n+        if (raw == String.class || raw == Object.class) {\n+            return StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n+        }\n+        // Most other keys are of limited number of static types\n+        KeyDeserializer kdes = _keyDeserializers.get(type);\n+        if (kdes != null) {\n+            return kdes;\n+        }\n+        // And then other one-offs; first, Enum:\n+        if (type.isEnumType()) {\n+            return StdKeyDeserializers.constructEnumKeyDeserializer(config, type);\n+        }\n+        // One more thing: can we find ctor(String) or valueOf(String)?\n+        kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+        return kdes;\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializerProvider.java\n      */\n \n     /**\n-     * Set of available key deserializers is currently limited\n-     * to standard types; and all known instances are storing\n-     * in this map.\n-     */\n-    final static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n-\n-    /**\n      * We will also cache some dynamically constructed deserializers;\n      * specifically, ones that are expensive to construct.\n      * This currently means bean and Enum deserializers; array, List and Map\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // 1.8: check if there are custom key deserializers...\n         KeyDeserializer kd = _factory.createKeyDeserializer(config, type, property);\n-        if (kd == null) {\n-            // No serializer needed if it's plain old String, or Object/untyped\n-            Class<?> raw = type.getRawClass();\n-            if (raw == String.class || raw == Object.class) {\n-                return null;\n-            }\n-            // Most other keys are of limited number of static types\n-            KeyDeserializer kdes = _keyDeserializers.get(type);\n-            if (kdes != null) {\n-                return kdes;\n-            }\n-            // And then other one-offs; first, Enum:\n-            if (type.isEnumType()) {\n-                return StdKeyDeserializers.constructEnumKeyDeserializer(config, type);\n-            }\n-            // One more thing: can we find ctor(String) or valueOf(String)?\n-            kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n-            if (kdes != null) {\n-                return kdes;\n-            }\n-            if (kd == null) {\n-                // otherwise, will probably fail:\n-                return _handleUnknownKeyDeserializer(type);\n-            }\n-        }\n-        // One more thing: contextuality:\n+        // One more thing: contextuality\n         if (kd instanceof ContextualKeyDeserializer) {\n             kd = ((ContextualKeyDeserializer) kd).createContextual(config, property);\n+        }\n+        if (kd == null) { // if none found, need to use a placeholder that'll fail\n+            return _handleUnknownKeyDeserializer(type);\n         }\n         return kd;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.util.EnumResolver;\n \n /**\n  * Deserializer for {@link EnumMap} values.\n public class EnumMapDeserializer\n     extends StdDeserializer<EnumMap<?,?>>\n {\n-    protected final EnumResolver<?> _enumResolver;\n+    protected final Class<?> _enumClass;\n+\n+    protected final JsonDeserializer<Enum<?>> _keyDeserializer;\n \n     protected final JsonDeserializer<Object> _valueDeserializer;\n \n-    public EnumMapDeserializer(EnumResolver<?> enumRes, JsonDeserializer<Object> valueDes)\n+    public EnumMapDeserializer(Class<?> enumClass, JsonDeserializer<?> keyDeserializer,\n+            JsonDeserializer<Object> valueDeser)\n     {\n         super(EnumMap.class);\n-        _enumResolver = enumRes;\n-        _valueDeserializer = valueDes;\n+        _enumClass = enumClass;\n+        _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n+        _valueDeserializer = valueDeser;\n     }\n \n     /**\n         EnumMap result = constructMap();\n \n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n-            String fieldName = jp.getCurrentName();\n-            Enum<?> key = _enumResolver.findEnum(fieldName);\n+            Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             if (key == null) {\n-                throw ctxt.weirdStringException(_enumResolver.getEnumClass(), \"value not one of declared Enum instance names\");\n+                throw ctxt.weirdStringException(_enumClass, \"value not one of declared Enum instance names\");\n             }\n             // And then the value...\n             JsonToken t = jp.nextToken();\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n     \n-    private EnumMap<?,?> constructMap()\n-    {\n-        Class<? extends Enum<?>> enumCls = _enumResolver.getEnumClass();\n-    \treturn new EnumMap(enumCls);\n+    private EnumMap<?,?> constructMap() {\n+        return new EnumMap(_enumClass);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n             String fieldName = jp.getCurrentName();\n-            Object key = (keyDes == null) ? fieldName : keyDes.deserializeKey(fieldName, ctxt);\n+            Object key = keyDes.deserializeKey(fieldName, ctxt);\n             // And then the value...\n             t = jp.nextToken();\n             if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n             }\n             // other property? needs buffering\n             String fieldName = jp.getCurrentName();\n-            Object key = (_keyDeserializer == null) ? fieldName : _keyDeserializer.deserializeKey(fieldName, ctxt);\n+            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n             Object value;            \n             if (t == JsonToken.VALUE_NULL) {\n                 value = null;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n \n     /*\n     /**********************************************************\n+    /* First: the standard \"String as String\" deserializer\n+    /**********************************************************\n+     */\n+\n+    final static class StringKD extends StdKeyDeserializer\n+    {\n+        private final static StringKD sString = new StringKD(String.class);\n+        private final static StringKD sObject = new StringKD(Object.class);\n+        \n+        private StringKD(Class<?> nominalType) { super(nominalType); }\n+\n+        public static StringKD forType(Class<?> nominalType)\n+        {\n+            if (nominalType == String.class) {\n+                return sString;\n+            }\n+            if (nominalType == Object.class) {\n+                return sObject;\n+            }\n+            return new StringKD(nominalType);\n+        }\n+        \n+        @Override\n+        public String _parse(String key, DeserializationContext ctxt) throws JsonMappingException {\n+            return key;\n+        }\n+    }    \n+    \n+    /*\n+    /**********************************************************\n     /* Key deserializer implementations; wrappers\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n-\n \n /**\n  * Helper class used to contain simple/well-known key deserializers.\n     /**********************************************************\n      */\n \n+    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config, JavaType type)\n+    {\n+        return StdKeyDeserializer.StringKD.forType(type.getClass());\n+    }\n+    \n     public static KeyDeserializer constructEnumKeyDeserializer(DeserializationConfig config, JavaType type)\n     {\n         EnumResolver<?> er = EnumResolver.constructUnsafe(type.getRawClass(), config.getAnnotationIntrospector());", "timestamp": 1326846773, "metainfo": ""}