{"sha": "21a81e1f0569f81d7f371ec05c4ea1f263996e7f", "log": "Implement #215", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n      * null passed, using timestamp (64-bit number.\n      */\n     public ObjectWriter writer(DateFormat df) {\n-        return new ObjectWriter(this,\n-                getSerializationConfig().with(df));\n+        return new ObjectWriter(this, getSerializationConfig().with(df));\n     }\n     \n     /**\n     public ObjectWriter writer(Base64Variant defaultBase64) {\n         return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n     }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified character escaping details for output.\n+     * \n+     * @since 2.3\n+     */\n+    public ObjectWriter writer(CharacterEscapes escapes) {\n+        return writer().with(escapes);\n+    }\n+\n     \n     /*\n     /**********************************************************\n     public ObjectReader reader(Base64Variant defaultBase64) {\n         return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n      */\n     protected final FormatSchema _schema;\n     \n+    /**\n+     * Caller may want to specify character escaping details, either as\n+     * defaults, or on call-by-call basis.\n+     * \n+     * @since 2.3\n+     */\n+    protected final CharacterEscapes _characterEscapes;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n         _rootType = rootType;\n         _prettyPrinter = pp;\n         _schema = null;\n+        _characterEscapes = null;\n \n         _rootSerializer = _prefetchRootSerializer(config, rootType);\n     }\n         _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = null;\n+        _characterEscapes = null;\n     }\n \n     /**\n         _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = s;\n+        _characterEscapes = null;\n     }\n     \n     /**\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n             JavaType rootType, JsonSerializer<Object> rootSer,\n-            PrettyPrinter pp, FormatSchema s)\n+            PrettyPrinter pp, FormatSchema s, CharacterEscapes escapes)\n     {\n         _config = config;\n \n         _rootSerializer = rootSer;\n         _prettyPrinter = pp;\n         _schema = s;\n+        _characterEscapes = escapes;\n     }\n \n     /**\n         _serializerFactory = base._serializerFactory;\n         _jsonFactory = base._jsonFactory;\n         _schema = base._schema;\n+        _characterEscapes = base._characterEscapes;\n \n         _rootType = base._rootType;\n         _rootSerializer = base._rootSerializer;\n         if (pp == null) {\n             pp = NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema);\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+                pp, _schema, _characterEscapes);\n     }\n \n     /**\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer, _prettyPrinter, schema);\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+                _prettyPrinter, schema, _characterEscapes);\n     }\n \n     /**\n         // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n         rootType = rootType.withStaticTyping();\n         JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType);\n-        return new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema);\n+        return new ObjectWriter(this, _config, rootType, rootSer,\n+                _prettyPrinter, _schema, _characterEscapes);\n     }    \n \n     /**\n     public ObjectWriter with(Base64Variant b64variant) {\n         SerializationConfig newConfig = _config.with(b64variant);\n         return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter with(CharacterEscapes escapes) {\n+        if (_characterEscapes == escapes) {\n+            return this;\n+        }\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n+                _prettyPrinter, _schema, escapes);\n     }\n     \n     /*\n         } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n+        if (_characterEscapes != null) {\n+            jgen.setCharacterEscapes(_characterEscapes);\n+        }\n         // [JACKSON-520]: add support for pass-through schema:\n         if (_schema != null) {\n             jgen.setSchema(_schema);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import org.w3c.dom.Element;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n         protected int y() { return 7; }\n     }\n \n+    /**\n+     * Trivial simple custom escape definition set.\n+     */\n+    @SuppressWarnings(\"serial\")\n+    static class CustomEscapes extends CharacterEscapes\n+    {\n+        private final int[] _asciiEscapes;\n+\n+        public CustomEscapes() {\n+            _asciiEscapes = standardAsciiEscapesForJSON();\n+            _asciiEscapes['a'] = 'A'; // to basically give us \"\\A\" instead of 'a'\n+            _asciiEscapes['b'] = CharacterEscapes.ESCAPE_STANDARD; // too force \"\\u0062\"\n+        }\n+        \n+        @Override\n+        public int[] getEscapeCodesForAscii() {\n+            return _asciiEscapes;\n+        }\n+\n+        @Override\n+        public SerializableString getEscapeSequence(int ch) {\n+            return null;\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n         mapper.registerModule(module);\n         assertEquals(\"{\\\"x\\\":3,\\\"y\\\":7}\", mapper.writeValueAsString(new Immutable()));\n     }\n+\n+    // [Issue#215]: Allow registering CharacterEscapes via ObjectWriter\n+    public void testCustomEscapes() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n+                mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n+    }\n }", "timestamp": 1370565067, "metainfo": ""}