{"sha": "9e080e298d8c0cfd7d77a56eb93d85a5da322555", "log": "Fix #506 for 2.4.2", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n     /**********************************************************\n      */\n \n-    public JsonMappingException(String msg)\n-    {\n-        super(msg);\n-    }\n-\n-    public JsonMappingException(String msg, Throwable rootCause)\n-    {\n-        super(msg, rootCause);\n-    }\n-\n-    public JsonMappingException(String msg, JsonLocation loc)\n-    {\n-        super(msg, loc);\n-    }\n-\n-    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause)\n-    {\n-        super(msg, loc, rootCause);\n-    }\n-\n-    public static JsonMappingException from(JsonParser jp, String msg)\n-    {\n+    public JsonMappingException(String msg) { super(msg); }\n+    public JsonMappingException(String msg, Throwable rootCause) { super(msg, rootCause); }\n+    public JsonMappingException(String msg, JsonLocation loc) { super(msg, loc); }\n+    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause) { super(msg, loc, rootCause); }\n+\n+    public static JsonMappingException from(JsonParser jp, String msg) {\n         return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()));\n     }\n \n-    public static JsonMappingException from(JsonParser jp, String msg,\n-            Throwable problem)\n-    {\n+    public static JsonMappingException from(JsonParser jp, String msg, Throwable problem) {\n         return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()), problem);\n     }\n     \n      * \n      * @since 2.1\n      */\n-    public static JsonMappingException fromUnexpectedIOE(IOException src)\n-    {\n+    public static JsonMappingException fromUnexpectedIOE(IOException src) {\n         return new JsonMappingException(\"Unexpected IOException (of type \"\n                 +src.getClass().getName()+\"): \"+src.getMessage(), (JsonLocation)null, src);\n     }\n      * non-indexed object, such as a Map or POJO/bean.\n      */\n     public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,\n-                                                    String refFieldName)\n-    {\n+            String refFieldName) {\n         return wrapWithPath(src, new Reference(refFrom, refFieldName));\n     }\n \n      * This version of method is called when the reference is through an\n      * index, which happens with arrays and Collections.\n      */\n-    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,\n-                                                    int index)\n-    {\n+    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index) {\n         return wrapWithPath(src, new Reference(refFrom, index));\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      *   {@link JsonMappingException} are to be passed as is\n      *</ul>\n      */\n-    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n-            DeserializationContext ctxt)\n+    public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)\n         throws IOException\n     {\n         // [JACKSON-55] Need to add reference information\n         throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);\n     }\n \n-    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n-        throws IOException\n-    {\n+    @Deprecated // since 2.4, not used by core Jackson; only relevant for arrays/Collections\n+    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException {\n         // [JACKSON-55] Need to add reference information\n         throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, index);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n+            } catch (Exception e) {\n+                // note: pass Object.class, not Object[].class, as we need element type for error info\n+                throw JsonMappingException.wrapWithPath(e, Object.class, result.size());\n             }\n         }\n         return result;\n         JsonToken t = jp.getCurrentToken();\n \n         Object value;\n-        \n-        if (t == JsonToken.VALUE_NULL) {\n-            value = valueDes.getNullValue();\n-        } else if (typeDeser == null) {\n-            value = valueDes.deserialize(jp, ctxt);\n-        } else {\n-            value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+\n+        try {\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = valueDes.getNullValue();\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+        } catch (Exception e) {\n+            // note: pass Object.class, not Object[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, Object.class, result.size());\n         }\n         result.add(value);\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n         EnumSet result = constructSet();\n         JsonToken t;\n \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            /* What to do with nulls? Fail or ignore? Fail, for now\n-             * (note: would fail if we passed it to EnumDeserializer, too,\n-             * but in general nulls should never be passed to non-container\n-             * deserializers)\n-             */\n-            if (t == JsonToken.VALUE_NULL) {\n-                throw ctxt.mappingException(_enumClass);\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                /* What to do with nulls? Fail or ignore? Fail, for now\n+                 * (note: would fail if we passed it to EnumDeserializer, too,\n+                 * but in general nulls should never be passed to non-container\n+                 * deserializers)\n+                 */\n+                if (t == JsonToken.VALUE_NULL) {\n+                    throw ctxt.mappingException(_enumClass);\n+                }\n+                Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);\n+                /* 24-Mar-2012, tatu: As per [JACKSON-810], may actually get nulls;\n+                 *    but EnumSets don't allow nulls so need to skip.\n+                 */\n+                if (value != null) { \n+                    result.add(value);\n+                }\n             }\n-            Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);\n-            /* 24-Mar-2012, tatu: As per [JACKSON-810], may actually get nulls;\n-             *    but EnumSets don't allow nulls so need to skip.\n-             */\n-            if (value != null) { \n-                result.add(value);\n-            }\n+        } catch (Exception e) {\n+            // note: pass Object.class, not Object[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, Enum.class, result.size());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n import java.lang.reflect.Array;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n         JsonToken t;\n         final TypeDeserializer typeDeser = _elementTypeDeserializer;\n \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            // Note: must handle null explicitly here; value deserializers won't\n-            Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = _elementDeserializer.getNullValue();\n-            } else if (typeDeser == null) {\n-                value = _elementDeserializer.deserialize(jp, ctxt);\n-            } else {\n-                value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                // Note: must handle null explicitly here; value deserializers won't\n+                Object value;\n+                \n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = _elementDeserializer.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value = _elementDeserializer.deserialize(jp, ctxt);\n+                } else {\n+                    value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                if (ix >= chunk.length) {\n+                    chunk = buffer.appendCompletedChunk(chunk);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n             }\n-            if (ix >= chunk.length) {\n-                chunk = buffer.appendCompletedChunk(chunk);\n-                ix = 0;\n-            }\n-            chunk[ix++] = value;\n+        } catch (Exception e) {\n+            // note: pass Object.class, not Object[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, Object.class, ix);\n         }\n \n         Object[] result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n \n         final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n         Object[] chunk = buffer.resetAndStart();\n-        \n+\n         int ix = 0;\n         JsonToken t;\n-        \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            // Ok: no need to convert Strings, but must recognize nulls\n-            String value;\n-            if (t == JsonToken.VALUE_STRING) {\n-                value = jp.getText();\n-            } else if (t == JsonToken.VALUE_NULL) {\n-                value = null; // since we have established that '_elementDeserializer == null' earlier\n-            } else {\n-                value = _parseString(jp, ctxt);\n+\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                // Ok: no need to convert Strings, but must recognize nulls\n+                String value;\n+                if (t == JsonToken.VALUE_STRING) {\n+                    value = jp.getText();\n+                } else if (t == JsonToken.VALUE_NULL) {\n+                    value = null; // since we have established that '_elementDeserializer == null' earlier\n+                } else {\n+                    value = _parseString(jp, ctxt);\n+                }\n+                if (ix >= chunk.length) {\n+                    chunk = buffer.appendCompletedChunk(chunk);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n             }\n-            if (ix >= chunk.length) {\n-                chunk = buffer.appendCompletedChunk(chunk);\n-                ix = 0;\n-            }\n-            chunk[ix++] = value;\n+        } catch (Exception e) {\n+            // note: pass String.class, not String[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n         }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n         \n         int ix = 0;\n         JsonToken t;\n-        \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            // Ok: no need to convert Strings, but must recognize nulls\n-            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n-            if (ix >= chunk.length) {\n-                chunk = buffer.appendCompletedChunk(chunk);\n-                ix = 0;\n+\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                // Ok: no need to convert Strings, but must recognize nulls\n+                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = buffer.appendCompletedChunk(chunk);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n             }\n-            chunk[ix++] = value;\n+        } catch (Exception e) {\n+            // note: pass String.class, not String[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n         }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         }\n         JsonToken t;\n \n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            String value;\n-            if (t == JsonToken.VALUE_STRING) {\n-                value = jp.getText();\n-            } else if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else {\n-                value = _parseString(jp, ctxt);\n-            }\n-            result.add(value);\n+        try {\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                String value;\n+                if (t == JsonToken.VALUE_STRING) {\n+                    value = jp.getText();\n+                } else if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else {\n+                    value = _parseString(jp, ctxt);\n+                }\n+                result.add(value);\n+            }\n+        } catch (Exception e) {\n+            // note: pass String.class, not String[].class, as we need element type for error info\n+            throw JsonMappingException.wrapWithPath(e, String.class, result.size());\n         }\n         return result;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n \n     static class ListAsIterableX {\n         public Iterable<XBean> nums;\n+    }\n+\n+    static class KeyListBean {\n+        public List<Key> keys;\n     }\n     \n     /*\n         assertEquals(2, xb.x);\n         assertFalse(it.hasNext());\n     }\n+\n+    // for [Issue#506]\n+    public void testArrayIndexForExceptions() throws Exception\n+    {\n+        final String OBJECTS_JSON = \"[ \\\"KEY2\\\", false ]\";\n+        try {\n+            MAPPER.readValue(OBJECTS_JSON, Key[].class);\n+            fail(\"Should not pass\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not deserialize\");\n+            List<JsonMappingException.Reference> refs = e.getPath();\n+            assertEquals(1, refs.size());\n+            assertEquals(1, refs.get(0).getIndex());\n+        }\n+\n+        try {\n+            MAPPER.readValue(\"[ \\\"xyz\\\", { } ]\", String[].class);\n+            fail(\"Should not pass\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not deserialize\");\n+            List<JsonMappingException.Reference> refs = e.getPath();\n+            assertEquals(1, refs.size());\n+            assertEquals(1, refs.get(0).getIndex());\n+        }\n+\n+        try {\n+            MAPPER.readValue(\"{\\\"keys\\\":\"+OBJECTS_JSON+\"}\", KeyListBean.class);\n+            fail(\"Should not pass\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not deserialize\");\n+            List<JsonMappingException.Reference> refs = e.getPath();\n+            assertEquals(2, refs.size());\n+            // Bean has no index, but has name:\n+            assertEquals(-1, refs.get(0).getIndex());\n+            assertEquals(\"keys\", refs.get(0).getFieldName());\n+\n+            // and for List, reverse:\n+            assertEquals(1, refs.get(1).getIndex());\n+            assertNull(refs.get(1).getFieldName());\n+        }\n+    }\n }", "timestamp": 1406266405, "metainfo": ""}