{"sha": "9312ad890b557806d84bde705f351e255e9fe050", "log": "Add little bif of caching for TypeFactory, to reduce cost of JavaType creation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n \n \n /**\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public final class TypeFactory\n {\n+    private final static JavaType[] NO_TYPES = new JavaType[0];\n+\n     /**\n      * Globally shared singleton. Not accessed directly; non-core\n      * code should use per-ObjectMapper instance (via configuration objects).\n      * Core Jackson code uses {@link #defaultInstance} for accessing it.\n      */\n     protected final static TypeFactory instance = new TypeFactory();\n-\n-    private final static JavaType[] NO_TYPES = new JavaType[0];\n-\n-    /**\n-     * Registered {@link TypeModifier}s: objects that can change details\n-     * of {@link JavaType} instances factory constructs.\n-     */\n-    protected final TypeModifier[] _modifiers;\n-    \n-    protected final TypeParser _parser;\n-\n+    \n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    // // // Let's assume that a small set of core primitive/basic types\n+    // // // will not be modified, and can be freely shared to streamline\n+    // // // parts of processing\n+    \n+    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n+    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n+    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n+    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n+    \n+    /**\n+     * Since type resolution can be expensive (specifically when resolving\n+     * actual generic types), we will use small cache to avoid repetitive\n+     * resolution of core types\n+     */\n+    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n+    \n     /*\n      * Looks like construction of {@link JavaType} instances can be\n      * a bottleneck, esp. for root-level Maps, so we better do bit\n      * of low-level component caching here...\n      */\n-\n+    \n     /**\n      * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n      * to its supertypes.\n      */\n     protected HierarchicType _cachedArrayListType;\n     \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Registered {@link TypeModifier}s: objects that can change details\n+     * of {@link JavaType} instances factory constructs.\n+     */\n+    protected final TypeModifier[] _modifiers;\n+    \n+    protected final TypeParser _parser;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         // simple class?\n         if (type instanceof Class<?>) {\n             Class<?> cls = (Class<?>) type;\n-            /* 24-Mar-2010, tatu: Better create context if one was not passed;\n-             *   mostly matters for root serialization types\n-             */\n-            if (context == null) {\n-                context = new TypeBindings(this, cls);\n-            }\n             resultType = _fromClass(cls, context);\n         }\n         // But if not, need to start resolving.\n     /* Actual factory methods\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @param context Mapping of formal parameter declarations (for generic\n      *   types) into actual types\n      */\n     protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n     {\n+        // Very first thing: small set of core types we know well:\n+        if (clz == String.class) return CORE_TYPE_STRING;\n+        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n+        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n+        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n+        \n+        // Barring that, we may have recently constructed an instance:\n+        ClassKey key = new ClassKey(clz);\n+        JavaType result;\n+        \n+        synchronized (_typeCache) {\n+            result = _typeCache.get(key);\n+        }\n+        if (result != null) {\n+            return result;\n+        }\n+\n+        // If context was needed, weed do:\n+        /*\n+        if (context == null) {\n+            context = new TypeBindings(this, cls);\n+        }\n+        */\n+        \n         // First: do we have an array type?\n         if (clz.isArray()) {\n-            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n-        }\n+            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n         /* Also: although enums can also be fully resolved, there's little\n          * point in doing so (T extends Enum<T>) etc.\n          */\n-        if (clz.isEnum()) {\n-            return new SimpleType(clz);\n-        }\n+        } else if (clz.isEnum()) {\n+            result = new SimpleType(clz);\n         /* Maps and Collections aren't quite as hot; problem is, due\n          * to type erasure we often do not know typing and can only assume\n          * base Object.\n          */\n-        if (Map.class.isAssignableFrom(clz)) {\n-            return _mapType(clz);\n-        }\n-        if (Collection.class.isAssignableFrom(clz)) {\n-            return _collectionType(clz);\n-        }\n-        return new SimpleType(clz);\n+        } else if (Map.class.isAssignableFrom(clz)) {\n+            result = _mapType(clz);\n+        } else if (Collection.class.isAssignableFrom(clz)) {\n+            result =  _collectionType(clz);\n+        } else {\n+            result = new SimpleType(clz);\n+        }\n+        \n+        synchronized (_typeCache) {\n+            _typeCache.put(key, result);\n+        }\n+        \n+        return result;\n     }\n     \n     /**\n     /**\n      * This method deals with parameterized types, that is,\n      * first class generic classes.\n-     *<p>\n-     * Since version 1.2, this resolves all parameterized types, not just\n-     * Maps or Collections.\n      */\n     protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n         return (Map<String,Object>) m.readValue(str, Map.class);\n     }\n \n-    protected Map<String,Object> writeAndMap(Object value)\n-        throws IOException\n-    {\n-        return writeAndMap(new ObjectMapper(), value);\n-    }\n-\n     protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n         throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n     }\n \n     /*\n-    /////////////////////////////////////////////////\n-    // Deserialization from simple types (String, int)\n-    /////////////////////////////////////////////////\n-     */\n-\n+    /**********************************************************\n+    /* Deserialization from simple types (String, int)\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testFromStringCtor() throws Exception\n     {\n-        CtorValueBean result = new ObjectMapper().readValue(\"\\\"abc\\\"\", CtorValueBean.class);\n+        CtorValueBean result = MAPPER.readValue(\"\\\"abc\\\"\", CtorValueBean.class);\n         assertEquals(\"abc\", result.toString());\n     }\n \n     public void testFromIntCtor() throws Exception\n     {\n-        CtorValueBean result = new ObjectMapper().readValue(\"13\", CtorValueBean.class);\n+        CtorValueBean result = MAPPER.readValue(\"13\", CtorValueBean.class);\n         assertEquals(\"13\", result.toString());\n     }\n \n     {\n         // Must use something that is forced as Long...\n         long value = 12345678901244L;\n-        CtorValueBean result = new ObjectMapper().readValue(\"\"+value, CtorValueBean.class);\n+        CtorValueBean result = MAPPER.readValue(\"\"+value, CtorValueBean.class);\n         assertEquals(\"\"+value, result.toString());\n     }\n \n     public void testFromStringFactory() throws Exception\n     {\n-        FactoryValueBean result = new ObjectMapper().readValue(\"\\\"abc\\\"\", FactoryValueBean.class);\n+        FactoryValueBean result = MAPPER.readValue(\"\\\"abc\\\"\", FactoryValueBean.class);\n         assertEquals(\"abc\", result.toString());\n     }\n \n     public void testFromIntFactory() throws Exception\n     {\n-        FactoryValueBean result = new ObjectMapper().readValue(\"13\", FactoryValueBean.class);\n+        FactoryValueBean result = MAPPER.readValue(\"13\", FactoryValueBean.class);\n         assertEquals(\"13\", result.toString());\n     }\n \n     {\n         // Must use something that is forced as Long...\n         long value = 12345678901244L;\n-        FactoryValueBean result = new ObjectMapper().readValue(\"\"+value, FactoryValueBean.class);\n+        FactoryValueBean result = MAPPER.readValue(\"\"+value, FactoryValueBean.class);\n         assertEquals(\"\"+value, result.toString());\n     }\n \n     /*\n-    /////////////////////////////////////////////////\n-    // Deserialization from Json Object\n-    /////////////////////////////////////////////////\n+    /**********************************************************\n+    /* Deserialization from JSON Object\n+    /**********************************************************\n      */\n \n     public void testSimpleBean() throws Exception\n         TestBean bean = new TestBean(13, -900L, \"\\\"test\\\"\", new URL(\"http://foobar.com\"), misc);\n \n         // Hmmh. We probably should use serializer too... easier\n-        StringWriter sw = new StringWriter();\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.writeValue(sw, bean);\n-\n-        TestBean result = new ObjectMapper().readValue(sw.toString(), TestBean.class);\n+        String json = MAPPER.writeValueAsString(bean);\n+\n+        TestBean result = MAPPER.readValue(json, TestBean.class);\n         assertEquals(bean, result);\n     }\n \n         BeanWithList bean = new BeanWithList(beans);\n \n         StringWriter sw = new StringWriter();\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.writeValue(sw, bean);\n-\n-        BeanWithList result = new ObjectMapper().readValue(sw.toString(), BeanWithList.class);\n+        MAPPER.writeValue(sw, bean);\n+\n+        BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class);\n         assertEquals(bean, result);\n     }\n \n      */\n     public void testUnknownFields() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         try {\n-            TestBean bean = mapper.readValue(\"{ \\\"foobar\\\" : 3 }\", TestBean.class);\n+            TestBean bean = MAPPER.readValue(\"{ \\\"foobar\\\" : 3 }\", TestBean.class);\n             fail(\"Expected an exception, got bean: \"+bean);\n         } catch (JsonMappingException jse) {\n             ;\n--- a/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n     /* Test cases\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testDynaBean() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         DynaBean b = new DynaBean();\n         b.id = 123;\n         b.set(\"name\", \"Billy\");\n-        assertEquals(\"{\\\"id\\\":123,\\\"name\\\":\\\"Billy\\\"}\", m.writeValueAsString(b));\n+        assertEquals(\"{\\\"id\\\":123,\\\"name\\\":\\\"Billy\\\"}\", MAPPER.writeValueAsString(b));\n \n-        DynaBean result = m.readValue(\"{\\\"id\\\":2,\\\"name\\\":\\\"Joe\\\"}\", DynaBean.class);\n+        DynaBean result = MAPPER.readValue(\"{\\\"id\\\":2,\\\"name\\\":\\\"Joe\\\"}\", DynaBean.class);\n         assertEquals(2, result.id);\n         assertEquals(\"Joe\", result.other.get(\"name\"));\n     }\n \n     public void testPrivate() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new PrivateThing());\n+        String json = MAPPER.writeValueAsString(new PrivateThing());\n         assertEquals(\"{\\\"a\\\":\\\"A\\\"}\", json);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n     /* Test methods\n     /**********************************************************\n      */\n+ \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     /**\n      * Related to issue [JACKSON-155].\n      */\n     public void testFile() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         // Not portable etc... has to do:\n         File src = new File(\"/test\").getAbsoluteFile();\n-        File result = m.readValue(\"\\\"\"+src.getAbsolutePath()+\"\\\"\", File.class);\n+        File result = MAPPER.readValue(\"\\\"\"+src.getAbsolutePath()+\"\\\"\", File.class);\n         assertEquals(src.getAbsolutePath(), result.getAbsolutePath());\n     }\n \n         /* Ok: easiest way is to just serialize first; problem\n          * is the backslash\n          */\n-        ObjectMapper m = new ObjectMapper();\n-        String json = m.writeValueAsString(exp);\n-        Pattern result = m.readValue(json, Pattern.class);\n+        String json = MAPPER.writeValueAsString(exp);\n+        Pattern result = MAPPER.readValue(json, Pattern.class);\n         assertEquals(exp.pattern(), result.pattern());\n     }\n \n     public void testCurrency() throws IOException\n     {\n         Currency usd = Currency.getInstance(\"USD\");\n-        assertEquals(usd, new ObjectMapper().readValue(quote(\"USD\"), Currency.class));\n+        assertEquals(usd, MAPPER.readValue(quote(\"USD\"), Currency.class));\n     }\n \n     /**\n      * Test for [JACKSON-419]\n-     * \n-     * @since 1.7\n      */\n     public void testLocale() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(new Locale(\"en\"), mapper.readValue(quote(\"en\"), Locale.class));\n-        assertEquals(new Locale(\"es\", \"ES\"), mapper.readValue(quote(\"es_ES\"), Locale.class));\n-        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), mapper.readValue(quote(\"fi_FI_savo\"), Locale.class));\n+        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n+        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n+        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n     }\n \n     /**\n      * Test for [JACKSON-420] (add DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES)\n-     * \n-     * @since 1.7\n      */\n     public void testNullForPrimitives() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         // by default, ok to rely on defaults\n-        PrimitivesBean bean = mapper.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n+        PrimitivesBean bean = MAPPER.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals(0, bean.intValue);\n         assertEquals(false, bean.booleanValue);\n         assertEquals(0.0, bean.doubleValue);\n \n-        bean = mapper.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals((byte) 0, bean.byteValue);\n         assertEquals(0.0f, bean.floatValue);\n         \n         // but not when enabled\n-        mapper = new ObjectMapper();\n+        ObjectMapper  mapper = new ObjectMapper();\n         mapper.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n \n         // boolean\n      */\n     public void testCharSequence() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        CharSequence cs = mapper.readValue(\"\\\"abc\\\"\", CharSequence.class);\n+        CharSequence cs = MAPPER.readValue(\"\\\"abc\\\"\", CharSequence.class);\n         assertEquals(String.class, cs.getClass());\n         assertEquals(\"abc\", cs.toString());\n     }\n     // [JACKSON-484]\n     public void testInetAddress() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        InetAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n+        InetAddress address = MAPPER.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n         assertEquals(\"127.0.0.1\", address.getHostAddress());\n \n         // should we try resolving host names? That requires connectivity... \n         final String HOST = \"www.ning.com\";\n-        address = mapper.readValue(quote(HOST), InetAddress.class);\n+        address = MAPPER.readValue(quote(HOST), InetAddress.class);\n         assertEquals(HOST, address.getHostName());\n     }\n \n     // [JACKSON-597]\n     public void testClass() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertSame(String.class, mapper.readValue(quote(\"java.lang.String\"), Class.class));\n+        assertSame(String.class, MAPPER.readValue(quote(\"java.lang.String\"), Class.class));\n \n         // then primitive types\n-        assertSame(Boolean.TYPE, mapper.readValue(quote(\"boolean\"), Class.class));\n-        assertSame(Byte.TYPE, mapper.readValue(quote(\"byte\"), Class.class));\n-        assertSame(Short.TYPE, mapper.readValue(quote(\"short\"), Class.class));\n-        assertSame(Character.TYPE, mapper.readValue(quote(\"char\"), Class.class));\n-        assertSame(Integer.TYPE, mapper.readValue(quote(\"int\"), Class.class));\n-        assertSame(Long.TYPE, mapper.readValue(quote(\"long\"), Class.class));\n-        assertSame(Float.TYPE, mapper.readValue(quote(\"float\"), Class.class));\n-        assertSame(Double.TYPE, mapper.readValue(quote(\"double\"), Class.class));\n-        assertSame(Void.TYPE, mapper.readValue(quote(\"void\"), Class.class));\n+        assertSame(Boolean.TYPE, MAPPER.readValue(quote(\"boolean\"), Class.class));\n+        assertSame(Byte.TYPE, MAPPER.readValue(quote(\"byte\"), Class.class));\n+        assertSame(Short.TYPE, MAPPER.readValue(quote(\"short\"), Class.class));\n+        assertSame(Character.TYPE, MAPPER.readValue(quote(\"char\"), Class.class));\n+        assertSame(Integer.TYPE, MAPPER.readValue(quote(\"int\"), Class.class));\n+        assertSame(Long.TYPE, MAPPER.readValue(quote(\"long\"), Class.class));\n+        assertSame(Float.TYPE, MAPPER.readValue(quote(\"float\"), Class.class));\n+        assertSame(Double.TYPE, MAPPER.readValue(quote(\"double\"), Class.class));\n+        assertSame(Void.TYPE, MAPPER.readValue(quote(\"void\"), Class.class));\n     }\n \n     // [JACKSON-605]\n     public void testClassWithParams() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new ParamClassBean(\"Foobar\"));\n-\n-        ParamClassBean result = mapper.readValue(json, ParamClassBean.class);\n+        String json = MAPPER.writeValueAsString(new ParamClassBean(\"Foobar\"));\n+\n+        ParamClassBean result = MAPPER.readValue(json, ParamClassBean.class);\n         assertEquals(\"Foobar\", result.name);\n         assertSame(String.class, result.clazz);\n     }\n     // by default, should return nulls, n'est pas?\n     public void testEmptyStringForWrappers() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         WrappersBean bean;\n \n         // by default, ok to rely on defaults\n-        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.booleanValue);\n-        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.byteValue);\n \n         // char/Character is different... not sure if this should work or not:\n-        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.charValue);\n \n-        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.shortValue);\n-        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.intValue);\n-        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.longValue);\n-        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.floatValue);\n-        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.doubleValue);\n     }\n \n     // for [JACKSON-616]\n-    // @since 1.9\n     public void testEmptyStringForPrimitives() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         PrimitivesBean bean;\n-        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertFalse(bean.booleanValue);\n-        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((byte) 0, bean.byteValue);\n-        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((char) 0, bean.charValue);\n-        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((short) 0, bean.shortValue);\n-        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0, bean.intValue);\n-        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0L, bean.longValue);\n-        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0f, bean.floatValue);\n-        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0, bean.doubleValue);\n     }\n \n     // for [JACKSON-652]\n-    // @since 1.9\n     public void testUntypedWithJsonArrays() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // by default we get:\n-        Object ob = mapper.readValue(\"[1]\", Object.class);\n+        Object ob = MAPPER.readValue(\"[1]\", Object.class);\n         assertTrue(ob instanceof List<?>);\n \n         // but can change to produce Object[]:\n-        mapper.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n-        ob = mapper.readValue(\"[1]\", Object.class);\n+        MAPPER.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        ob = MAPPER.readValue(\"[1]\", Object.class);\n         assertEquals(Object[].class, ob.getClass());\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testUntypedMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get \"untyped\" default map-to-map, pass Object.class\n         String JSON = \"{ \\\"foo\\\" : \\\"bar\\\", \\\"crazy\\\" : true, \\\"null\\\" : null }\";\n \n         // Not a guaranteed cast theoretically, but will work:\n         @SuppressWarnings(\"unchecked\")\n-        Map<String,Object> result = (Map<String,Object>)mapper.readValue(JSON, Object.class);\n+        Map<String,Object> result = (Map<String,Object>)MAPPER.readValue(JSON, Object.class);\n         assertNotNull(result);\n         assertTrue(result instanceof Map<?,?>);\n \n      */\n     public void testUntypedMap2() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get \"untyped\" default map-to-map, pass Object.class\n         String JSON = \"{ \\\"a\\\" : \\\"x\\\" }\";\n \n         @SuppressWarnings(\"unchecked\")\n-        HashMap<String,Object> result = /*(HashMap<String,Object>)*/ mapper.readValue(JSON, HashMap.class);\n+        HashMap<String,Object> result = /*(HashMap<String,Object>)*/ MAPPER.readValue(JSON, HashMap.class);\n         assertNotNull(result);\n         assertTrue(result instanceof Map<?,?>);\n \n     public void testUntypedMap3() throws Exception\n     {\n         String JSON = \"{\\\"a\\\":[{\\\"a\\\":\\\"b\\\"},\\\"value\\\"]}\";\n-        ObjectMapper m = new ObjectMapper();\n-        Map<?,?> result = m.readValue(JSON, Map.class);\n+        Map<?,?> result = MAPPER.readValue(JSON, Map.class);\n         assertTrue(result instanceof Map<?,?>);\n         assertEquals(1, result.size());\n         Object ob = result.get(\"a\");\n             +\" { \\\"a\\\":1 } ]\"\n             +\" }\"\n             ;\n-        result = m.readValue(JSON, Map.class);\n+        result = MAPPER.readValue(JSON, Map.class);\n         assertTrue(result instanceof Map<?,?>);\n         assertEquals(3, result.size());\n     }\n     \n     public void testSpecialMap() throws IOException\n     {\n-       final ObjectMapper mapper = new ObjectMapper();\n-       final ObjectWrapperMap map = mapper.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);\n+       final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);\n        _doTestUntyped(map);\n     }\n \n     public void testGenericMap() throws IOException\n     {\n-        final ObjectMapper mapper = new ObjectMapper();\n-        final Map<String, ObjectWrapper> map = mapper.readValue\n+        final Map<String, ObjectWrapper> map = MAPPER.readValue\n             (UNTYPED_MAP_JSON,\n              new TypeReference<Map<String, ObjectWrapper>>() { });\n        _doTestUntyped(map);\n \n     public void testExactStringIntMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get typing, must use type reference\n         String JSON = \"{ \\\"foo\\\" : 13, \\\"bar\\\" : -39, \\n \\\"\\\" : 0 }\";\n-        Map<String,Integer> result = mapper.readValue\n+        Map<String,Integer> result = MAPPER.readValue\n             (JSON, new TypeReference<HashMap<String,Integer>>() { });\n \n         assertNotNull(result);\n      */\n     public void testIntBooleanMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get typing, must use type reference\n         String JSON = \"{ \\\"1\\\" : true, \\\"-1\\\" : false }\";\n-        Map<String,Integer> result = mapper.readValue\n+        Map<String,Integer> result = MAPPER.readValue\n             (JSON, new TypeReference<HashMap<Integer,Boolean>>() { });\n \n         assertNotNull(result);\n \n     public void testExactStringStringMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get typing, must use type reference\n         String JSON = \"{ \\\"a\\\" : \\\"b\\\" }\";\n-        Map<String,Integer> result = mapper.readValue\n+        Map<String,Integer> result = MAPPER.readValue\n             (JSON, new TypeReference<TreeMap<String,String>>() { });\n \n         assertNotNull(result);\n      */\n     public void testGenericStringIntMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // to get typing, must use type reference; but with abstract type\n         String JSON = \"{ \\\"a\\\" : 1, \\\"b\\\" : 2, \\\"c\\\" : -99 }\";\n-        Map<String,Integer> result = mapper.readValue\n+        Map<String,Integer> result = MAPPER.readValue\n             (JSON, new TypeReference<Map<String,Integer>>() { });\n         assertNotNull(result);\n         assertTrue(result instanceof Map<?,?>);\n \n     public void testEnumMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         String JSON = \"{ \\\"KEY1\\\" : \\\"\\\", \\\"WHATEVER\\\" : null }\";\n \n         // to get typing, must use type reference\n-        EnumMap<Key,String> result = mapper.readValue\n+        EnumMap<Key,String> result = MAPPER.readValue\n             (JSON, new TypeReference<EnumMap<Key,String>>() { });\n \n         assertNotNull(result);\n \n     public void testMapWithEnums() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         String JSON = \"{ \\\"KEY2\\\" : \\\"WHATEVER\\\" }\";\n \n         // to get typing, must use type reference\n-        Map<Enum<?>,Enum<?>> result = mapper.readValue\n+        Map<Enum<?>,Enum<?>> result = MAPPER.readValue\n             (JSON, new TypeReference<Map<Key,Key>>() { });\n \n         assertNotNull(result);\n      */\n     public void testDateMap() throws Exception\n     {\n-    \t ObjectMapper mapper = new ObjectMapper();\n     \t Date date1=new Date(123456000L);\n     \t DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n          \n     \t String JSON = \"{ \\\"\"+  fmt.format(date1)+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n-    \t HashMap<Date,String> result=  mapper.readValue\n+    \t HashMap<Date,String> result=  MAPPER.readValue\n     \t            (JSON, new TypeReference<HashMap<Date,String>>() { });\n     \t \n     \t assertNotNull(result);\n     \t \n     \t assertTrue(result.containsKey(new Date(0)));\n     \t assertNull(result.get(new Date(0)));\n-    \t \n-    \t \n     }\n     \n     /*\n \n     public void testCalendarMap() throws Exception\n     {\n-    \t ObjectMapper mapper = new ObjectMapper();\n     \t Calendar c = Calendar.getInstance();\n          c.setTimeInMillis(123456000L);\n          DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     \t String JSON = \"{ \\\"\"+fmt.format(c.getTime())+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n-    \t HashMap<Calendar,String> result=  mapper.readValue\n+    \t HashMap<Calendar,String> result=  MAPPER.readValue\n     \t            (JSON, new TypeReference<HashMap<Calendar,String>>() { });\n     \t \n     \t assertNotNull(result);\n     // [JACKSON-726]\n     public void testUUIDKeyMap() throws Exception\n     {\n-         ObjectMapper mapper = new ObjectMapper();\n          UUID key = UUID.nameUUIDFromBytes(\"foobar\".getBytes(\"UTF-8\"));\n          String JSON = \"{ \\\"\"+key+\"\\\":4}\";\n-         Map<UUID,Object> result = mapper.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });\n+         Map<UUID,Object> result = MAPPER.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });\n          assertNotNull(result);\n          assertEquals(1, result.size());\n          Object ob = result.keySet().iterator().next();\n      */\n     public void testMapWithDeserializer() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        CustomMap result = mapper.readValue(quote(\"xyz\"), CustomMap.class);\n+        CustomMap result = MAPPER.readValue(quote(\"xyz\"), CustomMap.class);\n         assertEquals(1, result.size());\n         assertEquals(\"xyz\", result.get(\"x\"));\n     }\n \n     public void testMapError() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         try {\n-            Object result = mapper.readValue(\"[ 1, 2 ]\", \n+            Object result = MAPPER.readValue(\"[ 1, 2 ]\", \n                                              new TypeReference<Map<String,String>>() { });\n             fail(\"Expected an exception, but got result value: \"+result);\n         } catch (JsonMappingException jex) {\n \n     public void testNoCtorMap() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         try {\n-            BrokenMap result = mapper.readValue(\"{ \\\"a\\\" : 3 }\", BrokenMap.class);\n+            BrokenMap result = MAPPER.readValue(\"{ \\\"a\\\" : 3 }\", BrokenMap.class);\n             // should never get here; assert added to remove compiler warning\n             assertNull(result);\n         } catch (JsonMappingException e) {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testBooleanPrimitive() throws Exception\n     {\n         // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n-        BooleanBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":true}\"), BooleanBean.class);\n+        BooleanBean result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":true}\"), BooleanBean.class);\n         assertTrue(result._v);\n         // then [JACKSON-79]:\n-        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), BooleanBean.class);\n+        result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), BooleanBean.class);\n         assertNotNull(result);\n         assertFalse(result._v);\n \n         // should work with arrays too..\n-        boolean[] array = mapper.readValue(new StringReader(\"[ null ]\"), boolean[].class);\n+        boolean[] array = MAPPER.readValue(new StringReader(\"[ null ]\"), boolean[].class);\n         assertNotNull(array);\n         assertEquals(1, array.length);\n         assertFalse(array[0]);\n     public void testIntPrimitive() throws Exception\n     {\n         // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n-        IntBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":3}\"), IntBean.class);\n+        IntBean result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":3}\"), IntBean.class);\n         assertEquals(3, result._v);\n         // then [JACKSON-79]:\n-        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), IntBean.class);\n+        result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), IntBean.class);\n         assertNotNull(result);\n         assertEquals(0, result._v);\n \n         // should work with arrays too..\n-        int[] array = mapper.readValue(new StringReader(\"[ null ]\"), int[].class);\n+        int[] array = MAPPER.readValue(new StringReader(\"[ null ]\"), int[].class);\n         assertNotNull(array);\n         assertEquals(1, array.length);\n         assertEquals(0, array[0]);\n     public void testDoublePrimitive() throws Exception\n     {\n         // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n         // bit tricky with binary fps but...\n         double value = 0.016;\n-        DoubleBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\"+value+\"}\"), DoubleBean.class);\n+        DoubleBean result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":\"+value+\"}\"), DoubleBean.class);\n         assertEquals(value, result._v);\n         // then [JACKSON-79]:\n-        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), DoubleBean.class);\n+        result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), DoubleBean.class);\n         assertNotNull(result);\n         assertEquals(0.0, result._v);\n \n         // should work with arrays too..\n-        double[] array = mapper.readValue(new StringReader(\"[ null ]\"), double[].class);\n+        double[] array = MAPPER.readValue(new StringReader(\"[ null ]\"), double[].class);\n         assertNotNull(array);\n         assertEquals(1, array.length);\n         assertEquals(0.0, array[0]);\n     public void testDoublePrimitiveNonNumeric() throws Exception\n     {\n         // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n         // bit tricky with binary fps but...\n         double value = Double.POSITIVE_INFINITY;\n-        DoubleBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), DoubleBean.class);\n+        DoubleBean result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), DoubleBean.class);\n         assertEquals(value, result._v);\n         \n         // should work with arrays too..\n-        double[] array = mapper.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), double[].class);\n+        double[] array = MAPPER.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), double[].class);\n         assertNotNull(array);\n         assertEquals(1, array.length);\n         assertEquals(Double.POSITIVE_INFINITY, array[0]);\n     \n     public void testFloatPrimitiveNonNumeric() throws Exception\n     {\n-        // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n         // bit tricky with binary fps but...\n         float value = Float.POSITIVE_INFINITY;\n-        FloatBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), FloatBean.class);\n+        FloatBean result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), FloatBean.class);\n         assertEquals(value, result._v);\n         \n         // should work with arrays too..\n-        float[] array = mapper.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), float[].class);\n+        float[] array = MAPPER.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), float[].class);\n         assertNotNull(array);\n         assertEquals(1, array.length);\n         assertEquals(Float.POSITIVE_INFINITY, array[0]);\n      */\n     public void testIntWithOverride() throws Exception\n     {\n-        // first, simple case:\n-        ObjectMapper mapper = new ObjectMapper();\n-        IntBean2 result = mapper.readValue(new StringReader(\"{\\\"v\\\":8}\"), IntBean2.class);\n+        IntBean2 result = MAPPER.readValue(new StringReader(\"{\\\"v\\\":8}\"), IntBean2.class);\n         assertEquals(9, result._v);\n-\n     }\n \n     /*\n      */\n     public void testBooleanWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Boolean result = mapper.readValue(new StringReader(\"true\"), Boolean.class);\n+        Boolean result = MAPPER.readValue(new StringReader(\"true\"), Boolean.class);\n         assertEquals(Boolean.TRUE, result);\n-        result = mapper.readValue(new StringReader(\"false\"), Boolean.class);\n+        result = MAPPER.readValue(new StringReader(\"false\"), Boolean.class);\n         assertEquals(Boolean.FALSE, result);\n \n-        /* [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n-         */\n-        result = mapper.readValue(new StringReader(\"0\"), Boolean.class);\n+        // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n+        result = MAPPER.readValue(new StringReader(\"0\"), Boolean.class);\n         assertEquals(Boolean.FALSE, result);\n-        result = mapper.readValue(new StringReader(\"1\"), Boolean.class);\n+        result = MAPPER.readValue(new StringReader(\"1\"), Boolean.class);\n         assertEquals(Boolean.TRUE, result);\n     }\n \n     public void testByteWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Byte result = mapper.readValue(new StringReader(\"   -42\\t\"), Byte.class);\n+        Byte result = MAPPER.readValue(new StringReader(\"   -42\\t\"), Byte.class);\n         assertEquals(Byte.valueOf((byte)-42), result);\n \n         // Also: should be able to coerce floats, strings:\n-        result = mapper.readValue(new StringReader(\" \\\"-12\\\"\"), Byte.class);\n+        result = MAPPER.readValue(new StringReader(\" \\\"-12\\\"\"), Byte.class);\n         assertEquals(Byte.valueOf((byte)-12), result);\n \n-        result = mapper.readValue(new StringReader(\" 39.07\"), Byte.class);\n+        result = MAPPER.readValue(new StringReader(\" 39.07\"), Byte.class);\n         assertEquals(Byte.valueOf((byte)39), result);\n     }\n \n     public void testShortWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Short result = mapper.readValue(new StringReader(\"37\"), Short.class);\n+        Short result = MAPPER.readValue(new StringReader(\"37\"), Short.class);\n         assertEquals(Short.valueOf((short)37), result);\n \n         // Also: should be able to coerce floats, strings:\n-        result = mapper.readValue(new StringReader(\" \\\"-1009\\\"\"), Short.class);\n+        result = MAPPER.readValue(new StringReader(\" \\\"-1009\\\"\"), Short.class);\n         assertEquals(Short.valueOf((short)-1009), result);\n \n-        result = mapper.readValue(new StringReader(\"-12.9\"), Short.class);\n+        result = MAPPER.readValue(new StringReader(\"-12.9\"), Short.class);\n         assertEquals(Short.valueOf((short)-12), result);\n     }\n \n     public void testCharacterWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // First: canonical value is 1-char string\n-        Character result = mapper.readValue(new StringReader(\"\\\"a\\\"\"), Character.class);\n+        Character result = MAPPER.readValue(new StringReader(\"\\\"a\\\"\"), Character.class);\n         assertEquals(Character.valueOf('a'), result);\n \n         // But can also pass in ascii code\n-        result = mapper.readValue(new StringReader(\" \"+((int) 'X')), Character.class);\n+        result = MAPPER.readValue(new StringReader(\" \"+((int) 'X')), Character.class);\n         assertEquals(Character.valueOf('X'), result);\n     }\n \n     public void testIntWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Integer result = mapper.readValue(new StringReader(\"   -42\\t\"), Integer.class);\n+        Integer result = MAPPER.readValue(new StringReader(\"   -42\\t\"), Integer.class);\n         assertEquals(Integer.valueOf(-42), result);\n \n         // Also: should be able to coerce floats, strings:\n-        result = mapper.readValue(new StringReader(\" \\\"-1200\\\"\"), Integer.class);\n+        result = MAPPER.readValue(new StringReader(\" \\\"-1200\\\"\"), Integer.class);\n         assertEquals(Integer.valueOf(-1200), result);\n \n-        result = mapper.readValue(new StringReader(\" 39.07\"), Integer.class);\n+        result = MAPPER.readValue(new StringReader(\" 39.07\"), Integer.class);\n         assertEquals(Integer.valueOf(39), result);\n     }\n \n     public void testLongWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Long result = mapper.readValue(new StringReader(\"12345678901\"), Long.class);\n+        Long result = MAPPER.readValue(new StringReader(\"12345678901\"), Long.class);\n         assertEquals(Long.valueOf(12345678901L), result);\n \n         // Also: should be able to coerce floats, strings:\n-        result = mapper.readValue(new StringReader(\" \\\"-9876\\\"\"), Long.class);\n+        result = MAPPER.readValue(new StringReader(\" \\\"-9876\\\"\"), Long.class);\n         assertEquals(Long.valueOf(-9876), result);\n \n-        result = mapper.readValue(new StringReader(\"1918.3\"), Long.class);\n+        result = MAPPER.readValue(new StringReader(\"1918.3\"), Long.class);\n         assertEquals(Long.valueOf(1918), result);\n     }\n \n      */\n     public void testFloatWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         // Also: should be able to coerce floats, strings:\n         String[] STRS = new String[] {\n             \"1.0\", \"0.0\", \"-0.3\", \"0.7\", \"42.012\", \"-999.0\", NAN_STRING\n \n             if (NAN_STRING != str) {\n                 // First, as regular floating point value\n-                result = mapper.readValue(new StringReader(str), Float.class);\n+                result = MAPPER.readValue(new StringReader(str), Float.class);\n                 assertEquals(exp, result);\n             }\n \n             // and then as coerced String:\n-            result = mapper.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Float.class);\n+            result = MAPPER.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Float.class);\n             assertEquals(exp, result);\n         }\n     }\n \n     public void testDoubleWrapper() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         // Also: should be able to coerce doubles, strings:\n         String[] STRS = new String[] {\n             \"1.0\", \"0.0\", \"-0.3\", \"0.7\", \"42.012\", \"-999.0\", NAN_STRING\n \n             // First, as regular double value\n             if (NAN_STRING != str) {\n-            \tresult = mapper.readValue(new StringReader(str), Double.class);\n+            \tresult = MAPPER.readValue(new StringReader(str), Double.class);\n             \tassertEquals(exp, result);\n             }\n             // and then as coerced String:\n-            result = mapper.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Double.class);\n+            result = MAPPER.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Double.class);\n             assertEquals(exp, result);\n         }\n     }\n \n     public void testSingleString() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         String value = \"FOO!\";\n-        String result = mapper.readValue(new StringReader(\"\\\"\"+value+\"\\\"\"), String.class);\n+        String result = MAPPER.readValue(new StringReader(\"\\\"\"+value+\"\\\"\"), String.class);\n         assertEquals(value, result);\n     }\n \n     public void testNull() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // null doesn't really have a type, fake by assuming Object\n-        Object result = mapper.readValue(\"   null\", Object.class);\n+        Object result = MAPPER.readValue(\"   null\", Object.class);\n         assertNull(result);\n     }\n \n     public void testClass() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Class<?> result = mapper.readValue(\"\\\"java.lang.String\\\"\", Class.class);\n+        Class<?> result = MAPPER.readValue(\"\\\"java.lang.String\\\"\", Class.class);\n         assertEquals(String.class, result);\n     }\n \n     public void testBigDecimal() throws Exception\n     {\n         BigDecimal value = new BigDecimal(\"0.001\");\n-        BigDecimal result = new ObjectMapper().readValue(new StringReader(value.toString()), BigDecimal.class);\n+        BigDecimal result = MAPPER.readValue(new StringReader(value.toString()), BigDecimal.class);\n         assertEquals(value, result);\n     }\n \n     public void testBigInteger() throws Exception\n     {\n         BigInteger value = new BigInteger(\"-1234567890123456789012345567809\");\n-        BigInteger result = new ObjectMapper().readValue(new StringReader(value.toString()), BigInteger.class);\n+        BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class);\n         assertEquals(value, result);\n     }\n \n     public void testUUID() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         UUID value = UUID.fromString(\"76e6d183-5f68-4afa-b94a-922c1fdb83f8\");\n-        assertEquals(value, mapper.readValue(\"\\\"\"+value.toString()+\"\\\"\", UUID.class));\n+        assertEquals(value, MAPPER.readValue(\"\\\"\"+value.toString()+\"\\\"\", UUID.class));\n \n         // [JACKSON-393] fix:\n \n         // first, null should come as null\n         TokenBuffer buf = new TokenBuffer(null);\n         buf.writeObject(null);\n-        assertNull(mapper.readValue(buf.asParser(), UUID.class));\n+        assertNull(MAPPER.readValue(buf.asParser(), UUID.class));\n \n         // then, UUID itself come as is:\n         buf = new TokenBuffer(null);\n         buf.writeObject(value);\n-        assertSame(value, mapper.readValue(buf.asParser(), UUID.class));\n+        assertSame(value, MAPPER.readValue(buf.asParser(), UUID.class));\n \n         // and finally from byte[]\n         // oh crap; JDK UUID just... sucks. Not even byte[] accessors or constructors? Huh?\n         \n         buf.writeObject(data);\n \n-        UUID value2 = mapper.readValue(buf.asParser(), UUID.class);\n+        UUID value2 = MAPPER.readValue(buf.asParser(), UUID.class);\n         \n         assertEquals(value, value2);\n     }\n \n     public void testURL() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         URL value = new URL(\"http://foo.com\");\n-        assertEquals(value, mapper.readValue(\"\\\"\"+value.toString()+\"\\\"\", URL.class));\n+        assertEquals(value, MAPPER.readValue(\"\\\"\"+value.toString()+\"\\\"\", URL.class));\n \n         // trivial case; null to null, embedded URL to URL\n         TokenBuffer buf = new TokenBuffer(null);\n         buf.writeObject(null);\n-        assertNull(mapper.readValue(buf.asParser(), URL.class));\n+        assertNull(MAPPER.readValue(buf.asParser(), URL.class));\n \n         // then, UUID itself come as is:\n         buf = new TokenBuffer(null);\n         buf.writeObject(value);\n-        assertSame(value, mapper.readValue(buf.asParser(), URL.class));\n+        assertSame(value, MAPPER.readValue(buf.asParser(), URL.class));\n     }\n \n     public void testURI() throws Exception\n     {\n         URI value = new URI(\"http://foo.com\");\n-        assertEquals(value, new ObjectMapper().readValue(\"\\\"\"+value.toString()+\"\\\"\", URI.class));\n+        assertEquals(value, MAPPER.readValue(\"\\\"\"+value.toString()+\"\\\"\", URI.class));\n     }\n \n     /*\n             sb.append(\" \");\n             sb.append(i);\n         }\n-\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(sb.toString());\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(sb.toString());\n         for (int i = 0; i < NR_OF_INTS; ++i) {\n-            Integer result = mapper.readValue(jp, Integer.class);\n+            Integer result = MAPPER.readValue(jp, Integer.class);\n             assertEquals(Integer.valueOf(i), result);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestGroovyBeans.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestGroovyBeans.java\n         +\"String name = \\\"whome\\\";\\n\"\n         +\"}\";\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     public void testSimpleSerialization() throws Exception\n     {\n         Object ob = newGroovyObject(SIMPLE_POGO);\n-        Map<String,Object> result = writeAndMap(ob);\n+        Map<String,Object> result = writeAndMap(MAPPER, ob);\n         assertEquals(2, result.size());\n         assertEquals(\"whome\", result.get(\"name\"));\n         /* 26-Nov-2009, tatu: Strange... Groovy seems to decide\n     {\n         Class<?> cls = defineGroovyClass(SIMPLE_POGO);\n         // First: deserialize from data\n-        Object pogo = new ObjectMapper().readValue(\"{\\\"id\\\":9,\\\"name\\\":\\\"Bob\\\"}\", cls);\n+        Object pogo = MAPPER.readValue(\"{\\\"id\\\":9,\\\"name\\\":\\\"Bob\\\"}\", cls);\n         assertNotNull(pogo);\n         /* Hmmh. Could try to access using Reflection, or by defining\n          * a Java interface it implements. Or, maybe simplest, just\n          * re-serialize and see what we got.\n          */\n-        Map<String,Object> result = writeAndMap(pogo);\n+        Map<String,Object> result = writeAndMap(MAPPER, pogo);\n         assertEquals(2, result.size());\n         assertEquals(\"Bob\", result.get(\"name\"));\n         // as per earlier, we just get a number...\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     /* Unit tests\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     /**\n      * First things first, let's ensure we can serialize using\n      */\n     public void testSimpleClassAsProperty() throws Exception\n     {\n-        Map<String,Object> result = writeAndMap(new Cat(\"Beelzebub\", \"tabby\"));\n+        Map<String,Object> result = writeAndMap(MAPPER, new Cat(\"Beelzebub\", \"tabby\"));\n         assertEquals(3, result.size());\n         assertEquals(\"Beelzebub\", result.get(\"name\"));\n         assertEquals(\"tabby\", result.get(\"furColor\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize2.java\n     /* Test methods\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     // [JACKSON-480], test value annotation applied to List value class\n     public void testSerializedAsListWithClassAnnotations() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         SimpleValueList list = new SimpleValueList();\n         list.add(new ActualValue(\"foo\"));\n-        assertEquals(\"[{\\\"value\\\":\\\"foo\\\"}]\", m.writeValueAsString(list));\n+        assertEquals(\"[{\\\"value\\\":\\\"foo\\\"}]\", MAPPER.writeValueAsString(list));\n     }\n \n     // [JACKSON-480], test value annotation applied to Map value class\n     public void testSerializedAsMapWithClassAnnotations() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         SimpleValueMap map = new SimpleValueMap();\n         map.put(new SimpleKey(\"x\"), new ActualValue(\"y\"));\n-        assertEquals(\"{\\\"toString:x\\\":{\\\"value\\\":\\\"y\\\"}}\", m.writeValueAsString(map));\n+        assertEquals(\"{\\\"toString:x\\\":{\\\"value\\\":\\\"y\\\"}}\", MAPPER.writeValueAsString(map));\n     }\n \n     // [JACKSON-480], test Serialization annotation with List\n     // [JACKSON-480], test Serialization annotation with Map\n     public void testSerializedAsMapWithClassSerializer() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         SimpleValueMapWithSerializer map = new SimpleValueMapWithSerializer();\n         map.put(new SimpleKey(\"abc\"), new ActualValue(\"123\"));\n-        assertEquals(\"{\\\"key abc\\\":\\\"value 123\\\"}\", m.writeValueAsString(map));\n+        assertEquals(\"{\\\"key abc\\\":\\\"value 123\\\"}\", MAPPER.writeValueAsString(map));\n     }\n     \n     // [JACKSON-480], test annotations when applied to List property (getter, setter)\n     public void testSerializedAsListWithPropertyAnnotations() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         ListWrapperSimple input = new ListWrapperSimple(\"bar\");\n-        assertEquals(\"{\\\"values\\\":[{\\\"value\\\":\\\"bar\\\"}]}\", m.writeValueAsString(input));\n+        assertEquals(\"{\\\"values\\\":[{\\\"value\\\":\\\"bar\\\"}]}\", MAPPER.writeValueAsString(input));\n     }\n \n     public void testSerializedAsListWithPropertyAnnotations2() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         ListWrapperWithSerializer input = new ListWrapperWithSerializer(\"abc\");\n-        assertEquals(\"{\\\"values\\\":[\\\"value abc\\\"]}\", m.writeValueAsString(input));\n+        assertEquals(\"{\\\"values\\\":[\\\"value abc\\\"]}\", MAPPER.writeValueAsString(input));\n     }\n     \n     // [JACKSON-480], test annotations when applied to Map property (getter, setter)\n     public void testSerializedAsMapWithPropertyAnnotations() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         MapWrapperSimple input = new MapWrapperSimple(\"a\", \"b\");\n-        assertEquals(\"{\\\"values\\\":{\\\"toString:a\\\":{\\\"value\\\":\\\"b\\\"}}}\", m.writeValueAsString(input));\n+        assertEquals(\"{\\\"values\\\":{\\\"toString:a\\\":{\\\"value\\\":\\\"b\\\"}}}\", MAPPER.writeValueAsString(input));\n     }\n \n     public void testSerializedAsMapWithPropertyAnnotations2() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n         MapWrapperWithSerializer input = new MapWrapperWithSerializer(\"foo\", \"b\");\n-        assertEquals(\"{\\\"values\\\":{\\\"key foo\\\":\\\"value b\\\"}}\", m.writeValueAsString(input));\n+        assertEquals(\"{\\\"values\\\":{\\\"key foo\\\":\\\"value b\\\"}}\", MAPPER.writeValueAsString(input));\n     }\n \n     // [JACKSON-602]: Include.NON_EMPTY\n     public void testEmptyInclusion() throws IOException\n     {\n-        ObjectMapper defMapper = new ObjectMapper();\n+        ObjectMapper defMapper = MAPPER;\n         ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonSerialize.Inclusion.NON_EMPTY);\n \n         StringWrapper str = new StringWrapper(\"\");\n     // [JACKSON-699]\n     public void testNullSerializer() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new NullBean());\n+        String json = MAPPER.writeValueAsString(new NullBean());\n         assertEquals(\"{\\\"value\\\":null}\", json);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestArraySerialization.java\n package com.fasterxml.jackson.databind.ser;\n-\n-\n \n import java.io.*;\n \n public class TestArraySerialization\n     extends BaseTest\n {\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testLongStringArray() throws Exception\n     {\n         final int SIZE = 40000;\n             sb.append((char) i);\n         }\n         String str = sb.toString();\n-        ObjectMapper mapper = new ObjectMapper();\n-        byte[] data = mapper.writeValueAsBytes(new String[] { \"abc\", str, null, str });\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(data);\n+        byte[] data = MAPPER.writeValueAsBytes(new String[] { \"abc\", str, null, str });\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(data);\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n         assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n         assertEquals(\"abc\", jp.getText());\n     \n     public void testIntArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new int[] { 1, 2, 3, -7 });\n+        MAPPER.writeValue(sw, new int[] { 1, 2, 3, -7 });\n         assertEquals(\"[1,2,3,-7]\", sw.toString().trim());\n     }\n \n     public void testBigIntArray() throws Exception\n     {\n         final int SIZE = 99999;\n-        ObjectMapper mapper = new ObjectMapper();\n         int[] ints = new int[SIZE];\n         for (int i = 0; i < ints.length; ++i) {\n             ints[i] = i;\n         // Let's try couple of times, to ensure that state is handled\n         // correctly by ObjectMapper (wrt buffer recycling used\n         // with 'writeAsBytes()')\n-        JsonFactory f = mapper.getJsonFactory();\n+        JsonFactory f = MAPPER.getJsonFactory();\n         for (int round = 0; round < 3; ++round) {\n-            byte[] data = mapper.writeValueAsBytes(ints);\n+            byte[] data = MAPPER.writeValueAsBytes(ints);\n             JsonParser jp = f.createJsonParser(data);\n             assertToken(JsonToken.START_ARRAY, jp.nextToken());\n             for (int i = 0; i < SIZE; ++i) {\n     \n     public void testLongArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });\n+        MAPPER.writeValue(sw, new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });\n         assertEquals(\"[\"+Long.MIN_VALUE+\",0,\"+Long.MAX_VALUE+\"]\", sw.toString().trim());\n     }\n \n     public void testStringArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new String[] { \"a\", \"\\\"foo\\\"\", null });\n+        MAPPER.writeValue(sw, new String[] { \"a\", \"\\\"foo\\\"\", null });\n         assertEquals(\"[\\\"a\\\",\\\"\\\\\\\"foo\\\\\\\"\\\",null]\", sw.toString().trim());\n     }\n \n     public void testDoubleArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });\n+        MAPPER.writeValue(sw, new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });\n         assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n     }\n \n     public void testFloatArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });\n+        MAPPER.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });\n         assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFieldSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFieldSerialization.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testSimpleAutoDetect() throws Exception\n     {\n         SimpleFieldBean bean = new SimpleFieldBean();\n         // let's set x, leave y as is\n         bean.x = 13;\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, bean);\n+        Map<String,Object> result = writeAndMap(MAPPER, bean);\n         assertEquals(2, result.size());\n         assertEquals(Integer.valueOf(13), result.get(\"x\"));\n         assertEquals(Integer.valueOf(0), result.get(\"y\"));\n     {\n         SimpleFieldBean2 bean = new SimpleFieldBean2();\n         bean.values = new String[] { \"a\", \"b\" };\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, bean);\n+        Map<String,Object> result = writeAndMap(MAPPER, bean);\n         assertEquals(1, result.size());\n         List<String> values = (List<String>) result.get(\"values\");\n         assertEquals(2, values.size());\n     public void testTransientAndStatic() throws Exception\n     {\n         TransientBean bean = new TransientBean();\n-        Map<String,Object> result = writeAndMap(bean);\n+        Map<String,Object> result = writeAndMap(MAPPER, bean);\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(0), result.get(\"a\"));\n     }\n     {\n         NoAutoDetectBean bean = new NoAutoDetectBean();\n         bean._z = -4;\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, bean);\n+        Map<String,Object> result = writeAndMap(MAPPER, bean);\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(-4), result.get(\"z\"));\n     }\n         FieldAndMethodBean bean = new FieldAndMethodBean();\n         bean.z = 9;\n         assertEquals(10, bean.getZ());\n-        assertEquals(\"{\\\"z\\\":10}\", serializeAsString(bean));\n+        assertEquals(\"{\\\"z\\\":10}\", MAPPER.writeValueAsString(bean));\n     }\n \n     /**\n     public void testOkDupFields() throws Exception\n     {\n         OkDupFieldBean bean = new OkDupFieldBean(1, 2);\n-        Map<String,Object> json = writeAndMap(new ObjectMapper(), bean);\n+        Map<String,Object> json = writeAndMap(MAPPER, bean);\n         assertEquals(2, json.size());\n         assertEquals(Integer.valueOf(1), json.get(\"x\"));\n         assertEquals(Integer.valueOf(2), json.get(\"y\"));\n     public void testFailureDueToDups() throws Exception\n     {\n         try {\n-            writeAndMap(new ObjectMapper(), new DupFieldBean());\n+            writeAndMap(MAPPER, new DupFieldBean());\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Multiple fields representing\");\n         }\n     public void testFailureDueToDupField() throws Exception\n     {\n         try {\n-            writeAndMap(new ObjectMapper(), new DupFieldBean2());\n+            writeAndMap(MAPPER, new DupFieldBean2());\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Multiple fields representing\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestIgnoreProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestIgnoreProperties.java\n      ****************************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testExplicitIgnoralWithBean() throws Exception\n     {\n         IgnoreSome value = new IgnoreSome();\n-        Map<String,Object> result = writeAndMap(value);\n+        Map<String,Object> result = writeAndMap(MAPPER, value);\n         assertEquals(2, result.size());\n         // verify that specified fields are ignored\n         assertFalse(result.containsKey(\"b\"));\n         MyMap value = new MyMap();\n         value.put(\"a\", \"b\");\n         value.put(\"@class\", MyMap.class.getName());\n-        Map<String,Object> result = writeAndMap(value);\n+        Map<String,Object> result = writeAndMap(MAPPER, value);\n         assertEquals(1, result.size());\n         // verify that specified field is ignored\n         assertFalse(result.containsKey(\"@class\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n public class TestJdkTypes\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     /**\n      * Unit test related to [JACKSON-155]\n      */\n          * It'd be hard to make truly portable test tho...\n          */\n         File f = new File(\"/tmp/foo.txt\");\n-        String str = serializeAsString(new ObjectMapper(), f);\n+        String str = serializeAsString(MAPPER, f);\n         assertEquals(\"\\\"\"+f.getAbsolutePath()+\"\\\"\", str);\n     }\n \n         Pattern p = Pattern.compile(PATTERN_STR);\n         Map<String,Object> input = new HashMap<String,Object>();\n         input.put(\"p\", p);\n-        Map<String,Object> result = writeAndMap(input);\n+        Map<String,Object> result = writeAndMap(MAPPER, input);\n         assertEquals(p.pattern(), result.get(\"p\"));\n     }\n \n     public void testCurrency() throws IOException\n     {\n         Currency usd = Currency.getInstance(\"USD\");\n-        assertEquals(quote(\"USD\"), new ObjectMapper().writeValueAsString(usd));\n+        assertEquals(quote(\"USD\"), MAPPER.writeValueAsString(usd));\n     }\n \n-    // @since 1.7\n     public void testLocale() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(quote(\"en\"), mapper.writeValueAsString(new Locale(\"en\")));\n-        assertEquals(quote(\"es_ES\"), mapper.writeValueAsString(new Locale(\"es\", \"ES\")));\n-        assertEquals(quote(\"fi_FI_savo\"), mapper.writeValueAsString(new Locale(\"FI\", \"fi\", \"savo\")));\n+        assertEquals(quote(\"en\"), MAPPER.writeValueAsString(new Locale(\"en\")));\n+        assertEquals(quote(\"es_ES\"), MAPPER.writeValueAsString(new Locale(\"es\", \"ES\")));\n+        assertEquals(quote(\"fi_FI_savo\"), MAPPER.writeValueAsString(new Locale(\"FI\", \"fi\", \"savo\")));\n     }\n \n     // [JACKSON-484]\n     public void testInetAddress() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(quote(\"127.0.0.1\"), mapper.writeValueAsString(InetAddress.getByName(\"127.0.0.1\")));\n-        assertEquals(quote(\"ning.com\"), mapper.writeValueAsString(InetAddress.getByName(\"ning.com\")));\n+        assertEquals(quote(\"127.0.0.1\"), MAPPER.writeValueAsString(InetAddress.getByName(\"127.0.0.1\")));\n+        assertEquals(quote(\"ning.com\"), MAPPER.writeValueAsString(InetAddress.getByName(\"ning.com\")));\n     }\n \n     // [JACKSON-597]\n     public void testClass() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(quote(\"java.lang.String\"), mapper.writeValueAsString(String.class));\n-        assertEquals(quote(\"int\"), mapper.writeValueAsString(Integer.TYPE));\n-        assertEquals(quote(\"boolean\"), mapper.writeValueAsString(Boolean.TYPE));\n-        assertEquals(quote(\"void\"), mapper.writeValueAsString(Void.TYPE));\n+        assertEquals(quote(\"java.lang.String\"), MAPPER.writeValueAsString(String.class));\n+        assertEquals(quote(\"int\"), MAPPER.writeValueAsString(Integer.TYPE));\n+        assertEquals(quote(\"boolean\"), MAPPER.writeValueAsString(Boolean.TYPE));\n+        assertEquals(quote(\"void\"), MAPPER.writeValueAsString(Void.TYPE));\n     }\n \n }", "timestamp": 1325207168, "metainfo": ""}