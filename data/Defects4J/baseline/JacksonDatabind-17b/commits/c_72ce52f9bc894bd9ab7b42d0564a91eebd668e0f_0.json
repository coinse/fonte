{"sha": "72ce52f9bc894bd9ab7b42d0564a91eebd668e0f", "log": "Merge branch 'custom-id-resolution' of https://github.com/pgelinas/jackson-databind into pgelinas-custom-id-resolution  Conflicts: \tsrc/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n         }\n         return gen.forScope(objectIdInfo.getScope());\n     }\n-    \n+\n+    public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo)\n+    {\n+        Class<? extends ObjectIdResolver> implClass = objectIdInfo.getResolverType();\n+        final MapperConfig<?> config = getConfig();\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        ObjectIdResolver resolver = (hi == null) ? null : hi.resolverIdGeneratorInstance(config, annotated, implClass);\n+        if (resolver == null) {\n+            resolver = ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers());\n+        }\n+\n+        return resolver;\n+    }\n+\n     /**\n      * Helper method to use to construct a {@link Converter}, given a definition\n      * that may be either actual converter instance, or Class for instantiating one.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      * Method called to find and return entry corresponding to given\n      * Object Id: will add an entry if necessary, and never returns null\n      */\n-    public abstract ReadableObjectId findObjectId(Object id,\n-            ObjectIdGenerator<?> generator);\n+    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver);\n+\n+    @Deprecated\n+    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator);\n \n     /**\n      * Method called to ensure that every object id encounter during processing\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n package com.fasterxml.jackson.databind.cfg;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n         return null;\n     }\n \n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n+    {\n+        return null;\n+    }\n+\n     /**\n      * Method called to construct a NamingStrategy instance used for specified\n      * class.\n             Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n-        Object pojo = roid.item;\n+        Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n             throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n                 JavaType idType;\n                 SettableBeanProperty idProp;\n                 ObjectIdGenerator<?> idGen;\n+                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                 if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                     PropertyName propName = objectIdInfo.getPropertyName();\n                     idProp = findProperty(propName);\n                 }\n                 JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                 oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n-                \t\tidGen, deser, idProp);\n+                \t\tidGen, deser, idProp, resolver);\n             }\n         }\n         // either way, need to resolve serializer:\n             id = _convertObjectId(jp, ctxt, rawId, idDeser);\n         }\n \n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(pojo);\n         // also: may need to set a property value as well\n         SettableBeanProperty idProp = _objectIdReader.idProperty;\n         throws IOException, JsonProcessingException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n-        Object pojo = roid.item;\n+        Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n             throw new UnresolvedForwardReference(\"Could not resolve Object Id [\"+id+\"] (for \"\n                     +_beanType+\").\", jp.getCurrentLocation(), roid);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n         SettableBeanProperty idProp;\n         ObjectIdGenerator<?> gen;\n \n+        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n+\n         // Just one special case: Property-based generator is trickier\n         if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n             PropertyName propName = objectIdInfo.getPropertyName();\n         // also: unlike with value deserializers, let's just resolve one we need here\n         JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n         builder.setObjectIdReader(ObjectIdReader.construct(idType,\n-                objectIdInfo.getPropertyName(), gen, deser, idProp));\n+                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map.Entry;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n \n     protected transient LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds;\n \n+    private List<ObjectIdResolver> _objectIdResolvers;\n+\n     /**\n      * Constructor that will pass specified deserializer factory and\n      * cache: cache may be null (in which case default implementation\n      */\n \n     @Override\n-    public ReadableObjectId findObjectId(Object id,\n-            ObjectIdGenerator<?> generator)\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolverType)\n     {\n         final ObjectIdGenerator.IdKey key = generator.key(id);\n         if (_objectIds == null) {\n-            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n             ReadableObjectId entry = _objectIds.get(key);\n             if (entry != null) {\n                 return entry;\n             }\n         }\n-        ReadableObjectId entry = new ReadableObjectId(id);\n+\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        } else {\n+            for (ObjectIdResolver res : _objectIdResolvers) {\n+                if (res.canUseFor(resolverType)) {\n+                    resolver = res;\n+                    break;\n+                }\n+            }\n+        }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            _objectIdResolvers.add(resolver);\n+        }\n+\n+        ReadableObjectId entry = new ReadableObjectId(key);\n+        entry.setResolver(resolver);\n         _objectIds.put(key, entry);\n         return entry;\n     }\n     \n     @Override\n-    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n-    {\n-        if(_objectIds == null){\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator)\n+    {\n+        return findObjectId(id, generator, new SimpleObjectIdResolver());\n+    }\n+\n+    @Override\n+    public void checkUnresolvedObjectId()\n+        throws UnresolvedForwardReference\n+    {\n+        if (_objectIds == null) {\n             return;\n         }\n \n         UnresolvedForwardReference exception = null;\n         for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n             ReadableObjectId roid = entry.getValue();\n-            if(roid.hasReferringProperties()){\n-                if(exception == null){\n+            if (roid.hasReferringProperties()) {\n+                if (exception == null) {\n                     exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n                 }\n                 for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext();) {\n                     Referring referring = iterator.next();\n-                    exception.addUnresolvedId(roid.id, referring.getBeanType(), referring.getLocation());\n+                    exception.addUnresolvedId(roid.getKey().key, referring.getBeanType(), referring.getLocation());\n                 }\n             }\n         }\n-        if(exception != null){\n+        if (exception != null) {\n             throw exception;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n     }\n \n     public Object getUnresolvedId() {\n-        return _roid.id;\n+        return _roid.getKey().key;\n     }\n \n     public void addUnresolvedId(Object id, Class<?> type, JsonLocation where) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n      * the key.\n      */\n     public final ObjectIdGenerator<?> generator;\n-    \n+\n+    /**\n+     * \n+     */\n+    public final ObjectIdResolver resolver;\n+\n     /**\n      * Deserializer used for deserializing id values.\n      */\n     \n     @SuppressWarnings(\"unchecked\")\n     protected ObjectIdReader(JavaType t, PropertyName propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n+            JsonDeserializer<?> deser, SettableBeanProperty idProp, ObjectIdResolver resolver)\n     {\n         _idType = t;\n         propertyName = propName;\n         generator = gen;\n+        this.resolver = resolver;\n         _deserializer = (JsonDeserializer<Object>) deser;\n         idProperty = idProp;\n+    }\n+\n+    @Deprecated // since 2.4\n+    protected ObjectIdReader(JavaType t, PropertyName propName, ObjectIdGenerator<?> gen,\n+            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n+    {\n+        this(t,propName, gen, deser, idProp, new SimpleObjectIdResolver());\n     }\n \n     @Deprecated // since 2.3\n      */\n     public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n             ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n+            SettableBeanProperty idProp, ObjectIdResolver resolver)\n+    {\n+        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n+    }\n+\n+    @Deprecated // since 2.4\n+    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n+            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n             SettableBeanProperty idProp)\n     {\n-        return new ObjectIdReader(idType, propName, generator, deser, idProp);\n+        return construct(idType, propName, generator, deser, idProp, new SimpleObjectIdResolver());\n     }\n     \n     @Deprecated // since 2.3\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n     {\n         // note: no null checks (unlike usually); deserializer should fail if one found\n         Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(instance);\n         // also: may need to set a property value as well\n         SettableBeanProperty idProp = _objectIdReader.idProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n     {\n         if (_objectIdReader != null) {\n             if (_idValue != null) {\n-                ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator);\n+                ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator, _objectIdReader.resolver);\n                 roid.bindItem(bean);\n                 // also: may need to set a property value as well\n                 SettableBeanProperty idProp = _objectIdReader.idProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n import java.util.Iterator;\n import java.util.LinkedList;\n \n+import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.JsonLocation;\n \n /**\n  */\n public class ReadableObjectId\n {\n+    /**\n+     * @deprecated Prefer using {@link #resolve()}, which is able to handle\n+     *             external id resolving mechanism.\n+     */\n+    @Deprecated\n+    public Object item;\n+    @Deprecated\n     public final Object id;\n \n-    public Object item;\n+    private final IdKey _key;\n \n     private LinkedList<Referring> _referringProperties;\n \n+    private ObjectIdResolver _resolver;\n+\n+    @Deprecated\n     public ReadableObjectId(Object id)\n     {\n         this.id = id;\n+        _key = null;\n+    }\n+\n+    public ReadableObjectId(IdKey key)\n+    {\n+        _key = key;\n+        id = key.key;\n+    }\n+\n+    public void setResolver(ObjectIdResolver resolver)\n+    {\n+        _resolver = resolver;\n+    }\n+\n+    public IdKey getKey()\n+    {\n+        return _key;\n     }\n \n     public void appendReferring(Referring currentReferring) {\n      */\n     public void bindItem(Object ob) throws IOException\n     {\n-        if (item != null) {\n-            throw new IllegalStateException(\"Already had POJO for id (\" + id.getClass().getName() + \") [\" + id + \"]\");\n-        }\n+        _resolver.bindItem(_key, ob);\n         item = ob;\n         if (_referringProperties != null) {\n             Iterator<Referring> it = _referringProperties.iterator();\n                 it.next().handleResolvedForwardReference(id, ob);\n             }\n         }\n+    }\n+\n+    public Object resolve(){\n+         return (item = _resolver.resolveId(_key));\n     }\n \n     public boolean hasReferringProperties() {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         }\n         // In future may need to allow passing namespace?\n         PropertyName name = new PropertyName(info.property());\n-        return new ObjectIdInfo(name, info.scope(), info.generator());\n+        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n \n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.databind.PropertyName;\n \n /**\n {\n     protected final PropertyName _propertyName;\n     protected final Class<? extends ObjectIdGenerator<?>> _generator;\n+    private final Class<? extends ObjectIdResolver> _resolver;\n     protected final Class<?> _scope;\n     protected final boolean _alwaysAsId;\n \n-    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen) {\n+    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n+            Class<? extends ObjectIdResolver> resolver)\n+    {\n+        this(name, scope, gen, false, resolver);\n+    }\n+\n+    @Deprecated // since 2.4\n+    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen)\n+    {\n         this(name, scope, gen, false);\n     }\n \n     protected ObjectIdInfo(PropertyName prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n             boolean alwaysAsId)\n     {\n+        this(prop, scope, gen, alwaysAsId, SimpleObjectIdResolver.class);\n+\n+    }\n+\n+    protected ObjectIdInfo(PropertyName prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n+            boolean alwaysAsId, Class<? extends ObjectIdResolver> resolver)\n+    {\n         _propertyName = prop;\n         _scope = scope;\n         _generator = gen;\n         _alwaysAsId = alwaysAsId;\n+        _resolver = resolver;\n     }\n \n     public ObjectIdInfo withAlwaysAsId(boolean state) {\n     public PropertyName getPropertyName() { return _propertyName; }\n     public Class<?> getScope() { return _scope; }\n     public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; }\n+    public Class<? extends ObjectIdResolver> getResolverType() { return _resolver; }\n     public boolean getAlwaysAsId() { return _alwaysAsId; }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                 // no ObjectId override, but maybe ObjectIdRef?\n                 if (oiw != null) {\n                     objectIdInfo = intr.findObjectReferenceInfo(accessor,\n-                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null));\n+                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                     oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                 }\n             } else {\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n \n import com.fasterxml.jackson.annotation.JsonAnySetter;\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.UnresolvedId;\n import com.fasterxml.jackson.databind.struct.TestObjectId.Company;\n  */\n public class TestObjectIdDeserialization extends BaseMapTest\n {\n+    private static final String POOL_KEY = \"POOL\";\n+\n     // // Classes for external id use\n     \n     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n             // Ensure that it is never called with null because of unresolved reference.\n             assertNotNull(value);\n             values.put(field, value);\n+        }\n+    }\n+\n+    static class CustomResolutionWrapper {\n+        public List<WithCustomResolution> data;\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\", resolver = PoolResolver.class)\n+    static class WithCustomResolution {\n+        public int id;\n+        public int data;\n+\n+        public WithCustomResolution(int id, int data)\n+        {\n+            this.id = id;\n+            this.data = data;\n+        }\n+    }\n+\n+    public static class PoolResolver implements ObjectIdResolver {\n+        private Map<Object,WithCustomResolution> _pool;\n+\n+        public PoolResolver() {}\n+        public PoolResolver(Map<Object,WithCustomResolution> pool){ _pool = pool; }\n+\n+        @Override\n+        public void bindItem(IdKey id, Object pojo){ }\n+\n+        @Override\n+        public Object resolveId(IdKey id){ return _pool.get(id.key); }\n+\n+        @Override\n+        public boolean canUseFor(ObjectIdResolver resolverType)\n+        {\n+            return resolverType.getClass() == getClass() && _pool != null && !_pool.isEmpty();\n+        }\n+        \n+        @Override\n+        public ObjectIdResolver newForDeserialization(Object c)\n+        {\n+            DeserializationContext context = (DeserializationContext)c;\n+            @SuppressWarnings(\"unchecked\")\n+            Map<Object,WithCustomResolution> pool = (Map<Object,WithCustomResolution>)context.getAttribute(POOL_KEY);\n+            return new PoolResolver(pool);\n         }\n     }\n \n         assertSame(result.node, result.node.next.node);\n         assertEquals(3, result.node.customId);\n     }\n+\n+    /*\n+    /*****************************************************\n+    /* Unit tests, custom id resolver\n+    /*****************************************************\n+     */\n+    public void testCustomPoolResolver()\n+        throws Exception\n+    {\n+        Map<Object,WithCustomResolution> pool = new HashMap<Object,WithCustomResolution>();\n+        pool.put(1, new WithCustomResolution(1, 1));\n+        pool.put(2, new WithCustomResolution(2, 2));\n+        pool.put(3, new WithCustomResolution(3, 3));\n+        pool.put(4, new WithCustomResolution(4, 4));\n+        pool.put(5, new WithCustomResolution(5, 5));\n+        ContextAttributes attrs = mapper.getDeserializationConfig().getAttributes().withSharedAttribute(POOL_KEY, pool);\n+        String content = \"{\\\"data\\\":[1,2,3,4,5]}\";\n+        CustomResolutionWrapper wrapper = mapper.reader(CustomResolutionWrapper.class).with(attrs).readValue(content);\n+        assertFalse(wrapper.data.isEmpty());\n+        for (WithCustomResolution ob : wrapper.data) {\n+            assertSame(pool.get(ob.id), ob);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     FAIL_ON_EMPTY_BEANS(true),\n \n     /**\n+     * Feature that determines what happens when a direct self-reference\n+     * is detected by a POJO (and no Object Id handling is enabled for it):\n+     * either a {@link JsonMappingException} is\n+     * thrown (if true), or reference is normally processed (false).\n+     *<p>\n+     * Feature is enabled by default.\n+     *\n+     * @since 2.4\n+     */\n+    FAIL_ON_SELF_REFERENCES(true),\n+    \n+    /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n      * to add additional information about\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeIdResolver.java\n  * for converting between java types and type id included in JSON content.\n  * In simplest cases this can be a simple class with static mapping between\n  * type names and matching classes.\n+ *<p>\n+ * NOTE: since 2.4, applicable to properties as well (should have been long time\n+ *  ago, but problem only found then)\n  */\n-@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @JacksonAnnotation\n public @interface JsonTypeIdResolver\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonTypeResolver.java\n  * used for handling serialization and deserialization of type information,\n  * needed for handling of polymorphic types (or sometimes just for linking\n  * abstract types to concrete types)\n+ *<p>\n+ * NOTE: since 2.4, applicable to properties as well (should have been long time\n+ *  ago, but problem only found then)\n  */\n-@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n @Retention(RetentionPolicy.RUNTIME)\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonTypeResolver\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             }\n             return true;\n         }\n-    \n+        if (type == boolean.class || type == Boolean.class) {\n+            if (isCreator || isVisible) {\n+                creators.addBooleanCreator(ctor);\n+            }\n+            return true;\n+        }\n         // Delegating Creator ok iff it has @JsonCreator (etc)\n         if (isCreator) {\n             creators.addDelegatingCreator(ctor, null);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    @SuppressWarnings(\"resource\")\n     protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n     {\n-        final String idPropName = _objectIdReader.propertyName.getSimpleName();\n-        // First, the simple case: we point to the Object Id property\n-        if (idPropName.equals(jp.getCurrentName())\n-                // 05-Aug-2013, tatu: Or might point to a native Object Id\n-                || jp.canReadObjectId()) {\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        // otherwise need to reorder things\n-        TokenBuffer tmpBuffer = new TokenBuffer(jp);\n-        TokenBuffer mergedBuffer = null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // when we match the id property, can start merging\n-            if (mergedBuffer == null) {\n-                if (idPropName.equals(propName)) {\n-                    mergedBuffer = new TokenBuffer(jp);\n-                    mergedBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    mergedBuffer.copyCurrentStructure(jp);\n-                    mergedBuffer.append(tmpBuffer);\n-                    tmpBuffer = null;\n-                } else {\n-                    tmpBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    tmpBuffer.copyCurrentStructure(jp);\n-                }\n-            } else {\n-                mergedBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                mergedBuffer.copyCurrentStructure(jp);\n-            }\n-        }\n-        // note: we really should get merged buffer (and if not, that is likely error), but\n-        // for now let's allow missing case as well. Will be caught be a later stage...\n-        TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer;\n-        buffer.writeEndObject();\n-        // important: need to advance to point to first FIELD_NAME:\n-        JsonParser mergedParser = buffer.asParser();\n-        mergedParser.nextToken();\n-        return deserializeFromObject(mergedParser, ctxt);\n+        return deserializeFromObject(jp, ctxt);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            _handleSelfReference(bean, ser);\n+            // three choices: exception; handled by call; or pass-through\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n         }\n         jgen.writeFieldName(_name);\n         if (_typeSerializer == null) {\n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            _handleSelfReference(bean, ser);\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n         }\n         if (_typeSerializer == null) {\n             ser.serialize(value, jgen, prov);\n         return _field.get(bean);\n     }\n \n-    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException {\n-        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n-         *    object id; this may be the case for BeanSerializers at least.\n-         */\n-        if (ser.usesObjectId()) { return; }\n-        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n-    }\n-\n-    @Override\n-    public String toString()\n-    {\n+    /**\n+     * Method called to handle a direct self-reference through this property.\n+     * Method can choose to indicate an error by throwing {@link JsonMappingException};\n+     * fully handle serialization (and return true); or indicate that it should be\n+     * serialized normally (return false).\n+     *<p>\n+     * Default implementation will throw {@link JsonMappingException} if\n+     * {@link SerializationFeature.FAIL_ON_SELF_REFERENCES} is enabled;\n+     * or return <code>false</code> if it is disabled.\n+     * \n+     * @return True if method fully handled self-referential value; false if not (caller\n+     *    is to handle it) or {@link JsonMappingException} if there is no way handle it\n+     */\n+    protected boolean _handleSelfReference(Object bean, JsonGenerator jgen, SerializerProvider prov, JsonSerializer<?> ser)\n+            throws JsonMappingException {\n+        if (prov.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES)\n+                && !ser.usesObjectId()) {\n+            // 05-Feb-2013, tatu: Usually a problem, but NOT if we are handling\n+            //    object id; this may be the case for BeanSerializers at least.\n+            // 13-Feb-2014, tatu: another possible ok case: custom serializer (something\n+            //   OTHER than {@link BeanSerializerBase}\n+            if (ser instanceof BeanSerializerBase) {\n+                throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n         StringBuilder sb = new StringBuilder(40);\n         sb.append(\"property '\").append(getName()).append(\"' (\");\n         if (_accessorMethod != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n-        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n+        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n+        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n             contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n         }\n         // and if not JAXB collection/array with annotations, maybe regular type info?\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n         }\n         // For non-nulls, first: simple check for direct cycles\n         if (value == bean) {\n-            _handleSelfReference(bean, ser);\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n         }\n \n         // note: must verify we are using unwrapping serializer; if not, will write field name\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n      */\n     static class BooleanConstructorBean {\n         Boolean b;\n-        @JsonCreator protected BooleanConstructorBean(Boolean b) {\n+        protected BooleanConstructorBean(Boolean b) {\n             this.b = b;\n         }\n     }\n \n     static class BooleanConstructorBean2 {\n         boolean b;\n-        @JsonCreator protected BooleanConstructorBean2(boolean b) {\n+        protected BooleanConstructorBean2(boolean b) {\n             this.b = b;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n package com.fasterxml.jackson.databind.deser;\n \n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.databind.*;\n \n /**\n     static class StringLink extends GenericLink<String> {\n     }\n \n+    static class Selfie405 {\n+        public int id;\n+\n+        @JsonIgnoreProperties({ \"parent\" })\n+        public Selfie405 parent;\n+        \n+        public Selfie405(int id) { this.id = id; }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     public void testLinked() throws Exception\n     {\n-        Bean first = new ObjectMapper().readValue\n+        Bean first = MAPPER.readValue\n             (\"{\\\"name\\\":\\\"first\\\", \\\"next\\\": { \"\n              +\" \\\"name\\\":\\\"last\\\", \\\"next\\\" : null }}\",\n              Bean.class);\n \n     public void testLinkedGeneric() throws Exception\n     {\n-        StringLink link = new ObjectMapper().readValue\n-            (\"{\\\"next\\\":null}\", StringLink.class);\n+        StringLink link = MAPPER.readValue(\"{\\\"next\\\":null}\", StringLink.class);\n         assertNotNull(link);\n         assertNull(link.next);\n     }\n \n     public void testCycleWith2Classes() throws Exception\n     {\n-        LinkA a = new ObjectMapper().readValue(\"{\\\"next\\\":{\\\"a\\\":null}}\", LinkA.class);\n+        LinkA a = MAPPER.readValue(\"{\\\"next\\\":{\\\"a\\\":null}}\", LinkA.class);\n         assertNotNull(a.next);\n         LinkB b = a.next;\n         assertNull(b.a);\n     }\n+\n+    // [Issue#405]: Should be possible to ignore cyclic ref\n+    public void testIgnoredCycle() throws Exception\n+    {\n+        Selfie405 self1 = new Selfie405(1);\n+        self1.parent = self1;\n+\n+        // First: exception with default settings:\n+        assertTrue(MAPPER.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES));\n+        try {\n+            MAPPER.writeValueAsString(self1);\n+            fail(\"Should fail with direct self-ref\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Direct self-reference\");\n+        }\n+        \n+        ObjectWriter w = MAPPER.writer()\n+                .without(SerializationFeature.FAIL_ON_SELF_REFERENCES);\n+        String json = w.writeValueAsString(self1);\n+        assertNotNull(json);\n+        assertEquals(aposToQuotes(\"{'id':1,'parent':{'id':1}}\"), json);\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n {\n     @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_OBJECT)\n     @JsonTypeIdResolver(CustomResolver.class)\n-    static class CustomBean {\n+    static abstract class CustomBean { }\n+\n+    static class CustomBeanImpl extends CustomBean {\n         public int x;\n         \n-        public CustomBean() { }\n-        public CustomBean(int x) { this.x = x; }\n+        public CustomBeanImpl() { }\n+        public CustomBeanImpl(int x) { this.x = x; }\n     }\n-    \n-    static class CustomResolver implements TypeIdResolver\n-    {\n+\n+    static class ExtBeanWrapper {\n+        @JsonTypeInfo(use=Id.CUSTOM, include=As.EXTERNAL_PROPERTY, property=\"type\")\n+        @JsonTypeIdResolver(ExtResolver.class)\n+        public ExtBean value;\n+    }\n+\n+    static class CustomResolver extends CustomResolverBase {\n+        // yes, static: just for test purposes, not real use\n         static List<JavaType> initTypes;\n \n-        public CustomResolver() { }\n-        \n-        @Override\n-        public Id getMechanism() {\n-            return Id.CUSTOM;\n+        public CustomResolver() {\n+            super(CustomBean.class, CustomBeanImpl.class);\n         }\n \n         @Override\n-        public String idFromValue(Object value)\n-        {\n-            if (value.getClass() == CustomBean.class) {\n+        public void init(JavaType baseType) {\n+            if (initTypes != null) {\n+                initTypes.add(baseType);\n+            }\n+        }\n+    }\n+    \n+    static abstract class ExtBean { }\n+\n+    static class ExtBeanImpl extends ExtBean {\n+        public int y;\n+        \n+        public ExtBeanImpl() { }\n+        public ExtBeanImpl(int y) { this.y = y; }\n+    }\n+    \n+    static class ExtResolver extends CustomResolverBase {\n+        public ExtResolver() {\n+            super(ExtBean.class, ExtBeanImpl.class);\n+        }\n+    }\n+\n+    static class CustomResolverBase implements TypeIdResolver\n+    {\n+        protected final Class<?> superType;\n+        protected final Class<?> subType;\n+\n+        public CustomResolverBase(Class<?> baseType, Class<?> implType) {\n+            superType = baseType;\n+            subType = implType;\n+        }\n+\n+        @Override public Id getMechanism() { return Id.CUSTOM; }\n+\n+        @Override public String idFromValue(Object value) {\n+            if (superType.isAssignableFrom(value.getClass())) {\n                 return \"*\";\n             }\n             return \"unknown\";\n         }\n \n         @Override\n-        public void init(JavaType baseType) {\n-            if (initTypes != null) {\n-                initTypes.add(baseType);\n-            }\n-        }\n+        public void init(JavaType baseType) { }\n \n         @Override\n         public JavaType typeFromId(String id)\n         {\n             if (\"*\".equals(id)) {\n-                return TypeFactory.defaultInstance().constructType(CustomBean.class);\n+                return TypeFactory.defaultInstance().constructType(subType);\n             }\n             return null;\n         }\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     // for [JACKSON-359]\n     public void testCustomTypeIdResolver() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         List<JavaType> types = new ArrayList<JavaType>();\n         CustomResolver.initTypes = types;\n-        String json = m.writeValueAsString(new CustomBean[] { new CustomBean(28) });\n+        String json = MAPPER.writeValueAsString(new CustomBean[] { new CustomBeanImpl(28) });\n         assertEquals(\"[{\\\"*\\\":{\\\"x\\\":28}}]\", json);\n         assertEquals(1, types.size());\n         assertEquals(CustomBean.class, types.get(0).getRawClass());\n \n         types = new ArrayList<JavaType>();\n         CustomResolver.initTypes = types;\n-        CustomBean[] result = m.readValue(json, CustomBean[].class);\n+        CustomBean[] result = MAPPER.readValue(json, CustomBean[].class);\n         assertNotNull(result);\n         assertEquals(1, result.length);\n-        assertEquals(28, result[0].x);\n+        assertEquals(28, ((CustomBeanImpl) result[0]).x);\n         assertEquals(1, types.size());\n         assertEquals(CustomBean.class, types.get(0).getRawClass());\n     }\n+\n+    public void testCustomWithExternal() throws Exception\n+    {\n+        ExtBeanWrapper w = new ExtBeanWrapper();\n+        w.value = new ExtBeanImpl(12);\n+\n+        String json = MAPPER.writeValueAsString(w);\n+\n+        ExtBeanWrapper out = MAPPER.readValue(json, ExtBeanWrapper.class);\n+        assertNotNull(out);\n+        \n+        assertEquals(12, ((ExtBeanImpl) out.value).y);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestVisibleExternalId.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestVisibleExternalId extends BaseMapTest\n+{\n+    // [Issue#408]\n+    static class ExternalBeanWithId\n+    {\n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"type\", visible=true)\n+        public ValueBean bean;\n+\n+        public ExternalBeanWithId() { }\n+        public ExternalBeanWithId(int v) {\n+            bean = new ValueBean(v);\n+        }\n+    }\n+\n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n+    }\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n+    // [Issue#408]\n+    public void testVisibleTypeId() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new ExternalBeanWithId(3));\n+        ExternalBeanWithId result = MAPPER.readValue(json, ExternalBeanWithId.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        assertEquals(3, result.bean.value);\n+    }\n+}", "timestamp": 1392852922, "metainfo": ""}