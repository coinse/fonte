{"sha": "47b911dd10c8495fffed321b13951dbd68bfc78f", "log": "Merge branch 'master' of https://github.com/FasterXML/jackson-databind  Conflicts: \tsrc/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n  * contextualization.\n  */\n public abstract class JsonSerializer<T>\n+    implements JsonFormatVisitable // since 2.1\n {\n     /*\n     /**********************************************************\n     public JsonSerializer<?> getDelegatee() {\n         return null;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Default JsonFormatVisitable implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default implementation simply calls {@link JsonFormatVisitorWrapper#expectAnyFormat(JavaType)}.\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType type)\n+        throws JsonMappingException\n+    {\n+        visitor.expectAnyFormat(type);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n //            TimeZone.getDefault()\n             TimeZone.getTimeZone(\"GMT\"),\n             Base64Variants.getDefaultVariant() // 2.1\n-            );\n+    );\n     \n     /*\n     /**********************************************************\n         _serializationConfig = _serializationConfig.withFilters(filterProvider);\n     }\n \n+    /**\n+     * Method that will configure default {@link Base64Variant} that\n+     * <code>byte[]</code> serializers and deserializers will use.\n+     * \n+     * @param v Base64 variant to use\n+     * \n+     * @returns This mapper, for convenience to allow chaining\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectMapper setBase64Variant(Base64Variant v) {\n+        _serializationConfig = _serializationConfig.with(v);\n+        _deserializationConfig = _deserializationConfig.with(v);\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Configuration, other\n     public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n         return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n     }\n-    \n-    /**\n-     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n-     * instance for specified class.\n+\n+    /**\n+     * Method for visiting type hierarchy for given type, using specified visitor.\n+     *<p>\n+     * This method can be used for things like\n+     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n+     * instance for specified type.\n      *\n-     * @param javaType The class to generate schema for\n-     */\n-    public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n-    \tif (javaType == null) {\n-    \t\tthrow new IllegalArgumentException(\"class must be provided\");\n+     * @param type Type to generate schema for (possibly with generic signature)\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n+        throws JsonMappingException\n+    {\n+        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n+    }\n+    \n+    /**\n+     * Method for visiting type hierarchy for given type, using specified visitor.\n+     *<p>\n+     * This method can be used for things like\n+     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n+     * instance for specified type.\n+     *\n+     * @param type Type to generate schema for (possibly with generic signature)\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n+        throws JsonMappingException\n+    {\n+    \tif (type == null) {\n+    \t    throw new IllegalArgumentException(\"type must be provided\");\n     \t}\n-    \t\n     \tif (visitor == null) {\n-    \t\treturn;\n+    \t    return;\n     \t}\n     \tDefaultSerializerProvider provider = _serializerProvider(getSerializationConfig());\n         visitor.setProvider(provider);\n-    \tprovider.acceptJsonFormatVisitor(javaType, visitor);\n+    \tprovider.acceptJsonFormatVisitor(type, visitor);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n \n     public ObjectWriter with(TimeZone tz) {\n         SerializationConfig newConfig = _config.with(tz);\n+        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that uses specified default\n+     * {@link Base64Variant} for base64 encoding\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectWriter with(Base64Variant b64variant) {\n+        SerializationConfig newConfig = _config.with(b64variant);\n         return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n package com.fasterxml.jackson.databind.jsonFormatVisitors;\n \n-\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n \n /**\n  * Marker interface for schema-aware serializers.\n {\n     /**\n      * Get the representation of the schema to which this serializer will conform.\n-     * @param typeHint TODO\n+     * @param typeHint Type of element (entity like property) being visited\n      *\n      * @returns <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n      */\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint);\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWithSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWithSerializerProvider.java\n \n /**\n  * @author jphelan\n- *\n  */\n public interface JsonFormatVisitorWithSerializerProvider {\n-\n-\tpublic SerializerProvider getProvider();\n-\tpublic abstract void setProvider(SerializerProvider provider);\n+    public SerializerProvider getProvider();\n+    public abstract void setProvider(SerializerProvider provider);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n \n import com.fasterxml.jackson.databind.JavaType;\n \n-public interface JsonFormatVisitorWrapper extends JsonFormatVisitorWithSerializerProvider{\n-\n-\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType);\n-\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType);\n-\tpublic JsonStringFormatVisitor expectStringFormat(JavaType convertedType);\n-\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType);\n-\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType);\n-\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType);\n-\tpublic JsonNullFormatVisitor expectNullFormat(JavaType convertedType);\n-\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType);\n-\t\n+public interface JsonFormatVisitorWrapper extends JsonFormatVisitorWithSerializerProvider\n+{\n+    public JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType);\n+    public JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType);\n+    public JsonStringFormatVisitor expectStringFormat(JavaType convertedType);\n+    public JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType);\n+    public JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType);\n+    public JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType);\n+    public JsonNullFormatVisitor expectNullFormat(JavaType convertedType);\n+    public JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n  * Interface that defines API for filter objects use (as configured\n  * using {@link com.fasterxml.jackson.annotation.JsonFilter})\n  * for filtering bean properties to serialize.\n+ *<p>\n+ * Note that Jackson 2.1 added two new methods -- as a result, it is\n+ * strongly recommended that custom implementations extend\n+ * {@link com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter},\n+ * to avoid backwards compatibility issues in future.\n  */\n public interface BeanPropertyFilter\n {\n     /**\n      * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n      * form the given property exist within the parent, or root, schema. Filters can omit\n-     * adding the property to the node, or choose the form of the schema value for the property\n+     * adding the property to the node, or choose the form of the schema value for the property.\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(propertiesNode, provider);\n+     * }\n+     *</pre>\n      * \n      * @param writer Bean property serializer to use to create schema value\n      * @param propertiesNode Node which the given property would exist within\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      * \tprocessing\n-     *\n+     * \n+     * @since 2.1\n      */\n     public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode,\n-    \t\tSerializerProvider provider);\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n     \n     /**\n      * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n      * form the given property exist within the parent, or root, schema. Filters can omit\n      * adding the property to the node, or choose the form of the schema value for the property\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(objectVisitor, provider);\n+     * }\n+     *</pre>\n      * \n      * @param writer Bean property serializer to use to create schema value\n      * @param objectVisitor JsonObjectFormatVisitor which should be aware of \n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      * \tprocessing\n      * \n+     * @since 2.1\n      */\n     public void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor,\n-    \t\tSerializerProvider provider);\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Annotations;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n+\n+    /**\n+     *<p>\n+     * NOTE: due to introspection, this is a <b>slow</b> method to call\n+     * and should never be called during actual serialization or filtering\n+     * of the property. Rather it is needed for traversal needed for things\n+     * like constructing JSON Schema instances.\n+     * \n+     * @since 2.1\n+     */\n+    protected boolean isRequired(AnnotationIntrospector intr)\n+    {\n+        Boolean value = intr.hasRequiredMarker(_member);\n+        return (value == null) ? false : value.booleanValue();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Support for JsonFormatVisitable\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to handle appropriate type-specific visiting\n+     * over logical property this writer handles.\n+     * \n+     * @param objectVisitor ObjectVisitor which can receive the property\n+     * \n+     * @since 2.1\n+     */\n+    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n+        throws JsonMappingException\n+    {\n+        if (isRequired(objectVisitor.getProvider().getAnnotationIntrospector())) {\n+            objectVisitor.property(this); \n+        } else {\n+            objectVisitor.optionalProperty(this);\n+        }\n+    }\n+\n+    /**\n+     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n+     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n+     * \n+     * @param propertiesNode Node which the given property would exist within\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     *  processing\n+     *  \n+     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n+     * \n+     * @since 2.1\n+     */\n+    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JavaType propType = getSerializationType();\n+        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n+        JsonNode schemaNode;\n+        // Maybe it already has annotated/statically configured serializer?\n+        JsonSerializer<Object> ser = getSerializer();\n+        if (ser == null) { // nope\n+            Class<?> serType = getRawSerializationType();\n+            if (serType == null) {\n+                serType = getPropertyType();\n+            }\n+            ser = provider.findValueSerializer(serType, this);\n+        }\n+        boolean isOptional = !isRequired(provider.getAnnotationIntrospector());\n+        if (ser instanceof SchemaAware) {\n+            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n+        } else {  \n+            schemaNode = JsonSchema.getDefaultSchemaNode(); \n+        }\n+        propertiesNode.put(getName(), schemaNode);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n         /* no need for embedded type information for JSON schema generation (all\n          * type information it needs is accessible via \"untyped\" serializer)\n          */\n-        JsonSerializer<Object> ser = findValueSerializer(javaType, null);\n-        if (ser instanceof JsonFormatVisitable) {\n-        \t((JsonFormatVisitable) ser).acceptJsonFormatVisitor(visitor, javaType);\n-        } else {\n-        \tvisitor.expectAnyFormat(javaType);\n-        }\n+        findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n-import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n \n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n  * to determine whether to serialize property as is, or to filter it out.\n  */\n-public abstract class SimpleBeanPropertyFilter\n-    implements BeanPropertyFilter,\n-        java.io.Serializable // since 2.1\n+public abstract class SimpleBeanPropertyFilter implements BeanPropertyFilter\n {\n-    private static final long serialVersionUID = 612196544186875755L;\n-\n     /*\n     /**********************************************************\n     /* Life-cycle\n \n     /*\n     /**********************************************************\n+    /* Methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to determine whether property will be included\n+     * (if 'true' returned) or filtered out (if 'false' returned)\n+     */\n+    protected abstract boolean include(BeanPropertyWriter writer);\n+\n+    public void serializeAsField(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n+    {\n+        if (include(writer)) {\n+            writer.serializeAsField(bean, jgen, provider);\n+        }\n+    }\n+\n+    \n+    public void depositSchemaProperty(BeanPropertyWriter writer,\n+            ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(propertiesNode, provider);\n+        }\n+    }\n+\n+    public void depositSchemaProperty(BeanPropertyWriter writer,\n+            JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(objectVisitor);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Sub-classes\n     /**********************************************************\n      */\n     public static class FilterExceptFilter\n         extends SimpleBeanPropertyFilter\n     {\n-        // generated for 2.1.0\n-        private static final long serialVersionUID = -5409460444028386035L;\n-\n         /**\n          * Set of property names to serialize.\n          */\n             _propertiesToInclude = properties;\n         }\n \n-\t\tpublic void serializeAsField(Object bean, JsonGenerator jgen,\n-\t\t\t\tSerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-\t\t{\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\twriter.serializeAsField(bean, jgen, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-\t\t\t}\n-\t\t}\n+        @Override\n+        protected boolean include(BeanPropertyWriter writer) {\n+            return _propertiesToInclude.contains(writer.getName());\n+        }\n     }\n \n     /**\n     public static class SerializeExceptFilter\n         extends SimpleBeanPropertyFilter\n     {\n-        // generated for 2.1.0\n-        private static final long serialVersionUID = 6654996217449646999L;\n-\n         /**\n          * Set of property names to filter out.\n          */\n         protected final Set<String> _propertiesToExclude;\n \n-\t\tpublic SerializeExceptFilter(Set<String> properties) {\n-\t\t\t_propertiesToExclude = properties;\n-\t\t}\n+        public SerializeExceptFilter(Set<String> properties) {\n+            _propertiesToExclude = properties;\n+        }\n \n-\t\tpublic void serializeAsField(Object bean, JsonGenerator jgen,\n-\t\t\t\tSerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-\t\t{\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\twriter.serializeAsField(bean, jgen, provider);\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-\t\t\t}\n-\t\t}\n+        @Override\n+        protected boolean include(BeanPropertyWriter writer) {\n+            return !_propertiesToExclude.contains(writer.getName());\n+        }\n     }\n-}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n         ObjectNode propertiesNode = o.objectNode();\n         final BeanPropertyFilter filter;\n         if (_propertyFilterId != null) {\n-        \tfilter = findFilter(provider);\n-        } else {\n-        \tfilter = null;\n+            filter = findFilter(provider);\n+        } else {\n+            filter = null;\n         }\n         \t\t\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n-            if (filter != null) {\n-            \tfilter.depositSchemaProperty(prop, propertiesNode, provider);\n-            \t continue;\n-            }\n-            depositSchemaProperty(prop, propertiesNode, provider);\n+            if (filter == null) {\n+                prop.depositSchemaProperty(propertiesNode, provider);\n+            } else {\n+                filter.depositSchemaProperty(prop, propertiesNode, provider);\n+            }\n \n         }\n         o.put(\"properties\", propertiesNode);\n         return o;\n     }\n-\n-    /**\n-     * Determines if a bean property is required, as determined by\n-     * {@link com.fasterxml.jackson.databind.AnnotationIntrospector#hasRequiredMarker}.\n-     *<p>\n-     * \n-     * \n-     * @param prop the bean property.\n-     * @return true if the property is optional, false otherwise.\n-     */\n-    public static boolean isPropertyRequired(final BeanPropertyWriter prop, final SerializerProvider provider) {\n-        Boolean value = provider.getAnnotationIntrospector().hasRequiredMarker(prop.getMember());\n-        return (value == null) ? false : value.booleanValue();\n-    }\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n     \t//deposit your output format \n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n  \n         if (_propertyFilterId != null) {\n-            try {\n-                BeanPropertyFilter filter = findFilter(visitor.getProvider());\n-                for (int i = 0; i < _props.length; i++) {\n-                    BeanPropertyWriter prop = _props[i];\n-                    filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n-                }\n-                return;\n-            } catch (JsonMappingException e) {\n-                throw new IllegalStateException(\"Internal error: \"+e.getMessage(), e);\n-            }\n-        } \n-        \t\t\n-        for (int i = 0; i < _props.length; i++) {\n-            BeanPropertyWriter prop = _props[i];\n-            BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);\n-        }\n-    }\n-\n-    \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n-     * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param propertiesNode Node which the given property would exist within\n-     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n-     * \tprocessing\n-     * \t\n-     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider)\n-    {\n-        JavaType propType = writer.getSerializationType();\n-\n-        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n-        Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n-        JsonNode schemaNode;\n-        // Maybe it already has annotated/statically configured serializer?\n-        JsonSerializer<Object> ser = writer.getSerializer();\n-\n-        try {\n-            if (ser == null) { // nope\n-                Class<?> serType = writer.getRawSerializationType();\n-                if (serType == null) {\n-                    serType = writer.getPropertyType();\n-                }\n-                ser = provider.findValueSerializer(serType, writer);\n-            }\n-            boolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n-            if (ser instanceof SchemaAware) {\n-                schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n-            } else {  \n-                schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            }\n-        } catch (JsonMappingException e) {\n-            schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            // TODO: handle in better way (why not throw?)\n-        }\n-        propertiesNode.put(writer.getName(), schemaNode);\n-    }\n-    \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the \n-     *  given {@link JsonObjectFormatVisitor}.\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param objectVisitor ObjectVisitor which cab receive the property\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor) {\n-        if (isPropertyRequired(writer, objectVisitor.getProvider())) {\n-            objectVisitor.property(writer); \n-        } else {\n-            objectVisitor.optionalProperty(writer);\n+            BeanPropertyFilter filter = findFilter(visitor.getProvider());\n+            for (int i = 0; i < _props.length; i++) {\n+                filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());\n+            }\n+        } else {\n+            for (int i = 0; i < _props.length; i++) {\n+                _props[i].depositSchemaProperty(objectVisitor);\n+            }\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n         }\n         return o;\n     }\n-    \n-    @SuppressWarnings(\"unchecked\")\n+\n+    /* !!! 03-Oct-2012, tatu: This is total mess, and partly incorrect. MUST be\n+     *   rewritten in near future, to work.\n+     */\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n-        if (typeHint instanceof ParameterizedType) {\n-            Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n-            if (typeArgs.length == 2) {\n-                JavaType enumType = visitor.getProvider().constructType(typeArgs[0]);\n-                JavaType valueType = visitor.getProvider().constructType(typeArgs[1]);\n-//                ObjectNode propsNode = JsonNodeFactory.instance.objectNode();\n-                Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n-                for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n-                \tJsonSerializer<Object> ser;\n-                \tString name = visitor.getProvider().getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue);\n-                \ttry {\n-                \t\tser = visitor.getProvider().findValueSerializer(valueType.getRawClass(), _property);\n-                \t\tif (ser instanceof JsonFormatVisitable)  {\n-                \t\t\tobjectVisitor.property(name, (JsonFormatVisitable) ser, valueType);\n-                \t\t} \n-                \t\tcontinue;\n-                \t} catch (JsonMappingException e) {\n-                \t\t//TODO: log error\n-                \t}\n-                \tobjectVisitor.property(name);\n-                }\n-            }\n+    \t/*\n+        JavaType enumType = typeHint.containedType(0);\n+    \tif (enumType == null) {\n+    \t    enumType = visitor.getProvider().constructType(Object.class);\n+    \t}\n+    \t*/\n+        JavaType valueType = typeHint.containedType(1);\n+    \tif (valueType == null) {\n+    \t    valueType = visitor.getProvider().constructType(Object.class);\n+    \t}\n+        JsonSerializer<Object> ser = _valueSerializer;\n+//        Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n+        for (Map.Entry<?,SerializedString> entry : _keyEnums.internalMap().entrySet()) {\n+            String name = entry.getValue().getValue();\n+            // should all have the same type, so:\n+            if (ser == null) {\n+                ser = visitor.getProvider().findValueSerializer(entry.getKey().getClass(), _property);\n+            }\n+            objectVisitor.property(name, (JsonFormatVisitable) ser, valueType);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-    {\n-    \tif (_valueSerializer instanceof JsonFormatVisitable) {\n-    \t\t((JsonFormatVisitable) _valueSerializer).acceptJsonFormatVisitor(visitor, null); \n-    \t} else {\n-    \t\tvisitor.expectAnyFormat(typeHint);\n+        throws JsonMappingException\n+    {\n+        if (_valueSerializer != null) {\n+            _valueSerializer.acceptJsonFormatVisitor(visitor, null); \n+        } else {\n+            visitor.expectAnyFormat(typeHint);\n     \t}\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n-        if (_delegateSerializer instanceof JsonFormatVisitable) {\n-            ((JsonFormatVisitable) _delegateSerializer).acceptJsonFormatVisitor(visitor, typeHint);\n-            return;\n-        }\n-        super.acceptJsonFormatVisitor(visitor, typeHint);\n+        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n+         *    properly... but for now, try this:\n+         */\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n      * overriden by custom serializers.\n      */\n //  @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) { \n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n+    {\n     \tvisitor.expectAnyFormat(typeHint);\n     }\n             \n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n     public Collection<SerializedString> values() {\n         return _values.values();\n     }\n+\n+    /**\n+     * Method used for serialization and introspection by core Jackson\n+     * code.\n+     * \n+     * @since 2.1\n+     */\n+    public EnumMap<?,SerializedString> internalMap() {\n+        return _values;\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestTreeWithType.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestTreeWithType extends BaseMapTest\n+{\n+    public static class Foo {\n+        public String bar;\n+\n+        public Foo() { }\n+\n+        public Foo(String bar) {\n+            this.bar = bar;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+\n+    public void testValueAsStringWithoutDefaultTyping() throws Exception {\n+\n+        Foo foo = new Foo(\"baz\");\n+        String json = mapper.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueAsStringWithDefaultTyping() throws Exception {\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        String json = mapper.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testReadTreeWithDefaultTyping() throws Exception\n+    {\n+        final String CLASS = Foo.class.getName();\n+\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL,\n+                JsonTypeInfo.As.PROPERTY);\n+        String json = \"{\\\"@class\\\":\\\"\"+CLASS+\"\\\",\\\"bar\\\":\\\"baz\\\"}\";\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), \"baz\");\n+    }\n+\n+    public void testValueToTreeWithoutDefaultTyping() throws Exception {\n+\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = mapper.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueToTreeWithDefaultTyping() throws Exception {\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = mapper.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     public static class Pair\n         extends AnnotationIntrospectorPair\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         @Deprecated\n         public Pair(AnnotationIntrospector p, AnnotationIntrospector s) {\n             super(p, s);\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n+    implements java.io.Serializable // since 2.1\n {\n+    // for 2.1.0\n+    private static final long serialVersionUID = -4227480407273773599L;\n+\n     /**\n      * Set of features enabled; actual type (kind of features)\n      * depends on sub-classes.\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * Constructor only needed for JDK (de)serialization\n+     */\n+    DeserializationConfig() {\n+        super();\n+        _deserFeatures = 0;\n+        _problemHandlers = null;\n+        _nodeFactory = null;\n+    }\n+    \n+    // for unit tests only:\n+    protected BaseSettings getBaseSettings() { return _base; }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n  */\n public abstract class JavaType\n     extends ResolvedType\n+    implements java.io.Serializable\n {\n+    // for 2.1.0:\n+    private static final long serialVersionUID = -5321897246493723158L;\n+\n     /**\n      * This is the nominal type-erased Class that would be close to the\n      * type represented (but not exactly type, due to type erasure: type\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n public class MappingJsonFactory\n     extends JsonFactory\n {\n+    // generated for Jackson 2.1.0\n+    private static final long serialVersionUID = -6744103724013275513L;\n+\n     public MappingJsonFactory()\n     {\n         this(null);\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n  */\n public final class SerializationConfig\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n+    implements java.io.Serializable // since 2.1\n {\n+    // for 2.1.0:\n+    private static final long serialVersionUID = 8849092838541724233L;\n+\n     /**\n      * Set of features enabled; actual type (kind of features)\n      * depends on sub-classes.\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n  * be freely shared and used without synchronization.\n  */\n public final class BaseSettings\n+    implements java.io.Serializable // since 2.1\n {\n+    // for 2.1.0:\n+    private static final long serialVersionUID = 4939673998947122190L;\n+\n     /*\n     /**********************************************************\n     /* Configuration settings; introspection, related\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n         _base = src._base;\n         _mapperFeatures = src._mapperFeatures;\n     }\n+\n+    /**\n+     * Constructor only used for JDK deserialization\n+     * \n+     * @since 2.1\n+     */\n+    MapperConfig() {\n+        _base = null;\n+        _mapperFeatures = 0;\n+    }\n     \n     /**\n      * Method that calculates bit set (flags) of all features that\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n         _rootName = src._rootName;\n         _view = src._view;\n     }\n+\n+    /**\n+     * Constructor only used for JDK deserialization\n+     * \n+     * @since 2.1\n+     */\n+    protected MapperConfigBase() {\n+        super();\n+        _mixInAnnotations = null;\n+        _subtypeResolver = null;\n+        _rootName = null;\n+        _view = null;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/SerializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/SerializerFactoryConfig.java\n  * {@link SerializerFactory} implementations.\n  */\n public final class SerializerFactoryConfig\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n     /**\n      * Constant for empty <code>Serializers</code> array (which by definition\n      * is stateless and reusable)\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n  * @author tatu\n  */\n public class OptionalHandlerFactory\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = -7103336512296456640L;\n+\n     /* 1.6.1+ To make 2 main \"optional\" handler groups (javax.xml.stream)\n      * more dynamic, we better only figure out handlers completely dynamically, if and\n      * when they are needed. To do this we need to assume package prefixes.\n      */\n-\n     private final static String PACKAGE_PREFIX_JAVAX_XML = \"javax.xml.\";\n \n     private final static String SERIALIZERS_FOR_JAVAX_XML = \"com.fasterxml.jackson.databind.ext.CoreXMLSerializers\";\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n  * \n  * @since 2.1\n  */\n-public class AnnotationIntrospectorPair extends AnnotationIntrospector\n+public class AnnotationIntrospectorPair\n+    extends AnnotationIntrospector\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     protected final AnnotationIntrospector _primary, _secondary;\n \n     public AnnotationIntrospectorPair(AnnotationIntrospector p, AnnotationIntrospector s)\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n \n public class BasicClassIntrospector\n     extends ClassIntrospector\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /* We keep a small set of pre-constructed descriptions to use for\n      * common non-structured values, such as Numbers and Strings.\n      * This is strictly performance optimization to reduce what is\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n  */\n public class JacksonAnnotationIntrospector\n     extends AnnotationIntrospector\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     public JacksonAnnotationIntrospector() { }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n  */\n public abstract class NopAnnotationIntrospector\n     extends AnnotationIntrospector\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Static immutable and shareable instance that can be used as\n      * \"null\" introspector: one that never finds any annotation\n      * information.\n      */\n     public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector() {\n+        private static final long serialVersionUID = 1L;\n+\n         @Override\n         public Version version() {\n             return DatabindVersion.instance.version();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n         fieldVisibility = Visibility.PUBLIC_ONLY\n     )\n     public static class Std\n-        implements VisibilityChecker<Std>\n+        implements VisibilityChecker<Std>,\n+            java.io.Serializable\n     {\n+        private static final long serialVersionUID = -7073939237187922755L;\n+\n         /**\n          * This is the canonical base instance, configured with default\n          * visibility values\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n  * @author tatu\n  */\n public final class NamedType\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     protected final Class<?> _class;\n     protected final int _hashCode;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n  * concrete implementations; however, only works with abstract types (since\n  * this is only called for abstract types)\n  */\n-public class SimpleAbstractTypeResolver extends AbstractTypeResolver\n+public class SimpleAbstractTypeResolver\n+    extends AbstractTypeResolver\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 8635483102371490919L;\n+\n     /**\n      * Mappings from super types to subtypes\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n  * Unlike {@link SimpleSerializers}, this class does not currently support generic mappings;\n  * all mappings must be to exact declared deserialization type.\n  */\n-public class SimpleDeserializers implements Deserializers\n+public class SimpleDeserializers\n+   implements Deserializers, java.io.Serializable\n {\n+    private static final long serialVersionUID = -3006673354353448880L;\n+\n     protected HashMap<ClassKey,JsonDeserializer<?>> _classMappings = null;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n  * Unlike {@link SimpleSerializers}, this class does not currently support generic mappings;\n  * all mappings must be to exact declared deserialization type.\n  */\n-public class SimpleKeyDeserializers implements KeyDeserializers\n+public class SimpleKeyDeserializers\n+    implements KeyDeserializers, java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = -6786398737835438187L;\n+\n     protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n  * of serializers and deserializers, and bean serializer\n  * and deserializer modifiers.\n  */\n-public class SimpleModule extends Module\n+public class SimpleModule\n+    extends Module\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 3132264350026957446L;\n+\n     protected final String _name;\n     protected final Version _version;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n  * is found first. As an example, handler for {@link CharSequence} would also be used\n  * serializing {@link StringBuilder} instances, unless a direct mapping was found.\n  */\n-public class SimpleSerializers extends Serializers.Base\n+public class SimpleSerializers\n+    extends Serializers.Base\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 8531646511998456779L;\n+\n     /**\n      * Class-based mappings that are used both for exact and\n      * sub-class matches.\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n \n public class SimpleValueInstantiators\n     extends ValueInstantiators.Base\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = -8929386427526115130L;\n+\n     /**\n      * Mappings from raw (type-erased, i.e. non-generic) types\n      * to matching {@link ValueInstantiator} instances.\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n  * to behavior of node types, mostly) is needed.\n  */\n public class JsonNodeFactory\n+    implements java.io.Serializable // since 2.1\n {\n+    // for 2.1:\n+    private static final long serialVersionUID = 2323165117839546871L;\n+\n     private final boolean _cfgBigDecimalExact;\n \n     private static final JsonNodeFactory decimalsNormalized\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n  */\n public abstract class BasicSerializerFactory\n     extends SerializerFactory\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = -1416617628045738132L;\n+\n     /*\n     /**********************************************************\n     /* Configuration, lookup tables/maps\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n public class BeanSerializerFactory\n     extends BasicSerializerFactory\n {\n+    private static final long serialVersionUID = -5348294866902611332L;\n+\n     /**\n      * Like {@link BasicSerializerFactory}, this factory is stateless, and\n      * thus a single shared global (== singleton) instance can be used\n      * without thread-safety issues.\n      */\n     public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n-\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n  * implementations must sub-class this class: {@link ObjectMapper}\n  * requires this type, not basic provider type.\n  */\n-public abstract class DefaultSerializerProvider extends SerializerProvider\n+public abstract class DefaultSerializerProvider\n+    extends SerializerProvider\n+    implements java.io.Serializable // since 2.1; only because ObjectWriter needs it\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* State, for non-blueprint instances: Object Id handling\n      * Per-serialization map Object Ids that have seen so far, iff\n      * Object Id handling is enabled.\n      */\n-    protected IdentityHashMap<Object, WritableObjectId> _seenObjectIds;\n-    \n-    protected ArrayList<ObjectIdGenerator<?>> _objectIdGenerators;\n+    protected transient IdentityHashMap<Object, WritableObjectId> _seenObjectIds;\n+    \n+    protected transient ArrayList<ObjectIdGenerator<?>> _objectIdGenerators;\n     \n     /*\n     /**********************************************************\n      */\n     public final static class Impl extends DefaultSerializerProvider\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public Impl() { super(); }\n \n         protected Impl(SerializerProvider src,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n             return !_propertiesToExclude.contains(writer.getName());\n         }\n     }\n-}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n  * Simple {@link FilterProvider} implementation that just stores\n  * direct id-to-filter mapping.\n  */\n-public class SimpleFilterProvider extends FilterProvider\n+public class SimpleFilterProvider\n+    extends FilterProvider\n+    implements java.io.Serializable // since 2.1\n {\n+    // generated for 2.1.0\n+    private static final long serialVersionUID = -2825494703774121220L;\n+\n     /**\n      * Mappings from ids to filters.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n public final class ArrayType\n     extends TypeBase\n {\n+    private static final long serialVersionUID = -6866628807166594553L;\n+\n     /**\n      * Type of elements in the array.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ClassKey.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ClassKey.java\n  * know what it is doing, if changing field values.\n  */\n public final class ClassKey\n-    implements Comparable<ClassKey>\n+    implements Comparable<ClassKey>,\n+        java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 1L;\n+\n     private String _className;\n \n     private Class<?> _class;\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n  */\n public class CollectionLikeType extends TypeBase\n {\n+    private static final long serialVersionUID = -2079769185110719683L;\n+\n     /**\n      * Type of elements in collection\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n public final class CollectionType\n     extends CollectionLikeType\n {\n+    private static final long serialVersionUID = 7218006718717444365L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n  */\n public class MapLikeType extends TypeBase\n {\n+    private static final long serialVersionUID = -4720638149668688793L;\n+\n     /**\n      * Type of keys of Map.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n  */\n public final class MapType extends MapLikeType\n {\n+    private static final long serialVersionUID = 2276544408153191774L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n public final class SimpleType\n     extends TypeBase\n {\n+    private static final long serialVersionUID = -800374828948534376L;\n+\n     /**\n      * Generic type arguments for this type.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n     extends JavaType\n     implements JsonSerializable\n {\n+    private static final long serialVersionUID = -3581199092426900829L;\n+\n     /**\n      * Lazily initialized external representation of the type\n      */\n-    volatile String _canonicalName;\n+    volatile transient String _canonicalName;\n \n     /**\n      * Main constructor to use by extending classes.\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public final class TypeFactory\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     private final static JavaType[] NO_TYPES = new JavaType[0];\n \n     /**\n      * actual generic types), we will use small cache to avoid repetitive\n      * resolution of core types\n      */\n-    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n+    protected final transient LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n     \n     /*\n      * Looks like construction of {@link JavaType} instances can be\n      * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n      * to its supertypes.\n      */\n-    protected HierarchicType _cachedHashMapType;\n+    protected transient HierarchicType _cachedHashMapType;\n \n     /**\n      * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n      * to its supertypes.\n      */\n-    protected HierarchicType _cachedArrayListType;\n+    protected transient HierarchicType _cachedArrayListType;\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n  * @author tatu\n  */\n public class TypeParser\n+    implements java.io.Serializable\n {\n-    final TypeFactory _factory;\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final TypeFactory _factory;\n         \n     public TypeParser(TypeFactory f) {\n         _factory = f;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n     \n     static class FactoryWithSchema extends JsonFactory\n     {\n+        private static final long serialVersionUID = 1L;\n         @Override\n         protected JsonParser _createJsonParser(Reader r, IOContext ctxt)\n             throws IOException, JsonParseException\n--- a/src/test/java/com/fasterxml/jackson/databind/TestGeneratorUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestGeneratorUsingMapper.java\n \n         final ObjectMapper mapper = new ObjectMapper();\n         final CharacterEscapes defaultCharacterEscapes = new CharacterEscapes() {\n+            private static final long serialVersionUID = 1L;\n+\n             @Override\n             public int[] getEscapeCodesForAscii() {\n                 return standardAsciiEscapesForJSON();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+ * Tests to verify that most core Jackson components can be serialized\n+ * using default JDK serialization: this feature is useful for some\n+ * platforms, such as Android, where memory management is handled\n+ * much more aggressively.\n+ */\n+public class TestJDKSerialization extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Individual objects\n+    /**********************************************************\n+     */\n+\n+    public void testConfigs() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[] base = jdkSerialize(mapper.getDeserializationConfig().getBaseSettings());\n+        assertNotNull(jdkDeserialize(base));\n+\n+        // first things first: underlying BaseSettings\n+        \n+        DeserializationConfig origDC = mapper.getDeserializationConfig();\n+        SerializationConfig origSC = mapper.getSerializationConfig();\n+        byte[] dcBytes = jdkSerialize(origDC);\n+        byte[] scBytes = jdkSerialize(origSC);\n+\n+        DeserializationConfig dc = jdkDeserialize(dcBytes);\n+        assertNotNull(dc);\n+        assertEquals(dc._deserFeatures, origDC._deserFeatures);\n+        SerializationConfig sc = jdkDeserialize(scBytes);\n+        assertNotNull(sc);\n+        assertEquals(sc._serFeatures, origSC._serFeatures);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n      */\n     static class MyEscapes extends CharacterEscapes\n     {\n-        \n+        private static final long serialVersionUID = 1L;\n+\n         private final int[] _asciiEscapes;\n \n         public MyEscapes() {\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestValueInstantiator.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueInstantiator.java\n         }\n     }\n     \n+    @SuppressWarnings(\"serial\")\n     static class MyModule extends SimpleModule\n     {\n         public MyModule(Class<?> cls, ValueInstantiator inst)\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n+@SuppressWarnings(\"serial\")\n public class TestBeanDeserializer extends BaseMapTest\n {\n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n     // Test to ensure we can override enum settings\n     static class LcEnumIntrospector extends JacksonAnnotationIntrospector\n     {\n+        private static final long serialVersionUID = 1L;\n         @Override\n         public String findEnumValue(Enum<?> value)\n         {\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         }\n     }\n     \n+    @SuppressWarnings(\"serial\")\n     protected static class CustomJsonSerializerFactory extends BeanSerializerFactory\n     {\n         public CustomJsonSerializerFactory() { super(null); }\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class TestSimpleModule extends BaseMapTest\n {\n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.*;\n \n+@SuppressWarnings(\"serial\")\n public class TestTypeModifiers extends BaseMapTest\n {\n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNodeFactoryConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNodeFactoryConfig.java\n     static class MyNodeFactory\n         extends JsonNodeFactory\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         @Override\n         public ObjectNode objectNode() { return new MyObjectNode(this); }\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n  * Unit tests for verifying that it is possible to configure\n  * construction of {@link BeanSerializer} instances.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestBeanSerializer extends BaseMapTest\n {\n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n         public String type = null;\n     }\n     \n+    @SuppressWarnings(\"serial\")\n     static class MyNullProvider extends DefaultSerializerProvider\n     {\n         public MyNullProvider() { super(); }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n \n     static class ForceArraysIntrospector extends JacksonAnnotationIntrospector\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         @Override\n         public JsonFormat.Value findFormat(Annotated a) {\n             return new JsonFormat.Value().withShape(JsonFormat.Shape.ARRAY);\n--- a/src/test/java/perf/ManualReadPerfWithMedia.java\n+++ b/src/test/java/perf/ManualReadPerfWithMedia.java\n \n     final static class NoFormatIntrospector extends JacksonAnnotationIntrospector\n     {\n+        private static final long serialVersionUID = 1L;\n         @Override\n         public JsonFormat.Value findFormat(Annotated a) { return null; }\n     }", "timestamp": 1349479837, "metainfo": ""}