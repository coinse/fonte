{"sha": "3013582891ea5a74632dcc77f95be02f918b4436", "log": "Simplified handling of primitive array deserializers", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n     /**\n      * Also special array deserializers for primitive array types.\n      */\n-    final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n-        = PrimitiveArrayDeserializers.getAll();\n+//    final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers = PrimitiveArrayDeserializers.getAll();\n     \n     /* We do some defaulting for abstract Map classes and\n      * interfaces, to avoid having to use exact types or annotations in\n                 config, beanDesc, elemTypeDeser, contentDeser);\n         if (deser == null) {\n             if (contentDeser == null) {\n-                // Maybe special array type, such as \"primitive\" arrays (int[] etc)\n-                deser = _arrayDeserializers.get(elemType);\n-                if (deser == null) {\n-                    if (elemType.isPrimitive()) { // sanity check\n-                        throw new IllegalArgumentException(\"Internal error: primitive type (\"+type+\") passed, no array deserializer found\");\n-                    }\n+                Class<?> raw = elemType.getRawClass();\n+                if (elemType.isPrimitive()) {\n+                    return PrimitiveArrayDeserializers.forType(raw);\n+                } else if (raw == String.class) {\n+                    return StringArrayDeserializer.instance;\n                 }\n             }\n             if (deser == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n-\n \n /**\n  * Container for deserializers used for instantiating \"primitive arrays\",\n  * arrays that contain non-object java primitive types.\n  */\n-public class PrimitiveArrayDeserializers\n+@SuppressWarnings(\"serial\")\n+public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>\n {\n-    HashMap<JavaType,JsonDeserializer<Object>> _allDeserializers;\n-\n-    final static PrimitiveArrayDeserializers instance = new PrimitiveArrayDeserializers();\n-\n-    protected PrimitiveArrayDeserializers()\n-    {\n-        _allDeserializers = new HashMap<JavaType,JsonDeserializer<Object>>();\n-        // note: we'll use component type as key, not array type\n-        add(boolean.class, new BooleanDeser());\n-\n-        /* ByteDeser is bit special, as it has 2 separate modes of operation;\n-         * one for String input (-> base64 input), the other for\n-         * numeric input\n-         */\n-        add(byte.class, new ByteDeser());\n-        add(short.class, new ShortDeser());\n-        add(int.class, new IntDeser());\n-        add(long.class, new LongDeser());\n-\n-        add(float.class, new FloatDeser());\n-        add(double.class, new DoubleDeser());\n-\n-        add(String.class, new StringArrayDeserializer());\n-        /* also: char[] is most likely only used with Strings; doesn't\n-         * seem to make sense to transfer as numbers\n-         */\n-        add(char.class, new CharDeser());\n-    }\n-\n-    public static HashMap<JavaType,JsonDeserializer<Object>> getAll()\n-    {\n-        return instance._allDeserializers;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void add(Class<?> cls, JsonDeserializer<?> deser)\n-    {\n-        /* Not super clean to use default TypeFactory in general, but\n-         * since primitive array types can't be modified for anything\n-         * useful, this should be ok:\n-         */\n-        _allDeserializers.put(TypeFactory.defaultInstance().constructType(cls),\n-                (JsonDeserializer<Object>) deser);\n-    }\n-\n+    protected PrimitiveArrayDeserializers(Class<T> cls) {\n+        super(cls);\n+    }\n+\n+    public static JsonDeserializer<?> forType(Class<?> rawType)\n+    {\n+        // Start with more common types...\n+        if (rawType == Integer.TYPE) {\n+            return IntDeser.instance;\n+        }\n+        if (rawType == Long.TYPE) {\n+            return LongDeser.instance;\n+        }\n+        \n+        if (rawType == Byte.TYPE) {\n+            return new ByteDeser();\n+        }\n+        if (rawType == Short.TYPE) {\n+            return new ShortDeser();\n+        }\n+        if (rawType == Float.TYPE) {\n+            return new FloatDeser();\n+        }\n+        if (rawType == Double.TYPE) {\n+            return new DoubleDeser();\n+        }\n+        if (rawType == Boolean.TYPE) {\n+            return new BooleanDeser();\n+        }\n+        if (rawType == Character.TYPE) {\n+            return new CharDeser();\n+        }\n+        throw new IllegalStateException();\n+    }\n+\n+    @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n          * for now this should be enough:\n          */\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n-    }\n-\n-    /*\n-    /********************************************************\n-    /* Intermediate base class\n-    /********************************************************\n-     */\n-    \n-    /**\n-     * Intermediate base class for primitive array deserializers\n-     */\n-    static abstract class Base<T> extends StdDeserializer<T>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected Base(Class<T> cls) {\n-            super(cls);\n-        }\n-\n-        @Override\n-        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n-        }\n     }\n     \n     /*\n \n     @JacksonStdImpl\n     final static class CharDeser\n-        extends Base<char[]>\n+        extends PrimitiveArrayDeserializers<char[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class BooleanDeser\n-        extends Base<boolean[]>\n+        extends PrimitiveArrayDeserializers<boolean[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n      */\n     @JacksonStdImpl\n     final static class ByteDeser\n-        extends Base<byte[]>\n+        extends PrimitiveArrayDeserializers<byte[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class ShortDeser\n-        extends Base<short[]>\n+        extends PrimitiveArrayDeserializers<short[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class IntDeser\n-        extends Base<int[]>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n+        extends PrimitiveArrayDeserializers<int[]>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static IntDeser instance = new IntDeser();\n+        \n         public IntDeser() { super(int[].class); }\n \n         @Override\n \n     @JacksonStdImpl\n     final static class LongDeser\n-        extends Base<long[]>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n+        extends PrimitiveArrayDeserializers<long[]>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static LongDeser instance = new LongDeser();\n+        \n         public LongDeser() { super(long[].class); }\n \n         @Override\n \n     @JacksonStdImpl\n     final static class FloatDeser\n-        extends Base<float[]>\n+        extends PrimitiveArrayDeserializers<float[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class DoubleDeser\n-        extends Base<double[]>\n+        extends PrimitiveArrayDeserializers<double[]>\n     {\n         private static final long serialVersionUID = 1L;\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n \n /**\n  * Separate implementation for serializing String arrays (instead of\n- * using {@link ObjectArraySerializer}. Used if (and only if) no custom\n- * value deserializers are used.\n+ * using {@link ObjectArrayDeserializer}.\n+ * Used if (and only if) no custom value deserializers are used.\n  */\n @JacksonStdImpl\n-final class StringArrayDeserializer\n+public final class StringArrayDeserializer\n     extends StdDeserializer<String[]>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = -4286917407100819199L;\n+    private static final long serialVersionUID = -7589512013334920693L;\n \n+    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n+    \n     /**\n      * Value serializer to use, if not the standard one (which is inlined)\n      */\n         return this;\n     }\n }\n-    ", "timestamp": 1366081964, "metainfo": ""}