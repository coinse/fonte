{"sha": "0e1e87827326aa785da225aa980d7429a9d562f7", "log": "Fix #88", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n     implements java.io.Serializable, // 2.1\n         java.lang.reflect.Type // 2.2\n {\n-    private static final long serialVersionUID = 6774285981275451126L;\n+    private static final long serialVersionUID = 1;\n \n     /**\n      * This is the nominal type-erased Class that would be close to the\n      */\n     protected final Class<?> _class;\n \n-    protected final int _hashCode;\n+    protected final int _hash;\n \n     /**\n      * Optional handler (codec) that can be attached to indicate \n             Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n         _class = raw;\n-        _hashCode = raw.getName().hashCode() + additionalHash;\n+        _hash = raw.getName().hashCode() + additionalHash;\n         _valueHandler = valueHandler;\n         _typeHandler = typeHandler;\n         _asStatic = asStatic;\n      * true if instantiation of this Type is given (type-erased) Class.\n      */\n     @Override\n-    public final boolean hasRawClass(Class<?> clz) {\n-        return _class == clz;\n-    }\n+    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n \n     @Override\n     public boolean isAbstract() {\n         /* 19-Feb-2010, tatus: Holy mackarel; primitive types\n          *    have 'abstract' flag set...\n          */\n-        if (_class.isPrimitive()) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isThrowable() {\n-        return Throwable.class.isAssignableFrom(_class);\n-    }\n+        return _class.isPrimitive();\n+    }\n+\n+    @Override\n+    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n \n     @Override\n     public boolean isArrayType() { return false; }\n      * \n      * @since 2.2\n      */\n-    public final boolean useStaticType() {\n-        return _asStatic;\n-    }\n+    public final boolean useStaticType() { return _asStatic; }\n     \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public boolean hasGenericTypes()\n-    {\n-        return containedTypeCount() > 0;\n-    }\n+    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n \n     @Override\n     public JavaType getKeyType() { return null; }\n     /**********************************************************\n      */\n \n-    protected void _assertSubclass(Class<?> subclass, Class<?> superClass)\n-    {\n+    protected void _assertSubclass(Class<?> subclass, Class<?> superClass) {\n         if (!_class.isAssignableFrom(subclass)) {\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" is not assignable to \"+_class.getName());\n         }\n     public abstract boolean equals(Object o);\n \n     @Override\n-    public final int hashCode() { return _hashCode; }\n+    public final int hashCode() { return _hash; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * to specify what kind of types (classes) default typing should\n      * be used for. It will only be used if no explicit type information\n      * is found, but this enumeration further limits subset of those types.\n+     *<p>\n+     * Since 2.4 there are special exceptions for JSON Tree model\n+     * types (sub-types of {@link TreeNode}: default typing is never\n+     * applied to them\n+     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n      */\n     public enum DefaultTyping {\n         /**\n          * properties with declared type of {@link java.lang.Object}\n          * or an abstract type (abstract class or interface).\n          * Note that this does <b>not</b> include array types.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         OBJECT_AND_NON_CONCRETE,\n \n          * Value that means that default typing will be used for\n          * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n          * plus all array types for them.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         NON_CONCRETE_AND_ARRAYS,\n         \n          * \"natural\" types (String, Boolean, Integer, Double), which\n          * can be correctly inferred from JSON; as well as for\n          * all arrays of non-final types.\n+         *<p>\n+         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n          */\n         NON_FINAL\n     }\n                 }\n                 // fall through\n             case OBJECT_AND_NON_CONCRETE:\n-                return (t.getRawClass() == Object.class) || !t.isConcrete();\n+                return (t.getRawClass() == Object.class) || !t.isConcrete()\n+                        // [Issue#88] Should not apply to JSON tree models:\n+                        || TreeNode.class.isAssignableFrom(t.getRawClass());\n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n-                return !t.isFinal(); // includes Object.class\n+                // [Issue#88] Should not apply to JSON tree models:\n+                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n             default:\n             //case JAVA_LANG_OBJECT:\n                 return (t.getRawClass() == Object.class);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n         }\n         Class<?> implClass = objectIdInfo.getGeneratorType();\n         JavaType idType;\n-    \tSettableBeanProperty idProp;\n+        SettableBeanProperty idProp;\n         ObjectIdGenerator<?> gen;\n \n         // Just one special case: Property-based generator is trickier\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n \n /**\n  * Default {@link TypeResolverBuilder} implementation.\n- *\n- * @author tatu\n  */\n public class StdTypeResolverBuilder\n     implements TypeResolverBuilder<StdTypeResolverBuilder>\n         return this;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n-        if (_idType == JsonTypeInfo.Id.NONE) {\n-            return null;\n-        }\n+        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n-        if (_idType == JsonTypeInfo.Id.NONE) {\n-            return null;\n-        }\n+        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n \n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n         \n      * (property name to use for type id when using \"as-property\" inclusion).\n      */\n     @Override\n-    public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n-    {\n+    public StdTypeResolverBuilder typeProperty(String typeIdPropName) {\n         // ok to have null/empty; will restore to use defaults\n         if (typeIdPropName == null || typeIdPropName.length() == 0) {\n             typeIdPropName = _idType.getDefaultPropertyName();\n     }\n \n     @Override\n-    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)\n-    {\n+    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {\n         _defaultImpl = defaultImpl;\n         return this;\n     }\n     /**********************************************************\n      */\n \n+    @Override public Class<?> getDefaultImpl() { return _defaultImpl; }\n+\n     public String getTypeProperty() { return _typeProperty; }\n-\n-    @Override\n-    public Class<?> getDefaultImpl() {\n-        return _defaultImpl;\n-    }\n-\n     public boolean isTypeIdVisible() { return _typeIdVisible; }\n     \n     /*\n      * given configuration.\n      */\n     protected TypeIdResolver idResolver(MapperConfig<?> config,\n-            JavaType baseType, Collection<NamedType> subtypes,\n-            boolean forSer, boolean forDeser)\n+            JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser)\n     {\n         // Custom id resolver?\n-        if (_customIdResolver != null) {\n-            return _customIdResolver;\n-        }\n-        if (_idType == null) {\n-            throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n-        }\n+        if (_customIdResolver != null) { return _customIdResolver; }\n+        if (_idType == null) throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n         switch (_idType) {\n         case CLASS:\n             return new ClassNameIdResolver(baseType, config.getTypeFactory());", "timestamp": 1389498681, "metainfo": ""}