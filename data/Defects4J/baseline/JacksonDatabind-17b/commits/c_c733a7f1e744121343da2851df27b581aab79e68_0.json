{"sha": "c733a7f1e744121343da2851df27b581aab79e68", "log": "Yet more config refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n  * Note: as of 2.0, goal is still to make config instances fully immutable.\n  */\n public class DeserializationConfig\n-    extends MapperConfig.Impl<DeserializationConfig.Feature, DeserializationConfig>\n+    extends MapperConfigBase<DeserializationConfig.Feature, DeserializationConfig>\n {\n     /**\n      * Enumeration that defines togglable features that guide\n         _mixInAnnotations = mixins;\n     }\n     \n-    protected DeserializationConfig(DeserializationConfig src, MapperConfig.Base base)\n+    protected DeserializationConfig(DeserializationConfig src, BaseSettings base)\n     {\n         super(src, base, src._subtypeResolver, src._featureFlags);\n         _problemHandlers = src._problemHandlers;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     protected DeserializationContext(DeserializationConfig config)\n     {\n         _config = config;\n-        _featureFlags = config._featureFlags;\n+        _featureFlags = config.getFeatureFlags();\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n package com.fasterxml.jackson.databind;\n \n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      */\n     public DeserializationConfig copyDeserializationConfig() {\n         return _deserializationConfig.createUnshared(_subtypeResolver)\n-                .passSerializationFeatures(_serializationConfig._featureFlags);\n+                .passSerializationFeatures(_serializationConfig.getFeatureFlags());\n     }\n \n     /**\n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\n-            int serFeatures = _serializationConfig._featureFlags & ~(SerializationConfig.Feature.WRAP_ROOT_VALUE.getMask());\n+            int serFeatures = _serializationConfig.getFeatureFlags()\n+                    & ~(SerializationConfig.Feature.WRAP_ROOT_VALUE.getMask());\n             // no need to check for closing of TokenBuffer\n             _serializerProvider.serializeValue(copySerializationConfig(serFeatures),\n                     buf, fromValue, _serializerFactory);\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java\n package com.fasterxml.jackson.databind;\n \n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n  * Note: as of 2.0, goal is still to make config instances fully immutable.\n  */\n public class SerializationConfig\n-    extends MapperConfig.Impl<SerializationConfig.Feature, SerializationConfig>\n+    extends MapperConfigBase<SerializationConfig.Feature, SerializationConfig>\n {\n     /**\n      * Enumeration that defines togglable features that guide\n         _mixInAnnotations = mixins;\n     }\n     \n-    protected SerializationConfig(SerializationConfig src, MapperConfig.Base base)\n+    protected SerializationConfig(SerializationConfig src, BaseSettings base)\n     {\n         super(src, base, src._subtypeResolver);\n         _serializationInclusion = src._serializationInclusion;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Immutable container class used to store simple configuration\n+ * settings. Since instances are fully immutable, instances can\n+ * be freely shared and used without synchronization.\n+ */\n+public final class BaseSettings\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration settings; introspection, related\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Introspector used to figure out Bean properties needed for bean serialization\n+     * and deserialization. Overridable so that it is possible to change low-level\n+     * details of introspection, like adding new annotation types.\n+     */\n+    protected final ClassIntrospector<? extends BeanDescription> _classIntrospector;\n+\n+    /**\n+     * Introspector used for accessing annotation value based configuration.\n+     */\n+    protected final AnnotationIntrospector _annotationIntrospector;\n+\n+    /**\n+     * Object used for determining whether specific property elements\n+     * (method, constructors, fields) can be auto-detected based on\n+     * their visibility (access modifiers). Can be changed to allow\n+     * different minimum visibility levels for auto-detection. Note\n+     * that this is the global handler; individual types (classes)\n+     * can further override active checker used (using\n+     * {@link JsonAutoDetect} annotation)\n+     */\n+    protected final VisibilityChecker<?> _visibilityChecker;\n+\n+    /**\n+     * Custom property naming strategy in use, if any.\n+     */\n+    protected final PropertyNamingStrategy _propertyNamingStrategy;\n+\n+    /**\n+     * Specific factory used for creating {@link JavaType} instances;\n+     * needed to allow modules to add more custom type handling\n+     * (mostly to support types of non-Java JVM languages)\n+     */\n+    protected final TypeFactory _typeFactory;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration settings; type resolution\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Type information handler used for \"untyped\" values (ones declared\n+     * to have type <code>Object.class</code>)\n+     */\n+    protected final TypeResolverBuilder<?> _typeResolverBuilder;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration settings; other\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Custom date format to use for de-serialization. If specified, will be\n+     * used instead of {@link com.fasterxml.jackson.databind.util.StdDateFormat}.\n+     *<p>\n+     * Note that the configured format object will be cloned once per\n+     * deserialization process (first time it is needed)\n+     */\n+    protected final DateFormat _dateFormat;\n+\n+    /**\n+     * Object used for creating instances of handlers (serializers, deserializers,\n+     * type and type id resolvers), given class to instantiate. This is typically\n+     * used to do additional configuration (with dependency injection, for example)\n+     * beyond simply construction of instances; or to use alternative constructors.\n+     */\n+    protected final HandlerInstantiator _handlerInstantiator;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public BaseSettings(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+            VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n+            TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi)\n+    {\n+        _classIntrospector = ci;\n+        _annotationIntrospector = ai;\n+        _visibilityChecker = vc;\n+        _propertyNamingStrategy = pns;\n+        _typeFactory = tf;\n+        _typeResolverBuilder = typer;\n+        _dateFormat = dateFormat;\n+        _handlerInstantiator = hi;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+    \n+    public BaseSettings withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n+        return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+    \n+    public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+\n+    public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(ai, _annotationIntrospector));\n+    }\n+\n+    public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(_annotationIntrospector, ai));\n+    }\n+    \n+    public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+\n+    public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n+                _visibilityChecker.withVisibility(forMethod, visibility),\n+                _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+    \n+    public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+\n+    public BaseSettings withTypeFactory(TypeFactory tf) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+    }\n+\n+    public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                typer, _dateFormat, _handlerInstantiator);\n+    }\n+    \n+    public BaseSettings withDateFormat(DateFormat df) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, df, _handlerInstantiator);\n+    }\n+\n+    public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, hi);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* API\n+    /**********************************************************\n+     */\n+\n+    public ClassIntrospector<? extends BeanDescription> getClassIntrospector() {\n+        return _classIntrospector;\n+    }\n+    \n+    public AnnotationIntrospector getAnnotationIntrospector() {\n+        return _annotationIntrospector;\n+    }\n+\n+\n+    public VisibilityChecker<?> getVisibilityChecker() {\n+        return _visibilityChecker;\n+    }\n+\n+    public PropertyNamingStrategy getPropertyNamingStrategy() {\n+        return _propertyNamingStrategy;\n+    }\n+\n+    public TypeFactory getTypeFactory() {\n+        return _typeFactory;\n+    }\n+\n+    public TypeResolverBuilder<?> getTypeResolverBuilder() {\n+        return _typeResolverBuilder;\n+    }\n+    \n+    public DateFormat getDateFormat() {\n+        return _dateFormat;\n+    }\n+\n+    public HandlerInstantiator getHandlerInstantiator() {\n+        return _handlerInstantiator;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n+\n+/**\n+ * Interface that defines functionality accessible through both\n+ * serialization and deserialization configuration objects;\n+ * accessors to mode-independent configuration settings\n+ * and such.\n+ *<p>\n+ * As of version 1.9, the goal is to make this class eventually immutable.\n+ * Because of this, existing methods that allow changing state of this\n+ * instance are deprecated in favor of methods that create new instances\n+ * with different configuration (\"fluent factories\").\n+ * One major remaining issue is that of handling mix-in annotations, which\n+ * still represent a bit of mutable state; may need to implement a\n+ * functional-style immutable map for storing those.\n+ */\n+public abstract class MapperConfig<T extends MapperConfig<T>>\n+    implements ClassIntrospector.MixInResolver\n+{\n+    /*\n+    /**********************************************************\n+    /* Constants, default values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is the default {@link DateFormat} used unless overridden by\n+     * custom implementation.\n+     */\n+    protected final static DateFormat DEFAULT_DATE_FORMAT = StdDateFormat.instance;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple immutable basic settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Immutable container object for simple configuration settings.\n+     *<p>\n+     * Note: ideally this would be final, but until we can eliminate\n+     * mutators, must keep it mutable.\n+     */\n+    protected BaseSettings _base;\n+    \n+    /*\n+    /**********************************************************\n+    /* Mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Mapping that defines how to apply mix-in annotations: key is\n+     * the type to received additional annotations, and value is the\n+     * type that has annotations to \"mix in\".\n+     *<p>\n+     * Annotations associated with the value classes will be used to\n+     * override annotations of the key class, associated with the\n+     * same field or method. They can be further masked by sub-classes:\n+     * you can think of it as injecting annotations between the target\n+     * class and its sub-classes (or interfaces)\n+     */\n+    protected HashMap<ClassKey,Class<?>> _mixInAnnotations;\n+\n+    /**\n+     * Flag used to detect when a copy if mix-in annotations is\n+     * needed: set when current copy is shared, cleared when a\n+     * fresh copy is made\n+     */\n+    protected boolean _mixInAnnotationsShared;\n+\n+    /*\n+    /**********************************************************\n+    /* \"Late bound\" settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Registered concrete subtypes that can be used instead of (or\n+     * in addition to) ones declared using annotations.\n+     * Unlike most other settings, it is not configured as early\n+     * as it is set, but rather only when a non-shared instance\n+     * is constructed by <code>ObjectMapper</code> (or -Reader\n+     * or -Writer)\n+     *<p>\n+     * Note: this is the only property left as non-final, to allow\n+     * lazy construction of the instance as necessary.\n+     */\n+    protected SubtypeResolver _subtypeResolver;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    protected MapperConfig(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+            VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n+            HandlerInstantiator hi)\n+    {\n+        _base = new BaseSettings(ci, ai, vc, pns, tf, null, DEFAULT_DATE_FORMAT, hi);\n+        _subtypeResolver = str;\n+        // by default, assumed to be shared; only cleared when explicit copy is made\n+        _mixInAnnotationsShared = true;\n+    }\n+\n+    /**\n+     * Simple copy constructor\n+     */\n+    protected MapperConfig(MapperConfig<T> src) {\n+        this(src, src._base, src._subtypeResolver);\n+    }\n+\n+    /**\n+     * Fluent-copy constructor that creates a new slightly modified version, using\n+     * given config object as base for settings not provided.\n+     */\n+    protected MapperConfig(MapperConfig<T> src, BaseSettings base, SubtypeResolver str)\n+    {\n+        _base = base;\n+        _subtypeResolver = str;\n+        // by default, assumed to be shared; only cleared when explicit copy is made\n+        _mixInAnnotationsShared = true;\n+        _mixInAnnotations = src._mixInAnnotations;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method to use for constructing an instance that is not shared\n+     * between multiple operations but only used for a single one\n+     * (which may be this instance, if it is immutable; if not, a copy\n+     * is constructed with same settings)\n+     */\n+    public abstract T createUnshared(SubtypeResolver subtypeResolver);\n+\n+    /**\n+     * Method to use for constructing an instance that is not shared\n+     * between multiple operations but only used for a single one\n+     * (which may be this instance, if it is immutable; if not, a copy\n+     * is constructed with same settings)\n+     */\n+    public abstract T createUnshared(SubtypeResolver subtypeResolver, int features);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link ClassIntrospector}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link AnnotationIntrospector} to use (replacing old one).\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link VisibilityChecker}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * minimal visibility level for specified property type\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeResolverBuilder}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link SubtypeResolver}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withSubtypeResolver(SubtypeResolver str);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link PropertyNamingStrategy}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeFactory}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withTypeFactory(TypeFactory typeFactory);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link DateFormat}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withDateFormat(DateFormat df);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link HandlerInstantiator}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     */\n+    public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} inserted (as the highest priority one)\n+     */\n+    public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} appended (as the lowest priority one)\n+     */\n+    public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: simple features\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for determining whether annotation processing is enabled or not\n+     * (default settings are typically that it is enabled; must explicitly disable).\n+     * \n+     * @return True if annotation processing is enabled; false if not\n+     */\n+    public abstract boolean isAnnotationProcessingEnabled();\n+\n+    /**\n+     * Accessor for determining whether it is ok to try to force override of access\n+     * modifiers to be able to get or set values of non-public Methods, Fields;\n+     * to invoke non-public Constructors, Methods; or to instantiate non-public\n+     * Classes. By default this is enabled, but on some platforms it needs to be\n+     * prevented since if this would violate security constraints and cause failures.\n+     * \n+     * @return True if access modifier overriding is allowed (and may be done for\n+     *   any Field, Method, Constructor or Class); false to prevent any attempts\n+     *   to override.\n+     */\n+    public abstract boolean canOverrideAccessModifiers();\n+\n+    /**\n+     * Accessor for checking whether default settings for property handling\n+     * indicate that properties should be alphabetically ordered or not.\n+     */\n+    public abstract boolean shouldSortPropertiesAlphabetically();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: introspectors, mix-ins\n+    /**********************************************************\n+     */\n+    \n+    public ClassIntrospector<? extends BeanDescription> getClassIntrospector() {\n+        return _base.getClassIntrospector();\n+    }\n+\n+    /**\n+     * Method for getting {@link AnnotationIntrospector} configured\n+     * to introspect annotation values used for configuration.\n+     *<p>\n+     * Non-final since it is actually overridden by sub-classes (for now?)\n+     */\n+    public AnnotationIntrospector getAnnotationIntrospector() {\n+        return _base.getAnnotationIntrospector();\n+    }\n+\n+    /**\n+     * Accessor for object used for determining whether specific property elements\n+     * (method, constructors, fields) can be auto-detected based on\n+     * their visibility (access modifiers). Can be changed to allow\n+     * different minimum visibility levels for auto-detection. Note\n+     * that this is the global handler; individual types (classes)\n+     * can further override active checker used (using\n+     * {@link JsonAutoDetect} annotation)\n+     */\n+    public VisibilityChecker<?> getDefaultVisibilityChecker() {\n+        return _base.getVisibilityChecker();\n+    }\n+    \n+    public final PropertyNamingStrategy getPropertyNamingStrategy() {\n+        return _base.getPropertyNamingStrategy();\n+    }\n+\n+    public final HandlerInstantiator getHandlerInstantiator() {\n+        return _base.getHandlerInstantiator();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method to use for defining mix-in annotations to use for augmenting\n+     * annotations that processable (serializable / deserializable)\n+     * classes have.\n+     * Mixing in is done when introspecting class annotations and properties.\n+     * Map passed contains keys that are target classes (ones to augment\n+     * with new annotation overrides), and values that are source classes\n+     * (have annotations to use for augmentation).\n+     * Annotations from source classes (and their supertypes)\n+     * will <b>override</b>\n+     * annotations that target classes (and their super-types) have.\n+     */\n+    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+    {\n+        HashMap<ClassKey,Class<?>> mixins = null;\n+        if (sourceMixins != null && sourceMixins.size() > 0) {\n+            mixins = new HashMap<ClassKey,Class<?>>(sourceMixins.size());\n+            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n+                mixins.put(new ClassKey(en.getKey()), en.getValue());\n+            }\n+        }\n+        _mixInAnnotationsShared = false;\n+        _mixInAnnotations = mixins;\n+    }\n+\n+    /**\n+     * Method to use for adding mix-in annotations to use for augmenting\n+     * specified class or interface. All annotations from\n+     * <code>mixinSource</code> are taken to override annotations\n+     * that <code>target</code> (or its supertypes) has.\n+     *\n+     * @param target Class (or interface) whose annotations to effectively override\n+     * @param mixinSource Class (or interface) whose annotations are to\n+     *   be \"added\" to target's annotations, overriding as necessary\n+     */\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+    {\n+        if (_mixInAnnotations == null) {\n+            _mixInAnnotationsShared = false;\n+            _mixInAnnotations = new HashMap<ClassKey,Class<?>>();\n+        } else if (_mixInAnnotationsShared) {\n+            _mixInAnnotationsShared = false;\n+            _mixInAnnotations = new HashMap<ClassKey,Class<?>>(_mixInAnnotations);\n+        }\n+        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n+    }\n+\n+    // ClassIntrospector.MixInResolver impl:\n+\n+    /**\n+     * Method that will check if there are \"mix-in\" classes (with mix-in\n+     * annotations) for given class\n+     */\n+    @Override\n+    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n+    }\n+\n+    public final int mixInCount() {\n+        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: type and subtype handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to locate a type info handler for types that do not have\n+     * one explicitly declared via annotations (or other configuration).\n+     * If such default handler is configured, it is returned; otherwise\n+     * null is returned.\n+     */\n+    public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType) {\n+        return _base.getTypeResolverBuilder();\n+    }\n+    \n+    /**\n+     * Accessor for object used for finding out all reachable subtypes\n+     * for supertypes; needed when a logical type name is used instead\n+     * of class name (or custom scheme).\n+     */\n+    public final SubtypeResolver getSubtypeResolver() {\n+        if (_subtypeResolver == null) {\n+            _subtypeResolver = new StdSubtypeResolver();\n+        }\n+        return _subtypeResolver;\n+    }\n+\n+    public final TypeFactory getTypeFactory() {\n+        return _base.getTypeFactory();\n+    }\n+\n+    /**\n+     * Helper method that will construct {@link JavaType} for given\n+     * raw class.\n+     * This is a simple short-cut for:\n+     *<pre>\n+     *    getTypeFactory().constructType(cls);\n+     *</pre>\n+     */\n+    public final JavaType constructType(Class<?> cls) {\n+        return getTypeFactory().constructType(cls, (TypeBindings) null);\n+    }\n+\n+    /**\n+     * Helper method that will construct {@link JavaType} for given\n+     * type reference\n+     * This is a simple short-cut for:\n+     *<pre>\n+     *    getTypeFactory().constructType(valueTypeRef);\n+     *</pre>\n+     */\n+    public final JavaType constructType(TypeReference<?> valueTypeRef) {\n+        return getTypeFactory().constructType(valueTypeRef.getType(), (TypeBindings) null);\n+    }\n+\n+    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n+        return getTypeFactory().constructSpecializedType(baseType, subclass);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing currently configured (textual) date format\n+     * that will be used for reading or writing date values (in case\n+     * of writing, only if textual output is configured; not if dates\n+     * are to be serialized as time stamps).\n+     *<p>\n+     * Note that typically {@link DateFormat} instances are <b>not thread-safe</b>\n+     * (at least ones provided by JDK):\n+     * this means that calling code should clone format instance before\n+     * using it.\n+     *<p>\n+     * This method is usually only called by framework itself, since there\n+     * are convenience methods available via\n+     * {@link DeserializationContext} and {@link SerializerProvider} that\n+     * take care of cloning and thread-safe reuse.\n+     */\n+    public final DateFormat getDateFormat() { return _base.getDateFormat(); }\n+\n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <DESC extends BeanDescription> DESC introspectClassAnnotations(Class<?> cls) {\n+        return (DESC) introspectClassAnnotations(constructType(cls));\n+    }\n+    \n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    public abstract <DESC extends BeanDescription> DESC introspectClassAnnotations(JavaType type);\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <DESC extends BeanDescription> DESC introspectDirectClassAnnotations(Class<?> cls) {\n+        return (DESC) introspectDirectClassAnnotations(constructType(cls));\n+    }\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    public abstract <DESC extends BeanDescription> DESC introspectDirectClassAnnotations(JavaType type);\n+        \n+    /*\n+    /**********************************************************\n+    /* Methods for instantiating handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n+     * specified type.\n+     */\n+    public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated,\n+            Class<? extends TypeResolverBuilder<?>> builderClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            TypeResolverBuilder<?> builder = hi.typeResolverBuilderInstance(this, annotated, builderClass);\n+            if (builder != null) {\n+                return builder;\n+            }\n+        }\n+        return (TypeResolverBuilder<?>) ClassUtil.createInstance(builderClass, canOverrideAccessModifiers());\n+    }\n+\n+    /**\n+     * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n+     * specified type.\n+     */\n+    public TypeIdResolver typeIdResolverInstance(Annotated annotated,\n+            Class<? extends TypeIdResolver> resolverClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass);\n+            if (builder != null) {\n+                return builder;\n+            }\n+        }\n+        return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper interface used with simple on/off features\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Interface that actual Feature enumerations used by\n+     * {@link MapperConfig} implementations must implement.\n+     * Necessary since enums can not be extended using normal\n+     * inheritance, but can implement interfaces\n+     */\n+    public interface ConfigFeature\n+    {\n+        /**\n+         * Accessor for checking whether this feature is enabled by default.\n+         */\n+        public boolean enabledByDefault();\n+\n+        /**\n+         * Accessor for checking whether feature can be used on per-call basis\n+         * (true), or not (false): in latter case it can only be configured once\n+         * before any serialization or deserialization.\n+         */\n+        public boolean canUseForInstance();\n+        \n+        /**\n+         * Returns bit mask for this feature instance\n+         */\n+        public int getMask();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public abstract class MapperConfigBase<CFG extends MapperConfig.ConfigFeature,\n+    T extends MapperConfigBase<CFG,T>>\n+    extends MapperConfig<T>\n+{\n+    protected int _featureFlags;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    protected MapperConfigBase(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+            VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n+            HandlerInstantiator hi,\n+            int defaultFeatures)\n+    {\n+        super(ci, ai, vc, str, pns, tf, hi);\n+        _featureFlags = defaultFeatures;\n+    }\n+    \n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src) {\n+        super(src);\n+        _featureFlags = src._featureFlags;\n+    }\n+    \n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, int features) {\n+        super(src);\n+        _featureFlags = features;\n+    }\n+    \n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str)\n+    {\n+        super(src, base, str);\n+        _featureFlags = src._featureFlags;\n+    }\n+    \n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str,\n+            int features)\n+    {\n+        super(src, base, str);\n+        _featureFlags = features;\n+    }\n+    \n+    /**\n+     * Method that calculates bit set (flags) of all features that\n+     * are enabled by default.\n+     */\n+    protected static <F extends Enum<F> & MapperConfig.ConfigFeature> int collectFeatureDefaults(Class<F> enumClass)\n+    {\n+        int flags = 0;\n+        for (F value : enumClass.getEnumConstants()) {\n+            if (value.enabledByDefault()) {\n+                flags |= value.getMask();\n+            }\n+        }\n+        return flags;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Additional fluent-factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public abstract T with(CFG... features);\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public abstract T without(CFG... features);\n+\n+    /*\n+    /**********************************************************\n+    /* Simple accessors\n+    /**********************************************************\n+     */\n+\n+    public final int getFeatureFlags() {\n+        return _featureFlags;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n \n public class BasicClassIntrospector\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n import com.fasterxml.jackson.databind.BeanDescription;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.util.BeanUtil;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/SubtypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/SubtypeResolver.java\n import java.util.Collection;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n \n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n import com.fasterxml.jackson.databind.type.ClassKey;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n-import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.databind.MapperConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n ", "timestamp": 1326947127, "metainfo": ""}