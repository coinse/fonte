{"sha": "cd610520c64daa3e817abb053739d41c63b0375b", "log": "Working on being able to plug-in SerializableString replacements for 2.4", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.*;\n+\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n-import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n+\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n     {\n         String expName = config.getRootName();\n         if (expName == null) {\n-            SerializedString sstr = _rootNames.findRootName(rootType, config);\n+            SerializableString sstr = _rootNames.findRootName(rootType, config);\n             expName = sstr.getValue();\n         }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n     {\n         String expName = _config.getRootName();\n         if (expName == null) {\n-            SerializedString sstr = _rootNames.findRootName(rootType, _config);\n+            SerializableString sstr = _rootNames.findRootName(rootType, _config);\n             expName = sstr.getValue();\n         }\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.1.0:\n-    private static final long serialVersionUID = 8849092838541724233L;\n+    // Valid as of 2.4\n+    private static final long serialVersionUID = -1278867172535832879L;\n \n     /**\n      * Set of features enabled; actual type (kind of features)\n         _filterProvider = src._filterProvider;\n     }\n \n-    private SerializationConfig(SerializationConfig src,\n-            int mapperFeatures, int serFeatures)\n+    private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures)\n     {\n         super(src, mapperFeatures);\n         _serFeatures = serFeatures;\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.Base64Variant;\n+import com.fasterxml.jackson.core.SerializableString;\n+import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * is expected or not.\n      */\n     public abstract boolean useRootWrapping();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration: factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a specialized textual object that can typically\n+     * be serialized faster than basic {@link java.lang.String} (depending\n+     * on escaping needed if any, char-to-byte encoding if needed).\n+     * \n+     * @param src Text to represent\n+     * \n+     * @return Optimized text object constructed\n+     * \n+     * @since 2.4\n+     */\n+    public SerializableString compileString(String src) {\n+        /* 20-Jan-2014, tatu: For now we will just construct it directly, but\n+         *    for 2.4 need to allow overriding to support non-standard extensions\n+         *    to be used by extensions like Afterburner.\n+         */\n+        return new SerializedString(src);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         for (Serializers serializers : customSerializers()) {\n             ser = serializers.findMapSerializer(config, type, beanDesc,\n                     keySerializer, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                break;\n-            }\n+            if (ser != null) { break; }\n         }\n         if (ser == null) {\n             if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n                 if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n                     @SuppressWarnings(\"unchecked\")\n                     Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n-                    enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n+                    enums = EnumValues.construct(config, enumClass);\n                 }\n                 ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                     elementTypeSerializer, elementValueSerializer);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.*;\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n-public class BeanPropertyWriter\n-    extends PropertyWriter\n+public class BeanPropertyWriter extends PropertyWriter\n     implements BeanProperty\n {\n     /**\n      * Logical name of the property; will be used as the field name\n      * under which value for the property is written.\n      */\n-    protected final SerializedString _name;\n+    protected final SerializableString _name;\n \n     /**\n      * Wrapper name to use for this element, if any\n         this(base, base._name);\n     }\n \n-    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name)\n+    protected BeanPropertyWriter(BeanPropertyWriter base, SerializableString name)\n     {\n         _name = name;\n         _wrapperName = base._wrapperName;\n     /**********************************************************\n      */\n \n-    public SerializedString getSerializedName() { return _name; }\n+    public SerializableString getSerializedName() { return _name; }\n     \n     public boolean hasSerializer() { return _serializer != null; }\n     public boolean hasNullSerializer() { return _nullSerializer != null; }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n+import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n \n      * only write references, but id property is handled by some\n      * other entity.\n      */\n-    public final SerializedString propertyName;\n+    public final SerializableString propertyName;\n \n     /**\n      * Blueprint generator instance: actual instance will be\n      */\n \n     @SuppressWarnings(\"unchecked\")\n-    protected ObjectIdWriter(JavaType t, SerializedString propName,\n+    protected ObjectIdWriter(JavaType t, SerializableString propName,\n             ObjectIdGenerator<?> gen, JsonSerializer<?> ser, boolean alwaysAsId)\n     {\n         idType = t;\n     public static ObjectIdWriter construct(JavaType idType, String propName,\n             ObjectIdGenerator<?> generator, boolean alwaysAsId)\n     {\n-        SerializedString serName = (propName == null) ? null : new SerializedString(propName);\n+        SerializableString serName = (propName == null) ? null : new SerializedString(propName);\n         return new ObjectIdWriter(idType, serName, generator, null, alwaysAsId);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n     }\n \n     private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, NameTransformer transformer,\n-            SerializedString name) {\n+            SerializableString name) {\n         super(base, name);\n         _nameTransformer = transformer;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.SerializableString;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n \n             return;\n         }\n         \n-        SerializedString name = w.propertyName;\n+        SerializableString name = w.propertyName;\n         if (name != null) {\n             jgen.writeFieldName(name);\n             w.serializer.serialize(id, jgen, provider);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.io.SerializedString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n              }\n              keyEnums = ((EnumSerializer) enumSer).getEnumValues();\n         }\n-        for (Map.Entry<?,SerializedString> entry : keyEnums.internalMap().entrySet()) {\n+        for (Map.Entry<?,SerializableString> entry : keyEnums.internalMap().entrySet()) {\n             String name = entry.getValue().getValue();\n             // should all have the same type, so:\n             if (ser == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.io.SerializedString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n             BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n-            ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n+        EnumValues v = EnumValues.construct(config, enumClass);\n         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n         return new EnumSerializer(v, serializeAsIndex);\n-    }\n-    \n-    /**\n-     * @deprecated Since 2.1 use the variant that takes in <code>format</code> argument.\n-     */\n-    @Deprecated\n-    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n-            BeanDescription beanDesc)\n-    {\n-        return construct(enumClass, config, beanDesc, beanDesc.findExpectedFormat(null));\n     }\n \n     /**\n      * choice here, however.\n      */\n     @Override\n-    public JsonSerializer<?> createContextual(SerializerProvider prov,\n-            BeanProperty property) throws JsonMappingException\n+    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException\n     {\n         if (property != null) {\n             JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n             JavaType type = provider.constructType(typeHint);\n             if (type.isEnumType()) {\n                 ArrayNode enumNode = objectNode.putArray(\"enum\");\n-                for (SerializedString value : _values.values()) {\n+                for (SerializableString value : _values.values()) {\n                     enumNode.add(value.getValue());\n                 }\n             }\n     \t\tif (typeHint != null && stringVisitor != null) {\n     \t\t\tif (typeHint.isEnumType()) {\n     \t\t\t\tSet<String> enums = new LinkedHashSet<String>();\n-    \t\t\t\tfor (SerializedString value : _values.values()) {\n+    \t\t\t\tfor (SerializableString value : _values.values()) {\n     \t\t\t\t\tenums.add(value.getValue());\n     \t\t\t\t}\n     \t\t\t\tstringVisitor.enumTypes(enums);\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Helper class used for storing String serializations of\n     private final Class<Enum<?>> _enumClass;\n     \n     /**\n-     * Since 1.7, we are storing values as SerializedStrings, to further\n-     * speed up serialization.\n+     * Use a more optimized String value here, to possibly speed up\n+     * serialization.\n      */\n-    private final EnumMap<?,SerializedString> _values;\n+    private final EnumMap<?,SerializableString> _values;\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    private EnumValues(Class<Enum<?>> enumClass, Map<Enum<?>,SerializedString> v) {\n+    private EnumValues(Class<Enum<?>> enumClass, Map<Enum<?>,SerializableString> v) {\n         _enumClass = enumClass;\n         _values = new EnumMap(v);\n     }\n \n-    public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr) {\n-        return constructFromName(enumClass, intr);\n+    public static EnumValues construct(SerializationConfig config, Class<Enum<?>> enumClass) {\n+        if (config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {\n+            return constructFromToString(config, enumClass);\n+        }\n+        return constructFromName(config, enumClass);\n     }\n \n-    public static EnumValues constructFromName(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n+    public static EnumValues constructFromName(MapperConfig<?> config, Class<Enum<?>> enumClass)\n     {\n         /* [JACKSON-214]: Enum types with per-instance sub-classes\n          *   need special handling\n         Enum<?>[] values = cls.getEnumConstants();\n         if (values != null) {\n             // Type juggling... unfortunate\n-            Map<Enum<?>,SerializedString> map = new HashMap<Enum<?>,SerializedString>();\n+            Map<Enum<?>,SerializableString> map = new HashMap<Enum<?>,SerializableString>();\n             for (Enum<?> en : values) {\n-                String value = intr.findEnumValue(en);\n-                map.put(en, new SerializedString(value));\n+                String value = config.getAnnotationIntrospector().findEnumValue(en);\n+                map.put(en, config.compileString(value));\n             }\n             return new EnumValues(enumClass, map);\n         }\n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n \n-    public static EnumValues constructFromToString(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n+    public static EnumValues constructFromToString(MapperConfig<?> config, Class<Enum<?>> enumClass)\n     {\n         Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);\n         Enum<?>[] values = cls.getEnumConstants();\n         if (values != null) {\n             // Type juggling... unfortunate\n-            Map<Enum<?>,SerializedString> map = new HashMap<Enum<?>,SerializedString>();\n+            Map<Enum<?>,SerializableString> map = new HashMap<Enum<?>,SerializableString>();\n             for (Enum<?> en : values) {\n-                map.put(en, new SerializedString(en.toString()));\n+                map.put(en, config.compileString(en.toString()));\n             }\n             return new EnumValues(enumClass, map);\n         }\n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n \n-    public SerializedString serializedValueFor(Enum<?> key) { return _values.get(key); }\n-    public Collection<SerializedString> values() { return _values.values(); }\n+    public SerializableString serializedValueFor(Enum<?> key) { return _values.get(key); }\n+    public Collection<SerializableString> values() { return _values.values(); }\n \n     /**\n      * Method used for serialization and introspection by core Jackson code.\n      */\n-    public EnumMap<?,SerializedString> internalMap() { return _values; }\n+    public EnumMap<?,SerializableString> internalMap() { return _values; }\n \n     /**\n      * @since 2.2\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n package com.fasterxml.jackson.databind.util;\n \n-import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.SerializableString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n      * For efficient operation, let's try to minimize number of times we\n      * need to introspect root element name to use.\n      */\n-    protected transient LRUMap<ClassKey,SerializedString> _rootNames;\n+    protected transient LRUMap<ClassKey,SerializableString> _rootNames;\n \n     public RootNameLookup() { }\n \n-    public SerializedString findRootName(JavaType rootType, MapperConfig<?> config) {\n+    public SerializableString findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     }\n \n-    public SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n+    public SerializableString findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         ClassKey key = new ClassKey(rootType);\n \n         synchronized (this) {\n             if (_rootNames == null) {\n-                _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n+                _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);\n             } else {\n-                SerializedString name = _rootNames.get(key);\n+                SerializableString name = _rootNames.get(key);\n                 if (name != null) {\n                     return name;\n                 }\n         } else {\n             nameStr = pname.getSimpleName();\n         }\n-        SerializedString name = new SerializedString(nameStr);\n+        SerializableString name = config.compileString(nameStr);\n         synchronized (this) {\n             _rootNames.put(key, name);\n         }", "timestamp": 1390279848, "metainfo": ""}