{"sha": "ed98c9e3c47b12f6f457f4af6fd2546e53f68284", "log": "jsonschema serialization and deep equals implemented.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n      * pass specific schema object to {@link JsonGenerator} used for\n      * writing content.\n      * \n-     * @param schema Schema to pass to generator\n+     * @param schema JsonSchema to pass to generator\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n         return new ObjectWriter(this, getSerializationConfig(), schema);\n      * pass specific schema object to {@link JsonParser} used for\n      * reading content.\n      * \n-     * @param schema Schema to pass to parser\n+     * @param schema JsonSchema to pass to parser\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         return new ObjectReader(this, getDeserializationConfig(), null, null,\n \n     /*\n     /**********************************************************\n-    /* Extended Public API: JSON Schema generation\n+    /* Extended Public API: JSON JsonSchema generation\n     /**********************************************************\n      */\n \n      * @param t The class to generate schema for\n      * @return Constructed JSON schema.\n      */\n-    public Schema generateJsonSchema(Class<?> t) throws JsonMappingException {\n+    public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n     \tDefaultSerializerProvider provider = _serializerProvider(getSerializationConfig());\n     \tSchemaFactory visitor = new SchemaFactory(provider);\n         provider.acceptJsonFormatVisitor(t, visitor);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonFormatVisitorAware.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n+\n+/**\n+ * Marker interface for schema-aware serializers.\n+ */\n+public interface JsonFormatVisitorAware\n+{\n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     * @param typeHint TODO\n+     *\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public void acceptJsonFormatVisitor(JsonFormatVisitor visitor, JavaType typeHint);\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/AnySchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/AnySchemaFactory.java\n package com.fasterxml.jackson.databind.jsonschema.factories;\n \n import com.fasterxml.jackson.databind.jsonschema.types.AnySchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonAnyFormatVisitor;\n \n public class AnySchemaFactory extends SchemaFactory implements\n \t\tanySchema = new AnySchema();\n \t}\n \n-\tpublic Schema getSchema() {\n+\tpublic JsonSchema getSchema() {\n \t\treturn anySchema;\n \t}\n \t\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ArraySchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ArraySchemaFactory.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.types.ArraySchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonArrayFormatVisitor;\n \n             JsonSerializer<Object> ser;\n \t\t\ttry {\n \t\t\t\tser = getProvider().findValueSerializer(contentType, _property);\n-\t\t\t\tif (ser instanceof SchemaAware) {\n+\t\t\t\tif (ser instanceof JsonFormatVisitorAware) {\n \t            \tSchemaFactory visitor = new SchemaFactory(provider);\n-\t                ((SchemaAware) ser).acceptJsonFormatVisitor(visitor, contentType);\n+\t                ((JsonFormatVisitorAware) ser).acceptJsonFormatVisitor(visitor, contentType);\n \t                arraySchema.setItemsSchema(visitor.finalSchema());\n \t            }\n \t\t\t} catch (JsonMappingException e) {\n         }\n \t}\n \t\n-\tpublic void itemsFormat(SchemaAware toVisit) {}\n+\tpublic void itemsFormat(JsonFormatVisitorAware toVisit) {}\n \t\n \tpublic void itemsFormat(SchemaType format) {\n-\t\tarraySchema.setItemsSchema(Schema.minimalForFormat(format));\n+\t\tarraySchema.setItemsSchema(JsonSchema.minimalForFormat(format));\n \t}\n \n-\tpublic Schema getSchema() {\n+\tpublic JsonSchema getSchema() {\n \t\treturn arraySchema;\n \t}\n \t\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NullSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NullSchemaFactory.java\n package com.fasterxml.jackson.databind.jsonschema.factories;\n \n import com.fasterxml.jackson.databind.jsonschema.types.NullSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonNullFormatVisitor;\n \n public class NullSchemaFactory extends SchemaFactory implements\n \t\tnullSchema = new NullSchema();\n \t}\n \n-\tpublic Schema getSchema() {\n+\tpublic JsonSchema getSchema() {\n \t\treturn nullSchema;\n \t}\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ObjectSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ObjectSchemaFactory.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n \t\tobjectSchema = new ObjectSchema();\n \t}\n \t\n-\tpublic Schema getSchema() {\n-\t\t// TODO Auto-generated method stub\n+\tpublic JsonSchema getSchema() {\n \t\treturn objectSchema;\n \t}\n \n-\tprivate JsonSerializer<Object> getSer(BeanPropertyWriter writer, Class<?> serType) {\n+\tprivate JsonSerializer<Object> getSer(BeanPropertyWriter writer) {\n \t\tJsonSerializer<Object> ser = writer.getSerializer();\n-\t\tif (ser == null) { // nope\n-\t\t\tif (serType == null) {\n-\t\t\t\tserType = writer.getPropertyType();\n-\t\t\t}\n+\t\tif (ser == null) {\n+\t\t\tClass<?>\tserType = writer.getPropertyType();\n \t\t\ttry {\n \t\t\t\treturn getProvider().findValueSerializer(serType, writer);\n \t\t\t} catch (JsonMappingException e) {\n \t\treturn ser;\n \t}\t\n \t\n-\tprivate Class<?> writerType(BeanPropertyWriter writer) {\n-\t\t\n-\t\t//TODO:Will these ever return different types?\n-\t\t\n-\t\t//JavaType propType = writer.getSerializationType();\n-\t\t//Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n-\t\treturn writer.getPropertyType();\n-\t}\n-\t\n-\tprotected Schema propertySchema(BeanPropertyWriter writer) {\n+\tprotected JsonSchema propertySchema(BeanPropertyWriter writer) {\n \t\tSchemaFactory visitor = new SchemaFactory(provider);\n-\t\tClass<?> serType = writerType(writer);\n-\t\tJsonSerializer<Object> ser = getSer(writer, serType);\n-\t\tif (ser != null && ser instanceof SchemaAware) {\n-\t\t\t((SchemaAware)ser).acceptJsonFormatVisitor(visitor, writer.getType());\n+\t\tJsonSerializer<Object> ser = getSer(writer);\n+\t\tif (ser != null && ser instanceof JsonFormatVisitorAware) {\n+\t\t\t((JsonFormatVisitorAware)ser).acceptJsonFormatVisitor(visitor, writer.getType());\n \t\t} else {\n \t\t\tvisitor.anyFormat();\n \t\t}\n \t\treturn visitor.finalSchema();\n \t}\n \t\n-\tprotected Schema propertySchema(SchemaAware handler, JavaType propertyTypeHint) {\n+\tprotected JsonSchema propertySchema(JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n \t\tSchemaFactory visitor = new SchemaFactory(provider);\n \t\thandler.acceptJsonFormatVisitor(visitor, propertyTypeHint);\n \t\treturn visitor.finalSchema();\n \t\tobjectSchema.putOptionalProperty(writer.getName(), propertySchema(writer));\n \t}\n \t\n-\tpublic void property(String name, SchemaAware handler, JavaType propertyTypeHint) {\n+\tpublic void property(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n \t\tobjectSchema.putProperty(name, propertySchema(handler, propertyTypeHint));\n \t}\n \t\n-\tpublic void optionalProperty(String name, SchemaAware handler, JavaType propertyTypeHint) {\n+\tpublic void optionalProperty(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint) {\n \t\tobjectSchema.putOptionalProperty(name, propertySchema(handler, propertyTypeHint));\n \t}\n \t\n \tpublic void property(String name) {\n-\t\tobjectSchema.putProperty(name, Schema.minimalForFormat(SchemaType.ANY));\n+\t\tobjectSchema.putProperty(name, JsonSchema.minimalForFormat(SchemaType.ANY));\n \t}\n \t\n \tpublic void optionalProperty(String name) {\n-\t\tobjectSchema.putOptionalProperty(name, Schema.minimalForFormat(SchemaType.ANY));\n+\t\tobjectSchema.putOptionalProperty(name, JsonSchema.minimalForFormat(SchemaType.ANY));\n \t}\n \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactory.java\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonAnyFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonBooleanFormatVisitor;\n \t\treturn (JsonBooleanFormatVisitor) delegate;\n \t}\n \n-\tpublic Schema finalSchema() {\n-\t\tassert delegate != null : \"SchemaFactory must envoke a delegate method before it can return a Schema.\";\n+\tpublic JsonSchema finalSchema() {\n+\t\tassert delegate != null : \"SchemaFactory must envoke a delegate method before it can return a JsonSchema.\";\n \t\tif (delegate == null) {\n \t\t\treturn null;\n \t\t} else {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactoryDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactoryDelegate.java\n package com.fasterxml.jackson.databind.jsonschema.factories;\n \n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n \n public interface SchemaFactoryDelegate {\n \n-\tpublic Schema getSchema();\n+\tpublic JsonSchema getSchema();\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ValueTypeSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ValueTypeSchemaFactory.java\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonValueFormatVisitor;\n \n \t\tsuper(provider);\n \t}\n \n-\tpublic Schema getSchema() {\n+\tpublic JsonSchema getSchema() {\n \t\treturn getValueSchema();\n \t}\n \tprotected abstract ValueTypeSchema getValueSchema();\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n import java.util.HashSet;\n import java.util.Set;\n \n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n-\n+/**\n+ * This class represents a {@link JsonSchema} of type any\n+ * @author jphelan\n+ *\n+ */\n public class AnySchema extends SimpleTypeSchema {\n \t\n \t/**\n \t@JsonProperty\n \tprivate Set<String> enums;\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.ANY;\n \t\n \t//instance initializer block\n \t\tenums = new HashSet<String>();\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asAnySchema()\n+\t */\n \t@Override\n \tpublic AnySchema asAnySchema() { return this; }\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof AnySchema) {\n+\t\t\tAnySchema that = ((AnySchema)obj);\n+\t\t\treturn super.equals(obj) && \n+\t\t\t\t\tenums == null ? that.enums == null : enums.equals(that.enums);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isAnySchema()\n+\t */\n \t@Override\n \tpublic boolean isAnySchema() { return true; }\n \t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonUnwrapped;\n import com.fasterxml.jackson.annotation.JsonValue;\n+import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n \n /*\n  * This attribute defines the allowed items in an instance array, and\n-   MUST be a schema or an array of schemas.  The default value is an\n-   empty schema which allows any value for items in the instance array.\n+   MUST be a jsonSchema or an array of jsonSchemas.  The default value is an\n+   empty jsonSchema which allows any value for items in the instance array.\n  */\n public class ArraySchema extends ContainerTypeSchema {\n \t\n+\t\n+\t/**\n+\t * see {@link AdditionalItems}\n+\t */\n \t@JsonProperty\n \tprivate ArraySchema.AdditionalItems additionalItems;\n \t\n+\t/**\n+\t * see {@link Items}\n+\t */\n \t@JsonProperty\n \tprivate ArraySchema.Items items;\n+\t\n \t/**This attribute defines the maximum number of values in an array*/\n \t@JsonProperty\n \tprivate Integer maxItems;\n+\t\n \t/**This attribute defines the minimum number of values in an array*/\n \t@JsonProperty\n \tprivate Integer minItems;\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.ARRAY;\n+\t\n \t/**\n \t * This attribute indicates that all items in an array instance MUST be\n \t   unique (contains no two identical values).\n \t@JsonProperty\n \tprivate Boolean uniqueItems = null;\n \t\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asArraySchema()\n+\t */\n \t@Override\n \tpublic ArraySchema asArraySchema() { return this; }\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ArraySchema) {\n+\t\t\tArraySchema that = (ArraySchema) obj;\n+\t\t\treturn getAdditionalItems() == null ? that.getAdditionalItems() == null : \n+\t\t\t\t\t\tgetAdditionalItems().equals(that.getAdditionalItems()) &&\n+\t\t\t\t\tgetItems() == null ? that.getItems() == null : \n+\t\t\t\t\t\tgetItems().equals(that.getItems()) &&\n+\t\t\t\t\tgetMaxItems() == null ? that.getMaxItems() == null :\n+\t\t\t\t\t\tgetMaxItems().equals(that.getMaxItems()) &&\n+\t\t\t\t\tgetMinItems() == null ? that.getMinItems() == null :\n+\t\t\t\t\t\tgetMinItems().equals(that.getMinItems()) &&\n+\t\t\t\t\tgetUniqueItems() == null ? that.getUniqueItems() == null :\n+\t\t\t\t\t\tgetUniqueItems().equals(that.getUniqueItems()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * {@link ArraySchema#additionalItems}\n \t * @return the additionalItems\n \t}\n \t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n \tpublic Boolean getUniqueItems() {\n \t\treturn uniqueItems;\n \t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isArraySchema()\n+\t */\n \t@Override\n \tpublic boolean isArraySchema() { return true; }\n \t\n \tpublic void setItems(ArraySchema.Items items) {\n \t\tthis.items = items;\n \t}\n-\tpublic void setItemsSchema(Schema schema) {\n-\t\titems = new SingleItems(schema);\n+\t\n+\t/**\n+\t * Convenience method to set the json schema for the {@link ArraySchema#items}\n+\t * field\n+\t * @param jsonSchema\n+\t */\n+\tpublic void setItemsSchema(JsonSchema jsonSchema) {\n+\t\titems = new SingleItems(jsonSchema);\n \t}\n \t/**\n \t * {@link ArraySchema#maxItems}\n \t * This provides a definition for additional items in an array instance\n    when tuple definitions of the items is provided.\n \t */\n-\tpublic static abstract class AdditionalItems {}\n-\t\n-\t/**\n-\t * When this attribute value is an array of schemas and the instance\n+\tpublic static abstract class AdditionalItems {\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic static Items jsonCreator(Map<String,Object> props) {\n+\t\t\t// not implemented for jsonSchema\n+\t\t\treturn null;\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * When this attribute value is an array of jsonSchemas and the instance\n \t   value is an array, each position in the instance array MUST conform\n-\t   to the schema in the corresponding position for this array.  This\n+\t   to the jsonSchema in the corresponding position for this array.  This\n \t   called tuple typing.  When tuple typing is used, additional items are\n \t   allowed, disallowed, or constrained by the \"additionalItems\"\n \t */\n \tpublic static class ArrayItems extends ArraySchema.Items {\n \t\t@JsonProperty\n-\t\tprivate Schema[] schemas;\n+\t\tprivate JsonSchema[] jsonSchemas;\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#asArrayItems()\n+\t\t */\n+\t\t@Override\n+\t\tpublic ArrayItems asArrayItems() { return this; }\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof Items) {\n+\t\t\t\tArrayItems that = (ArrayItems) obj;\n+\t\t\t\treturn getJsonSchemas() == null ? that.getJsonSchemas() == null :\n+\t\t\t\t\tgetJsonSchemas().equals(that.getJsonSchemas());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ArraySchema.ArrayItems#jsonSchemas}\n+\t\t * @return the jsonSchemas\n+\t\t */\n+\t\tpublic JsonSchema[] getJsonSchemas() {\n+\t\t\treturn jsonSchemas;\n+\t\t}\n \t\t\n \t\t/* (non-Javadoc)\n \t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#isArrayItems()\n \t\t@Override\n \t\tpublic boolean isArrayItems() { return true; }\n \t\t\n-\t\t/* (non-Javadoc)\n-\t\t * @see com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items#asArrayItems()\n-\t\t */\n-\t\t@Override\n-\t\tpublic ArrayItems asArrayItems() { return this; }\n \t}\n \t\n \t/**\n \t * This attribute defines the allowed items in an instance array, and\n-\t   MUST be a schema or an array of schemas.  The default value is an\n-\t   empty schema which allows any value for items in the instance array.\n+\t   MUST be a jsonSchema or an array of jsonSchemas.  The default value is an\n+\t   empty jsonSchema which allows any value for items in the instance array.\n \t */\n \tpublic static abstract class Items {\n \t\t\n \t\t\n \t\tpublic SingleItems asSingleItems() { return null; }\n \t\tpublic ArrayItems asArrayItems() { return null; }\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic static Items jsonCreator(Map<String,Object> props) {\n+\t\t\t//for now only support deserialization of singleItems\n+\t\t\tObject typeFound = props.get(\"type\");\n+\t\t\tif (typeFound == null || ! (typeFound instanceof String)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tString type = (String) typeFound;\n+\t\t\tJsonSchema schema = JsonSchema.minimalForFormat(SchemaType.forValue(type));\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\t//only deserialize items as minimal schema for type\n+\t\t\treturn new SingleItems(schema);\n+\t\t}\n+\t\t\n \t}\n \t\n \t/**\n \t *  This can be false\n    \t\tto indicate additional items in the array are not allowed\n \t */\n-\tpublic static class NoAdditionalItems {\n+\tpublic static class NoAdditionalItems extends AdditionalItems {\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof NoAdditionalItems;\n+\t\t}\n \t\t@JsonValue\n \t\tpublic Boolean value() { return false; }\n \t}\n \t\n \t/**\n \t * or it can\n-   \t\tbe a schema that defines the schema of the additional items.\n-\t */\n-\tpublic static class SchemaAdditionalItems {\n-\t\t\n-\t\t@JsonUnwrapped\n-\t\tprivate Schema schema;\n-\t}\n-\t\n-\t/**\n-\t * When this attribute value is a schema and the instance value is an\n+   \t\tbe a jsonSchema that defines the jsonSchema of the additional items.\n+\t */\n+\tpublic static class SchemaAdditionalItems extends AdditionalItems {\n+\t\t\n+\t\t@JsonIgnore\n+\t\tprivate JsonSchema jsonSchema;\n+\t\t\n+\t\tpublic SchemaAdditionalItems(JsonSchema schema) {\n+\t\t\tjsonSchema = schema;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SchemaAdditionalItems &&\n+\t\t\t\t\tgetJsonSchema() == null ? ((SchemaAdditionalItems)obj).getJsonSchema() == null :\n+\t\t\t\t\t\tgetJsonSchema().equals(((SchemaAdditionalItems)obj).getJsonSchema());\n+\t\t}\n+\t\t\n+\t\t@JsonValue\n+\t\tpublic JsonSchema getJsonSchema() {\n+\t\t\treturn jsonSchema;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * When this attribute value is a jsonSchema and the instance value is an\n \t   array, then all the items in the array MUST be valid according to the\n-\t   schema.\n+\t   jsonSchema.\n \t */\n \tpublic static class SingleItems extends ArraySchema.Items {\n-\t\t@JsonUnwrapped\n-\t\tprivate Schema schema;\n+\t\t@JsonIgnore\n+\t\tprivate JsonSchema jsonSchema;\n \t\t\t\n-\t\tpublic SingleItems(Schema schema) {\n-\t\t\tthis.schema = schema;\n+\t\tpublic SingleItems(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SingleItems &&\n+\t\t\t\t\tgetSchema() == null ? ((SingleItems)obj).getSchema() == null :\n+\t\t\t\t\t\tgetSchema().equals(((SingleItems)obj).getSchema());\n \t\t}\n \t\t\n \t\t/**\n-\t\t * {@link ArraySchema.SingleItems#schema}\n-\t\t * @return the schema\n-\t\t */\n-\t\tpublic Schema getSchema() {\n-\t\t\treturn schema;\n+\t\t * {@link ArraySchema.SingleItems#jsonSchema}\n+\t\t * @return the jsonSchema\n+\t\t */\n+\t\t@JsonValue\n+\t\tpublic JsonSchema getSchema() {\n+\t\t\treturn jsonSchema;\n \t\t}\n \t\t\n \t\t/**\n-\t\t * {@link ArraySchema.SingleItems#schema}\n-\t\t * @param schema the schema to set\n-\t\t */\n-\t\tpublic void setSchema(Schema schema) {\n-\t\t\tthis.schema = schema;\n+\t\t * {@link ArraySchema.SingleItems#jsonSchema}\n+\t\t * @param jsonSchema the jsonSchema to set\n+\t\t */\n+\t\tpublic void setSchema(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n \t\t}\n \t\t\n \t\t/* (non-Javadoc)\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/BooleanSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/BooleanSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n-import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n \n+/**\n+ * This class represents a {@link JsonSchema} of type boolean\n+ * @author jphelan\n+ *\n+ */\n public class BooleanSchema extends ValueTypeSchema {\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.BOOLEAN;\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isBooleanSchema()\n+\t */\n \t@Override\n \tpublic boolean isBooleanSchema() { return true; }\n \t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n \t\treturn type;\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asBooleanSchema()\n+\t */\n \t@Override\n \tpublic BooleanSchema asBooleanSchema() { return this; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n \n-\n+/**\n+ * This class encapsulates the functionality of container type {@link JsonSchema}\n+ * Array and Object\n+ * @author jphelan\n+ *\n+ */\n public abstract class ContainerTypeSchema extends SimpleTypeSchema {\n \t/**\n \t * This provides an enumeration of all possible values that are valid\n \t\tenums = new HashSet<String>();\n \t}\n \t\n-\t/**\n-\t * {@link ContainerTypeSchema#enums}\n-\t * @param enums the enums to set\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asContainerSchema()\n \t */\n-\tpublic void setEnums(Set<String> enums) {\n-\t\tthis.enums = enums;\n-\t}\n+\t@Override\n+\tpublic ContainerTypeSchema asContainerSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.SimpleTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ContainerTypeSchema) {\n+\t\t\tContainerTypeSchema that = (ContainerTypeSchema)obj;\n+\t\t\treturn getEnums() == null ? that.getEnums() == null :\n+\t\t\t\tgetEnums().equals(that.getEnums()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n \t/**\n \t * {@link ContainerTypeSchema#enums}\n \t * @return the enums\n \t\treturn enums;\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isContainerTypeSchema()\n+\t */\n \t@Override\n \tpublic boolean isContainerTypeSchema() { return true; }\n \t\n-\t@Override\n-\tpublic ContainerTypeSchema asContainerSchema() { return this; }\n+\t/**\n+\t * {@link ContainerTypeSchema#enums}\n+\t * @param enums the enums to set\n+\t */\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/HyperSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/HyperSchema.java\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n \n-public class HyperSchema extends Schema {\n+/**\n+ * This class represents the HyperSchema portion of a {@link JsonSchema}\n+ * It is a skeleton intended as a starting point for customization.\n+ * @author jphelan\n+ *\n+ */\n+public class HyperSchema extends JsonSchema {\n \t\n \t\n \t/**\n \t/**\n \t * If the instance property value is a string, this attribute defines\n \t   that the string SHOULD be interpreted as binary data and decoded\n-\t   using the encoding named by this schema property.  RFC 2045, Sec 6.1\n+\t   using the encoding named by this jsonSchema property.  RFC 2045, Sec 6.1\n \t   [RFC2045] lists the possible values for this property.\n \t */\n \t@JsonProperty\n \t   relative to the instance's URI.\n \t\n \t   When multiple schemas have been referenced for an instance, the user\n-\t   agent can determine if this schema is applicable for a particular\n+\t   agent can determine if this jsonSchema is applicable for a particular\n \t   instance by determining if the URI of the instance begins with the\n \t   the value of the \"pathStart\" attribute.  If the URI of the instance\n-\t   does not start with this URI, or if another schema specifies a\n+\t   does not start with this URI, or if another jsonSchema specifies a\n \t   starting URI that is longer and also matches the instance, this\n-\t   schema SHOULD NOT be applied to the instance.  Any schema that does\n+\t   jsonSchema SHOULD NOT be applied to the instance.  Any jsonSchema that does\n \t   not have a pathStart attribute SHOULD be considered applicable to all\n \t   the instances for which it is referenced.\n \t */\n \t\n \t/**\n \t * This attribute defines the media type of the instance representations\n-\t\tthat this schema is defining.\n+\t\tthat this jsonSchema is defining.\n \t */\n \t@JsonProperty\n \tprivate String mediaType;\n \t\n \t/**\n \t *  A link description object is used to describe link relations.  In the\n-\t   context of a schema, it defines the link relations of the instances\n-\t   of the schema, and can be parameterized by the instance values.  The\n-\t   link description format can be used on its own in regular (non-schema\n+\t   context of a jsonSchema, it defines the link relations of the instances\n+\t   of the jsonSchema, and can be parameterized by the instance values.  The\n+\t   link description format can be used on its own in regular (non-jsonSchema\n \t   documents), and use of this format can be declared by referencing the\n-\t   normative link description schema as the the schema for the data\n+\t   normative link description jsonSchema as the the jsonSchema for the data\n \t   structure that uses the links.\n \t */\n \tpublic class LinkDescriptionObject {\n \t\t   property SHOULD be resolved as a URI-Reference per RFC 3986 [RFC3986]\n \t\t   and MAY be a relative URI.  The base URI to be used for relative\n \t\t   resolution SHOULD be the URI used to retrieve the instance object\n-\t\t   (not the schema) when used within a schema.  Also, when links are\n-\t\t   used within a schema, the URI SHOULD be parametrized by the property\n+\t\t   (not the jsonSchema) when used within a jsonSchema.  Also, when links are\n+\t\t   used within a jsonSchema, the URI SHOULD be parametrized by the property\n \t\t   values of the instance object, if property values exist for the\n \t\t   corresponding variables in the template (otherwise they MAY be\n \t\t   provided from alternate sources, like user input).\n \t\t/**\n \t\t * The value of the \"rel\" property indicates the name of the relation to\n \t\t   the target resource.  The relation to the target SHOULD be\n-\t\t   interpreted as specifically from the instance object that the schema\n-\t\t   (or sub-schema) applies to, not just the top level resource that\n+\t\t   interpreted as specifically from the instance object that the jsonSchema\n+\t\t   (or sub-jsonSchema) applies to, not just the top level resource that\n \t\t   contains the object within its hierarchy.  If a resource JSON\n \t\t   representation contains a sub object with a property interpreted as a\n \t\t   link, that sub-object holds the relation with the target.  A relation\n \t\t   to target from the top level resource MUST be indicated with the\n-\t\t   schema describing the top level JSON representation.\n+\t\t   jsonSchema describing the top level JSON representation.\n \t\t\n \t\t   Relationship definitions SHOULD NOT be media type dependent, and\n \t\t   users are encouraged to utilize existing accepted relation\n \t\t   definitions, including those in existing relation registries (see RFC\n \t\t   4287 [RFC4287]).  However, we define these relations here for clarity\n-\t\t   of normative interpretation within the context of JSON hyper schema\n+\t\t   of normative interpretation within the context of JSON hyper jsonSchema\n \t\t   defined relations:\n \t\t\n \t\t   self  If the relation value is \"self\", when this property is\n \t\t      representation for the instance object.  The object that contains\n \t\t      this link possibly may not be the full representation.\n \t\t\n-\t\t   describedby  This indicates the target of the link is the schema for\n+\t\t   describedby  This indicates the target of the link is the jsonSchema for\n \t\t      the instance object.  This MAY be used to specifically denote the\n \t\t      schemas of objects within a JSON object hierarchy, facilitating\n \t\t      polymorphic type data structures.\n \t\t      other properties of the instance objects can be regarded as meta-\n \t\t       data descriptions for the data.\n \n-\t\t   The following relations are applicable for schemas (the schema as the\n+\t\t   The following relations are applicable for schemas (the jsonSchema as the\n \t\t   \"from\" resource in the relation):\n \t\t\n \t\t   instances  This indicates the target resource that represents\n-\t\t      collection of instances of a schema.\n+\t\t      collection of instances of a jsonSchema.\n \t\t\n \t\t   create  This indicates a target to use for creating new instances of\n-\t\t      a schema.  This link definition SHOULD be a submission link with a\n+\t\t      a jsonSchema.  This link definition SHOULD be a submission link with a\n \t\t      non-safe method (like POST).\n \t\t\n-\t\t   For example, if a schema is defined:\n+\t\t   For example, if a jsonSchema is defined:\n \t\t\n \t\t   {\n \t\t     \"links\": [\n \t\tprivate String rel;\n \t\t\n \t\t/**\n-\t\t * This property value is a schema that defines the expected structure\n+\t\t * This property value is a jsonSchema that defines the expected structure\n \t\t\tof the JSON representation of the target of the link.\n \t\t */\n \t\t@JsonProperty\n-\t\tprivate Schema targetSchema;\n+\t\tprivate JsonSchema targetSchema;\n \t\t\n \t\t/**\n \t\t * This attribute defines which method can be used to access the target\n \t\t   target URI to query the collection with property-based constraints on\n \t\t   the resources that SHOULD be returned from the server or used to post\n \t\t   data to the resource (depending on the method).  For example, with\n-\t\t   the following schema:\n+\t\t   the following jsonSchema:\n \t\t\n \t\t   {\n \t\t    \"links\":[\n \t\tprivate String enctype;\n \t\t\n \t\t/**\n-\t\t * This attribute contains a schema which defines the acceptable\n-\t\t   structure of the submitted request (for a GET request, this schema\n+\t\t * This attribute contains a jsonSchema which defines the acceptable\n+\t\t   structure of the submitted request (for a GET request, this jsonSchema\n \t\t   would define the properties for the query string and for a POST\n \t\t   request, this would define the body).\n \t\t */\n \t\t@JsonProperty\n-\t\tprivate Schema schema;\n+\t\tprivate JsonSchema jsonSchema;\n \t\t\n \t}\n \n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n-\t\t// TODO Auto-generated method stub\n \t\treturn null;\n \t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n \n+/**\n+ * This class represents a {@link JsonSchema} as an integer type\n+ * @author jphelan\n+ *\n+ */\n public class IntegerSchema extends NumberSchema {\n-\t\n-\t@JsonProperty(required = true)\n-\tpublic final SchemaType type = SchemaType.INTEGER;\n \t\n \t/**\n \t * This attribute defines what value the number instance must be\n \t@JsonProperty\n \tprivate Integer divisibleBy;\n \t\n-\t/**\n-\t * {@link IntegerSchema#divisibleBy}\n-\t * @param divisibleBy the divisibleBy to set\n+\t@JsonProperty(required = true)\n+\tpublic final SchemaType type = SchemaType.INTEGER;\n+\t\n+\t@Override\n+\tpublic IntegerSchema asIntegerSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.NumberSchema#equals(java.lang.Object)\n \t */\n-\tpublic void setDivisibleBy(Integer divisibleBy) {\n-\t\tthis.divisibleBy = divisibleBy;\n-\t}\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof IntegerSchema) {\n+\t\t\tIntegerSchema that = (IntegerSchema)obj;\n+\t\t\treturn getDivisibleBy() == null ? that.getDivisibleBy() == null :\n+\t\t\t\tgetDivisibleBy().equals(that.getDivisibleBy()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n \t/**\n \t * {@link IntegerSchema#divisibleBy}\n \t * @return the divisibleBy\n \t@Override\n \tpublic boolean isIntegerSchema() { return true; }\n \t\n-\t@Override\n-\tpublic IntegerSchema asIntegerSchema() { return this; }\n+\t/**\n+\t * {@link IntegerSchema#divisibleBy}\n+\t * @param divisibleBy the divisibleBy to set\n+\t */\n+\tpublic void setDivisibleBy(Integer divisibleBy) {\n+\t\tthis.divisibleBy = divisibleBy;\n+\t}\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/JsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * The type wraps the json schema specification at :\n+ * <a href=\"http://tools.ietf.org/id/draft-zyp-json-schema-03.txt\"> Json JsonSchema\n+ * Draft </a> <blockquote> JSON (JavaScript Object Notation) JsonSchema defines the\n+ * media type \"application/schema+json\", a JSON based format for defining the\n+ * structure of JSON data. JSON JsonSchema provides a contract for what JSON data is\n+ * required for a given application and how to interact with it. JSON JsonSchema is\n+ * intended to define validation, documentation, hyperlink navigation, and\n+ * interaction control of JSON data. </blockquote>\n+ * \n+ * <blockquote> JSON (JavaScript Object Notation) JsonSchema is a JSON media type\n+ * for defining the structure of JSON data. JSON JsonSchema provides a contract for\n+ * what JSON data is required for a given application and how to interact with\n+ * it. JSON JsonSchema is intended to define validation, documentation, hyperlink\n+ * navigation, and interaction control of JSON data. </blockquote>\n+ * \n+ * An example JSON JsonSchema provided by the JsonSchema draft:\n+ * \n+ * <pre>\n+ * \t{\n+ * \t  \"name\":\"Product\",\n+ * \t  \"properties\":{\n+ * \t    \"id\":{\n+ * \t      \"type\":\"number\",\n+ * \t      \"description\":\"Product identifier\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"name\":{\n+ * \t      \"description\":\"Name of the product\",\n+ * \t      \"type\":\"string\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"price\":{\n+ * \t      \"required\":true,\n+ * \t      \"type\": \"number\",\n+ * \t      \"minimum\":0,\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"tags\":{\n+ * \t      \"type\":\"array\",\n+ * \t      \"items\":{\n+ * \t        \"type\":\"string\"\n+ * \t      }\n+ * \t    }\n+ * \t  },\n+ * \t  \"links\":[\n+ * \t    {\n+ * \t      \"rel\":\"full\",\n+ * \t      \"href\":\"{id}\"\n+ * \t    },\n+ * \t    {\n+ * \t      \"rel\":\"comments\",\n+ * \t      \"href\":\"comments/?id={id}\"\n+ * \t    }\n+ * \t  ]\n+ * \t}\n+ * </pre>\n+ * \n+ * @author jphelan\n+ */\n+@JsonInclude(Include.NON_EMPTY)\n+@JsonTypeInfo(use = Id.CUSTOM, include = As.PROPERTY, property = \"type\")\n+@JsonTypeIdResolver(JsonSchema.JsonSchemaIdResolver.class)\n+public abstract class JsonSchema {\n+\n+\t/**\n+\t * This attribute defines a URI of a schema that contains the full\n+\t * representation of this schema. When a validator encounters this\n+\t * attribute, it SHOULD replace the current schema with the schema\n+\t * referenced by the value's URI (if known and available) and re- validate\n+\t * the instance. This URI MAY be relative or absolute, and relative URIs\n+\t * SHOULD be resolved against the URI of the current schema.\n+\t */\n+\t@JsonProperty\n+\tprivate String $ref;\n+\n+\t/**\n+\t * This attribute defines a URI of a JSON JsonSchema that is the schema of the\n+\t * current schema. When this attribute is defined, a validator SHOULD use\n+\t * the schema referenced by the value's URI (if known and available) when\n+\t * resolving Hyper JsonSchema (Section 6) links (Section 6.1).\n+\t * \n+\t * A validator MAY use this attribute's value to determine which version of\n+\t * JSON JsonSchema the current schema is written in, and provide the appropriate\n+\t * validation features and behavior. Therefore, it is RECOMMENDED that all\n+\t * schema authors include this attribute in their schemas to prevent\n+\t * conflicts with future JSON JsonSchema specification changes.\n+\t */\n+\t@JsonProperty\n+\tprivate String $schema;\n+\n+\t/**\n+\t * This attribute takes the same values as the \"type\" attribute, however if\n+\t * the instance matches the type or if this value is an array and the\n+\t * instance matches any type or schema in the array, then this instance is\n+\t * not valid.\n+\t */\n+\t@JsonProperty\n+\tprivate JsonSchema[] disallow;\n+\t/**\n+\t * The value of this property MUST be another schema which will provide a\n+\t * base schema which the current schema will inherit from. The inheritance\n+\t * rules are such that any instance that is valid according to the current\n+\t * schema MUST be valid according to the referenced schema. This MAY also be\n+\t * an array, in which case, the instance MUST be valid for all the schemas\n+\t * in the array. A schema that extends another schema MAY define additional\n+\t * attributes, constrain existing attributes, or add other constraints.\n+\t * \n+\t * Conceptually, the behavior of extends can be seen as validating an\n+\t * instance against all constraints in the extending schema as well as the\n+\t * extended schema(s). More optimized implementations that merge schemas are\n+\t * possible, but are not required. An example of using \"extends\":\n+\t * \n+\t * { \"description\":\"An adult\", \"properties\":{\"age\":{\"minimum\": 21}},\n+\t * \"extends\":\"person\" } { \"description\":\"Extended schema\",\n+\t * \"properties\":{\"deprecated\":{\"type\": \"boolean\"}},\n+\t * \"extends\":\"http://json-schema.org/draft-03/schema\" }\n+\t */\n+\t@JsonIgnore\n+\tprivate JsonSchema[] extendsextends;\n+\t/**\n+\t * This attribute defines the current URI of this schema (this attribute is\n+\t * effectively a \"self\" link). This URI MAY be relative or absolute. If the\n+\t * URI is relative it is resolved against the current URI of the parent\n+\t * schema it is contained in. If this schema is not contained in any parent\n+\t * schema, the current URI of the parent schema is held to be the URI under\n+\t * which this schema was addressed. If id is missing, the current URI of a\n+\t * schema is defined to be that of the parent schema. The current URI of the\n+\t * schema is also used to construct relative references such as for $ref.\n+\t */\n+\t@JsonProperty\n+\tprivate String id;\n+\t/**\n+\t * This attribute indicates if the instance must have a value, and not be\n+\t * undefined. This is false by default, making the instance optional.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean required = null;\n+\n+\t\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link AnySchema}\n+\t * @return this as an AnySchema if possible, or null otherwise\n+\t */\n+\tpublic AnySchema asAnySchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link ArraySchema}\n+\t * @return this as an ArraySchema if possible, or null otherwise\n+\t */\n+\tpublic ArraySchema asArraySchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link BooleanSchema}\n+\t * @return this as a BooleanSchema if possible, or null otherwise\n+\t */\n+\tpublic BooleanSchema asBooleanSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link ContainerTypeSchema}\n+\t * @return this as an ContainerTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic ContainerTypeSchema asContainerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link IntegerSchema}\n+\t * @return this as an IntegerSchema if possible, or null otherwise\n+\t */\n+\tpublic IntegerSchema asIntegerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link NullSchema}\n+\t * @return this as a NullSchema if possible, or null otherwise\n+\t */\n+\tpublic NullSchema asNullSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link NumberSchema}\n+\t * @return this as a NumberSchema if possible, or null otherwise\n+\t */\n+\tpublic NumberSchema asNumberSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link ObjectSchema}\n+\t * @return this as an ObjectSchema if possible, or null otherwise\n+\t */\n+\tpublic ObjectSchema asObjectSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link SimpleTypeSchema}\n+\t * @return this as a SimpleTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic SimpleTypeSchema asSimpleTypeSchema() {\n+\t\treturn null;\n+\t}\n+\t\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link StringSchema}\n+\t * @return this as a StringSchema if possible, or null otherwise\n+\t */\n+\tpublic StringSchema asStringSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as an {@link UnionTypeSchema}\n+\t * @return this as a UnionTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic UnionTypeSchema asUnionTypeSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Attempt to return this JsonSchema as a {@link ValueTypeSchema}\n+\t * @return this as a ValueTypeSchema if possible, or null otherwise\n+\t */\n+\tpublic ValueTypeSchema asValueSchemaSchema() {\n+\t\treturn null;\n+\t}\n+\n+\t\n+\t/* (non-Javadoc)\n+\t * @see java.lang.Object#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof JsonSchema) {\n+\t\t\tJsonSchema that = ((JsonSchema)obj);\n+\t\t\treturn that.getType() == getType() &&\n+\t\t\t\t\tgetRequired() == null ? that.getRequired() == null : \n+\t\t\t\t\t\tgetRequired().equals(that.getRequired()) &&\n+\t\t\t\t\tget$ref() == null ? that.get$ref() == null : \n+\t\t\t\t\t\tget$ref().equals(that.get$ref()) &&\n+\t\t\t\t\tget$schema() == null ? that.get$schema() == null : \n+\t\t\t\t\t\tget$schema().equals(that.get$schema()) &&\n+\t\t\t\t\tgetDisallow() == null ? that.getDisallow() == null : \n+\t\t\t\t\t\tgetDisallow().equals(that.getDisallow()) &&\n+\t\t\t\t\tgetExtends() == null ? that.getExtends() == null : \n+\t\t\t\t\t\tgetExtends().equals(that.getExtends());\n+\t\t} \n+\t\treturn false;\n+\t}\n+\t\n+\t/**\n+\t * {@link JsonSchema#$ref}\n+\t * \n+\t * @return the $ref\n+\t */\n+\tpublic String get$ref() {\n+\t\treturn $ref;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$schema}\n+\t * \n+\t * @return the $schema\n+\t */\n+\tpublic String get$schema() {\n+\t\treturn $schema;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#disallow}\n+\t * \n+\t * @return the disallow\n+\t */\n+\tpublic JsonSchema[] getDisallow() {\n+\t\treturn disallow;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#extendsextends}\n+\t * \n+\t * @return the extendsextends\n+\t */\n+\t@JsonGetter(\"extends\")\n+\tpublic JsonSchema[] getExtends() {\n+\t\treturn extendsextends;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#id}\n+\t * \n+\t * @return the id\n+\t */\n+\tpublic String getId() {\n+\t\treturn id;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#required}\n+\t * \n+\t * @return the required\n+\t */\n+\tpublic Boolean getRequired() {\n+\t\treturn required;\n+\t}\n+\n+\t@JsonIgnore\n+\tpublic abstract SchemaType getType();\n+\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link AnySchema}.\n+\t *\n+\t * @return true if this JsonSchema is an AnySchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isAnySchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ArraySchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ArraySchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isArraySchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link BooleanSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an BooleanSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isBooleanSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ContainerTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ContainerTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isContainerTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link IntegerSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an IntegerSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isIntegerSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link NullSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an NullSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isNullSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link NumberSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an NumberSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isNumberSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ObjectSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ObjectSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isObjectSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link SimpleTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an SimpleTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isSimpleTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link StringSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an StringSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isStringSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link UnionTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an UnionTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isUnionTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t * determine if this JsonSchema is an {@link ValueTypeSchema}.\n+\t *\n+\t * @return true if this JsonSchema is an ValueTypeSchema, false otherwise\n+\t */\n+\t@JsonIgnore\n+\tpublic boolean isValueTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$ref}\n+\t * \n+\t * @param $ref\n+\t *            the $ref to set\n+\t */\n+\tpublic void set$ref(String $ref) {\n+\t\tthis.$ref = $ref;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#$schema}\n+\t * \n+\t * @param $schema\n+\t *            the $schema to set\n+\t */\n+\tpublic void set$schema(String $schema) {\n+\t\tthis.$schema = $schema;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#disallow}\n+\t * \n+\t * @param disallow\n+\t *            the disallow to set\n+\t */\n+\tpublic void setDisallow(JsonSchema[] disallow) {\n+\t\tthis.disallow = disallow;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#extendsextends}\n+\t * \n+\t * @param extendsextends\n+\t *            the extendsextends to set\n+\t */\n+\t@JsonSetter(\"extends\")\n+\tpublic void setExtends(JsonSchema[] extendsextends) {\n+\t\tthis.extendsextends = extendsextends;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#id}\n+\t * \n+\t * @param id\n+\t *            the id to set\n+\t */\n+\tpublic void setId(String id) {\n+\t\tthis.id = id;\n+\t}\n+\n+\t/**\n+\t * {@link JsonSchema#required}\n+\t * \n+\t * @param required\n+\t *            the required to set\n+\t */\n+\tpublic void setRequired(Boolean required) {\n+\t\tthis.required = required;\n+\t}\n+\n+\t/**\n+\t * Create a schema which verifies only that an object is of the given format.\n+\t * @param format the format to expect\n+\t * @return the schema verifying the given format\n+\t */\n+\tpublic static JsonSchema minimalForFormat(SchemaType format) {\n+\t\tswitch (format) {\n+\t\tcase ARRAY:\n+\t\t\treturn new ArraySchema();\n+\t\tcase OBJECT:\n+\t\t\treturn new ObjectSchema();\n+\t\tcase BOOLEAN:\n+\t\t\treturn new BooleanSchema();\n+\t\tcase INTEGER:\n+\t\t\treturn new IntegerSchema();\n+\t\tcase NUMBER:\n+\t\t\treturn new NumberSchema();\n+\t\tcase STRING:\n+\t\t\treturn new StringSchema();\n+\t\tcase NULL:\n+\t\t\treturn new NullSchema();\n+\n+\t\tdefault:\n+\t\t\treturn new AnySchema();\n+\t\t}\n+\t}\n+\t\n+\tpublic static class JsonSchemaIdResolver implements TypeIdResolver {\n+\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromValue(java.lang.Object)\n+\t\t */\n+\t\tpublic String idFromValue(Object value) {\n+\t\t\tif ( value instanceof JsonSchema) {\n+\t\t\t\treturn ((JsonSchema)value).getType().value();\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromValueAndType(java.lang.Object, java.lang.Class)\n+\t\t */\n+\t\tpublic String idFromValueAndType(Object value, Class<?> suggestedType) {\n+\t\t\treturn idFromValue(value);\n+\t\t}\n+\t\t\n+\t\tprivate static JavaType any = TypeFactory.defaultInstance().constructType(AnySchema.class);\n+\t\tprivate static JavaType array = TypeFactory.defaultInstance().constructType(ArraySchema.class);\n+\t\tprivate static JavaType booleanboolean = TypeFactory.defaultInstance().constructType(BooleanSchema.class);\n+\t\tprivate static JavaType integer = TypeFactory.defaultInstance().constructType(IntegerSchema.class);\n+\t\tprivate static JavaType nullnull = TypeFactory.defaultInstance().constructType(NullSchema.class);\n+\t\tprivate static JavaType number = TypeFactory.defaultInstance().constructType(NumberSchema.class);\n+\t\tprivate static JavaType object = TypeFactory.defaultInstance().constructType(ObjectSchema.class);\n+\t\tprivate static JavaType string = TypeFactory.defaultInstance().constructType(StringSchema.class);\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#typeFromId(java.lang.String)\n+\t\t */\n+\t\tpublic JavaType typeFromId(String id) {\n+\t\t\tswitch (SchemaType.forValue(id)) {\n+\t\t\tcase ANY: \t\treturn any;\n+\t\t\tcase ARRAY: \treturn array;\n+\t\t\tcase BOOLEAN:\treturn booleanboolean;\n+\t\t\tcase INTEGER:\treturn integer;\n+\t\t\tcase NULL:\t\treturn nullnull;\n+\t\t\tcase NUMBER:\treturn number;\n+\t\t\tcase OBJECT:\treturn object;\n+\t\t\tcase STRING:\treturn string;\n+\t\t\tdefault:\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#getMechanism()\n+\t\t */\n+\t\tpublic Id getMechanism() {\n+\t\t\treturn Id.CUSTOM;\n+\t\t}\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#init(com.fasterxml.jackson.databind.JavaType)\n+\t\t */\n+\t\tpublic void init(JavaType baseType) { }\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see com.fasterxml.jackson.databind.jsontype.TypeIdResolver#idFromBaseType()\n+\t\t */\n+\t\tpublic String idFromBaseType() {\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/JsonValueFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/JsonValueFormat.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+/**\n+ * This enum represents the encoded format for a jsonSchema value type\n+ * @author jphelan\n+ *\n+ */\n public enum JsonValueFormat {\n-\t/*\n+\t/**\n \t * This SHOULD be a date in ISO 8601 format of YYYY-MM-\n       DDThh:mm:ssZ in UTC time.  This is the recommended form of date/\n       timestamp.\n \t\tpublic String toString() { return \"date-time\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be a date in the format of YYYY-MM-DD.  It is\n       recommended that you use the \"date-time\" format instead of \"date\"\n       unless you need to transfer only the date part.\n \t\tpublic String toString() { return \"date\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be a time in the format of hh:mm:ss.  It is\n       recommended that you use the \"date-time\" format instead of \"time\"\n       unless you need to transfer only the time part.\n \t\tpublic String toString() { return \"time\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be the difference, measured in\n       milliseconds, between the specified time and midnight, 00:00 of\n       January 1, 1970 UTC.  The value SHOULD be a number (integer or\n \t\tpublic String toString() { return \"utc-millisec\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * A regular expression, following the regular expression\n   \t  specification from ECMA 262/Perl 5.\n \t */\n \t\tpublic String toString() { return \"regex\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This is a CSS color (like \"#FF0000\" or \"red\"), based on CSS\n   \t\t2.1 [W3C.CR-CSS21-20070719].\n \t */\n \t\tpublic String toString() { return \"color\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This is a CSS style definition (like \"color: red; background-\n   \t\tcolor:#FFF\"), based on CSS 2.1 [W3C.CR-CSS21-20070719].\n \t */\n \t\tpublic String toString() { return \"style\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be a phone number (format MAY follow E.123).\n \t */\n \tPHONE {\n \t\tpublic String toString() { return \"phone\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This value SHOULD be a URI..\n \t */\n \tURI {\n \t\tpublic String toString() { return \"uri\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be an email address.\n \t */\n \tEMAIL {\n \t\t@Override\n \t\tpublic String toString() { return \"email\"; }\n \t},\n-\t/*\n+\t/**\n \t * This SHOULD be an ip version 4 address.\n \t */\n \tIP_ADDRESS {\n \t\tpublic String toString() { return \"ip-address\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be an ip version 6 address.\n \t */\n \tIPV6 {\n \t\tpublic String toString() { return \"ipv6\"; }\n \t},\n \t\n-\t/*\n+\t/**\n \t * This SHOULD be a host-name.\n \t */\n \tHOST_NAME {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NullSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NullSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n-import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n \n /**\n- * value must be null;\n+ * This class represents a {@link JsonSchema} as a null type\n+ * @author jphelan\n  */\n public class NullSchema extends SimpleTypeSchema {\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.NULL;\n \t\n+\t@Override\n+\tpublic NullSchema asNullSchema() { return this; }\n+\t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\treturn (obj instanceof NullSchema && super.equals(obj));\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n \t@Override\n \tpublic boolean isNullSchema() { return true; }\n \t\n-\t@Override\n-\tpublic NullSchema asNullSchema() { return this; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n+/**\n+ * This class represents a {@link JsonSchema} as a number type\n+ * @author jphelan\n+ *\n+ */\n public class NumberSchema extends ValueTypeSchema {\n \t\n \t/**\n \t@JsonProperty\n \tprivate Double minimum = null;\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.NUMBER;\n \t\n \t@Override\n \tpublic NumberSchema asNumberSchema() { return this; }\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof NumberSchema) {\n+\t\t\tNumberSchema that = (NumberSchema)obj;\n+\t\t\treturn getExclusiveMaximum() == null ? that.getExclusiveMaximum() == null :\n+\t\t\t\tgetExclusiveMaximum().equals(that.getExclusiveMaximum()) &&\n+\t\t\t\tgetExclusiveMinimum() == null ? that.getExclusiveMinimum() == null :\n+\t\t\t\t\tgetExclusiveMinimum().equals(that.getExclusiveMinimum()) &&\n+\t\t\t\tgetMaximum() == null ? that.getMaximum() == null :\n+\t\t\t\t\tgetMaximum().equals(that.getMaximum()) &&\n+\t\t\t\tgetMinimum() == null ? that.getMinimum() == null :\n+\t\t\t\t\tgetMinimum().equals(that.getMinimum()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n \t/**\n \t * {@link NumberSchema#exclusiveMaximum}\n \t * @return the exclusiveMaximum\n \t}\n \t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n import java.util.List;\n import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n \n+/**\n+ * This type represents a {@link JsonSchema} as an object type\n+ * @author jphelan\n+ *\n+ */\n public class ObjectSchema extends ContainerTypeSchema {\n \n \t/**\n-\t * This attribute defines a schema for all properties that are not\n+\t * This attribute defines a jsonSchema for all properties that are not\n \t * explicitly defined in an object type definition. If specified, the value\n-\t * MUST be a schema or a boolean. If false is provided, no additional\n-\t * properties are allowed beyond the properties defined in the schema. The\n-\t * default value is an empty schema which allows any value for additional\n+\t * MUST be a jsonSchema or a boolean. If false is provided, no additional\n+\t * properties are allowed beyond the properties defined in the jsonSchema. The\n+\t * default value is an empty jsonSchema which allows any value for additional\n \t * properties.\n \t */\n \t@JsonProperty\n \n \t/**\n \t * \n-\t This attribute is an object that defines the schema for a set of property\n+\t This attribute is an object that defines the jsonSchema for a set of property\n \t * names of an object instance. The name of each property of this\n \t * attribute's object is a regular expression pattern in the ECMA 262/Perl 5\n-\t * format, while the value is a schema. If the pattern matches the name of a\n+\t * format, while the value is a jsonSchema. If the pattern matches the name of a\n \t * property on the instance object, the value of the instance's property\n-\t * MUST be valid against the pattern name's schema value.\n+\t * MUST be valid against the pattern name's jsonSchema value.\n \t */\n \t@JsonProperty\n-\tprivate Map<String, Schema> patternProperties;\n+\tprivate Map<String, JsonSchema> patternProperties;\n \n \t/**\n \t * This attribute is an object with property definitions that define the\n \t * valid values of instance object property values. When the instance value\n \t * is an object, the property values of the instance object MUST conform to\n \t * the property definitions in this object. In this object, each property\n-\t * definition's value MUST be a schema, and the property's name MUST be the\n+\t * definition's value MUST be a jsonSchema, and the property's name MUST be the\n \t * name of the instance property that it defines. The instance property\n-\t * value MUST be valid according to the schema from the property definition.\n+\t * value MUST be valid according to the jsonSchema from the property definition.\n \t * Properties are considered unordered, the order of the instance properties\n \t * MAY be in any order.\n \t */\n \t@JsonProperty\n-\tprivate Map<String, Schema> properties;\n-\n-\t@JsonProperty(required = true)\n+\tprivate Map<String, JsonSchema> properties;\n+\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.OBJECT;\n \n \t// instance initializer block\n \t{\n \t\tdependencies = new ArrayList<Dependency>();\n-\t\tpatternProperties = new HashMap<String, Schema>();\n-\t\tproperties = new HashMap<String, Schema>();\n-\t}\n-\n-\tpublic boolean addSchemaDependency(String depender, Schema parentMustMatch) {\n+\t\tpatternProperties = new HashMap<String, JsonSchema>();\n+\t\tproperties = new HashMap<String, JsonSchema>();\n+\t}\n+\n+\tpublic boolean addSchemaDependency(String depender, JsonSchema parentMustMatch) {\n \t\treturn dependencies\n \t\t\t\t.add(new SchemaDependency(depender, parentMustMatch));\n \t}\n \t\treturn dependencies.add(new SimpleDependency(depender, dependsOn));\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asObjectSchema()\n+\t */\n \t@Override\n \tpublic ObjectSchema asObjectSchema() {\n \t\treturn this;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ObjectSchema) {\n+\t\t\tObjectSchema that = (ObjectSchema) obj;\n+\t\t\treturn getAdditionalProperties() == null ? that.getAdditionalProperties() == null :\n+\t\t\t\t\t\tgetAdditionalProperties().equals(that.getAdditionalProperties()) &&\n+\t\t\t\t\tgetDependencies() == null ? that.getDependencies() == null :\n+\t\t\t\t\t\tgetDependencies().equals(that.getDependencies()) &&\n+\t\t\t\t\tgetPatternProperties() == null ? that.getPatternProperties() == null :\n+\t\t\t\t\t\tgetPatternProperties().equals(that.getPatternProperties()) &&\n+\t\t\t\t\tgetProperties() == null ? that.getProperties() == null :\n+\t\t\t\t\t\tgetProperties().equals(that.getProperties()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\t\n \t/**\n \t * {@link ObjectSchema#additionalProperties}\n \t * \n \t * \n \t * @return the patternProperties\n \t */\n-\tpublic Map<String, Schema> getPatternProperties() {\n+\tpublic Map<String, JsonSchema> getPatternProperties() {\n \t\treturn patternProperties;\n \t}\n \n \t * \n \t * @return the properties\n \t */\n-\tpublic Map<String, Schema> getProperties() {\n+\tpublic Map<String, JsonSchema> getProperties() {\n \t\treturn properties;\n \t}\n \n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n \t\treturn type;\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isObjectSchema()\n+\t */\n \t@Override\n \tpublic boolean isObjectSchema() {\n \t\treturn true;\n \t}\n \n-\tpublic void putOptionalProperty(String name, Schema schema) {\n-\t\tproperties.put(name, schema);\n-\t}\n-\n-\tpublic Schema putPatternProperty(String regex, Schema value) {\n+\tpublic void putOptionalProperty(String name, JsonSchema jsonSchema) {\n+\t\tproperties.put(name, jsonSchema);\n+\t}\n+\n+\tpublic JsonSchema putPatternProperty(String regex, JsonSchema value) {\n \t\treturn patternProperties.put(regex, value);\n \t}\n \n-\tpublic Schema putProperty(String name, Schema value) {\n+\tpublic JsonSchema putProperty(String name, JsonSchema value) {\n \t\tvalue.setRequired(true);\n \t\treturn properties.put(name, value);\n \t}\n \t * @param patternProperties\n \t *            the patternProperties to set\n \t */\n-\tpublic void setPatternProperties(Map<String, Schema> patternProperties) {\n+\tpublic void setPatternProperties(Map<String, JsonSchema> patternProperties) {\n \t\tthis.patternProperties = patternProperties;\n \t}\n \n \t * @param properties\n \t *            the properties to set\n \t */\n-\tpublic void setProperties(Map<String, Schema> properties) {\n+\tpublic void setProperties(Map<String, JsonSchema> properties) {\n \t\tthis.properties = properties;\n \t}\n \n \tpublic static abstract class AdditionalProperties {\n+\t\t\n+\t\t@JsonCreator\n+\t\tpublic AdditionalProperties jsonCreator() {\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\treturn null;\n+\t\t}\n \t}\n \n \tpublic static abstract class Dependency {\n+\t\t@JsonCreator\n+\t\tpublic Dependency jsonCreator() {\n+\t\t\t//KNOWN ISSUE: pending https://github.com/FasterXML/jackson-databind/issues/43\n+\t\t\treturn null;\n+\t\t}\n \t}\n \n \tpublic static class NoAdditionalProperties extends AdditionalProperties {\n \t\tpublic final Boolean schema = false;\n \n \t\tprotected NoAdditionalProperties() {\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof NoAdditionalProperties;\n \t\t}\n \n \t\t@JsonValue\n \tpublic static class SchemaAdditionalProperties extends AdditionalProperties {\n \n \t\t@JsonProperty\n-\t\tprivate Schema schema;\n-\n-\t\tpublic SchemaAdditionalProperties(Schema schema) {\n-\t\t\tthis.schema = schema;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Schema Dependency If the dependency value is a schema, then the instance\n-\t * object MUST be valid against the schema.\n+\t\tprivate JsonSchema jsonSchema;\n+\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn obj instanceof SchemaAdditionalProperties &&\n+\t\t\t\t\tgetJsonSchema() == null ? ((SchemaAdditionalProperties)obj).getJsonSchema() == null :\n+\t\t\t\t\t\tgetJsonSchema().equals(((SchemaAdditionalProperties)obj).getJsonSchema());\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaAdditionalProperties#jsonSchema}\n+\t\t * @return the jsonSchema\n+\t\t */\n+\t\tpublic JsonSchema getJsonSchema() {\n+\t\t\treturn jsonSchema;\n+\t\t}\n+\t\t\n+\t\tpublic SchemaAdditionalProperties(JsonSchema jsonSchema) {\n+\t\t\tthis.jsonSchema = jsonSchema;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * JsonSchema Dependency If the dependency value is a jsonSchema, then the instance\n+\t * object MUST be valid against the jsonSchema.\n \t */\n \tpublic static class SchemaDependency extends Dependency {\n \n \t\tprivate String depender;\n \n \t\t@JsonProperty(required = true)\n-\t\tprivate Schema parentMustMatch;\n-\n-\t\tpublic SchemaDependency(String depender, Schema parentMustMatch) {\n+\t\tprivate JsonSchema parentMustMatch;\n+\n+\t\tpublic SchemaDependency(String depender, JsonSchema parentMustMatch) {\n \t\t\tthis.depender = depender;\n \t\t\tthis.parentMustMatch = parentMustMatch;\n+\t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof SchemaDependency) {\n+\t\t\t\tSchemaDependency that = (SchemaDependency) obj;\n+\t\t\t\treturn getDepender() == null ? that.getDepender() == null :\n+\t\t\t\t\t\tgetDepender().equals(that.getDepender()) &&\n+\t\t\t\t\tgetParentMustMatch() == null ? that.getParentMustMatch() == null :\n+\t\t\t\t\t\tgetParentMustMatch().equals(that.getParentMustMatch());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaDependency#depender}\n+\t\t * @return the depender\n+\t\t */\n+\t\tpublic String getDepender() {\n+\t\t\treturn depender;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SchemaDependency#parentMustMatch}\n+\t\t * @return the parentMustMatch\n+\t\t */\n+\t\tpublic JsonSchema getParentMustMatch() {\n+\t\t\treturn parentMustMatch;\n \t\t}\n \t}\n \n \t\t\tthis.depender = depender;\n \t\t\tthis.dependsOn = dependsOn;\n \t\t}\n+\t\t\n+\t\t/* (non-Javadoc)\n+\t\t * @see java.lang.Object#equals(java.lang.Object)\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj instanceof SchemaDependency) {\n+\t\t\t\tSimpleDependency that = (SimpleDependency) obj;\n+\t\t\t\treturn getDepender() == null ? that.getDepender() == null :\n+\t\t\t\t\t\tgetDepender().equals(that.getDepender()) &&\n+\t\t\t\t\tgetDependsOn() == null ? that.getDependsOn() == null :\n+\t\t\t\t\t\tgetDependsOn().equals(that.getDependsOn());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SimpleDependency#depender}\n+\t\t * @return the depender\n+\t\t */\n+\t\tpublic String getDepender() {\n+\t\t\treturn depender;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * {@link ObjectSchema.SimpleDependency#dependsOn}\n+\t\t * @return the dependsOn\n+\t\t */\n+\t\tpublic String getDependsOn() {\n+\t\t\treturn dependsOn;\n+\t\t}\n \t}\n \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonSetter;\n \n-public abstract class SimpleTypeSchema extends Schema {\n+/**\n+ * This class encapsulates the functionality of {@link JsonSchema} simple types\n+ * @author jphelan\n+ *\n+ */\n+public abstract class SimpleTypeSchema extends JsonSchema {\n \n \t/**\n \t * This attribute defines the default value of the instance when the\n \t@JsonProperty\n \tprivate String title;\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asSimpleTypeSchema()\n+\t */\n \t@Override\n \tpublic SimpleTypeSchema asSimpleTypeSchema() {\n \t\treturn this;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof SimpleTypeSchema) {\n+\t\t\tSimpleTypeSchema that = (SimpleTypeSchema)obj;\n+\t\t\treturn getDefault() == null ? that.getDefault() == null :\n+\t\t\t\tgetDefault().equals(that.getDefault()) &&\n+\t\t\t\tgetDescription() == null ? that.getDescription() == null :\n+\t\t\t\t\tgetDescription().equals(that.getDescription()) &&\n+\t\t\t\tgetTitle() == null ? that.getTitle() == null :\n+\t\t\t\t\tgetTitle().equals(that.getTitle()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n+\t\n \t/**\n \t * {@link SimpleTypeSchema#defaultdefault}\n \t * \n \t\treturn title;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isSimpleTypeSchema()\n+\t */\n \t@Override\n \tpublic boolean isSimpleTypeSchema() {\n \t\treturn true;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n+/**\n+ * This represents a {@link JsonSchema} as a String\n+ * @author jphelan\n+ *\n+ */\n public class StringSchema extends ValueTypeSchema {\n \n \t/** this defines the maximum length of the string. */\n \t@JsonProperty\n \tprivate String pattern;\n \t\n-\t@JsonProperty(required = true)\n+\t@JsonIgnore\n \tprivate final SchemaType type = SchemaType.STRING;\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asStringSchema()\n+\t */\n \t@Override\n \tpublic StringSchema asStringSchema() {\n \t\treturn this;\n \t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof StringSchema) {\n+\t\t\tStringSchema that = (StringSchema)obj;\n+\t\t\treturn getMaxLength() == null ? that.getMaxLength() == null :\n+\t\t\t\tgetMaxLength().equals(that.getMaxLength()) &&\n+\t\t\t\tgetMinLength() == null ? that.getMinLength() == null :\n+\t\t\t\t\tgetMinLength().equals(that.getMinLength()) &&\n+\t\t\t\tgetPattern() == null ? that.getPattern() == null :\n+\t\t\t\t\tgetPattern().equals(that.getPattern()) &&\n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t} \n+\t\n \n \t/**\n \t * {@link StringSchema#maxLength}\n \t}\n \t\n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n \t\treturn type;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isStringSchema()\n+\t */\n \t@Override\n \tpublic boolean isStringSchema() {\n \t\treturn true;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n \n-public class UnionTypeSchema extends Schema {\n+/**\n+ * This class represents a {@link JsonSchema} as a Union Type Schema:\n+ * \"An array of two or more simple type definitions.  Each\n+      item in the array MUST be a simple type definition or a schema.\n+      The instance value is valid if it is of the same type as one of\n+      the simple type definitions, or valid by one of the schemas, in\n+      the array.\"\n+\n+ * @author jphelan\n+ *\n+ */\n+public class UnionTypeSchema extends JsonSchema {\n \n \t@JsonProperty\n \tprivate ValueTypeSchema[] elements;\n \t\treturn this;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof UnionTypeSchema) {\n+\t\t\tUnionTypeSchema that = (UnionTypeSchema) obj;\n+\t\t\treturn getElements() == null ? that.getElements() == null :\n+\t\t\t\tgetElements().equals(that.getElements()) && \n+\t\t\t\tsuper.equals(obj);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * {@link UnionTypeSchema#elements}\n \t * \n \t}\n \n \t/* (non-Javadoc)\n-\t * @see com.fasterxml.jackson.databind.jsonschema.types.Schema#getType()\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#getType()\n \t */\n \t@Override\n \tpublic SchemaType getType() {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n /**\n-* A primitive type. \n-*/\n+ * This class represents a {@link JsonSchema} \n+ * A primitive type. \n+ */\n public abstract class ValueTypeSchema extends SimpleTypeSchema {\n \t\t\t\n \t/**\n \t\tenums = new HashSet<String>();\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#asValueSchemaSchema()\n+\t */\n \t@Override\n \tpublic ValueTypeSchema asValueSchemaSchema() { return this; }\n \n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#equals(java.lang.Object)\n+\t */\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj instanceof ValueTypeSchema) {\n+\t\t\tValueTypeSchema that = (ValueTypeSchema) obj;\n+\t\t\treturn getEnums() == null ? that.getEnums() == null :\n+\t\t\t\t\t\tgetEnums().equals(that.getEnums()) &&\n+\t\t\t\t\tgetFormat() == null ? that.getFormat() == null :\n+\t\t\t\t\t\tgetFormat().equals(that.getFormat()) &&\n+\t\t\t\t\tsuper.equals(obj);\n+\t\t}\t\n+\t\treturn false;\n+\t}\n \t\n \t/**\n \t * {@link ValueTypeSchema#enums}\n \tpublic JsonValueFormat getFormat() {\n \t\treturn format;\n \t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see com.fasterxml.jackson.databind.jsonschema.types.JsonSchema#isValueTypeSchema()\n+\t */\n \t@Override\n \tpublic boolean isValueTypeSchema() { return true; }\n \t\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/visitors/JsonArrayFormatVisitor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/visitors/JsonArrayFormatVisitor.java\n package com.fasterxml.jackson.databind.jsonschema.visitors;\n \n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n \n public interface JsonArrayFormatVisitor {\n \n \tvoid itemsFormat(SchemaType format);\n \n-\tvoid itemsFormat(SchemaAware toVisit);\n+\tvoid itemsFormat(JsonFormatVisitorAware toVisit);\n \t\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/visitors/JsonObjectFormatVisitor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/visitors/JsonObjectFormatVisitor.java\n \n \n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n \n public interface JsonObjectFormatVisitor extends JsonFormatVisitor {\n \n \tpublic void optionalProperty(BeanPropertyWriter writer);\n \n-\tpublic void property(String name, SchemaAware handler, JavaType propertyTypeHint);\n+\tpublic void property(String name, JsonFormatVisitorAware handler, JavaType propertyTypeHint);\n \n-\tpublic void optionalProperty(String name, SchemaAware handler,\n+\tpublic void optionalProperty(String name, JsonFormatVisitorAware handler,\n \t\t\tJavaType propertyTypeHint);\n \n \tpublic void property(String name);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n          * type information it needs is accessible via \"untyped\" serializer)\n          */\n         JsonSerializer<Object> ser = findValueSerializer(type, null);\n-        if (ser instanceof SchemaAware) {\n-        \t((SchemaAware) ser).acceptJsonFormatVisitor(visitor, constructType(type));\n+        if (ser instanceof JsonFormatVisitorAware) {\n+        \t((JsonFormatVisitorAware) ser).acceptJsonFormatVisitor(visitor, constructType(type));\n         } else {\n         \tvisitor.anyFormat();\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n-import java.lang.reflect.Type;\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n public abstract class BeanSerializerBase\n     extends StdSerializer<Object>\n     implements ContextualSerializer, ResolvableSerializer,\n-        SchemaAware\n+        JsonFormatVisitorAware\n {\n     final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n \n     public void acceptJsonFormatVisitor(JsonFormatVisitor visitor, JavaType typeHint)\n     {\n     \tJsonObjectFormatVisitor objectVisitor = visitor.objectFormat(typeHint);\n-        // [JACKSON-813]: Add optional JSON Schema id attribute, if found\n-        // NOTE: not optimal, does NOT go through AnnotationIntrospector etc:\n-        JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class);\n-        if (ann != null) {\n-            String id = ann.id();\n-            if (id != null && id.length() > 0) {\n-                //o.put(\"id\", id); what is this?\n-                //objectVisitor.expect??\n-            }\n-        }\n  \n         BeanPropertyFilter filter;\n         if (_propertyFilterId != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n                 \tString name = visitor.getProvider().getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue);\n                 \ttry {\n                 \t\tser = visitor.getProvider().findValueSerializer(valueType.getRawClass(), _property);\n-                \t\tif (ser instanceof SchemaAware)  {\n-                \t\t\tobjectVisitor.property(name, (SchemaAware) ser, valueType);\n+                \t\tif (ser instanceof JsonFormatVisitorAware)  {\n+                \t\t\tobjectVisitor.property(name, (JsonFormatVisitorAware) ser, valueType);\n                 \t\t} \n                 \t\tcontinue;\n                 \t} catch (JsonMappingException e) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n @JacksonStdImpl\n public class JsonValueSerializer\n     extends StdSerializer<Object>\n-    implements ContextualSerializer, SchemaAware\n+    implements ContextualSerializer, JsonFormatVisitorAware\n {\n     protected final Method _accessorMethod;\n \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitor visitor, JavaType typeHint)\n     {\n-    \tif (_valueSerializer instanceof SchemaAware) {\n-    \t\t((SchemaAware) _valueSerializer).acceptJsonFormatVisitor(visitor, null); \n+    \tif (_valueSerializer instanceof JsonFormatVisitorAware) {\n+    \t\t((JsonFormatVisitorAware) _valueSerializer).acceptJsonFormatVisitor(visitor, null); \n     \t} else {\n     \t\tvisitor.anyFormat();\n     \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n-import com.fasterxml.jackson.databind.jsonschema.visitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n-import com.fasterxml.jackson.databind.type.ArrayType;\n \n /**\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n \n \n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.visitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Generic handler for types that implement {@link JsonSerializable}.\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitor visitor, JavaType typeHint)\n     {\n-        if (typeHint == null) {\n-        \tvisitor.anyFormat();\n-        } else  {\n-            Class<?> rawClass = typeHint.getRawClass();\n-            if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n-                JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n-                \n-                if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) {\n-                \tvisitor.objectFormat(typeHint);\n-                    //objectProperties = schemaInfo.schemaObjectPropertiesDefinition();\n-                } else \n-                if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) {\n-                    visitor.arrayFormat(typeHint);\n-                \t//itemDefinition = schemaInfo.schemaItemDefinition();\n-                } else {\n-                \tvisitor.anyFormat();\n-                \t//visitor.forFormat(SchemaType.valueOf(schemaInfo.schemaType()));\n-                }\n-            } else {\n-            \tvisitor.anyFormat();\n-            }\n-        } \n-        /* 19-Mar-2012, tatu: geez, this is butt-ugly abonimation of code...\n-         *    really, really should not require back ref to an ObjectMapper.\n-         */\n-//        objectNode.put(\"type\", schemaType);\n-//        if (objectProperties != null) {\n-//            try {\n-//                objectNode.put(\"properties\", _getObjectMapper().readTree(objectProperties));\n-//            } catch (IOException e) {\n-//                throw new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value\");\n-//            }\n-//        }\n-//        if (itemDefinition != null) {\n-//            try {\n-//                objectNode.put(\"items\", _getObjectMapper().readTree(itemDefinition));\n-//            } catch (IOException e) {\n-//                throw new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaItemDefinition value\");\n-//            }\n-//        }\n-\n+    \tvisitor.anyFormat();\n     }\n-    \n-    private final static synchronized ObjectMapper _getObjectMapper()\n-    {\n-        ObjectMapper mapper = _mapperReference.get();\n-        if (mapper == null) {\n-            mapper = new ObjectMapper();\n-            _mapperReference.set(mapper);\n-        }\n-        return mapper;\n     }\n-}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonFormatVisitor;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n  * Base class used by all standard serializers, and can also\n  * be used for custom serializers (in fact, this is the recommended\n  * base class to use).\n- * Provides convenience methods for implementing {@link SchemaAware}\n+ * Provides convenience methods for implementing {@link JsonFormatVisitorAware}\n  */\n public abstract class StdSerializer<T>\n     extends JsonSerializer<T>\n-    implements SchemaAware\n+    implements JsonFormatVisitorAware\n {\n     /**\n      * Nominal type supported, usually declared type of\n \n     /*\n     /**********************************************************\n-    /* Helper methods for JSON Schema generation\n+    /* Helper methods for JSON JsonSchema generation\n     /**********************************************************\n      */\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n     \tDefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();\n         ObjectMapper m = new ObjectMapper();\n         m.setSerializerProvider(sp);\n-        Schema schema = m.generateJsonSchema(SimpleBean.class);\n-        \n-        assertNotNull(schema);\n+        JsonSchema jsonSchema = m.generateJsonSchema(SimpleBean.class);\n+        \n+        assertNotNull(jsonSchema);\n \n         // test basic equality, and that equals() handles null, other obs\n-        assertTrue(schema.equals(schema));\n-        assertFalse(schema.equals(null));\n-        assertFalse(schema.equals(\"foo\"));\n-\n-        assertTrue(schema.isObjectSchema());\n-        ObjectSchema object = schema.asObjectSchema();\n+        assertTrue(jsonSchema.equals(jsonSchema));\n+        assertFalse(jsonSchema.equals(null));\n+        assertFalse(jsonSchema.equals(\"foo\"));\n+\n+        assertTrue(jsonSchema.isObjectSchema());\n+        ObjectSchema object = jsonSchema.asObjectSchema();\n         assertNotNull(object);\n-        Map<String,Schema> properties = object.getProperties();\n+        Map<String,JsonSchema> properties = object.getProperties();\n         assertNotNull(properties);\n-        Schema prop1 = properties.get(\"property1\");\n+        JsonSchema prop1 = properties.get(\"property1\");\n         assertNotNull(prop1);\n         assertTrue(prop1.isIntegerSchema());\n         assertNull(prop1.getRequired());\n         \n-        Schema prop2 = properties.get(\"property2\");\n+        JsonSchema prop2 = properties.get(\"property2\");\n         assertNotNull(prop2);\n         assertTrue(prop2.isStringSchema());\n         assertNull(prop2.getRequired());\n         \n-        Schema prop3 = properties.get(\"property3\");\n+        JsonSchema prop3 = properties.get(\"property3\");\n         assertNotNull(prop3);\n         assertTrue(prop3.isArraySchema());\n         assertNull(prop3.getRequired());\n         Items items = prop3.asArraySchema().getItems();\n         assertTrue(items.isSingleItems());\n-        Schema itemType = items.asSingleItems().getSchema();\n+        JsonSchema itemType = items.asSingleItems().getSchema();\n         assertNotNull(itemType);\n         assertTrue(itemType.isStringSchema());\n         \n-        Schema prop4 = properties.get(\"property4\");\n+        JsonSchema prop4 = properties.get(\"property4\");\n         assertNotNull(prop4);\n         assertTrue(prop4.isArraySchema());\n         assertNull(prop4.getRequired());\n         assertNotNull(itemType);\n         assertTrue(itemType.isNumberSchema());\n         \n-        Schema prop5 = properties.get(\"property5\");\n+        JsonSchema prop5 = properties.get(\"property5\");\n         assertNotNull(prop5);\n         assertTrue(prop5.getRequired());\n       \n     public void testGeneratingJsonSchemaWithFilters() throws Exception {\n     \tObjectMapper mapper = new ObjectMapper();\n     \tmapper.setFilters(secretFilterProvider);\n-    \tSchema schema = mapper.generateJsonSchema(FilteredBean.class);\n-    \tassertNotNull(schema);\n-    \tassertTrue(schema.isObjectSchema());\n-    \tObjectSchema object = schema.asObjectSchema();\n+    \tJsonSchema jsonSchema = mapper.generateJsonSchema(FilteredBean.class);\n+    \tassertNotNull(jsonSchema);\n+    \tassertTrue(jsonSchema.isObjectSchema());\n+    \tObjectSchema object = jsonSchema.asObjectSchema();\n     \tassertNotNull(object);\n-    \tMap<String, Schema> properties = object.getProperties();\n+    \tMap<String, JsonSchema> properties = object.getProperties();\n     \tassertNotNull(properties);\n-    \tSchema obvious = properties.get(\"obvious\");\n+    \tJsonSchema obvious = properties.get(\"obvious\");\n     \tassertNotNull(obvious);\n     \tassertTrue(obvious.isStringSchema());\n     \tassertNull(properties.get(\"secret\"));\n     public void testSchemaSerialization()\n             throws Exception\n     {\n-        Schema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n         Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n         assertNotNull(result);\n         // no need to check out full structure, just basics...\n      */\n     public void testThatObjectsHaveNoItems() throws Exception\n     {\n-        Schema jsonSchema = MAPPER.generateJsonSchema(TrivialBean.class);\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(TrivialBean.class);\n         Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n         // can we count on ordering being stable? I think this is true with current ObjectNode impl\n         // as perh [JACKSON-563]; 'required' is only included if true\n \n     }\n \n-    public void testSchemaId() throws Exception\n-    {\n-        Schema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\", \"serial\" })\n+\tpublic void testSchemaId() throws Exception\n+    {\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class);\n         Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n         \n         assertEquals(new HashMap() {{ \n         \tput(\"type\", \"object\");\n-        \tput(\"id\", \"myType\");\n+        \t//put(\"id\", \"myType\"); /* This is not a correct use of id. see \"http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.27\" */\n         \tput(\"properties\", \n         \t\t\tnew HashMap(){{ put(\"value\", \n         \t\t\t\t\tnew HashMap() {{ put(\"type\", \"string\");}}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n+import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n \n /**\n  * Trivial test to ensure {@link JsonSchema} can be also deserialized\n     public void testDeserializeSimple() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        Schema schema = mapper.generateJsonSchema(Schemable.class);\n-        assertNotNull(schema);\n+        JsonSchema jsonSchema = mapper.generateJsonSchema(Schemable.class);\n+        assertNotNull(jsonSchema);\n \n-        String schemaStr = mapper.writeValueAsString(schema);\n+        String schemaStr = mapper.writeValueAsString(jsonSchema);\n         assertNotNull(schemaStr);\n         JsonSchema result = mapper.readValue(schemaStr, JsonSchema.class);\n-        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", schema, result);\n+        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", jsonSchema, result);\n     }\n }", "timestamp": 1344044514, "metainfo": ""}