{"sha": "f0b28a96644b3dc22c997a05975de335dfed0418", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             throws JsonMappingException;\n     \n     @Override\n-    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerCache p,\n+    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n             ArrayType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     \n     @Override\n     public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n-            DeserializerCache p,\n             CollectionType type, BeanProperty property)\n         throws JsonMappingException\n     {\n             // One special type: EnumSet:\n             if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                 return new EnumSetDeserializer(contentType.getRawClass(),\n-                        createEnumDeserializer(config, p, contentType, property));\n+                        createEnumDeserializer(config, contentType, property));\n             }\n         }\n         \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            DeserializerCache p, CollectionLikeType type, BeanProperty property)\n+            CollectionLikeType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: global defaulting:\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config, DeserializerCache p,\n+    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n             MapType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         \n         // Ok: need a key deserializer (null indicates 'default' here)\n         KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n-        if (keyDes == null) {\n-            keyDes = p.findKeyDeserializer(config, keyType, property);\n-        }\n         // Then optional type info (1.5); either attached to type, or resolved separately:\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n                 throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n             }\n             return new EnumMapDeserializer(type, property,\n-                    createEnumDeserializer(config, p, keyType, property),\n+                    createEnumDeserializer(config, keyType, property),\n                     contentDeser);\n         }\n \n     // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            DeserializerCache p, MapLikeType type, BeanProperty property)\n+            MapLikeType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: global defaulting:\n         \n         // Ok: need a key deserializer (null indicates 'default' here)\n         KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n+        /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!\n         if (keyDes == null) {\n             keyDes = p.findKeyDeserializer(config, keyType, property);\n         }\n+        */\n         // Then optional type info (1.5); either attached to type, or resolve separately:\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n      * Factory method for constructing serializers of {@link Enum} types.\n      */\n     @Override\n-    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config, DeserializerCache p,\n+    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     }\n \n     @Override\n-    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerCache p,\n+    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n             JavaType nodeType, BeanProperty property)\n         throws JsonMappingException\n     {\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> findStdBeanDeserializer(DeserializationConfig config,\n-            DeserializerCache p, JavaType type, BeanProperty property)\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         Class<?> cls = type.getRawClass();\n             return (JsonDeserializer<Object>)d2;\n         }\n         // [JACKSON-386]: External/optional type handlers are handled somewhat differently\n-        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, config, p);\n+        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, config);\n         if (d != null) {\n             return (JsonDeserializer<Object>)d;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n     // Note: NOT overriding, superclass has no matching method\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config,\n-            DeserializerCache provider, BeanDescription beanDesc, BeanProperty property)\n+            BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         for (Deserializers d  : _factoryConfig.deserializers()) {\n      */\n     @Override\n     public JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n-            DeserializerCache p, JavaType type, BeanProperty property)\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First things first: abstract types may use defaulting:\n             beanDesc = config.introspect(type);\n         }\n         // We may also have custom overrides:\n-        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, p, beanDesc, property);\n+        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc, property);\n         if (custom != null) {\n             return custom;\n         }\n         }\n \n         // Otherwise, may want to check handlers for standard types, from superclass:\n-        JsonDeserializer<Object> deser = findStdBeanDeserializer(config, p, type, property);\n+        JsonDeserializer<Object> deser = findStdBeanDeserializer(config, type, property);\n         if (deser != null) {\n             return deser;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n         throws JsonMappingException\n     {\n         if (type.isEnumType()) {\n-            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, this, type, property);\n+            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, type, property);\n         }\n         if (type.isContainerType()) {\n             if (type.isArrayType()) {\n-                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config, this,\n+                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config,\n                         (ArrayType) type, property);\n             }\n             if (type.isMapLikeType()) {\n                 MapLikeType mlt = (MapLikeType) type;\n                 if (mlt.isTrueMapType()) {\n-                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(config, this,\n+                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(config,\n                             (MapType) mlt, property);\n                 }\n-                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config, this,\n+                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config,\n                         mlt, property);\n             }\n             if (type.isCollectionLikeType()) {\n                 CollectionLikeType clt = (CollectionLikeType) type;\n                 if (clt.isTrueCollectionType()) {\n-                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config, this,\n+                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config,\n                             (CollectionType) clt, property);\n                 }\n-                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config, this,\n+                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config,\n                         clt, property);\n             }\n         }\n \n         // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n-            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, this, type, property);\n-        }\n-        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, this, type, property);\n+            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, type, property);\n+        }\n+        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, type, property);\n     }\n \n     protected void _resolveDeserializer(DeserializationContext ctxt, ResolvableDeserializer ser)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n      * this method can be overridden to add support for custom types.\n      *\n      * @param type Type to be deserialized\n-     * @param p Provider that can be called to create deserializers for\n-     *   contained member types\n-     */\n-    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config, DeserializerCache p,\n+     */\n+    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n      * specified Java type.\n      *\n      * @param type Type to be deserialized\n-     * @param p Provider that can be called to create deserializers for\n-     *   contained member types\n-     */\n-    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerCache p,\n+     */\n+    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n             ArrayType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n-            DeserializerCache p, CollectionType type, BeanProperty property)\n+            CollectionType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            DeserializerCache p, CollectionLikeType type, BeanProperty property)\n+            CollectionLikeType type, BeanProperty property)\n         throws JsonMappingException;\n     \n     public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n-            DeserializerCache p, JavaType type, BeanProperty property)\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n-            DeserializerCache p, MapType type, BeanProperty property)\n+            MapType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            DeserializerCache p, MapLikeType type, BeanProperty property)\n+            MapLikeType type, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * Method called to create and return a deserializer that can construct\n      * JsonNode(s) from JSON content.\n      */\n-    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerCache p,\n+    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n      * @return Key deserializer to use for specified type, if one found; null if not\n      *   (and default key deserializer should be used)\n      */\n-    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n-            BeanProperty property)\n+    public KeyDeserializer createKeyDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Default implementation returns null for backwards compatibility reasons\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     protected final BeanProperty _property;\n     \n     /**\n-     * Key deserializer used, if not null. If null, String from JSON\n-     * content is used as is.\n-     */\n-    protected final KeyDeserializer _keyDeserializer;\n-\n+     * Key deserializer to use; either passed via constructor\n+     * (when indicated by annotations), or resolved when\n+     * {@link #resolve} is called;\n+     */\n+    protected KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Flag set to indicate that the key type is\n+     * {@link java.lang.String} (or {@link java.lang.Object}, for\n+     * which String is acceptable), <b>and</b> that the\n+     * default Jackson key deserializer would be used.\n+     * If both are true, can optimize handling.\n+     */\n+    protected boolean _standardStringKey;\n+    \n     /**\n      * Value deserializer.\n      */\n                 }\n             }\n         }\n+        if (_keyDeserializer == null) {\n+            _keyDeserializer = ctxt.findKeyDeserializer(_mapType.getKeyType(), _property);\n+        }\n+        Class<?> raw = _mapType.getKeyType().getRawClass();\n+        _standardStringKey =  (raw == String.class || raw == Object.class)\n+            && isDefaultKeyDeserializer(_keyDeserializer);\n         if (_valueDeserializer == null) {\n             _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n         }\n             throw ctxt.mappingException(getMapClass());\n         }\n         final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n+        if (_standardStringKey) {\n+            _readAndBindStringMap(jp, ctxt, result);\n+            return result;\n+        }\n         _readAndBind(jp, ctxt, result);\n         return result;\n     }\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             throw ctxt.mappingException(getMapClass());\n         }\n+        if (_standardStringKey) {\n+            _readAndBindStringMap(jp, ctxt, result);\n+            return result;\n+        }\n         _readAndBind(jp, ctxt, result);\n         return result;\n     }\n      */\n \n     protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n-                                      Map<Object,Object> result)\n+            Map<Object,Object> result)\n         throws IOException, JsonProcessingException\n     {\n         JsonToken t = jp.getCurrentToken();\n             t = jp.nextToken();\n         }\n         final KeyDeserializer keyDes = _keyDeserializer;\n+        \n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n         }\n     }\n \n+    /**\n+     * Optimized method used when keys can be deserialized as plain old\n+     * {@link java.lang.String}s, and there is no custom deserialized\n+     * specified.\n+     */\n+    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt,\n+            Map<Object,Object> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            // Must point to field name\n+            String fieldName = jp.getCurrentName();\n+            // And then the value...\n+            t = jp.nextToken();\n+            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // Note: must handle null explicitly here; value deserializers won't\n+            Object value;            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+            result.put(fieldName, value);\n+        }\n+    }\n+    \n     @SuppressWarnings(\"unchecked\") \n     public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n      * a module or calling application. Determination is done using\n      * {@link JacksonStdImpl} annotation on deserializer class.\n      */\n-    protected boolean isDefaultSerializer(JsonDeserializer<?> deserializer)\n-    {\n+    protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) {\n         return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null);\n+    }\n+\n+    protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) {\n+        return (keyDeser != null && keyDeser.getClass().getAnnotation(JacksonStdImpl.class) != null);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n     /**********************************************************\n      */\n \n+    @JacksonStdImpl\n     final static class StringKD extends StdKeyDeserializer\n     {\n         private final static StringKD sString = new StringKD(String.class);\n     /**********************************************************\n      */\n \n+    @JacksonStdImpl\n     final static class BoolKD extends StdKeyDeserializer\n     {\n         BoolKD() { super(Boolean.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class ByteKD extends StdKeyDeserializer\n     {\n         ByteKD() { super(Byte.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class ShortKD extends StdKeyDeserializer\n     {\n         ShortKD() { super(Integer.class); }\n      * Dealing with Characters is bit trickier: let's assume it must be a String, and that\n      * Unicode numeric value is never used.\n      */\n+    @JacksonStdImpl\n     final static class CharKD extends StdKeyDeserializer\n     {\n         CharKD() { super(Character.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class IntKD extends StdKeyDeserializer\n     {\n         IntKD() { super(Integer.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class LongKD extends StdKeyDeserializer\n     {\n         LongKD() { super(Long.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class DoubleKD extends StdKeyDeserializer\n     {\n         DoubleKD() { super(Double.class); }\n         }\n     }\n \n+    @JacksonStdImpl\n     final static class FloatKD extends StdKeyDeserializer\n     {\n         FloatKD() { super(Float.class); }\n         public Class<?> getKeyClass() { return _keyClass; }\n     }\n      \n+    @JacksonStdImpl\n     final static class EnumKD extends StdKeyDeserializer\n     {\n         protected final EnumResolver<?> _resolver;\n     }\n \n     // as per [JACKSON-657]\n+    @JacksonStdImpl\n     final static class DateKD extends StdKeyDeserializer\n     {\n         protected DateKD() {\n     }\n         \n     // as per [JACKSON-657]\n+    @JacksonStdImpl\n     final static class CalendarKD extends StdKeyDeserializer\n     {\n         protected CalendarKD() {\n     }\n \n     // as per [JACKSON-726]\n+    @JacksonStdImpl\n     final static class UuidKD extends StdKeyDeserializer\n     {\n         protected UuidKD() {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n             JsonDeserializer<?> deser = ctxt.findValueDeserializer(_collectionType.getContentType(), _property);\n             _valueDeserializer = (JsonDeserializer<String>) deser;\n         }\n-        if (isDefaultSerializer(_valueDeserializer)) {\n+        if (isDefaultDeserializer(_valueDeserializer)) {\n             _valueDeserializer = null;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n import java.util.Collection;\n import java.util.Map;\n \n-\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n         return null;\n     }\n \n-    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, DeserializerCache p)\n+    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config)\n     {\n         Class<?> rawType = type.getRawClass();\n         String className = rawType.getName();", "timestamp": 1327440434, "metainfo": ""}