{"sha": "302df7b8bf6f33369c3ed918a9323df567064f40", "log": "Minor clean up of format/type visitor code", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonMapFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n         return o;\n     }\n \n-    /* !!! 03-Oct-2012, tatu: This is total mess, and partly incorrect. MUST be\n-     *   rewritten in near future, to work.\n+    /**\n+     * We consider possibility here that an EnumMap might actually just be serialized\n+     * as something like a Record, given that number of keys is bound, just like\n+     * with Objects/Records (and not unbounded like regular maps)\n      */\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n     {\n+        if (visitor == null) {\n+            return;\n+        }\n         JsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n+        if (objectVisitor == null) {\n+            return;\n+        }\n         JavaType valueType = typeHint.containedType(1);\n         JsonSerializer<Object> ser = _valueSerializer;\n         if (ser == null && valueType != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n             throws JsonMappingException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n-            visitor.expectIntegerFormat(typeHint);\n-        } else {\n-    \t\tJsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);\n-    \t\tif (typeHint != null && stringVisitor != null) {\n-    \t\t\tif (typeHint.isEnumType()) {\n-    \t\t\t\tSet<String> enums = new LinkedHashSet<String>();\n-    \t\t\t\tfor (SerializedString value : _values.values()) {\n-    \t\t\t\t\tenums.add(value.getValue());\n-    \t\t\t\t}\n-    \t\t\t\tstringVisitor.enumTypes(enums);\n-    \t\t\t}\n-    \t\t}\n+        if (visitor != null) {\n+            if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+                visitor.expectIntegerFormat(typeHint);\n+            } else {\n+        \t\tJsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);\n+        \t\tif (typeHint != null && stringVisitor != null) {\n+        \t\t\tif (typeHint.isEnumType()) {\n+        \t\t\t\tSet<String> enums = new LinkedHashSet<String>();\n+        \t\t\t\tfor (SerializedString value : _values.values()) {\n+        \t\t\t\t\tenums.add(value.getValue());\n+        \t\t\t\t}\n+        \t\t\t\tstringVisitor.enumTypes(enums);\n+        \t\t\t}\n+        \t\t}\n+            }\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n /**\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n     {\n-        visitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n+        JsonStringFormatVisitor v2 = (visitor == null) ? null : visitor.expectStringFormat(typeHint);\n+        if (v2 != null) {\n+            v2.format(JsonValueFormat.DATE_TIME);\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n @JacksonStdImpl\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n             throws JsonMappingException\n     {\n-        visitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n+        JsonStringFormatVisitor v2 = (visitor == null) ? null : visitor.expectStringFormat(typeHint);\n+        if (v2 != null) {\n+            v2.format(JsonValueFormat.DATE_TIME);\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n public final class EnumValues\n {\n     /**\n+     * @since 2.2\n+     */\n+    private final Class<Enum<?>> _enumClass;\n+    \n+    /**\n      * Since 1.7, we are storing values as SerializedStrings, to further\n      * speed up serialization.\n      */\n     private final EnumMap<?,SerializedString> _values;\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    private EnumValues(Map<Enum<?>,SerializedString> v) {\n+    private EnumValues(Class<Enum<?>> enumClass, Map<Enum<?>,SerializedString> v) {\n+        _enumClass = enumClass;\n         _values = new EnumMap(v);\n     }\n \n         /* [JACKSON-214]: Enum types with per-instance sub-classes\n          *   need special handling\n          */\n-    \tClass<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);\n+        Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);\n         Enum<?>[] values = cls.getEnumConstants();\n         if (values != null) {\n             // Type juggling... unfortunate\n                 String value = intr.findEnumValue(en);\n                 map.put(en, new SerializedString(value));\n             }\n-            return new EnumValues(map);\n+            return new EnumValues(enumClass, map);\n         }\n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n             for (Enum<?> en : values) {\n                 map.put(en, new SerializedString(en.toString()));\n             }\n-            return new EnumValues(map);\n+            return new EnumValues(enumClass, map);\n         }\n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n         return _values;\n     }\n \n+    /**\n+     * @since 2.2\n+     */\n+    public Class<Enum<?>> getEnumClass() {\n+        return _enumClass;\n+    }\n+    \n }", "timestamp": 1353654233, "metainfo": ""}