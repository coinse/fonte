{"sha": "288087216060a7f910a9bcf20bfd4504bd31c89d", "log": "Implement [JACKSON-795]: @JsonValue will now work with Maps, Collections too", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n     }\n \n     /**\n+     * Method called to see if one of primary per-class annotations\n+     * (or related, like implementing of {@link JsonSerializable})\n+     * determines the serializer to use.\n+     *<p>\n+     * Currently handles things like:\n+     *<ul>\n+     * <li>If type implements {@link JsonSerializable}, use that\n+     *  </li>\n+     * <li>If type has {@link JsonValue} annotation (or equivalent), build serializer\n+     *    based on that property\n+     *  </li>\n+     *</ul>\n+     *\n+     * @since 2.0\n+     */\n+    protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, \n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        Class<?> raw = type.getRawClass();\n+        // First: JsonSerializable?\n+        if (JsonSerializable.class.isAssignableFrom(raw)) {\n+            return SerializableSerializer.instance;\n+        }\n+        // Second: @JsonValue for any type\n+        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n+        if (valueMethod != null) {\n+            Method m = valueMethod.getAnnotated();\n+            if (prov.canOverrideAccessModifiers()) {\n+                ClassUtil.checkAndFixAccess(m);\n+            }\n+            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n+            return new JsonValueSerializer(m, ser);\n+        }\n+        // No well-known annotations...\n+        return null;\n+    }\n+    \n+    /**\n      * Method for checking if we can determine serializer to use based on set of\n      * known primary types, checking for set of known base types (exact matches\n      * having been compared against with <code>findSerializerByLookup</code>).\n         throws JsonMappingException\n     {\n         Class<?> raw = type.getRawClass();\n-        // First: JsonSerializable and related\n-        if (JsonSerializable.class.isAssignableFrom(raw)) {\n-            return SerializableSerializer.instance;\n-        }\n-        // Second: as per [JACKSON-193] consider @JsonValue for any types:\n-        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n-        if (valueMethod != null) {\n-            // [JACKSON-586]: need to ensure accessibility of method\n-            Method m = valueMethod.getAnnotated();\n-            if (prov.canOverrideAccessModifiers()) {\n-                ClassUtil.checkAndFixAccess(m);\n-            }\n-            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n-            return new JsonValueSerializer(m, ser);\n-        }\n-        \n         // One unfortunate special case, as per [JACKSON-484]\n         if (InetAddress.class.isAssignableFrom(raw)) {\n             return InetAddressSerializer.instance;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             }\n         }\n \n+        // Then JsonSerializable, @JsonValue etc:\n+        ser = findSerializerByAnnotations(prov, type, beanDesc);\n+        if (ser != null) {\n+            return (JsonSerializer<Object>) ser;\n+        }\n+        \n         // Container types differ from non-container types:\n         if (origType.isContainerType()) {\n             if (!staticTyping) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n package com.fasterxml.jackson.databind.ser;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n \n             return map;\n         }\n     }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MapAsNumber extends HashMap<String,String>\n+    {\n+        @JsonValue\n+        public int value() { return 42; }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class ListAsNumber extends ArrayList<Integer>\n+    {\n+        @JsonValue\n+        public int value() { return 13; }\n+    }\n     \n     /*\n     /*********************************************************\n     /*********************************************************\n      */\n \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testSimpleJsonValue() throws Exception\n     {\n-        String result = mapper.writeValueAsString(new ValueClass<String>(\"abc\"));\n+        String result = MAPPER.writeValueAsString(new ValueClass<String>(\"abc\"));\n         assertEquals(\"\\\"abc\\\"\", result);\n     }\n \n     public void testJsonValueWithUseSerializer() throws Exception\n     {\n-        String result = serializeAsString(mapper, new ToStringValueClass<Integer>(Integer.valueOf(123)));\n+        String result = serializeAsString(MAPPER, new ToStringValueClass<Integer>(Integer.valueOf(123)));\n         assertEquals(\"\\\"123\\\"\", result);\n     }\n \n      */\n     public void testMixedJsonValue() throws Exception\n     {\n-        String result = serializeAsString(mapper, new ToStringValueClass2(\"xyz\"));\n+        String result = serializeAsString(MAPPER, new ToStringValueClass2(\"xyz\"));\n         assertEquals(\"\\\"xyz\\\"\", result);\n     }\n \n     public void testValueWithStaticType() throws Exception\n     {\n         // Ok; first, with dynamic type:\n-        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(new ValueWrapper()));\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", MAPPER.writeValueAsString(new ValueWrapper()));\n \n         // then static\n         ObjectMapper staticMapper = new ObjectMapper();\n         assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", staticMapper.writeValueAsString(new ValueWrapper()));\n     }\n \n-    public void testMapWithJsonValue() throws Exception\n-    {\n-        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", mapper.writeValueAsString(new MapBean()));\n+    public void testMapWithJsonValue() throws Exception {\n+        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", MAPPER.writeValueAsString(new MapBean()));\n+    }\n+\n+    public void testWithMap() throws Exception {\n+        assertEquals(\"42\", MAPPER.writeValueAsString(new MapAsNumber()));\n+\n+    }\n+\n+    public void testWithList() throws Exception {\n+        assertEquals(\"13\", MAPPER.writeValueAsString(new ListAsNumber()));\n     }\n }", "timestamp": 1330137350, "metainfo": ""}