{"sha": "afb688acea2f5b9bed243de7b002d574740724c7", "log": "Merge pull request #785 from drcrallen/jackson-databind-2.4.4-mmx  Add handlings for classes which are available in `Thread.currentThread().getContextClassLoader()`", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n         List<AnnotatedMethod> creatorMethods = null;\n         \n         // Then static methods which are potential factory methods\n-        for (Method m : _class.getDeclaredMethods()) {\n+\n+        Method[] classMethods;\n+        try{\n+            classMethods = _class.getDeclaredMethods();\n+        }catch(final NoClassDefFoundError ex){\n+            // One of the methods had a class that was not found in the cls.getClassLoader.\n+            // Maybe the developer was nice and has a different class loader for this context.\n+            final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+            if(loader == null){\n+                // Nope... this is going to end poorly\n+                throw ex;\n+            }\n+            final Class<?> contextClass;\n+            try {\n+                contextClass = loader.loadClass(_class.getName());\n+            }\n+            catch (ClassNotFoundException e) {\n+                //ex.addSuppressed(e); Not until 1.7\n+                throw ex;\n+            }\n+            classMethods = contextClass.getDeclaredMethods(); // Cross fingers\n+        }\n+\n+        for (Method m : classMethods) {\n             if (!Modifier.isStatic(m.getModifiers())) {\n                 continue;\n             }\n         if (cls == null) { // just so caller need not check when passing super-class\n             return;\n         }\n-\n+        Method[] classMethods;\n+        try{\n+            classMethods = cls.getDeclaredMethods();\n+        }catch(final NoClassDefFoundError ex){\n+            // One of the methods had a class that was not found in the cls.getClassLoader.\n+            // Maybe the developer was nice and has a different class loader for this context.\n+            final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+            if (loader == null) {\n+                // Nope... this is going to end poorly\n+                throw ex;\n+            }\n+            final Class<?> contextClass;\n+            try {\n+                contextClass = loader.loadClass(cls.getName());\n+            }\n+            catch (ClassNotFoundException e) {\n+                //ex.addSuppressed(e); Not until 1.7\n+                throw ex;\n+            }\n+            classMethods = contextClass.getDeclaredMethods(); // Cross fingers\n+        }\n         // then methods from the class itself\n-        for (Method m : cls.getDeclaredMethods()) {\n+        for (Method m : classMethods) {\n             if (!_isIncludableMemberMethod(m)) {\n                 continue;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         throws JsonMappingException\n     {\n         if (_rootDeserializer != null) {\n-            return _rootDeserializer;\n+            // 02-Apr-2015, tatu: Patch for #744 (better fix in 2.5.3)\n+            if (valueType != JSON_NODE_TYPE) {\n+                return _rootDeserializer;\n+            }\n         }\n \n         // Sanity check: must have actual type...\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n         if (type == null) {\n             throw new IllegalArgumentException(\"Null JavaType passed\");\n         }\n+        if (_hasCustomValueHandler(type)) {\n+            return null;\n+        }\n         return _cachedDeserializers.get(type);\n     }\n \n      * @param ctxt Currently active deserialization context\n      * @param type Type of property to deserialize\n      */\n-    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n+    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n             DeserializerFactory factory, JavaType type)\n         throws JsonMappingException\n     {\n          */\n         // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n         boolean isResolvable = (deser instanceof ResolvableDeserializer);\n-        boolean addToCache = deser.isCachable();\n+        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();\n \n         /* we will temporarily hold on to all created deserializers (to\n          * handle cyclic references, and possibly reuse non-cached\n         return type;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used to prevent both caching and cache lookups for structured\n+     * types that have custom value handlers\n+     *\n+     * @since 2.4.6\n+     */\n+    private boolean _hasCustomValueHandler(JavaType t) {\n+        if (t.isContainerType()) {\n+            JavaType ct = t.getContentType();\n+            if (ct != null) {\n+                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+            }\n+        }\n+        return false;\n+    }\n+\n     private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n     {\n         if (src == null) {\n         }\n         return cls;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Overridable error reporting methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         return ((rawKeyType == String.class || rawKeyType == Object.class)\n                 && isDefaultKeyDeserializer(keyDeser));\n     }\n-    \n+\n     public void setIgnorableProperties(String[] ignorable) {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n             null : ArrayBuilders.arrayToSet(ignorable);\n     /**\n      * Turns out that these are expensive enough to create so that caching\n      * does make sense.\n+     *<p>\n+     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n+     * a value type deserializer; this caused an issue with 2.4.4 of\n+     * JAXB Annotations (failing a test).\n+     * It is also possible that some other settings could make deserializers\n+     * un-cacheable; but on the other hand, caching can make a big positive\n+     * difference with performance... so it's a hard choice.\n      * \n      * @since 2.4.4\n      */\n     @Override\n-    public boolean isCachable() { return true; }\n+    public boolean isCachable() {\n+        /* As per [databind#735], existence of value or key deserializer (only passed\n+         * if annotated to use non-standard one) should also prevent caching.\n+         */\n+        return (_valueDeserializer == null)\n+                && (_keyDeserializer == null)\n+                && (_valueTypeDeserializer == null)\n+                && (_ignorableProperties == null);\n+    }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n         throw JsonMappingException.wrapWithPath(t, ref, key);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n-            UnresolvedForwardReference reference)\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n+            Object key, UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n         if (accumulator == null) {\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final static class MapReferringAccumulator  {\n+    private final static class MapReferringAccumulator {\n         private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n         public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n         public final Object key;\n         \n-        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n         _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Initialization\n      * to: it can not be done earlier since delegated deserializers almost\n      * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         JavaType obType = ctxt.constructType(Object.class);\n         JavaType stringType = ctxt.constructType(String.class);\n         TypeFactory tf = ctxt.getTypeFactory();\n+\n+        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n+         *    should always be called separately, from within \"createContextual()\".\n+         *    But this is a very singular deserializer since it operates on `Object`\n+         *    (and often for `?` type parameter), and as a result, easily and commonly\n+         *    results in cycles, being value deserializer for various Maps and Collections.\n+         *    Because of this, we must somehow break the cycles. This is done here by\n+         *    forcing pseudo-contextualization with null property.\n+         */\n+\n+        // So: first find possible custom instances\n         _mapDeserializer = _findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType));\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        // NOTE: since we don't yet have the referring property, this should be fine:\n         JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n-    \n+\n+    /**\n+     * We only use contextualization for optimizing the case where no customization\n+     * occurred; if so, can slip in a more streamlined version.\n+     */\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n         }\n-        JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n-        if (mapDeserializer instanceof ContextualDeserializer) {\n-            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> listDeserializer = _listDeserializer;\n-        if (listDeserializer instanceof ContextualDeserializer) {\n-            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> stringDeserializer = _stringDeserializer;\n-        if (stringDeserializer instanceof ContextualDeserializer) {\n-            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> numberDeserializer = _numberDeserializer;\n-        if (numberDeserializer instanceof ContextualDeserializer) {\n-            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);\n-        }\n-\n-        // And if anything changed, we'll need to change too!\n-        if ((mapDeserializer != _mapDeserializer)\n-                || (listDeserializer != _listDeserializer)\n-                || (stringDeserializer != _stringDeserializer)\n-                || (numberDeserializer != _numberDeserializer)\n-                ) {\n-            return _withResolved(mapDeserializer, listDeserializer,\n-                    stringDeserializer, numberDeserializer);\n-        }\n         return this;\n     }\n \n     /* Deserializer API\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n     public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n-        super(bt, idRes, typePropertyName, typeIdVisible, null);\n+        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n     }\n \n     protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property) {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.io.NumberOutput;\n import com.fasterxml.jackson.databind.SerializerProvider;\n \n /**\n \n     @Override\n     public String asText() {\n-        return NumberOutput.toString(_value);\n+        // As per [jackson-core#179]\n+//        return NumberOutput.toString(_value);\n+        return Float.toString(_value);\n     }\n \n     @Override\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonFormatVisitorNullWrapper.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.*;\n+\n+/**\n+ * Default \"empty\" implementation, useful as the base to start on; especially as\n+ * it is guaranteed to implement all the method of the interface, even if new\n+ * methods are getting added.\n+ */\n+class JsonFormatVisitorNullWrapper implements JsonFormatVisitorWrapper {\n+\tprotected SerializerProvider _provider;\n+\n+\tpublic JsonFormatVisitorNullWrapper() {\n+\t}\n+\n+\tpublic JsonFormatVisitorNullWrapper(SerializerProvider p) {\n+\t\t_provider = p;\n+\t}\n+\n+\t@Override\n+\tpublic SerializerProvider getProvider() {\n+\t\treturn _provider;\n+\t}\n+\n+\t@Override\n+\tpublic void setProvider(SerializerProvider p) {\n+\t\t_provider = p;\n+\t}\n+\n+\t@Override\n+\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonStringFormatVisitor expectStringFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonNullFormatVisitor expectNullFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic JsonMapFormatVisitor expectMapFormat(JavaType type)\n+\t\t\tthrows JsonMappingException {\n+\t\treturn null;\n+\t}\n+\n+};\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n     extends FilterProvider\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.3.0\n-    private static final long serialVersionUID = -6305772546718366447L;\n+    // for 2.5+\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Mappings from ids to filters.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n import java.util.Iterator;\n import java.util.Map.Entry;\n \n-import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n     /**********************************************************\n      */\n \n-    // TODO: if/how to change this? Base class has this\n-/*    \n-    @Override\n-    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n-        throws JsonMappingException\n-    {\n-        if (objectVisitor != null) {\n-            if (isRequired()) {\n-                objectVisitor.property(this); \n-            } else {\n-                objectVisitor.optionalProperty(this);\n-            }\n-        }\n-    }\n-    */\n+    @Override\n+    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor)\n+            throws JsonMappingException {\n+        SerializerProvider provider = visitor.getProvider();\n+        JsonSerializer<Object> ser = provider\n+                .findValueSerializer(this.getType(), this)\n+                .unwrappingSerializer(_nameTransformer);\n+        \n+        if (ser.isUnwrappingSerializer()) {\n+            ser.acceptJsonFormatVisitor(new JsonFormatVisitorNullWrapper(provider) {\n+                // an unwrapping serializer will always expect ObjectFormat,\n+                // hence, the other cases do not have to be implemented\n+                @Override\n+                public JsonObjectFormatVisitor expectObjectFormat(JavaType type)\n+                        throws JsonMappingException {\n+                    return visitor;\n+                }\n+            }, this.getType());\n+        } else {\n+            super.depositSchemaProperty(visitor);\n+        }\n+    }\n     \n     // Override needed to support legacy JSON Schema generator\n     @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n \n /**\n  * Tests to verify that most core Jackson components can be serialized\n         assertEquals(p.x, p2.x);\n         assertEquals(p.y, p2.y);\n     }\n-    \n+\n+    public void testTypeFactory() throws Exception\n+    {\n+        TypeFactory orig = TypeFactory.defaultInstance();\n+        JavaType t = orig.constructType(JavaType.class);\n+        assertNotNull(t);\n+\n+        byte[] bytes = jdkSerialize(orig);\n+        TypeFactory result = jdkDeserialize(bytes);\n+        assertNotNull(result);\n+        t = orig.constructType(JavaType.class);\n+        assertEquals(JavaType.class, t.getRawClass());\n+    }\n+\n+    public void testLRUMap() throws Exception\n+    {\n+        LRUMap<String,Integer> map = new LRUMap<String,Integer>(32, 32);\n+        map.put(\"a\", 1);\n+\n+        byte[] bytes = jdkSerialize(map);\n+        LRUMap<String,Integer> result = jdkDeserialize(bytes);\n+        // transient implementation, will be read as empty\n+        assertEquals(0, result.size());\n+\n+        // but should be possible to re-populate\n+        result.put(\"a\", 2);\n+        assertEquals(1, result.size());\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n             return super.createDeserializationContext(jp, cfg);\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyAnnotationIntrospector extends JacksonAnnotationIntrospector { }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(1, m.getDeserializationConfig().mixInCount());\n         assertEquals(0, m2.getDeserializationConfig().mixInCount());\n     }\n+\n+    public void testAnnotationIntrospectorCopyin() \n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.setAnnotationIntrospector(new MyAnnotationIntrospector());\n+        assertEquals(MyAnnotationIntrospector.class,\n+                m.getDeserializationConfig().getAnnotationIntrospector().getClass());\n+        ObjectMapper m2 = m.copy();\n+\n+        assertEquals(MyAnnotationIntrospector.class,\n+                m2.getDeserializationConfig().getAnnotationIntrospector().getClass());\n+        assertEquals(MyAnnotationIntrospector.class,\n+                m2.getSerializationConfig().getAnnotationIntrospector().getClass());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java\n package com.fasterxml.jackson.databind.convert;\n \n+import java.io.IOException;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonView;\n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n \n import static org.junit.Assert.assertArrayEquals;\n \n         @JsonView(TextView.class)\n         public String str;\n     }\n-        \n+\n+    // for [databind#744]\n+    static class DataA {\n+        public int i = 1;\n+        public int j = 2;\n+\n+    }\n+\n+    static class DataB {\n+        public DataA da = new DataA();\n+        public int k = 3;\n+    }\n+\n+    static class DataADeserializer extends StdDeserializer<DataA> {\n+        private static final long serialVersionUID = 1L;\n+\n+        DataADeserializer() {\n+            super(DataA.class);\n+        }\n+\n+        public DataA deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws JsonProcessingException, IOException {\n+            if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+                throw ctxt.mappingException(\"Wrong current token, expected START_OBJECT, got: \"\n+                        +jp.getCurrentToken());\n+            }\n+            /*JsonNode node =*/ jp.readValueAsTree();\n+\n+            DataA da = new DataA();\n+            da.i = 5;\n+            return da;\n+        }\n+    }\n+    \n     /*\n     /********************************************************\n     /* Unit tests\n         assertEquals(100, bean.num);\n         assertEquals(\"foobar\", bean.str);\n     }\n+\n+    // [databind#744]\n+    public void testIssue744() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule();\n+        module.addDeserializer(DataA.class, new DataADeserializer());\n+        mapper.registerModule(module);\n+\n+        DataB db = new DataB();\n+        db.da.i = 11;\n+        db.k = 13;\n+        String jsonBString = mapper.writeValueAsString(db);\n+        JsonNode jsonBNode = mapper.valueToTree(db);\n+\n+        // create parent\n+        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n+        assertEquals(5, dbNewViaString.da.i);\n+        assertEquals(13, dbNewViaString.k);\n+\n+        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n+        assertEquals(5, dbNewViaNode.da.i);\n+        assertEquals(13, dbNewViaNode.k);\n+\n+        // update parent\n+        DataB dbUpdViaString = new DataB();\n+        DataB dbUpdViaNode = new DataB();\n+\n+        assertEquals(1, dbUpdViaString.da.i);\n+        assertEquals(3, dbUpdViaString.k);\n+        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n+        assertEquals(5, dbUpdViaString.da.i);\n+        assertEquals(13, dbUpdViaString.k);\n+\n+        assertEquals(1, dbUpdViaNode.da.i);\n+        assertEquals(3, dbUpdViaNode.k);\n+        \n+        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n+        assertEquals(5, dbUpdViaNode.da.i);\n+        assertEquals(13, dbUpdViaNode.k);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCachingOfDeser.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestCachingOfDeser extends BaseMapTest\n+{\n+    // For [databind#735]\n+    public static class TestMapNoCustom {\n+\n+        public Map<String, Integer> map;\n+    }\n+\n+    public static class TestMapWithCustom {\n+\n+        @JsonDeserialize(contentUsing = CustomDeserializer735.class)\n+        public Map<String, Integer> map;\n+    }\n+\n+    public static class TestListWithCustom {\n+        @JsonDeserialize(contentUsing = CustomDeserializer735.class)\n+        public List<Integer> list;\n+    }\n+\n+    public static class TestListNoCustom {\n+        public List<Integer> list;\n+    }\n+\n+    public static class CustomDeserializer735 extends StdDeserializer<Integer> {\n+        public CustomDeserializer735() {\n+            super(Integer.class);\n+        }\n+\n+        @Override\n+        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n+            return 100 * p.getValueAsInt();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    final static String MAP_INPUT = \"{\\\"map\\\":{\\\"a\\\":1}}\";\n+    final static String LIST_INPUT = \"{\\\"list\\\":[1]}\";\n+\n+    \n+    // Ok: first, use custom-annotated instance first, then standard\n+    public void testCustomMapCaching1() throws Exception\n+    {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        TestMapWithCustom mapC = mapper.readValue(MAP_INPUT, TestMapWithCustom.class);\n+        TestMapNoCustom mapStd = mapper.readValue(MAP_INPUT, TestMapNoCustom.class);\n+\n+        assertNotNull(mapC.map);\n+        assertNotNull(mapStd.map);\n+        assertEquals(Integer.valueOf(100), mapC.map.get(\"a\"));\n+        assertEquals(Integer.valueOf(1), mapStd.map.get(\"a\"));\n+    }\n+        \n+    // And then standard first, custom next\n+    public void testCustomMapCaching2() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TestMapNoCustom mapStd = mapper.readValue(MAP_INPUT, TestMapNoCustom.class);\n+        TestMapWithCustom mapC = mapper.readValue(MAP_INPUT, TestMapWithCustom.class);\n+\n+        assertNotNull(mapStd.map);\n+        assertNotNull(mapC.map);\n+        assertEquals(Integer.valueOf(1), mapStd.map.get(\"a\"));\n+        assertEquals(Integer.valueOf(100), mapC.map.get(\"a\"));\n+    }\n+\n+    // Ok: first, use custom-annotated instance first, then standard\n+    public void testCustomListCaching1() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TestListWithCustom listC = mapper.readValue(LIST_INPUT, TestListWithCustom.class);\n+        TestListNoCustom listStd = mapper.readValue(LIST_INPUT, TestListNoCustom.class);\n+\n+        assertNotNull(listC.list);\n+        assertNotNull(listStd.list);\n+        assertEquals(Integer.valueOf(100), listC.list.get(0));\n+        assertEquals(Integer.valueOf(1), listStd.list.get(0));\n+    }\n+\n+    // First custom-annotated, then standard\n+    public void testCustomListCaching2() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TestListNoCustom listStd = mapper.readValue(LIST_INPUT, TestListNoCustom.class);\n+        TestListWithCustom listC = mapper.readValue(LIST_INPUT, TestListWithCustom.class);\n+\n+        assertNotNull(listC.list);\n+        assertNotNull(listStd.list);\n+        assertEquals(Integer.valueOf(100), listC.list.get(0));\n+        assertEquals(Integer.valueOf(1), listStd.list.get(0));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.*;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import java.lang.annotation.*;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+\n import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n             }\n             return this;\n         }\n-        \n-    }\n-    \n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java\n package com.fasterxml.jackson.databind.deser;\n \n-import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n-import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.annotation.JsonSubTypes;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.annotation.*;\n+\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * Test for testing forward reference handling\n \t}\n \n \t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n-\tprivate static class YetAnotherClass\n+\tstatic class YetAnotherClass\n \t{\n \t\tpublic YetAnotherClass() {}\n \t\tpublic ForwardReferenceClass frc;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n /**\n- * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * Unit tests for verifying \"raw\" (or \"untyped\") data binding from JSON to JDK objects;\n  * one that only uses core JDK types; wrappers, Maps and Lists.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestUntypedDeserialization\n     extends BaseMapTest\n {\n-    @SuppressWarnings(\"serial\")\n     static class UCStringDeserializer\n         extends StdScalarDeserializer<String>\n     {\n         public UCStringDeserializer() { super(String.class); }\n \n         @Override\n-        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return jp.getText().toUpperCase();\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n     static class CustomNumberDeserializer\n         extends StdScalarDeserializer<Number>\n     {\n         }\n \n         @Override\n-        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return value;\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n+    // Let's make this Contextual, to tease out cyclic resolution issues, if any\n     static class ListDeserializer extends StdDeserializer<List<Object>>\n+        implements ContextualDeserializer\n     {\n         public ListDeserializer() { super(List.class); }\n \n             }\n             return list;\n         }\n-    }\n-\n-    @SuppressWarnings(\"serial\")\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            // For now, we just need to access \"untyped\" deserializer; not use it.\n+            \n+            /*JsonDeserializer<Object> ob = */\n+            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);\n+            return this;\n+        }\n+    }\n+\n     static class MapDeserializer extends StdDeserializer<Map<String,Object>>\n     {\n         public MapDeserializer() { super(Map.class); }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n     // @since 2.2\n     public void testFloat()\n     {\n-        FloatNode n = FloatNode.valueOf(0.25f);\n+        FloatNode n = FloatNode.valueOf(0.45f);\n         assertStandardEquals(n);\n         assertTrue(0 != n.hashCode());\n         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n         assertEquals(JsonParser.NumberType.FLOAT, n.numberType());\n         assertEquals(0, n.intValue());\n-        assertEquals(0.25, n.doubleValue());\n-        assertEquals(0.25f, n.floatValue());\n+        \n+        // NOTE: conversion to double NOT as simple as with exact numbers like 0.25:\n+        assertEquals(0.45f, n.floatValue());\n+        assertEquals(\"0.45\", n.asText());\n+\n+        // so; as double we'll get more complex number; however, should round-trip\n+        // to something that gets printed the same way. But not exact value, alas, hence:\n+        assertEquals(\"0.45\",  String.valueOf((float) n.doubleValue()));\n+\n         assertNotNull(n.decimalValue());\n+        // possibly surprisingly, however, this will produce same output:\n         assertEquals(BigInteger.ZERO, n.bigIntegerValue());\n-        assertEquals(\"0.25\", n.asText());\n+        assertEquals(\"0.45\", n.asText());\n \n         // 1.6:\n         assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f);", "timestamp": 1431122980, "metainfo": ""}