{"sha": "6125110531d11e019b719c1300ec46bda622c494", "log": "try to streamline node deserializer too", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n      * Overridden by typed sub-classes for more thorough checking\n      */\n     @Override\n-    public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getCurrentToken()) {\n-        case START_OBJECT:\n+    public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_START_OBJECT:\n             return deserializeObject(jp, ctxt, ctxt.getNodeFactory());\n-        case START_ARRAY:\n+        case JsonTokenId.ID_START_ARRAY:\n             return deserializeArray(jp, ctxt, ctxt.getNodeFactory());\n         default:\n             return deserializeAny(jp, ctxt, ctxt.getNodeFactory());\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n-        public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (jp.getCurrentToken() == JsonToken.START_OBJECT) {\n                 jp.nextToken();\n abstract class BaseNodeDeserializer<T extends JsonNode>\n     extends StdDeserializer<T>\n {\n-    public BaseNodeDeserializer(Class<T> vc)\n-    {\n+    public BaseNodeDeserializer(Class<T> vc) {\n         super(vc);\n     }\n     \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         /* Output can be as JSON Object, Array or scalar: no way to know\n          * a priori. So:\n     /**********************************************************\n      */\n     \n-    protected void _reportProblem(JsonParser jp, String msg)\n-        throws JsonMappingException\n-    {\n+    protected void _reportProblem(JsonParser jp, String msg) throws JsonMappingException {\n         throw new JsonMappingException(msg, jp.getTokenLocation());\n     }\n     \n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             String fieldName = jp.getCurrentName();\n             JsonNode value;\n-            switch (jp.nextToken()) {\n-            case START_OBJECT:\n+            t = jp.nextToken();\n+            switch (t.id()) {\n+            case JsonTokenId.ID_START_OBJECT:\n                 value = deserializeObject(jp, ctxt, nodeFactory);\n                 break;\n-            case START_ARRAY:\n+            case JsonTokenId.ID_START_ARRAY:\n                 value = deserializeArray(jp, ctxt, nodeFactory);\n                 break;\n-            case VALUE_STRING:\n+            case JsonTokenId.ID_STRING:\n                 value = nodeFactory.textNode(jp.getText());\n+                break;\n+            case JsonTokenId.ID_NUMBER_INT:\n+                value = _fromInt(jp, ctxt, nodeFactory);\n+                break;\n+            case JsonTokenId.ID_TRUE:\n+                value = nodeFactory.booleanNode(true);\n+                break;\n+            case JsonTokenId.ID_FALSE:\n+                value = nodeFactory.booleanNode(false);\n+                break;\n+            case JsonTokenId.ID_NULL:\n+                value = nodeFactory.nullNode();\n                 break;\n             default:\n                 value = deserializeAny(jp, ctxt, nodeFactory);\n             if (t == null) {\n                 throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n             }\n-            switch (t) {\n-            case START_OBJECT:\n+            switch (t.id()) {\n+            case JsonTokenId.ID_START_OBJECT:\n                 node.add(deserializeObject(jp, ctxt, nodeFactory));\n                 break;\n-            case START_ARRAY:\n+            case JsonTokenId.ID_START_ARRAY:\n                 node.add(deserializeArray(jp, ctxt, nodeFactory));\n                 break;\n-            case END_ARRAY:\n+            case JsonTokenId.ID_END_ARRAY:\n                 return node;\n-            case VALUE_STRING:\n+            case JsonTokenId.ID_STRING:\n                 node.add(nodeFactory.textNode(jp.getText()));\n+                break;\n+            case JsonTokenId.ID_NUMBER_INT:\n+                node.add(_fromInt(jp, ctxt, nodeFactory));\n+                break;\n+            case JsonTokenId.ID_TRUE:\n+                node.add(nodeFactory.booleanNode(true));\n+                break;\n+            case JsonTokenId.ID_FALSE:\n+                node.add(nodeFactory.booleanNode(false));\n+                break;\n+            case JsonTokenId.ID_NULL:\n+                node.add(nodeFactory.nullNode());\n                 break;\n             default:\n                 node.add(deserializeAny(jp, ctxt, nodeFactory));\n             }\n         }\n     }\n-\n+    \n     protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n             final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getCurrentToken()) {\n-        case START_OBJECT:\n-        case END_OBJECT: // for empty JSON Objects we may point to this\n+        throws IOException\n+    {\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_START_OBJECT:\n+        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n             return deserializeObject(jp, ctxt, nodeFactory);\n-\n-        case START_ARRAY:\n+        case JsonTokenId.ID_START_ARRAY:\n             return deserializeArray(jp, ctxt, nodeFactory);\n-\n-        case FIELD_NAME:\n+        case JsonTokenId.ID_FIELD_NAME:\n             return deserializeObject(jp, ctxt, nodeFactory);\n-\n-        case VALUE_EMBEDDED_OBJECT:\n-            // [JACKSON-796]\n-            {\n-                Object ob = jp.getEmbeddedObject();\n-                if (ob == null) { // should this occur?\n-                    return nodeFactory.nullNode();\n-                }\n-                Class<?> type = ob.getClass();\n-                if (type == byte[].class) { // most common special case\n-                    return nodeFactory.binaryNode((byte[]) ob);\n-                }\n-                if (JsonNode.class.isAssignableFrom(type)) {\n-                    // [Issue#433]: but could also be a JsonNode hiding in there!\n-                    return (JsonNode) ob;\n-                }\n-                // any other special handling needed?\n-                return nodeFactory.pojoNode(ob);\n-            }\n-\n-        case VALUE_STRING:\n+        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+            return _fromEmbedded(jp, ctxt, nodeFactory);\n+        case JsonTokenId.ID_STRING:\n             return nodeFactory.textNode(jp.getText());\n-\n-        case VALUE_NUMBER_INT:\n-            {\n-                JsonParser.NumberType nt = jp.getNumberType();\n-                if (nt == JsonParser.NumberType.BIG_INTEGER\n-                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n-                    return nodeFactory.numberNode(jp.getBigIntegerValue());\n-                }\n-                if (nt == JsonParser.NumberType.INT) {\n-                    return nodeFactory.numberNode(jp.getIntValue());\n-                }\n-                return nodeFactory.numberNode(jp.getLongValue());\n-            }\n-\n-        case VALUE_NUMBER_FLOAT:\n-            {\n-                JsonParser.NumberType nt = jp.getNumberType();\n-                if (nt == JsonParser.NumberType.BIG_DECIMAL\n-                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                    return nodeFactory.numberNode(jp.getDecimalValue());\n-                }\n-                return nodeFactory.numberNode(jp.getDoubleValue());\n-            }\n-\n-        case VALUE_TRUE:\n+        case JsonTokenId.ID_NUMBER_INT:\n+            return _fromInt(jp, ctxt, nodeFactory);\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            return _fromFloat(jp, ctxt, nodeFactory);\n+        case JsonTokenId.ID_TRUE:\n             return nodeFactory.booleanNode(true);\n-\n-        case VALUE_FALSE:\n+        case JsonTokenId.ID_FALSE:\n             return nodeFactory.booleanNode(false);\n-\n-        case VALUE_NULL:\n+        case JsonTokenId.ID_NULL:\n             return nodeFactory.nullNode();\n             \n             // These states can not be mapped; input stream is\n             throw ctxt.mappingException(handledType());\n         }\n     }\n+\n+    protected final JsonNode _fromInt(JsonParser jp, DeserializationContext ctxt,\n+            JsonNodeFactory nodeFactory)\n+        throws IOException\n+    {\n+        JsonParser.NumberType nt = jp.getNumberType();\n+        if (nt == JsonParser.NumberType.BIG_INTEGER\n+            || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n+            return nodeFactory.numberNode(jp.getBigIntegerValue());\n+        }\n+        if (nt == JsonParser.NumberType.INT) {\n+            return nodeFactory.numberNode(jp.getIntValue());\n+        }\n+        return nodeFactory.numberNode(jp.getLongValue());\n+    }\n+\n+    protected final JsonNode _fromFloat(JsonParser jp, DeserializationContext ctxt,\n+            final JsonNodeFactory nodeFactory)\n+        throws IOException\n+    {\n+        JsonParser.NumberType nt = jp.getNumberType();\n+        if (nt == JsonParser.NumberType.BIG_DECIMAL\n+            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            return nodeFactory.numberNode(jp.getDecimalValue());\n+        }\n+        return nodeFactory.numberNode(jp.getDoubleValue());\n+    }\n+\n+    protected final JsonNode _fromEmbedded(JsonParser jp, DeserializationContext ctxt,\n+            JsonNodeFactory nodeFactory)\n+        throws IOException\n+    {\n+        // [JACKSON-796]\n+        Object ob = jp.getEmbeddedObject();\n+        if (ob == null) { // should this occur?\n+            return nodeFactory.nullNode();\n+        }\n+        Class<?> type = ob.getClass();\n+        if (type == byte[].class) { // most common special case\n+            return nodeFactory.binaryNode((byte[]) ob);\n+        }\n+        if (JsonNode.class.isAssignableFrom(type)) {\n+            // [Issue#433]: but could also be a JsonNode hiding in there!\n+            return (JsonNode) ob;\n+        }\n+        // any other special handling needed?\n+        return nodeFactory.pojoNode(ob);\n+    }\n }", "timestamp": 1398224243, "metainfo": ""}