{"sha": "09b7e79f536537ec6bdf8a9b0324c3dce07e40fc", "log": "Merge pull request #139 from bgertzfield/master  jackson-databind: Add PackageVersion to improve Android memory usage", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/PackageVersion.java.in\n+package @package@;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.Versioned;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Automatically generated from PackageVersion.java.in during\n+ * packageVersion-generate execution of maven-replacer-plugin in\n+ * pom.xml.\n+ */\n+public final class PackageVersion implements Versioned {\n+    public final static Version VERSION = VersionUtil.parseVersion(\n+        \"@projectversion@\", \"@projectgroupid@\", \"@projectartifactid@\");\n+\n+    @Override\n+    public Version version() {\n+        return VERSION;\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.PackageVersion;\n \n /**\n  * Tests to ensure that we get proper Version information via\n  */\n public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n {\n-    // Not a good to do this, but has to do, for now...\n-    private final static int MAJOR_VERSION = 2;\n-    private final static int MINOR_VERSION = 2;\n-\n     private final static String GROUP_ID = \"com.fasterxml.jackson.core\";\n     private final static String ARTIFACT_ID = \"jackson-databind\";\n \n         assertVersion(new JacksonAnnotationIntrospector());\n     }\n \n+    public void testDatabindVersion()\n+    {\n+        assertEquals(PackageVersion.VERSION, DatabindVersion.instance.version());\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n     {\n         Version v = vers.version();\n         assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n-        assertEquals(MAJOR_VERSION, v.getMajorVersion());\n-        assertEquals(MINOR_VERSION, v.getMinorVersion());\n-        // Check patch level initially, comment out for maint versions\n-//        assertEquals(0, v.getPatchLevel());\n-        assertEquals(GROUP_ID, v.getGroupId());\n-        assertEquals(ARTIFACT_ID, v.getArtifactId());\n+        assertEquals(PackageVersion.VERSION, v);\n     }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n  * Abstract class that defines API used by {@link ObjectMapper} (and\n  * other chained {@link JsonSerializer}s too) to serialize Objects of\n  * arbitrary types into JSON, using provided {@link JsonGenerator}.\n- *<p>\n- * NOTE: it is recommended that custom serializers extend\n  * {@link com.fasterxml.jackson.databind.ser.std.StdSerializer} instead\n  * of this class, since it will implement many of optional\n  * methods of this class.\n+ *<p>\n+ * NOTE: various <code>serialize</code> methods are never (to be) called\n+ * with null values -- caller <b>must</b> handle null values, usually\n+ * by calling {@link SerializerProvider#findNullValueSerializer} to obtain\n+ * serializer to use.\n+ * This also means that custom serializers can not be directly used to change\n+ * the output to produce when serializing null values.\n  *<p>\n  * If serializer is an aggregate one -- meaning it delegates handling of some\n  * of its contents by using other serializer(s) -- it typically also needs\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n      * Feature is disabled by default, so that no special handling is done.\n      */\n     WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED(false),\n+\n+    /**\n+     * Feature that determines whether {@link java.math.BigDecimal} entries are\n+     * serialized using {@link java.math.BigDecimal#toPlainString()} to prevent\n+     * values to be written using scientific notation.\n+     * <p>\n+     * Feature is disabled by default.\n+     */\n+    WRITE_BIGDECIMAL_AS_PLAIN(false),\n     \n     /**\n      * Feature that determines whether {@link java.util.Map} entries are first\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n                 if (kt == null || !kt.isEnum()) {\n                     throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                 }\n-                deser = new EnumMapDeserializer(type, null, contentDeser);\n+                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n             }\n \n             // Otherwise, generic handler works ok.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n         if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {\n             String name = jp.getText();\n             Enum<?> result = _resolver.findEnum(name);\n-            if (result == null  && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n-                        \"value not one of declared Enum instance names\");\n+            if (result == null) {\n+                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                    if (name.length() == 0 || name.trim().length() == 0) {\n+                        return null;\n+                    }\n+                }\n+                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+                    throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n+                            \"value not one of declared Enum instance names\");\n+                }\n             }\n             return result;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     extends StdDeserializer<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 1916979386940205321L;\n+    private static final long serialVersionUID = 1518773374647478964L;\n \n     protected final JavaType _mapType;\n     \n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n+\n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n+    public EnumMapDeserializer(JavaType mapType,\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser) {\n+        this(mapType, keyDeserializer, valueDeser, null);\n+    }\n     \n     public EnumMapDeserializer(JavaType mapType,\n-            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser)\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n     {\n         super(EnumMap.class);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n         _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n     }\n \n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n     public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n             JsonDeserializer<?> valueDeserializer)\n     {\n-        if ((keyDeserializer == _keyDeserializer) && valueDeserializer == _valueDeserializer) {\n+        return withResolved(keyDeserializer, valueDeserializer, null);\n+    } \n+    \n+    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n+            JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    {\n+        if ((keyDeserializer == _keyDeserializer)\n+                && (valueDeserializer == _valueDeserializer)\n+                && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         }\n         return new EnumMapDeserializer(_mapType,\n-                keyDeserializer, valueDeserializer);\n+                keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n     }\n     \n     /**\n                 vd = ((ContextualDeserializer) vd).createContextual(ctxt, property);\n             }\n         }\n-\n-        return withResolved(kd, vd);\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vd, vtd);\n     }\n     \n     /**\n             throw ctxt.mappingException(EnumMap.class);\n         }\n         EnumMap result = constructMap();\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n             Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             /* note: MUST check for nulls separately: deserializers will\n              * not handle them (and maybe fail or return bogus data)\n              */\n-            Object value = (t == JsonToken.VALUE_NULL) ?\n-                null :  _valueDeserializer.deserialize(jp, ctxt);\n+            Object value;\n+            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value =  valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n             result.put(key, value);\n         }\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             t = jp.nextToken();\n         }\n         final KeyDeserializer keyDes = _keyDeserializer;\n-        \n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n         JsonSerializer<Object> prevSerializer = null;\n         Class<?> prevClass = null;\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             // First, serialize key\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            // And then value\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n+                continue;\n+            }\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> currSerializer;\n+            if (cc == prevClass) {\n+                currSerializer = prevSerializer;\n             } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevClass) {\n-                    currSerializer = prevSerializer;\n+                currSerializer = provider.findValueSerializer(cc, _property);\n+                prevSerializer = currSerializer;\n+                prevClass = cc;\n+            }\n+            try {\n+                if (vts == null) {\n+                    currSerializer.serialize(valueElem, jgen, provider);\n                 } else {\n-                    currSerializer = provider.findValueSerializer(cc, _property);\n-                    prevSerializer = currSerializer;\n-                    prevClass = cc;\n+                    currSerializer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n-                try {\n-                    currSerializer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n-                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n         throws IOException, JsonGenerationException\n     {\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 // clumsy, but has to do for now:\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n-            } else {\n-                try {\n+                continue;\n+            }\n+            try {\n+                if (vts == null) {\n                     valueSer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n+                } else {\n+                    valueSer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n         {\n             // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n             if (value instanceof BigDecimal) {\n-                jgen.writeNumber((BigDecimal) value);\n+                if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n+                    jgen.writeNumber(((BigDecimal) value).toPlainString());\n+                } else {\n+                    jgen.writeNumber((BigDecimal) value);\n+                }\n             } else if (value instanceof BigInteger) {\n                 jgen.writeNumber((BigInteger) value);\n                 \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n             y = y0;\n         }\n     }\n+\n+    // [JACKSON-882]\n+    public static class CustomKey {\n+        private final int id;\n+\n+        public CustomKey(int id) {this.id = id;}\n+\n+        public int getId() { return id; }\n+    }\n+    \n+    public static class Model\n+    {\n+        protected final Map<CustomKey, String> map;\n+\n+        @JsonCreator\n+        public Model(@JsonProperty(\"map\") @JsonDeserialize(keyUsing = CustomKeyDeserializer.class) Map<CustomKey, String> map)\n+        {\n+            this.map = new HashMap<CustomKey, String>(map);\n+        }\n+\n+        @JsonProperty\n+        @JsonSerialize(keyUsing = CustomKeySerializer.class)\n+        public Map<CustomKey, String> getMap() {\n+            return map;\n+        }\n+    }\n+     \n+    static class CustomKeySerializer extends JsonSerializer<CustomKey> {\n+        @Override\n+        public void serialize(CustomKey value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(String.valueOf(value.getId()));\n+        }\n+    }\n+\n+    static class CustomKeyDeserializer extends KeyDeserializer {\n+        @Override\n+        public CustomKey deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+            return new CustomKey(Integer.valueOf(key));\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n+    final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testCustomBeanDeserializer() throws Exception\n     {\n-\n-        final ObjectMapper map = new ObjectMapper();\n         String json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"a\\\":10,\\\"b\\\":20},\\\"d\\\":\\\"hello, tatu\\\"}]}\";\n-        TestBeans beans = map.readValue(json, TestBeans.class);\n+        TestBeans beans = MAPPER.readValue(json, TestBeans.class);\n \n         assertNotNull(beans);\n         List<TestBean> results = beans.beans;\n \n         json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"b\\\":3,\\\"a\\\":-4},\\\"d\\\":\\\"\\\"},\"\n             +\"{\\\"d\\\":\\\"abc\\\", \\\"c\\\":{\\\"b\\\":15}}]}\";\n-        beans = map.readValue(json, TestBeans.class);\n+        beans = MAPPER.readValue(json, TestBeans.class);\n \n         assertNotNull(beans);\n         results = beans.beans;\n         assertEquals(3, imm.x);\n         assertEquals(7, imm.y);\n     }\n+\n+    public void testIssue882() throws Exception\n+    {\n+        Model original = new Model(Collections.singletonMap(new CustomKey(123), \"test\"));\n+        String json = MAPPER.writeValueAsString(original);\n+        Model deserialized = MAPPER.readValue(json, Model.class);\n+        assertNotNull(deserialized);\n+        assertNotNull(deserialized.map);\n+        assertEquals(1, deserialized.map.size());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n         TestEnumFor834 res = mapper.readValue(\"1 \", TestEnumFor834.class);\n         assertSame(TestEnumFor834.ENUM_A, res);\n     }\n+\n+    // [Issue#141]: allow mapping of empty String into null\n+    public void testEnumsWithEmpty() throws Exception\n+    {\n+       final ObjectMapper m = new ObjectMapper();\n+       m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+       TestEnum result = m.readValue(\"\\\"\\\"\", TestEnum.class);\n+       assertNull(result);\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n             return new KeyType(v, true);\n         }\n     }\n+\n+    // Issue #142\n+    public static class EnumMapContainer {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+        public EnumMap<KeyEnum,ITestType> testTypes;\n+    }\n+\n+    public static class ListContainer {\n+        public List<ITestType> testTypes;\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+    public static interface ITestType { }\n+\n+    public static enum KeyEnum {\n+        A, B\n+    }\n+    public static enum ConcreteType implements ITestType {\n+        ONE, TWO;\n+    }\n+\n+    \n     \n     /*\n     /**********************************************************\n         assertNull(result.get(Key.WHATEVER));\n         assertNull(result.get(Key.KEY1));\n     }\n-    \n+\n+    public void testEnumPolymorphicSerializationTest() throws Exception \n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        List<ITestType> testTypesList = new ArrayList<ITestType>();\n+        testTypesList.add(ConcreteType.ONE);\n+        testTypesList.add(ConcreteType.TWO);\n+        ListContainer listContainer = new ListContainer();\n+        listContainer.testTypes = testTypesList;\n+        String json = mapper.writeValueAsString(listContainer);\n+        listContainer = mapper.readValue(json, ListContainer.class);\n+        EnumMapContainer enumMapContainer = new EnumMapContainer();\n+        EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);\n+        testTypesMap.put(KeyEnum.A, ConcreteType.ONE);\n+        testTypesMap.put(KeyEnum.B, ConcreteType.TWO);\n+        enumMapContainer.testTypes = testTypesMap;\n+        \n+        json = mapper.writeValueAsString(enumMapContainer);\n+        enumMapContainer = mapper.readValue(json, EnumMapContainer.class);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods, maps with Date\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n         map.put(\"pi\", new BigDecimal(PI_STR));\n         String str = MAPPER.writeValueAsString(map);\n         assertEquals(\"{\\\"pi\\\":3.14159265}\", str);\n+    }\n+    \n+    public void testBigDecimalAsPlainString()\n+        throws Exception\n+    {\n+        MAPPER.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        String PI_STR = \"3.00000000\";\n+        map.put(\"pi\", new BigDecimal(PI_STR));\n+        String str = MAPPER.writeValueAsString(map);\n+        assertEquals(\"{\\\"pi\\\":3.00000000}\", str);\n     }\n     \n     /**", "timestamp": 1357841011, "metainfo": ""}