{"sha": "a8000c3713d3c9ebf7bf5292cb15514f8e6a320c", "log": "Merge pull request #451 from christophercurrie/scalaStyleProps  Scala style props", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests Scala-style JVM naming patterns for properties.\n+ *\n+ * Scala uses identifiers that are legal JVM names, but not legal Java names:\n+ *\n+ * <ul>\n+ *     <li><code>prop\u2423</code> (trailing space) for fields</li>\n+ *     <li><code>prop</code> for getters</li>\n+ *     <li><code>prop_=</code> for setters</li>\n+ * </ul>\n+ *\n+ * Scala sources turn property accesses into method calls in most cases; the\n+ * backing field and the particulars of the method names are implementation details.\n+ *\n+ * Since I can't reproduce them in Java, I've substituted legal but uncommonly\n+ * used characters as placeholders.\n+ */\n+public class TestScalaLikeImplicitProperties extends BaseMapTest\n+{\n+    static class ValProperty\n+    {\n+        public final String prop\u203f;\n+        public String prop() { return prop\u203f; }\n+\n+        public ValProperty(String prop) {\n+            prop\u203f = prop;\n+        }\n+    }\n+\n+\n+    static class ValWithBeanProperty\n+    {\n+        public final String prop\u203f;\n+        public String prop() { return prop\u203f; }\n+        public String getProp() { return prop\u203f; }\n+\n+        public ValWithBeanProperty(String prop) {\n+            prop\u203f = prop;\n+        }\n+    }\n+\n+\n+    static class VarProperty\n+    {\n+        public String prop\u203f;\n+        public String prop() { return prop\u203f; }\n+        public void prop_\u2040(String p) { prop\u203f = p; }\n+\n+        public VarProperty(String prop) {\n+            prop\u203f = prop;\n+        }\n+    }\n+\n+\n+    static class VarWithBeanProperty\n+    {\n+        public String prop\u203f;\n+        public String prop() { return prop\u203f; }\n+        public void prop_\u2040(String p) { prop\u203f = p; }\n+        public String getProp() { return prop\u203f; }\n+        public void setProp(String p) { prop\u203f = p; }\n+\n+        public VarWithBeanProperty(String prop) {\n+            prop\u203f = prop;\n+        }\n+    }\n+\n+    static class GetterSetterProperty\n+    {\n+        // Different name to represent an arbitrary implementation, not necessarily local to this class.\n+        private String _prop_impl = \"get/set\";\n+        public String prop() { return _prop_impl; }\n+        public void prop_\u2040(String p) { _prop_impl = p; }\n+\n+        // Getter/Setters are typically not in the constructor because they are implemented\n+        // by the end user, not the compiler. They should be detected similar to 'bean-style'\n+        // getProp/setProp pairs.\n+    }\n+\n+\n+    public void testValProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // TODO: Activate whatever handler implements the property detection style\n+\n+        assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValProperty(\"val\")));\n+    }\n+\n+\n+    public void testValWithBeanProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // TODO: Activate whatever handler implements the property detection style\n+\n+        assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValWithBeanProperty(\"val\")));\n+    }\n+\n+\n+    public void testVarProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // TODO: Activate whatever handler implements the property detection style\n+\n+        assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarProperty(\"var\")));\n+        VarProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarProperty.class);\n+        assertEquals(\"read\", result.prop());\n+    }\n+\n+\n+    public void testVarWithBeanProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // TODO: Activate whatever handler implements the property detection style\n+\n+        assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarWithBeanProperty(\"var\")));\n+        VarWithBeanProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarWithBeanProperty.class);\n+        assertEquals(\"read\", result.prop());\n+    }\n+\n+\n+    public void testGetterSetterProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // TODO: Activate whatever handler implements the property detection style\n+\n+        assertEquals(\"{\\\"prop\\\":\\\"get/set\\\"}\", m.writeValueAsString(new GetterSetterProperty()));\n+        GetterSetterProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", GetterSetterProperty.class);\n+        assertEquals(\"read\", result.prop());\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n             if (_filterId != null) {\n                 serializeFilteredFields(value, jgen, provider,\n                         findPropertyFilter(provider, _filterId, value));\n+                jgen.writeEndObject();\n                 return;\n             }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n     {\n         FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n                 SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n-        assertEquals(aposToQuotes(\"{'values':{'b':5}}\"),\n-                MAPPER.writer(prov).writeValueAsString(new MapBean()));\n+        String json = MAPPER.writer(prov).writeValueAsString(new MapBean());\n+        assertEquals(aposToQuotes(\"{'values':{'b':5}}\"), json);\n     }\n \n     public void testMapFilteringViaClass() throws Exception\n         bean.put(\"b\", 3);\n         FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterForMaps\",\n                 SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n-        assertEquals(aposToQuotes(\"{'b':3}\"),\n-                MAPPER.writer(prov).writeValueAsString(bean));\n+        String json = MAPPER.writer(prov).writeValueAsString(bean);\n+        assertEquals(aposToQuotes(\"{'b':3}\"), json);\n     }\n     \n }\n--- a/src/test/java/perf/ManualReadPerfUntyped.java\n+++ b/src/test/java/perf/ManualReadPerfUntyped.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n \n-public class ManualReadPerfUntyped extends ObjectReaderBase\n+public class ManualReadPerfUntyped extends ObjectReaderTestBase\n {\n     @Override\n     protected int targetSizeMegs() { return 10; }\n--- a/src/test/java/perf/ManualReadPerfUntypedReader.java\n+++ b/src/test/java/perf/ManualReadPerfUntypedReader.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n \n-public class ManualReadPerfUntypedReader extends ObjectReaderBase\n+public class ManualReadPerfUntypedReader extends ObjectReaderTestBase\n {\n     @Override\n     protected int targetSizeMegs() { return 15; }\n--- a/src/test/java/perf/ManualReadPerfUntypedStream.java\n+++ b/src/test/java/perf/ManualReadPerfUntypedStream.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n \n-public class ManualReadPerfUntypedStream extends ObjectReaderBase\n+public class ManualReadPerfUntypedStream extends ObjectReaderTestBase\n {\n     @Override\n     protected int targetSizeMegs() { return 15; }\n--- a/src/test/java/perf/ManualReadPerfWithMedia.java\n+++ b/src/test/java/perf/ManualReadPerfWithMedia.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n-public class ManualReadPerfWithMedia extends ObjectReaderBase\n+public class ManualReadPerfWithMedia extends ObjectReaderTestBase\n {\n     @Override\n     protected int targetSizeMegs() { return 8; }\n--- a/src/test/java/perf/ManualReadPerfWithRecord.java\n+++ b/src/test/java/perf/ManualReadPerfWithRecord.java\n  * Simple manually run micro-benchmark for checking effects of (de)serializer\n  * pre-fetching\n  */\n-public class ManualReadPerfWithRecord extends ObjectReaderBase\n+public class ManualReadPerfWithRecord extends ObjectReaderTestBase\n {\n     @Override\n     protected int targetSizeMegs() { return 8; }\n--- a/src/test/java/perf/ManualReadPerfWithUUID.java\n+++ b/src/test/java/perf/ManualReadPerfWithUUID.java\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n \n-public class ManualReadPerfWithUUID extends ObjectReaderBase\n+public class ManualReadPerfWithUUID extends ObjectReaderTestBase\n {\n     static class UUIDNative {\n         public UUID[] ids;\n--- a/src/test/java/perf/ManualWritePerfUntyped.java\n+++ b/src/test/java/perf/ManualWritePerfUntyped.java\n  * Jackson implementation.\n  */\n public class ManualWritePerfUntyped\n-    extends ObjectWriterBase<Object,Object>\n+    extends ObjectWriterTestBase<Object,Object>\n {\n     @Override\n     protected int targetSizeMegs() { return 15; }\n         ObjectMapper mapper = new ObjectMapper();\n         Map<?,?> stuff = mapper.readValue(new File(args[0]), Map.class);\n         new ManualWritePerfUntyped().test(mapper,\n-                \"AllTypes/small-1\", stuff, Object.class,\n-                \"AllTypes/small-2\", stuff, Object.class);\n+                \"Untyped-1\", stuff, Object.class,\n+                \"Untyped-2\", stuff, Object.class);\n     }\n \n     @Override\n-    protected long testSer(int REPS, Object value, ObjectWriter writer) throws Exception\n+    protected double testSer(int REPS, Object value, ObjectWriter writer) throws Exception\n     {\n-        final NopOutputStream out = new NopOutputStream();\n         long start = System.nanoTime();\n-        byte[] output = null;\n \n+        // As Bytes\n+        /*\n+//        byte[] output = null;\n+        NopOutputStream out = new NopOutputStream();\n         while (--REPS >= 0) {\n-            output = writer.writeValueAsBytes(value);\n+//            output = writer.writeValueAsBytes(value);\n+            writer.writeValue(out, value);\n         }\n-        hash = output.length;\n         long nanos = System.nanoTime() - start;\n+        hash = out.size;\n         out.close();\n-        return nanos;\n+        */\n+\n+        // As String\n+\n+//        String output = null;\n+        NopWriter w = new NopWriter();\n+        while (--REPS >= 0) {\n+//            output = writer.writeValueAsString(value);\n+            writer.writeValue(w, value);\n+        }\n+        long nanos = System.nanoTime() - start;\n+//        hash = output.length();\n+        hash = w.size();\n+\n+        return _msecsFromNanos(nanos);\n     }\n }\n--- a/src/test/java/perf/ManualWritePerfWithAllTypes.java\n+++ b/src/test/java/perf/ManualWritePerfWithAllTypes.java\n  * Jackson implementation.\n  */\n public class ManualWritePerfWithAllTypes\n-    extends ObjectWriterBase<ManualWritePerfWithAllTypes.AllTypes, ManualWritePerfWithAllTypes.AllTypes>\n+    extends ObjectWriterTestBase<ManualWritePerfWithAllTypes.AllTypes, ManualWritePerfWithAllTypes.AllTypes>\n {\n     @Override\n     protected int targetSizeMegs() { return 15; }\n     }\n \n     @Override\n-    protected long testSer(int REPS, Object value, ObjectWriter writer) throws Exception\n+    protected double testSer(int REPS, Object value, ObjectWriter writer) throws Exception\n     {\n         final NopOutputStream out = new NopOutputStream();\n         long start = System.nanoTime();\n         hash = output.length;\n         long nanos = System.nanoTime() - start;\n         out.close();\n-        return nanos;\n+        return _msecsFromNanos(nanos);\n     }\n \n     // Value type for test\n--- a/src/test/java/perf/ManualWritePerfWithRecord.java\n+++ b/src/test/java/perf/ManualWritePerfWithRecord.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n public class ManualWritePerfWithRecord\n-    extends ObjectWriterBase<Record, RecordAsArray>\n+    extends ObjectWriterTestBase<Record, RecordAsArray>\n {\n     @Override\n     protected int targetSizeMegs() { return 10; }\n--- a/src/test/java/perf/ManulWritePerfWithUUID.java\n+++ b/src/test/java/perf/ManulWritePerfWithUUID.java\n import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n \n public class ManulWritePerfWithUUID\n-    extends ObjectWriterBase<UUIDFast, UUIDSlow>\n+    extends ObjectWriterTestBase<UUIDFast, UUIDSlow>\n {\n     @Override\n     protected int targetSizeMegs() { return 10; }\n--- /dev/null\n+++ b/src/test/java/perf/NopWriter.java\n+package perf;\n+\n+import java.io.*;\n+\n+public class NopWriter extends Writer\n+{\n+    protected int size = 0;\n+    \n+    public NopWriter() { }\n+\n+    @Override\n+    public void write(int b) throws IOException { ++size; }\n+\n+    @Override\n+    public void write(char[] b) throws IOException { size += b.length; }\n+\n+    @Override\n+    public void write(char[] b, int offset, int len) throws IOException { size += len; }\n+\n+    public int size() { return size; }\n+\n+    @Override\n+    public void close() throws IOException { }\n+\n+    @Override\n+    public void flush() throws IOException { }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/ObjectReaderTestBase.java\n+package perf;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+abstract class ObjectReaderTestBase\n+{\n+    protected final static int WARMUP_ROUNDS = 5;\n+\n+    protected String _desc1, _desc2;\n+    \n+    protected int hash;\n+    protected int roundsDone = 0;\n+    protected int REPS;\n+    private double[] timeMsecs;\n+\n+    protected abstract int targetSizeMegs();\n+    \n+    protected void testFromBytes(ObjectMapper mapper1, String desc1,\n+            Object inputValue1, Class<?> inputClass1,\n+            ObjectMapper mapper2, String desc2,\n+            Object inputValue2, Class<?> inputClass2)\n+        throws Exception\n+    {\n+        final byte[] byteInput1 = mapper1.writeValueAsBytes(inputValue1);\n+        final byte[] byteInput2 = mapper2.writeValueAsBytes(inputValue2);\n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        REPS = (int) ((double) (targetSizeMegs() * 1000 * 1000) / (double) byteInput1.length);\n+\n+        // sanity check:\n+        /*T1 back1 =*/ mapper1.readValue(byteInput1, inputClass1);\n+        /*T2 back2 =*/ mapper2.readValue(byteInput2, inputClass2);\n+        System.out.println(\"Input successfully round-tripped for both styles...\");\n+\n+        _desc1 = String.format(\"%s (%d bytes)\", desc1, byteInput1.length);\n+        _desc2 = String.format(\"%s (%d bytes)\", desc2, byteInput2.length);\n+        \n+        doTest(mapper1, byteInput1, inputClass1, mapper2, byteInput2, inputClass2);\n+    }\n+    \n+    protected void testFromString(ObjectMapper mapper1, String desc1,\n+            Object inputValue1, Class<?> inputClass1,\n+            ObjectMapper mapper2, String desc2,\n+            Object inputValue2, Class<?> inputClass2)\n+        throws Exception\n+    {\n+        final String input1 = mapper1.writeValueAsString(inputValue1);\n+        final String input2 = mapper2.writeValueAsString(inputValue2);\n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        REPS = (int) ((double) (targetSizeMegs() * 1000 * 1000) / (double) input1.length());\n+        _desc1 = String.format(\"%s (%d chars)\", desc1, input1.length());\n+        _desc2 = String.format(\"%s (%d chars)\", desc2, input2.length());\n+\n+        // sanity check:\n+        /*T1 back1 =*/ mapper1.readValue(input1, inputClass1);\n+        /*T2 back2 =*/ mapper2.readValue(input2, inputClass2);\n+        System.out.println(\"Input successfully round-tripped for both styles...\");\n+        \n+        doTest(mapper1, input1, inputClass1, mapper2, input2, inputClass2);\n+    }\n+    \n+    protected void doTest(ObjectMapper mapper1, byte[] byteInput1, Class<?> inputClass1,\n+            ObjectMapper mapper2, byte[] byteInput2, Class<?> inputClass2)\n+        throws Exception\n+    {\n+        System.out.printf(\"Read %d bytes to bind (%d as array); will do %d repetitions\\n\",\n+                byteInput1.length, byteInput2.length, REPS);\n+\n+        final ObjectReader jsonReader = mapper1.reader()\n+                .withType(inputClass1);\n+        final ObjectReader arrayReader = mapper2.reader()\n+                .withType(inputClass2);\n+        \n+        int i = 0;\n+        final int TYPES = 2;\n+\n+        timeMsecs = new double[TYPES];\n+        \n+        while (true) {\n+            Thread.sleep(100L);\n+            int type = (i++ % TYPES);\n+\n+            String msg;\n+            double msesc;\n+            \n+            switch (type) {\n+            case 0:\n+                msg = _desc1;\n+                msesc = testDeser1(REPS, byteInput1, jsonReader);\n+                break;\n+            case 1:\n+                msg = _desc2;\n+                msesc = testDeser2(REPS, byteInput2, arrayReader);\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            updateStats(type, (i % 17) == 0, msg, msesc);\n+        }\n+    }\n+\n+    protected void doTest(ObjectMapper mapper1, String input1, Class<?> inputClass1,\n+            ObjectMapper mapper2, String input2, Class<?> inputClass2)\n+        throws Exception\n+    {\n+        System.out.printf(\"Read %d bytes to bind (%d as array); will do %d repetitions\\n\",\n+                input1.length(), input2.length(), REPS);\n+\n+        final ObjectReader jsonReader = mapper1.reader()\n+                .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n+                .withType(inputClass1);\n+        final ObjectReader arrayReader = mapper2.reader()\n+                .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n+                .withType(inputClass2);\n+        \n+        int i = 0;\n+        final int TYPES = 2;\n+\n+        timeMsecs = new double[TYPES];\n+\n+        while (true) {\n+            Thread.sleep(100L);\n+            int type = (i++ % TYPES);\n+\n+// !!! TEST\n+//type = 0;            \n+            \n+            String msg;\n+            double msecs;\n+            \n+            switch (type) {\n+            case 0:\n+                msg = _desc1;\n+                msecs = testDeser1(REPS, input1, jsonReader);\n+                break;\n+            case 1:\n+                msg = _desc2;\n+                msecs = testDeser2(REPS, input2, arrayReader);\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            updateStats(type, (i % 17) == 0, msg, msecs);\n+        }\n+    }\n+    \n+    private void updateStats(int type, boolean doGc, String msg, double msecs)\n+        throws Exception\n+    {\n+        // skip first N rounds to let results stabilize\n+        if (roundsDone >= WARMUP_ROUNDS) {\n+            timeMsecs[type] += msecs;\n+        }\n+        System.out.printf(\"Test '%s' [hash: 0x%s] -> %.1f msecs\\n\", msg, this.hash, msecs);\n+        if (type == 0) {\n+            ++roundsDone;\n+            if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                System.out.printf(\"Averages after %d rounds (Object / Array): %.1f / %.1f msecs\\n\",\n+                        (int) den,\n+                        timeMsecs[0] / den, timeMsecs[1] / den);\n+                        \n+            }\n+            System.out.println();\n+        }\n+        if (doGc) {\n+            System.out.println(\"[GC]\");\n+            Thread.sleep(100L);\n+            System.gc();\n+            Thread.sleep(100L);\n+        }\n+    }\n+\n+    protected double testDeser1(int reps, byte[] input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+    protected double testDeser2(int reps, byte[] input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+    \n+    protected final double _testDeser(int reps, byte[] input, ObjectReader reader) throws Exception\n+    {\n+        long start = System.nanoTime();\n+        Object result = null;\n+        while (--reps >= 0) {\n+            result = reader.readValue(input);\n+        }\n+        hash = result.hashCode();\n+        // return microseconds\n+        return _msecsFromNanos(System.nanoTime() - start);\n+    }\n+\n+    protected double testDeser1(int reps, String input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+\n+    protected double testDeser2(int reps, String input, ObjectReader reader) throws Exception {\n+        return _testDeser(reps, input, reader);\n+    }\n+    \n+    protected final double _testDeser(int reps, String input, ObjectReader reader) throws Exception\n+    {\n+        long start = System.nanoTime();\n+        Object result = null;\n+        while (--reps >= 0) {\n+            result = reader.readValue(input);\n+        }\n+        hash = result.hashCode();\n+        return _msecsFromNanos(System.nanoTime() - start);\n+    }\n+\n+    protected final double _msecsFromNanos(long nanos) {\n+        return (nanos / 1000000.0);\n+    }\n+    \n+    protected static byte[] readAll(String filename) throws IOException\n+    {\n+        File f = new File(filename);\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream((int) f.length());\n+        byte[] buffer = new byte[4000];\n+        int count;\n+        FileInputStream in = new FileInputStream(f);\n+        \n+        while ((count = in.read(buffer)) > 0) {\n+            bytes.write(buffer, 0, count);\n+        }\n+        in.close();\n+        return bytes.toByteArray();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/ObjectWriterTestBase.java\n+package perf;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+abstract class ObjectWriterTestBase<T1,T2>\n+{\n+    protected int hash;\n+\n+    protected abstract int targetSizeMegs();\n+\n+    protected void test(ObjectMapper mapper,\n+            String desc1, T1 inputValue1, Class<? extends T1> inputClass1,\n+            String desc2, T2 inputValue2, Class<? extends T2> inputClass2)\n+        throws Exception\n+    {\n+        final int REPS;\n+        {\n+            final byte[] input1 = mapper.writeValueAsBytes(inputValue1);\n+            final byte[] input2 = mapper.writeValueAsBytes(inputValue2);\n+            \n+            // Let's try to guestimate suitable size, N megs of output\n+            REPS = (int) ((double) (targetSizeMegs() * 1000 * 1000) / (double) input1.length);\n+            System.out.printf(\"Read %d bytes to bind (%d as array); will do %d repetitions\\n\",\n+                    input1.length, input2.length, REPS);\n+        }\n+\n+        final ObjectWriter writer0 = mapper.writer().with(SerializationFeature.EAGER_SERIALIZER_FETCH);\n+        final ObjectWriter writer1 = writer0.withType(inputClass1);\n+        final ObjectWriter writer2 = writer0.withType(inputClass2);\n+        \n+        int i = 0;\n+        int roundsDone = 0;\n+        final int TYPES = 2;\n+\n+        // Skip first 5 seconds\n+        long startMeasure = System.currentTimeMillis() + 5000L;\n+        \n+        final double[] timesMsec = new double[TYPES];\n+\n+        System.out.print(\"Warming up\");\n+        \n+        while (true) {\n+            final int round = (i % TYPES);\n+            final boolean lf = (++i % TYPES) == 0;\n+\n+            String msg;\n+\n+            ObjectWriter writer;\n+            Object value;\n+            switch (round) {\n+            case 0:\n+                msg = desc1;\n+                writer = writer1;\n+                value = inputValue1;\n+                break;\n+            case 1:\n+                msg = desc2;\n+                writer = writer2;\n+                value = inputValue2;\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+\n+            double msecs = testSer(REPS, value, writer);\n+\n+            // skip first N seconds to let results stabilize\n+            if (startMeasure > 0L) {\n+                if ((round != 0) || (System.currentTimeMillis() < startMeasure)) {\n+                    System.out.print(\".\");\n+                    continue;\n+                }\n+                startMeasure = 0L;\n+                System.out.println();\n+                System.out.println(\"Starting measurements...\");\n+                Thread.sleep(250L);\n+                System.out.println();\n+            }\n+\n+            timesMsec[round] += msecs;\n+\n+            if ((i % 17) == 0) {\n+                System.out.println(\"[GC]\");\n+                Thread.sleep(100L);\n+                System.gc();\n+                Thread.sleep(100L);\n+            }\n+            \n+            System.out.printf(\"Test '%s' [hash: 0x%s] -> %.1f msecs\\n\", msg, hash, msecs);\n+            Thread.sleep(50L);\n+            if (!lf) {\n+                continue;\n+            }\n+            \n+            if ((++roundsDone % 3) == 0) {\n+                double den = (double) roundsDone;\n+                System.out.printf(\"Averages after %d rounds (%s/%s): %.1f / %.1f msecs\\n\",\n+                        roundsDone, desc1, desc2,\n+                        timesMsec[0] / den, timesMsec[1] / den);\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+    protected double testSer(int REPS, Object value, ObjectWriter writer) throws Exception\n+    {\n+        final NopOutputStream out = new NopOutputStream();\n+        long start = System.nanoTime();\n+        while (--REPS >= 0) {\n+            writer.writeValue(out, value);\n+        }\n+        hash = out.size();\n+        long nanos = System.nanoTime() - start;\n+        out.close();\n+        return _msecsFromNanos(nanos);\n+    }\n+\n+    protected final double _msecsFromNanos(long nanos) {\n+        return (nanos / 1000000.0);\n+    }\n+}", "timestamp": 1398879902, "metainfo": ""}