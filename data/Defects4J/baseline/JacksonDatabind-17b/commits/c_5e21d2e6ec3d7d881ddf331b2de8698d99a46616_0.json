{"sha": "5e21d2e6ec3d7d881ddf331b2de8698d99a46616", "log": "Bit more rearranging; trying to reduce use of inner classes for shared things (only leave inner classes for private use)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n  * @author pgelinas\n  */\n public final class UnresolvedForwardReference extends JsonMappingException {\n-\n-    private static final long serialVersionUID = -5097969645059502061L;\n+    private static final long serialVersionUID = 1L;\n     private ReadableObjectId _roid;\n     private List<UnresolvedId> _unresolvedIds;\n \n     // ****** Accessor methods ******\n     // ******************************\n \n-    public ReadableObjectId getRoid()\n-    {\n+    public ReadableObjectId getRoid() {\n         return _roid;\n     }\n \n-    public Object getUnresolvedId()\n-    {\n+    public Object getUnresolvedId() {\n         return _roid.id;\n     }\n \n-    /**\n-     * Helper class\n-     * \n-     * @author pgelinas\n-     */\n-    public static class UnresolvedId {\n-        private Object _id;\n-        private JsonLocation _location;\n-        private Class<?> _type;\n-\n-        public UnresolvedId(Object id, Class<?> type, JsonLocation where)\n-        {\n-            _id = id;\n-            _type = type;\n-            _location = where;\n-        }\n-        \n-        /**\n-         * The id which is unresolved.\n-         */\n-        public Object getId() { return _id; }\n-        /**\n-         * The type of object which was expected.\n-         */\n-        public Class<?> getType() { return _type; }\n-        public JsonLocation getLocation() { return _location; }\n-\n-        @Override\n-        public String toString()\n-        {\n-            return String.format(\"Object id [%s] (for %s) at %s\", _id, _type, _location);\n-        }\n-    }\n-\n-    public void addUnresolvedId(Object id, Class<?> type, JsonLocation where)\n-    {\n+    public void addUnresolvedId(Object id, Class<?> type, JsonLocation where) {\n         _unresolvedIds.add(new UnresolvedId(id, type, where));\n     }\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedId.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+\n+/**\n+ * Helper class for {@link UnresolvedForwardReference}, to contain information about unresolved ids.\n+ * \n+ * @author pgelinas\n+ */\n+public class UnresolvedId {\n+    private Object _id;\n+    private JsonLocation _location;\n+    private Class<?> _type;\n+\n+    public UnresolvedId(Object id, Class<?> type, JsonLocation where)\n+    {\n+        _id = id;\n+        _type = type;\n+        _location = where;\n+    }\n+    \n+    /**\n+     * The id which is unresolved.\n+     */\n+    public Object getId() { return _id; }\n+\n+    /**\n+     * The type of object which was expected.\n+     */\n+    public Class<?> getType() { return _type; }\n+    public JsonLocation getLocation() { return _location; }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Object id [%s] (for %s) at %s\", _id, _type, _location);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n \n /**\n  * Wrapper property that is used to handle managed (forward) properties\n- * (see [JACKSON-235] for more information). Basically just need to\n- * delegate first to actual forward property, and \n+ * Basically just needs to delegate first to actual forward property, and\n+ * then to back property.\n  */\n public final class ManagedReferenceProperty\n     extends SettableBeanProperty\n \n     protected final SettableBeanProperty _backProperty;\n     \n-    public ManagedReferenceProperty(SettableBeanProperty forward,\n-            String refName, SettableBeanProperty backward,\n-            Annotations contextAnnotations, boolean isContainer)\n+    public ManagedReferenceProperty(SettableBeanProperty forward, String refName,\n+            SettableBeanProperty backward, Annotations contextAnnotations, boolean isContainer)\n     {\n         super(forward.getFullName(), forward.getType(), forward.getWrapperName(),\n                 forward.getValueTypeDeserializer(), contextAnnotations,\n      */\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                                  Object instance)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance)\n+            throws IOException, JsonProcessingException {\n         set(instance, _managedProperty.deserialize(jp, ctxt));\n     }\n \n     @Override\n-    public Object deserializeSetAndReturn(JsonParser jp,\n-    \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance)\n+            throws IOException, JsonProcessingException {\n         return setAndReturn(instance, deserialize(jp, ctxt));\n     }\n     \n     @Override\n-    public final void set(Object instance, Object value)\n-        throws IOException\n-    {\n+    public final void set(Object instance, Object value) throws IOException {\n     \tsetAndReturn(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-   \t\tthrows IOException\n-\t{\n+    public Object setAndReturn(Object instance, Object value) throws IOException\n+    {\n+        /* 04-Feb-2014, tatu: As per [#390], it may be necessary to switch the\n+         *   ordering of forward/backward references, and start with back ref.\n+         *   But before doing that, need a unit test.\n+         */\n+        \n+        // Start with forward property\n         Object result = _managedProperty.setAndReturn(instance, value);\n         /* And then back reference, if (and only if!) we actually have a non-null\n          * reference\n             if (_isContainer) { // ok, this gets ugly... but has to do for now\n                 if (value instanceof Object[]) {\n                     for (Object ob : (Object[]) value) {\n-                        if (ob != null) {\n-                            _backProperty.set(ob, instance);                            \n-                        }\n+                        if (ob != null) { _backProperty.set(ob, instance); }\n                     }\n                 } else if (value instanceof Collection<?>) {\n                     for (Object ob : (Collection<?>) value) {\n-                        if (ob != null) {\n-                            _backProperty.set(ob, instance);                            \n-                        }\n+                        if (ob != null) { _backProperty.set(ob, instance); }\n                     }\n                 } else if (value instanceof Map<?,?>) {\n                     for (Object ob : ((Map<?,?>) value).values()) {\n-                        if (ob != null) {\n-                            _backProperty.set(ob, instance);                            \n-                        }\n+                        if (ob != null) { _backProperty.set(ob, instance); }\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Unsupported container type (\"+value.getClass().getName()\n         }\n         return result;\n \t}\n-}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n         this.id = id;\n     }\n \n-    public void appendReferring(Referring currentReferring)\n-    {\n+    public void appendReferring(Referring currentReferring) {\n         if (_referringProperties == null) {\n             _referringProperties = new LinkedList<Referring>();\n         }\n      * Method called to assign actual POJO to which ObjectId refers to: will\n      * also handle referring properties, if any, by assigning POJO.\n      */\n-    public void bindItem(Object ob)\n-        throws IOException\n+    public void bindItem(Object ob) throws IOException\n     {\n         if (item != null) {\n             throw new IllegalStateException(\"Already had POJO for id (\" + id.getClass().getName() + \") [\" + id + \"]\");\n             Iterator<Referring> it = _referringProperties.iterator();\n             _referringProperties = null;\n             while (it.hasNext()) {\n-                Referring ref = it.next();\n-                ref.handleResolvedForwardReference(id, ob);\n+                it.next().handleResolvedForwardReference(id, ob);\n             }\n         }\n     }\n \n-    public boolean hasReferringProperties()\n-    {\n+    public boolean hasReferringProperties() {\n         return (_referringProperties != null) && !_referringProperties.isEmpty();\n     }\n \n-    public Iterator<Referring> referringProperties()\n-    {\n+    public Iterator<Referring> referringProperties() {\n         if (_referringProperties == null) {\n             return Collections.<Referring> emptyList().iterator();\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         }\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        CollectionReferringAccumulator referringAccumulator =\n+            (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(result);\n+\n         JsonToken t;\n-        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        CollectionReferringAccumulator referringAccumulator = null;\n-        if(valueDes.getObjectIdReader() != null){\n-            referringAccumulator = new CollectionReferringAccumulator(result);\n-        }\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n             try {\n                 Object value;\n             return id;\n         }\n \n-        public void resolveForwardReference(Object id, Object value)\n-            throws IOException\n+        public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n             Iterator<UnresolvedId> iterator = _accumulator.iterator();\n             // Resolve ordering after resolution of an id. This mean either:\n             }\n \n             @Override\n-            public void handleResolvedForwardReference(Object id, Object value)\n-                throws IOException\n-            {\n+            public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n                 resolveForwardReference(id, value);\n             }\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n-import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference.UnresolvedId;\n+import com.fasterxml.jackson.databind.deser.UnresolvedId;\n import com.fasterxml.jackson.databind.struct.TestObjectId.Company;\n import com.fasterxml.jackson.databind.struct.TestObjectId.Employee;\n ", "timestamp": 1391582072, "metainfo": ""}