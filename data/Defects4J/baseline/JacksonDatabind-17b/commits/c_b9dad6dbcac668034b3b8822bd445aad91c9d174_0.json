{"sha": "b9dad6dbcac668034b3b8822bd445aad91c9d174", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java\n package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Defines interface for resolvers that can resolve abstract types into concrete\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.Named;\n \n-\n /**\n  * Bean properties are logical entities that represent data\n- * Java objects (\"beans\", although more accurately POJOs)\n- * contain; and that are accessed using some combination\n- * of methods (getter, setter), field and constructor\n- * parameter.\n+ * that Java objects (POJOs (Plain Old Java Objects), sometimes also called \"beans\")\n+ * contain; and that are accessed using accessors (methods like getters\n+ * and setters, fields, contstructor parametrers).\n  * Instances allow access to annotations directly associated\n  * to property (via field or method), as well as contextual\n  * annotations (annotations for class that contains properties).\n  *<p>\n- * Instances are passed during construction of serializers and\n- * deserializers, and references can be stored by serializers\n- * and deserializers for futher use; mostly to retain access\n- * to annotations when dynamically locating handlers for\n- * sub-properties or dynamic types.\n+ * Instances are not typically passed when constructing serializers\n+ * and deserializers, but rather only passed when context\n+ * is known when\n+ * {@link com.fasterxml.jackson.databind.ser.ContextualSerializer} and\n+ * {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}\n+ * resolution occurs (<code>createContextual(...)</code> method is called).\n+ * References may (need to) be retained by serializers and deserializers,\n+ * especially when further resolving dependant handlers like value\n+ * serializers/deserializers or structured types.\n  */\n public interface BeanProperty extends Named\n {\n     \n     /*\n     /**********************************************************\n-    /* Simple stand-alone implementation, useful as a placeholder\n-    /* or base class.\n+    /* Helper classes\n     /**********************************************************\n      */\n \n+    /**\n+     * Simple stand-alone implementation, useful as a placeholder\n+     * or base class for more complex implementations.\n+     */\n     public static class Std implements BeanProperty\n     {\n         protected final String _name;\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n  * serialization and deserialization purposes.\n  * These instances are created before actual {@link BeanProperty}\n  * instances are created, i.e. they are used earlier in the process\n- * flow.\n+ * flow, and are typically use to construct actual\n+ * {@link BeanProperty} instances.\n  */\n public abstract class BeanPropertyDefinition\n     implements Named\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.*;\n-import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * Convenience method for checking whether specified on/off\n      * feature is enabled\n      */\n-    public final boolean isEnabled(DeserializationConfig.Feature feat) {\n+    public final boolean isEnabled(DeserializationFeature feat) {\n         /* 03-Dec-2010, tatu: minor shortcut; since this is called quite often,\n          *   let's use a local copy of feature settings:\n          */\n         return (_featureFlags & feat.getMask()) != 0;\n     }\n \n-    public final boolean isEnabled(MapperConfig.Feature feat) {\n+    public final boolean isEnabled(MapperFeature feat) {\n         return _config.isEnabled(feat);\n     }\n     \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features that affect\n+ * the way Java objects are deserialized from JSON\n+ *<p>\n+ * Note that features can be set both through\n+ * {@link ObjectMapper} (as sort of defaults) and through\n+ * {@link ObjectReader}.\n+ * In first case these defaults must follow \"config-then-use\" patterns\n+ * (i.e. defined once, not changed afterwards); all per-call\n+ * changes must be done using {@link ObjectReader}.\n+ */\n+public enum DeserializationFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /* Type conversion features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether JSON floating point numbers\n+     * are to be deserialized into {@link java.math.BigDecimal}s\n+     * if only generic type description (either {@link Object} or\n+     * {@link Number}, or within untyped {@link java.util.Map}\n+     * or {@link java.util.Collection} context) is available.\n+     * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n+     * if disabled, will be deserialized as {@link Double}s.\n+     * <p>\n+     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * point numbers will by default be deserialized as {@link Double}s\n+     * (choice is for performance reason -- BigDecimals are slower than\n+     * Doubles).\n+     */\n+    USE_BIG_DECIMAL_FOR_FLOATS(false),\n+\n+    /**\n+     * SerializationFeature that determines whether JSON integral (non-floating-point)\n+     * numbers are to be deserialized into {@link java.math.BigInteger}s\n+     * if only generic type description (either {@link Object} or\n+     * {@link Number}, or within untyped {@link java.util.Map}\n+     * or {@link java.util.Collection} context) is available.\n+     * If enabled such values will be deserialized as\n+     * {@link java.math.BigInteger}s;\n+     * if disabled, will be deserialized as \"smallest\" available type,\n+     * which is either {@link Integer}, {@link Long} or\n+     * {@link java.math.BigInteger}, depending on number of digits.\n+     * <p>\n+     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * point numbers will by default be deserialized using whatever\n+     * is the most compact integral type, to optimize efficiency.\n+     */\n+    USE_BIG_INTEGER_FOR_INTS(false),\n+\n+    // [JACKSON-652]\n+    /**\n+     * SerializationFeature that determines whether JSON Array is mapped to\n+     * <code>Object[]</code> or <code>List&lt;Object></code> when binding\n+     * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n+     * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n+     *<p>\n+     * SerializationFeature is disabled by default, meaning that JSON arrays are bound as\n+     * {@link java.util.List}s.\n+     */\n+    USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n+    \n+    /**\n+     * SerializationFeature that determines standard deserialization mechanism used for\n+     * Enum values: if enabled, Enums are assumed to have been serialized  using\n+     * return value of <code>Enum.toString()</code>;\n+     * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n+     *<p>\n+     * Note: this feature should usually have same value\n+     * as {@link SerializationConfig.SerializationFeature#WRITE_ENUMS_USING_TO_STRING}.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    READ_ENUMS_USING_TO_STRING(false),\n+    \n+    /*\n+    /******************************************************\n+     *  Error handling features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether encountering of unknown\n+     * properties (ones that do not map to a property, and there is\n+     * no \"any setter\" or handler that can handle it)\n+     * should result in a failure (by throwing a\n+     * {@link JsonMappingException}) or not.\n+     * This setting only takes effect after all other handling\n+     * methods for unknown properties have been tried, and\n+     * property remains unhandled.\n+     *<p>\n+     * SerializationFeature is enabled by default (meaning that a\n+     * {@link JsonMappingException} will be thrown if an unknown property\n+     * is encountered).\n+     */\n+    FAIL_ON_UNKNOWN_PROPERTIES(true),\n+\n+    /**\n+     * SerializationFeature that determines whether encountering of JSON null\n+     * is an error when deserializing into Java primitive types\n+     * (like 'int' or 'double'). If it is, a JsonProcessingException\n+     * is thrown to indicate this; if not, default value is used\n+     * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    FAIL_ON_NULL_FOR_PRIMITIVES(false),\n+\n+    /**\n+     * SerializationFeature that determines whether JSON integer numbers are valid\n+     * values to be used for deserializing Java enum values.\n+     * If set to 'false' numbers are acceptable and are used to map to\n+     * ordinal() of matching enumeration value; if 'true', numbers are\n+     * not allowed and a {@link JsonMappingException} will be thrown.\n+     * Latter behavior makes sense if there is concern that accidental\n+     * mapping from integer values to enums might happen (and when enums\n+     * are always serialized as JSON Strings)\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    FAIL_ON_NUMBERS_FOR_ENUMS(false),\n+\n+    /**\n+     * SerializationFeature that determines whether Jackson code should catch\n+     * and wrap {@link Exception}s (but never {@link Error}s!)\n+     * to add additional information about\n+     * location (within input) of problem or not. If enabled,\n+     * most exceptions will be caught and re-thrown (exception\n+     * specifically being that {@link java.io.IOException}s may be passed\n+     * as is, since they are declared as throwable); this can be\n+     * convenient both in that all exceptions will be checked and\n+     * declared, and so there is more contextual information.\n+     * However, sometimes calling application may just want \"raw\"\n+     * unchecked exceptions passed as is.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_EXCEPTIONS(true),\n+    \n+    /*\n+    /******************************************************\n+     *  Structural conversion features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether it is acceptable to coerce non-array\n+     * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n+     * types. If enabled, collection deserializers will try to handle non-array\n+     * values as if they had \"implicit\" surrounding JSON array.\n+     * This feature is meant to be used for compatibility/interoperability reasons,\n+     * to work with packages (such as XML-to-JSON converters) that leave out JSON\n+     * array in cases where there is just a single element in array.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n+    \n+    /**\n+     * SerializationFeature to allow \"unwrapping\" root-level JSON value, to match setting of\n+     * {@link SerializationConfig.SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n+     * Will verify that the root JSON value is a JSON Object, and that it has\n+     * a single property with expected root name. If not, a\n+     * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n+     * will be deserialized as if it was the root value.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    UNWRAP_ROOT_VALUE(false),\n+\n+    /*\n+    /******************************************************\n+    /* Value conversion features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that can be enabled to allow JSON empty String\n+     * value (\"\") to be bound to POJOs as null.\n+     * If disabled, standard POJOs can only be bound from JSON null or\n+     * JSON Object (standard meaning that no custom deserializers or\n+     * constructors are defined; both of which can add support for other\n+     * kinds of JSON values); if enable, empty JSON String can be taken\n+     * to be equivalent of JSON null.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n+    \n+    ;\n+\n+    private final boolean _defaultState;\n+    \n+    private DeserializationFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+\n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n      */\n \n     /**\n-     * Method that will return valid String representation of\n+     * Method that will return a valid String representation of\n      * the container value, if the node is a value node\n-     * (method {@link #isValueNode} returns true), otherwise\n-     * empty String.\n+     * (method {@link #isValueNode} returns true),\n+     * otherwise empty String.\n      */\n     public abstract String asText();\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features to set\n+ * for {@link ObjectMapper}, and accessible (but not changeable)\n+ * via {@link ObjectReader} and {@link ObjectWriter} (as well as\n+ * through various convenience methods through context objects).\n+ *<p>\n+ * Note that in addition to being only mutable via {@link ObjectMapper},\n+ * changes only take effect when done <b>before any serialization or\n+ * deserialization</b> calls -- that is, caller must follow\n+ * \"configure-then-use\" pattern.\n+ */\n+public enum MapperFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /*  Introspection features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * Feature that determines whether annotation introspection\n+     * is used for configuration; if enabled, configured\n+     * {@link AnnotationIntrospector} will be used: if disabled,\n+     * no annotations are considered.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    USE_ANNOTATIONS(true),\n+\n+    /**\n+     * Feature that determines whether \"creator\" methods are\n+     * automatically detected by consider public constructors,\n+     * and static single argument methods with name \"valueOf\".\n+     * If disabled, only methods explicitly annotated are considered\n+     * creator methods (except for the no-arg default constructor which\n+     * is always considered a factory method).\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<P>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_CREATORS(true),\n+    \n+    /**\n+     * Feature that determines whether non-static fields are recognized as\n+     * properties.\n+     * If yes, then all public member fields\n+     * are considered as properties. If disabled, only fields explicitly\n+     * annotated are considered property fields.\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+     AUTO_DETECT_FIELDS(true),\n+    \n+    /**\n+     * Feature that determines whether regualr \"getter\" methods are\n+     * automatically detected based on standard Bean naming convention\n+     * or not. If yes, then all public zero-argument methods that\n+     * start with prefix \"get\" \n+     * are considered as getters.\n+     * If disabled, only methods explicitly  annotated are considered getters.\n+     *<p>\n+     * Note that since version 1.3, this does <b>NOT</b> include\n+     * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_GETTERS(true),\n+\n+    /**\n+     * Feature that determines whether \"is getter\" methods are\n+     * automatically detected based on standard Bean naming convention\n+     * or not. If yes, then all public zero-argument methods that\n+     * start with prefix \"is\", and whose return type is boolean\n+     * are considered as \"is getters\".\n+     * If disabled, only methods explicitly annotated are considered getters.\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_IS_GETTERS(true),\n+\n+     /**\n+      * Feature that determines whether \"setter\" methods are\n+      * automatically detected based on standard Bean naming convention\n+      * or not. If yes, then all public one-argument methods that\n+      * start with prefix \"set\"\n+      * are considered setters. If disabled, only methods explicitly\n+      * annotated are considered setters.\n+      *<p>\n+      * Note that this feature has lower precedence than per-class\n+      * annotations, and is only used if there isn't more granular\n+      * configuration available.\n+      *<P>\n+      * Feature is enabled by default.\n+      */\n+     AUTO_DETECT_SETTERS(true),\n+     \n+     /**\n+      * Feature that determines whether getters (getter methods)\n+      * can be auto-detected if there is no matching mutator (setter,\n+      * constructor parameter or field) or not: if set to true,\n+      * only getters that match a mutator are auto-discovered; if\n+      * false, all auto-detectable getters can be discovered.\n+      *<p>\n+      * Feature is disabled by default.\n+      */\n+     REQUIRE_SETTERS_FOR_GETTERS(false),\n+\n+     /**\n+      * Feature that determines whether otherwise regular \"getter\"\n+      * methods (but only ones that handle Collections and Maps,\n+      * not getters of other type)\n+      * can be used for purpose of getting a reference to a Collection\n+      * and Map to modify the property, without requiring a setter\n+      * method.\n+      * This is similar to how JAXB framework sets Collections and\n+      * Maps: no setter is involved, just setter.\n+      *<p>\n+      * Note that such getters-as-setters methods have lower\n+      * precedence than setters, so they are only used if no\n+      * setter is found for the Map/Collection property.\n+      *<p>\n+      * Feature is enabled by default.\n+      */\n+     USE_GETTERS_AS_SETTERS(true),\n+\n+     /**\n+     * Feature that determines whether method and field access\n+     * modifier settings can be overridden when accessing\n+     * properties. If enabled, method\n+     * {@link java.lang.reflect.AccessibleObject#setAccessible}\n+     * may be called to enable access to otherwise unaccessible\n+     * objects.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+\n+    /*\n+    /******************************************************\n+    /* Type-handling features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether the type detection for\n+     * serialization should be using actual dynamic runtime type,\n+     * or declared static type.\n+     * Note that deserialization always uses declared static types\n+     * since no runtime types are available (as we are creating\n+     * instances after using type information).\n+     *<p>\n+     * This global default value can be overridden at class, method\n+     * or field level by using {@link JsonSerialize#typing} annotation\n+     * property.\n+     *<p>\n+     * Feature is disabled by default which means that dynamic runtime types\n+     * are used (instead of declared static types) for serialization.\n+     */\n+    USE_STATIC_TYPING(false),\n+\n+    /*\n+    /******************************************************\n+    /* View-related features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that determines whether properties that have no view\n+     * annotations are included in JSON serialization views (see\n+     * {@link com.fasterxml.jackson.annotation.JsonView} for more\n+     * details on JSON Views).\n+     * If enabled, non-annotated properties will be included;\n+     * when disabled, they will be excluded. So this feature\n+     * changes between \"opt-in\" (feature disabled) and\n+     * \"opt-out\" (feature enabled) modes.\n+     *<p>\n+     * Default value is enabled, meaning that non-annotated\n+     * properties are included in all views if there is no\n+     * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    DEFAULT_VIEW_INCLUSION(true),\n+    \n+    /*\n+    /******************************************************\n+    /* Generic output features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that defines default property serialization order used\n+     * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n+     * serialization!):\n+     * if enabled, default ordering is alphabetic (similar to\n+     * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n+     * works); if disabled, order is unspecified (based on what JDK gives\n+     * us, which may be declaration order, but is not guaranteed).\n+     *<p>\n+     * Note that this is just the default behavior, and can be overridden by\n+     * explicit overrides in classes.\n+     *<p>\n+     * Feature is disabled by default.\n+     */\n+    SORT_PROPERTIES_ALPHABETICALLY(false)\n+\n+    ;\n+\n+    private final boolean _defaultState;\n+    \n+    private MapperFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+    \n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n package com.fasterxml.jackson.databind;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n          */\n         public TypeFactory getTypeFactory();\n         \n-        public boolean isEnabled(MapperConfig.Feature f);\n-        \n-        public boolean isEnabled(DeserializationConfig.Feature f);\n-\n-        public boolean isEnabled(SerializationConfig.Feature f);\n+        public boolean isEnabled(MapperFeature f);\n+        \n+        public boolean isEnabled(DeserializationFeature f);\n+\n+        public boolean isEnabled(SerializationFeature f);\n \n         public boolean isEnabled(JsonFactory.Feature f);\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n             }\n             \n             @Override\n-            public boolean isEnabled(MapperConfig.Feature f) {\n+            public boolean isEnabled(MapperFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n             @Override\n-            public boolean isEnabled(DeserializationConfig.Feature f) {\n+            public boolean isEnabled(DeserializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n             \n             @Override\n-            public boolean isEnabled(SerializationConfig.Feature f) {\n+            public boolean isEnabled(SerializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n      * Method for changing state of an on/off mapper feature for\n      * this mapper instance.\n      */\n-    public ObjectMapper configure(MapperConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(MapperFeature f, boolean state) {\n         _serializationConfig = state ?\n                 _serializationConfig.with(f) : _serializationConfig.without(f);\n         _deserializationConfig = state ?\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n      */\n-    public ObjectMapper configure(SerializationConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(SerializationFeature f, boolean state) {\n         _serializationConfig = state ?\n                 _serializationConfig.with(f) : _serializationConfig.without(f);\n         return this;\n      * Method for changing state of an on/off deserialization feature for\n      * this object mapper.\n      */\n-    public ObjectMapper configure(DeserializationConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n         _deserializationConfig = state ?\n                 _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n      * Method for enabling specified {@link MapperConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(MapperConfig.Feature... f) {\n+    public ObjectMapper enable(MapperFeature... f) {\n         _deserializationConfig = _deserializationConfig.with(f);\n         _serializationConfig = _serializationConfig.with(f);\n         return this;\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(MapperConfig.Feature... f) {\n+    public ObjectMapper disable(MapperFeature... f) {\n         _deserializationConfig = _deserializationConfig.without(f);\n         _serializationConfig = _serializationConfig.without(f);\n         return this;\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(DeserializationConfig.Feature feature) {\n+    public ObjectMapper enable(DeserializationFeature feature) {\n         _deserializationConfig = _deserializationConfig.with(feature);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... f) {\n+    public ObjectMapper enable(DeserializationFeature first,\n+            DeserializationFeature... f) {\n         _deserializationConfig = _deserializationConfig.with(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(DeserializationConfig.Feature feature) {\n+    public ObjectMapper disable(DeserializationFeature feature) {\n         _deserializationConfig = _deserializationConfig.without(feature);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... f) {\n+    public ObjectMapper disable(DeserializationFeature first,\n+            DeserializationFeature... f) {\n         _deserializationConfig = _deserializationConfig.without(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} feature.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(SerializationConfig.Feature f) {\n+    public ObjectMapper enable(SerializationFeature f) {\n         _serializationConfig = _serializationConfig.with(f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... f) {\n+    public ObjectMapper enable(SerializationFeature first,\n+            SerializationFeature... f) {\n         _serializationConfig = _serializationConfig.with(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(SerializationConfig.Feature f) {\n+    public ObjectMapper disable(SerializationFeature f) {\n         _serializationConfig = _serializationConfig.without(f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... f) {\n+    public ObjectMapper disable(SerializationFeature first,\n+            SerializationFeature... f) {\n         _serializationConfig = _serializationConfig.without(first, f);\n         return this;\n     }\n      * Method for checking whether given Mapper\n      * feature is enabled.\n      */\n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         // ok to use either one, should be kept in sync\n         return _serializationConfig.isEnabled(f);\n     }\n      * Method for checking whether given serialization-specific\n      * feature is enabled.\n      */\n-    public boolean isEnabled(SerializationConfig.Feature f) {\n+    public boolean isEnabled(SerializationFeature f) {\n         return _serializationConfig.isEnabled(f);\n     }\n     \n      * Method for checking whether given deserialization-specific\n      * feature is enabled.\n      */\n-    public boolean isEnabled(DeserializationConfig.Feature f) {\n+    public boolean isEnabled(DeserializationFeature f) {\n         return _deserializationConfig.isEnabled(f);\n     }\n \n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig config = getSerializationConfig();\n-        if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n             _serializerProvider(config).serializeValue(jgen, value);\n-            if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n     {\n         SerializationConfig config = getSerializationConfig();\n         _serializerProvider(config).serializeValue(jgen, rootNode);\n-        if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n             jgen.flush();\n         }\n     }\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationConfig.Feature feature) {\n+    public ObjectWriter writer(SerializationFeature feature) {\n         return new ObjectWriter(this, getSerializationConfig().with(feature));\n     }\n \n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other) {\n+    public ObjectWriter writer(SerializationFeature first,\n+            SerializationFeature... other) {\n         return new ObjectWriter(this, getSerializationConfig().with(first, other));\n     }\n     \n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationConfig.Feature feature) {\n+    public ObjectReader reader(DeserializationFeature feature) {\n         return new ObjectReader(this, getDeserializationConfig().with(feature));\n     }\n \n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other) {\n+    public ObjectReader reader(DeserializationFeature first,\n+            DeserializationFeature... other) {\n         return new ObjectReader(this, getDeserializationConfig().with(first, other));\n     }\n     \n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\n-            SerializationConfig config = getSerializationConfig().without(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n             // no need to check for closing of TokenBuffer\n             _serializerProvider(config).serializeValue(buf, fromValue);\n \n     {\n         SerializationConfig cfg = getSerializationConfig();\n         // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n-        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n         }\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n-        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n         }\n         Closeable toClose = (Closeable) value;\n         try {\n             _serializerProvider(cfg).serializeValue(jgen, value);\n-            if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n             Closeable tmpToClose = toClose;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectReader with(DeserializationConfig.Feature feature) \n+    public ObjectReader with(DeserializationFeature feature) \n     {\n         DeserializationConfig newConfig = _config.with(feature);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader with(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other)\n+    public ObjectReader with(DeserializationFeature first,\n+            DeserializationFeature... other)\n     {\n         DeserializationConfig newConfig = _config.with(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader withFeatures(DeserializationConfig.Feature... features)\n+    public ObjectReader withFeatures(DeserializationFeature... features)\n     {\n         DeserializationConfig newConfig = _config.withFeatures(features);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n-    public ObjectReader without(DeserializationConfig.Feature feature) \n+    public ObjectReader without(DeserializationFeature feature) \n     {\n         DeserializationConfig newConfig = _config.without(feature);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader without(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other)\n+    public ObjectReader without(DeserializationFeature first,\n+            DeserializationFeature... other)\n     {\n         DeserializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader withoutFeatures(DeserializationConfig.Feature... features)\n+    public ObjectReader withoutFeatures(DeserializationFeature... features)\n     {\n         DeserializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     /**********************************************************\n      */\n     \n-    public boolean isEnabled(DeserializationConfig.Feature f) {\n+    public boolean isEnabled(DeserializationFeature f) {\n         return _config.isEnabled(f);\n     }\n \n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         return _config.isEnabled(f);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      * Method for constructing a new instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectWriter with(SerializationConfig.Feature feature) \n+    public ObjectWriter with(SerializationFeature feature) \n     {\n         SerializationConfig newConfig = _config.with(feature);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter with(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other)\n+    public ObjectWriter with(SerializationFeature first,\n+            SerializationFeature... other)\n     {\n         SerializationConfig newConfig = _config.with(first, other);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter withFeatures(SerializationConfig.Feature... features)\n+    public ObjectWriter withFeatures(SerializationFeature... features)\n     {\n         SerializationConfig newConfig = _config.withFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectWriter without(SerializationConfig.Feature feature) \n+    public ObjectWriter without(SerializationFeature feature) \n     {\n         SerializationConfig newConfig = _config.without(feature);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter without(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other)\n+    public ObjectWriter without(SerializationFeature first,\n+            SerializationFeature... other)\n     {\n         SerializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter withoutFeatures(SerializationConfig.Feature... features)\n+    public ObjectWriter withoutFeatures(SerializationFeature... features)\n     {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n     /**********************************************************\n      */\n \n-    public boolean isEnabled(SerializationConfig.Feature f) {\n+    public boolean isEnabled(SerializationFeature f) {\n         return _config.isEnabled(f);\n     }\n \n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         return _config.isEnabled(f);\n     }\n \n     public void writeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, _config);\n         } else {\n             if (_rootType == null) {\n             } else {\n                 _serializerProvider(_config).serializeValue(jgen, value, _rootType);\n             }\n-            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n         if (_prettyPrinter != null) {\n             PrettyPrinter pp = _prettyPrinter;\n             jgen.setPrettyPrinter((pp == NULL_PRETTY_PRINTER) ? null : pp);\n-        } else if (_config.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-520]: add support for pass-through schema:\n             jgen.setSchema(_schema);\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, _config);\n             return;\n         }\n             } else {\n                 _serializerProvider(cfg).serializeValue(jgen, value, _rootType);\n             }\n-            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n             Closeable tmpToClose = toClose;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features that affect\n+ * the way Java objects are serialized.\n+ *<p>\n+ * Note that features can be set both through\n+ * {@link ObjectMapper} (as sort of defaults) and through\n+ * {@link ObjectWriter}.\n+ * In first case these defaults must follow \"config-then-use\" patterns\n+ * (i.e. defined once, not changed afterwards); all per-call\n+ * changes must be done using {@link ObjectWriter}.\n+ */\n+public enum SerializationFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /* Generic output features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that can be enabled to make root value (usually JSON\n+     * Object but can be any type) wrapped within a single property\n+     * JSON object, where key as the \"root name\", as determined by\n+     * annotation introspector (esp. for JAXB that uses\n+     * <code>@XmlRootElement.name</code>) or fallback (non-qualified\n+     * class name).\n+     * SerializationFeature is mostly intended for JAXB compatibility.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_ROOT_VALUE(false),\n+\n+    /**\n+     * SerializationFeature that allows enabling (or disabling) indentation\n+     * for the underlying generator, using the default pretty\n+     * printer (see\n+     * {@link com.fasterxml.jackson.core.JsonGenerator#useDefaultPrettyPrinter}\n+     * for details).\n+     *<p>\n+     * Note that this only affects cases where\n+     * {@link com.fasterxml.jackson.core.JsonGenerator}\n+     * is constructed implicitly by ObjectMapper: if explicit\n+     * generator is passed, its configuration is not changed.\n+     *<p>\n+     * Also note that if you want to configure details of indentation,\n+     * you need to directly configure the generator: there is a\n+     * method to use any <code>PrettyPrinter</code> instance.\n+     * This feature will only allow using the default implementation.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    INDENT_OUTPUT(false),\n+    \n+    /*\n+    /******************************************************\n+    /*  Error handling features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that determines what happens when no accessors are\n+     * found for a type (and there are no annotations to indicate\n+     * it is meant to be serialized). If enabled (default), an\n+     * exception is thrown to indicate these as non-serializable\n+     * types; if disabled, they are serialized as empty Objects,\n+     * i.e. without any properties.\n+     *<p>\n+     * Note that empty types that this feature has only effect on\n+     * those \"empty\" beans that do not have any recognized annotations\n+     * (like <code>@JsonSerialize</code>): ones that do have annotations\n+     * do not result in an exception being thrown.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    FAIL_ON_EMPTY_BEANS(true),\n+\n+    /**\n+     * SerializationFeature that determines whether Jackson code should catch\n+     * and wrap {@link Exception}s (but never {@link Error}s!)\n+     * to add additional information about\n+     * location (within input) of problem or not. If enabled,\n+     * most exceptions will be caught and re-thrown (exception\n+     * specifically being that {@link java.io.IOException}s may be passed\n+     * as is, since they are declared as throwable); this can be\n+     * convenient both in that all exceptions will be checked and\n+     * declared, and so there is more contextual information.\n+     * However, sometimes calling application may just want \"raw\"\n+     * unchecked exceptions passed as is.\n+     *<p>\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_EXCEPTIONS(true),\n+\n+    /*\n+    /******************************************************\n+    /* Output life cycle features\n+    /******************************************************\n+     */\n+    \n+     /**\n+      * SerializationFeature that determines whether <code>close</code> method of\n+      * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n+      * writeValue() (or equivalent) method is called)\n+      * that implement {@link java.io.Closeable} \n+      * is called after serialization or not. If enabled, <b>close()</b> will\n+      * be called after serialization completes (whether succesfully, or\n+      * due to an error manifested by an exception being thrown). You can\n+      * think of this as sort of \"finally\" processing.\n+      *<p>\n+      * NOTE: only affects behavior with <b>root</b> objects, and not other\n+      * objects reachable from the root object. Put another way, only one\n+      * call will be made for each 'writeValue' call.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+      */\n+    CLOSE_CLOSEABLE(false),\n+\n+    /**\n+     * SerializationFeature that determines whether <code>JsonGenerator.flush()</code> is\n+     * called after <code>writeValue()</code> method <b>that takes JsonGenerator\n+     * as an argument</b> completes (i.e. does NOT affect methods\n+     * that use other destinations); same for methods in {@link ObjectWriter}.\n+     * This usually makes sense; but there are cases where flushing\n+     * should not be forced: for example when underlying stream is\n+     * compressing and flush() causes compression state to be flushed\n+     * (which occurs with some compression codecs).\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    FLUSH_AFTER_WRITE_VALUE(true),\n+     \n+    /*\n+    /******************************************************\n+    /* Data type - specific serialization configuration\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether {@link java.util.Date} values\n+     * (and Date-based things like {@link java.util.Calendar}s) are to be\n+     * serialized as numeric timestamps (true; the default),\n+     * or as something else (usually textual representation).\n+     * If textual representation is used, the actual format is\n+     * one returned by a call to {@link #getDateFormat}.\n+     *<p>\n+     * Note: whether this feature affects handling of other date-related\n+     * types depend on handlers of those types, although ideally they\n+     * should use this feature\n+     *<p>\n+     * Note: whether {@link java.util.Map} keys are serialized as Strings\n+     * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+    /**\n+     * SerializationFeature that determines whether {@link java.util.Date}s\n+     * (and sub-types) used as {@link java.util.Map} keys are serialized\n+     * as timestamps or not (if not, will be serialized as textual\n+     * values).\n+     *<p>\n+     * Default value is 'false', meaning that Date-valued Map keys are serialized\n+     * as textual (ISO-8601) values.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n+\n+    /**\n+     * SerializationFeature that determines how type <code>char[]</code> is serialized:\n+     * when enabled, will be serialized as an explict JSON array (with\n+     * single-character Strings as values); when disabled, defaults to\n+     * serializing them as Strings (which is more compact).\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n+\n+    /**\n+     * SerializationFeature that determines standard serialization mechanism used for\n+     * Enum values: if enabled, return value of <code>Enum.toString()</code>\n+     * is used; if disabled, return value of <code>Enum.name()</code> is used.\n+     *<p>\n+     * Note: this feature should usually have same value\n+     * as {@link DeserializationConfig.DeserializationFeature#READ_ENUMS_USING_TO_STRING}.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_ENUMS_USING_TO_STRING(false),\n+\n+    /**\n+     * SerializationFeature that determines whethere Java Enum values are serialized\n+     * as numbers (true), or textual values (false). If textual values are\n+     * used, other settings are also considered.\n+     * If this feature is enabled,\n+     *  return value of <code>Enum.ordinal()</code>\n+     * (an integer) will be used as the serialization.\n+     *<p>\n+     * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n+     * which is only considered if this feature is set to false.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_ENUMS_USING_INDEX(false),\n+    \n+    /**\n+     * SerializationFeature that determines whether Map entries with null values are\n+     * to be serialized (true) or not (false).\n+     *<p>\n+     * For further details, check out [JACKSON-314]\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_NULL_MAP_VALUES(true),\n+\n+    /**\n+     * SerializationFeature that determines whether Container properties (POJO properties\n+     * with declared value of Collection or array; i.e. things that produce JSON\n+     * arrays) that are empty (have no elements)\n+     * will be serialized as empty JSON arrays (true), or suppressed from output (false).\n+     *<p>\n+     * Note that this does not change behavior of {@link java.util.Map}s, or\n+     * \"Collection-like\" types.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_EMPTY_JSON_ARRAYS(true)\n+    \n+        ;\n+\n+    private final boolean _defaultState;\n+    \n+    private SerializationFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+    \n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n             String rootName = _config.getRootName();\n             if (rootName == null) { // not explicitly specified\n                 // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n                 if (wrap) {\n                     jgen.writeStartObject();\n                     jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n             // root value, not reached via property:\n             ser = findTypedValueSerializer(rootType, true, null);\n             // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n                 jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n      *  getConfig().isEnabled(feature);\n      *</pre>\n      */\n-    public final boolean isEnabled(MapperConfig.Feature feature) {\n+    public final boolean isEnabled(MapperFeature feature) {\n         return _config.isEnabled(feature);\n     }\n \n      *  getConfig().isEnabled(feature);\n      *</pre>\n      */\n-    public final boolean isEnabled(SerializationConfig.Feature feature) {\n+    public final boolean isEnabled(SerializationFeature feature) {\n         return _config.isEnabled(feature);\n     }\n \n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-87]: Support both numeric timestamps and textual\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(timestamp);\n         } else {\n             if (_dateFormat == null) {\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-87]: Support both numeric timestamps and textual\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(date.getTime());\n         } else {\n             if (_dateFormat == null) {\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n-     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * based on {@link SerializationFeature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n     public void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(timestamp));\n         } else {\n             if (_dateFormat == null) {\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n-     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * based on {@link SerializationFeature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n     public void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(date.getTime()));\n         } else {\n             if (_dateFormat == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n package com.fasterxml.jackson.databind.cfg;\n \n /**\n- * Interface that actual Feature enumerations used by\n+ * Interface that actual SerializationFeature enumerations used by\n  * {@link MapperConfig} implementations must implement.\n  * Necessary since enums can not be extended using normal\n  * inheritance, but can implement interfaces\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DatabindVersion.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Helper class used for finding and caching version information\n+ * for the databind bundle.\n+ * NOTE: although defined as public, should NOT be accessed directly\n+ * from outside databind bundle itself.\n+ */\n+public class DatabindVersion extends VersionUtil\n+{\n+    public final static DatabindVersion instance = new DatabindVersion();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializationConfig.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.LinkedNode;\n+\n+/**\n+ * Object that contains baseline configuration for deserialization\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance to be used for deserialization process.\n+ *<p>\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n+ */\n+public final class DeserializationConfig\n+    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n+{\n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _deserFeatures;\n+\n+    /**\n+     * Linked list that contains all registered problem handlers.\n+     * Implementation as front-added linked list allows for sharing\n+     * of the list (tail) without copying the list.\n+     */\n+    protected final LinkedNode<DeserializationProblemHandler> _problemHandlers;\n+    \n+    /**\n+     * Factory used for constructing {@link com.fasterxml.jackson.core.JsonNode} instances.\n+     */\n+    protected final JsonNodeFactory _nodeFactory;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public DeserializationConfig(BaseSettings base,\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n+        _nodeFactory = JsonNodeFactory.instance;\n+        _problemHandlers = null;\n+    }\n+\n+    /**\n+     * Copy constructor used to create a non-shared instance with given mix-in\n+     * annotation definitions and subtype resolver.\n+     */\n+    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n+    {\n+        super(src, str);\n+        _deserFeatures = src._deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _deserFeatures = deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+    \n+    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n+    {\n+        super(src, base);\n+        _deserFeatures = src._deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+    \n+    private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n+    {\n+        super(src);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = f;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            LinkedNode<DeserializationProblemHandler> problemHandlers)\n+    {\n+        super(src);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src, Class<?> view)\n+    {\n+        super(src, view);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public DeserializationConfig with(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+    }\n+\n+    @Override\n+    public DeserializationConfig without(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withClassIntrospector(ClassIntrospector ci) {\n+        return _withBase(_base.withClassIntrospector(ci));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return _withBase(_base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n+        return _withBase( _base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return _withBase(_base.withTypeResolverBuilder(trb));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withSubtypeResolver(SubtypeResolver str) {\n+        return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this, rootName);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeFactory(TypeFactory tf) {\n+        return _withBase( _base.withTypeFactory(tf));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withDateFormat(DateFormat df) {\n+        return _withBase(_base.withDateFormat(df));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return _withBase(_base.withHandlerInstantiator(hi));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withView(Class<?> view) {\n+        return (_view == view) ? this : new DeserializationConfig(this, view);\n+    }\n+    \n+    private final DeserializationConfig _withBase(BaseSettings newBase) {\n+        return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, deserialization-specific factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct a new instance with\n+     * specified {@link JsonNodeFactory}\n+     */\n+    public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n+        if (_nodeFactory == f) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this, f);\n+    }\n+\n+    /**\n+     * Method that can be used to add a handler that can (try to)\n+     * resolve non-fatal deserialization problems.\n+     */\n+    public DeserializationConfig withHandler(DeserializationProblemHandler h)\n+    {\n+        // Sanity check: let's prevent adding same handler multiple times\n+        if (LinkedNode.contains(_problemHandlers, h)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));\n+    }\n+\n+    /**\n+     * Method for removing all configured problem handlers; usually done to replace\n+     * existing handler(s) with different one(s)\n+     */\n+    public DeserializationConfig withNoProblemHandlers() {\n+        if (_problemHandlers == null) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                (LinkedNode<DeserializationProblemHandler>) null);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = (_deserFeatures | feature.getMask());\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures | first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for getting {@link AnnotationIntrospector} configured\n+     * to introspect annotation values used for configuration.\n+     */\n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return NopAnnotationIntrospector.instance;\n+    }\n+\n+    @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+    }\n+    \n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    @Override\n+    public BeanDescription introspectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    @Override\n+    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+\n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n+            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n+            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+\n+    public final boolean isEnabled(DeserializationFeature f) {\n+        return (_deserFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other configuration\n+    /**********************************************************\n+     */\n+\n+    public final int getDeserializationFeatures() {\n+        return _deserFeatures;\n+    }\n+    \n+    /**\n+     * Method for getting head of the problem handler chain. May be null,\n+     * if no handlers have been added.\n+     */\n+    public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n+        return _problemHandlers;\n+    }\n+    \n+    /**\n+     * Method called during deserialization if Base64 encoded content\n+     * needs to be decoded. Default version just returns default Jackson\n+     * uses, which is modified-mime which does not add linefeeds (because\n+     * those would have to be escaped in JSON strings).\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return Base64Variants.getDefaultVariant();\n+    }\n+\n+    public final JsonNodeFactory getNodeFactory() {\n+        return _nodeFactory;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean deserializer\n+     *\n+     * @param type Type of class to be introspected\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forDeserialization(this, type, this);\n+    }\n+\n+    /**\n+     * Method that will introspect subset of bean properties needed to\n+     * construct bean instance.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n+        return (T) getClassIntrospector().forCreation(this, type, this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Helper class used for handling details of creating handler instances (things\n+ * like {@link JsonSerializer}s, {@link JsonDeserializer}s, various type\n+ * handlers) of specific types. Actual handler type has been resolved at this\n+ * point, so instantiator is strictly responsible for providing a configured\n+ * instance by constructing and configuring a new instance, or possibly by\n+ * recycling a shared instance. One use case is that of allowing\n+ * dependency injection, which would otherwise be difficult to do.\n+ *<p>\n+ * Custom instances are allowed to return null to indicate that caller should\n+ * use the default instantiation handling (which just means calling no-argument\n+ * constructor via reflection).\n+ *<p>\n+ * Care has to be taken to ensure that if instance returned is shared, it will\n+ * be thread-safe; caller will not synchronize access to returned instances.\n+ */\n+public abstract class HandlerInstantiator\n+{\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get an instance of deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param deserClass Class of deserializer instance to return\n+     * \n+     * @return Deserializer instance to use\n+     */\n+    public abstract JsonDeserializer<?> deserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<?> deserClass);\n+\n+    /**\n+     * Method called to get an instance of key deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of key deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param keyDeserClass Class of key deserializer instance to return\n+     * \n+     * @return Key deserializer instance to use\n+     */\n+    public abstract KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<?> keyDeserClass);\n+    \n+    /**\n+     * Method called to get an instance of serializer of specified type.\n+     * \n+     * @param config Serialization configuration in effect\n+     * @param annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of serializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param serClass Class of serializer instance to return\n+     * \n+     * @return Serializer instance to use\n+     */\n+    public abstract JsonSerializer<?> serializerInstance(SerializationConfig config,\n+            Annotated annotated, Class<?> serClass);\n+\n+    /**\n+     * Method called to get an instance of TypeResolverBuilder of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of builder to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param builderClass Class of builder instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> builderClass);\n+\n+    /**\n+     * Method called to get an instance of TypeIdResolver of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of resolver to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param resolverClass Class of resolver instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> resolverClass);\n+\n+    /**\n+     * Method called to construct an instance of ValueInstantiator of specified type.\n+     */\n+    public ValueInstantiator valueInstantiatorInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> resolverClass) {\n+        return null;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n  * accessors to mode-independent configuration settings\n  * and such.\n  * In addition, shared features are defined\n- * in {@link MapperConfig.Feature}\n+ * in {@link MapperFeature}\n  *<p>\n  * Small part of implementation is included here by aggregating\n  * {@link BaseSettings} instance that contains configuration\n     implements ClassIntrospector.MixInResolver\n {\n     /**\n-     * Enumeration that defines simple on/off features to set\n-     * for {@link ObjectMapper}, and accessible (but NOT mutable!)\n-     * via {@link SerializationConfig} and {@link DeserializationConfig}.\n-     * Note that in addition to being only mutable via {@link ObjectMapper},\n-     * changes only take effect when done <b>before any serialization or\n-     * deserialization</b> calls -- that is, caller must follow\n-     * \"configure-then-use\" pattern.\n-     */\n-    public enum Feature implements ConfigFeature\n-    {\n-        /*\n-        /******************************************************\n-        /*  Introspection features\n-        /******************************************************\n-         */\n-        \n-        /**\n-         * Feature that determines whether annotation introspection\n-         * is used for configuration; if enabled, configured\n-         * {@link AnnotationIntrospector} will be used: if disabled,\n-         * no annotations are considered.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        USE_ANNOTATIONS(true),\n-\n-        /**\n-         * Feature that determines whether \"creator\" methods are\n-         * automatically detected by consider public constructors,\n-         * and static single argument methods with name \"valueOf\".\n-         * If disabled, only methods explicitly annotated are considered\n-         * creator methods (except for the no-arg default constructor which\n-         * is always considered a factory method).\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_CREATORS(true),\n-        \n-        /**\n-         * Feature that determines whether non-static fields are recognized as\n-         * properties.\n-         * If yes, then all public member fields\n-         * are considered as properties. If disabled, only fields explicitly\n-         * annotated are considered property fields.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-         AUTO_DETECT_FIELDS(true),\n-        \n-        /**\n-         * Feature that determines whether regualr \"getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"get\" \n-         * are considered as getters.\n-         * If disabled, only methods explicitly  annotated are considered getters.\n-         *<p>\n-         * Note that since version 1.3, this does <b>NOT</b> include\n-         * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_GETTERS(true),\n-\n-        /**\n-         * Feature that determines whether \"is getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"is\", and whose return type is boolean\n-         * are considered as \"is getters\".\n-         * If disabled, only methods explicitly annotated are considered getters.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_IS_GETTERS(true),\n-\n-         /**\n-          * Feature that determines whether \"setter\" methods are\n-          * automatically detected based on standard Bean naming convention\n-          * or not. If yes, then all public one-argument methods that\n-          * start with prefix \"set\"\n-          * are considered setters. If disabled, only methods explicitly\n-          * annotated are considered setters.\n-          *<p>\n-          * Note that this feature has lower precedence than per-class\n-          * annotations, and is only used if there isn't more granular\n-          * configuration available.\n-          *<P>\n-          * Feature is enabled by default.\n-          */\n-         AUTO_DETECT_SETTERS(true),\n-         \n-         /**\n-          * Feature that determines whether getters (getter methods)\n-          * can be auto-detected if there is no matching mutator (setter,\n-          * constructor parameter or field) or not: if set to true,\n-          * only getters that match a mutator are auto-discovered; if\n-          * false, all auto-detectable getters can be discovered.\n-          *<p>\n-          * Feature is disabled by default.\n-          */\n-         REQUIRE_SETTERS_FOR_GETTERS(false),\n-\n-         /**\n-          * Feature that determines whether otherwise regular \"getter\"\n-          * methods (but only ones that handle Collections and Maps,\n-          * not getters of other type)\n-          * can be used for purpose of getting a reference to a Collection\n-          * and Map to modify the property, without requiring a setter\n-          * method.\n-          * This is similar to how JAXB framework sets Collections and\n-          * Maps: no setter is involved, just setter.\n-          *<p>\n-          * Note that such getters-as-setters methods have lower\n-          * precedence than setters, so they are only used if no\n-          * setter is found for the Map/Collection property.\n-          *<p>\n-          * Feature is enabled by default.\n-          */\n-         USE_GETTERS_AS_SETTERS(true),\n-\n-         /**\n-         * Feature that determines whether method and field access\n-         * modifier settings can be overridden when accessing\n-         * properties. If enabled, method\n-         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n-         * may be called to enable access to otherwise unaccessible\n-         * objects.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n-\n-        /*\n-        /******************************************************\n-        /* Type-handling features\n-        /******************************************************\n-         */\n-\n-        /**\n-         * Feature that determines whether the type detection for\n-         * serialization should be using actual dynamic runtime type,\n-         * or declared static type.\n-         * Note that deserialization always uses declared static types\n-         * since no runtime types are available (as we are creating\n-         * instances after using type information).\n-         *<p>\n-         * This global default value can be overridden at class, method\n-         * or field level by using {@link JsonSerialize#typing} annotation\n-         * property.\n-         *<p>\n-         * Feature is disabled by default which means that dynamic runtime types\n-         * are used (instead of declared static types) for serialization.\n-         */\n-        USE_STATIC_TYPING(false),\n-\n-        /*\n-        /******************************************************\n-        /* View-related features\n-        /******************************************************\n-         */\n-        \n-        /**\n-         * Feature that determines whether properties that have no view\n-         * annotations are included in JSON serialization views (see\n-         * {@link com.fasterxml.jackson.annotation.JsonView} for more\n-         * details on JSON Views).\n-         * If enabled, non-annotated properties will be included;\n-         * when disabled, they will be excluded. So this feature\n-         * changes between \"opt-in\" (feature disabled) and\n-         * \"opt-out\" (feature enabled) modes.\n-         *<p>\n-         * Default value is enabled, meaning that non-annotated\n-         * properties are included in all views if there is no\n-         * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        DEFAULT_VIEW_INCLUSION(true),\n-        \n-        /*\n-        /******************************************************\n-        /* Generic output features\n-        /******************************************************\n-         */\n-\n-        /**\n-         * Feature that defines default property serialization order used\n-         * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n-         * serialization!):\n-         * if enabled, default ordering is alphabetic (similar to\n-         * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n-         * works); if disabled, order is unspecified (based on what JDK gives\n-         * us, which may be declaration order, but is not guaranteed).\n-         *<p>\n-         * Note that this is just the default behavior, and can be overridden by\n-         * explicit overrides in classes.\n-         *<p>\n-         * Feature is disabled by default.\n-         */\n-        SORT_PROPERTIES_ALPHABETICALLY(false)\n-\n-        ;\n-\n-        private final boolean _defaultState;\n-        \n-        private Feature(boolean defaultState) {\n-            _defaultState = defaultState;\n-        }\n-        \n-        @Override\n-        public boolean enabledByDefault() { return _defaultState; }\n-\n-        @Override\n-        public int getMask() { return (1 << ordinal()); }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Simple immutable basic settings\n-    /**********************************************************\n-     */\n-\n-    /**\n      * Set of shared mapper features enabled.\n      */\n     protected final int _mapperFeatures;\n      * Method for constructing and returning a new instance with specified\n      * mapper features enabled.\n      */\n-    public abstract T with(MapperConfig.Feature... features);\n+    public abstract T with(MapperFeature... features);\n \n     /**\n      * Method for constructing and returning a new instance with specified\n      * mapper features disabled.\n      */\n-    public abstract T without(MapperConfig.Feature... features);\n+    public abstract T without(MapperFeature... features);\n     \n     /*\n     /**********************************************************\n      * Accessor for simple mapper features (which are shared for\n      * serialization, deserialization)\n      */\n-    public final boolean isEnabled(MapperConfig.Feature f) {\n+    public final boolean isEnabled(MapperFeature f) {\n         return (_mapperFeatures & f.getMask()) != 0;\n     }\n     \n      * @return True if annotation processing is enabled; false if not\n      */\n     public final boolean isAnnotationProcessingEnabled() {\n-        return isEnabled(MapperConfig.Feature.USE_ANNOTATIONS);\n+        return isEnabled(MapperFeature.USE_ANNOTATIONS);\n     }\n \n     /**\n      *   to override.\n      */\n     public final boolean canOverrideAccessModifiers() {\n-        return isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+        return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n     }\n \n     /**\n      * indicate that properties should be alphabetically ordered or not.\n      */\n     public final boolean shouldSortPropertiesAlphabetically() {\n-        return isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.MapperFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n     T extends MapperConfigBase<CFG,T>>\n     extends MapperConfig<T>\n {\n-    private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperConfig.Feature.class);\n+    private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperFeature.class);\n \n     /*\n     /**********************************************************\n      * Note that when a root name is set to a non-Empty String, this will automatically force use\n      * of root element wrapping with given name. If empty String passed, will\n      * disable root name wrapping; and if null used, will instead use\n-     * <code>Feature</code> to determine if to use wrapping, and annotation\n+     * <code>SerializationFeature</code> to determine if to use wrapping, and annotation\n      * (or default name) for actual root name to use.\n      * \n      * @param rootName to use: if null, means \"use default\" (clear setting);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/SerializationConfig.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Object that contains baseline configuration for serialization\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance for serialization process to\n+ * {@link SerializerProvider} and {@link SerializerFactory}\n+ * (either directly, or through {@link ObjectWriter}.\n+ *<p>\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n+ */\n+public final class SerializationConfig\n+    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n+{\n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _serFeatures;\n+    \n+    /**\n+     * Which Bean/Map properties are to be included in serialization?\n+     * Default settings is to include all regardless of value; can be\n+     * changed to only include non-null properties, or properties\n+     * with non-default values.\n+     */\n+    protected JsonInclude.Include _serializationInclusion = null;\n+    \n+    /**\n+     * Object used for resolving filter ids to filter instances.\n+     * Non-null if explicitly defined; null by default.\n+     */\n+    protected final FilterProvider _filterProvider;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public SerializationConfig(BaseSettings base,\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n+        _filterProvider = null;\n+    }\n+    \n+    private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n+    {\n+        super(src, str);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _serFeatures = serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+    \n+    private SerializationConfig(SerializationConfig src, BaseSettings base)\n+    {\n+        super(src, base);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, FilterProvider filters)\n+    {\n+        super(src);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = filters;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, Class<?> view)\n+    {\n+        super(src, view);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n+    {\n+        super(src);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = incl;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    @Override\n+    public SerializationConfig with(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    @Override\n+    public SerializationConfig without(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+    }\n+\n+    @Override\n+    public SerializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withClassIntrospector(ClassIntrospector ci) {\n+        return _withBase(_base.withClassIntrospector(ci));\n+    }\n+    \n+    /**\n+     * In addition to constructing instance with specified date format,\n+     * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n+     * (enable if format set as null; disable if non-null)\n+     */\n+    @Override\n+    public SerializationConfig withDateFormat(DateFormat df) {\n+        SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n+        // Also need to toggle this feature based on existence of date format:\n+        if (df == null) {\n+            cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        } else {\n+            cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        }\n+        return cfg;\n+    }\n+    \n+    @Override\n+    public SerializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return _withBase(_base.withHandlerInstantiator(hi));\n+    }\n+    \n+    @Override\n+    public SerializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public SerializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new SerializationConfig(this, rootName);\n+    }\n+\n+    @Override\n+    public SerializationConfig withSubtypeResolver(SubtypeResolver str) {\n+        return (str == _subtypeResolver)? this : new SerializationConfig(this, str);\n+    }\n+\n+    @Override\n+    public SerializationConfig withTypeFactory(TypeFactory tf) {\n+        return _withBase(_base.withTypeFactory(tf));\n+    }\n+\n+    @Override\n+    public SerializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return _withBase(_base.withTypeResolverBuilder(trb));\n+    }\n+    \n+    public SerializationConfig withView(Class<?> view) {\n+        return (_view == view) ? this : new SerializationConfig(this, view);\n+    }\n+\n+    @Override\n+    public SerializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return _withBase(_base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n+        return _withBase(_base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    private final SerializationConfig _withBase(BaseSettings newBase) {\n+        return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, SerializationConfig specific factory methods\n+    /**********************************************************\n+     */\n+        \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature enabled.\n+     */\n+    public SerializationConfig with(SerializationFeature feature)\n+    {\n+        int newSerFeatures = _serFeatures | feature.getMask();\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public SerializationConfig with(SerializationFeature first, SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures | first.getMask();\n+        for (SerializationFeature f : features) {\n+            newSerFeatures |= f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public SerializationConfig withFeatures(SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (SerializationFeature f : features) {\n+            newSerFeatures |= f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public SerializationConfig without(SerializationFeature feature)\n+    {\n+        int newSerFeatures = _serFeatures & ~feature.getMask();\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public SerializationConfig without(SerializationFeature first, SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures & ~first.getMask();\n+        for (SerializationFeature f : features) {\n+            newSerFeatures &= ~f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public SerializationConfig withoutFeatures(SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (SerializationFeature f : features) {\n+            newSerFeatures &= ~f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+    \n+    public SerializationConfig withFilters(FilterProvider filterProvider) {\n+        return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n+    }\n+\n+    public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n+        return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation/overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+    }\n+    \n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return AnnotationIntrospector.nopInstance();\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    @Override\n+    public BeanDescription introspectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    @Override\n+    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+    \n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n+            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n+        }\n+        // then global overrides (disabling)\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n+            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+\n+    public final boolean isEnabled(SerializationFeature f) {\n+        return (_serFeatures & f.getMask()) != 0;\n+    }\n+    \n+    public final int getSerializationFeatures() {\n+        return _serFeatures;\n+    }\n+    \n+    public JsonInclude.Include getSerializationInclusion()\n+    {\n+        if (_serializationInclusion != null) {\n+            return _serializationInclusion;\n+        }\n+        return JsonInclude.Include.ALWAYS;\n+    }\n+    \n+    /**\n+     * Method for getting provider used for locating filters given\n+     * id (which is usually provided with filter annotations).\n+     * Will be null if no provided was set for {@link ObjectWriter}\n+     * (or if serialization directly called from {@link ObjectMapper})\n+     */\n+    public FilterProvider getFilterProvider() {\n+        return _filterProvider;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean serializer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forSerialization(this, type, this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Debug support\n+    /**********************************************************\n+     */\n+    \n+    @Override public String toString()\n+    {\n+        return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/package-info.java\n+/**\n+Package that contains most of configuration-related classes;\n+exception being couple of most-commonly used configuration\n+things (like Feature enumerations) that are at the\n+main level (<code>com.fasterxml.jackson.databind</code>).\n+*/\n+\n+package com.fasterxml.jackson.databind.cfg;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n             return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n         }\n         // [JACKSON-212]: may need to use Enum.toString()\n-        if (config.isEnabled(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING)) {\n+        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n             return EnumResolver.constructUnsafeUsingToString(enumClass);\n         }\n         return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n         if (_valueInstantiator.canCreateFromObjectWith()) {\n             SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n-            _propertyBasedCreator = new PropertyBasedCreator(_valueInstantiator, creatorProps);\n-            for (SettableBeanProperty prop : creatorProps) {\n-                if (!prop.hasValueDeserializer()) {\n-                    _propertyBasedCreator.assignDeserializer(prop,\n-                           findDeserializer(ctxt, prop.getType(), prop));\n-                }\n-            }\n+            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n         }\n \n         Iterator<SettableBeanProperty> it = _beanProperties.allProperties();\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             // Since we have no more information to add, let's not actually wrap..\n             throw (IOException) t;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n             DeserializationConfig config)\n     { \n         _beanDesc = beanDesc;\n-        _defaultViewInclusion = config.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n                 }\n             }\n         }\n-        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)\n-                && ctxt.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n+                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n \n         // Ok: let's then filter out property definitions\n         List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                 Class<?>[] views = propDef.findViews();\n                 if (views == null) {\n                     // one more twist: if default inclusion disabled, need to force empty set of views\n-                    if (!ctxt.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION)) {\n+                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                         views = NO_VIEWS;\n                     }\n                 }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n import java.util.List;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n \n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * This is the class that can be registered (via\n      *</pre>\n      *<p>\n      * Note: version 1.2 added new deserialization feature\n-     * (<code>DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES</code>).\n+     * (<code>DeserializationConfig.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>).\n      * It will only have effect <b>after</b> handler is called, and only\n      * if handler did <b>not</b> handle the problem.\n      *\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Class that defines caching layer between callers (like\n+ * {@link ObjectMapper},\n+ * {@link com.fasterxml.jackson.databind.DeserializationContext})\n+ * and classes that construct deserializers\n+ * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n+ */\n+public final class DeserializerCache\n+{\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will also cache some dynamically constructed deserializers;\n+     * specifically, ones that are expensive to construct.\n+     * This currently means bean and Enum deserializers; array, List and Map\n+     * deserializers will not be cached.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+\n+    /**\n+     * During deserializer construction process we may need to keep track of partially\n+     * completed deserializers, to resolve cyclic dependencies. This is the\n+     * map used for storing deserializers before they are fully complete.\n+     */\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public DeserializerCache() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Access to caching aspects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many deserializers this\n+     * provider is caching currently \n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of deserializers get cached;\n+     * default implementation caches only dynamically constructed deserializers,\n+     * but not eagerly constructed standard deserializers (which is different\n+     * from how serializer provider works).\n+     *<p>\n+     * The main use case for this method is to allow conditional flushing of\n+     * deserializer cache, if certain number of entries is reached.\n+     */\n+    public int cachedDeserializersCount() {\n+        return _cachedDeserializers.size();\n+    }\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     */\n+    public void flushCachedDeserializers() {\n+        _cachedDeserializers.clear();       \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General deserializer locating method\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a deserializer for a value of given type;\n+     * or if no such deserializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for value types; not for keys.\n+     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *<p>\n+     * Note also that deserializer returned is guaranteed to be resolved\n+     * (if it is of type {@link ResolvableDeserializer}), but\n+     * not contextualized (wrt {@link ContextualDeserializer}): caller\n+     * has to handle latter if necessary.\n+     *\n+     * @param ctxt Deserialization context\n+     * @param propertyType Declared type of the value to deserializer (obtained using\n+     *   'setter' method signature and/or type annotations\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType propertyType)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, need to request factory to construct (or recycle)\n+        deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n+        if (deser == null) {\n+            /* Should we let caller handle it? Let's have a helper method\n+             * decide it; can throw an exception, or return a valid\n+             * deserializer\n+             */\n+            deser = _handleUnknownValueDeserializer(propertyType);\n+        }\n+        return deser;\n+    }\n+\n+    /**\n+     * Method called to get hold of a deserializer to use for deserializing\n+     * keys for {@link java.util.Map}.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable key deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n+        if (kd == null) { // if none found, need to use a placeholder that'll fail\n+            return _handleUnknownKeyDeserializer(type);\n+        }\n+        // First: need to resolve?\n+        if (kd instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) kd).resolve(ctxt);\n+        }\n+        return kd;\n+    }\n+\n+    /**\n+     * Method called to find out whether provider would be able to find\n+     * a deserializer for given type, using a root reference (i.e. not\n+     * through fields or membership in an array or collection)\n+     */\n+    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+    {\n+        /* Note: mostly copied from findValueDeserializer, except for\n+         * handling of unknown types\n+         */\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+        if (deser == null) {\n+            try {\n+                deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return (deser != null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods that handle cache lookups\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Null JavaType passed\");\n+        }\n+        return _cachedDeserializers.get(type);\n+    }\n+\n+    /**\n+     * Method that will try to create a deserializer for given type,\n+     * and resolve and cache it if necessary\n+     * \n+     * @param config Configuration\n+     * @param type Type of property to deserializer\n+     * @param property Property (field, setter, ctor arg) to use deserializer for\n+     */\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Only one thread to construct deserializers at any given point in time;\n+         * limitations necessary to ensure that only completely initialized ones\n+         * are visible and used.\n+         */\n+        synchronized (_incompleteDeserializers) {\n+            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n+            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+            if (deser != null) {\n+                return deser;\n+            }\n+            int count = _incompleteDeserializers.size();\n+            // Or perhaps being resolved right now?\n+            if (count > 0) {\n+                deser = _incompleteDeserializers.get(type);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+            // Nope: need to create and possibly cache\n+            try {\n+                return _createAndCache2(ctxt, factory, type);\n+            } finally {\n+                // also: any deserializers that have been created are complete by now\n+                if (count == 0 && _incompleteDeserializers.size() > 0) {\n+                    _incompleteDeserializers.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that handles actual construction (via factory) and caching (both\n+     * intermediate and eventual)\n+     */\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser;\n+        try {\n+            deser = _createDeserializer(ctxt, factory, type);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+        if (deser == null) {\n+            return null;\n+        }\n+        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n+         * (but can be re-defined for sub-classes by using @JsonCachable!)\n+         */\n+        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n+        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n+        boolean addToCache = deser.isCachable();\n+\n+        /* we will temporarily hold on to all created deserializers (to\n+         * handle cyclic references, and possibly reuse non-cached\n+         * deserializers (list, map))\n+         */\n+        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n+         *   resolution of a reference -- couple of ways to prevent this;\n+         *   either not add Lists or Maps, or clear references eagerly.\n+         *   Let's actually do both; since both seem reasonable.\n+         */\n+        /* Need to resolve? Mostly done for bean deserializers; required for\n+         * resolving cyclic references.\n+         */\n+        if (isResolvable) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer)deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n+        if (addToCache) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for actual construction of deserializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that does the heavy lifting of checking for per-type annotations,\n+     * find out full type, and figure out which actual factory method\n+     * to call.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        // First things first: do we need to use abstract type mapping?\n+        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n+            type = factory.mapAbstractType(config, type);\n+        }\n+        BeanDescription beanDesc = config.introspect(type);\n+        // Then: does type define explicit deserializer to use, with annotation(s)?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n+                beanDesc.getClassInfo());\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // If not, may have further type-modification annotations to check:\n+        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n+        if (newType != type) {\n+            type = newType;\n+            beanDesc = config.introspect(newType);\n+        }\n+\n+        // If not, let's see which factory method to use:\n+        if (type.isEnumType()) {\n+            return (JsonDeserializer<Object>) factory.createEnumDeserializer(ctxt,\n+                    type, beanDesc);\n+        }\n+        if (type.isContainerType()) {\n+            if (type.isArrayType()) {\n+                return (JsonDeserializer<Object>) factory.createArrayDeserializer(ctxt,\n+                        (ArrayType) type, beanDesc);\n+            }\n+            if (type.isMapLikeType()) {\n+                MapLikeType mlt = (MapLikeType) type;\n+                if (mlt.isTrueMapType()) {\n+                    return (JsonDeserializer<Object>) factory.createMapDeserializer(ctxt,\n+                            (MapType) mlt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createMapLikeDeserializer(ctxt,\n+                        mlt, beanDesc);\n+            }\n+            if (type.isCollectionLikeType()) {\n+                CollectionLikeType clt = (CollectionLikeType) type;\n+                if (clt.isTrueCollectionType()) {\n+                    return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n+                            (CollectionType) clt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n+                        clt, beanDesc);\n+            }\n+        }\n+\n+        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n+        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n+            return (JsonDeserializer<Object>) factory.createTreeDeserializer(config, type, beanDesc);\n+        }\n+        return (JsonDeserializer<Object>) factory.createBeanDeserializer(ctxt, type, beanDesc);\n+    }\n+\n+    /**\n+     * Helper method called to check if a class or method\n+     * has annotation that tells which class to use for deserialization.\n+     * Returns null if no such annotation found.\n+     */\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n+            Annotated ann)\n+        throws JsonMappingException\n+    {\n+        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        return ctxt.deserializerInstance(ann, deserDef);\n+    }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, JavaType type)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type);\n+        if (subclass != null) {\n+            try {\n+                type = type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                    if (kd != null) {\n+                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n+                }\n+            }            \n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n+            if (cc != null) {\n+                try {\n+                    type = type.narrowContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            // ... as well as deserializer for contents:\n+            JavaType contentType = type.getContentType();\n+            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+                Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = ctxt.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = type.withContentValueHandler(cd);\n+                    }\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable error reporting methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Let's try to figure out the reason, to give better error\n+         * messages\n+         */\n+        Class<?> rawClass = type.getRawClass();\n+        if (!ClassUtil.isConcrete(rawClass)) {\n+            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n+        }\n+        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n+    }\n+\n+    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Interface that defines API for simple extensions that can provide additional deserializers\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n \n         public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException\n         {\n-            if (_isPrimitive && ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n+            if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                 throw ctxt.mappingException(\"Can not map JSON null into type \"+_rawType.getName()\n-                        +\" (set DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n+                        +\" (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n             }\n             return _nullValue;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n \n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Interface for providers of {@link ValueInstantiator} instances.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n \n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n      */\n     protected final SettableBeanProperty[] _propertiesWithInjectables;\n     \n-    public PropertyBasedCreator(ValueInstantiator valueInstantiator,\n-            SettableBeanProperty[] creatorProps)\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    protected PropertyBasedCreator(ValueInstantiator valueInstantiator,\n+            SettableBeanProperty[] creatorProps, Object[] defaultValues)\n     {\n         _valueInstantiator = valueInstantiator;\n         _properties = new HashMap<String, SettableBeanProperty>();\n-        // [JACKSON-372]: primitive types need extra care\n-        Object[] defValues = null;\n         SettableBeanProperty[] propertiesWithInjectables = null;\n         for (int i = 0, len = creatorProps.length; i < len; ++i) {\n             SettableBeanProperty prop = creatorProps[i];\n             _properties.put(prop.getName(), prop);\n-            if (prop.getType().isPrimitive()) {\n-                if (defValues == null) {\n-                    defValues = new Object[len];\n-                }\n-                defValues[i] = ClassUtil.defaultValue(prop.getType().getRawClass());\n-            }\n             Object injectableValueId = prop.getInjectableValueId();\n             if (injectableValueId != null) {\n                 if (propertiesWithInjectables == null) {\n                 propertiesWithInjectables[i] = prop;\n             }\n         }\n-        _defaultValues = defValues;\n+        _defaultValues = defaultValues;\n         _propertiesWithInjectables = propertiesWithInjectables;        \n     }\n \n+    /**\n+     * Factory method used for building actual instances: resolves deserializers\n+     * and checks for \"null values\".\n+     */\n+    public static PropertyBasedCreator construct(DeserializationContext ctxt,\n+            ValueInstantiator valueInstantiator, SettableBeanProperty[] srcProps)\n+        throws JsonMappingException\n+    {\n+        final int len = srcProps.length;\n+        SettableBeanProperty[] creatorProps = new SettableBeanProperty[len];\n+        Object[] defaultValues = null;\n+        for (int i = 0; i < len; ++i) {\n+            SettableBeanProperty prop = srcProps[i];\n+            if (!prop.hasValueDeserializer()) {\n+                prop = prop.withValueDeserializer(ctxt.findContextualValueDeserializer(prop.getType(), prop));\n+            }\n+            creatorProps[i] = prop;\n+            // [JACKSON-372]: primitive types need extra care\n+            // [JACKSON-774]: as do non-default nulls...\n+            JsonDeserializer<?> deser = prop.getValueDeserializer();\n+            Object nullValue = (deser == null) ? null : deser.getNullValue();\n+            if ((nullValue == null) && prop.getType().isPrimitive()) {\n+                nullValue = ClassUtil.defaultValue(prop.getType().getRawClass());\n+            }\n+            if (nullValue != null) {\n+                if (defaultValues == null) {\n+                    defaultValues = new Object[len];\n+                }\n+                defaultValues[i] = nullValue;\n+            }\n+        }\n+        return new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues);\n+    }\n+    \n+    public void assignDeserializer(SettableBeanProperty prop, JsonDeserializer<Object> deser) {\n+        prop = prop.withValueDeserializer(deser);\n+        _properties.put(prop.getName(), prop);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+    \n     public Collection<SettableBeanProperty> getCreatorProperties() {\n         return _properties.values();\n     }\n     public SettableBeanProperty findCreatorProperty(String name) {\n         return _properties.get(name);\n     }\n+    \n+    /*\n+    /**********************************************************\n+    /* Building process\n+    /**********************************************************\n+     */\n \n-    public void assignDeserializer(SettableBeanProperty prop, JsonDeserializer<Object> deser) {\n-        prop = prop.withValueDeserializer(deser);\n-        _properties.put(prop.getName(), prop);\n-    }\n-    \n     /**\n      * Method called when starting to build a bean instance.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             throw ctxt.mappingException(_collectionType.getRawClass());\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n             /* ... unless told not to do that. :-)\n              * (as per [JACKSON-412]\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n-                throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n+            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n+                throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n             }\n             \n             int index = jp.getIntValue();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n             {\n                 JsonParser.NumberType nt = jp.getNumberType();\n                 if (nt == JsonParser.NumberType.BIG_INTEGER\n-                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                     return nodeFactory.numberNode(jp.getBigIntegerValue());\n                 }\n                 if (nt == JsonParser.NumberType.INT) {\n             {\n                 JsonParser.NumberType nt = jp.getNumberType();\n                 if (nt == JsonParser.NumberType.BIG_DECIMAL\n-                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                     return nodeFactory.numberNode(jp.getDecimalValue());\n                 }\n                 return nodeFactory.numberNode(jp.getDoubleValue());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         }\n         if (_valueInstantiator.canCreateFromObjectWith()) {\n             SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n-            _propertyBasedCreator = new PropertyBasedCreator(_valueInstantiator, creatorProps);\n-            for (SettableBeanProperty prop : creatorProps) {\n-                if (!prop.hasValueDeserializer()) {\n-                    _propertyBasedCreator.assignDeserializer(prop,\n-                            findDeserializer(ctxt, prop.getType(), prop));\n-                }\n-            }\n+            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n         }\n         _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         {\n             JsonToken t = jp.getCurrentToken();\n             if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                     return jp.getBigIntegerValue();\n                 }\n                 return jp.getNumberValue();\n                 /* [JACKSON-72]: need to allow overriding the behavior\n                  * regarding which type to use\n                  */\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                     return jp.getDecimalValue();\n                 }\n                 return Double.valueOf(jp.getDoubleValue());\n                 try {\n                     if (text.indexOf('.') >= 0) { // floating point\n                         // as per [JACKSON-72]:\n-                        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                             return new BigDecimal(text);\n                         }\n                         return new Double(text);\n                     }\n                     // as per [JACKSON-100]:\n-                    if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                         return new BigInteger(text);\n                     }\n                     long value = Long.parseLong(text);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n     {\n         // [JACKSON-620] Empty String can become null...\n         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n             String str = jp.getText();\n             if (str.length() == 0) {\n                 return null;\n         }\n         \n         // Can we do implicit coercion to a single-element array still?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             /* 04-Oct-2009, tatu: One exception; byte arrays are generally\n              *   serialized as base64, so that should be handled\n              */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n             throws IOException, JsonProcessingException\n         {\n             // [JACKSON-526]: implicit arrays from single values?\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 // [JACKSON-620] Empty String can become null...\n                 if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                        && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                        && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                     String str = jp.getText();\n                     if (str.length() == 0) {\n                         return null;\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new boolean[] { _parseBooleanPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             byte value;\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new short[] { _parseShortPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new int[] { _parseIntPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new long[] { _parseLongPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new float[] { _parseFloatPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new double[] { _parseDoublePrimitive(jp, ctxt) };\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // throw exception if that's what we are expected to do\n-        if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n             throw ctxt.unknownFieldException(instanceOrClass, fieldName);\n         }\n         // ... or if not, just ignore\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n     public StdValueInstantiator(DeserializationConfig config, Class<?> valueType)\n     {\n         _cfgEmptyStringsAsObjects = (config == null) ? false\n-                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+                : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n         _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.getName();\n     }\n     \n     public StdValueInstantiator(DeserializationConfig config, JavaType valueType)\n     {\n         _cfgEmptyStringsAsObjects = (config == null) ? false\n-                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+                : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n         _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             throw ctxt.mappingException(_collectionType.getRawClass());\n         }\n         // Strings are one of \"native\" (intrinsic) types, so there's never type deserializer involved\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n             /* [JACKSON-100]: caller may want to get all integral values\n              * returned as BigInteger, for consistency\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue(); // should be optimal, whatever it is\n             }\n             return jp.getNumberValue(); // should be optimal, whatever it is\n             /* [JACKSON-72]: need to allow overriding the behavior regarding\n              *   which type to use\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return jp.getDecimalValue();\n             }\n             return Double.valueOf(jp.getDoubleValue());\n \n         case VALUE_NUMBER_INT:\n             // For [JACKSON-100], see above:\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue();\n             }\n             return jp.getIntValue();\n \n         case VALUE_NUMBER_FLOAT:\n             // For [JACKSON-72], see above\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return jp.getDecimalValue();\n             }\n             return Double.valueOf(jp.getDoubleValue());\n     protected Object mapArray(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n             return mapArrayToArray(jp, ctxt);\n         }\n         // Minor optimization to handle small lists (default size for ArrayList is 10)\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n         public void serialize(DateTime value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 jgen.writeNumber(value.getMillis());\n             } else {\n                 jgen.writeString(value.toString());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"number\" : \"string\", true);\n         }\n     }\n         public void serialize(LocalDateTime dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // Timestamp here actually means an array of values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n         public void serialize(LocalDate dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // Timestamp here actually means an array of values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n         public void serialize(DateMidnight dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // same as with other date-only values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n import java.util.Map;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n \n public class BasicClassIntrospector\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n \n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n /**\n  * Interface that defines builders that are configured based on\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n \n \n import com.fasterxml.jackson.databind.AbstractTypeResolver;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.type.ClassKey;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.type.ClassKey;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.ArrayType;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n import com.fasterxml.jackson.databind.type.ClassKey;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n     public boolean isMissingNode() { return true; }\n \n     @Override\n-    public String asText() { return null; }\n+    public String asText() { return \"\"; }\n     \n     @Override\n     public int asInt(int defaultValue) {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n \n-import com.fasterxml.jackson.databind.DatabindVersion;\n import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n         _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n     }\n \n-    protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n-        new HashMap<String, JsonSerializer<?>>();\n-    static {\n-        // Arrays of various types (including common object types)\n-        _arraySerializers.put(boolean[].class.getName(), new StdArraySerializers.BooleanArraySerializer());\n-        _arraySerializers.put(byte[].class.getName(), new StdArraySerializers.ByteArraySerializer());\n-        _arraySerializers.put(char[].class.getName(), new StdArraySerializers.CharArraySerializer());\n-        _arraySerializers.put(short[].class.getName(), new StdArraySerializers.ShortArraySerializer());\n-        _arraySerializers.put(int[].class.getName(), new StdArraySerializers.IntArraySerializer());\n-        _arraySerializers.put(long[].class.getName(), new StdArraySerializers.LongArraySerializer());\n-        _arraySerializers.put(float[].class.getName(), new StdArraySerializers.FloatArraySerializer());\n-        _arraySerializers.put(double[].class.getName(), new StdArraySerializers.DoubleArraySerializer());\n-    }\n-\n     /*\n     /**********************************************************\n     /* Configuration\n                 return StringArraySerializer.instance;\n             }\n             // other standard types?\n-            JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n+            JsonSerializer<?> ser = StdArraySerializers.findStandardImpl(raw);\n             if (ser != null) {\n                 return ser;\n             }\n                 return true;\n             }\n         } else {\n-            if (config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)) {\n+            if (config.isEnabled(MapperFeature.USE_STATIC_TYPING)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     /**********************************************************\n      */\n     \n+    @SuppressWarnings(\"unchecked\")\n     public BeanPropertyWriter(BeanPropertyDefinition propDef,\n             AnnotatedMember member, Annotations contextAnnotations,\n             JavaType declaredType,\n-            JsonSerializer<Object> ser, TypeSerializer typeSer, JavaType serType,\n+            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n             boolean suppressNulls, Object suppressableValue)\n     {\n         \n         _contextAnnotations = contextAnnotations;\n         _name = new SerializedString(propDef.getName());\n         _declaredType = declaredType;\n-        _serializer = ser;\n+        _serializer = (JsonSerializer<Object>) ser;\n         _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n         _typeSerializer = typeSer;\n         _cfgSerializationType = serType;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n         if (ser != null) {\n             return (JsonSerializer<Object>) ser;\n         }\n+        \n         // Next: we may have annotations that further define types to use...\n         JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+\n         // and if so, we consider it implicit \"force static typing\" instruction\n         boolean staticTyping = (type != origType);\n \n             }\n             JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n             // copied from BasicSerializerFactory.buildMapSerializer():\n-            boolean staticTyping = config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING);\n+            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n             JavaType valueType = type.getContentType();\n             TypeSerializer typeSer = createTypeSerializer(config, valueType);\n             // last 2 nulls; don't know key, value serializers (yet)\n         removeIgnorableTypes(config, beanDesc, properties);\n         \n         // and possibly remove ones without matching mutator...\n-        if (config.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS)) {\n+        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n             removeSetterlessGetters(config, beanDesc, properties);\n         }\n         \n                 continue;\n             }\n             if (accessor instanceof AnnotatedMethod) {\n-                result.add(_constructWriter(property, prov, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n+                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n             } else {\n-                result.add(_constructWriter(property, prov, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n+                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n             }\n         }\n         return result;\n     {\n         // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n         List<BeanPropertyWriter> props = builder.getProperties();\n-        boolean includeByDefault = config.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n         final int propCount = props.size();\n         int viewsFound = 0;\n         BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n      * Secondary helper method for constructing {@link BeanPropertyWriter} for\n      * given member (field or method).\n      */\n-    protected BeanPropertyWriter _constructWriter(BeanPropertyDefinition propDef,\n-            SerializerProvider prov, TypeBindings typeContext,\n+    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n+            BeanPropertyDefinition propDef, TypeBindings typeContext,\n             PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n         throws JsonMappingException\n     {\n         BeanProperty.Std property = new BeanProperty.Std(name, type, pb.getClassAnnotations(), accessor);\n \n         // Does member specify a serializer? If so, let's use it.\n-        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(prov, accessor);\n+        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n+                accessor);\n+        /* 02-Feb-2012, tatu: Unlike most other codepaths, Serializer produced\n+         *  here will NOT be resolved or contextualized, unless done here, so:\n+         */\n+        if (annotatedSerializer instanceof ResolvableSerializer) {\n+            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n+        }\n+        if (annotatedSerializer instanceof ContextualSerializer) {\n+            annotatedSerializer = ((ContextualSerializer) annotatedSerializer).createContextual(prov, property);\n+        }\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n         if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n \n import com.fasterxml.jackson.databind.BeanDescription;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n /**\n  * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.*;\n      *    of container type)\n      */\n     protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef,\n-            JavaType declaredType,\n-            JsonSerializer<Object> ser,\n+            JavaType declaredType, JsonSerializer<?> ser,\n             TypeSerializer typeSer, TypeSerializer contentTypeSer,\n             AnnotatedMember am, boolean defaultUseStaticTyping)\n     {\n             case ALWAYS: // default\n                 // we may still want to suppress empty collections, as per [JACKSON-254]:\n                 if (declaredType.isContainerType()\n-                        && !_config.isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS)) {\n+                        && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n                 }\n                 break;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\n+\n+/**\n+ * Simple cache object that allows for doing 2-level lookups: first level is\n+ * by \"local\" read-only lookup Map (used without locking)\n+ * and second backup level is by a shared modifiable HashMap.\n+ * The idea is that after a while, most serializers are found from the\n+ * local Map (to optimize performance, reduce lock contention),\n+ * but that during buildup we can use a shared map to reduce both\n+ * number of distinct read-only maps constructed, and number of\n+ * serializers constructed.\n+ *<p>\n+ * Since version 1.5 cache will actually contain three kinds of entries,\n+ * based on combination of class pair key. First class in key is for the\n+ * type to serialize, and second one is type used for determining how\n+ * to resolve value type. One (but not both) of entries can be null.\n+ */\n+public final class SerializerCache\n+{\n+    /**\n+     * Shared, modifiable map; all access needs to be through synchronized blocks.\n+     *<p>\n+     * NOTE: keys are of various types (see below for key types), in addition to\n+     * basic {@link JavaType} used for \"untyped\" serializers.\n+     */\n+    private HashMap<TypeKey, JsonSerializer<Object>> _sharedMap = new HashMap<TypeKey, JsonSerializer<Object>>(64);\n+\n+    /**\n+     * Most recent read-only instance, created from _sharedMap, if any.\n+     */\n+    private ReadOnlyClassToSerializerMap _readOnlyMap = null;\n+\n+    public SerializerCache() { }\n+\n+    /**\n+     * Method that can be called to get a read-only instance populated from the\n+     * most recent version of the shared lookup Map.\n+     */\n+    public ReadOnlyClassToSerializerMap getReadOnlyLookupMap()\n+    {\n+        ReadOnlyClassToSerializerMap m;\n+        synchronized (this) {\n+            m = _readOnlyMap;\n+            if (m == null) {\n+                _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap);\n+            }\n+        }\n+        return m.instance();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Lookup methods for accessing shared (slow) cache\n+    /**********************************************************\n+     */\n+\n+    public synchronized int size() {\n+        return _sharedMap.size();\n+    }\n+    \n+    /**\n+     * Method that checks if the shared (and hence, synchronized) lookup Map might have\n+     * untyped serializer for given type.\n+     */\n+    public JsonSerializer<Object> untypedValueSerializer(Class<?> type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, true));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(Class<?> cls)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(cls, true));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for adding shared serializer instances\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called if none of lookups succeeded, and caller had to construct\n+     * a serializer. If so, we will update the shared lookup map so that it\n+     * can be resolved via it next time.\n+     */\n+    public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+\n+    public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(cls, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+    \n+    public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called by StdSerializerProvider#flushCachedSerializers() to\n+     * clear all cached serializers\n+     */\n+    public synchronized void flush() {\n+        _sharedMap.clear();\n+    }\n+\n+    /*\n+    /**************************************************************\n+    /* Helper class(es)\n+    /**************************************************************\n+     */\n+\n+    /**\n+     * Key that offers two \"modes\"; one with raw class, as used for\n+     * cases were raw class type is available (for example, when using\n+     * runtime type); and one with full generics-including.\n+     */\n+    public final static class TypeKey\n+    {\n+        protected int _hashCode;\n+\n+        protected Class<?> _class;\n+\n+        protected JavaType _type;\n+\n+        /**\n+         * Indicator of whether serializer stored has a type serializer\n+         * wrapper around it or not; if not, it is \"untyped\" serializer;\n+         * if it has, it is \"typed\"\n+         */\n+        protected boolean _isTyped;\n+        \n+        public TypeKey(Class<?> key, boolean typed) {\n+            _class = key;\n+            _type = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        public TypeKey(JavaType key, boolean typed) {\n+            _type = key;\n+            _class = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        private final static int hash(Class<?> cls, boolean typed) {\n+            int hash = cls.getName().hashCode();\n+            if (typed) {\n+                ++hash;\n+            }\n+            return hash;\n+        }\n+\n+        private final static int hash(JavaType type, boolean typed) {\n+            int hash = type.hashCode() - 1;\n+            if (typed) {\n+                --hash;\n+            }\n+            return hash;\n+        }\n+        \n+        public void resetTyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = true;\n+            _hashCode = hash(cls, true);\n+        }\n+\n+        public void resetUntyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = false;\n+            _hashCode = hash(cls, false);\n+        }\n+        \n+        public void resetTyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = true;\n+            _hashCode = hash(type, true);\n+        }\n+\n+        public void resetUntyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = false;\n+            _hashCode = hash(type, false);\n+        }\n+        \n+        @Override public final int hashCode() { return _hashCode; }\n+\n+        @Override public final String toString() {\n+            if (_class != null) {\n+                return \"{class: \"+_class.getName()+\", typed? \"+_isTyped+\"}\";\n+            }\n+            return \"{type: \"+_type+\", typed? \"+_isTyped+\"}\";\n+        }\n+        \n+        // note: we assume key is never used for anything other than as map key, so:\n+        @Override public final boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            TypeKey other = (TypeKey) o;\n+            if (other._isTyped == _isTyped) {\n+                if (_class != null) {\n+                    return other._class == _class;\n+                }\n+                return _type.equals(other._type);\n+            }\n+            return false;\n+        } \n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n \n     @SuppressWarnings(\"unchecked\")\n     public IndexedStringListSerializer(JsonSerializer<?> ser) {\n-        super(List.class, null);\n+        super(List.class);\n         _serializer = (JsonSerializer<String>) ser;\n         \n     }\n     {\n         JsonSerializer<?> ser = _serializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n import java.util.Map;\n \n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+import com.fasterxml.jackson.databind.ser.SerializerCache.TypeKey;\n \n /**\n  * Specialized read-only map used for storing and accessing serializers by type.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+import com.fasterxml.jackson.databind.ser.SerializerCache.TypeKey;\n \n /**\n  * Optimized lookup table for accessing two types of serializers; typed\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n     {\n         JsonSerializer<?> ser = _elementSerializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n     @SuppressWarnings(\"unchecked\")\n     protected StringCollectionSerializer(JsonSerializer<?> ser)\n     {\n-        super(Collection.class, null);\n+        super(Collection.class);\n         _serializer = (JsonSerializer<String>) ser;\n     }        \n     \n     {\n         JsonSerializer<?> ser = _serializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n         throws IOException, JsonMappingException\n     {\n         // 27-Nov-2009, tatu: As per [JACKSON-201] may or may not fail...\n-        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+        if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n             failForEmpty(value);\n         }\n         // But if it's fine, we'll just output empty JSON Object:\n             TypeSerializer typeSer)\n         throws IOException, JsonGenerationException\n     {\n-        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+        if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n             failForEmpty(value);\n         }\n         typeSer.writeTypePrefixForObject(value, jgen);\n \n     protected void failForEmpty(Object value) throws JsonMappingException\n     {\n-        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS) )\");\n+        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS) )\");\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                     continue;\n                 }\n             }\n+            \n             JsonSerializer<Object> ser = provider.findValueSerializer(type, prop);\n             /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n              *   too, earlier; if so, it's time to connect the dots here:\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         //TODO: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                 ? \"number\" : \"string\", true);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         //todo: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                 ? \"number\" : \"string\", true);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.util.EnumValues;\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        EnumValues v = config.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING)\n+        EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n             ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n         return new EnumSerializer(v);\n     }\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n             jgen.writeNumber(en.ordinal());\n             return;\n         }\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n             return createSchemaNode(\"integer\", true);\n         }\n         ObjectNode objectNode = createSchemaNode(\"string\", true);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n              * if not, we don't really know the actual type until we get the instance.\n              */\n             // 10-Mar-2010, tatu: Except if static typing is to be used\n-            if (provider.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)\n+            if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING)\n                     || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n                 JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n                 // false -> no need to cache\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         JsonSerializer<?> ser = _valueSerializer;\n         if (ser == null) {\n             if (_valueTypeIsStatic) {\n-                ser = provider.findValueSerializer(_valueType, _property);\n+                ser = provider.findValueSerializer(_valueType, property);\n             }\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n          */\n         JsonSerializer<?> keySer = _keySerializer;\n         if (keySer == null) {\n-            keySer = provider.findKeySerializer(_keyType, _property);\n+            keySer = provider.findKeySerializer(_keyType, property);\n         } else if (keySer instanceof ContextualSerializer) {\n             keySer = ((ContextualSerializer) keySer).createContextual(provider, property);\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             Object valueElem = entry.getValue();\n         JsonSerializer<Object> prevValueSerializer = null;\n         Class<?> prevValueClass = null;\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n     \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             Object valueElem = entry.getValue();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n-import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n public abstract class StaticListSerializerBase<T extends Collection<?>>\n     extends StdSerializer<T>\n {\n-    /**\n-     * Property that contains String List to serialize, if known.\n-     */\n-    protected final BeanProperty _property;\n-\n-    protected StaticListSerializerBase(Class<?> cls, BeanProperty property)\n-    {\n+    protected StaticListSerializerBase(Class<?> cls) {\n         super(cls, false);\n-        _property = property;\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.util.HashMap;\n \n import com.fasterxml.jackson.core.*;\n \n  */\n public class StdArraySerializers\n {\n+    protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n+        new HashMap<String, JsonSerializer<?>>();\n+    static {\n+        // Arrays of various types (including common object types)\n+        _arraySerializers.put(boolean[].class.getName(), new StdArraySerializers.BooleanArraySerializer());\n+        _arraySerializers.put(byte[].class.getName(), new StdArraySerializers.ByteArraySerializer());\n+        _arraySerializers.put(char[].class.getName(), new StdArraySerializers.CharArraySerializer());\n+        _arraySerializers.put(short[].class.getName(), new StdArraySerializers.ShortArraySerializer());\n+        _arraySerializers.put(int[].class.getName(), new StdArraySerializers.IntArraySerializer());\n+        _arraySerializers.put(long[].class.getName(), new StdArraySerializers.LongArraySerializer());\n+        _arraySerializers.put(float[].class.getName(), new StdArraySerializers.FloatArraySerializer());\n+        _arraySerializers.put(double[].class.getName(), new StdArraySerializers.DoubleArraySerializer());\n+    }\n+\n     protected StdArraySerializers() { }\n \n+    /**\n+     * Accessor for checking to see if there is a standard serializer for\n+     * given primitive value type.\n+     */\n+    public static JsonSerializer<?> findStandardImpl(Class<?> cls)\n+    {\n+        return _arraySerializers.get(cls.getName());\n+    }\n+    \n     /*\n      ****************************************************************\n     /* Intermediate base classes\n             throws IOException, JsonGenerationException\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n                 jgen.writeStartArray();\n                 _writeArrayContents(jgen, value);\n                 jgen.writeEndArray();\n             throws IOException, JsonGenerationException\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n                 typeSer.writeTypePrefixForArray(value, jgen);\n                 _writeArrayContents(jgen, value);\n                 typeSer.writeTypeSuffixForArray(value, jgen);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n             throw (Error) t;\n         }\n         // Ditto for IOExceptions... except for mapping exceptions!\n-        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n                 throw (IOException) t;\n             throw (Error) t;\n         }\n         // Ditto for IOExceptions... except for mapping exceptions!\n-        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n                 throw (IOException) t;\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n  *<p>\n  * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n  * as well as many objects it constructs (like\n-* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n- * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n+* {@link com.fasterxml.jackson.databind.cfg.DeserializationConfig} and\n+ * {@link com.fasterxml.jackson.databind.cfg.SerializationConfig})),\n  * but usually those objects also \n  * expose convenience methods (<code>constructType</code>).\n  * So, you can do for example:\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n \n-import com.fasterxml.jackson.databind.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Utility class used for efficient storage of {@link JsonToken}\n         return this;\n     }\n \n-    //public JsonGenerator configure(Feature f, boolean state) { }\n+    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n \n     @Override\n     public boolean isEnabled(Feature f) {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.HandlerInstantiator;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.setPropertyNamingStrategy(new LcStrategy());\n-//        mapper.disable(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS);\n+//        mapper.disable(DeserializationConfig.DeserializationFeature.USE_GETTERS_AS_SETTERS);\n         RenamedCollectionBean foo = mapper.readValue(\"{\\\"thevalues\\\":[\\\"a\\\"]}\", RenamedCollectionBean.class);\n         assertNotNull(foo.getTheVALUEs());\n         assertEquals(1, foo.getTheVALUEs().size());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n \n import com.fasterxml.jackson.core.JsonFactory;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         ObjectMapper m = new ObjectMapper();\n         \n         // sort-alphabetically is disabled by default:\n-        assertFalse(m.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(m.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         SerializationConfig sc = m.getSerializationConfig();\n-        assertFalse(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertFalse(sc.shouldSortPropertiesAlphabetically());\n         DeserializationConfig dc = m.getDeserializationConfig();\n         assertFalse(dc.shouldSortPropertiesAlphabetically());\n \n         // but when enabled, should be visible:\n-        m.enable(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n         sc = m.getSerializationConfig();\n-        assertTrue(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertTrue(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(sc.shouldSortPropertiesAlphabetically());\n         dc = m.getDeserializationConfig();\n         // and not just via SerializationConfig, but also via DeserializationConfig\n-        assertTrue(dc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertTrue(dc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(dc.shouldSortPropertiesAlphabetically());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n \n /**\n  * Unit tests dealing with handling of \"root element wrapping\",\n         String jsonUnwrapped = mapper.writeValueAsString(input);\n         assertEquals(\"{\\\"a\\\":3}\", jsonUnwrapped);\n         // secondary: wrapping\n-        String jsonWrapped = mapper.writer(SerializationConfig.Feature.WRAP_ROOT_VALUE)\n+        String jsonWrapped = mapper.writer(SerializationFeature.WRAP_ROOT_VALUE)\n             .writeValueAsString(input);\n         assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", jsonWrapped);\n \n         Bean result = mapper.readValue(jsonUnwrapped, Bean.class);\n         assertNotNull(result);\n         try { // must not have extra wrapping\n-            result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+            result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)\n                 .readValue(jsonUnwrapped);\n             fail(\"Should have failed\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Root name 'a'\");\n         }\n         // except wrapping may be expected:\n-        result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+        result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)\n             .readValue(jsonWrapped);\n         assertNotNull(result);\n     }\n         Bean bean = reader.readValue(json);\n         assertNotNull(bean);\n \n-        // also: verify that we can override Feature as well:\n+        // also: verify that we can override SerializationFeature as well:\n         ObjectMapper wrapping = rootMapper();\n         json = wrapping.writer().withRootName(\"something\").writeValueAsString(new Bean());\n         assertEquals(\"{\\\"something\\\":{\\\"a\\\":3}}\", json);\n     private ObjectMapper rootMapper()\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n-        mapper.configure(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true);\n         return mapper;\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n     /* Unit tests\n     /**********************************************************\n      */\n-\n+    \n     // Test to verify that contextual serializer can make use of property\n     // (method, field) annotations.\n     public void testMethodAnnotations() throws Exception\n         assertEquals(\"{\\\"value\\\":\\\"prefix->abc\\\"}\", mapper.writeValueAsString(bean));\n     }\n \n+    /*\n     // [JACKSON-647]: is resolve() called for contextual instances?\n     public void testResolveOnContextual() throws Exception\n     {\n         ContextualArrayElementBean beans = new ContextualArrayElementBean(\"456\");\n         assertEquals(\"{\\\"beans\\\":[\\\"elem->456\\\"]}\", mapper.writeValueAsString(beans));\n     }\n+    */\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n     public void testWrapping() throws Exception\n     {\n         ObjectMapper wrappingMapper = new ObjectMapper();\n-        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);\n \n         // conversion is ok, even if it's bogus one\n         _convertAndVerifyPoint(wrappingMapper);\n         // also: ok to have mismatched settings, since as per [JACKSON-710], should\n         // not actually use wrapping internally in these cases\n         wrappingMapper = new ObjectMapper();\n-        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.disable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.disable(SerializationFeature.WRAP_ROOT_VALUE);\n         _convertAndVerifyPoint(wrappingMapper);\n \n         wrappingMapper = new ObjectMapper();\n-        wrappingMapper.disable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.disable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);\n         _convertAndVerifyPoint(wrappingMapper);\n     }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.deser.*;\n+\n+// Mostly for [JACSON-774]\n+public class TestCreatorNullValue extends BaseMapTest\n+{\n+    protected static class Container {\n+        Contained<String> contained;\n+\n+        @JsonCreator\n+        public Container(@JsonProperty(\"contained\") Contained<String> contained) {\n+            this.contained = contained;\n+        }\n+    }\n+\n+    private static interface Contained<T> {}\n+\n+    private static class NullContained implements Contained<Object> {}\n+\n+    private static final NullContained NULL_CONTAINED = new NullContained();\n+\n+    private static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n+        @Override\n+        public Contained<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException {\n+            return null;\n+        }\n+\n+        @Override\n+        public Contained<?> getNullValue() {\n+            return NULL_CONTAINED;\n+        }\n+    }\n+\n+    private static class ContainerDeserializerResolver extends Deserializers.Base {\n+        @Override\n+        public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n+                DeserializationConfig config, BeanDescription beanDesc)\n+            throws JsonMappingException\n+        {\n+            if (!Contained.class.isAssignableFrom(type.getRawClass())) {\n+                return null;\n+            } else {\n+                return new ContainedDeserializer();\n+            }\n+        }\n+    }\n+\n+    private static class TestModule extends Module\n+    {\n+        @Override\n+        public String getModuleName() {\n+            return \"ContainedModule\";\n+        }\n+\n+        @Override\n+        public Version version() {\n+            return Version.unknownVersion();\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext setupContext) {\n+            setupContext.addDeserializers(new ContainerDeserializerResolver());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testUsesDeserializersNullValue() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new TestModule());\n+        Container container = mapper.readValue(\"{}\", Container.class);\n+        assertEquals(NULL_CONTAINED, container.contained);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that it is possible to annotate\n+ * various kinds of things with {@link JsonCreator} annotation.\n+ */\n+public class TestCreators\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes, simple\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple(st) possible demonstration of using annotated\n+     * constructors\n+     */\n+    static class ConstructorBean {\n+        int x;\n+\n+        @JsonCreator protected ConstructorBean(@JsonProperty(\"x\") int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    /**\n+     * Another simple constructor, but with bit more unusual argument\n+     * type\n+     */\n+    static class BooleanConstructorBean {\n+        Boolean b;\n+        @JsonCreator protected BooleanConstructorBean(Boolean b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static class BooleanConstructorBean2 {\n+        boolean b;\n+        @JsonCreator protected BooleanConstructorBean2(boolean b) {\n+            this.b = b;\n+        }\n+    }\n+    \n+    static class DoubleConstructorBean {\n+        Double d; // cup?\n+        @JsonCreator protected DoubleConstructorBean(Double d) {\n+            this.d = d;\n+        }\n+    }\n+\n+    static class FactoryBean {\n+        double d; // teehee\n+\n+        private FactoryBean(double value, boolean dummy) { d = value; }\n+\n+        @JsonCreator protected static FactoryBean createIt(@JsonProperty(\"f\") double value) {\n+            return new FactoryBean(value, true);\n+        }\n+    }\n+\n+    static class LongFactoryBean {\n+        long value;\n+\n+        private LongFactoryBean(long v) { value = v; }\n+\n+        @JsonCreator static protected LongFactoryBean valueOf(long v) {\n+            return new LongFactoryBean(v);\n+        }\n+    }\n+\n+    static class StringFactoryBean {\n+        String value;\n+\n+        private StringFactoryBean(String v, boolean dummy) { value = v; }\n+\n+        @JsonCreator static protected StringFactoryBean valueOf(String v) {\n+            return new StringFactoryBean(v, true);\n+        }\n+    }\n+\n+    static class FactoryBeanMixIn { // static just to be able to use static methods\n+        /**\n+         * Note: signature (name and parameter types) must match; but\n+         * only annotations will be used, not code or such. And use\n+         * is by augmentation, so we only need to add things to add\n+         * or override.\n+         */\n+        static FactoryBean createIt(@JsonProperty(\"mixed\") double xyz) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Simple demonstration of INVALID construtor annotation (only\n+     * defining name for first arg)\n+     */\n+    static class BrokenBean {\n+        @JsonCreator protected BrokenBean(@JsonProperty(\"a\") int a,\n+                                          int b) {\n+        }\n+    }\n+\n+    /**\n+     * Bean that defines both creator and factory methor as\n+     * creators. Constructors have priority; but it is possible\n+     * to hide it using mix-in annotations.\n+     */\n+    static class CreatorBean\n+    {\n+        String a;\n+        int x;\n+\n+        @JsonCreator\n+        protected CreatorBean(@JsonProperty(\"a\") String paramA,\n+                              @JsonProperty(\"x\") int paramX)\n+        {\n+            a = \"ctor:\"+paramA;\n+            x = 1+paramX;\n+        }\n+\n+        private CreatorBean(String a, int x, boolean dummy) {\n+            this.a = a;\n+            this.x = x;\n+        }\n+\n+        @JsonCreator\n+        public static CreatorBean buildMeUpButterCup(@JsonProperty(\"a\") String paramA,\n+                                                     @JsonProperty(\"x\") int paramX)\n+        {\n+            return new CreatorBean(\"factory:\"+paramA, paramX-1, false);\n+        }\n+    }\n+\n+    /**\n+     * Class for sole purpose of hosting mix-in annotations.\n+     * Couple of things to note: (a) MUST be static class (non-static\n+     * get implicit pseudo-arg, 'this';\n+     * (b) for factory methods, must have static to match (part of signature)\n+     */\n+    abstract static class MixIn {\n+        @JsonIgnore private MixIn(String a, int x) { }\n+    }\n+\n+    static class MultiBean {\n+        Object value;\n+\n+        @JsonCreator public MultiBean(int v) { value = v; }\n+        @JsonCreator public MultiBean(double v) { value = v; }\n+        @JsonCreator public MultiBean(String v) { value = v; }\n+        @JsonCreator public MultiBean(boolean v) { value = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes, mixed (creator and props)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Test bean for ensuring that constructors can be mixed with setters\n+     */\n+    static class ConstructorAndPropsBean\n+    {\n+        final int a, b;\n+        boolean c;\n+\n+        @JsonCreator protected ConstructorAndPropsBean(@JsonProperty(\"a\") int a,\n+                                                       @JsonProperty(\"b\") int b)\n+        {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        public void setC(boolean value) { c = value; }\n+    }\n+\n+    /**\n+     * Test bean for ensuring that factory methods can be mixed with setters\n+     */\n+    static class FactoryAndPropsBean\n+    {\n+        boolean[] arg1;\n+        int arg2, arg3;\n+\n+        @JsonCreator protected FactoryAndPropsBean(@JsonProperty(\"a\") boolean[] arg)\n+        {\n+            arg1 = arg;\n+        }\n+\n+        public void setB(int value) { arg2 = value; }\n+        public void setC(int value) { arg3 = value; }\n+    }\n+\n+    static class DeferredConstructorAndPropsBean\n+    {\n+        final int[] createA;\n+        String propA = \"xyz\";\n+        String propB;\n+\n+        @JsonCreator\n+        public DeferredConstructorAndPropsBean(@JsonProperty(\"createA\") int[] a)\n+        {\n+            createA = a;\n+        }\n+        public void setPropA(String a) { propA = a; }\n+        public void setPropB(String b) { propB = b; }\n+    }\n+\n+    static class DeferredFactoryAndPropsBean\n+    {\n+        String prop, ctor;\n+\n+        @JsonCreator DeferredFactoryAndPropsBean(@JsonProperty(\"ctor\") String str)\n+        {\n+            ctor = str;\n+        }\n+\n+        public void setProp(String str) { prop = str; }\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Annotated helper classes for Maps\n+    //////////////////////////////////////////////\n+     */\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MapWithCtor extends HashMap<Object,Object>\n+    {\n+        final int _number;\n+        String _text = \"initial\";\n+\n+        MapWithCtor() { this(-1, \"default\"); }\n+\n+        @JsonCreator\n+            public MapWithCtor(@JsonProperty(\"number\") int nr,\n+                               @JsonProperty(\"text\") String t)\n+        {\n+            _number = nr;\n+            _text = t;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MapWithFactory extends TreeMap<Object,Object>\n+    {\n+        Boolean _b;\n+\n+        private MapWithFactory(Boolean b) {\n+            _b = b;\n+        }\n+\n+        @JsonCreator\n+            static MapWithFactory createIt(@JsonProperty(\"b\") Boolean b)\n+        {\n+            return new MapWithFactory(b);\n+        }\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, non-deferred, no-mixins\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testSimpleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ConstructorBean bean = m.readValue(\"{ \\\"x\\\" : 42 }\", ConstructorBean.class);\n+        assertEquals(42, bean.x);\n+    }\n+\n+    public void testSimpleDoubleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Double exp = new Double(\"0.25\");\n+        DoubleConstructorBean bean = m.readValue(exp.toString(), DoubleConstructorBean.class);\n+        assertEquals(exp, bean.d);\n+    }\n+\n+    public void testSimpleBooleanConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BooleanConstructorBean bean = m.readValue(\" true \", BooleanConstructorBean.class);\n+        assertEquals(Boolean.TRUE, bean.b);\n+\n+        BooleanConstructorBean2 bean2 = m.readValue(\" true \", BooleanConstructorBean2.class);\n+        assertTrue(bean2.b);\n+    }\n+\n+    public void testSimpleFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryBean bean = m.readValue(\"{ \\\"f\\\" : 0.25 }\", FactoryBean.class);\n+        assertEquals(0.25, bean.d);\n+    }\n+\n+    public void testLongFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        long VALUE = 123456789000L;\n+        LongFactoryBean bean = m.readValue(String.valueOf(VALUE), LongFactoryBean.class);\n+        assertEquals(VALUE, bean.value);\n+    }\n+\n+    public void testStringFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String str = \"abc\";\n+        StringFactoryBean bean = m.readValue(quote(str), StringFactoryBean.class);\n+        assertEquals(str, bean.value);\n+    }\n+\n+    public void testConstructorCreator() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        CreatorBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n+        assertEquals(13, bean.x);\n+        assertEquals(\"ctor:xyz\", bean.a);\n+    }\n+\n+    public void testConstructorAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ConstructorAndPropsBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"1\\\", \\\"b\\\": 2, \\\"c\\\" : true }\", ConstructorAndPropsBean.class);\n+        assertEquals(1, bean.a);\n+        assertEquals(2, bean.b);\n+        assertEquals(true, bean.c);\n+    }\n+\n+    public void testFactoryAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryAndPropsBean bean = m.readValue\n+            (\"{ \\\"a\\\" : [ false, true, false ], \\\"b\\\": 2, \\\"c\\\" : -1 }\", FactoryAndPropsBean.class);\n+        assertEquals(2, bean.arg2);\n+        assertEquals(-1, bean.arg3);\n+        boolean[] arg1 = bean.arg1;\n+        assertNotNull(arg1);\n+        assertEquals(3, arg1.length);\n+        assertFalse(arg1[0]);\n+        assertTrue(arg1[1]);\n+        assertFalse(arg1[2]);\n+    }\n+\n+    /**\n+     * Test to verify that multiple creators may co-exist, iff\n+     * they use different JSON type as input\n+     */\n+    public void testMultipleCreators() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MultiBean bean = m.readValue(\"123\", MultiBean.class);\n+        assertEquals(Integer.valueOf(123), bean.value);\n+        bean = m.readValue(quote(\"abc\"), MultiBean.class);\n+        assertEquals(\"abc\", bean.value);\n+        bean = m.readValue(\"0.25\", MultiBean.class);\n+        assertEquals(Double.valueOf(0.25), bean.value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, valid cases, deferred, no mixins\n+    /**********************************************************\n+     */\n+\n+    public void testDeferredConstructorAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeferredConstructorAndPropsBean bean = m.readValue\n+            (\"{ \\\"propB\\\" : \\\"...\\\", \\\"createA\\\" : [ 1 ], \\\"propA\\\" : null }\",\n+             DeferredConstructorAndPropsBean.class);\n+\n+        assertEquals(\"...\", bean.propB);\n+        assertNull(bean.propA);\n+        assertNotNull(bean.createA);\n+        assertEquals(1, bean.createA.length);\n+        assertEquals(1, bean.createA[0]);\n+    }\n+\n+    public void testDeferredFactoryAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeferredFactoryAndPropsBean bean = m.readValue\n+            (\"{ \\\"prop\\\" : \\\"1\\\", \\\"ctor\\\" : \\\"2\\\" }\", DeferredFactoryAndPropsBean.class);\n+        assertEquals(\"1\", bean.prop);\n+        assertEquals(\"2\", bean.ctor);\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, mixins\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testFactoryCreatorWithMixin() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        CreatorBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n+        assertEquals(11, bean.x);\n+        assertEquals(\"factory:xyz\", bean.a);\n+    }\n+\n+    public void testFactoryCreatorWithRenamingMixin() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        // override changes property name from \"f\" to \"mixed\"\n+        FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n+        assertEquals(20.5, bean.d);\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, Map with creator\n+    // (to test [JACKSON-153])\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testMapWithConstructor() throws Exception\n+    {\n+        MapWithCtor result = new ObjectMapper().readValue\n+            (\"{\\\"text\\\":\\\"abc\\\", \\\"entry\\\":true, \\\"number\\\":123, \\\"xy\\\":\\\"yx\\\"}\",\n+             MapWithCtor.class);\n+        // regular Map entries:\n+        assertEquals(Boolean.TRUE, result.get(\"entry\"));\n+        assertEquals(\"yx\", result.get(\"xy\"));\n+        assertEquals(2, result.size());\n+        // then ones passed via constructor\n+        assertEquals(\"abc\", result._text);\n+        assertEquals(123, result._number);\n+    }\n+\n+    public void testMapWithFactory() throws Exception\n+    {\n+        MapWithFactory result = new ObjectMapper().readValue\n+            (\"{\\\"x\\\":\\\"...\\\",\\\"b\\\":true  }\",\n+             MapWithFactory.class);\n+        assertEquals(\"...\", result.get(\"x\"));\n+        assertEquals(1, result.size());\n+        assertEquals(Boolean.TRUE, result._b);\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Test methods, invalid/broken cases\n+    //////////////////////////////////////////////\n+     */\n+\n+    public void testBrokenConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            /*BrokenBean bean =*/ m.readValue(\"{ \\\"x\\\" : 42 }\", BrokenBean.class);\n+        } catch (JsonMappingException je) {\n+            verifyException(je, \"has no property name\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators2.java\n+\n+package com.fasterxml.jackson.databind.creators;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+public class TestCreators2\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class HashTest\n+    {\n+        final byte[] bytes;\n+        final String type;\n+\n+        @JsonCreator\n+        public HashTest(@JsonProperty(\"bytes\") @JsonDeserialize(using = BytesDeserializer.class) final byte[] bytes,\n+                @JsonProperty(\"type\") final String type)\n+        {\n+            this.bytes = bytes;\n+            this.type = type;\n+        }\n+    }\n+\n+    static class BytesDeserializer extends JsonDeserializer<byte[]>\n+    {\n+        @Override\n+        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            String str = jp.getText();\n+            return str.getBytes(\"UTF-8\");\n+        }\n+    }\n+\n+    static class Primitives\n+    {\n+        protected int x = 3;\n+        protected double d = -0.5;\n+        protected boolean b = true;\n+        \n+        @JsonCreator\n+        public Primitives(@JsonProperty(\"x\") int x,\n+                @JsonProperty(\"d\") double d,\n+                @JsonProperty(\"b\") boolean b)\n+        {\n+            this.x = x;\n+            this.d = d;\n+            this.b = b;\n+        }\n+    }\n+    \n+    protected static class Test431Container {\n+        protected final List<Item431> items;\n+\n+        @JsonCreator\n+        public Test431Container(@JsonProperty(\"items\") final List<Item431> i) {\n+            items = i;\n+        }\n+}    \n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    protected static class Item431 {\n+        protected final String id;\n+\n+        @JsonCreator\n+        public Item431(@JsonProperty(\"id\") String id) {\n+            this.id = id;\n+        }\n+    }\n+\n+    // Test class for verifying that creator-call failures are reported as checked exceptions\n+    static class BeanFor438 {\n+        @JsonCreator\n+        public BeanFor438(@JsonProperty(\"name\") String s) {\n+            throw new IllegalArgumentException(\"I don't like that name!\");\n+        }\n+    }\n+\n+    // For [JACKSON-465]\n+    static class MapBean\n+    {\n+        protected Map<String,Long> map;\n+        \n+        @JsonCreator\n+        public MapBean(Map<String, Long> map) {\n+            this.map = map;\n+        }\n+    }\n+\n+    // For [JACKSON-470]: should be appropriately detected, reported error about\n+    static class BrokenCreatorBean\n+    {\n+        protected String bar;\n+        \n+        @JsonCreator\n+        public BrokenCreatorBean(@JsonProperty(\"bar\") String bar1, @JsonProperty(\"bar\") String bar2) {\n+            bar = \"\"+bar1+\"/\"+bar2;\n+        }\n+    }\n+    \n+    // For [JACKSON-541]: should not need @JsonCreator if SerializationFeature.AUTO_DETECT_CREATORS is on.\n+    static class AutoDetectConstructorBean\n+    {\n+    \tprotected final String foo;\n+    \tprotected final String bar;\n+\n+    \tpublic AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar, @JsonProperty(\"foo\") String foo){\n+    \t    this.bar = bar;\n+    \t    this.foo = foo;\n+    \t}\n+    }\n+\n+    static class BustedCtor {\n+        @JsonCreator\n+        BustedCtor(@JsonProperty(\"a\") String value) {\n+            throw new IllegalArgumentException(\"foobar\");\n+        }\n+    }\n+\n+    // As per [JACKSON-575]\n+    static class IgnoredCtor\n+    {\n+        @JsonIgnore\n+        public IgnoredCtor(String arg) {\n+            throw new RuntimeException(\"Should never use this constructor\");\n+        }\n+\n+        public IgnoredCtor() { }\n+    }\n+\n+    abstract static class AbstractBase {\n+        @JsonCreator\n+        public static AbstractBase create(Map<String,Object> props)\n+        {\n+            return new AbstractBaseImpl(props);\n+        }\n+    }\n+\n+    static class AbstractBaseImpl extends AbstractBase\n+    {\n+        protected Map<String,Object> props;\n+        \n+        public AbstractBaseImpl(Map<String,Object> props) {\n+            this.props = props;\n+        }\n+    }\n+    \n+    static interface Issue700Set extends java.util.Set<Object> { }\n+\n+    static class Issue700Bean\n+    {\n+        protected Issue700Set item;\n+\n+        @JsonCreator\n+        public Issue700Bean(@JsonProperty(\"item\") String item) { }\n+\n+        public String getItem() { return null; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // for [JACKSON-547]\n+    public void testExceptionFromConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            m.readValue(\"{}\", BustedCtor.class);\n+            fail(\"Expected exception\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \": foobar\");\n+            // also: should have nested exception\n+            Throwable t = e.getCause();\n+            assertNotNull(t);\n+            assertEquals(IllegalArgumentException.class, t.getClass());\n+            assertEquals(\"foobar\", t.getMessage());\n+        }\n+    }\n+    \n+    public void testSimpleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        HashTest test = m.readValue(\"{\\\"type\\\":\\\"custom\\\",\\\"bytes\\\":\\\"abc\\\" }\", HashTest.class);\n+        assertEquals(\"custom\", test.type);\n+        assertEquals(\"abc\", new String(test.bytes, \"UTF-8\"));\n+    }    \n+\n+    // Test for [JACKSON-372]\n+    public void testMissingPrimitives() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Primitives p = m.readValue(\"{}\", Primitives.class);\n+        assertFalse(p.b);\n+        assertEquals(0, p.x);\n+        assertEquals(0.0, p.d);\n+    }\n+\n+    public void testJackson431() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        final Test431Container foo = m.readValue(\n+                \"{\\\"items\\\":\\n\"\n+                +\"[{\\\"bar\\\": 0,\\n\"\n+                +\"\\\"id\\\": \\\"id123\\\",\\n\"\n+                +\"\\\"foo\\\": 1\\n\" \n+                +\"}]}\",\n+                Test431Container.class);\n+        assertNotNull(foo);\n+    }\n+\n+    // [JACKSON-438]: Catch and rethrow exceptions that Creator methods throw\n+    public void testJackson438() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            m.readValue(\"{ \\\"name\\\":\\\"foobar\\\" }\", BeanFor438.class);\n+            fail(\"Should have failed\");\n+        } catch (Exception e) {\n+            if (!(e instanceof JsonMappingException)) {\n+                fail(\"Should have received JsonMappingException, caught \"+e.getClass().getName());\n+            }\n+            verifyException(e, \"don't like that name\");\n+            // Ok: also, let's ensure root cause is directly linked, without other extra wrapping:\n+            Throwable t = e.getCause();\n+            assertNotNull(t);\n+            assertEquals(IllegalArgumentException.class, t.getClass());\n+            verifyException(e, \"don't like that name\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIssue465() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final String JSON = \"{\\\"A\\\":12}\";\n+\n+        // first, test with regular Map, non empty\n+        Map<String,Long> map = mapper.readValue(JSON, Map.class);\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(12), map.get(\"A\"));\n+        \n+        MapBean bean = mapper.readValue(JSON, MapBean.class);\n+        assertEquals(1, bean.map.size());\n+        assertEquals(Long.valueOf(12L), bean.map.get(\"A\"));\n+\n+        // and then empty ones\n+        final String EMPTY_JSON = \"{}\";\n+\n+        map = mapper.readValue(EMPTY_JSON, Map.class);\n+        assertEquals(0, map.size());\n+        \n+        bean = mapper.readValue(EMPTY_JSON, MapBean.class);\n+        assertEquals(0, bean.map.size());\n+    }\n+\n+    public void testCreatorWithDupNames() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(\"{\\\"bar\\\":\\\"x\\\"}\", BrokenCreatorBean.class);\n+            fail(\"Should have caught duplicate creator parameters\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"duplicate creator property \\\"bar\\\"\");\n+        }\n+    }\n+    \n+    public void testCreatorMultipleArgumentWithoutAnnotation() throws Exception {\n+    \tObjectMapper mapper = new ObjectMapper();\n+    \tAutoDetectConstructorBean value = mapper.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\", AutoDetectConstructorBean.class);\n+    \tassertEquals(\"bar\", value.bar);\n+    \tassertEquals(\"foo\", value.foo);\n+    }\n+\n+    // for [JACKSON-575]\n+    public void testIgnoredSingleArgCtor() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(quote(\"abc\"), IgnoredCtor.class);\n+            fail(\"Should have caught missing constructor problem\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"no single-String constructor/factory method\");\n+        }\n+    }\n+\n+    public void testAbstractFactory() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AbstractBase bean = mapper.readValue(\"{\\\"a\\\":3}\",\n+                AbstractBase.class);\n+        assertNotNull(bean);\n+        AbstractBaseImpl impl = (AbstractBaseImpl) bean;\n+        assertEquals(1, impl.props.size());\n+        assertEquals(Integer.valueOf(3), impl.props.get(\"a\"));\n+    }\n+\n+    // [JACKSON-700]\n+    public void testCreatorProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Issue700Bean value = mapper.readValue(\"{ \\\"item\\\" : \\\"foo\\\" }\", Issue700Bean.class);\n+        assertNotNull(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueInstantiator.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonValueInstantiator;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Test related to [JACKSON-580] (allow specifying custom instantiators)\n+ */\n+public class TestValueInstantiator extends BaseMapTest\n+{\n+    static class MyBean\n+    {\n+        String _secret;\n+        \n+        public MyBean(String s, boolean bogus) {\n+            _secret = s;\n+        }\n+    }\n+\n+    static class MysteryBean\n+    {\n+        Object value;\n+        \n+        public MysteryBean(Object v) { value = v; }\n+    }\n+    \n+    static class CreatorBean\n+    {\n+        String _secret;\n+\n+        public String value;\n+        \n+        protected CreatorBean(String s) {\n+            _secret = s;\n+        }\n+    }\n+\n+    static abstract class InstantiatorBase extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return \"UNKNOWN\";\n+        }\n+\n+        @Override\n+        public boolean canCreateUsingDelegate() { return false; }\n+    }\n+    \n+    static abstract class PolymorphicBeanBase { }\n+    \n+    static class PolymorphicBean extends PolymorphicBeanBase\n+    {\n+        public String name;\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class MyList extends ArrayList<Object>\n+    {\n+        public MyList(boolean b) { super(); }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyMap extends HashMap<String,Object>\n+    {\n+        public MyMap(boolean b) { super(); }\n+        public MyMap(String name) {\n+            super();\n+            put(name, name);\n+        }\n+    }\n+    \n+    static class MyBeanInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyBean.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyBean createUsingDefault(DeserializationContext ctxt) {\n+            return new MyBean(\"secret!\", true);\n+        }\n+    }\n+\n+    /**\n+     * Something more ambitious: semi-automated approach to polymorphic\n+     * deserialization, using ValueInstantiator; from Object to any\n+     * type...\n+     */\n+    static class PolymorphicBeanInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return Object.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateFromObjectWith() { return true; }\n+\n+        @Override\n+        public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n+            return  new CreatorProperty[] {\n+                    new CreatorProperty(\"type\", config.constructType(Class.class),\n+                            null, null, null, 0, null)\n+            };\n+        }\n+\n+        @Override\n+        public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {\n+            try {\n+                Class<?> cls = (Class<?>) args[0];\n+                return cls.newInstance();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+    \n+    static class CreatorMapInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateFromObjectWith() { return true; }\n+\n+        @Override\n+        public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n+            return  new CreatorProperty[] {\n+                    new CreatorProperty(\"name\", config.constructType(String.class),\n+                            null, null, null, 0, null)\n+            };\n+        }\n+\n+        @Override\n+        public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {\n+            return new MyMap((String) args[0]);\n+        }\n+    }\n+    \n+    static class MyDelegateBeanInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType(DeserializationConfig config) {\n+            return config.constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {\n+            return new MyBean(\"\"+delegate, true);\n+        }\n+    }\n+    \n+    static class MyListInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyList.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyList createUsingDefault(DeserializationContext ctxt) {\n+            return new MyList(true);\n+        }\n+    }\n+\n+    static class MyDelegateListInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType(DeserializationConfig config) {\n+            return config.constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {\n+            MyList list = new MyList(true);\n+            list.add(delegate);\n+            return list;\n+        }\n+    }\n+    \n+    static class MyMapInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyMap createUsingDefault(DeserializationContext ctxt) {\n+            return new MyMap(true);\n+        }\n+    }\n+\n+    static class MyDelegateMapInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType(DeserializationConfig config) {\n+            return TypeFactory.defaultInstance().constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {\n+            MyMap map = new MyMap(true);\n+            map.put(\"value\", delegate);\n+            return map;\n+        }\n+    }\n+\n+    @JsonValueInstantiator(AnnotatedBeanInstantiator.class)\n+    static class AnnotatedBean {\n+        protected final String a;\n+        protected final int b;\n+        \n+        public AnnotatedBean(String a, int b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    static class AnnotatedBeanInstantiator extends InstantiatorBase\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public AnnotatedBean createUsingDefault(DeserializationContext ctxt) {\n+            return new AnnotatedBean(\"foo\", 3);\n+        }\n+    }\n+    \n+    static class MyModule extends SimpleModule\n+    {\n+        public MyModule(Class<?> cls, ValueInstantiator inst)\n+        {\n+            super(\"Test\", Version.unknownVersion());\n+            this.addValueInstantiator(cls, inst);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests for default creators\n+    /**********************************************************\n+     */\n+\n+    public void testCustomBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator()));\n+        MyBean bean = mapper.readValue(\"{}\", MyBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"secret!\", bean._secret);\n+    }\n+\n+    public void testCustomListInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyList.class, new MyListInstantiator()));\n+        MyList result = mapper.readValue(\"[]\", MyList.class);\n+        assertNotNull(result);\n+        assertEquals(MyList.class, result.getClass());\n+        assertEquals(0, result.size());\n+    }\n+\n+    public void testCustomMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator()));\n+        MyMap result = mapper.readValue(\"{ \\\"a\\\":\\\"b\\\" }\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(MyMap.class, result.getClass());\n+        assertEquals(1, result.size());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests for delegate creators\n+    /**********************************************************\n+     */\n+\n+    public void testDelegateBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyBean.class, new MyDelegateBeanInstantiator()));\n+        MyBean bean = mapper.readValue(\"123\", MyBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._secret);\n+    }\n+\n+    public void testDelegateListInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator()));\n+        MyList result = mapper.readValue(\"123\", MyList.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(123), result.get(0));\n+    }\n+    \n+    public void testDelegateMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator()));\n+        MyMap result = mapper.readValue(\"123\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(123), result.values().iterator().next());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests for property-based creators\n+    /**********************************************************\n+     */\n+\n+    public void testPropertyBasedBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(CreatorBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromObjectWith() { return true; }\n+        \n+                    @Override\n+                    public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n+                        return  new CreatorProperty[] {\n+                                new CreatorProperty(\"secret\", config.constructType(String.class),\n+                                        null, null, null, 0, null)\n+                        };\n+                    }\n+        \n+                    @Override\n+                    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {\n+                        return new CreatorBean((String) args[0]);\n+                    }\n+        }));\n+        CreatorBean bean = mapper.readValue(\"{\\\"secret\\\":123,\\\"value\\\":37}\", CreatorBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._secret);\n+    }\n+\n+    public void testPropertyBasedMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new CreatorMapInstantiator()));\n+        MyMap result = mapper.readValue(\"{\\\"name\\\":\\\"bob\\\", \\\"x\\\":\\\"y\\\"}\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(2, result.size());\n+        assertEquals(\"bob\", result.get(\"bob\"));\n+        assertEquals(\"y\", result.get(\"x\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests for scalar-delegates\n+    /**********************************************************\n+     */\n+\n+    public void testBeanFromString() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromString() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromString(DeserializationContext ctxt, String value) {\n+                        return new MysteryBean(value);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(quote(\"abc\"), MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.value);\n+    }\n+\n+    public void testBeanFromInt() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromInt() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromInt(DeserializationContext ctxt, int value) {\n+                        return new MysteryBean(value+1);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"37\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Integer.valueOf(38), result.value);\n+    }\n+\n+    public void testBeanFromLong() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromLong() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromLong(DeserializationContext ctxt, long value) {\n+                        return new MysteryBean(value+1L);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"9876543210\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Long.valueOf(9876543211L), result.value);\n+    }\n+\n+    public void testBeanFromDouble() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromDouble() { return true; }\n+\n+                    @Override\n+                    public Object createFromDouble(DeserializationContext ctxt, double value) {\n+                        return new MysteryBean(2.0 * value);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"0.25\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Double.valueOf(0.5), result.value);\n+    }\n+\n+    public void testBeanFromBoolean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromBoolean() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromBoolean(DeserializationContext ctxt, boolean value) {\n+                        return new MysteryBean(Boolean.valueOf(value));\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"true\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Boolean.TRUE, result.value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other tests\n+    /**********************************************************\n+     */\n+\n+    \n+    /**\n+     * Beyond basic features, it should be possible to even implement\n+     * polymorphic handling...\n+     */\n+    public void testPolymorphicCreatorBean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(PolymorphicBeanBase.class, new PolymorphicBeanInstantiator()));\n+        String JSON = \"{\\\"type\\\":\"+quote(PolymorphicBean.class.getName())+\",\\\"name\\\":\\\"Axel\\\"}\";\n+        PolymorphicBeanBase result = mapper.readValue(JSON, PolymorphicBeanBase.class);\n+        assertNotNull(result);\n+        assertSame(PolymorphicBean.class, result.getClass());\n+        assertEquals(\"Axel\", ((PolymorphicBean) result).name);\n+    }\n+\n+    public void testJackson633() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedBean bean = mapper.readValue(\"{}\", AnnotatedBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"foo\", bean.a);\n+        assertEquals(3, bean.b);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n     public void testIgnored() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, true);\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);\n         _testIgnorals(mapper);\n     }\n \n     public void testIgnored383() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n         _testIgnorals(mapper);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         assertNull(m.readValue(quote(\"\"), Object[].class));\n         assertNull( m.readValue(quote(\"\"), String[].class));\n         assertNull( m.readValue(quote(\"\"), int[].class));\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n \n         // should be ok to enable dynamically:\n         mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         Bean result = mapper.readValue(quote(\"\"), Bean.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     public void testImplicitArrays() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n+        mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n \n         // first with simple scalar types (numbers), with collections\n         List<Integer> ints = mapper.readValue(\"4\", List.class);\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         List<?> result = m.readValue(quote(\"\"), List.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Unit tests for checking handling of DeserializationConfig.\n         DeserializationConfig cfg = m.getDeserializationConfig();\n \n         // Expected defaults:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_CREATORS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_CREATORS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n \n-        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS));\n-        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS));\n+        assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS));\n+        assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS));\n \n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        assertTrue(cfg.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n     }\n \n     public void testOverrideIntrospectors()\n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getDeserializationConfig().isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS));\n         // with annotations, property is renamed\n         AnnoBean bean = m.readValue(\"{ \\\"y\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n \n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n         // without annotations, should default to default bean-based name...\n         bean = m.readValue(\"{ \\\"x\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n     {\n         // can't reuse global one due to reconfig\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);\n         LowerCaseEnum value = m.readValue(\"\\\"c\\\"\", LowerCaseEnum.class);\n         assertEquals(LowerCaseEnum.C, value);\n     }\n     {\n         // can't reuse global one due to reconfig\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);\n         EnumMap<LowerCaseEnum,String> value = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\",\n                 new TypeReference<EnumMap<LowerCaseEnum,String>>() { });\n         assertEquals(\"value\", value.get(LowerCaseEnum.A));\n     public void testNumbersToEnums() throws Exception\n     {\n         // by default numbers are fine:\n-        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS));\n+        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS));\n         TestEnum value = mapper.readValue(\"1\", TestEnum.class);\n         assertSame(TestEnum.RULES, value);\n \n         // but can also be changed to errors:\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n+        m.configure(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n         try {\n             value = m.readValue(\"1\", TestEnum.class);\n             fail(\"Expected an error\");\n     public void testEnumsWithIndex() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        m.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n         String json = m.writeValueAsString(TestEnum.RULES);\n         assertEquals(String.valueOf(TestEnum.RULES.ordinal()), json);\n         TestEnum result = m.readValue(json, TestEnum.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericNumber.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericNumber.java\n          * to BigInteger even if value would fit in Integer\n          */\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);\n+        m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS);\n         BigInteger exp = BigInteger.valueOf(123L);\n \n         // first test as any Number\n     public void testFpTypeOverrideSimple() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+        m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n         BigDecimal dec = new BigDecimal(\"0.1\");\n \n         // First test generic stand-alone Number\n         ObjectMapper m = new ObjectMapper();\n         BigDecimal dec = new BigDecimal(\"-19.37\");\n \n-        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+        m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n \n         // List element types\n         @SuppressWarnings(\"unchecked\")\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n         \n         // but not when enabled\n         final ObjectMapper mapper2 = new ObjectMapper();\n-        mapper2.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n+        mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n \n         // boolean\n         try {\n         assertTrue(ob instanceof List<?>);\n \n         // but can change to produce Object[]:\n-        mapper.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        mapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n         ob = mapper.readValue(\"[1]\", Object.class);\n         assertEquals(Object[].class, ob.getClass());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         Map<?,?> result = m.readValue(quote(\"\"), Map.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that feature requested\n     {\n         ObjectMapper m = new ObjectMapper();\n         // by default, it should be enabled\n-        assertTrue(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n+        assertFalse(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n \n         // and now this should fail\n         try {\n         throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n         // so this should fail now without a setter\n         try {\n             m.readValue\n     public void testSetterlessPrecedence() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, true);\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, true);\n         Dual value = m.readValue(\"{\\\"list\\\":[1,2,3]}, valueType)\", Dual.class);\n         assertNotNull(value);\n         assertEquals(3, value.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n         throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n         TestBean result = null;\n         try {\n             result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n         assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis());\n         \n         // and then textual variant\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // this is ALMOST same as default for XMLGregorianCalendar... just need to unify Z/+0000\n         String exp = cal.toXMLFormat();\n         String act = mapper.writeValueAsString(cal);\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestJodaTime.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJodaTime.java\n \n         // but if re-configured, as regular ISO-8601 string\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        m.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         assertEquals(quote(\"1970-01-01T00:00:00.000Z\"), serializeAsString(m, dt));\n     }\n \n         assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n     }\n \n         assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n     }\n \n         assertEquals(\"[2001,5,25,10,15,30,37]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25T10:15:30.037\"), mapper.writeValueAsString(date));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n     public void testSerializeDeserializeWithJaxbAnnotations() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationConfig.Feature.INDENT_OUTPUT);\n+        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n         JacksonExample ex = new JacksonExample();\n         QName qname = new QName(\"urn:hi\", \"hello\");\n         ex.setQname(qname);\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestPOJOPropertiesCollector\n     extends BaseMapTest\n     public void testGlobalVisibilityForGetters()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         POJOPropertiesCollector coll = collector(m, SimpleGetterVisibility.class, true);\n         // should be 1, expect that we disabled getter auto-detection, so\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n     public void testJackson703() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        mapper.configure(MapperFeature.USE_ANNOTATIONS, false);\n         BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));\n         assertNotNull(beanDesc);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n     public void testEmptyCollection() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n         List<User>friends = new ArrayList<User>();\n         friends.add(new DefaultUser(\"Joe Hildebrandt\", null));\n         friends.add(new DefaultEmployee(\"Richard Nasr\",null,\"MDA\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestGenericListSerialization\n         embedded.add(new Child1());\n         embedded.add(new Child2());\n         input.setResult(embedded);\n-        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n     {\n         // First, with annotations\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);\n         String json = mapper.writeValueAsString(new EmptyBean());\n         assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n \n         mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = mapper.writeValueAsString(new EmptyBean());\n         assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n \n         // and then with defaults\n         mapper = new ObjectMapper();\n         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = mapper.writeValueAsString(new EmptyNonFinal());\n         assertEquals(\"[\\\"com.fasterxml.jackson.databind.jsontype.TestSubtypes$EmptyNonFinal\\\",{}]\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that types that serialize as JSON Arrays\n \n         // then with static typing enabled:\n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         assertEquals(EXP, m.writeValueAsString(input));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testEmptyBean() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         assertEquals(\"{\\\"@type\\\":\\\"empty\\\"}\", m.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         ObjectMapper om = new ObjectMapper();\n         om.enableDefaultTyping( ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY );\n         om.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-        om.enable( SerializationConfig.Feature.INDENT_OUTPUT);\n+        om.enable( SerializationFeature.INDENT_OUTPUT);\n \n         MyClass mc = new MyClass();\n \n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestMixinSerWithViews\n     extends BaseMapTest\n         ObjectMapper mapper = new ObjectMapper();\n         A a = new A(\"myname\", 29, \"mysurname\");\n \n-        // Property SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION set to false\n-        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n+        // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false\n+        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n         mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n     private ObjectMapper createObjectMapper( )\n     {\n       ObjectMapper objectMapper = new ObjectMapper( );\n-      objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+      objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false );\n       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-      objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+      objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n \n       Map<Class<?>, Class<?>> sourceMixins = new HashMap<Class<?>, Class<?>>( );\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n     {\n         MissingNode n = MissingNode.getInstance();\n         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());\n-        assertNull(n.asText());\n+        // as per [JACKSON-775]\n+        assertEquals(\"\", n.asText());\n         assertStandardEquals(n);\n         assertEquals(\"\", n.toString());\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite tries to verify that JsonNode-based trees\n+ * can be deserialized as expected.\n+ */\n+public class TestTreeDeserialization\n+    extends BaseMapTest\n+{\n+    final static class Bean {\n+        int _x;\n+        JsonNode _node;\n+\n+        public void setX(int x) { _x = x; }\n+        public void setNode(JsonNode n) { _node = n; }\n+    }\n+\n+    /**\n+     * This test checks that is possible to mix \"regular\" Java objects\n+     * and JsonNode.\n+     */\n+    public void testMixed() throws IOException\n+    {\n+        ObjectMapper om = new ObjectMapper();\n+        String JSON = \"{\\\"node\\\" : { \\\"a\\\" : 3 }, \\\"x\\\" : 9 }\";\n+        Bean bean = om.readValue(JSON, Bean.class);\n+\n+        assertEquals(9, bean._x);\n+        JsonNode n = bean._node;\n+        assertNotNull(n);\n+        assertEquals(1, n.size());\n+        ObjectNode on = (ObjectNode) n;\n+        assertEquals(3, on.get(\"a\").intValue());\n+    }\n+\n+    /// Verifying [JACKSON-143]\n+    public void testArrayNodeEquality()\n+    {\n+        ArrayNode n1 = new ArrayNode(null);\n+        ArrayNode n2 = new ArrayNode(null);\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+\n+        n1.add(TextNode.valueOf(\"Test\"));\n+\n+        assertFalse(n1.equals(n2));\n+        assertFalse(n2.equals(n1));\n+\n+        n2.add(TextNode.valueOf(\"Test\"));\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+    }\n+\n+    public void testObjectNodeEquality()\n+    {\n+        ObjectNode n1 = new ObjectNode(null);\n+        ObjectNode n2 = new ObjectNode(null);\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+\n+        n1.put(\"x\", TextNode.valueOf(\"Test\"));\n+\n+        assertFalse(n1.equals(n2));\n+        assertFalse(n2.equals(n1));\n+\n+        n2.put(\"x\", TextNode.valueOf(\"Test\"));\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperDeserializer.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tries to verify that ObjectMapper\n+ * can properly parse JSON and bind contents into appropriate\n+ * JsonNode instances.\n+ */\n+public class TestTreeMapperDeserializer\n+    extends BaseTest\n+{\n+\tpublic void testSimple()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (int type = 0; type < 2; ++type) {\n+            JsonNode result;\n+\n+            if (type == 0) {\n+                result = mapper.readTree(new StringReader(JSON));\n+            } else {\n+                result = mapper.readTree(JSON);\n+            }\n+\n+            assertType(result, ObjectNode.class);\n+            assertEquals(1, result.size());\n+            assertTrue(result.isObject());\n+            \n+            ObjectNode main = (ObjectNode) result;\n+            assertEquals(\"Image\", main.fieldNames().next());\n+            JsonNode ob = main.elements().next();\n+            assertType(ob, ObjectNode.class);\n+            ObjectNode imageMap = (ObjectNode) ob;\n+            \n+            assertEquals(5, imageMap.size());\n+            ob = imageMap.get(\"Width\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertFalse(ob.isFloatingPointNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.intValue());\n+            ob = imageMap.get(\"Height\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());\n+            \n+            ob = imageMap.get(\"Title\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());\n+            \n+            ob = imageMap.get(\"Thumbnail\");\n+            assertType(ob, ObjectNode.class);\n+            ObjectNode tn = (ObjectNode) ob;\n+            ob = tn.get(\"Url\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());\n+            ob = tn.get(\"Height\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());\n+            ob = tn.get(\"Width\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());\n+            \n+            ob = imageMap.get(\"IDs\");\n+            assertTrue(ob.isArray());\n+            ArrayNode idList = (ArrayNode) ob;\n+            assertEquals(4, idList.size());\n+            assertEquals(4, calcLength(idList.elements()));\n+            assertEquals(4, calcLength(idList.iterator()));\n+            {\n+                int[] values = new int[] {\n+                    SAMPLE_SPEC_VALUE_TN_ID1,\n+                    SAMPLE_SPEC_VALUE_TN_ID2,\n+                    SAMPLE_SPEC_VALUE_TN_ID3,\n+                    SAMPLE_SPEC_VALUE_TN_ID4\n+                };\n+                for (int i = 0; i < values.length; ++i) {\n+                    assertEquals(values[i], idList.get(i).intValue());\n+                }\n+                int i = 0;\n+                for (JsonNode n : idList) {\n+                    assertEquals(values[i], n.intValue());\n+                    ++i;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testBoolean()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(\"true\\n\");\n+        assertFalse(result.isNull());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isTextual());\n+        assertTrue(result.isBoolean());\n+        assertType(result, BooleanNode.class);\n+        assertTrue(result.booleanValue());\n+        assertEquals(\"true\", result.asText());\n+        assertFalse(result.isMissingNode());\n+\n+        // also, equality should work ok\n+        assertEquals(result, BooleanNode.valueOf(true));\n+        assertEquals(result, BooleanNode.getTrue());\n+    }\n+\n+    public void testDouble()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        double value = 3.04;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertFalse(result.isNull());\n+        assertType(result, DoubleNode.class);\n+        assertTrue(result.isFloatingPointNumber());\n+        assertTrue(result.isDouble());\n+        assertFalse(result.isInt());\n+        assertFalse(result.isLong());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.doubleValue());\n+        assertEquals(value, result.numberValue().doubleValue());\n+        assertEquals((int) value, result.intValue());\n+        assertEquals((long) value, result.longValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, DoubleNode.valueOf(value));\n+    }\n+\n+    public void testInt()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        int value = -90184;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isInt());\n+        assertType(result, IntNode.class);\n+        assertFalse(result.isLong());\n+        assertFalse(result.isFloatingPointNumber());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.numberValue().intValue());\n+        assertEquals(value, result.intValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+        assertEquals((double) value, result.doubleValue());\n+        assertEquals((long) value, result.longValue());\n+\n+        // also, equality should work ok\n+        assertEquals(result, IntNode.valueOf(value));\n+    }\n+\n+    public void testLong()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // need to use something being 32-bit value space\n+        long value = 12345678L << 32;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isLong());\n+        assertType(result, LongNode.class);\n+        assertFalse(result.isInt());\n+        assertFalse(result.isFloatingPointNumber());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.numberValue().longValue());\n+        assertEquals(value, result.longValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+        assertEquals((double) value, result.doubleValue());\n+\n+        // also, equality should work ok\n+        assertEquals(result, LongNode.valueOf(value));\n+    }\n+\n+    public void testNull()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(\"   null \");\n+        // should not get java null, but NullNode...\n+        assertNotNull(result);\n+        assertTrue(result.isNull());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isTextual());\n+        assertEquals(\"null\", result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, NullNode.instance);\n+    }\n+\n+    public void testDecimalNode()\n+        throws Exception\n+    {\n+        // no \"natural\" way to get it, must construct\n+        BigDecimal value = new BigDecimal(\"0.1\");\n+        JsonNode result = DecimalNode.valueOf(value);\n+\n+        assertFalse(result.isArray());\n+        assertFalse(result.isObject());\n+        assertTrue(result.isNumber());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isLong());\n+        assertType(result, DecimalNode.class);\n+        assertFalse(result.isInt());\n+        assertTrue(result.isFloatingPointNumber());\n+        assertTrue(result.isBigDecimal());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.numberValue());\n+        assertEquals(value.toString(), result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, DecimalNode.valueOf(value));\n+    }\n+\n+    public void testSimpleArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode result = mapper.createArrayNode();\n+\n+        assertTrue(result.isArray());\n+        assertType(result, ArrayNode.class);\n+\n+        assertFalse(result.isObject());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+\n+        // and let's add stuff...\n+        result.add(false);\n+        result.insertNull(0);\n+\n+        // should be equal to itself no matter what\n+        assertEquals(result, result);\n+        assertFalse(result.equals(null)); // but not to null\n+\n+        // plus see that we can access stuff\n+        assertEquals(NullNode.instance, result.path(0));\n+        assertEquals(NullNode.instance, result.get(0));\n+        assertEquals(BooleanNode.FALSE, result.path(1));\n+        assertEquals(BooleanNode.FALSE, result.get(1));\n+        assertEquals(2, result.size());\n+\n+        assertNull(result.get(-1));\n+        assertNull(result.get(2));\n+        JsonNode missing = result.path(2);\n+        assertTrue(missing.isMissingNode());\n+        assertTrue(result.path(-100).isMissingNode());\n+\n+        // then construct and compare\n+        ArrayNode array2 = mapper.createArrayNode();\n+        array2.addNull();\n+        array2.add(false);\n+        assertEquals(result, array2);\n+\n+        // plus remove entries\n+        JsonNode rm1 = array2.remove(0);\n+        assertEquals(NullNode.instance, rm1);\n+        assertEquals(1, array2.size());\n+        assertEquals(BooleanNode.FALSE, array2.get(0));\n+        assertFalse(result.equals(array2));\n+\n+        JsonNode rm2 = array2.remove(0);\n+        assertEquals(BooleanNode.FALSE, rm2);\n+        assertEquals(0, array2.size());\n+    }\n+\n+    /**\n+     * Type mappers should be able to gracefully deal with end of\n+     * input.\n+     */\n+    public void testEOF() throws Exception\n+    {\n+        String JSON =\n+            \"{ \\\"key\\\": [ { \\\"a\\\" : { \\\"name\\\": \\\"foo\\\",  \\\"type\\\": 1\\n\"\n+            +\"},  \\\"type\\\": 3, \\\"url\\\": \\\"http://www.google.com\\\" } ],\\n\"\n+            +\"\\\"name\\\": \\\"xyz\\\", \\\"type\\\": 1, \\\"url\\\" : null }\\n  \"\n+            ;\n+        JsonFactory jf = new JsonFactory();\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+        JsonNode result = mapper.readTree(jp);\n+\n+        assertTrue(result.isObject());\n+        assertEquals(4, result.size());\n+\n+        assertNull(mapper.readTree(jp));\n+    }\n+\n+    public void testMultiple() throws Exception\n+    {\n+        String JSON = \"12  \\\"string\\\" [ 1, 2, 3 ]\";\n+        JsonFactory jf = new JsonFactory();\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+        JsonNode result = mapper.readTree(jp);\n+\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isInt());\n+        assertFalse(result.isTextual());\n+        assertEquals(12, result.intValue());\n+\n+        result = mapper.readTree(jp);\n+        assertTrue(result.isTextual());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isInt());\n+        assertEquals(\"string\", result.textValue());\n+\n+        result = mapper.readTree(jp);\n+        assertTrue(result.isArray());\n+        assertEquals(3, result.size());\n+\n+        assertNull(mapper.readTree(jp));\n+    }\n+\n+    /**\n+     * Let's also verify behavior of \"MissingNode\" -- one needs to be able\n+     * to traverse such bogus nodes with appropriate methods.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public void testMissingNode()\n+        throws Exception\n+    {\n+        String JSON = \"[ { }, [ ] ]\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(new StringReader(JSON));\n+\n+        assertTrue(result.isContainerNode());\n+        assertTrue(result.isArray());\n+        assertEquals(2, result.size());\n+\n+        int count = 0;\n+        for (JsonNode node : result) {\n+            ++count;\n+        }\n+        assertEquals(2, count);\n+\n+        Iterator<JsonNode> it = result.iterator();\n+\n+        JsonNode onode = it.next();\n+        assertTrue(onode.isContainerNode());\n+        assertTrue(onode.isObject());\n+        assertEquals(0, onode.size());\n+        assertFalse(onode.isMissingNode()); // real node\n+        assertNull(onode.textValue());\n+\n+        // how about dereferencing?\n+        assertNull(onode.get(0));\n+        JsonNode dummyNode = onode.path(0);\n+        assertNotNull(dummyNode);\n+        assertTrue(dummyNode.isMissingNode());\n+        assertNull(dummyNode.get(3));\n+        assertNull(dummyNode.get(\"whatever\"));\n+        JsonNode dummyNode2 = dummyNode.path(98);\n+        assertNotNull(dummyNode2);\n+        assertTrue(dummyNode2.isMissingNode());\n+        JsonNode dummyNode3 = dummyNode.path(\"field\");\n+        assertNotNull(dummyNode3);\n+        assertTrue(dummyNode3.isMissingNode());\n+\n+        // and same for the array node\n+\n+        JsonNode anode = it.next();\n+        assertTrue(anode.isContainerNode());\n+        assertTrue(anode.isArray());\n+        assertFalse(anode.isMissingNode()); // real node\n+        assertEquals(0, anode.size());\n+\n+        assertNull(anode.get(0));\n+        dummyNode = anode.path(0);\n+        assertNotNull(dummyNode);\n+        assertTrue(dummyNode.isMissingNode());\n+        assertNull(dummyNode.get(0));\n+        assertNull(dummyNode.get(\"myfield\"));\n+        dummyNode2 = dummyNode.path(98);\n+        assertNotNull(dummyNode2);\n+        assertTrue(dummyNode2.isMissingNode());\n+        dummyNode3 = dummyNode.path(\"f\");\n+        assertNotNull(dummyNode3);\n+        assertTrue(dummyNode3.isMissingNode());\n+    }\n+\n+    public void testArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final String JSON = \"[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]\";\n+\n+        JsonNode n = mapper.readTree(JSON);\n+        assertNotNull(n);\n+        assertTrue(n.isArray());\n+        ArrayNode an = (ArrayNode) n;\n+        assertEquals(1, an.size());\n+        ArrayNode an2 = (ArrayNode) n.get(0);\n+        assertTrue(an2.isArray());\n+        assertEquals(4, an2.size());\n+    }\n+    \n+    /*\n+    /**********************************************\n+    /* Helper methods\n+    /**********************************************\n+     */\n+\n+    private int calcLength(Iterator<JsonNode> it)\n+    {\n+        int count = 0;\n+        while (it.hasNext()) {\n+            it.next();\n+            ++count;\n+        }\n+        return count;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperMaps.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests to verify that Json Objects map property to Map-like\n+ * ObjectNodes.\n+ */\n+public class TestTreeMapperMaps\n+    extends BaseTest\n+{\n+    public void testSimpleObject() throws Exception\n+    {\n+        String JSON = \"{ \\\"key\\\" : 1, \\\"b\\\" : \\\"x\\\" }\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode root = mapper.readTree(JSON);\n+\n+        // basic properties first:\n+        assertFalse(root.isValueNode());\n+        assertTrue(root.isContainerNode());\n+        assertFalse(root.isArray());\n+        assertTrue(root.isObject());\n+        assertEquals(2, root.size());\n+\n+        // Related to [JACKSON-50]:\n+        Iterator<JsonNode> it = root.iterator();\n+        assertNotNull(it);\n+        assertTrue(it.hasNext());\n+        JsonNode n = it.next();\n+        assertNotNull(n);\n+        assertEquals(IntNode.valueOf(1), n);\n+\n+        assertTrue(it.hasNext());\n+        n = it.next();\n+        assertNotNull(n);\n+        assertEquals(TextNode.valueOf(\"x\"), n);\n+\n+        assertFalse(it.hasNext());\n+\n+        // Ok, then, let's traverse via extended interface\n+        ObjectNode obNode = (ObjectNode) root;\n+        Iterator<Map.Entry<String,JsonNode>> fit = obNode.fields();\n+        // we also know that LinkedHashMap is used, i.e. order preserved\n+        assertTrue(fit.hasNext());\n+        Map.Entry<String,JsonNode> en = fit.next();\n+        assertEquals(\"key\", en.getKey());\n+        assertEquals(IntNode.valueOf(1), en.getValue());\n+\n+        assertTrue(fit.hasNext());\n+        en = fit.next();\n+        assertEquals(\"b\", en.getKey());\n+        assertEquals(TextNode.valueOf(\"x\"), en.getValue());\n+\n+        // Plus: we should be able to modify the node via iterator too:\n+        fit.remove();\n+        assertEquals(1, obNode.size());\n+        assertEquals(IntNode.valueOf(1), root.get(\"key\"));\n+        assertNull(root.get(\"b\"));\n+    }\n+\n+    public void testSimplePath() throws Exception\n+    {\n+        JsonNode root = new ObjectMapper().readTree(\"{ \\\"results\\\" : { \\\"a\\\" : 3 } }\");\n+        assertTrue(root.isObject());\n+        JsonNode rnode = root.path(\"results\");\n+        assertNotNull(rnode);\n+        assertTrue(rnode.isObject());\n+        assertEquals(3, rnode.path(\"a\").intValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperSerializer.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tries to verify that the trees ObjectMapper\n+ * constructs can be serialized properly.\n+ */\n+public class TestTreeMapperSerializer\n+    extends BaseTest\n+{\n+    final static String FIELD1 = \"first\";\n+    final static String FIELD2 = \"Second?\";\n+    final static String FIELD3 = \"foo'n \\\"bar\\\"\";\n+    final static String FIELD4 = \"4\";\n+\n+    final static String TEXT1 = \"Some text & \\\"stuff\\\"\";\n+    final static String TEXT2 = \"Some more text:\\twith\\nlinefeeds and all!\";\n+\n+    final static double DOUBLE_VALUE = 9.25;\n+\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode root = mapper.createArrayNode();\n+        root.add(TEXT1);\n+        root.add(3);\n+        ObjectNode obj = root.addObject();\n+        obj.put(FIELD1, true);\n+        obj.putArray(FIELD2);\n+        root.add(false);\n+\n+        /* Ok, ready... let's serialize using one of two alternate\n+         * methods: first preferred (using generator)\n+         * (there are 2 variants here too)\n+         */\n+        for (int i = 0; i < 2; ++i) {\n+            StringWriter sw = new StringWriter();\n+            if (i == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            verifyFromArray(sw.toString());\n+        }\n+            \n+        // And then convenient but less efficient alternative:\n+        verifyFromArray(root.toString());\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode root = mapper.createObjectNode();\n+        root.put(FIELD4, TEXT2);\n+        root.put(FIELD3, -1);\n+        root.putArray(FIELD2);\n+        root.put(FIELD1, DOUBLE_VALUE);\n+\n+        /* Let's serialize using one of two alternate methods:\n+         * first preferred (using generator)\n+         * (there are 2 variants here too)\n+         */\n+        for (int i = 0; i < 2; ++i) {\n+            StringWriter sw = new StringWriter();\n+            if (i == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            verifyFromMap(sw.toString());\n+        }\n+\n+        // And then convenient but less efficient alternative:\n+        verifyFromMap(root.toString());\n+    }\n+\n+    /**\n+     * Unit test to check for regression of [JACKSON-18].\n+     */\n+    public void testSmallNumbers()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode root = mapper.createArrayNode();\n+        for (int i = -20; i <= 20; ++i) {\n+            JsonNode n = root.numberNode(i);\n+            root.add(n);\n+            // Hmmh. Not sure why toString() won't be triggered otherwise...\n+            assertEquals(String.valueOf(i), n.toString());\n+        }\n+\n+        // Loop over 2 different serialization methods\n+        for (int type = 0; type < 2; ++type) {\n+            StringWriter sw = new StringWriter();\n+            if (type == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            \n+            String doc = sw.toString();\n+            JsonParser jp = new JsonFactory().createJsonParser(new StringReader(doc));\n+            \n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = -20; i <= 20; ++i) {\n+                assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+                assertEquals(\"\"+i, jp.getText());\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, NullNode.instance);\n+        assertEquals(\"null\", sw.toString());\n+    }\n+\n+    public void testBinary()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LENGTH = 13045;\n+        byte[] data = new byte[LENGTH];\n+        for (int i = 0; i < LENGTH; ++i) {\n+            data[i] = (byte) i;\n+        }\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, BinaryNode.valueOf(data));\n+\n+        JsonParser jp = new JsonFactory().createJsonParser(sw.toString());\n+        // note: can't determine it's binary from json alone:\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertArrayEquals(data, jp.getBinaryValue());\n+        jp.close();\n+    }\n+\n+    /*\n+    ///////////////////////////////////////////////////////////////\n+    // Internal methods\n+    ///////////////////////////////////////////////////////////////\n+     */\n+\n+    private void verifyFromArray(String input)\n+        throws Exception\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(new StringReader(input));\n+        \n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(TEXT1, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(3, jp.getIntValue());\n+        \n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD1, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD2, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+        \n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+\n+    private void verifyFromMap(String input)\n+        throws Exception\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(new StringReader(input));\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD4, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(TEXT2, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD3, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-1, jp.getIntValue());\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD2, getAndVerifyText(jp));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD1, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertEquals(DOUBLE_VALUE, jp.getDoubleValue());\n+        \n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertNull(jp.nextToken());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationAnyGetter.java\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n \n public class TestAnnotationAnyGetter\n     extends BaseMapTest\n \n         // First, with normal fail settings:\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);\n         String json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n \n         // then without fail\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of @JsonClass Annotation\n     public void testStaticTypingWithMap() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueMap map = new ValueMap();\n         map.put(\"a\", new ValueClass());\n         assertEquals(\"{\\\"a\\\":{\\\"x\\\":3}}\", serializeAsString(m, map));\n     public void testStaticTypingWithArrayList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueList list = new ValueList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", m.writeValueAsString(list));\n     public void testStaticTypingWithLinkedList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueLinkedList list = new ValueLinkedList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, list));\n     public void testStaticTypingWithArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueInterface[] array = new ValueInterface[] { new ValueClass() };\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, array));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n \n /**\n \n         // then static\n         ObjectMapper staticMapper = new ObjectMapper();\n-        staticMapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        staticMapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", staticMapper.writeValueAsString(new ValueWrapper()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of Annotations for\n         public int getZ() { return 3; }\n     }\n \n-    // For [JACKSON-666] (\"Feature of the Beast!\")\n+    // For [JACKSON-666] (\"SerializationFeature of the Beast!\")\n     @JsonPropertyOrder(alphabetic=true)\n     static class GettersWithoutSetters\n     {\n     {\n         ObjectMapper m = new ObjectMapper();\n         GettersWithoutSetters bean = new GettersWithoutSetters(123);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS));\n+        assertFalse(m.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS));\n     \n         // by default, all 4 found:\n         assertEquals(\"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n \n         // but 3 if we require mutator:\n         m = new ObjectMapper();\n-        m.enable(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS);\n+        m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS);\n         assertEquals(\"{\\\"a\\\":3,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n         EmptyListBean list = new EmptyListBean();\n         EmptyArrayBean array = new EmptyArrayBean();\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS));\n+        assertTrue(m.getSerializationConfig().isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n         assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(list));\n         assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(array));\n \n         // note: value of setting may be cached when constructing serializer, need a new instance\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS, false);\n+        m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);\n         assertEquals(\"{}\", m.writeValueAsString(list));\n         assertEquals(\"{}\", m.writeValueAsString(array));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n /**\n         SerializationConfig cfg = m.getSerializationConfig();\n \n         // First, defaults:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+        assertTrue(cfg.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n \n-        assertFalse(cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT));\n-        assertFalse(cfg.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING));\n+        assertFalse(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT));\n+        assertFalse(cfg.isEnabled(MapperFeature.USE_STATIC_TYPING));\n \n         // since 1.3:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS));\n         // since 1.4\n         \n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n+        assertTrue(cfg.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));\n         // since 1.5\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION));\n+        assertTrue(cfg.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION));\n \n     }\n \n     public void testIndentation() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        m.configure(SerializationFeature.INDENT_OUTPUT, true);\n         Map<String,Integer> map = new HashMap<String,Integer>();\n         map.put(\"a\", Integer.valueOf(2));\n         String result = serializeAsString(m, map).trim();\n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.isEnabled(MapperFeature.USE_ANNOTATIONS));\n         Map<String,Object> result = writeAndMap(m, new AnnoBean());\n         assertEquals(2, result.size());\n \n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n         result = writeAndMap(m, new AnnoBean());\n         assertEquals(1, result.size());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         // default is to output time stamps...\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n         // shouldn't matter which offset we give...\n         mapper.writeValue(sw, new Date(199L));\n         assertEquals(\"199\", sw.toString());\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // let's hit epoch start\n         mapper.writeValue(sw, new Date(0L));\n         assertEquals(\"\\\"1970-01-01T00:00:00.000+0000\\\"\", sw.toString());\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         Map<Date,Integer> map = new HashMap<Date,Integer>();\n-        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS));\n+        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS));\n         map.put(new Date(0L), Integer.valueOf(1));\n         // by default will serialize as ISO-8601 values...\n         assertEquals(\"{\\\"1970-01-01T00:00:00.000+0000\\\":1}\", mapper.writeValueAsString(map));\n         \n         // but can change to use timestamps too\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n+        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n         assertEquals(\"{\\\"0\\\":1}\", mapper.writeValueAsString(map));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n     public void testEmptyWithFeature() throws Exception\n     {\n         // should be enabled by default\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n     public void testToStringEnum() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);\n         assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(LowerCaseEnum.B));\n     }\n \n     public void testToStringEnumWithEnumMap() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);\n         EnumMap<LowerCaseEnum,String> m = new EnumMap<LowerCaseEnum,String>(LowerCaseEnum.class);\n         m.put(LowerCaseEnum.C, \"value\");\n         assertEquals(\"{\\\"c\\\":\\\"value\\\"}\", mapper.writeValueAsString(m));\n     {\n         // By default, serialize using name\n         ObjectMapper mapper = new ObjectMapper();\n-        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX));\n+        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX));\n         assertEquals(quote(\"B\"), mapper.writeValueAsString(TestEnum.B));\n \n         // but we can change (dynamically, too!) it to be number-based\n-        mapper.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        mapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n         assertEquals(\"1\", mapper.writeValueAsString(TestEnum.B));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for checking whether JsonSerializerFactory.Feature\n         // Then auto-detection disabled. But note: we MUST create a new\n         // mapper, since old version of serializer may be cached by now\n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new GetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"x\"));\n         assertTrue(result.containsKey(\"x\"));\n \n         // And then class-level auto-detection enabling, should override defaults\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new EnabledGetterClass());\n         assertEquals(2, result.size());\n         assertTrue(result.containsKey(\"x\"));\n     {\n         ObjectMapper m = new ObjectMapper();\n         // class level should override\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, true);\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, true);\n+        m.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n          Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"ok\"));\n     public void testConfigChainability()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_SETTERS, false)\n-            .configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n+        m.configure(MapperFeature.AUTO_DETECT_SETTERS, false)\n+            .configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n+        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n     }\n \n     // Test for [JACKSON-282]\n         assertFalse(bean.wasClosed);\n \n         // but can enable it:\n-        m.configure(SerializationConfig.Feature.CLOSE_CLOSEABLE, true);\n+        m.configure(SerializationFeature.CLOSE_CLOSEABLE, true);\n         bean = new CloseableBean();\n         m.writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n         assertEquals(quote(\"abc\"), m.writeValueAsString(chars));\n         \n         // new feature: serialize as JSON array:\n-        m.configure(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);\n+        m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);\n         assertEquals(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", m.writeValueAsString(chars));\n     }\n \n     public void testFlushingAutomatic() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE));\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE));\n         // default is to flush after writeValue()\n         StringWriter sw = new StringWriter();\n         JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n     {\n         // but should not occur if configured otherwise\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE, false);\n+        mapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false);\n         StringWriter sw = new StringWriter();\n         JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n         // by default, should output null-valued entries:\n         assertEquals(\"{\\\"a\\\":null}\", m.writeValueAsString(map));\n         // but not if explicitly asked not to (note: config value is dynamic here)\n-        m.configure(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES, false);\n+        m.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);\n         assertEquals(\"{}\", m.writeValueAsString(map));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n public class TestNullSerialization\n     extends BaseMapTest\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.annotation.*;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         // must force static typing, otherwise won't matter a lot\n-        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n         String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n     public void testRootWrapping() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n         String json = mapper.writeValueAsString(new StringWrapper(\"abc\"));\n         assertEquals(\"{\\\"StringWrapper\\\":{\\\"str\\\":\\\"abc\\\"}}\", json);\n     }\n     public void testRootNameAnnotation() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n         String json = mapper.writeValueAsString(new WithRootName());\n         assertEquals(\"{\\\"root\\\":{\\\"a\\\":3}}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that constraints on ordering of serialized\n     public void testOrderWithFeature() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY, true);\n+        m.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);\n         assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanFor459()));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n \n public class TestSerializerProvider\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n import com.fasterxml.jackson.annotation.JsonView;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViewDeserialization extends BaseMapTest\n {\n         assertEquals(9, bean.b);\n \n         ObjectMapper myMapper = new ObjectMapper();\n-        myMapper.disable(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        myMapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);\n \n         // but with, say, AA, will not get 'b'\n         bean = myMapper.readerWithView(ViewAA.class)\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying JSON view functionality: ability to declaratively\n \n         // but can also change (but not necessarily on the fly...)\n         mapper = new ObjectMapper();\n-        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false);\n+        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false);\n         // with this setting, only explicit inclusions count:\n         String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean);\n         map = mapper.readValue(json, Map.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewsSerialization2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewsSerialization2.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViewsSerialization2 extends BaseMapTest\n {\n   private ObjectMapper createObjectMapper(Class<?> viewClass)\n   {\n     ObjectMapper objectMapper = new ObjectMapper( );\n-    objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+    objectMapper.configure( SerializationFeature.FAIL_ON_EMPTY_BEANS, false );\n     objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-    objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n-//    objectMapper.getSerializationConfig( ).disable( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION );\n+    objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n+//    objectMapper.getSerializationConfig( ).disable( SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION );\n //    objectMapper.getSerializationConfig( ).setSerializationView( viewClass );\n     return objectMapper;\n   }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n     public abstract JsonNode path(int index);\n \n     /**\n-     * Method that can be called on object nodes, to access a property\n-     * that has object value; or if no such property exists, to create and\n-     * return such object node.\n-     * If node method is called on is not Object node,\n-     * or if property exists and has value that is not object node,\n+     * Method that can be called on Object nodes, to access a property\n+     * that has Object value; or if no such property exists, to create,\n+     * add and return such Object node.\n+     * If the node method is called on is not Object node,\n+     * or if property exists and has value that is not Object node,\n      * {@link UnsupportedOperationException} is thrown\n      */\n     public JsonNode with(String propertyName) {\n                 +getClass().getName()+\"), can not call with() on it\");\n     }\n \n+    /**\n+     * Method that can be called on Object nodes, to access a property\n+     * that has <code>Array</code> value; or if no such property exists, to create,\n+     * add and return such Array node.\n+     * If the node method is called on is not Object node,\n+     * or if property exists and has value that is not Array node,\n+     * {@link UnsupportedOperationException} is thrown\n+     */\n+    public JsonNode withArray(String propertyName) {\n+        throw new UnsupportedOperationException(\"JsonNode not of type ObjectNode (but \"\n+                +getClass().getName()+\"), can not call withArray() on it\");\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API: converting to/from Streaming API\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n             }\n         }\n         ObjectNode result = objectNode();\n+        _children.put(propertyName, result);\n+        return result;\n+    }\n+\n+    @Override\n+    public ArrayNode withArray(String propertyName)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>();\n+        } else {\n+            JsonNode n = _children.get(propertyName);\n+            if (n != null) {\n+                if (n instanceof ArrayNode) {\n+                    return (ArrayNode) n;\n+                }\n+                throw new UnsupportedOperationException(\"Property '\"+propertyName\n+                        +\"' has value that is not of type ArrayNode (but \"\n+                        +n.getClass().getName()+\")\");\n+            }\n+        }\n+        ArrayNode result = arrayNode();\n         _children.put(propertyName, result);\n         return result;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n         assertEquals(\"{\\\"prop\\\":{}}\", mapper.writeValueAsString(root));\n     }\n \n+    public void testValidWithArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode root = mapper.createObjectNode();\n+        assertEquals(\"{}\", mapper.writeValueAsString(root));\n+        JsonNode child = root.withArray(\"arr\");\n+        assertTrue(child instanceof ArrayNode);\n+        assertEquals(\"{\\\"arr\\\":[]}\", mapper.writeValueAsString(root));\n+    }\n+\n     public void testInvalidWith() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n             verifyException(e, \"has value that is not\");\n         }\n     }\n+\n+    public void testInvalidWithArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode root = mapper.createArrayNode();\n+        try { // should not work for non-ObjectNode nodes:\n+            root.withArray(\"prop\");\n+            fail(\"Expected exception\");\n+        } catch (UnsupportedOperationException e) {\n+            verifyException(e, \"not of type ObjectNode\");\n+        }\n+        // also: should fail of we already have non-Array property\n+        ObjectNode root2 = mapper.createObjectNode();\n+        root2.put(\"prop\", 13);\n+        try { // should not work for non-ObjectNode nodes:\n+            root2.withArray(\"prop\");\n+            fail(\"Expected exception\");\n+        } catch (UnsupportedOperationException e) {\n+            verifyException(e, \"has value that is not\");\n+        }\n+    }\n }", "timestamp": 1328245855, "metainfo": ""}