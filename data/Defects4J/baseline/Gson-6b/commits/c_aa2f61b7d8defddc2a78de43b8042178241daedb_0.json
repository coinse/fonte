{"sha": "aa2f61b7d8defddc2a78de43b8042178241daedb", "log": "Rename GsonExclusionStrategy to Excluder. The new class is its own factory, which simplifies its caller in GsonBuilder. It no longer implements ExclusionStrategy, which allows the callers to pass in a boolean for serialize/deserialize. This allows us to use one excluder for both code paths. The delegate ExclusionStrategy instances might end up not being shared so it has two lists internally.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n+import com.google.gson.internal.$Gson$Preconditions;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Collections;\n \n /**\n  * A data object that stores attributes of a field.\n  * @since 1.4\n  */\n public final class FieldAttributes {\n-  private static final String MAX_CACHE_PROPERTY_NAME =\n-      \"com.google.gson.annotation_cache_size_hint\";\n-\n-  private static final LruCache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE\n-      = new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n-\n-  private final Class<?> declaringClazz;\n   private final Field field;\n-  private final Class<?> declaredType;\n-  private final boolean isSynthetic;\n-  private final int modifiers;\n-  private final String name;\n-\n-  // Fields used for lazy initialization\n-  private Type genericType;\n-  private Collection<Annotation> annotations;\n \n   /**\n    * Constructs a Field Attributes object from the {@code f}.\n    * @param f the field to pull attributes from\n    */\n   public FieldAttributes(Field f) {\n-    this.declaringClazz = f.getDeclaringClass();\n-    this.name = f.getName();\n-    this.declaredType = f.getType();\n-    this.isSynthetic = f.isSynthetic();\n-    this.modifiers = f.getModifiers();\n+    $Gson$Preconditions.checkNotNull(f);\n     this.field = f;\n-  }\n-\n-  private static int getMaxCacheSize() {\n-    final int defaultMaxCacheSize = 2000;\n-    try {\n-      String propertyValue = System.getProperty(\n-          MAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize));\n-      return Integer.parseInt(propertyValue);\n-    } catch (NumberFormatException e) {\n-      return defaultMaxCacheSize;\n-    }\n   }\n \n   /**\n    * @return the declaring class that contains this field\n    */\n   public Class<?> getDeclaringClass() {\n-    return declaringClazz;\n+    return field.getDeclaringClass();\n   }\n \n   /**\n    * @return the name of the field\n    */\n   public String getName() {\n-    return name;\n+    return field.getName();\n   }\n \n   /**\n    * @return the specific type declared for this field\n    */\n   public Type getDeclaredType() {\n-    if (genericType == null) {\n-      genericType = field.getGenericType();\n-    }\n-    return genericType;\n+    return field.getGenericType();\n   }\n \n   /**\n    * @return the specific class object that was declared for the field\n    */\n   public Class<?> getDeclaredClass() {\n-    return declaredType;\n+    return field.getType();\n   }\n \n   /**\n    * @return the annotation instance if it is bound to the field; otherwise {@code null}\n    */\n   public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n-    return getAnnotationFromArray(getAnnotations(), annotation);\n+    return field.getAnnotation(annotation);\n   }\n \n   /**\n    * @since 1.4\n    */\n   public Collection<Annotation> getAnnotations() {\n-    if (annotations == null) {\n-      Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name);\n-      Collection<Annotation> cachedValue = ANNOTATION_CACHE.get(key);\n-      if (cachedValue == null) {\n-        cachedValue = Collections.unmodifiableCollection(\n-            Arrays.asList(field.getAnnotations()));\n-        ANNOTATION_CACHE.put(key, cachedValue);\n-      }\n-      annotations = cachedValue;\n-    }\n-    return annotations;\n+    return Arrays.asList(field.getAnnotations());\n   }\n \n   /**\n    * @see java.lang.reflect.Modifier\n    */\n   public boolean hasModifier(int modifier) {\n-    return (modifiers & modifier) != 0;\n+    return (field.getModifiers() & modifier) != 0;\n   }\n \n   /**\n    * @return true if the field is synthetic; otherwise false\n    */\n   boolean isSynthetic() {\n-    return isSynthetic;\n+    return field.isSynthetic();\n   }\n \n   @SuppressWarnings(\"unchecked\")\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n package com.google.gson;\n \n import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.Excluder;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n-import com.google.gson.internal.bind.ExcludedTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonElementReader;\n import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n-import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n   static final TypeMap EMPTY_MAP = new TypeMap().makeUnmodifiable();\n \n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n-\n-  private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY = new GsonExclusionStrategy(\n-      GsonExclusionStrategy.IGNORE_VERSIONS, Modifier.TRANSIENT | Modifier.STATIC,\n-      true, true, true, false, false);\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n    */\n   @SuppressWarnings(\"unchecked\")\n   public Gson() {\n-    this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, FieldNamingPolicy.IDENTITY,\n+    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n         EMPTY_MAP, false, EMPTY_MAP, EMPTY_MAP, false, DEFAULT_JSON_NON_EXECUTABLE, true,\n         false, false, LongSerializationPolicy.DEFAULT,\n         Collections.<TypeAdapter.Factory>emptyList());\n   }\n \n-  Gson(final ExclusionStrategy deserializationExclusionStrategy,\n-      final ExclusionStrategy serializationExclusionStrategy,\n-      final FieldNamingStrategy fieldNamingPolicy,\n+  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n       final TypeMap<InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n       final TypeMap<JsonSerializer<?>> serializers,\n       final TypeMap<JsonDeserializer<?>> deserializers,\n     this.prettyPrinting = prettyPrinting;\n \n     TypeAdapter.Factory reflectiveTypeAdapterFactory = new ReflectiveTypeAdapterFactory(\n-        constructorConstructor, fieldNamingPolicy, serializationExclusionStrategy,\n-        deserializationExclusionStrategy);\n+        constructorConstructor, fieldNamingPolicy, excluder);\n \n     ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n             doubleAdapter(serializeSpecialFloatingPointValues)));\n     factories.add(TypeAdapters.newFactory(float.class, Float.class,\n             floatAdapter(serializeSpecialFloatingPointValues)));\n-    factories.add(new ExcludedTypeAdapterFactory(\n-            serializationExclusionStrategy, deserializationExclusionStrategy));\n+    factories.add(excluder);\n     factories.add(TypeAdapters.NUMBER_FACTORY);\n     factories.add(TypeAdapters.CHARACTER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.Excluder;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n-import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n  * @author Joel Leitch\n  */\n public final class GsonBuilder {\n-  private ExclusionStrategy serializeExclusionStrategy;\n-  private ExclusionStrategy deserializeExclusionStrategy;\n-  private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\n-  private double ignoreVersionsAfter = GsonExclusionStrategy.IGNORE_VERSIONS;\n-  private boolean serializeInnerClasses = true;\n-  private boolean excludeFieldsWithoutExposeAnnotation = false;\n+  private Excluder excluder = Excluder.DEFAULT;\n \n   private LongSerializationPolicy longSerializationPolicy;\n   private FieldNamingStrategy fieldNamingPolicy;\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder setVersion(double ignoreVersionsAfter) {\n-    this.ignoreVersionsAfter = ignoreVersionsAfter;\n+    excluder = excluder.withVersion(ignoreVersionsAfter);\n     return this;\n   }\n \n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n-    this.modifiers = 0;\n-    for (int modifier : modifiers) {\n-      this.modifiers |= modifier;\n-    }\n+    excluder = excluder.withModifiers(modifiers);\n     return this;\n   }\n \n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder excludeFieldsWithoutExposeAnnotation() {\n-    excludeFieldsWithoutExposeAnnotation = true;\n+    excluder = excluder.excludeFieldsWithoutExposeAnnotation();\n     return this;\n   }\n \n    * @since 1.3\n    */\n   public GsonBuilder disableInnerClassSerialization() {\n-    serializeInnerClasses = false;\n+    excluder = excluder.disableInnerClassSerialization();\n     return this;\n   }\n \n    */\n   public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\n     for (ExclusionStrategy strategy : strategies) {\n-      addSerializationExclusionStrategy(strategy);\n-      addDeserializationExclusionStrategy(strategy);\n+      excluder = excluder.withExclusionStrategy(strategy, true, true);\n     }\n     return this;\n   }\n    * @since 1.7\n    */\n   public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\n-    serializeExclusionStrategy = combine(serializeExclusionStrategy, strategy);\n+    excluder = excluder.withExclusionStrategy(strategy, true, false);\n     return this;\n   }\n \n    * @since 1.7\n    */\n   public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\n-    deserializeExclusionStrategy = combine(deserializeExclusionStrategy, strategy);\n+    excluder = excluder.withExclusionStrategy(strategy, false, true);\n     return this;\n   }\n \n   }\n \n   /**\n-   * Unions two exclusion strategies. If the first is null, this returns the\n-   * second.\n-   */\n-  private static ExclusionStrategy combine(final ExclusionStrategy a, final ExclusionStrategy b) {\n-    if (b == null) {\n-      throw new IllegalArgumentException();\n-    }\n-    if (a == null) {\n-      return b;\n-    }\n-    return new ExclusionStrategy() {\n-      public boolean shouldSkipField(FieldAttributes f) {\n-        return a.shouldSkipField(f) || b.shouldSkipField(f);\n-      }\n-      public boolean shouldSkipClass(Class<?> clazz) {\n-        return a.shouldSkipClass(clazz) || b.shouldSkipClass(clazz);\n-      }\n-    };\n-  }\n-\n-  /**\n    * Creates a {@link Gson} instance based on the current configuration. This method is free of\n    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n    *\n   public Gson create() {\n     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers);\n \n-    ExclusionStrategy deserializeExclusionStrategy = combine(this.deserializeExclusionStrategy,\n-        new GsonExclusionStrategy(ignoreVersionsAfter, modifiers, true,\n-        true, serializeInnerClasses, false, excludeFieldsWithoutExposeAnnotation));\n-    ExclusionStrategy serializeExclusionStrategy = combine(this.serializeExclusionStrategy,\n-        new GsonExclusionStrategy(ignoreVersionsAfter, modifiers, true, true,\n-            serializeInnerClasses, excludeFieldsWithoutExposeAnnotation, false));\n-\n-    return new Gson(deserializeExclusionStrategy, serializeExclusionStrategy, fieldNamingPolicy,\n-        instanceCreators.copyOf().makeUnmodifiable(), serializeNulls,\n-        serializers.copyOf().makeUnmodifiable(), deserializers.copyOf().makeUnmodifiable(),\n-        complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n+    return new Gson(excluder, fieldNamingPolicy, instanceCreators.copyOf().makeUnmodifiable(),\n+        serializeNulls, serializers.copyOf().makeUnmodifiable(),\n+        deserializers.copyOf().makeUnmodifiable(), complexMapKeySerialization,\n+        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n         serializeSpecialFloatingPointValues, longSerializationPolicy, typeAdapterFactories);\n   }\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.ExclusionStrategy;\n+import com.google.gson.FieldAttributes;\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.Since;\n+import com.google.gson.annotations.Until;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class selects which fields and types to omit. It is configurable,\n+ * supporting version attributes {@link Since} and {@link Until}, modifiers,\n+ * synthetic fields, anonymous and local classes, inner classes, and fields with\n+ * the {@link Expose} annotation.\n+ *\n+ * <p>This class is a type adapter factory; types that are excluded will be\n+ * adapted to null. It may delegate to another type adapter if only one\n+ * direction is excluded.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+public final class Excluder implements TypeAdapter.Factory, Cloneable {\n+  private static final double IGNORE_VERSIONS = -1.0d;\n+  public static final Excluder DEFAULT = new Excluder();\n+\n+  private double version = IGNORE_VERSIONS;\n+  private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\n+  private boolean serializeInnerClasses = true;\n+  private boolean requireExpose;\n+  private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\n+  private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n+\n+  @Override protected Excluder clone() {\n+    try {\n+      return (Excluder) super.clone();\n+    } catch (CloneNotSupportedException e) {\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  public Excluder withVersion(double ignoreVersionsAfter) {\n+    Excluder result = clone();\n+    result.version = ignoreVersionsAfter;\n+    return result;\n+  }\n+\n+  public Excluder withModifiers(int... modifiers) {\n+    Excluder result = clone();\n+    result.modifiers = 0;\n+    for (int modifier : modifiers) {\n+      result.modifiers |= modifier;\n+    }\n+    return result;\n+  }\n+\n+  public Excluder disableInnerClassSerialization() {\n+    Excluder result = clone();\n+    result.serializeInnerClasses = false;\n+    return result;\n+  }\n+\n+  public Excluder excludeFieldsWithoutExposeAnnotation() {\n+    Excluder result = clone();\n+    result.requireExpose = true;\n+    return result;\n+  }\n+\n+  public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,\n+      boolean serialization, boolean deserialization) {\n+    Excluder result = clone();\n+    if (serialization) {\n+      result.serializationStrategies = new ArrayList<ExclusionStrategy>(serializationStrategies);\n+      result.serializationStrategies.add(exclusionStrategy);\n+    }\n+    if (deserialization) {\n+      result.deserializationStrategies\n+          = new ArrayList<ExclusionStrategy>(deserializationStrategies);\n+      result.deserializationStrategies.add(exclusionStrategy);\n+    }\n+    return result;\n+  }\n+\n+  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> type) {\n+    Class<?> rawType = type.getRawType();\n+    final boolean skipSerialize = excludeClass(rawType, true);\n+    final boolean skipDeserialize = excludeClass(rawType, false);\n+\n+    if (!skipSerialize && !skipDeserialize) {\n+      return null;\n+    }\n+\n+    return new TypeAdapter<T>() {\n+      /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n+      private TypeAdapter<T> delegate;\n+\n+      @Override public T read(JsonReader reader) throws IOException {\n+        if (skipDeserialize) {\n+          reader.skipValue();\n+          return null;\n+        }\n+        return delegate().read(reader);\n+      }\n+\n+      @Override public void write(JsonWriter writer, T value) throws IOException {\n+        if (skipSerialize) {\n+          writer.nullValue();\n+          return;\n+        }\n+        delegate().write(writer, value);\n+      }\n+\n+      private TypeAdapter<T> delegate() {\n+        TypeAdapter<T> d = delegate;\n+        return d != null\n+            ? d\n+            : (delegate = context.getNextAdapter(Excluder.this, type));\n+      }\n+    };\n+  }\n+\n+  public boolean excludeField(Field field, boolean serialize) {\n+    if ((modifiers & field.getModifiers()) != 0) {\n+      return true;\n+    }\n+\n+    if (version != Excluder.IGNORE_VERSIONS\n+        && !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\n+      return true;\n+    }\n+\n+    if (field.isSynthetic()) {\n+      return true;\n+    }\n+\n+    if (requireExpose) {\n+      Expose annotation = field.getAnnotation(Expose.class);\n+      if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\n+        return true;\n+      }\n+    }\n+\n+    if (!serializeInnerClasses && isInnerClass(field.getType())) {\n+      return true;\n+    }\n+\n+    if (isAnonymousOrLocal(field.getType())) {\n+      return true;\n+    }\n+\n+    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n+    if (!list.isEmpty()) {\n+      FieldAttributes fieldAttributes = new FieldAttributes(field);\n+      for (ExclusionStrategy exclusionStrategy : list) {\n+        if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  public boolean excludeClass(Class<?> clazz, boolean serialize) {\n+    if (version != Excluder.IGNORE_VERSIONS\n+        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n+      return true;\n+    }\n+\n+    if (!serializeInnerClasses && isInnerClass(clazz)) {\n+      return true;\n+    }\n+\n+    if (isAnonymousOrLocal(clazz)) {\n+      return true;\n+    }\n+\n+    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n+    for (ExclusionStrategy exclusionStrategy : list) {\n+      if (exclusionStrategy.shouldSkipClass(clazz)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private boolean isAnonymousOrLocal(Class<?> clazz) {\n+    return !Enum.class.isAssignableFrom(clazz)\n+        && (clazz.isAnonymousClass() || clazz.isLocalClass());\n+  }\n+\n+  private boolean isInnerClass(Class<?> clazz) {\n+    return clazz.isMemberClass() && !isStatic(clazz);\n+  }\n+\n+  private boolean isStatic(Class<?> clazz) {\n+    return (clazz.getModifiers() & Modifier.STATIC) != 0;\n+  }\n+\n+  private boolean isValidVersion(Since since, Until until) {\n+    return isValidSince(since) && isValidUntil(until);\n+  }\n+\n+  private boolean isValidSince(Since annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n+      if (annotationVersion > version) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isValidUntil(Until annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n+      if (annotationVersion <= version) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.Excluder;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Primitives;\n import com.google.gson.reflect.TypeToken;\n public final class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {\n   private final ConstructorConstructor constructorConstructor;\n   private final FieldNamingStrategy fieldNamingPolicy;\n-  private final ExclusionStrategy serializationExclusionStrategy;\n-  private final ExclusionStrategy deserializationExclusionStrategy;\n+  private final Excluder excluder;\n \n   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n-      FieldNamingStrategy fieldNamingPolicy, ExclusionStrategy serializationExclusionStrategy,\n-      ExclusionStrategy deserializationExclusionStrategy) {\n+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n     this.constructorConstructor = constructorConstructor;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n-    this.serializationExclusionStrategy = serializationExclusionStrategy;\n-    this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n-  }\n-\n-  public boolean serializeField(Field f) {\n-    return !serializationExclusionStrategy.shouldSkipClass(f.getType())\n-        && !serializationExclusionStrategy.shouldSkipField(new FieldAttributes(f));\n-  }\n-\n-  private boolean deserializeField(Field f) {\n-    return !deserializationExclusionStrategy.shouldSkipClass(f.getType())\n-        && !deserializationExclusionStrategy.shouldSkipField(new FieldAttributes(f));\n+    this.excluder = excluder;\n+  }\n+\n+  public boolean excludeField(Field f, boolean serialize) {\n+    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n   }\n \n   private String getFieldName(Field f) {\n       Field[] fields = raw.getDeclaredFields();\n       AccessibleObject.setAccessible(fields, true);\n       for (Field field : fields) {\n-        boolean serialize = serializeField(field);\n-        boolean deserialize = deserializeField(field);\n+        boolean serialize = excludeField(field, true);\n+        boolean deserialize = excludeField(field, false);\n         if (!serialize && !deserialize) {\n           continue;\n         }\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n \n import com.google.gson.annotations.Expose;\n \n+import com.google.gson.internal.Excluder;\n import junit.framework.TestCase;\n \n import java.lang.reflect.Field;\n  * @author Joel Leitch\n  */\n public class ExposeAnnotationExclusionStrategyTest extends TestCase {\n-  private ExclusionStrategy serializationStrategy = new GsonExclusionStrategy(\n-      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, true, true, true, false);\n-  private ExclusionStrategy deserializationStrategy = new GsonExclusionStrategy(\n-      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, true, true, false, true);\n+  private Excluder excluder = Excluder.DEFAULT.excludeFieldsWithoutExposeAnnotation();\n \n   public void testNeverSkipClasses() throws Exception {\n-    assertFalse(deserializationStrategy.shouldSkipClass(MockObject.class));\n-    assertFalse(serializationStrategy.shouldSkipClass(MockObject.class));\n+    assertFalse(excluder.excludeClass(MockObject.class, true));\n+    assertFalse(excluder.excludeClass(MockObject.class, false));\n   }\n \n   public void testSkipNonAnnotatedFields() throws Exception {\n-    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n-    assertTrue(deserializationStrategy.shouldSkipField(f));\n-    assertTrue(serializationStrategy.shouldSkipField(f));\n+    Field f = createFieldAttributes(\"hiddenField\");\n+    assertTrue(excluder.excludeField(f, true));\n+    assertTrue(excluder.excludeField(f, false));\n   }\n \n   public void testSkipExplicitlySkippedFields() throws Exception {\n-    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n-    assertTrue(deserializationStrategy.shouldSkipField(f));\n-    assertTrue(serializationStrategy.shouldSkipField(f));\n+    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n+    assertTrue(excluder.excludeField(f, true));\n+    assertTrue(excluder.excludeField(f, false));\n   }\n \n   public void testNeverSkipExposedAnnotatedFields() throws Exception {\n-    FieldAttributes f = createFieldAttributes(\"exposedField\");\n-    assertFalse(deserializationStrategy.shouldSkipField(f));\n-    assertFalse(serializationStrategy.shouldSkipField(f));\n+    Field f = createFieldAttributes(\"exposedField\");\n+    assertFalse(excluder.excludeField(f, true));\n+    assertFalse(excluder.excludeField(f, false));\n   }\n \n   public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n-    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n-    assertFalse(deserializationStrategy.shouldSkipField(f));\n-    assertFalse(serializationStrategy.shouldSkipField(f));\n+    Field f = createFieldAttributes(\"explicitlyExposedField\");\n+    assertFalse(excluder.excludeField(f, true));\n+    assertFalse(excluder.excludeField(f, false));\n   }\n \n   public void testDifferentSerializeAndDeserializeField() throws Exception {\n-    FieldAttributes f = createFieldAttributes(\"explicitlyDifferentModeField\");\n-    assertTrue(deserializationStrategy.shouldSkipField(f));\n-    assertFalse(serializationStrategy.shouldSkipField(f));\n+    Field f = createFieldAttributes(\"explicitlyDifferentModeField\");\n+    assertFalse(excluder.excludeField(f, true));\n+    assertTrue(excluder.excludeField(f, false));\n   }\n \n-  private static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n-    Field f = MockObject.class.getField(fieldName);\n-    return new FieldAttributes(f);\n+  private static Field createFieldAttributes(String fieldName) throws Exception {\n+    return MockObject.class.getField(fieldName);\n   }\n \n   @SuppressWarnings(\"unused\")\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Excluder;\n import java.lang.reflect.Field;\n import junit.framework.TestCase;\n \n public class InnerClassExclusionStrategyTest extends TestCase {\n   public InnerClass innerClass = new InnerClass();\n   public StaticNestedClass staticNestedClass = new StaticNestedClass();\n-  private ExclusionStrategy strategy = new GsonExclusionStrategy(\n-      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, false, false, false, false);\n+  private Excluder excluder = Excluder.DEFAULT.disableInnerClassSerialization();\n \n   public void testExcludeInnerClassObject() throws Exception {\n     Class<?> clazz = innerClass.getClass();\n-    assertTrue(strategy.shouldSkipClass(clazz));\n+    assertTrue(excluder.excludeClass(clazz, true));\n   }\n \n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(excluder.excludeField(f, true));\n   }\n \n   public void testIncludeStaticNestedClassObject() throws Exception {\n     Class<?> clazz = staticNestedClass.getClass();\n-    assertFalse(strategy.shouldSkipClass(clazz));\n+    assertFalse(excluder.excludeClass(clazz, true));\n   }\n \n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(excluder.excludeField(f, true));\n   }\n \n   class InnerClass {\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n package com.google.gson;\n \n import com.google.gson.annotations.Since;\n-import java.lang.reflect.Field;\n+import com.google.gson.internal.Excluder;\n import junit.framework.TestCase;\n \n /**\n- * Unit tests for the {@link GsonExclusionStrategy} class.\n+ * Unit tests for the {@link Excluder} class.\n  *\n  * @author Joel Leitch\n  */\n   private static final double VERSION = 5.0D;\n \n   public void testClassAndFieldAreAtSameVersion() throws Exception {\n-    Class<MockObject> clazz = MockObject.class;\n-    Field f = clazz.getField(\"someField\");\n-    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION, 0,\n-        true, true, true, false, false);\n-    assertFalse(strategy.shouldSkipClass(clazz));\n-\n-    FieldAttributes fieldAttributes = new FieldAttributes(f);\n-    assertFalse(strategy.shouldSkipField(fieldAttributes));\n+    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n+    assertFalse(excluder.excludeClass(MockObject.class, true));\n+    assertFalse(excluder.excludeField(MockObject.class.getField(\"someField\"), true));\n   }\n \n   public void testClassAndFieldAreBehindInVersion() throws Exception {\n-    Class<MockObject> clazz = MockObject.class;\n-    Field f = clazz.getField(\"someField\");\n-    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION + 1, 0,\n-        true, true, true, false, false);\n-    assertFalse(strategy.shouldSkipClass(clazz));\n-\n-    FieldAttributes fieldAttributes = new FieldAttributes(f);\n-    assertFalse(strategy.shouldSkipField(fieldAttributes));\n+    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 1);\n+    assertFalse(excluder.excludeClass(MockObject.class, true));\n+    assertFalse(excluder.excludeField(MockObject.class.getField(\"someField\"), true));\n   }\n \n   public void testClassAndFieldAreAheadInVersion() throws Exception {\n-    Class<MockObject> clazz = MockObject.class;\n-    Field f = clazz.getField(\"someField\");\n-    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION - 1, 0,\n-        true, true, true, false, false);\n-    assertTrue(strategy.shouldSkipClass(clazz));\n-\n-    FieldAttributes fieldAttributes = new FieldAttributes(f);\n-    assertTrue(strategy.shouldSkipField(fieldAttributes));\n+    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 1);\n+    assertTrue(excluder.excludeClass(MockObject.class, true));\n+    assertTrue(excluder.excludeField(MockObject.class.getField(\"someField\"), true));\n   }\n \n   @Since(VERSION)", "timestamp": 1321947433, "metainfo": ""}