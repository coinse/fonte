{"sha": "b819307de8b6bf24241c8ee75acbf90f88489c56", "log": "refactored the field navigation using reflection out of ObjectNavigator.", "commit": "\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n \n package com.google.gson;\n \n+import java.lang.reflect.Type;\n+\n import com.google.gson.internal.Preconditions;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Types;\n-\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n \n /**\n  * Provides ability to apply a visitor to an object and all of its fields\n \n   private final ExclusionStrategy exclusionStrategy;\n   private final ObjectTypePair objTypePair;\n+  private ReflectingFieldNavigator reflectingFieldNavigator;\n \n   /**\n    * @param objTypePair\n    *          object.\n    */\n   ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\n+    reflectingFieldNavigator = new ReflectingFieldNavigator(exclusionStrategy);\n     this.objTypePair = objTypePair;\n     this.exclusionStrategy = Preconditions.checkNotNull(exclusionStrategy);\n   }\n           visitor.getTarget();\n         } else {\n           visitor.startVisitingObject(objectToVisit);\n-          ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n-          Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n-          for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n-              curr.getSuperclass()) {\n-            if (!curr.isSynthetic()) {\n-              navigateClassFields(objectToVisit, curr, visitor);\n-            }\n-          }\n+          reflectingFieldNavigator.visitFieldsReflectively(objTypePair, visitor);\n         }\n       } finally {\n         visitor.end(objTypePair);\n     }\n   }\n \n-  private boolean isPrimitiveOrString(Object objectToVisit) {\n+  private static boolean isPrimitiveOrString(Object objectToVisit) {\n     Class<?> realClazz = objectToVisit.getClass();\n     return realClazz == Object.class || realClazz == String.class\n         || Primitives.unwrap(realClazz).isPrimitive();\n   }\n-\n-  private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\n-    Field[] fields = clazz.getDeclaredFields();\n-    AccessibleObject.setAccessible(fields, true);\n-    for (Field f : fields) {\n-      FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n-      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n-          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n-        continue; // skip\n-      }\n-      Type declaredTypeOfField = getTypeInfoForField(f, objTypePair.type);\n-      boolean visitedWithCustomHandler =\n-          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n-      if (!visitedWithCustomHandler) {\n-        if (Types.isArray(declaredTypeOfField)) {\n-          visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n-        } else {\n-          visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n-        }\n-      }\n-    }\n-  }\n-\n-\n-  /**\n-   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n-   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n-   *\n-   * @param f the actual field object to retrieve the type from\n-   * @param typeDefiningF the type that contains the field {@code f}\n-   * @return the type information for the field\n-   */\n-  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n-    Class<?> rawType = Types.getRawType(typeDefiningF);\n-    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n-      // this field is unrelated to the type; the user probably omitted type information\n-      return f.getGenericType();\n-    }\n-    return Types.resolve(typeDefiningF, rawType, f.getGenericType());\n-  }\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.ObjectNavigator.Visitor;\n+import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.Types;\n+\n+/**\n+ * Visits each of the fields of the specified class using reflection\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+final class ReflectingFieldNavigator {\n+\n+  private final ExclusionStrategy exclusionStrategy;\n+\n+  /**\n+   * @param objTypePair\n+   *          The object,type (fully genericized) being navigated\n+   * @param exclusionStrategy\n+   *          the concrete strategy object to be used to filter out fields of an\n+   *          object.\n+   */\n+  ReflectingFieldNavigator(ExclusionStrategy exclusionStrategy) {\n+    this.exclusionStrategy = Preconditions.checkNotNull(exclusionStrategy);\n+  }\n+\n+  void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {\n+    ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n+    Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n+    for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n+      curr.getSuperclass()) {\n+      if (!curr.isSynthetic()) {\n+        navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);\n+      }\n+    }\n+  }\n+\n+  private void navigateClassFields(Object obj, Type objType,\n+      Class<?> classInInheritanceHierarchyForObj, Visitor visitor) {\n+    Field[] fields = classInInheritanceHierarchyForObj.getDeclaredFields();\n+    AccessibleObject.setAccessible(fields, true);\n+    for (Field f : fields) {\n+      FieldAttributes fieldAttributes = new FieldAttributes(classInInheritanceHierarchyForObj, f);\n+      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n+          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n+        continue; // skip\n+      }\n+      Type declaredTypeOfField = getTypeInfoForField(f, objType);\n+      boolean visitedWithCustomHandler =\n+          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n+      if (!visitedWithCustomHandler) {\n+        if (Types.isArray(declaredTypeOfField)) {\n+          visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n+        } else {\n+          visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n+   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n+   *\n+   * @param f the actual field object to retrieve the type from\n+   * @param typeDefiningF the type that contains the field {@code f}\n+   * @return the type information for the field\n+   */\n+  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n+    Class<?> rawType = Types.getRawType(typeDefiningF);\n+    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n+      // this field is unrelated to the type; the user probably omitted type information\n+      return f.getGenericType();\n+    }\n+    return Types.resolve(typeDefiningF, rawType, f.getGenericType());\n+  }\n+}", "timestamp": 1300991303, "metainfo": ""}