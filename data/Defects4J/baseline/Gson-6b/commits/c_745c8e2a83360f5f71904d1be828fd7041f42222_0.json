{"sha": "745c8e2a83360f5f71904d1be828fd7041f42222", "log": "Fixed issue 58 by disabling the use of field value actual type for all cases except when it is marked as Object.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n       }\n     } else {\n       Object fieldValue = getFieldValue(f, obj);\n-      // See if the fieldValue has better type information than the specified typeOfF\n       // This takes care of situations where the field was declared as an Object, but the\n       // actual value contains something more specific. See Issue 54.\n-      if (fieldValue != null && typeOfF instanceof Class) {\n-        Class<?> classOfF = (Class<?>) typeOfF;\n-        Class<?> actualClassOfF = fieldValue.getClass();\n-        if (classOfF.isAssignableFrom(actualClassOfF)) {\n-          typeOfF = actualClassOfF;\n-        }\n+      if (fieldValue != null && typeOfF == Object.class) {\n+        typeOfF = fieldValue.getClass();\n       }\n       addAsChildOfObject(f, typeOfF, fieldValue);\n     }\n--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n   public void testRawCollectionOfIntegersSerialization() {\n     Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n     assertEquals(\"[1,2,3,4,5,6,7,8,9]\", gson.toJson(target));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testRawCollectionSerialization() {\n+    BagOfPrimitives bag1 = new BagOfPrimitives();\n+    Collection target = Arrays.asList(bag1, bag1);\n+    String json = gson.toJson(target);\n+    assertTrue(json.contains(bag1.getExpectedJson()));\n   }\n \n   public void testRawCollectionDeserializationNotAlllowed() {", "timestamp": 1224010559, "metainfo": ""}