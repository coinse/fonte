{"sha": "e3af076ff271968a1a639c5bbdc1ba967b11ea94", "log": "Deprecate the FieldNamingStrategy interface and replace it with FieldNamingStrategy2.  This is the first step to help make it easy to cache field annotations across all instances of a class, etc.", "commit": "\n--- a/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * Converts the field name that uses camel-case define word separation into separate words that\n   }\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annnotations) {\n+  protected String translateName(String target, Type fieldType,\n+      Collection<Annotation> annnotations) {\n     StringBuilder translation = new StringBuilder();\n     for (int i = 0; i < target.length(); i++) {\n       char character = target.charAt(i);\n--- a/gson/src/main/java/com/google/gson/CircularReferenceException.java\n+++ b/gson/src/main/java/com/google/gson/CircularReferenceException.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.google.gson;\n-\n-import java.lang.reflect.Field;\n \n /**\n  * Exception class to indicate a circular reference error.\n     this.offendingNode = offendingNode;\n   }\n   \n-  public IllegalStateException createDetailedException(Field offendingField) {\n+  public IllegalStateException createDetailedException(FieldAttributes offendingField) {\n     StringBuilder msg = new StringBuilder(getMessage());\n     if (offendingField != null) {\n       msg.append(\"\\n  \").append(\"Offending field: \").append(offendingField.getName() + \"\\n\");\n--- a/gson/src/main/java/com/google/gson/CompositionFieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/CompositionFieldNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * Performs numerous field naming translations wrapped up as one object.\n   }\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+  protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) {\n     for (RecursiveFieldNamingPolicy policy : fieldPolicies) {\n       target = policy.translateName(target, fieldType, annotations);\n     }\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n \n /**\n  * A data object that stores attributes of a field.\n   private final Class<?> declaredType;\n   private final boolean isSynthetic;\n   private final int modifiers;\n+  private final String name;\n \n   // Fields used for lazy initialization\n-  private String name;\n   private Type genericType;\n-  private Annotation[] annotations;\n+  private Collection<Annotation> annotations;\n \n   /**\n    * Constructs a Field Attributes object from the {@code f}.\n   FieldAttributes(final Field f) {\n     Preconditions.checkNotNull(f);\n     field = f;\n+    name = field.getName();\n     declaredType = f.getType();\n     isSynthetic = f.isSynthetic();\n     modifiers = field.getModifiers();\n    * @return the name of the field\n    */\n   public String getName() {\n-    if (name == null) {\n-      name = field.getName();\n-    }\n     return name;\n   }\n \n    * @return the annotation instance if it is bound to the field; otherwise {@code null}\n    */\n   public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n+    return getAnnotationFromArray(getAnnotations(), annotation);\n+  }\n+\n+  /**\n+   * Return the annotations that are present on this field.\n+   *\n+   * @return an array of all the annotations set on the field\n+   * @since 1.4 \n+   */\n+  public Collection<Annotation> getAnnotations() {\n     if (annotations == null) {\n-      annotations = field.getAnnotations();\n+      annotations = Collections.unmodifiableCollection(\n+          Arrays.asList(field.getAnnotations()));\n     }\n-    return getAnnotationFromArray(annotations, annotation);\n+    return annotations;\n   }\n \n   /**\n    * This is exposed internally only for the removing synthetic fields from the JSON output.\n    *\n    * @return true if the field is synthetic; otherwise false\n+   * @throws IllegalAccessException \n+   * @throws IllegalArgumentException \n+   */\n+  void set(Object instance, Object value) throws IllegalAccessException {\n+    field.set(instance, value);\n+  }\n+  \n+  /**\n+   * This is exposed internally only for the removing synthetic fields from the JSON output.\n+   *\n+   * @return true if the field is synthetic; otherwise false\n+   * @throws IllegalAccessException \n+   * @throws IllegalArgumentException \n+   */\n+  Object get(Object instance) throws IllegalAccessException {\n+    return field.get(instance);\n+  }\n+  \n+  /**\n+   * This is exposed internally only for the removing synthetic fields from the JSON output.\n+   *\n+   * @return true if the field is synthetic; otherwise false\n    */\n   boolean isSynthetic() {\n     return isSynthetic;\n   }\n+  \n+  /**\n+   * @deprecated remove this when {@link FieldNamingStrategy} is deleted.\n+   */\n+  @Deprecated\n+  Field getFieldObject() {\n+    return field;\n+  }\n \n   @SuppressWarnings(\"unchecked\")\n   private static <T extends Annotation> T getAnnotationFromArray(\n-      Annotation[] annotations, Class<T> annotation) {\n+      Collection<Annotation> annotations, Class<T> annotation) {\n     for (Annotation a : annotations) {\n       if (a.annotationType() == annotation) {\n         return (T) a;\n--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n    */\n   LOWER_CASE_WITH_DASHES(new LowerCamelCaseSeparatorNamingPolicy(\"-\"));\n \n-  private final FieldNamingStrategy namingPolicy;\n+  private final FieldNamingStrategy2 namingPolicy;\n \n-  private FieldNamingPolicy(FieldNamingStrategy namingPolicy) {\n+  private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) {\n     this.namingPolicy = namingPolicy;\n   }\n \n-  FieldNamingStrategy getFieldNamingPolicy() {\n+  FieldNamingStrategy2 getFieldNamingPolicy() {\n     return namingPolicy;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  * @since 1.3\n+ * @deprecated use {@link FieldNamingStrategy2} instead\n  */\n+@Deprecated\n public interface FieldNamingStrategy {\n \n   /**\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy2.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * The new mechanism for providing custom field naming in Gson.  This allows the client code\n+ * to translate field names into a particular convention that is not supported as a normal\n+ * Java field declaration rules.  For example, Java does not support \"-\" characters in a\n+ * field name.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @since 1.4\n+ */\n+public interface FieldNamingStrategy2 {\n+\n+  /**\n+   * Translates the field name into its JSON field name representation.\n+   *\n+   * @param f the field that is being translated\n+   * @return the translated field name.\n+   * @since 1.3\n+   */\n+  public String translateName(FieldAttributes f);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Adapts the old \"deprecated\" {@link FieldNamingStrategy} to the new {@link FieldNamingStrategy2}\n+ * type. \n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class FieldNamingStrategy2Adapter implements FieldNamingStrategy2 {\n+  private final FieldNamingStrategy adaptee;\n+\n+  public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {\n+    Preconditions.checkNotNull(adaptee);\n+    this.adaptee = adaptee;\n+  }\n+  \n+  public String translateName(FieldAttributes f) {\n+    return adaptee.translateName(f.getFieldObject());\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n       new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n   static final JsonFormatter DEFAULT_JSON_FORMATTER = new JsonCompactFormatter();\n-  static final FieldNamingStrategy DEFAULT_NAMING_POLICY =\n+  static final FieldNamingStrategy2 DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n \n   private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY =\n \n   private final ExclusionStrategy deserializationStrategy;\n \n-  private final FieldNamingStrategy fieldNamingPolicy;\n+  private final FieldNamingStrategy2 fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n \n   /** Map containing Type or Class objects as keys */\n   }\n \n   Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\n-      FieldNamingStrategy fieldNamingPolicy, MappedObjectConstructor objectConstructor,\n+      FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor,\n       JsonFormatter formatter, boolean serializeNulls,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private boolean serializeInnerClasses;\n   private boolean excludeFieldsWithoutExposeAnnotation;\n   private LongSerializationPolicy longSerializationPolicy;\n-  private FieldNamingStrategy fieldNamingPolicy;\n+  private FieldNamingStrategy2 fieldNamingPolicy;\n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n   private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n   private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n    * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.3\n-   */\n+   * @deprecated use {@link #setFieldNamingStrategy(FieldNamingStrategy2)} instead.\n+   */\n+  @Deprecated\n   public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n+    return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy));\n+  }\n+  \n+  /**\n+   * Configures Gson to apply a specific naming policy strategy to an object's field during\n+   * serialization and deserialization.\n+   *\n+   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.4\n+   */\n+  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) {\n     this.fieldNamingPolicy =\n         new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy);\n     return this;\n--- a/gson/src/main/java/com/google/gson/JavaFieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/JavaFieldNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * A simple implementation of the {@link FieldNamingStrategy} interface such that it does not\n class JavaFieldNamingPolicy extends RecursiveFieldNamingPolicy {\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+  protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) {\n     return target;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n package com.google.gson;\n \n import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n \n /**\n     throw new JsonParseException(\"Expecting array but found object: \" + node);\n   }\n \n-  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+  public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) {\n     throw new JsonParseException(\"Expecting array but found array field \" + f.getName() + \": \"\n         + obj);\n   }\n \n-  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+  public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) {\n     throw new JsonParseException(\"Expecting array but found object field \" + f.getName() + \": \" \n         + obj);\n   }\n \n-  public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent) {\n+  public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent) {\n     throw new JsonParseException(\"Expecting array but found field \" + f.getName() + \": \" \n         + parent);\n   }\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n \n /**\n     throw new JsonParseException(\"Expecting object but found array: \" + array);\n   }\n \n-  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+  public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (!json.isJsonObject()) {\n         throw new JsonParseException(\"Expecting object found: \" + json); \n     }\n   }\n \n-  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+  public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (!json.isJsonObject()) {\n         throw new JsonParseException(\"Expecting object found: \" + json); \n     }\n   }\n \n-  private String getFieldName(Field f) {\n-    FieldNamingStrategy namingPolicy = factory.getFieldNamingPolicy();\n+  private String getFieldName(FieldAttributes f) {\n+    FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy();\n     return namingPolicy.translateName(f);\n   }\n \n-  public boolean visitFieldUsingCustomHandler(Field f, Type declaredTypeOfField, Object parent) {\n+  public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) {\n     try {\n       String fName = getFieldName(f);\n       if (!json.isJsonObject()) {\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n package com.google.gson;\n \n import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n \n /**\n     }\n   }\n \n-  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+  public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (isFieldNull(f, obj)) {\n         if (serializeNulls) {\n     }\n   }\n \n-  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+  public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (isFieldNull(f, obj)) {\n         if (serializeNulls) {\n     assignToRoot(json);\n   }\n \n-  private void addAsChildOfObject(Field f, ObjectTypePair fieldValuePair) {\n+  private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair) {\n     JsonElement childElement = getJsonElementForChild(fieldValuePair);\n     addChildAsElement(f, childElement);\n   }\n \n-  private void addChildAsElement(Field f, JsonElement childElement) {\n-    FieldNamingStrategy namingPolicy = factory.getFieldNamingPolicy();\n+  private void addChildAsElement(FieldAttributes f, JsonElement childElement) {\n+    FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy();\n     root.getAsJsonObject().add(namingPolicy.translateName(f), childElement);\n   }\n \n     }\n   }\n \n-  public boolean visitFieldUsingCustomHandler(Field f, Type declaredTypeOfField, Object parent) {\n+  public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) {\n     try {\n       Preconditions.checkState(root.isJsonObject());\n       Object obj = f.get(parent);\n     root = newRoot;\n   }\n \n-  private boolean isFieldNull(Field f, Object obj) {\n+  private boolean isFieldNull(FieldAttributes f, Object obj) {\n     return getFieldValue(f, obj) == null;\n   }\n \n-  private Object getFieldValue(Field f, Object obj) {\n+  private Object getFieldValue(FieldAttributes f, Object obj) {\n     try {\n       return f.get(obj);\n     } catch (IllegalAccessException e) {\n--- a/gson/src/main/java/com/google/gson/LowerCaseNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/LowerCaseNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n  * lower case letters.\n  *\n- *<p>The following is an example:</p>\n+ * <p>The following is an example:</p>\n  * <pre>\n  * class IntWrapper {\n  *   public int integerField = 0;\n  * assert(\"integerfield\".equals(translatedFieldName));\n  * </pre>\n  *\n+ * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n class LowerCaseNamingPolicy extends RecursiveFieldNamingPolicy {\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+  protected String translateName(String target, Type fieldType,\n+      Collection<Annotation> annotations) {\n     return target.toLowerCase();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * A {@link FieldNamingStrategy} that ensures the JSON field names begins with\n   }\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+  protected String translateName(String target, Type fieldType,\n+      Collection<Annotation> annotations) {\n     StringBuilder fieldNameBuilder = new StringBuilder();\n     int index = 0;\n     char firstCharacter = target.charAt(index);\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n import java.lang.reflect.Type;\n \n /**\n- * Provides ability to apply a visitor to an object and all of its fields recursively.\n- *\n+ * Provides ability to apply a visitor to an object and all of its fields\n+ * recursively.\n+ * \n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n \n   public interface Visitor {\n     public void start(ObjectTypePair node);\n+\n     public void end(ObjectTypePair node);\n \n     /**\n-     * This is called before the object navigator starts visiting the current object\n+     * This is called before the object navigator starts visiting the current\n+     * object\n      */\n     void startVisitingObject(Object node);\n \n     /**\n      * This is called to visit an object field of the current object\n      */\n-    void visitObjectField(Field f, Type typeOfF, Object obj);\n+    void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);\n \n     /**\n      * This is called to visit an array field of the current object\n      */\n-    void visitArrayField(Field f, Type typeOfF, Object obj);\n+    void visitArrayField(FieldAttributes f, Type typeOfF, Object obj);\n \n     /**\n      * This is called to visit an object using a custom handler\n+     * \n      * @return true if a custom handler exists, false otherwise\n      */\n     public boolean visitUsingCustomHandler(ObjectTypePair objTypePair);\n \n     /**\n-     * This is called to visit a field of the current object using a custom handler\n+     * This is called to visit a field of the current object using a custom\n+     * handler\n      */\n-    public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent);\n+    public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField,\n+        Object parent);\n \n     /**\n      * Retrieve the current target\n   private final ObjectTypePair objTypePair;\n \n   /**\n-   * @param objTypePair The object,type (fully genericized) being navigated\n-   * @param exclusionStrategy the concrete strategy object to be used to\n-   *        filter out fields of an object.\n+   * @param objTypePair\n+   *          The object,type (fully genericized) being navigated\n+   * @param exclusionStrategy\n+   *          the concrete strategy object to be used to filter out fields of an\n+   *          object.\n    */\n   ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\n     Preconditions.checkNotNull(exclusionStrategy);\n   }\n \n   /**\n-   * Navigate all the fields of the specified object.\n-   * If a field is null, it does not get visited.\n+   * Navigate all the fields of the specified object. If a field is null, it\n+   * does not get visited.\n    */\n   public void accept(Visitor visitor) {\n     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type);\n         } else if (objTypeInfo.getActualType() == Object.class\n             && isPrimitiveOrString(objectToVisit)) {\n           // TODO(Joel): this is only used for deserialization of \"primitives\"\n-          //             we should rethink this!!!\n+          // we should rethink this!!!\n           visitor.visitPrimitive(objectToVisit);\n           objectToVisit = visitor.getTarget();\n         } else {\n           visitor.startVisitingObject(objectToVisit);\n           ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n           Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass();\n-          for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class);\n-              curr = curr.getSuperclass()) {\n+          for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n+              curr.getSuperclass()) {\n             if (!curr.isSynthetic()) {\n               navigateClassFields(objectToVisit, curr, visitor);\n             }\n         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type);\n         Type declaredTypeOfField = fieldTypeInfo.getActualType();\n         boolean visitedWithCustomHandler =\n-            visitor.visitFieldUsingCustomHandler(f, declaredTypeOfField, obj);\n+            visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n         if (!visitedWithCustomHandler) {\n           if (fieldTypeInfo.isArray()) {\n-            visitor.visitArrayField(f, declaredTypeOfField, obj);\n+            visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n           } else {\n-            visitor.visitObjectField(f, declaredTypeOfField, obj);\n+            visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n           }\n         }\n       }\n--- a/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n  */\n final class ObjectNavigatorFactory {\n   private final ExclusionStrategy strategy;\n-  private final FieldNamingStrategy fieldNamingPolicy;\n+  private final FieldNamingStrategy2 fieldNamingPolicy;\n \n   /**\n    * Creates a factory object that will be able to create new\n    * @param fieldNamingPolicy the naming policy that should be applied to field\n    *        names\n    */\n-  public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n+  public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) {\n     Preconditions.checkNotNull(fieldNamingPolicy);\n     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     return new ObjectNavigator(objTypePair, strategy);\n   }\n \n-  FieldNamingStrategy getFieldNamingPolicy() {\n+  FieldNamingStrategy2 getFieldNamingPolicy() {\n     return fieldNamingPolicy;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Pair.java\n+++ b/gson/src/main/java/com/google/gson/Pair.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.google.gson;\n \n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n final class Pair<FIRST, SECOND> {\n \n   final FIRST first;\n     this.first = first;\n     this.second = second;\n   }\n-}\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    Pair<?, ?> that = (Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/RecursiveFieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/RecursiveFieldNamingPolicy.java\n package com.google.gson;\n \n import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * A mechanism for providing custom field naming in Gson.  This allows the client code to translate\n  *\n  * @author Joel Leitch\n  */\n-abstract class RecursiveFieldNamingPolicy implements FieldNamingStrategy {\n+abstract class RecursiveFieldNamingPolicy implements FieldNamingStrategy2 {\n \n-  public final String translateName(Field f) {\n+  public final String translateName(FieldAttributes f) {\n     Preconditions.checkNotNull(f);\n-    return translateName(f.getName(), f.getGenericType(), f.getAnnotations());\n+    return translateName(f.getName(), f.getDeclaredType(), f.getAnnotations());\n   }\n \n   /**\n    * @param annotations the annotations set on the field\n    * @return the translated field name\n    */\n-  protected abstract String translateName(String target, Type fieldType, Annotation[] annotations);\n+  protected abstract String translateName(String target, Type fieldType, Collection<Annotation> annotations);\n }\n--- a/gson/src/main/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicy.java\n \n import com.google.gson.annotations.SerializedName;\n \n-import java.lang.reflect.Field;\n-\n /**\n  * A {@link FieldNamingStrategy} that acts as a chain of responsibility.  If the\n  * {@link com.google.gson.annotations.SerializedName} annotation is applied to a field then this\n  *\n  * @author Joel Leitch\n  */\n-final class SerializedNameAnnotationInterceptingNamingPolicy implements FieldNamingStrategy {\n+final class SerializedNameAnnotationInterceptingNamingPolicy implements FieldNamingStrategy2 {\n   private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\n-  private final FieldNamingStrategy delegate;\n+  private final FieldNamingStrategy2 delegate;\n \n-  public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy delegate) {\n+  public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\n     this.delegate = delegate;\n   }\n \n-  public String translateName(Field f) {\n+  public String translateName(FieldAttributes f) {\n     Preconditions.checkNotNull(f);\n     SerializedName serializedName = f.getAnnotation(SerializedName.class);\n     if (serializedName != null) {\n--- a/gson/src/main/java/com/google/gson/UpperCaseNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/UpperCaseNamingPolicy.java\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n \n /**\n  * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n class UpperCaseNamingPolicy extends RecursiveFieldNamingPolicy {\n \n   @Override\n-  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+  protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) {\n     return target.toUpperCase();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n \n import junit.framework.TestCase;\n \n-import java.lang.reflect.Field;\n-\n /**\n  * Tests for the {@link JavaFieldNamingPolicy} class.\n  *\n   }\n \n   public void testFieldNamingPolicy() throws Exception {\n-    Field f = String.class.getFields()[0];\n+    FieldAttributes f = new FieldAttributes(String.class.getFields()[0]);\n     assertEquals(f.getName(), namingPolicy.translateName(f));\n   }\n \n   public void testNullField() throws Exception {\n     try {\n-      namingPolicy.translateName((Field) null);\n+      namingPolicy.translateName((FieldAttributes) null);\n       fail(\"Should have thrown an exception\");\n     } catch (IllegalArgumentException expected) { }\n   }\n--- a/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n \n package com.google.gson;\n \n-import com.google.gson.annotations.SerializedName;\n-\n import junit.framework.TestCase;\n \n-import java.lang.reflect.Field;\n+import com.google.gson.annotations.SerializedName;\n \n /**\n  * Unit tests for the {@link SerializedNameAnnotationInterceptingNamingPolicy} class.\n \n   public void testFieldWithAnnotation() throws Exception {\n     String fieldName = \"fieldWithAnnotation\";\n-    Field f = SomeObject.class.getField(fieldName);\n+    FieldAttributes f = new FieldAttributes(SomeObject.class.getField(fieldName));\n \n     assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));\n     assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));\n \n   public void testFieldWithoutAnnotation() throws Exception {\n     String fieldName = \"fieldWithoutAnnotation\";\n-    Field f = SomeObject.class.getField(fieldName);\n+    FieldAttributes f = new FieldAttributes(SomeObject.class.getField(fieldName));\n \n     assertEquals(fieldName, policy.translateName(f));\n   }\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n   }\n \n   private static class DataHolder {\n-    @SuppressWarnings(\"unused\")\n     final String data;\n \n     // For use by Gson", "timestamp": 1263077007, "metainfo": ""}