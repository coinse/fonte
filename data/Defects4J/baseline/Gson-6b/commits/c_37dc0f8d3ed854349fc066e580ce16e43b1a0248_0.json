{"sha": "37dc0f8d3ed854349fc066e580ce16e43b1a0248", "log": "Type adapter for maps. Supports both complex and non-complex keys.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/MapAsArrayTypeAdapter.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Adapts maps containing complex keys as arrays of map entries.\n+ *\n+ * <h3>Maps as JSON objects</h3>\n+ * The standard GSON map type adapter converts Java {@link Map Maps} to JSON\n+ * Objects. This requires that map keys can be serialized as strings; this is\n+ * insufficient for some key types. For example, consider a map whose keys are\n+ * points on a grid. The default JSON form encodes reasonably: <pre>   {@code\n+ *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n+ *   original.put(new Point(5, 6), \"a\");\n+ *   original.put(new Point(8, 8), \"b\");\n+ *   System.out.println(gson.toJson(original, type));\n+ * }</pre>\n+ * The above code prints this JSON object:<pre>   {@code\n+ *   {\n+ *     \"(5,6)\": \"a\",\n+ *     \"(8,8)\": \"b\"\n+ *   }\n+ * }</pre>\n+ * But GSON is unable to deserialize this value because the JSON string name is\n+ * just the {@link Object#toString() toString()} of the map key. Attempting to\n+ * convert the above JSON to an object fails with a parse exception:\n+ * <pre>com.google.gson.JsonParseException: Expecting object found: \"(5,6)\"\n+ *   at com.google.gson.JsonObjectDeserializationVisitor.visitFieldUsingCustomHandler\n+ *   at com.google.gson.ObjectNavigator.navigateClassFields\n+ *   ...</pre>\n+ *\n+ * <h3>Maps as JSON arrays</h3>\n+ * An alternative approach taken by this type adapter is to encode maps as\n+ * arrays of map entries. Each map entry is a two element array containing a key\n+ * and a value. This approach is more flexible because any type can be used as\n+ * the map's key; not just strings. But it's also less portable because the\n+ * receiver of such JSON must be aware of the map entry convention.\n+ *\n+ * <p>Register this adapter when you are creating your GSON instance.\n+ * <pre>   {@code\n+ *   Gson gson = new GsonBuilder()\n+ *     .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())\n+ *     .create();\n+ * }</pre>\n+ * This will change the structure of the JSON emitted by the code above. Now we\n+ * get an array. In this case the arrays elements are map entries:\n+ * <pre>   {@code\n+ *   [\n+ *     [\n+ *       {\n+ *         \"x\": 5,\n+ *         \"y\": 6\n+ *       },\n+ *       \"a\",\n+ *     ],\n+ *     [\n+ *       {\n+ *         \"x\": 8,\n+ *         \"y\": 8\n+ *       },\n+ *       \"b\"\n+ *     ]\n+ *   ]\n+ * }</pre>\n+ * This format will serialize and deserialize just fine as long as this adapter\n+ * is registered.\n+ *\n+ * <p>This adapter returns regular JSON objects for maps whose keys are not\n+ * complex. A key is complex if its JSON-serialized form is an array or an\n+ * object.\n+ */\n+public final class MapAsArrayTypeAdapter\n+    implements JsonSerializer<Map<?, ?>>, JsonDeserializer<Map<?, ?>> {\n+\n+  public Map<?, ?> deserialize(JsonElement json, Type typeOfT,\n+      JsonDeserializationContext context) throws JsonParseException {\n+    Map<Object, Object> result = new LinkedHashMap<Object, Object>();\n+    Type[] keyAndValueType = typeToTypeArguments(typeOfT);\n+    if (json.isJsonArray()) {\n+      JsonArray array = json.getAsJsonArray();\n+      for (int i = 0; i < array.size(); i++) {\n+        JsonArray entryArray = array.get(i).getAsJsonArray();\n+        Object k = context.deserialize(entryArray.get(0), keyAndValueType[0]);\n+        Object v = context.deserialize(entryArray.get(1), keyAndValueType[1]);\n+        result.put(k, v);\n+      }\n+      checkSize(array, array.size(), result, result.size());\n+    } else {\n+      JsonObject object = json.getAsJsonObject();\n+      for (Map.Entry<String, JsonElement> entry : object.entrySet()) {\n+        Object k = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueType[0]);\n+        Object v = context.deserialize(entry.getValue(), keyAndValueType[1]);\n+        result.put(k, v);\n+      }\n+      checkSize(object, object.entrySet().size(), result, result.size());\n+    }\n+    return result;\n+  }\n+\n+  public JsonElement serialize(Map<?, ?> src, Type typeOfSrc, JsonSerializationContext context) {\n+    Type[] keyAndValueType = typeToTypeArguments(typeOfSrc);\n+    boolean serializeAsArray = false;\n+    List<JsonElement> keysAndValues = new ArrayList<JsonElement>();\n+    for (Map.Entry<?, ?> entry : src.entrySet()) {\n+      JsonElement key = context.serialize(entry.getKey(), keyAndValueType[0]);\n+      serializeAsArray |= key.isJsonObject() || key.isJsonArray();\n+      keysAndValues.add(key);\n+      keysAndValues.add(context.serialize(entry.getValue(), keyAndValueType[1]));\n+    }\n+\n+    if (serializeAsArray) {\n+      JsonArray result = new JsonArray();\n+      for (int i = 0; i < keysAndValues.size(); i+=2) {\n+        JsonArray entryArray = new JsonArray();\n+        entryArray.add(keysAndValues.get(i));\n+        entryArray.add(keysAndValues.get(i + 1));\n+        result.add(entryArray);\n+      }\n+      return result;\n+    } else {\n+      JsonObject result = new JsonObject();\n+      for (int i = 0; i < keysAndValues.size(); i+=2) {\n+        result.add(keysAndValues.get(i).getAsString(), keysAndValues.get(i + 1));\n+      }\n+      checkSize(src, src.size(), result, result.entrySet().size());\n+      return result;\n+    }\n+  }\n+\n+  private Type[] typeToTypeArguments(Type typeOfT) {\n+    if (typeOfT instanceof ParameterizedType) {\n+      Type[] typeArguments = ((ParameterizedType) typeOfT).getActualTypeArguments();\n+      if (typeArguments.length != 2) {\n+        throw new IllegalArgumentException(\"MapAsArrayTypeAdapter cannot handle \" + typeOfT);\n+      }\n+      return typeArguments;\n+    }\n+    return new Type[] { Object.class, Object.class };\n+  }\n+\n+  private void checkSize(Object input, int inputSize, Object output, int outputSize) {\n+    if (inputSize != outputSize) {\n+      throw new JsonSyntaxException(\"Input size \" + inputSize + \" != output size \" + outputSize\n+          + \" for input \" + input + \" and output \" + output);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.MapAsArrayTypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+public class MapAsArrayTypeAdapterTest extends TestCase {\n+\n+  public void testSerializeComplexMapWithTypeAdapter() {\n+    Type type = new TypeToken<Map<Point, String>>() {}.getType();\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())\n+        .create();\n+\n+    Map<Point, String> original = new LinkedHashMap<Point, String>();\n+    original.put(new Point(5, 5), \"a\");\n+    original.put(new Point(8, 8), \"b\");\n+    String json = gson.toJson(original, type);\n+    assertEquals(\"[[{\\\"x\\\":5,\\\"y\\\":5},\\\"a\\\"],[{\\\"x\\\":8,\\\"y\\\":8},\\\"b\\\"]]\", json);\n+    assertEquals(original, gson.<Map<Point, String>>fromJson(json, type));\n+\n+    // test that registering a type adapter for one map doesn't interfere with others\n+    Map<String, Boolean> otherMap = new LinkedHashMap<String, Boolean>();\n+    otherMap.put(\"t\", true);\n+    otherMap.put(\"f\", false);\n+    assertEquals(\"{\\\"t\\\":true,\\\"f\\\":false}\",\n+        gson.toJson(otherMap, Map.class));\n+    assertEquals(\"{\\\"t\\\":true,\\\"f\\\":false}\",\n+        gson.toJson(otherMap, new TypeToken<Map<String, Boolean>>() {}.getType()));\n+    assertEquals(otherMap, gson.<Object>fromJson(\"{\\\"t\\\":true,\\\"f\\\":false}\",\n+        new TypeToken<Map<String, Boolean>>() {}.getType()));\n+  }\n+\n+  public void testTwoTypesCollapseToOneSerialize() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())\n+        .create();\n+\n+    Map<Number, String> original = new LinkedHashMap<Number, String>();\n+    original.put(new Double(1.0), \"a\");\n+    original.put(new Float(1.0), \"b\");\n+    try {\n+      gson.toJson(original, new TypeToken<Map<Number, String>>() {}.getType());\n+      fail();\n+    } catch (JsonSyntaxException expected) {\n+    }\n+  }\n+\n+  public void testTwoTypesCollapseToOneDeserialize() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())\n+        .create();\n+\n+    String s = \"[[\\\"1.00\\\",\\\"a\\\"],[\\\"1.0\\\",\\\"b\\\"]]\";\n+    try {\n+      gson.fromJson(s, new TypeToken<Map<Double, String>>() {}.getType());\n+      fail();\n+    } catch (JsonSyntaxException expected) {\n+    }\n+  }\n+\n+  static class Point {\n+    int x;\n+    int y;\n+    Point(int x, int y) {\n+      this.x = x;\n+      this.y = y;\n+    }\n+    Point() {}\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Point && ((Point) o).x == x && ((Point) o).y == y;\n+    }\n+    @Override public int hashCode() {\n+      return x * 37 + y;\n+    }\n+    @Override public String toString() {\n+      return \"(\" + x + \",\" + y + \")\";\n+    }\n+  }\n+}", "timestamp": 1294791441, "metainfo": ""}