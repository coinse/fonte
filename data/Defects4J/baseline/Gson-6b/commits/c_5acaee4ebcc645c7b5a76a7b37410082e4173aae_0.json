{"sha": "5acaee4ebcc645c7b5a76a7b37410082e4173aae", "log": "Check in our best Jackson vs. Gson comparison benchmarks. http://microbenchmarks.appspot.com/run/limpbizkit@gmail.com/com.google.gson.metrics.ParseBenchmark", "commit": "\n--- /dev/null\n+++ b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.metrics;\n+\n+import com.google.caliper.Param;\n+import com.google.caliper.Runner;\n+import com.google.caliper.SimpleBenchmark;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParser;\n+import com.google.gson.annotations.SerializedName;\n+import com.google.gson.reflect.TypeToken;\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.StringWriter;\n+import java.lang.reflect.Type;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+import org.codehaus.jackson.JsonFactory;\n+import org.codehaus.jackson.annotate.JsonProperty;\n+import org.codehaus.jackson.map.DeserializationConfig;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+\n+/**\n+ * Measure Gson and Jackson parsing and binding performance.\n+ *\n+ * <p>This benchmark requires that ParseBenchmarkData.zip is on the classpath.\n+ * That file contains Twitter feed data, which is representative of what\n+ * applications will be parsing.\n+ */\n+public final class ParseBenchmark extends SimpleBenchmark {\n+  @Param Document document;\n+  @Param Api api;\n+\n+  private enum Document {\n+    TWEETS(new TypeToken<List<Tweet>>() {}, new TypeReference<List<Tweet>>() {}),\n+    READER_SHORT(new TypeToken<Feed>() {}, new TypeReference<Feed>() {}),\n+    READER_LONG(new TypeToken<Feed>() {}, new TypeReference<Feed>() {});\n+\n+    private final Type gsonType;\n+    private final TypeReference<?> jacksonType;\n+\n+    private Document(TypeToken<?> typeToken, TypeReference<?> typeReference) {\n+      this.gsonType = typeToken.getType();\n+      this.jacksonType = typeReference;\n+    }\n+  }\n+\n+  private enum Api {\n+    JACKSON_STREAM {\n+      @Override Parser newParser() {\n+        return new JacksonStreamParser();\n+      }\n+    },\n+    JACKSON_BIND {\n+      @Override Parser newParser() {\n+        return new JacksonBindParser();\n+      }\n+    },\n+    GSON_STREAM {\n+      @Override Parser newParser() {\n+        return new GsonStreamParser();\n+      }\n+    },\n+    GSON_DOM {\n+      @Override Parser newParser() {\n+        return new GsonDomParser();\n+      }\n+    },\n+    GSON_BIND {\n+      @Override Parser newParser() {\n+        return new GsonBindParser();\n+      }\n+    };\n+    abstract Parser newParser();\n+  }\n+\n+  private char[] text;\n+  private Parser parser;\n+\n+  @Override protected void setUp() throws Exception {\n+    text = resourceToString(\"/\" + document.name() + \".json\").toCharArray();\n+    parser = api.newParser();\n+  }\n+\n+  public void timeParse(int reps) throws Exception {\n+    for (int i = 0; i < reps; i++) {\n+      parser.parse(text, document);\n+    }\n+  }\n+\n+  private static String resourceToString(String path) throws Exception {\n+    InputStream in = ParseBenchmark.class.getResourceAsStream(path);\n+    if (in == null) {\n+      throw new IllegalArgumentException(\"No such file: \" + path);\n+    }\n+\n+    Reader reader = new InputStreamReader(in, \"UTF-8\");\n+    char[] buffer = new char[8192];\n+    StringWriter writer = new StringWriter();\n+    int count;\n+    while ((count = reader.read(buffer)) != -1) {\n+      writer.write(buffer, 0, count);\n+    }\n+    reader.close();\n+    return writer.toString();\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    Runner.main(ParseBenchmark.class, args);\n+  }\n+\n+  interface Parser {\n+    void parse(char[] data, Document document) throws Exception;\n+  }\n+\n+  private static class GsonStreamParser implements Parser {\n+    public void parse(char[] data, Document document) throws Exception {\n+      com.google.gson.stream.JsonReader jsonReader\n+          = new com.google.gson.stream.JsonReader(new CharArrayReader(data));\n+      readToken(jsonReader);\n+      jsonReader.close();\n+    }\n+\n+    public void readObject(com.google.gson.stream.JsonReader reader) throws IOException {\n+      reader.beginObject();\n+      while (reader.hasNext()) {\n+        reader.nextName();\n+        readToken(reader);\n+      }\n+      reader.endObject();\n+    }\n+\n+    public void readArray(com.google.gson.stream.JsonReader reader) throws IOException {\n+      reader.beginArray();\n+      while (reader.hasNext()) {\n+        readToken(reader);\n+      }\n+      reader.endArray();\n+    }\n+\n+    private void readToken(com.google.gson.stream.JsonReader reader) throws IOException {\n+      switch (reader.peek()) {\n+      case BEGIN_ARRAY:\n+        readArray(reader);\n+        break;\n+      case BEGIN_OBJECT:\n+        readObject(reader);\n+        break;\n+      case BOOLEAN:\n+        reader.nextBoolean();\n+        break;\n+      case NULL:\n+        reader.nextNull();\n+        break;\n+      case NUMBER:\n+        reader.nextLong();\n+        break;\n+      case STRING:\n+        reader.nextString();\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unexpected token\" + reader.peek());\n+      }\n+    }\n+  }\n+\n+  private static class JacksonStreamParser implements Parser {\n+    public void parse(char[] data, Document document) throws Exception {\n+      JsonFactory jsonFactory = new JsonFactory();\n+      org.codehaus.jackson.JsonParser jp = jsonFactory.createJsonParser(new CharArrayReader(data));\n+      jp.configure(org.codehaus.jackson.JsonParser.Feature.CANONICALIZE_FIELD_NAMES, false);\n+      int depth = 0;\n+      do {\n+        switch (jp.nextToken()) {\n+        case START_OBJECT:\n+        case START_ARRAY:\n+          depth++;\n+          break;\n+        case END_OBJECT:\n+        case END_ARRAY:\n+          depth--;\n+          break;\n+        case FIELD_NAME:\n+          jp.getCurrentName();\n+          break;\n+        case VALUE_STRING:\n+          jp.getText();\n+          break;\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+          jp.getLongValue();\n+          break;\n+        }\n+      } while (depth > 0);\n+      jp.close();\n+    }\n+  }\n+\n+  private static class GsonDomParser implements Parser {\n+    public void parse(char[] data, Document document) throws Exception {\n+      new JsonParser().parse(new CharArrayReader(data));\n+    }\n+  }\n+\n+  private static class GsonBindParser implements Parser {\n+    private static Gson gson = new GsonBuilder()\n+        .setDateFormat(\"EEE MMM dd HH:mm:ss Z yyyy\")\n+        .create();\n+\n+    public void parse(char[] data, Document document) throws Exception {\n+      gson.fromJson(new CharArrayReader(data), document.gsonType);\n+    }\n+  }\n+\n+  private static class JacksonBindParser implements Parser {\n+    private static ObjectMapper mapper = new ObjectMapper();\n+\n+    static {\n+      mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+      mapper.configure(DeserializationConfig.Feature.AUTO_DETECT_FIELDS, true);\n+      mapper.setDateFormat(new SimpleDateFormat(\"EEE MMM dd HH:mm:ss Z yyyy\"));\n+    }\n+\n+    public void parse(char[] data, Document document) throws Exception {\n+      mapper.readValue(new CharArrayReader(data), document.jacksonType);\n+    }\n+  }\n+\n+  static class Tweet {\n+    @JsonProperty String coordinates;\n+    @JsonProperty boolean favorited;\n+    @JsonProperty Date created_at;\n+    @JsonProperty boolean truncated;\n+    @JsonProperty Tweet retweeted_status;\n+    @JsonProperty String id_str;\n+    @JsonProperty String in_reply_to_id_str;\n+    @JsonProperty String contributors;\n+    @JsonProperty String text;\n+    @JsonProperty long id;\n+    @JsonProperty String retweet_count;\n+    @JsonProperty String in_reply_to_status_id_str;\n+    @JsonProperty Object geo;\n+    @JsonProperty boolean retweeted;\n+    @JsonProperty String in_reply_to_user_id;\n+    @JsonProperty String in_reply_to_screen_name;\n+    @JsonProperty Object place;\n+    @JsonProperty User user;\n+    @JsonProperty String source;\n+    @JsonProperty String in_reply_to_user_id_str;\n+  }\n+\n+  static class User {\n+    @JsonProperty String name;\n+    @JsonProperty String profile_sidebar_border_color;\n+    @JsonProperty boolean profile_background_tile;\n+    @JsonProperty String profile_sidebar_fill_color;\n+    @JsonProperty Date created_at;\n+    @JsonProperty String location;\n+    @JsonProperty String profile_image_url;\n+    @JsonProperty boolean follow_request_sent;\n+    @JsonProperty String profile_link_color;\n+    @JsonProperty boolean is_translator;\n+    @JsonProperty String id_str;\n+    @JsonProperty int favourites_count;\n+    @JsonProperty boolean contributors_enabled;\n+    @JsonProperty String url;\n+    @JsonProperty boolean default_profile;\n+    @JsonProperty long utc_offset;\n+    @JsonProperty long id;\n+    @JsonProperty boolean profile_use_background_image;\n+    @JsonProperty int listed_count;\n+    @JsonProperty String lang;\n+    @JsonProperty(\"protected\") @SerializedName(\"protected\") boolean isProtected;\n+    @JsonProperty int followers_count;\n+    @JsonProperty String profile_text_color;\n+    @JsonProperty String profile_background_color;\n+    @JsonProperty String time_zone;\n+    @JsonProperty String description;\n+    @JsonProperty boolean notifications;\n+    @JsonProperty boolean geo_enabled;\n+    @JsonProperty boolean verified;\n+    @JsonProperty String profile_background_image_url;\n+    @JsonProperty boolean defalut_profile_image;\n+    @JsonProperty int friends_count;\n+    @JsonProperty int statuses_count;\n+    @JsonProperty String screen_name;\n+    @JsonProperty boolean following;\n+    @JsonProperty boolean show_all_inline_media;\n+  }\n+\n+  static class Feed {\n+    @JsonProperty String id;\n+    @JsonProperty String title;\n+    @JsonProperty String description;\n+    @JsonProperty(\"alternate\") @SerializedName(\"alternate\") List<Link> alternates;\n+    @JsonProperty long updated;\n+    @JsonProperty List<Item> items;\n+\n+    @Override public String toString() {\n+      StringBuilder result = new StringBuilder()\n+          .append(id)\n+          .append(\"\\n\").append(title)\n+          .append(\"\\n\").append(description)\n+          .append(\"\\n\").append(alternates)\n+          .append(\"\\n\").append(updated);\n+      int i = 1;\n+      for (Item item : items) {\n+        result.append(i++).append(\": \").append(item).append(\"\\n\\n\");\n+      }\n+      return result.toString();\n+    }\n+  }\n+\n+  static class Link {\n+    @JsonProperty String href;\n+\n+    @Override public String toString() {\n+      return href;\n+    }\n+  }\n+\n+  static class Item {\n+    @JsonProperty List<String> categories;\n+    @JsonProperty String title;\n+    @JsonProperty long published;\n+    @JsonProperty long updated;\n+    @JsonProperty(\"alternate\") @SerializedName(\"alternate\") List<Link> alternates;\n+    @JsonProperty Content content;\n+    @JsonProperty String author;\n+    @JsonProperty List<ReaderUser> likingUsers;\n+\n+    @Override public String toString() {\n+      return title\n+          + \"\\nauthor: \" + author\n+          + \"\\npublished: \" + published\n+          + \"\\nupdated: \" + updated\n+          + \"\\n\" + content\n+          + \"\\nliking users: \" + likingUsers\n+          + \"\\nalternates: \" + alternates\n+          + \"\\ncategories: \" + categories;\n+    }\n+  }\n+\n+  static class Content {\n+    @JsonProperty String content;\n+\n+    @Override public String toString() {\n+      return content;\n+    }\n+  }\n+\n+  static class ReaderUser {\n+    @JsonProperty String userId;\n+\n+    @Override public String toString() {\n+      return userId;\n+    }\n+  }\n+}", "timestamp": 1323932581, "metainfo": ""}