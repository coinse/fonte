{"sha": "3b3a60d301a66dfd1599c796c7f5b92e93972816", "log": "Use new instances of DateTypeAdapter and TimeTypeAdapter for each GSON; this guarantees that the TimeZone and Locale are what they should be", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.ArrayTypeAdapter;\n+import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n+import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n+import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n+import com.google.gson.internal.bind.DateTypeAdapter;\n+import com.google.gson.internal.bind.ExcludedTypeAdapterFactory;\n+import com.google.gson.internal.bind.MapTypeAdapterFactory;\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.ObjectTypeAdapter;\n+import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n+import com.google.gson.internal.bind.TimeTypeAdapter;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.internal.bind.TypeAdapters;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import com.google.gson.stream.MalformedJsonException;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.Reader;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-\n-import com.google.gson.internal.ConstructorConstructor;\n-import com.google.gson.internal.ParameterizedTypeHandlerMap;\n-import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.Streams;\n-import com.google.gson.internal.bind.ArrayTypeAdapter;\n-import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n-import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n-import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n-import com.google.gson.internal.bind.ExcludedTypeAdapterFactory;\n-import com.google.gson.internal.bind.MapTypeAdapterFactory;\n-import com.google.gson.internal.bind.MiniGson;\n-import com.google.gson.internal.bind.ObjectTypeAdapter;\n-import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n-import com.google.gson.internal.bind.TypeAdapter;\n-import com.google.gson.internal.bind.TypeAdapters;\n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n-import com.google.gson.stream.JsonWriter;\n-import com.google.gson.stream.MalformedJsonException;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n         .factory(TypeAdapters.LOCALE_FACTORY)\n         .factory(TypeAdapters.INET_ADDRESS_FACTORY)\n         .factory(TypeAdapters.BIT_SET_FACTORY)\n-        .factory(TypeAdapters.DATE_FACTORY)\n+        .factory(DateTypeAdapter.FACTORY)\n         .factory(TypeAdapters.CALENDAR_FACTORY)\n-        .factory(TypeAdapters.SQL_TIME_FACTORY)\n+        .factory(TimeTypeAdapter.FACTORY)\n         .factory(TypeAdapters.SQL_DATE_FACTORY)\n         .factory(TypeAdapters.SQL_TIMESTAMP_FACTORY)\n         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * Adapter for Time. Although this class appears stateless, it is not.\n+ * DateFormat captures its time zone and locale when it is created, which gives\n+ * this class state. DateFormat isn't thread safe either, so this class has\n+ * to synchronize its read and write methods.\n+ */\n+public final class DateTypeAdapter extends TypeAdapter<Date> {\n+  public static final Factory FACTORY = new Factory() {\n+    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n+    }\n+  };\n+\n+  private final DateFormat enUsFormat\n+      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);\n+  private final DateFormat localFormat\n+      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);\n+  private final DateFormat iso8601Format = buildIso8601Format();\n+\n+  private static DateFormat buildIso8601Format() {\n+    DateFormat iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n+    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return iso8601Format;\n+  }\n+\n+  @Override public Date read(JsonReader reader) throws IOException {\n+    return deserializeToDate(reader.nextString());\n+  }\n+\n+  private synchronized Date deserializeToDate(String json) {\n+    try {\n+      return localFormat.parse(json);\n+    } catch (ParseException ignored) {\n+    }\n+    try {\n+      return enUsFormat.parse(json);\n+    } catch (ParseException ignored) {\n+    }\n+    try {\n+      return iso8601Format.parse(json);\n+    } catch (ParseException e) {\n+      throw new JsonSyntaxException(json, e);\n+    }\n+  }\n+\n+  @Override public synchronized void write(JsonWriter writer, Date value) throws IOException {\n+    String dateFormatAsString = enUsFormat.format(value);\n+    writer.value(dateFormatAsString);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.sql.Time;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+/**\n+ * Adapter for Time. Although this class appears stateless, it is not.\n+ * DateFormat captures its time zone and locale when it is created, which gives\n+ * this class state. DateFormat isn't thread safe either, so this class has\n+ * to synchronize its read and write methods.\n+ */\n+public final class TimeTypeAdapter extends TypeAdapter<Time> {\n+  public static final Factory FACTORY = new Factory() {\n+    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n+    }\n+  };\n+\n+  private final DateFormat format = new SimpleDateFormat(\"hh:mm:ss a\");\n+\n+  @Override public synchronized Time read(JsonReader reader) throws IOException {\n+    try {\n+      Date date = format.parse(reader.nextString());\n+      return new Time(date.getTime());\n+    } catch (ParseException e) {\n+      throw new JsonSyntaxException(e);\n+    }\n+  }\n+\n+  @Override public synchronized void write(JsonWriter writer, Time value) throws IOException {\n+    writer.value(format.format(value));\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.JsonIOException;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.internal.LazilyParsedNumber;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n-import java.sql.Time;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.StringTokenizer;\n-import java.util.TimeZone;\n import java.util.UUID;\n-\n-import com.google.gson.JsonIOException;\n-import com.google.gson.JsonSyntaxException;\n-import com.google.gson.internal.LazilyParsedNumber;\n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n-import com.google.gson.stream.JsonWriter;\n \n /**\n  * Type adapters for basic types.\n     }\n   };\n \n-  private static DateFormat buildIso8601Format() {\n-    DateFormat iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n-    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    return iso8601Format;\n-  }\n-  \n-  public static final TypeAdapter<Date> DATE = new TypeAdapter<Date>() {\n-    private final DateFormat enUsFormat =\n-    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);\n-    private final DateFormat localFormat =\n-    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);\n-    private final DateFormat iso8601Format = buildIso8601Format();\n-    @Override\n-    public Date read(JsonReader reader) throws IOException {\n-      return deserializeToDate(reader.nextString());\n-    }\n-\n-    private Date deserializeToDate(String json) {\n-      synchronized (localFormat) {\n-        try {\n-          return localFormat.parse(json);\n-        } catch (ParseException ignored) {\n-        }\n-        try {\n-          return enUsFormat.parse(json);\n-        } catch (ParseException ignored) {\n-        }\n-        try {\n-          return iso8601Format.parse(json);\n-        } catch (ParseException e) {\n-          throw new JsonSyntaxException(json, e);\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void write(JsonWriter writer, Date value) throws IOException {\n-      synchronized (localFormat) {\n-        String dateFormatAsString = enUsFormat.format(value);\n-        writer.value(dateFormatAsString);\n-      }\n-    }\n-  };\n-\n-  public static final TypeAdapter.Factory DATE_FACTORY = newFactory(Date.class, DATE);\n-\n   public static final TypeAdapter.Factory UUID_FACTORY = newFactory(UUID.class, UUID);\n-\n-  public static final TypeAdapter<Time> SQL_TIME = new TypeAdapter<Time>() {\n-    private final DateFormat format = new SimpleDateFormat(\"hh:mm:ss a\");\n-    @Override\n-    public Time read(JsonReader reader) throws IOException {\n-      try {\n-        synchronized (format) {\n-          Date date = format.parse(reader.nextString());\n-          return new java.sql.Time(date.getTime());\n-        }\n-      } catch (ParseException e) {\n-        throw new JsonSyntaxException(e);\n-      }\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Time value) throws IOException {\n-      writer.value(format.format(value));\n-    }\n-  };\n-\n-  public static final TypeAdapter.Factory SQL_TIME_FACTORY = newFactory(Time.class, SQL_TIME);\n \n   private static final class TimestampTypeAdapter extends TypeAdapter<Timestamp> {\n     private final MiniGson context;", "timestamp": 1317073448, "metainfo": ""}