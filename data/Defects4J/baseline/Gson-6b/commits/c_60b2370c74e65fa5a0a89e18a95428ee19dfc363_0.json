{"sha": "60b2370c74e65fa5a0a89e18a95428ee19dfc363", "log": "added a test for RuntimeTypeAdapterFactory using JsonAdapter annotation", "commit": "\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n     }\n     static final class JsonAdapterFactory implements TypeAdapterFactory {\n       public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n-\n-        // Ensure that gson.getDelegateAdapter continues to work for type adapter factories\n-        // registered through JsonAdapter annotation. Query for a random type adapter.\n-        gson.getDelegateAdapter(this, TypeToken.get(JsonAdapterAnnotationOnFieldsTest.class));\n-\n         return new TypeAdapter<T>() {\n           @Override public void write(JsonWriter out, T value) throws IOException {\n             out.value(\"jsonAdapterFactory\");\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.annotations.JsonAdapter;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for the RuntimeTypeAdapterFactory feature in extras.\n+ */\n+public final class RuntimeTypeAdapterFactoryFunctionalTest extends TestCase {\n+\n+  private final Gson gson = new Gson();\n+\n+  /**\n+   * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}\n+   * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.\n+   */\n+  public void testSubclassesAutomaticallySerialzed() throws Exception {\n+    Shape shape = new Circle(25);\n+    String json = gson.toJson(shape);\n+    shape = gson.fromJson(json, Shape.class);\n+    assertEquals(25, ((Circle)shape).radius);\n+\n+    shape = new Square(15);\n+    json = gson.toJson(shape);\n+    shape = gson.fromJson(json, Shape.class);\n+    assertEquals(15, ((Square)shape).side);\n+  }\n+\n+  @JsonAdapter(Shape.JsonAdapterFactory.class)\n+  static class Shape {\n+    final ShapeType type;\n+    Shape(ShapeType type) { this.type = type; }\n+    private static final class JsonAdapterFactory extends RuntimeTypeAdapterFactory<Shape> {\n+      public JsonAdapterFactory() {\n+        super(Shape.class, \"type\");\n+        registerSubtype(Circle.class, ShapeType.CIRCLE.toString());\n+        registerSubtype(Square.class, ShapeType.SQUARE.toString());\n+      }\n+    }\n+  }\n+\n+  public enum ShapeType {\n+    SQUARE, CIRCLE\n+  }\n+\n+  private static final class Circle extends Shape {\n+    final int radius;\n+    Circle(int radius) { super(ShapeType.CIRCLE); this.radius = radius; }\n+  }\n+\n+  private static final class Square extends Shape {\n+    final int side;\n+    Square(int side) { super(ShapeType.SQUARE); this.side = side; }\n+  }\n+\n+  // Copied from the extras package\n+  static class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {\n+    private final Class<?> baseType;\n+    private final String typeFieldName;\n+    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();\n+    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();\n+\n+    protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {\n+      if (typeFieldName == null || baseType == null) {\n+        throw new NullPointerException();\n+      }\n+      this.baseType = baseType;\n+      this.typeFieldName = typeFieldName;\n+    }\n+\n+    /**\n+     * Creates a new runtime type adapter using for {@code baseType} using {@code\n+     * typeFieldName} as the type field name. Type field names are case sensitive.\n+     */\n+    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {\n+      return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);\n+    }\n+\n+    /**\n+     * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\n+     * the type field name.\n+     */\n+    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {\n+      return new RuntimeTypeAdapterFactory<T>(baseType, \"type\");\n+    }\n+\n+    /**\n+     * Registers {@code type} identified by {@code label}. Labels are case\n+     * sensitive.\n+     *\n+     * @throws IllegalArgumentException if either {@code type} or {@code label}\n+     *     have already been registered on this type adapter.\n+     */\n+    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {\n+      if (type == null || label == null) {\n+        throw new NullPointerException();\n+      }\n+      if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\n+        throw new IllegalArgumentException(\"types and labels must be unique\");\n+      }\n+      labelToSubtype.put(label, type);\n+      subtypeToLabel.put(type, label);\n+      return this;\n+    }\n+\n+    /**\n+     * Registers {@code type} identified by its {@link Class#getSimpleName simple\n+     * name}. Labels are case sensitive.\n+     *\n+     * @throws IllegalArgumentException if either {@code type} or its simple name\n+     *     have already been registered on this type adapter.\n+     */\n+    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {\n+      return registerSubtype(type, type.getSimpleName());\n+    }\n+\n+    public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {\n+      if (type.getRawType() != baseType) {\n+        return null;\n+      }\n+\n+      final Map<String, TypeAdapter<?>> labelToDelegate\n+          = new LinkedHashMap<String, TypeAdapter<?>>();\n+      final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n+          = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n+      for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n+        TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\n+        labelToDelegate.put(entry.getKey(), delegate);\n+        subtypeToDelegate.put(entry.getValue(), delegate);\n+      }\n+\n+      return new TypeAdapter<R>() {\n+        @Override public R read(JsonReader in) throws IOException {\n+          JsonElement jsonElement = Streams.parse(in);\n+          JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\n+          if (labelJsonElement == null) {\n+            throw new JsonParseException(\"cannot deserialize \" + baseType\n+                + \" because it does not define a field named \" + typeFieldName);\n+          }\n+          String label = labelJsonElement.getAsString();\n+          @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n+          TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);\n+          if (delegate == null) {\n+            throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n+                + label + \"; did you forget to register a subtype?\");\n+          }\n+          return delegate.fromJsonTree(jsonElement);\n+        }\n+\n+        @Override public void write(JsonWriter out, R value) throws IOException {\n+          Class<?> srcType = value.getClass();\n+          String label = subtypeToLabel.get(srcType);\n+          @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n+          TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);\n+          if (delegate == null) {\n+            throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n+                + \"; did you forget to register a subtype?\");\n+          }\n+          JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\n+          if (!jsonObject.has(typeFieldName)) {\n+            JsonObject clone = new JsonObject();\n+            clone.add(typeFieldName, new JsonPrimitive(label));\n+            for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {\n+              clone.add(e.getKey(), e.getValue());\n+            }\n+            jsonObject = clone;\n+          }\n+          Streams.write(jsonObject, out);\n+        }\n+      };\n+    }\n+  }\n+}", "timestamp": 1415743460, "metainfo": ""}