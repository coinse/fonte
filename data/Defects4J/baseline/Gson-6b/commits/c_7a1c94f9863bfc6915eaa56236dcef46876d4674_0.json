{"sha": "7a1c94f9863bfc6915eaa56236dcef46876d4674", "log": "Remove synthetic accessors from being generated.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n    * Converts the field name that uses camel-case define word separation into\n    * separate words that are separated by the provided {@code separatorString}.\n    */\n-  private static String separateCamelCase(String name, String separator) {\n+  static String separateCamelCase(String name, String separator) {\n     StringBuilder translation = new StringBuilder();\n     for (int i = 0; i < name.length(); i++) {\n       char character = name.charAt(i);\n   /**\n    * Ensures the JSON field names begins with an upper case letter.\n    */\n-  private static String upperCaseFirstLetter(String name) {\n+  static String upperCaseFirstLetter(String name) {\n     StringBuilder fieldNameBuilder = new StringBuilder();\n     int index = 0;\n     char firstCharacter = name.charAt(index);\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     };\n   }\n \n-  private void checkValidFloatingPoint(double value) {\n+  static void checkValidFloatingPoint(double value) {\n     if (Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(value\n           + \" is not a valid double value as per JSON specification. To override this\"\n    *  }</pre>\n    *  Note that this call will skip all factories registered before {@code skipPast}. In case of\n    *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n-   *  that the order of registration does not prevent this method from reaching a factory they \n+   *  that the order of registration does not prevent this method from reaching a factory they\n    *  would expect to reply from this call.\n    *  Note that since you can not override type adapter factories for String and Java primitive\n    *  types, our stats factory will not count the number of String or primitives that will be\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n   /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n   private TypeAdapter<T> delegate;\n \n-  private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n+  TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n     this.serializer = serializer;\n     this.deserializer = deserializer;\n     private final JsonSerializer<?> serializer;\n     private final JsonDeserializer<?> deserializer;\n \n-    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n+    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n         Class<?> hierarchyType) {\n       serializer = typeAdapter instanceof JsonSerializer\n           ? (JsonSerializer<?>) typeAdapter\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n \n package com.google.gson.internal;\n \n-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n-\n import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n import java.util.NoSuchElementException;\n import java.util.Properties;\n \n+import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n+import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n+\n /**\n  * Static methods for working with types.\n  *\n     }\n   }\n \n-  private static int hashCodeOrZero(Object o) {\n+  static int hashCodeOrZero(Object o) {\n     return o != null ? o.hashCode() : 0;\n   }\n \n         : null;\n   }\n \n-  private static void checkNotPrimitive(Type type) {\n+  static void checkNotPrimitive(Type type) {\n     checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java\n     Node<K, V> lastReturned = null;\n     int expectedModCount = modCount;\n \n+    LinkedTreeMapIterator() {\n+    }\n+\n     public final boolean hasNext() {\n       return next != header;\n     }\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n     Node<K, V> lastReturned = null;\n     int expectedModCount = modCount;\n \n+    LinkedTreeMapIterator() {\n+    }\n+\n     public final boolean hasNext() {\n       return next != header;\n     }\n   private Object writeReplace() throws ObjectStreamException {\n     return new LinkedHashMap<K, V>(this);\n   }\n-}\n+}\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     private final Appendable appendable;\n     private final CurrentWrite currentWrite = new CurrentWrite();\n \n-    private AppendableWriter(Appendable appendable) {\n+    AppendableWriter(Appendable appendable) {\n       this.appendable = appendable;\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n  */\n public final class MapTypeAdapterFactory implements TypeAdapterFactory {\n   private final ConstructorConstructor constructorConstructor;\n-  private final boolean complexMapKeySerialization;\n+  final boolean complexMapKeySerialization;\n \n   public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n       boolean complexMapKeySerialization) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n \n   private final Gson gson;\n \n-  private ObjectTypeAdapter(Gson gson) {\n+  ObjectTypeAdapter(Gson gson) {\n     this.gson = gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n-\n-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n \n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n \n /**\n  * Type adapter that reflects over the fields and methods of a class.\n     };\n   }\n \n-  private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n+  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n     if (annotation != null) {\n       TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n     private final ObjectConstructor<T> constructor;\n     private final Map<String, BoundField> boundFields;\n \n-    private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n       this.constructor = constructor;\n       this.boundFields = boundFields;\n     }\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   private int lineNumber = 0;\n   private int lineStart = 0;\n \n-  private int peeked = PEEKED_NONE;\n+  int peeked = PEEKED_NONE;\n \n   /**\n    * A peeked value that was composed entirely of digits with an optional\n     }\n   }\n \n-  private int doPeek() throws IOException {\n+  int doPeek() throws IOException {\n     int peekStack = stack[stackSize - 1];\n     if (peekStack == JsonScope.EMPTY_ARRAY) {\n       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n     return false;\n   }\n \n-  private int getLineNumber() {\n+  int getLineNumber() {\n     return lineNumber + 1;\n   }\n \n-  private int getColumnNumber() {\n+  int getColumnNumber() {\n     return pos - lineStart + 1;\n   }\n ", "timestamp": 1451198359, "metainfo": ""}