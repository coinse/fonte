{"sha": "6ec6caa49da4fb28dcf51428dcb45838d98b7966", "log": "New extension: handle circular references.  Serialize graphs of objects by assigning each instance a generated ID and writing the complete graph out as a list. The output for a cycle of Rock/Scissors/Paper looks like this:  {   '0x1':{'name':'ROCK','beats':'0x2'},   '0x2':{'name':'SCISSORS','beats':'0x3'},   '0x3':{'name':'PAPER','beats':'0x1'} }  This is work towards issue 137. The hard part is going to be deserializing that back into a graph.", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.graph;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+/**\n+ * Writes a graph of objects as a list of named nodes.\n+ */\n+// TODO: proper documentation\n+public final class GraphTypeAdapterFactory implements TypeAdapterFactory {\n+  private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<Graph>();\n+  private final Set<Type> graphTypes;\n+\n+  private GraphTypeAdapterFactory(Type... graphTypes) {\n+    this.graphTypes = new HashSet<Type>();\n+    this.graphTypes.addAll(Arrays.asList(graphTypes));\n+  }\n+\n+  public static GraphTypeAdapterFactory of(Type... graphTypes) {\n+    return new GraphTypeAdapterFactory(graphTypes);\n+  }\n+\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+    if (!graphTypes.contains(type.getType())) {\n+      return null;\n+    }\n+\n+    final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n+    return new TypeAdapter<T>() {\n+      @Override public void write(JsonWriter out, T value) throws IOException {\n+        if (value == null) {\n+          out.nullValue();\n+          return;\n+        }\n+\n+        Graph graph = graphThreadLocal.get();\n+\n+        // this is the top-level object in the graph; write the whole graph recursively\n+        if (graph == null) {\n+          graph = new Graph();\n+          graphThreadLocal.set(graph);\n+          Element element = new Element<T>(value, graph.elements.size() + 1, typeAdapter);\n+          graph.elements.put(value, element);\n+          graph.queue.add(element);\n+\n+          out.beginObject();\n+          Element current;\n+          while ((current = graph.queue.poll()) != null) {\n+            out.name(current.getName());\n+            current.write(out);\n+          }\n+          out.endObject();\n+          graphThreadLocal.remove();\n+\n+        // this is an element nested in the graph; just reference it by ID\n+        } else {\n+          Element element = graph.elements.get(value);\n+          if (element == null) {\n+            element = new Element<T>(value, graph.elements.size() + 1, typeAdapter);\n+            graph.elements.put(value, element);\n+            graph.queue.add(element);\n+          }\n+          out.value(element.getName());\n+        }\n+      }\n+\n+      @Override public T read(JsonReader in) throws IOException {\n+        // TODO:\n+        return null;\n+      }\n+    };\n+  }\n+\n+  static class Graph {\n+    private final Map<Object, Element> elements = new IdentityHashMap<Object, Element>();\n+    private final Queue<Element> queue = new LinkedList<Element>();\n+  }\n+\n+  static class Element<T> {\n+    private final T value;\n+    private final int id;\n+    private final TypeAdapter<T> typeAdapter;\n+    Element(T value, int id, TypeAdapter<T> typeAdapter) {\n+      this.value = value;\n+      this.id = id;\n+      this.typeAdapter = typeAdapter;\n+    }\n+    private String getName() {\n+      return \"0x\" + Integer.toHexString(id);\n+    }\n+    private void write(JsonWriter out) throws IOException {\n+      typeAdapter.write(out, value);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/test/java/com/google/gson/graph/GraphTypeAdapterFactoryTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.graph;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import junit.framework.TestCase;\n+\n+public final class GraphTypeAdapterFactoryTest extends TestCase {\n+  public void testBasicCycle() {\n+    Roshambo rock = new Roshambo(\"ROCK\");\n+    Roshambo scissors = new Roshambo(\"SCISSORS\");\n+    Roshambo paper = new Roshambo(\"PAPER\");\n+    rock.beats = scissors;\n+    scissors.beats = paper;\n+    paper.beats = rock;\n+\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapterFactory(GraphTypeAdapterFactory.of(Roshambo.class))\n+        .create();\n+\n+    assertEquals(\"{'0x1':{'name':'ROCK','beats':'0x2'},\" +\n+        \"'0x2':{'name':'SCISSORS','beats':'0x3'},\" +\n+        \"'0x3':{'name':'PAPER','beats':'0x1'}}\",\n+        gson.toJson(rock).replace('\\\"', '\\''));\n+  }\n+\n+  static class Roshambo {\n+    String name;\n+    Roshambo beats;\n+    Roshambo(String name) {\n+      this.name = name;\n+    }\n+  }\n+}", "timestamp": 1325230483, "metainfo": ""}