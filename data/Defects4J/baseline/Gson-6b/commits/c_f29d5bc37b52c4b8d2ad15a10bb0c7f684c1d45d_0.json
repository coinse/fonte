{"sha": "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d", "log": "Create a LinkedTreeMap based on the LinkedHashTreeMap; however, removed all the hashing from it as resorted to a single tree. The insertion order is still preserved.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.LinkedHashTreeMap;\n+import com.google.gson.internal.LinkedTreeMap;\n \n import java.util.Map;\n import java.util.Set;\n  * @author Joel Leitch\n  */\n public final class JsonObject extends JsonElement {\n-  private final LinkedHashTreeMap<String, JsonElement> members =\n-      new LinkedHashTreeMap<String, JsonElement>();\n+  private final LinkedTreeMap<String, JsonElement> members =\n+      new LinkedTreeMap<String, JsonElement>();\n \n   @Override\n   JsonObject deepCopy() {\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n       } else {\n         return new ObjectConstructor<T>() {\n           public T construct() {\n-            return (T) new LinkedHashTreeMap<String, Object>();\n+            return (T) new LinkedTreeMap<String, Object>();\n           }\n         };\n       }\n \n     return null;\n   }\n-\n \n   private <T> ObjectConstructor<T> newUnsafeAllocator(\n       final Type type, final Class<? super T> rawType) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+/*\n+ * Copyright (C) 2010 The Android Open Source Project\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses\n+ * insertion order for iteration order. Comparison order is only used as an\n+ * optimization for efficient insertion and removal.\n+ *\n+ * <p>This implementation was derived from Android 4.1's TreeMap class.\n+ */\n+public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // to avoid Comparable<Comparable<Comparable<...>>>\n+  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n+    public int compare(Comparable a, Comparable b) {\n+      return a.compareTo(b);\n+    }\n+  };\n+\n+  Comparator<? super K> comparator;\n+  Node<K, V> root;\n+  int size = 0;\n+  int modCount = 0;\n+\n+  // Used to preserve iteration order\n+  final Node<K, V> header = new Node<K, V>();\n+\n+  /**\n+   * Create a natural order, empty tree map whose keys must be mutually\n+   * comparable and non-null.\n+   */\n+  @SuppressWarnings(\"unchecked\") // unsafe! this assumes K is comparable\n+  public LinkedTreeMap() {\n+    this((Comparator<? super K>) NATURAL_ORDER);\n+  }\n+\n+  /**\n+   * Create a tree map ordered by {@code comparator}. This map's keys may only\n+   * be null if {@code comparator} permits.\n+   *\n+   * @param comparator the comparator to order elements with, or {@code null} to\n+   *     use the natural ordering.\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // unsafe! if comparator is null, this assumes K is comparable\n+  public LinkedTreeMap(Comparator<? super K> comparator) {\n+    this.comparator = comparator != null\n+        ? comparator\n+        : (Comparator) NATURAL_ORDER;\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public V get(Object key) {\n+    Node<K, V> node = findByObject(key);\n+    return node != null ? node.value : null;\n+  }\n+\n+  @Override public boolean containsKey(Object key) {\n+    return findByObject(key) != null;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    if (key == null) {\n+      throw new NullPointerException(\"key == null\");\n+    }\n+    Node<K, V> created = find(key, true);\n+    V result = created.value;\n+    created.value = value;\n+    return result;\n+  }\n+\n+  @Override public void clear() {\n+    root = null;\n+    size = 0;\n+    modCount++;\n+\n+    // Clear iteration order\n+    Node<K, V> header = this.header;\n+    header.next = header.prev = header;\n+  }\n+\n+  @Override public V remove(Object key) {\n+    Node<K, V> node = removeInternalByKey(key);\n+    return node != null ? node.value : null;\n+  }\n+\n+  /**\n+   * Returns the node at or adjacent to the given key, creating it if requested.\n+   *\n+   * @throws ClassCastException if {@code key} and the tree's keys aren't\n+   *     mutually comparable.\n+   */\n+  Node<K, V> find(K key, boolean create) {\n+    Comparator<? super K> comparator = this.comparator;\n+    Node<K, V> nearest = root;\n+    int comparison = 0;\n+\n+    if (nearest != null) {\n+      // Micro-optimization: avoid polymorphic calls to Comparator.compare().\n+      @SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\n+          Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n+          ? (Comparable<Object>) key\n+          : null;\n+\n+      while (true) {\n+        comparison = (comparableKey != null)\n+            ? comparableKey.compareTo(nearest.key)\n+            : comparator.compare(key, nearest.key);\n+\n+        // We found the requested key.\n+        if (comparison == 0) {\n+          return nearest;\n+        }\n+\n+        // If it exists, the key is in a subtree. Go deeper.\n+        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\n+        if (child == null) {\n+          break;\n+        }\n+\n+        nearest = child;\n+      }\n+    }\n+\n+    // The key doesn't exist in this tree.\n+    if (!create) {\n+      return null;\n+    }\n+\n+    // Create the node and add it to the tree or the table.\n+    Node<K, V> header = this.header;\n+    Node<K, V> created;\n+    if (nearest == null) {\n+      // Check that the value is comparable if we didn't do any comparisons.\n+      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\n+        throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n+      }\n+      created = new Node<K, V>(nearest, key, header, header.prev);\n+      root = created;\n+    } else {\n+      created = new Node<K, V>(nearest, key, header, header.prev);\n+      if (comparison < 0) { // nearest.key is higher\n+        nearest.left = created;\n+      } else { // comparison > 0, nearest.key is lower\n+        nearest.right = created;\n+      }\n+      rebalance(nearest, true);\n+    }\n+    size++;\n+    modCount++;\n+\n+    return created;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  Node<K, V> findByObject(Object key) {\n+    try {\n+      return key != null ? find((K) key, false) : null;\n+    } catch (ClassCastException e) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns this map's entry that has the same key and value as {@code\n+   * entry}, or null if this map has no such entry.\n+   *\n+   * <p>This method uses the comparator for key equality rather than {@code\n+   * equals}. If this map's comparator isn't consistent with equals (such as\n+   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\n+   * contains()} will violate the collections API.\n+   */\n+  Node<K, V> findByEntry(Entry<?, ?> entry) {\n+    Node<K, V> mine = findByObject(entry.getKey());\n+    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\n+    return valuesEqual ? mine : null;\n+  }\n+\n+  private boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Removes {@code node} from this tree, rearranging the tree's structure as\n+   * necessary.\n+   *\n+   * @param unlink true to also unlink this node from the iteration linked list.\n+   */\n+  void removeInternal(Node<K, V> node, boolean unlink) {\n+    if (unlink) {\n+      node.prev.next = node.next;\n+      node.next.prev = node.prev;\n+    }\n+\n+    Node<K, V> left = node.left;\n+    Node<K, V> right = node.right;\n+    Node<K, V> originalParent = node.parent;\n+    if (left != null && right != null) {\n+\n+      /*\n+       * To remove a node with both left and right subtrees, move an\n+       * adjacent node from one of those subtrees into this node's place.\n+       *\n+       * Removing the adjacent node may change this node's subtrees. This\n+       * node may no longer have two subtrees once the adjacent node is\n+       * gone!\n+       */\n+\n+      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\n+      removeInternal(adjacent, false); // takes care of rebalance and size--\n+\n+      int leftHeight = 0;\n+      left = node.left;\n+      if (left != null) {\n+        leftHeight = left.height;\n+        adjacent.left = left;\n+        left.parent = adjacent;\n+        node.left = null;\n+      }\n+\n+      int rightHeight = 0;\n+      right = node.right;\n+      if (right != null) {\n+        rightHeight = right.height;\n+        adjacent.right = right;\n+        right.parent = adjacent;\n+        node.right = null;\n+      }\n+\n+      adjacent.height = Math.max(leftHeight, rightHeight) + 1;\n+      replaceInParent(node, adjacent);\n+      return;\n+    } else if (left != null) {\n+      replaceInParent(node, left);\n+      node.left = null;\n+    } else if (right != null) {\n+      replaceInParent(node, right);\n+      node.right = null;\n+    } else {\n+      replaceInParent(node, null);\n+    }\n+\n+    rebalance(originalParent, false);\n+    size--;\n+    modCount++;\n+  }\n+\n+  Node<K, V> removeInternalByKey(Object key) {\n+    Node<K, V> node = findByObject(key);\n+    if (node != null) {\n+      removeInternal(node, true);\n+    }\n+    return node;\n+  }\n+\n+  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\n+    Node<K, V> parent = node.parent;\n+    node.parent = null;\n+    if (replacement != null) {\n+      replacement.parent = parent;\n+    }\n+\n+    if (parent != null) {\n+      if (parent.left == node) {\n+        parent.left = replacement;\n+      } else {\n+        assert (parent.right == node);\n+        parent.right = replacement;\n+      }\n+    } else {\n+      root = replacement;\n+    }\n+  }\n+\n+  /**\n+   * Rebalances the tree by making any AVL rotations necessary between the\n+   * newly-unbalanced node and the tree's root.\n+   *\n+   * @param insert true if the node was unbalanced by an insert; false if it\n+   *     was by a removal.\n+   */\n+  private void rebalance(Node<K, V> unbalanced, boolean insert) {\n+    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\n+      Node<K, V> left = node.left;\n+      Node<K, V> right = node.right;\n+      int leftHeight = left != null ? left.height : 0;\n+      int rightHeight = right != null ? right.height : 0;\n+\n+      int delta = leftHeight - rightHeight;\n+      if (delta == -2) {\n+        Node<K, V> rightLeft = right.left;\n+        Node<K, V> rightRight = right.right;\n+        int rightRightHeight = rightRight != null ? rightRight.height : 0;\n+        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\n+\n+        int rightDelta = rightLeftHeight - rightRightHeight;\n+        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\n+          rotateLeft(node); // AVL right right\n+        } else {\n+          assert (rightDelta == 1);\n+          rotateRight(right); // AVL right left\n+          rotateLeft(node);\n+        }\n+        if (insert) {\n+          break; // no further rotations will be necessary\n+        }\n+\n+      } else if (delta == 2) {\n+        Node<K, V> leftLeft = left.left;\n+        Node<K, V> leftRight = left.right;\n+        int leftRightHeight = leftRight != null ? leftRight.height : 0;\n+        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\n+\n+        int leftDelta = leftLeftHeight - leftRightHeight;\n+        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\n+          rotateRight(node); // AVL left left\n+        } else {\n+          assert (leftDelta == -1);\n+          rotateLeft(left); // AVL left right\n+          rotateRight(node);\n+        }\n+        if (insert) {\n+          break; // no further rotations will be necessary\n+        }\n+\n+      } else if (delta == 0) {\n+        node.height = leftHeight + 1; // leftHeight == rightHeight\n+        if (insert) {\n+          break; // the insert caused balance, so rebalancing is done!\n+        }\n+\n+      } else {\n+        assert (delta == -1 || delta == 1);\n+        node.height = Math.max(leftHeight, rightHeight) + 1;\n+        if (!insert) {\n+          break; // the height hasn't changed, so rebalancing is done!\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rotates the subtree so that its root's right child is the new root.\n+   */\n+  private void rotateLeft(Node<K, V> root) {\n+    Node<K, V> left = root.left;\n+    Node<K, V> pivot = root.right;\n+    Node<K, V> pivotLeft = pivot.left;\n+    Node<K, V> pivotRight = pivot.right;\n+\n+    // move the pivot's left child to the root's right\n+    root.right = pivotLeft;\n+    if (pivotLeft != null) {\n+      pivotLeft.parent = root;\n+    }\n+\n+    replaceInParent(root, pivot);\n+\n+    // move the root to the pivot's left\n+    pivot.left = root;\n+    root.parent = pivot;\n+\n+    // fix heights\n+    root.height = Math.max(left != null ? left.height : 0,\n+        pivotLeft != null ? pivotLeft.height : 0) + 1;\n+    pivot.height = Math.max(root.height,\n+        pivotRight != null ? pivotRight.height : 0) + 1;\n+  }\n+\n+  /**\n+   * Rotates the subtree so that its root's left child is the new root.\n+   */\n+  private void rotateRight(Node<K, V> root) {\n+    Node<K, V> pivot = root.left;\n+    Node<K, V> right = root.right;\n+    Node<K, V> pivotLeft = pivot.left;\n+    Node<K, V> pivotRight = pivot.right;\n+\n+    // move the pivot's right child to the root's left\n+    root.left = pivotRight;\n+    if (pivotRight != null) {\n+      pivotRight.parent = root;\n+    }\n+\n+    replaceInParent(root, pivot);\n+\n+    // move the root to the pivot's right\n+    pivot.right = root;\n+    root.parent = pivot;\n+\n+    // fixup heights\n+    root.height = Math.max(right != null ? right.height : 0,\n+        pivotRight != null ? pivotRight.height : 0) + 1;\n+    pivot.height = Math.max(root.height,\n+        pivotLeft != null ? pivotLeft.height : 0) + 1;\n+  }\n+\n+  private EntrySet entrySet;\n+  private KeySet keySet;\n+\n+  @Override public Set<Entry<K, V>> entrySet() {\n+    EntrySet result = entrySet;\n+    return result != null ? result : (entrySet = new EntrySet());\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    KeySet result = keySet;\n+    return result != null ? result : (keySet = new KeySet());\n+  }\n+\n+  static final class Node<K, V> implements Entry<K, V> {\n+    Node<K, V> parent;\n+    Node<K, V> left;\n+    Node<K, V> right;\n+    Node<K, V> next;\n+    Node<K, V> prev;\n+    final K key;\n+    V value;\n+    int height;\n+\n+    /** Create the header entry */\n+    Node() {\n+      key = null;\n+      next = prev = this;\n+    }\n+\n+    /** Create a regular entry */\n+    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\n+      this.parent = parent;\n+      this.key = key;\n+      this.height = 1;\n+      this.next = next;\n+      this.prev = prev;\n+      prev.next = this;\n+      next.prev = this;\n+    }\n+\n+    public K getKey() {\n+      return key;\n+    }\n+\n+    public V getValue() {\n+      return value;\n+    }\n+\n+    public V setValue(V value) {\n+      V oldValue = this.value;\n+      this.value = value;\n+      return oldValue;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override public boolean equals(Object o) {\n+      if (o instanceof Entry) {\n+        Entry other = (Entry) o;\n+        return (key == null ? other.getKey() == null : key.equals(other.getKey()))\n+            && (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+      }\n+      return false;\n+    }\n+\n+    @Override public int hashCode() {\n+      return (key == null ? 0 : key.hashCode())\n+          ^ (value == null ? 0 : value.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      return key + \"=\" + value;\n+    }\n+\n+    /**\n+     * Returns the first node in this subtree.\n+     */\n+    public Node<K, V> first() {\n+      Node<K, V> node = this;\n+      Node<K, V> child = node.left;\n+      while (child != null) {\n+        node = child;\n+        child = node.left;\n+      }\n+      return node;\n+    }\n+\n+    /**\n+     * Returns the last node in this subtree.\n+     */\n+    public Node<K, V> last() {\n+      Node<K, V> node = this;\n+      Node<K, V> child = node.right;\n+      while (child != null) {\n+        node = child;\n+        child = node.right;\n+      }\n+      return node;\n+    }\n+  }\n+\n+  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {\n+    Node<K, V> next = header.next;\n+    Node<K, V> lastReturned = null;\n+    int expectedModCount = modCount;\n+\n+    public final boolean hasNext() {\n+      return next != header;\n+    }\n+\n+    final Node<K, V> nextNode() {\n+      Node<K, V> e = next;\n+      if (e == header) {\n+        throw new NoSuchElementException();\n+      }\n+      if (modCount != expectedModCount) {\n+        throw new ConcurrentModificationException();\n+      }\n+      next = e.next;\n+      return lastReturned = e;\n+    }\n+\n+    public final void remove() {\n+      if (lastReturned == null) {\n+        throw new IllegalStateException();\n+      }\n+      removeInternal(lastReturned, true);\n+      lastReturned = null;\n+      expectedModCount = modCount;\n+    }\n+  }\n+\n+  class EntrySet extends AbstractSet<Entry<K, V>> {\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    @Override public Iterator<Entry<K, V>> iterator() {\n+      return new LinkedTreeMapIterator<Entry<K, V>>() {\n+        public Entry<K, V> next() {\n+          return nextNode();\n+        }\n+      };\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;\n+    }\n+\n+    @Override public boolean remove(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+\n+      Node<K, V> node = findByEntry((Entry<?, ?>) o);\n+      if (node == null) {\n+        return false;\n+      }\n+      removeInternal(node, true);\n+      return true;\n+    }\n+\n+    @Override public void clear() {\n+      LinkedTreeMap.this.clear();\n+    }\n+  }\n+\n+  class KeySet extends AbstractSet<K> {\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    @Override public Iterator<K> iterator() {\n+      return new LinkedTreeMapIterator<K>() {\n+        public K next() {\n+          return nextNode().key;\n+        }\n+      };\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+\n+    @Override public boolean remove(Object key) {\n+      return removeInternalByKey(key) != null;\n+    }\n+\n+    @Override public void clear() {\n+      LinkedTreeMap.this.clear();\n+    }\n+  }\n+\n+  /**\n+   * If somebody is unlucky enough to have to serialize one of these, serialize\n+   * it as a LinkedHashMap so that they won't need Gson on the other side to\n+   * deserialize it. Using serialization defeats our DoS defence, so most apps\n+   * shouldn't use it.\n+   */\n+  private Object writeReplace() throws ObjectStreamException {\n+    return new LinkedHashMap<K, V>(this);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.LinkedHashTreeMap;\n+import com.google.gson.internal.LinkedTreeMap;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n       return list;\n \n     case BEGIN_OBJECT:\n-      Map<String, Object> map = new LinkedHashTreeMap<String, Object>();\n+      Map<String, Object> map = new LinkedTreeMap<String, Object>();\n       in.beginObject();\n       while (in.hasNext()) {\n         map.put(in.nextName(), read(in));\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.common.MoreAsserts;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Random;\n+\n+public final class LinkedTreeMapTest extends TestCase {\n+\n+  public void testIterationOrder() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    assertIterationOrder(map.keySet(), \"a\", \"c\", \"b\");\n+    assertIterationOrder(map.values(), \"android\", \"cola\", \"bbq\");\n+  }\n+\n+  public void testRemoveRootDoesNotDoubleUnlink() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    Iterator<Map.Entry<String,String>> it = map.entrySet().iterator();\n+    it.next();\n+    it.next();\n+    it.next();\n+    it.remove();\n+    assertIterationOrder(map.keySet(), \"a\", \"c\");\n+  }\n+\n+  public void testPutNullKeyFails() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    try {\n+      map.put(null, \"android\");\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testPutNonComparableKeyFails() {\n+    LinkedTreeMap<Object, String> map = new LinkedTreeMap<Object, String>();\n+    try {\n+      map.put(new Object(), \"android\");\n+      fail();\n+    } catch (ClassCastException expected) {}\n+  }\n+\n+  @SuppressWarnings(\"SuspiciousMethodCalls\")\n+  public void testContainsNonComparableKeyReturnsFalse() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    assertFalse(map.containsKey(new Object()));\n+  }\n+\n+  public void testContainsNullKeyIsAlwaysFalse() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    assertFalse(map.containsKey(null));\n+  }\n+\n+  public void testPutOverrides() throws Exception {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    assertNull(map.put(\"d\", \"donut\"));\n+    assertNull(map.put(\"e\", \"eclair\"));\n+    assertNull(map.put(\"f\", \"froyo\"));\n+    assertEquals(3, map.size());\n+\n+    assertEquals(\"donut\", map.get(\"d\"));\n+    assertEquals(\"donut\", map.put(\"d\", \"done\"));\n+    assertEquals(3, map.size());\n+  }\n+\n+  public void testEmptyStringValues() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"\");\n+    assertTrue(map.containsKey(\"a\"));\n+    assertEquals(\"\", map.get(\"a\"));\n+  }\n+\n+  public void testLargeSetOfRandomKeys() throws Exception {\n+    Random random = new Random(1367593214724L);\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    String[] keys = new String[1000];\n+    for (int i = 0; i < keys.length; i++) {\n+      keys[i] = Integer.toString(Math.abs(random.nextInt()), 36) + \"-\" + i;\n+      map.put(keys[i], \"\" + i);\n+    }\n+\n+    for (int i = 0; i < keys.length; i++) {\n+      String key = keys[i];\n+      assertTrue(map.containsKey(key));\n+      assertEquals(\"\" + i, map.get(key));\n+    }\n+  }\n+\n+  public void testClear() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    map.clear();\n+    assertIterationOrder(map.keySet());\n+    assertEquals(0, map.size());\n+  }\n+\n+  public void testEqualsAndHashCode() throws Exception {\n+    LinkedTreeMap<String, Integer> map1 = new LinkedTreeMap<String, Integer>();\n+    map1.put(\"A\", 1);\n+    map1.put(\"B\", 2);\n+    map1.put(\"C\", 3);\n+    map1.put(\"D\", 4);\n+\n+    LinkedTreeMap<String, Integer> map2 = new LinkedTreeMap<String, Integer>();\n+    map2.put(\"C\", 3);\n+    map2.put(\"B\", 2);\n+    map2.put(\"D\", 4);\n+    map2.put(\"A\", 1);\n+\n+    MoreAsserts.assertEqualsAndHashCode(map1, map2);\n+  }\n+\n+  private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {\n+    ArrayList<T> actualList = new ArrayList<T>();\n+    for (T t : actual) {\n+      actualList.add(t);\n+    }\n+    assertEquals(Arrays.asList(expected), actualList);\n+  }\n+}", "timestamp": 1367597476, "metainfo": ""}