{"sha": "bcd52a1fdc4883731ee25b79e2c3f6a7d578bf92", "log": "Added ISO8601 complete support for date deserialization", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n+import java.text.ParsePosition;\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n import java.util.TimeZone;\n+\n+import com.google.gson.internal.bind.util.ISO8601Utils;\n \n /**\n  * This type adapter supports three subclasses of date: Date, Timestamp, and\n \n   private final DateFormat enUsFormat;\n   private final DateFormat localFormat;\n-  private final DateFormat iso8601Format;\n \n   DefaultDateTypeAdapter() {\n     this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n   DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n     this.enUsFormat = enUsFormat;\n     this.localFormat = localFormat;\n-    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n-    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n   }\n \n   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n   private Date deserializeToDate(JsonElement json) {\n     synchronized (localFormat) {\n       try {\n-        return localFormat.parse(json.getAsString());\n-      } catch (ParseException ignored) {\n-      }\n+      \treturn localFormat.parse(json.getAsString());\n+      } catch (ParseException ignored) {}\n       try {\n         return enUsFormat.parse(json.getAsString());\n-      } catch (ParseException ignored) {\n-      }\n+      } catch (ParseException ignored) {}\n       try {\n-        return iso8601Format.parse(json.getAsString());\n+        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n       } catch (ParseException e) {\n         throw new JsonSyntaxException(json.getAsString(), e);\n       }\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.bind.util.ISO8601Utils;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import java.io.IOException;\n import java.text.DateFormat;\n import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n+import java.text.ParsePosition;\n import java.util.Date;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n /**\n  * Adapter for Date. Although this class appears stateless, it is not.\n       = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);\n   private final DateFormat localFormat\n       = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);\n-  private final DateFormat iso8601Format = buildIso8601Format();\n-\n-  private static DateFormat buildIso8601Format() {\n-    DateFormat iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n-    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    return iso8601Format;\n-  }\n \n   @Override public Date read(JsonReader in) throws IOException {\n     if (in.peek() == JsonToken.NULL) {\n     } catch (ParseException ignored) {\n     }\n     try {\n-      return iso8601Format.parse(json);\n+    \treturn ISO8601Utils.parse(json, new ParsePosition(0));\n     } catch (ParseException e) {\n       throw new JsonSyntaxException(json, e);\n     }\n     String dateFormatAsString = enUsFormat.format(value);\n     out.value(dateFormatAsString);\n   }\n+  \n+  \n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n+package com.google.gson.internal.bind.util;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.*;\n+\n+/**\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\n+ * \n+ * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n+ */\n+//Date parsing code from Jackson databind ISO8601Utils.java\n+// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+public class ISO8601Utils\n+{\n+    /**\n+     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\n+     * \n+     * @since 2.7\n+     */\n+    private static final String UTC_ID = \"UTC\";\n+    /**\n+     * The UTC timezone, prefetched to avoid more lookups.\n+     * \n+     * @since 2.7\n+     */\n+    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n+\n+    /*\n+    /**********************************************************\n+    /* Formatting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n+     * \n+     * @param date the date to format\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n+     */\n+    public static String format(Date date) {\n+        return format(date, false, TIMEZONE_UTC);\n+    }\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n+     * \n+     * @param date the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n+     */\n+    public static String format(Date date, boolean millis) {\n+        return format(date, millis, TIMEZONE_UTC);\n+    }\n+\n+    /**\n+     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     * \n+     * @param date the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n+     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     */\n+    public static String format(Date date, boolean millis, TimeZone tz) {\n+        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n+        calendar.setTime(date);\n+\n+        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n+        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n+        capacity += millis ? \".sss\".length() : 0;\n+        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n+        StringBuilder formatted = new StringBuilder(capacity);\n+\n+        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n+        formatted.append('T');\n+        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n+        if (millis) {\n+            formatted.append('.');\n+            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n+        }\n+\n+        int offset = tz.getOffset(calendar.getTimeInMillis());\n+        if (offset != 0) {\n+            int hours = Math.abs((offset / (60 * 1000)) / 60);\n+            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n+            formatted.append(offset < 0 ? '-' : '+');\n+            padInt(formatted, hours, \"hh\".length());\n+            formatted.append(':');\n+            padInt(formatted, minutes, \"mm\".length());\n+        } else {\n+            formatted.append('Z');\n+        }\n+\n+        return formatted.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Parse a date from ISO-8601 formatted string. It expects a format\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * \n+     * @param date ISO string to parse in the appropriate format.\n+     * @param pos The position to start parsing from, updated to where parsing stopped.\n+     * @return the parsed date\n+     * @throws ParseException if the date is not in the appropriate format\n+     */\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n+        Exception fail = null;\n+        try {\n+            int offset = pos.getIndex();\n+\n+            // extract year\n+            int year = parseInt(date, offset, offset += 4);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n+\n+            // extract month\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n+\n+            // extract day\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n+            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n+\n+            // if the value has no time component (and no time zone), we are done\n+            boolean hasT = checkOffset(date, offset, 'T');\n+            \n+            if (!hasT && (date.length() <= offset)) {\n+                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+\n+                pos.setIndex(offset);\n+                return calendar.getTime();\n+            }\n+\n+            if (hasT) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            offset += 1;\n+                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n+                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n+                            int fraction = parseInt(date, offset, parseEndOffset);\n+                            // compensate for \"missing\" digits\n+                            switch (parseEndOffset - offset) { // number of digits parsed\n+                            case 2:\n+                                milliseconds = fraction * 10;\n+                                break;\n+                            case 1:\n+                                milliseconds = fraction * 100;\n+                                break;\n+                            default:\n+                                milliseconds = fraction;\n+                            }\n+                            offset = endOffset;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // extract timezone\n+            if (date.length() <= offset) {\n+                throw new IllegalArgumentException(\"No time zone indicator\");\n+            }\n+\n+            TimeZone timezone = null;\n+            char timezoneIndicator = date.charAt(offset);\n+\n+            if (timezoneIndicator == 'Z') {\n+                timezone = TIMEZONE_UTC;\n+                offset += 1;\n+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                String timezoneOffset = date.substring(offset);\n+                offset += timezoneOffset.length();\n+                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n+                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                    timezone = TIMEZONE_UTC;\n+                } else {\n+                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n+                    //    not sure why, but that's the way it looks. Further, Javadocs for\n+                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n+                    //    custom timezones... odd.\n+                    String timezoneId = \"GMT\" + timezoneOffset;\n+//                    String timezoneId = \"UTC\" + timezoneOffset;\n+\n+                    timezone = TimeZone.getTimeZone(timezoneId);\n+\n+                    String act = timezone.getID();\n+                    if (!act.equals(timezoneId)) {\n+                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n+                         *    one without. If so, don't sweat.\n+                         *   Yes, very inefficient. Hopefully not hit often.\n+                         *   If it becomes a perf problem, add 'loose' comparison instead.\n+                         */\n+                        String cleaned = act.replace(\":\", \"\");\n+                        if (!cleaned.equals(timezoneId)) {\n+                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n+                                    +timezone.getID());\n+                        }\n+                    }\n+                }\n+            } else {\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n+            }\n+\n+            Calendar calendar = new GregorianCalendar(timezone);\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n+            calendar.set(Calendar.HOUR_OF_DAY, hour);\n+            calendar.set(Calendar.MINUTE, minutes);\n+            calendar.set(Calendar.SECOND, seconds);\n+            calendar.set(Calendar.MILLISECOND, milliseconds);\n+\n+            pos.setIndex(offset);\n+            return calendar.getTime();\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n+        } catch (IndexOutOfBoundsException e) {\n+            fail = e;\n+        } catch (NumberFormatException e) {\n+            fail = e;\n+        } catch (IllegalArgumentException e) {\n+            fail = e;\n+        }\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        String msg = fail.getMessage();\n+        if (msg == null || msg.isEmpty()) {\n+            msg = \"(\"+fail.getClass().getName()+\")\";\n+        }\n+        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n+        ex.initCause(fail);\n+        throw ex;\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n+     * @param expected the expected character\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return (offset < value.length()) && (value.charAt(offset) == expected);\n+    }\n+\n+    /**\n+     * Parse an integer located between 2 given offsets in a string\n+     * \n+     * @param value the string to parse\n+     * @param beginIndex the start index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n+     * @return the int\n+     * @throws NumberFormatException if the value is not a number\n+     */\n+    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n+        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n+            throw new NumberFormatException(value);\n+        }\n+        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n+        int i = beginIndex;\n+        int result = 0;\n+        int digit;\n+        if (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n+            }\n+            result = -digit;\n+        }\n+        while (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n+            }\n+            result *= 10;\n+            result -= digit;\n+        }\n+        return -result;\n+    }\n+\n+    /**\n+     * Zero pad a number to a specified length\n+     * \n+     * @param buffer buffer to use for padding\n+     * @param value the integer value to pad if necessary.\n+     * @param length the length of the string we should zero pad\n+     */\n+    private static void padInt(StringBuilder buffer, int value, int length) {\n+        String strValue = Integer.toString(value);\n+        for (int i = length - strValue.length(); i > 0; i--) {\n+            buffer.append('0');\n+        }\n+        buffer.append(strValue);\n+    }\n+\n+    /**\n+     * Returns the index of the first character in the string that is not a digit, starting at offset.\n+     */\n+    private static int indexOfNonDigit(String string, int offset) {\n+        for (int i = offset; i < string.length(); i++) {\n+            char c = string.charAt(i);\n+            if (c < '0' || c > '9') return i;\n+        }\n+        return string.length();\n+    }\n+\n+    public static void main(String[] args)\n+    {\n+        final int REPS = 250000;\n+        while (true) {\n+            long start = System.currentTimeMillis();\n+            int resp = test1(REPS, 3);\n+            long msecs = System.currentTimeMillis() - start;\n+            System.out.println(\"Pow (\"+resp+\") -> \"+msecs+\" ms\");\n+\n+            start = System.currentTimeMillis();\n+            resp = test2(REPS, 3);\n+            msecs = System.currentTimeMillis() - start;\n+            System.out.println(\"Iter (\"+resp+\") -> \"+msecs+\" ms\");\n+        }\n+    }\n+\n+    static int test1(int reps, int pow)\n+    {\n+        int resp = 3;\n+        while (--reps >= 0) {\n+            resp = (int) Math.pow(10, pow);\n+        }\n+        return resp;\n+    }\n+\n+    static int test2(int reps, int pow)\n+    {\n+        int resp = 3;\n+        while (--reps >= 0) {\n+            resp = 10;\n+            int p = pow;\n+\n+            while (--p > 0) {\n+                resp *= 10;\n+            }\n+        }\n+        return resp;\n+    }\n+}\n--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n     }\n   }\n \n+  public void testDateDeserializationISO8601() throws Exception {\n+  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n+    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n+    assertParsed(\"1970-01-01T00:00Z\", adapter);\n+    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n+    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n+  }\n+  \n   public void testDateSerialization() throws Exception {\n     int dateStyle = DateFormat.LONG;\n     DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);", "timestamp": 1448259101, "metainfo": ""}