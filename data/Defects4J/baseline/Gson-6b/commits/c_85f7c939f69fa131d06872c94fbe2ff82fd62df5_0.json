{"sha": "85f7c939f69fa131d06872c94fbe2ff82fd62df5", "log": "Renamed JsonParserImpl to JsonParserJavacc for clarity.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n    */\n   public JsonElement parse(Reader json) throws JsonParseException {\n     try {\n-      JsonParserImpl parser = new JsonParserImpl(json);\n+      JsonParserJavacc parser = new JsonParserJavacc(json);\n       return parser.parse();\n     } catch (TokenMgrError e) {\n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavacc.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParserJavacc.java */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+final class JsonParserJavacc implements JsonParserJavaccConstants {\n+\n+  final public JsonElement parse() throws ParseException {\n+  JsonElement json = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 26:\n+      jj_consume_token(26);\n+      break;\n+    default:\n+      jj_la1[0] = jj_gen;\n+      ;\n+    }\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 27:\n+      json = JsonObject();\n+      break;\n+    case 31:\n+      json = JsonArray();\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case BOOLEAN:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+    case 33:\n+      json = JsonPrimitive();\n+      break;\n+    case NULL:\n+      json = JsonNull();\n+      break;\n+    default:\n+      jj_la1[1] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return json;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonObject JsonObject() throws ParseException {\n+  JsonObject o = new JsonObject();\n+    jj_consume_token(27);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER_SANS_EXPONENT:\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[2] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(28);\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonNull JsonNull() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(NULL);\n+               {if (true) return JsonNull.createJsonNull();}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Members(JsonObject o) throws ParseException {\n+    Pair(o);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 29:\n+      jj_consume_token(29);\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[3] = jj_gen;\n+      ;\n+    }\n+  }\n+\n+  final private void Pair(JsonObject o) throws ParseException {\n+  JsonPrimitive property;\n+  JsonElement value;\n+    property = JsonMemberName();\n+    jj_consume_token(30);\n+    value = JsonValue();\n+    o.add(property.getAsString(), value);\n+  }\n+\n+  final private JsonPrimitive JsonMemberName() throws ParseException {\n+  Token t; JsonPrimitive value;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER_SANS_EXPONENT:\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n+      t = Identifier();\n+                    {if (true) return new JsonPrimitive(t.image);}\n+      break;\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      value = JsonString();\n+                       {if (true) return value;}\n+      break;\n+    default:\n+      jj_la1[4] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonArray JsonArray() throws ParseException {\n+  JsonArray array = new JsonArray();\n+    jj_consume_token(31);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case DIGITS:\n+    case NULL:\n+    case NAN:\n+    case INFINITY:\n+    case BOOLEAN:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+    case 27:\n+    case 31:\n+    case 33:\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[5] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(32);\n+    array.reverse();\n+    {if (true) return array;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Elements(JsonArray array) throws ParseException {\n+  JsonElement element;\n+    element = JsonValue();\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 29:\n+      jj_consume_token(29);\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[6] = jj_gen;\n+      ;\n+    }\n+    array.add(element);\n+  }\n+\n+  final private JsonElement JsonValue() throws ParseException {\n+  JsonElement o = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      o = JsonString();\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case 33:\n+      o = JsonNumber();\n+      break;\n+    case 27:\n+      o = JsonObject();\n+      break;\n+    case 31:\n+      o = JsonArray();\n+      break;\n+    case BOOLEAN:\n+      o = JsonBoolean();\n+      break;\n+    case NULL:\n+      o = JsonNull();\n+      break;\n+    default:\n+      jj_la1[7] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonBoolean() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(BOOLEAN);\n+    boolean value = Boolean.valueOf(t.image);\n+    {if (true) return new JsonPrimitive(value);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonPrimitive() throws ParseException {\n+  JsonPrimitive value;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      value = JsonString();\n+                          {if (true) return value;}\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case 33:\n+      value = JsonNumber();\n+                          {if (true) return value;}\n+      break;\n+    case BOOLEAN:\n+      value = JsonBoolean();\n+                           {if (true) return value;}\n+      break;\n+    default:\n+      jj_la1[8] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonNumber() throws ParseException {\n+  String intpart = null,\n+         fracpart = null,\n+         exppart = null;\n+  JsonPrimitive value;\n+    if (jj_2_1(2)) {\n+      value = JsonSpecialNumbers();\n+                                {if (true) return value;}\n+    } else {\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case DIGITS:\n+      case 33:\n+        intpart = JsonInt();\n+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+        case 34:\n+          fracpart = JsonFrac();\n+          break;\n+        default:\n+          jj_la1[9] = jj_gen;\n+          ;\n+        }\n+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+        case EXPONENT:\n+          exppart = JsonExp();\n+          break;\n+        default:\n+          jj_la1[10] = jj_gen;\n+          ;\n+        }\n+    Number n;\n+    if (exppart != null || fracpart != null) {\n+      fracpart = (fracpart == null) ? \"\" : fracpart;\n+      exppart = (exppart == null) ? \"\" : exppart;\n+      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n+    } else {\n+      n = new java.math.BigInteger(intpart);\n+    }\n+    {if (true) return new JsonPrimitive(n);}\n+        break;\n+      default:\n+        jj_la1[11] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonSpecialNumbers() throws ParseException {\n+  boolean negative = false;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case NAN:\n+      jj_consume_token(NAN);\n+           {if (true) return new JsonPrimitive(Double.NaN);}\n+      break;\n+    case INFINITY:\n+    case 33:\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case 33:\n+        jj_consume_token(33);\n+         negative = true;\n+        break;\n+      default:\n+        jj_la1[12] = jj_gen;\n+        ;\n+      }\n+      jj_consume_token(INFINITY);\n+                                        {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\n+      break;\n+    default:\n+      jj_la1[13] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonInt() throws ParseException {\n+  String digits;\n+  boolean negative = false;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 33:\n+      jj_consume_token(33);\n+         negative = true;\n+      break;\n+    default:\n+      jj_la1[14] = jj_gen;\n+      ;\n+    }\n+    digits = Digits();\n+    if(negative)\n+      {if (true) return \"-\" + digits;}\n+    {if (true) return digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonFrac() throws ParseException {\n+  String digits;\n+    jj_consume_token(34);\n+    digits = Digits();\n+    {if (true) return \".\" + digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonExp() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(EXPONENT);\n+                  {if (true) return t.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private Token Identifier() throws ParseException {\n+  Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n+      t = jj_consume_token(IDENTIFIER_STARTS_WITH_EXPONENT);\n+      break;\n+    case IDENTIFIER_SANS_EXPONENT:\n+      t = jj_consume_token(IDENTIFIER_SANS_EXPONENT);\n+      break;\n+    default:\n+      jj_la1[15] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+                                                                            {if (true) return t;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String Digits() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(DIGITS);\n+    {if (true) return t.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonString() throws ParseException {\n+  Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+      t = jj_consume_token(SINGLE_QUOTE_LITERAL);\n+      break;\n+    case DOUBLE_QUOTE_LITERAL:\n+      t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n+      break;\n+    default:\n+      jj_la1[16] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    String value = StringUnmarshaller.unmarshall(t.image);\n+    {if (true) return new JsonPrimitive(value);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  private boolean jj_2_1(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    try { return !jj_3_1(); }\n+    catch(LookaheadSuccess ls) { return true; }\n+    finally { jj_save(0, xla); }\n+  }\n+\n+  private boolean jj_3R_4() {\n+    if (jj_scan_token(33)) return true;\n+    return false;\n+  }\n+\n+  private boolean jj_3R_3() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_4()) jj_scanpos = xsp;\n+    if (jj_scan_token(INFINITY)) return true;\n+    return false;\n+  }\n+\n+  private boolean jj_3_1() {\n+    if (jj_3R_1()) return true;\n+    return false;\n+  }\n+\n+  private boolean jj_3R_2() {\n+    if (jj_scan_token(NAN)) return true;\n+    return false;\n+  }\n+\n+  private boolean jj_3R_1() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_2()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_3()) return true;\n+    }\n+    return false;\n+  }\n+\n+  /** Generated Token Manager. */\n+  public JsonParserJavaccTokenManager token_source;\n+  SimpleCharStream jj_input_stream;\n+  /** Current token. */\n+  public Token token;\n+  /** Next token. */\n+  public Token jj_nt;\n+  private int jj_ntk;\n+  private Token jj_scanpos, jj_lastpos;\n+  private int jj_la;\n+  private int jj_gen;\n+  final private int[] jj_la1 = new int[17];\n+  static private int[] jj_la1_0;\n+  static private int[] jj_la1_1;\n+  static {\n+      jj_la1_init_0();\n+      jj_la1_init_1();\n+   }\n+   private static void jj_la1_init_0() {\n+      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x31800,0x20000000,0x31800,0x880307c0,0x20000000,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n+   }\n+   private static void jj_la1_init_1() {\n+      jj_la1_1 = new int[] {0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n+   }\n+  final private JJCalls[] jj_2_rtns = new JJCalls[1];\n+  private boolean jj_rescan = false;\n+  private int jj_gc = 0;\n+\n+  /** Constructor with InputStream. */\n+  public JsonParserJavacc(java.io.InputStream stream) {\n+     this(stream, null);\n+  }\n+  /** Constructor with InputStream and supplied encoding */\n+  public JsonParserJavacc(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source = new JsonParserJavaccTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream stream) {\n+     ReInit(stream, null);\n+  }\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  /** Constructor. */\n+  public JsonParserJavacc(java.io.Reader stream) {\n+    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n+    token_source = new JsonParserJavaccTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.Reader stream) {\n+    jj_input_stream.ReInit(stream, 1, 1);\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  /** Constructor with generated Token Manager. */\n+  public JsonParserJavacc(JsonParserJavaccTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(JsonParserJavaccTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 17; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  private Token jj_consume_token(int kind) throws ParseException {\n+    Token oldToken;\n+    if ((oldToken = token).next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    if (token.kind == kind) {\n+      jj_gen++;\n+      if (++jj_gc > 100) {\n+        jj_gc = 0;\n+        for (int i = 0; i < jj_2_rtns.length; i++) {\n+          JJCalls c = jj_2_rtns[i];\n+          while (c != null) {\n+            if (c.gen < jj_gen) c.first = null;\n+            c = c.next;\n+          }\n+        }\n+      }\n+      return token;\n+    }\n+    token = oldToken;\n+    jj_kind = kind;\n+    throw generateParseException();\n+  }\n+\n+  static private final class LookaheadSuccess extends java.lang.Error { }\n+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n+  private boolean jj_scan_token(int kind) {\n+    if (jj_scanpos == jj_lastpos) {\n+      jj_la--;\n+      if (jj_scanpos.next == null) {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n+      } else {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next;\n+      }\n+    } else {\n+      jj_scanpos = jj_scanpos.next;\n+    }\n+    if (jj_rescan) {\n+      int i = 0; Token tok = token;\n+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n+      if (tok != null) jj_add_error_token(kind, i);\n+    }\n+    if (jj_scanpos.kind != kind) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;\n+    return false;\n+  }\n+\n+\n+/** Get the next Token. */\n+  final public Token getNextToken() {\n+    if (token.next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    jj_gen++;\n+    return token;\n+  }\n+\n+/** Get the specific Token. */\n+  final public Token getToken(int index) {\n+    Token t = token;\n+    for (int i = 0; i < index; i++) {\n+      if (t.next != null) t = t.next;\n+      else t = t.next = token_source.getNextToken();\n+    }\n+    return t;\n+  }\n+\n+  private int jj_ntk() {\n+    if ((jj_nt=token.next) == null)\n+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n+    else\n+      return (jj_ntk = jj_nt.kind);\n+  }\n+\n+  private java.util.List jj_expentries = new java.util.ArrayList();\n+  private int[] jj_expentry;\n+  private int jj_kind = -1;\n+  private int[] jj_lasttokens = new int[100];\n+  private int jj_endpos;\n+\n+  private void jj_add_error_token(int kind, int pos) {\n+    if (pos >= 100) return;\n+    if (pos == jj_endpos + 1) {\n+      jj_lasttokens[jj_endpos++] = kind;\n+    } else if (jj_endpos != 0) {\n+      jj_expentry = new int[jj_endpos];\n+      for (int i = 0; i < jj_endpos; i++) {\n+        jj_expentry[i] = jj_lasttokens[i];\n+      }\n+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {\n+        int[] oldentry = (int[])(it.next());\n+        if (oldentry.length == jj_expentry.length) {\n+          for (int i = 0; i < jj_expentry.length; i++) {\n+            if (oldentry[i] != jj_expentry[i]) {\n+              continue jj_entries_loop;\n+            }\n+          }\n+          jj_expentries.add(jj_expentry);\n+          break jj_entries_loop;\n+        }\n+      }\n+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n+    }\n+  }\n+\n+  /** Generate ParseException. */\n+  public ParseException generateParseException() {\n+    jj_expentries.clear();\n+    boolean[] la1tokens = new boolean[35];\n+    if (jj_kind >= 0) {\n+      la1tokens[jj_kind] = true;\n+      jj_kind = -1;\n+    }\n+    for (int i = 0; i < 17; i++) {\n+      if (jj_la1[i] == jj_gen) {\n+        for (int j = 0; j < 32; j++) {\n+          if ((jj_la1_0[i] & (1<<j)) != 0) {\n+            la1tokens[j] = true;\n+          }\n+          if ((jj_la1_1[i] & (1<<j)) != 0) {\n+            la1tokens[32+j] = true;\n+          }\n+        }\n+      }\n+    }\n+    for (int i = 0; i < 35; i++) {\n+      if (la1tokens[i]) {\n+        jj_expentry = new int[1];\n+        jj_expentry[0] = i;\n+        jj_expentries.add(jj_expentry);\n+      }\n+    }\n+    jj_endpos = 0;\n+    jj_rescan_token();\n+    jj_add_error_token(0, 0);\n+    int[][] exptokseq = new int[jj_expentries.size()][];\n+    for (int i = 0; i < jj_expentries.size(); i++) {\n+      exptokseq[i] = (int[])jj_expentries.get(i);\n+    }\n+    return new ParseException(token, exptokseq, tokenImage);\n+  }\n+\n+  /** Enable tracing. */\n+  final public void enable_tracing() {\n+  }\n+\n+  /** Disable tracing. */\n+  final public void disable_tracing() {\n+  }\n+\n+  private void jj_rescan_token() {\n+    jj_rescan = true;\n+    for (int i = 0; i < 1; i++) {\n+    try {\n+      JJCalls p = jj_2_rtns[i];\n+      do {\n+        if (p.gen > jj_gen) {\n+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n+          switch (i) {\n+            case 0: jj_3_1(); break;\n+          }\n+        }\n+        p = p.next;\n+      } while (p != null);\n+      } catch(LookaheadSuccess ls) { }\n+    }\n+    jj_rescan = false;\n+  }\n+\n+  private void jj_save(int index, int xla) {\n+    JJCalls p = jj_2_rtns[index];\n+    while (p.gen > jj_gen) {\n+      if (p.next == null) { p = p.next = new JJCalls(); break; }\n+      p = p.next;\n+    }\n+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;\n+  }\n+\n+  static final class JJCalls {\n+    int gen;\n+    Token first;\n+    int arg;\n+    JJCalls next;\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavaccConstants.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParserJavaccConstants.java */\n+package com.google.gson;\n+\n+\n+/**\n+ * Token literal values and constants.\n+ * Generated by org.javacc.parser.OtherFilesGen#start()\n+ */\n+@SuppressWarnings(\"all\")\n+interface JsonParserJavaccConstants {\n+\n+  /** End of File. */\n+  int EOF = 0;\n+  /** RegularExpression Id. */\n+  int EXPONENT = 5;\n+  /** RegularExpression Id. */\n+  int DIGITS = 6;\n+  /** RegularExpression Id. */\n+  int NULL = 7;\n+  /** RegularExpression Id. */\n+  int NAN = 8;\n+  /** RegularExpression Id. */\n+  int INFINITY = 9;\n+  /** RegularExpression Id. */\n+  int BOOLEAN = 10;\n+  /** RegularExpression Id. */\n+  int IDENTIFIER_SANS_EXPONENT = 11;\n+  /** RegularExpression Id. */\n+  int IDENTIFIER_STARTS_WITH_EXPONENT = 12;\n+  /** RegularExpression Id. */\n+  int HEX_CHAR = 13;\n+  /** RegularExpression Id. */\n+  int UNICODE_CHAR = 14;\n+  /** RegularExpression Id. */\n+  int ESCAPE_CHAR = 15;\n+  /** RegularExpression Id. */\n+  int SINGLE_QUOTE_LITERAL = 16;\n+  /** RegularExpression Id. */\n+  int DOUBLE_QUOTE_LITERAL = 17;\n+  /** RegularExpression Id. */\n+  int QUOTE = 18;\n+  /** RegularExpression Id. */\n+  int ENDQUOTE = 20;\n+  /** RegularExpression Id. */\n+  int CHAR = 21;\n+  /** RegularExpression Id. */\n+  int CNTRL_ESC = 22;\n+  /** RegularExpression Id. */\n+  int HEX = 24;\n+  /** RegularExpression Id. */\n+  int HEX_ESC = 25;\n+\n+  /** Lexical state. */\n+  int DEFAULT = 0;\n+  /** Lexical state. */\n+  int STRING_STATE = 1;\n+  /** Lexical state. */\n+  int ESC_STATE = 2;\n+  /** Lexical state. */\n+  int HEX_STATE = 3;\n+\n+  /** Literal token values. */\n+  String[] tokenImage = {\n+    \"<EOF>\",\n+    \"\\\" \\\"\",\n+    \"\\\"\\\\t\\\"\",\n+    \"\\\"\\\\n\\\"\",\n+    \"\\\"\\\\r\\\"\",\n+    \"<EXPONENT>\",\n+    \"<DIGITS>\",\n+    \"\\\"null\\\"\",\n+    \"\\\"NaN\\\"\",\n+    \"\\\"Infinity\\\"\",\n+    \"<BOOLEAN>\",\n+    \"<IDENTIFIER_SANS_EXPONENT>\",\n+    \"<IDENTIFIER_STARTS_WITH_EXPONENT>\",\n+    \"<HEX_CHAR>\",\n+    \"<UNICODE_CHAR>\",\n+    \"<ESCAPE_CHAR>\",\n+    \"<SINGLE_QUOTE_LITERAL>\",\n+    \"<DOUBLE_QUOTE_LITERAL>\",\n+    \"\\\"\\\\\\\"\\\"\",\n+    \"\\\"\\\\\\\\\\\"\",\n+    \"<ENDQUOTE>\",\n+    \"<CHAR>\",\n+    \"<CNTRL_ESC>\",\n+    \"\\\"u\\\"\",\n+    \"<HEX>\",\n+    \"<HEX_ESC>\",\n+    \"\\\")]}\\\\\\'\\\\n\\\"\",\n+    \"\\\"{\\\"\",\n+    \"\\\"}\\\"\",\n+    \"\\\",\\\"\",\n+    \"\\\":\\\"\",\n+    \"\\\"[\\\"\",\n+    \"\\\"]\\\"\",\n+    \"\\\"-\\\"\",\n+    \"\\\".\\\"\",\n+  };\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParserJavaccTokenManager.java */\n+package com.google.gson;\n+\n+/** Token Manager. */\n+@SuppressWarnings(\"all\")\n+final class JsonParserJavaccTokenManager implements JsonParserJavaccConstants\n+{\n+\n+  /** Debug output. */\n+  public  java.io.PrintStream debugStream = System.out;\n+  /** Set debug output. */\n+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\n+private int jjMoveStringLiteralDfa0_3()\n+{\n+   return jjMoveNfa_3(0, 0);\n+}\n+private int jjMoveNfa_3(int startState, int curPos)\n+{\n+   int startsAt = 0;\n+   jjnewStateCnt = 4;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 25)\n+                     kind = 25;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x7e0000007eL & l) != 0L && kind > 25)\n+                     kind = 25;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_0(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      case 0:\n+         if ((active0 & 0x380L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            return 10;\n+         }\n+         if ((active0 & 0x40000L) != 0L)\n+            return 43;\n+         return -1;\n+      case 1:\n+         if ((active0 & 0x380L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 1;\n+            return 10;\n+         }\n+         return -1;\n+      case 2:\n+         if ((active0 & 0x100L) != 0L)\n+            return 10;\n+         if ((active0 & 0x280L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 2;\n+            return 10;\n+         }\n+         return -1;\n+      case 3:\n+         if ((active0 & 0x80L) != 0L)\n+            return 10;\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 3;\n+            return 10;\n+         }\n+         return -1;\n+      case 4:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 4;\n+            return 10;\n+         }\n+         return -1;\n+      case 5:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 5;\n+            return 10;\n+         }\n+         return -1;\n+      case 6:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 6;\n+            return 10;\n+         }\n+         return -1;\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_0(int pos, long active0)\n+{\n+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);\n+}\n+private int jjStopAtPos(int pos, int kind)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   return pos + 1;\n+}\n+private int jjMoveStringLiteralDfa0_0()\n+{\n+   switch(curChar)\n+   {\n+      case 34:\n+         return jjStartNfaWithStates_0(0, 18, 43);\n+      case 41:\n+         return jjMoveStringLiteralDfa1_0(0x4000000L);\n+      case 44:\n+         return jjStopAtPos(0, 29);\n+      case 45:\n+         return jjStopAtPos(0, 33);\n+      case 46:\n+         return jjStopAtPos(0, 34);\n+      case 58:\n+         return jjStopAtPos(0, 30);\n+      case 73:\n+         return jjMoveStringLiteralDfa1_0(0x200L);\n+      case 78:\n+         return jjMoveStringLiteralDfa1_0(0x100L);\n+      case 91:\n+         return jjStopAtPos(0, 31);\n+      case 93:\n+         return jjStopAtPos(0, 32);\n+      case 110:\n+         return jjMoveStringLiteralDfa1_0(0x80L);\n+      case 123:\n+         return jjStopAtPos(0, 27);\n+      case 125:\n+         return jjStopAtPos(0, 28);\n+      default :\n+         return jjMoveNfa_0(4, 0);\n+   }\n+}\n+private int jjMoveStringLiteralDfa1_0(long active0)\n+{\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(0, active0);\n+      return 1;\n+   }\n+   switch(curChar)\n+   {\n+      case 93:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L);\n+      case 97:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x100L);\n+      case 110:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x200L);\n+      case 117:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x80L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(0, active0);\n+}\n+private int jjMoveStringLiteralDfa2_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(0, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(1, active0);\n+      return 2;\n+   }\n+   switch(curChar)\n+   {\n+      case 78:\n+         if ((active0 & 0x100L) != 0L)\n+            return jjStartNfaWithStates_0(2, 8, 10);\n+         break;\n+      case 102:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x200L);\n+      case 108:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x80L);\n+      case 125:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(1, active0);\n+}\n+private int jjMoveStringLiteralDfa3_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(1, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(2, active0);\n+      return 3;\n+   }\n+   switch(curChar)\n+   {\n+      case 39:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000L);\n+      case 105:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x200L);\n+      case 108:\n+         if ((active0 & 0x80L) != 0L)\n+            return jjStartNfaWithStates_0(3, 7, 10);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(2, active0);\n+}\n+private int jjMoveStringLiteralDfa4_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(2, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(3, active0);\n+      return 4;\n+   }\n+   switch(curChar)\n+   {\n+      case 10:\n+         if ((active0 & 0x4000000L) != 0L)\n+            return jjStopAtPos(4, 26);\n+         break;\n+      case 110:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(3, active0);\n+}\n+private int jjMoveStringLiteralDfa5_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(3, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(4, active0);\n+      return 5;\n+   }\n+   switch(curChar)\n+   {\n+      case 105:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(4, active0);\n+}\n+private int jjMoveStringLiteralDfa6_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(4, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(5, active0);\n+      return 6;\n+   }\n+   switch(curChar)\n+   {\n+      case 116:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(5, active0);\n+}\n+private int jjMoveStringLiteralDfa7_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(5, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(6, active0);\n+      return 7;\n+   }\n+   switch(curChar)\n+   {\n+      case 121:\n+         if ((active0 & 0x200L) != 0L)\n+            return jjStartNfaWithStates_0(7, 9, 10);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(6, active0);\n+}\n+private int jjStartNfaWithStates_0(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_0(state, pos + 1);\n+}\n+static final long[] jjbitVec0 = {\n+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+static final long[] jjbitVec2 = {\n+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+private int jjMoveNfa_0(int startState, int curPos)\n+{\n+   int startsAt = 0;\n+   jjnewStateCnt = 43;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 43:\n+                  if ((0xfffffffbffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 34)\n+                  {\n+                     if (kind > 17)\n+                        kind = 17;\n+                  }\n+                  break;\n+               case 4:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                  {\n+                     if (kind > 6)\n+                        kind = 6;\n+                     jjCheckNAdd(0);\n+                  }\n+                  else if (curChar == 34)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 39)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 0:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 6)\n+                     kind = 6;\n+                  jjCheckNAdd(0);\n+                  break;\n+               case 10:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjstateSet[jjnewStateCnt++] = 10;\n+                  break;\n+               case 12:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n+                  break;\n+               case 13:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 14;\n+                  break;\n+               case 14:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 15;\n+                  break;\n+               case 15:\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 14)\n+                     kind = 14;\n+                  break;\n+               case 17:\n+                  if (curChar == 39)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 18:\n+                  if ((0xffffff7fffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 20:\n+                  if ((0x808400000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 22:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 23;\n+                  break;\n+               case 23:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 24;\n+                  break;\n+               case 24:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 25;\n+                  break;\n+               case 25:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 27:\n+                  if (curChar == 39 && kind > 16)\n+                     kind = 16;\n+                  break;\n+               case 28:\n+                  if (curChar == 34)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 29:\n+                  if ((0xfffffffbffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 31:\n+                  if ((0x808400000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 33:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  break;\n+               case 34:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 35;\n+                  break;\n+               case 35:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 36;\n+                  break;\n+               case 36:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 38:\n+                  if (curChar == 34 && kind > 17)\n+                     kind = 17;\n+                  break;\n+               case 40:\n+                  if ((0x3ff280000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 5)\n+                     kind = 5;\n+                  jjCheckNAdd(41);\n+                  break;\n+               case 41:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 5)\n+                     kind = 5;\n+                  jjCheckNAdd(41);\n+                  break;\n+               case 42:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjstateSet[jjnewStateCnt++] = 42;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 43:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 32;\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 31;\n+                  break;\n+               case 4:\n+                  if ((0x7ffffde87ffffdeL & l) != 0L)\n+                  {\n+                     if (kind > 11)\n+                        kind = 11;\n+                     jjCheckNAdd(10);\n+                  }\n+                  else if ((0x2000000020L & l) != 0L)\n+                  {\n+                     if (kind > 12)\n+                        kind = 12;\n+                     jjCheckNAddTwoStates(40, 42);\n+                  }\n+                  else if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 11;\n+                  if (curChar == 102)\n+                     jjstateSet[jjnewStateCnt++] = 7;\n+                  else if (curChar == 116)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 1:\n+                  if (curChar == 101 && kind > 10)\n+                     kind = 10;\n+                  break;\n+               case 2:\n+                  if (curChar == 117)\n+                     jjCheckNAdd(1);\n+                  break;\n+               case 3:\n+                  if (curChar == 114)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 5:\n+                  if (curChar == 115)\n+                     jjCheckNAdd(1);\n+                  break;\n+               case 6:\n+                  if (curChar == 108)\n+                     jjstateSet[jjnewStateCnt++] = 5;\n+                  break;\n+               case 7:\n+                  if (curChar == 97)\n+                     jjstateSet[jjnewStateCnt++] = 6;\n+                  break;\n+               case 8:\n+                  if (curChar == 102)\n+                     jjstateSet[jjnewStateCnt++] = 7;\n+                  break;\n+               case 9:\n+                  if ((0x7ffffde87ffffdeL & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjCheckNAdd(10);\n+                  break;\n+               case 10:\n+                  if ((0x7fffffe87fffffeL & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjCheckNAdd(10);\n+                  break;\n+               case 11:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 12;\n+                  break;\n+               case 12:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n+                  break;\n+               case 13:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 14;\n+                  break;\n+               case 14:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 15;\n+                  break;\n+               case 15:\n+                  if ((0x7e0000007eL & l) != 0L && kind > 14)\n+                     kind = 14;\n+                  break;\n+               case 16:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 11;\n+                  break;\n+               case 18:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 19:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 20;\n+                  break;\n+               case 20:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 21:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 22;\n+                  break;\n+               case 22:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 23;\n+                  break;\n+               case 23:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 24;\n+                  break;\n+               case 24:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 25;\n+                  break;\n+               case 25:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 26:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 21;\n+                  break;\n+               case 29:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 30:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 31;\n+                  break;\n+               case 31:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 32:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 33;\n+                  break;\n+               case 33:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  break;\n+               case 34:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 35;\n+                  break;\n+               case 35:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 36;\n+                  break;\n+               case 36:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 37:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 32;\n+                  break;\n+               case 39:\n+                  if ((0x2000000020L & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjCheckNAddTwoStates(40, 42);\n+                  break;\n+               case 42:\n+                  if ((0x7fffffe87fffffeL & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjCheckNAdd(42);\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 43:\n+               case 29:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 18:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjAddStates(4, 7);\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 43 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_2(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_2(int pos, long active0)\n+{\n+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);\n+}\n+private int jjMoveStringLiteralDfa0_2()\n+{\n+   switch(curChar)\n+   {\n+      case 117:\n+         return jjStopAtPos(0, 23);\n+      default :\n+         return jjMoveNfa_2(0, 0);\n+   }\n+}\n+private int jjMoveNfa_2(int startState, int curPos)\n+{\n+   int startsAt = 0;\n+   jjnewStateCnt = 1;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x800400000000L & l) != 0L)\n+                     kind = 22;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     kind = 22;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_1(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_1(int pos, long active0)\n+{\n+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);\n+}\n+private int jjMoveStringLiteralDfa0_1()\n+{\n+   switch(curChar)\n+   {\n+      case 92:\n+         return jjStopAtPos(0, 19);\n+      default :\n+         return jjMoveNfa_1(0, 0);\n+   }\n+}\n+private int jjMoveNfa_1(int startState, int curPos)\n+{\n+   int startsAt = 0;\n+   jjnewStateCnt = 2;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                  {\n+                     if (kind > 21)\n+                        kind = 21;\n+                  }\n+                  else if (curChar == 34)\n+                  {\n+                     if (kind > 20)\n+                        kind = 20;\n+                  }\n+                  break;\n+               case 1:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                     kind = 21;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     kind = 21;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 21)\n+                     kind = 21;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+static final int[] jjnextStates = {\n+   29, 30, 37, 38, 18, 19, 26, 27, \n+};\n+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec2[i2] & l2) != 0L);\n+      default :\n+         if ((jjbitVec0[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+\n+/** Token literal values. */\n+public static final String[] jjstrLiteralImages = {\n+\"\", null, null, null, null, null, null, \"\\156\\165\\154\\154\", \"\\116\\141\\116\", \n+\"\\111\\156\\146\\151\\156\\151\\164\\171\", null, null, null, null, null, null, null, null, \"\\42\", null, null, null, null, \n+null, null, null, \"\\51\\135\\175\\47\\12\", \"\\173\", \"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \n+\"\\55\", \"\\56\", };\n+\n+/** Lexer state names. */\n+public static final String[] lexStateNames = {\n+   \"DEFAULT\",\n+   \"STRING_STATE\",\n+   \"ESC_STATE\",\n+   \"HEX_STATE\",\n+};\n+\n+/** Lex State array. */\n+public static final int[] jjnewLexState = {\n+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, \n+   1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n+};\n+static final long[] jjtoToken = {\n+   0x7fe775fe1L, \n+};\n+static final long[] jjtoSkip = {\n+   0x1eL, \n+};\n+static final long[] jjtoMore = {\n+   0x880000L, \n+};\n+protected SimpleCharStream input_stream;\n+private final int[] jjrounds = new int[43];\n+private final int[] jjstateSet = new int[86];\n+protected char curChar;\n+/** Constructor. */\n+public JsonParserJavaccTokenManager(SimpleCharStream stream){\n+   if (SimpleCharStream.staticFlag)\n+      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n+   input_stream = stream;\n+}\n+\n+/** Constructor. */\n+public JsonParserJavaccTokenManager(SimpleCharStream stream, int lexState){\n+   this(stream);\n+   SwitchTo(lexState);\n+}\n+\n+/** Reinitialise parser. */\n+public void ReInit(SimpleCharStream stream)\n+{\n+   jjmatchedPos = jjnewStateCnt = 0;\n+   curLexState = defaultLexState;\n+   input_stream = stream;\n+   ReInitRounds();\n+}\n+private void ReInitRounds()\n+{\n+   int i;\n+   jjround = 0x80000001;\n+   for (i = 43; i-- > 0;)\n+      jjrounds[i] = 0x80000000;\n+}\n+\n+/** Reinitialise parser. */\n+public void ReInit(SimpleCharStream stream, int lexState)\n+{\n+   ReInit(stream);\n+   SwitchTo(lexState);\n+}\n+\n+/** Switch to specified lex state. */\n+public void SwitchTo(int lexState)\n+{\n+   if (lexState >= 4 || lexState < 0)\n+      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n+   else\n+      curLexState = lexState;\n+}\n+\n+protected Token jjFillToken()\n+{\n+   final Token t;\n+   final String curTokenImage;\n+   final int beginLine;\n+   final int endLine;\n+   final int beginColumn;\n+   final int endColumn;\n+   String im = jjstrLiteralImages[jjmatchedKind];\n+   curTokenImage = (im == null) ? input_stream.GetImage() : im;\n+   beginLine = input_stream.getBeginLine();\n+   beginColumn = input_stream.getBeginColumn();\n+   endLine = input_stream.getEndLine();\n+   endColumn = input_stream.getEndColumn();\n+   t = Token.newToken(jjmatchedKind);\n+   t.kind = jjmatchedKind;\n+   t.image = curTokenImage;\n+\n+   t.beginLine = beginLine;\n+   t.endLine = endLine;\n+   t.beginColumn = beginColumn;\n+   t.endColumn = endColumn;\n+\n+   return t;\n+}\n+\n+int curLexState = 0;\n+int defaultLexState = 0;\n+int jjnewStateCnt;\n+int jjround;\n+int jjmatchedPos;\n+int jjmatchedKind;\n+\n+/** Get the next Token. */\n+public Token getNextToken() \n+{\n+  Token matchedToken;\n+  int curPos = 0;\n+\n+  EOFLoop :\n+  for (;;)\n+  {\n+   try\n+   {\n+      curChar = input_stream.BeginToken();\n+   }\n+   catch(java.io.IOException e)\n+   {\n+      jjmatchedKind = 0;\n+      matchedToken = jjFillToken();\n+      return matchedToken;\n+   }\n+\n+   for (;;)\n+   {\n+     switch(curLexState)\n+     {\n+       case 0:\n+         try { input_stream.backup(0);\n+            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)\n+               curChar = input_stream.BeginToken();\n+         }\n+         catch (java.io.IOException e1) { continue EOFLoop; }\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_0();\n+         break;\n+       case 1:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_1();\n+         break;\n+       case 2:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_2();\n+         break;\n+       case 3:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_3();\n+         break;\n+     }\n+     if (jjmatchedKind != 0x7fffffff)\n+     {\n+        if (jjmatchedPos + 1 < curPos)\n+           input_stream.backup(curPos - jjmatchedPos - 1);\n+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+           matchedToken = jjFillToken();\n+       if (jjnewLexState[jjmatchedKind] != -1)\n+         curLexState = jjnewLexState[jjmatchedKind];\n+           return matchedToken;\n+        }\n+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+         if (jjnewLexState[jjmatchedKind] != -1)\n+           curLexState = jjnewLexState[jjmatchedKind];\n+           continue EOFLoop;\n+        }\n+      if (jjnewLexState[jjmatchedKind] != -1)\n+        curLexState = jjnewLexState[jjmatchedKind];\n+        curPos = 0;\n+        jjmatchedKind = 0x7fffffff;\n+        try {\n+           curChar = input_stream.readChar();\n+           continue;\n+        }\n+        catch (java.io.IOException e1) { }\n+     }\n+     int error_line = input_stream.getEndLine();\n+     int error_column = input_stream.getEndColumn();\n+     String error_after = null;\n+     boolean EOFSeen = false;\n+     try { input_stream.readChar(); input_stream.backup(1); }\n+     catch (java.io.IOException e1) {\n+        EOFSeen = true;\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+        if (curChar == '\\n' || curChar == '\\r') {\n+           error_line++;\n+           error_column = 0;\n+        }\n+        else\n+           error_column++;\n+     }\n+     if (!EOFSeen) {\n+        input_stream.backup(1);\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+     }\n+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n+   }\n+  }\n+}\n+\n+private void jjCheckNAdd(int state)\n+{\n+   if (jjrounds[state] != jjround)\n+   {\n+      jjstateSet[jjnewStateCnt++] = state;\n+      jjrounds[state] = jjround;\n+   }\n+}\n+private void jjAddStates(int start, int end)\n+{\n+   do {\n+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n+   } while (start++ != end);\n+}\n+private void jjCheckNAddTwoStates(int state1, int state2)\n+{\n+   jjCheckNAdd(state1);\n+   jjCheckNAdd(state2);\n+}\n+\n+private void jjCheckNAddStates(int start, int end)\n+{\n+   do {\n+      jjCheckNAdd(jjnextStates[start]);\n+   } while (start++ != end);\n+}\n+\n+}", "timestamp": 1238522315, "metainfo": ""}