{"sha": "c6a4f55d1a9b191dbbd958c366091e567191ccab", "log": "Fix for Issue #40.", "commit": "\n--- a/gson/src/main/java/com/google/gson/TypeInfoFactory.java\n+++ b/gson/src/main/java/com/google/gson/TypeInfoFactory.java\n         int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n         Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n         return actualTypeArguments[indexOfActualTypeArgument];\n+      } else if (typeToEvaluate instanceof TypeVariable<?>) {\n+        Type theSearchedType = null;\n+\n+        do {\n+          theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate);\n+        } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>));\n+\n+        if (theSearchedType != null) {\n+          return theSearchedType;\n+        }\n       }\n+\n       throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n-          + \".\\n Are you missing the use of TypeToken idiom?\\n See \" \n+          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n           + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n     } else if (typeToEvaluate instanceof WildcardType) {\n       WildcardType castedType = (WildcardType) typeToEvaluate;\n       throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n           + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n     }\n+  }\n+\n+  private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) {\n+    Class<?> rawParentType = null;\n+    if (parentType instanceof Class<?>) {\n+      rawParentType = (Class<?>) parentType;\n+    } else if (parentType instanceof ParameterizedType) {\n+      ParameterizedType parentTypeAsPT = (ParameterizedType) parentType;\n+      rawParentType = (Class<?>) parentTypeAsPT.getRawType();\n+    } else {\n+      return null;\n+    }\n+\n+    Type superClass = rawParentType.getGenericSuperclass();\n+    if (superClass instanceof ParameterizedType\n+        && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) {\n+      // Evaluate type on this type\n+      TypeVariable<?>[] classTypeVariables =\n+          ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters();\n+      int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate);\n+\n+      Type[] actualTypeArguments = null;\n+      if (parentType instanceof Class<?>) {\n+        actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments();\n+      } else if (parentType instanceof ParameterizedType) {\n+        actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments();\n+      } else {\n+        return null;\n+      }\n+\n+      return actualTypeArguments[indexOfActualTypeArgument];\n+    }\n+\n+    Type searchedType = null;\n+    if (superClass != null) {\n+      searchedType = extractTypeForHierarchy(superClass, typeToEvaluate);\n+    }\n+    return searchedType;\n   }\n \n   private static Type[] extractRealTypes(\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/TypeVariableTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Functional test for Gson serialization and deserialization of\n+ * @author Joel Leitch\n+ */\n+public class TypeVariableTest extends TestCase {\n+\n+  public void testSingle() throws Exception {\n+    Gson gson = new Gson();\n+    Bar bar1 = new Bar(\"someString\", 1);\n+    ArrayList<Integer> arrayList = new ArrayList<Integer>();\n+    arrayList.add(1);\n+    arrayList.add(2);\n+    bar1.map.put(\"key1\", arrayList);\n+    bar1.map.put(\"key2\", new ArrayList<Integer>());\n+    String json = gson.toJson(bar1);\n+    System.out.println(json);\n+\n+    Bar bar2 = gson.fromJson(json, Bar.class);\n+    assertEquals(bar1, bar2);\n+  }\n+\n+  public static class Foo<S, T> {\n+    private final S someSField;\n+    private final T someTField;\n+    public final Map<S, List<T>> map = new HashMap<S, List<T>>();\n+\n+    public Foo(S sValue, T tValue) {\n+      this.someSField = sValue;\n+      this.someTField = tValue;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof Foo)) {\n+        return false;\n+      } else {\n+        Foo<S, T> realFoo = (Foo<S, T>) o;\n+        return someTField.equals(realFoo.someTField)\n+          && someSField.equals(realFoo.someSField)\n+          && map.equals(realFoo.map);\n+      }\n+    }\n+  }\n+\n+  public static class Bar extends Foo<String, Integer> {\n+    public Bar() {\n+      this(\"\", 0);\n+    }\n+\n+    public Bar(String s, Integer i) {\n+      super(s, i);\n+    }\n+  }\n+}", "timestamp": 1288668759, "metainfo": ""}