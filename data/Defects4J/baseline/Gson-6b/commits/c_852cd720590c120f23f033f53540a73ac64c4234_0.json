{"sha": "852cd720590c120f23f033f53540a73ac64c4234", "log": "Don't allocate a whole bunch of objects each time we deserialize a map key. This saves 20% on bug 375's benchmark.  The fix here is quite distasteful; I'm adding an ugly backdoor API for MapTypeAdapterFactory to fiddle with the internal bits of JsonReader. I'd like to revisit this sooner or later, but for now I'll take the speedup.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.stream.JsonReader;\n+import java.io.IOException;\n+\n+/**\n+ * Internal-only APIs of JsonReader available only to other classes in Gson.\n+ */\n+public abstract class JsonReaderInternalAccess {\n+  public static JsonReaderInternalAccess INSTANCE;\n+\n+  /**\n+   * Changes the type of the current property name token to a string value.\n+   */\n+  public abstract void promoteNameToValue(JsonReader reader) throws IOException;\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n import com.google.gson.TypeAdapter;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.JsonReaderInternalAccess;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Streams;\n import com.google.gson.reflect.TypeToken;\n       } else {\n         reader.beginObject();\n         while (reader.hasNext()) {\n-          String keyString = reader.nextName();\n-          K key = keyTypeAdapter.fromJsonElement(new JsonPrimitive(keyString));\n+          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(reader);\n+          K key = keyTypeAdapter.read(reader);\n           V value = valueTypeAdapter.read(reader);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.internal.JsonReaderInternalAccess;\n import java.io.Closeable;\n import java.io.EOFException;\n import java.io.IOException;\n     snippet.append(buffer, pos, afterPos);\n     return snippet;\n   }\n+\n+  static {\n+    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n+      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n+        reader.quickPeek();\n+        if (reader.token != JsonToken.NAME) {\n+          throw new IllegalStateException(\"Expected a name but was \" + reader.peek());\n+        }\n+        reader.value = reader.name;\n+        reader.name = null;\n+        reader.token = JsonToken.STRING;\n+      }\n+    };\n+  }\n }", "timestamp": 1322321768, "metainfo": ""}