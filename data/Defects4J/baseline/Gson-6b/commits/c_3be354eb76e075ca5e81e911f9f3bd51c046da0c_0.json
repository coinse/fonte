{"sha": "3be354eb76e075ca5e81e911f9f3bd51c046da0c", "log": "APT hello world. This generates an empty class for each class annotated @GeneratedTypeAdapter.", "commit": "\n--- /dev/null\n+++ b/gson/gson-codegen/src/main/java/com/google/gson/codegen/CodeGen.java\n+/*\n+ * Copyright (C) 2012 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.codegen;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+public class CodeGen {\n+  private CodeGen() {\n+  }\n+\n+  public static PackageElement getPackage(Element type) {\n+    while (type.getKind() != ElementKind.PACKAGE) {\n+      type = type.getEnclosingElement();\n+    }\n+    return (PackageElement) type;\n+  }\n+\n+  /**\n+   * Returns a fully qualified class name to complement {@code type}.\n+   */\n+  public static String adapterName(TypeElement typeElement, String suffix) {\n+    StringBuilder builder = new StringBuilder();\n+    rawTypeToString(builder, typeElement, '$');\n+    builder.append(suffix);\n+    return builder.toString();\n+  }\n+\n+  static void rawTypeToString(StringBuilder result, TypeElement type, char innerClassSeparator) {\n+    String packageName = getPackage(type).getQualifiedName().toString();\n+    String qualifiedName = type.getQualifiedName().toString();\n+    result.append(packageName);\n+    result.append('.');\n+    result.append(\n+        qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));\n+  }\n+}\n--- /dev/null\n+++ b/gson/gson-codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapter.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.codegen;\n+\n+public @interface GeneratedTypeAdapter {\n+  Class<?>[] value() default {};\n+}\n--- /dev/null\n+++ b/gson/gson-codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapterProcessor.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.codegen;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaFileObject;\n+\n+import static java.lang.reflect.Modifier.FINAL;\n+\n+@SupportedAnnotationTypes(\"com.google.gson.codegen.GeneratedTypeAdapter\")\n+@SupportedSourceVersion(SourceVersion.RELEASE_6)\n+public final class GeneratedTypeAdapterProcessor extends AbstractProcessor {\n+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {\n+    try {\n+      for (Element element : env.getElementsAnnotatedWith(GeneratedTypeAdapter.class)) {\n+        writeAdapter((TypeElement) element);\n+      }\n+    } catch (IOException e) {\n+      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());\n+    }\n+    return true;\n+  }\n+\n+  private void writeAdapter(TypeElement type) throws IOException {\n+    String typeAdapterName = CodeGen.adapterName(type, \"$TypeAdapter\");\n+    JavaFileObject sourceFile = processingEnv.getFiler()\n+        .createSourceFile(typeAdapterName, type);\n+\n+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());\n+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());\n+    writer.beginType(typeAdapterName, \"class\", FINAL, null);\n+    writer.endType();\n+    writer.close();\n+  }\n+}\n--- /dev/null\n+++ b/gson/gson-codegen/src/main/java/com/google/gson/codegen/JavaWriter.java\n+/**\n+ * Copyright (C) 2012 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.codegen;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Emits Java source files.\n+ */\n+public final class JavaWriter {\n+  private static final Pattern TYPE_PATTERN = Pattern.compile(\"(?:[\\\\w$]+\\\\.)*([\\\\w$]+)\");\n+  private static final String INDENT = \"  \";\n+\n+  /** Map fully qualified type names to their short names. */\n+  private final Map<String, String> importedTypes = new HashMap<String, String>();\n+\n+  private String packagePrefix;\n+  private final List<Scope> scopes = new ArrayList<Scope>();\n+  private final Writer out;\n+\n+  /**\n+   * @param out the stream to which Java source will be written. This should be\n+   *     a buffered stream.\n+   */\n+  public JavaWriter(Writer out) {\n+    this.out = out;\n+  }\n+\n+  /**\n+   * Emit a package declaration.\n+   */\n+  public void addPackage(String packageName) throws IOException {\n+    if (this.packagePrefix != null) {\n+      throw new IllegalStateException();\n+    }\n+    out.write(\"package \");\n+    out.write(packageName);\n+    out.write(\";\\n\");\n+    this.packagePrefix = packageName + \".\";\n+  }\n+\n+  /**\n+   * Equivalent to {@code addImport(type.getName())}.\n+   */\n+  public void addImport(Class<?> type) throws IOException {\n+    addImport(type.getName());\n+  }\n+\n+  /**\n+   * Emit an import for {@code type}. For the duration of the file, all\n+   * references to this class will be automatically shortened.\n+   */\n+  public void addImport(String type) throws IOException {\n+    Matcher matcher = TYPE_PATTERN.matcher(type);\n+    if (!matcher.matches()) {\n+      throw new IllegalArgumentException(type);\n+    }\n+    if (importedTypes.put(type, matcher.group(1)) != null) {\n+      throw new IllegalArgumentException(type);\n+    }\n+    out.write(\"import \");\n+    out.write(type);\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * Emits a name like {@code java.lang.String} or {@code\n+   * java.util.List<java.lang.String>}, shorting it with imports if\n+   * possible.\n+   */\n+  private void type(String type) throws IOException {\n+    if (this.packagePrefix == null) {\n+      throw new IllegalStateException();\n+    }\n+\n+    Matcher m = TYPE_PATTERN.matcher(type);\n+    int pos = 0;\n+    while (true) {\n+      boolean found = m.find(pos);\n+\n+      // copy non-matching characters like \"<\"\n+      int typeStart = found ? m.start() : type.length();\n+      out.write(type, pos, typeStart - pos);\n+\n+      if (!found) {\n+        break;\n+      }\n+\n+      // copy a single class name, shortening it if possible\n+      String name = m.group(0);\n+      String imported;\n+      if ((imported = importedTypes.get(name)) != null) {\n+        out.write(imported);\n+      } else if (name.startsWith(packagePrefix)\n+          && name.indexOf('.', packagePrefix.length()) == -1) {\n+        out.write(name.substring(packagePrefix.length()));\n+      } else if (name.startsWith(\"java.lang.\")) {\n+        out.write(name.substring(\"java.lang.\".length()));\n+      } else {\n+        out.write(name);\n+      }\n+      pos = m.end();\n+    }\n+  }\n+\n+  /**\n+   * Emits a type declaration.\n+   *\n+   * @param kind such as \"class\", \"interface\" or \"enum\".\n+   */\n+  public void beginType(String type, String kind, int modifiers) throws IOException {\n+    beginType(type, kind, modifiers, null);\n+  }\n+\n+  /**\n+   * Emits a type declaration.\n+   *\n+   * @param kind such as \"class\", \"interface\" or \"enum\".\n+   * @param extendsType the class to extend, or null for no extends clause.\n+   */\n+  public void beginType(String type, String kind, int modifiers,\n+      String extendsType, String... implementsTypes) throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    out.write(kind);\n+    out.write(\" \");\n+    type(type);\n+    if (extendsType != null) {\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"    extends \");\n+      type(extendsType);\n+    }\n+    if (implementsTypes.length > 0) {\n+      out.write(\"\\n\");\n+      indent();\n+      out.write(\"    implements \");\n+      for (int i = 0; i < implementsTypes.length; i++) {\n+        if (i != 0) {\n+          out.write(\", \");\n+        }\n+        type(implementsTypes[i]);\n+      }\n+    }\n+    out.write(\" {\\n\");\n+    pushScope(Scope.TYPE_DECLARATION);\n+  }\n+\n+  /**\n+   * Completes the current type declaration.\n+   */\n+  public void endType() throws IOException {\n+    if (popScope() != Scope.TYPE_DECLARATION) {\n+      throw new IllegalStateException();\n+    }\n+    indent();\n+    out.write(\"}\\n\");\n+  }\n+\n+  /**\n+   * Emits a field declaration.\n+   */\n+  public void field(String type, String name, int modifiers) throws IOException {\n+    field(type, name, modifiers, null);\n+  }\n+\n+  public void field(String type, String name, int modifiers, String initialValue)\n+      throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    type(type);\n+    out.write(\" \");\n+    out.write(name);\n+\n+    if (initialValue != null) {\n+      out.write(\" = \");\n+      out.write(initialValue);\n+    }\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * Emit a method declaration.\n+   *\n+   * @param returnType the method's return type, or null for constructors.\n+   * @param parameters alternating parameter types and names.\n+   * @param name the method name, or the fully qualified class name for\n+   *     constructors.\n+   */\n+  public void beginMethod(String returnType, String name, int modifiers, String... parameters)\n+      throws IOException {\n+    indent();\n+    modifiers(modifiers);\n+    if (returnType != null) {\n+      type(returnType);\n+      out.write(\" \");\n+      out.write(name);\n+    } else {\n+      type(name);\n+    }\n+    out.write(\"(\");\n+    for (int p = 0; p < parameters.length; ) {\n+      if (p != 0) {\n+        out.write(\", \");\n+      }\n+      type(parameters[p++]);\n+      out.write(\" \");\n+      type(parameters[p++]);\n+    }\n+    out.write(\")\");\n+    if ((modifiers & Modifier.ABSTRACT) != 0) {\n+      out.write(\";\\n\");\n+      pushScope(Scope.ABSTRACT_METHOD);\n+    } else {\n+      out.write(\" {\\n\");\n+      pushScope(Scope.NON_ABSTRACT_METHOD);\n+    }\n+  }\n+\n+  /**\n+   * Annotates the next element with {@code annotation}. The annotation has no\n+   * attributes.\n+   */\n+  public void annotation(String annotation) throws IOException {\n+    indent();\n+    out.write(\"@\");\n+    type(annotation);\n+    out.write(\"\\n\");\n+  }\n+\n+  /**\n+   * Equivalent to {@code annotation(annotationType.getName())}.\n+   */\n+  public void annotation(Class<? extends Annotation> annotationType) throws IOException {\n+    annotation(annotationType.getName());\n+  }\n+\n+  /**\n+   * @param pattern a code pattern like \"int i = %s\". Shouldn't contain a\n+   * trailing semicolon or newline character.\n+   */\n+  public void statement(String pattern, Object... args) throws IOException {\n+    checkInMethod();\n+    indent();\n+    out.write(String.format(pattern, args));\n+    out.write(\";\\n\");\n+  }\n+\n+  /**\n+   * @param controlFlow the control flow construct and its code, such as\n+   *     \"if (foo == 5)\". Shouldn't contain braces or newline characters.\n+   */\n+  public void beginControlFlow(String controlFlow) throws IOException {\n+    checkInMethod();\n+    indent();\n+    out.write(controlFlow);\n+    out.write(\" {\\n\");\n+    pushScope(Scope.CONTROL_FLOW);\n+  }\n+\n+  /**\n+   * @param controlFlow the control flow construct and its code, such as\n+   *     \"else if (foo == 10)\". Shouldn't contain braces or newline characters.\n+   */\n+  public void nextControlFlow(String controlFlow) throws IOException {\n+    if (popScope() != Scope.CONTROL_FLOW) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    indent();\n+    pushScope(Scope.CONTROL_FLOW);\n+    out.write(\"} \");\n+    out.write(controlFlow);\n+    out.write(\" {\\n\");\n+  }\n+\n+  public void endControlFlow() throws IOException {\n+    endControlFlow(null);\n+  }\n+\n+  /**\n+   * @param controlFlow the optional control flow construct and its code, such\n+   *     as \"while(foo == 20)\". Only used for \"do/while\" control flows.\n+   */\n+  public void endControlFlow(String controlFlow) throws IOException {\n+    if (popScope() != Scope.CONTROL_FLOW) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    indent();\n+    if (controlFlow != null) {\n+      out.write(\"} \");\n+      out.write(controlFlow);\n+      out.write(\";\\n\");\n+    } else {\n+      out.write(\"}\\n\");\n+    }\n+  }\n+\n+  /**\n+   * Completes the current method declaration.\n+   */\n+  public void endMethod() throws IOException {\n+    Scope popped = popScope();\n+    if (popped == Scope.NON_ABSTRACT_METHOD) {\n+      indent();\n+      out.write(\"}\\n\");\n+    } else if (popped != Scope.ABSTRACT_METHOD) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  /**\n+   * Returns the string literal representing {@code data}, including wrapping\n+   * quotes.\n+   */\n+  public static String stringLiteral(String data) {\n+    StringBuilder result = new StringBuilder();\n+    result.append('\"');\n+    for (int i = 0; i < data.length(); i++) {\n+      char c = data.charAt(i);\n+      switch (c) {\n+        case '\"':\n+          result.append(\"\\\\\\\"\");\n+          break;\n+        case '\\\\':\n+          result.append(\"\\\\\\\\\");\n+          break;\n+        case '\\t':\n+          result.append(\"\\\\\\t\");\n+          break;\n+        case '\\b':\n+          result.append(\"\\\\\\b\");\n+          break;\n+        case '\\n':\n+          result.append(\"\\\\\\n\");\n+          break;\n+        case '\\r':\n+          result.append(\"\\\\\\r\");\n+          break;\n+        case '\\f':\n+          result.append(\"\\\\\\f\");\n+          break;\n+        default:\n+          result.append(c);\n+      }\n+    }\n+    result.append('\"');\n+    return result.toString();\n+  }\n+\n+  public void close() throws IOException {\n+    out.close();\n+  }\n+\n+  /**\n+   * Emit modifier names.\n+   */\n+  private void modifiers(int modifiers) throws IOException {\n+    if ((modifiers & Modifier.PUBLIC) != 0) {\n+      out.write(\"public \");\n+    }\n+    if ((modifiers & Modifier.PRIVATE) != 0) {\n+      out.write(\"private \");\n+    }\n+    if ((modifiers & Modifier.PROTECTED) != 0) {\n+      out.write(\"protected \");\n+    }\n+    if ((modifiers & Modifier.STATIC) != 0) {\n+      out.write(\"static \");\n+    }\n+    if ((modifiers & Modifier.FINAL) != 0) {\n+      out.write(\"final \");\n+    }\n+    if ((modifiers & Modifier.ABSTRACT) != 0) {\n+      out.write(\"abstract \");\n+    }\n+    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {\n+      out.write(\"synchronized \");\n+    }\n+    if ((modifiers & Modifier.TRANSIENT) != 0) {\n+      out.write(\"transient \");\n+    }\n+    if ((modifiers & Modifier.VOLATILE) != 0) {\n+      out.write(\"volatile \");\n+    }\n+  }\n+\n+  private void indent() throws IOException {\n+    for (int i = 0; i < scopes.size(); i++) {\n+      out.write(INDENT);\n+    }\n+  }\n+\n+  private void checkInMethod() {\n+    Scope scope = peekScope();\n+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+  private void pushScope(Scope pushed) {\n+    scopes.add(pushed);\n+  }\n+\n+  private Scope peekScope() {\n+    return scopes.get(scopes.size() - 1);\n+  }\n+\n+  private Scope popScope() {\n+    return scopes.remove(scopes.size() - 1);\n+  }\n+\n+  private enum Scope {\n+    TYPE_DECLARATION,\n+    ABSTRACT_METHOD,\n+    NON_ABSTRACT_METHOD,\n+    CONTROL_FLOW,\n+  }\n+}", "timestamp": 1343861884, "metainfo": ""}