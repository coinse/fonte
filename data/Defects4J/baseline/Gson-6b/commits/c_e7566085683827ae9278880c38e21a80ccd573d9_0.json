{"sha": "e7566085683827ae9278880c38e21a80ccd573d9", "log": "Forbid custom serializers for primitive types (so we can avoid boxing in the reflective and array adapters)", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n import com.google.gson.internal.$Gson$Preconditions;\n-\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n   private GsonBuilder registerTypeAdapter(Type type, Object typeAdapter, boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n         || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+    if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type)) {\n+      throw new IllegalArgumentException(\n+          \"Cannot register type adapters for \" + type);\n+    }\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter, isSystem);\n     }\n--- a/gson/src/main/java/com/google/gson/Primitives.java\n+++ b/gson/src/main/java/com/google/gson/Primitives.java\n package com.google.gson;\n \n \n+import com.google.gson.internal.$Gson$Preconditions;\n import java.lang.reflect.Type;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-\n-import com.google.gson.internal.$Gson$Preconditions;\n \n /**\n  * Contains static utility methods pertaining to primitive types and their\n    *\n    * @see Class#isPrimitive\n    */\n-  public static boolean isWrapperType(Class<?> type) {\n+  public static boolean isWrapperType(Type type) {\n     return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n         $Gson$Preconditions.checkNotNull(type));\n   }\n--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java\n import java.lang.reflect.Type;\n \n /**\n- * Functional Test exercising custom deserialization only.  When test applies to both \n+ * Functional Test exercising custom deserialization only.  When test applies to both\n  * serialization and deserialization then add it to CustomTypeAdapterTest.\n  *\n  * @author Joel Leitch\n public class CustomDeserializerTest extends TestCase {\n   private static final String DEFAULT_VALUE = \"test123\";\n   private static final String SUFFIX = \"blah\";\n-  \n+\n   private Gson gson;\n-  \n+\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n     gson = new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();\n   }\n-  \n+\n   public void testDefaultConstructorNotCalledOnObject() throws Exception {\n     DataHolder data = new DataHolder(DEFAULT_VALUE);\n     String json = gson.toJson(data);\n-    \n+\n     DataHolder actual = gson.fromJson(json, DataHolder.class);\n     assertEquals(DEFAULT_VALUE + SUFFIX, actual.getData());\n   }\n-  \n+\n   public void testDefaultConstructorNotCalledOnField() throws Exception {\n     DataHolderWrapper dataWrapper = new DataHolderWrapper(new DataHolder(DEFAULT_VALUE));\n     String json = gson.toJson(dataWrapper);\n-    \n+\n     DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class);\n     assertEquals(DEFAULT_VALUE + SUFFIX, actual.getWrappedData().getData());\n   }\n     private DataHolder() {\n       throw new IllegalStateException();\n     }\n-    \n+\n     public DataHolder(String data) {\n       this.data = data;\n     }\n-    \n+\n     public String getData() {\n       return data;\n     }\n   }\n-  \n+\n   private static class DataHolderWrapper {\n     private final DataHolder wrappedData;\n-    \n+\n     // For use by Gson\n     @SuppressWarnings(\"unused\")\n     private DataHolderWrapper() {\n       this(new DataHolder(DEFAULT_VALUE));\n     }\n-    \n+\n     public DataHolderWrapper(DataHolder data) {\n       this.wrappedData = data;\n     }\n       return wrappedData;\n     }\n   }\n-  \n+\n   private static class DataHolderDeserializer implements JsonDeserializer<DataHolder> {\n     public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       return new DataHolder(dataString + SUFFIX);\n     }\n   }\n-  \n+\n   public void testJsonTypeFieldBasedDeserialization() {\n     String json = \"{field1:'abc',field2:'def',__type__:'SUB_TYPE1'}\";\n     Gson gson = new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer<MyBase>() {\n         String type = json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();\n         return context.deserialize(json, SubTypes.valueOf(type).getSubclass());\n       }\n-    }).create();    \n+    }).create();\n     SubType1 target = (SubType1) gson.fromJson(json, MyBase.class);\n-    assertEquals(\"abc\", target.field1);    \n+    assertEquals(\"abc\", target.field1);\n   }\n \n   private static class MyBase {\n     static final String TYPE_ACCESS = \"__type__\";\n   }\n \n-  private enum SubTypes { \n+  private enum SubTypes {\n     SUB_TYPE1(SubType1.class),\n     SUB_TYPE2(SubType2.class);\n     private final Type subClass;\n   }\n \n   private static class SubType1 extends MyBase {\n-    String field1;    \n+    String field1;\n   }\n \n   private static class SubType2 extends MyBase {\n     @SuppressWarnings(\"unused\")\n-    String field2;    \n-  }\n-  \n+    String field2;\n+  }\n+\n   public void testCustomDeserializerReturnsNullForTopLevelObject() {\n     Gson gson = new GsonBuilder()\n       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {\n     assertNull(target.base);\n   }\n \n-  public void testCustomDeserializerReturnsNullForTopLevelPrimitives() {\n-    Gson gson = new GsonBuilder()\n-      .registerTypeAdapter(long.class, new JsonDeserializer<Long>() {\n-        public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-            throws JsonParseException {\n-          return null;\n-        }\n-      }).create();\n-    String json = \"10\";\n-    assertNull(gson.fromJson(json, long.class));\n-  }\n-\n-  public void testCustomDeserializerReturnsNullForPrimitiveFields() {\n-    Gson gson = new GsonBuilder()\n-      .registerTypeAdapter(long.class, new JsonDeserializer<Long>() {\n-        public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-            throws JsonParseException {\n-          return null;\n-        }\n-      }).create();\n-    String json = \"{field:10}\";\n-    ClassWithLong target = gson.fromJson(json, ClassWithLong.class);\n-    assertEquals(0, target.field);\n-  }\n-  private static class ClassWithLong {\n-    long field;\n-  }\n- \n   public void testCustomDeserializerReturnsNullForArrayElements() {\n     Gson gson = new GsonBuilder()\n       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n     ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);\n     assertEquals(5, target.getBag().getIntValue());\n   }\n-  \n+\n   public void disable_testCustomSerializersOfSelf() {\n     Gson gson = createGsonObjectWithFooTypeAdapter();\n     Gson basicGson = new Gson();\n     Foo newFooObject = new Foo(1, 2L);\n     String jsonFromCustomSerializer = gson.toJson(newFooObject);\n     String jsonFromGson = basicGson.toJson(newFooObject);\n-    \n+\n     assertEquals(jsonFromGson, jsonFromCustomSerializer);\n   }\n \n     Foo expectedFoo = new Foo(1, 2L);\n     String json = basicGson.toJson(expectedFoo);\n     Foo newFooObject = gson.fromJson(json, Foo.class);\n-    \n+\n     assertEquals(expectedFoo.key, newFooObject.key);\n     assertEquals(expectedFoo.value, newFooObject.value);\n   }\n     ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);\n     assertEquals(7, target.getBag().getIntValue());\n   }\n-  \n+\n   public void testCustomTypeAdapterDoesNotAppliesToSubClasses() {\n     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {\n       public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n         JsonObject json = new JsonObject();\n         json.addProperty(\"value\", src.baseValue);\n         return json;\n-      }          \n+      }\n     }).create();\n     Base b = new Base();\n     String json = gson.toJson(b);\n-    assertTrue(json.contains(\"value\"));    \n+    assertTrue(json.contains(\"value\"));\n     b = new Derived();\n     json = gson.toJson(b);\n-    assertTrue(json.contains(\"derivedValue\"));    \n-  }\n-  \n+    assertTrue(json.contains(\"derivedValue\"));\n+  }\n+\n   public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {\n     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {\n       public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n         JsonObject json = new JsonObject();\n         json.addProperty(\"value\", src.baseValue);\n         return json;\n-      }          \n+      }\n     }).create();\n     Base b = new Base();\n     String json = gson.toJson(b);\n-    assertTrue(json.contains(\"value\"));    \n+    assertTrue(json.contains(\"value\"));\n     b = new Derived();\n     json = gson.toJson(b, Base.class);\n-    assertTrue(json.contains(\"value\"));    \n+    assertTrue(json.contains(\"value\"));\n     assertFalse(json.contains(\"derivedValue\"));\n   }\n-  \n+\n   private static class Base {\n     int baseValue = 2;\n   }\n-  \n+\n   private static class Derived extends Base {\n     @SuppressWarnings(\"unused\")\n     int derivedValue = 3;\n   }\n-  \n-  \n+\n+\n   private Gson createGsonObjectWithFooTypeAdapter() {\n     return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();\n   }\n-  \n+\n   public static class Foo {\n     private final int key;\n     private final long value;\n-    \n+\n     public Foo() {\n       this(0, 0L);\n     }\n       this.value = value;\n     }\n   }\n-  \n+\n   public static class FooTypeAdapter implements JsonSerializer<Foo>, JsonDeserializer<Foo> {\n     public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       return context.serialize(src, typeOfSrc);\n     }\n   }\n-  \n-  public void testCustomSerializerForLong() {\n-    final ClassWithBooleanField customSerializerInvoked = new ClassWithBooleanField();\n-    customSerializerInvoked.value = false;\n-    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonSerializer<Long>() {\n-      public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {\n-        customSerializerInvoked.value = true;\n-        return new JsonPrimitive(src);\n-      }      \n-    }).serializeNulls().create();\n-    ClassWithWrapperLongField src = new ClassWithWrapperLongField();\n-    String json = gson.toJson(src);\n-    assertTrue(json.contains(\"\\\"value\\\":null\"));\n-    assertFalse(customSerializerInvoked.value);\n-    \n-    customSerializerInvoked.value = false;\n-    src.value = 10L;\n-    json = gson.toJson(src);\n-    assertTrue(json.contains(\"\\\"value\\\":10\"));\n-    assertTrue(customSerializerInvoked.value);\n-  }\n-  \n-  public void testCustomDeserializerForLong() {\n-    final ClassWithBooleanField customDeserializerInvoked = new ClassWithBooleanField();\n-    customDeserializerInvoked.value = false;\n-    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonDeserializer<Long>() {\n-      public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-          throws JsonParseException {\n-        customDeserializerInvoked.value = true;\n-        if (json == null || json.isJsonNull()) {\n-          return null;\n+\n+  public void testCustomSerializerForbiddenForPrimitives() {\n+    try {\n+      new GsonBuilder().registerTypeAdapter(long.class, new JsonSerializer<Long>() {\n+        public JsonElement serialize(Long s, Type t, JsonSerializationContext c) {\n+          throw new AssertionError();\n         }\n-        Number number = json.getAsJsonPrimitive().getAsNumber();\n-        return number == null ? null : number.longValue();\n-      }      \n-    }).create();\n-    String json = \"{'value':null}\";\n-    ClassWithWrapperLongField target = gson.fromJson(json, ClassWithWrapperLongField.class);\n-    assertNull(target.value);\n-    assertFalse(customDeserializerInvoked.value);\n-    \n-    customDeserializerInvoked.value = false;\n-    json = \"{'value':10}\";\n-    target = gson.fromJson(json, ClassWithWrapperLongField.class);\n-    assertEquals(10L, target.value.longValue());\n-    assertTrue(customDeserializerInvoked.value);\n-  }\n-  \n-  private static class ClassWithWrapperLongField {\n-    Long value;\n-  }\n-  \n-  private static class ClassWithBooleanField {\n-    Boolean value;\n-  }\n-  \n+      });\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testCustomDeserializerForbiddenForPrimitives() {\n+    try {\n+      new GsonBuilder().registerTypeAdapter(long.class, new JsonDeserializer<Long>() {\n+        public Long deserialize(JsonElement json, Type t, JsonDeserializationContext c) {\n+          throw new AssertionError();\n+        }\n+      });\n+      fail();\n+    } catch (Exception expected) {\n+    }\n+  }\n+\n   public void testCustomByteArraySerializer() {\n     Gson gson = new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {\n       public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {\n           sb.append(b);\n         }\n         return new JsonPrimitive(sb.toString());\n-      }      \n+      }\n     }).create();\n     byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n     String json = gson.toJson(data);\n     assertEquals(\"\\\"0123456789\\\"\", json);\n   }\n-  \n+\n   public void testCustomByteArrayDeserializerAndInstanceCreator() {\n-    GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class, \n+    GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class,\n         new JsonDeserializer<byte[]>() {\n       public byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n           throws JsonParseException {\n           data[i] = Byte.parseByte(\"\"+str.charAt(i));\n         }\n         return data;\n-      }      \n+      }\n     });\n     Gson gson = gsonBuilder.create();\n     String json = \"'0123456789'\";\n       assertEquals(expected[i], actual[i]);\n     }\n   }\n-  \n+\n   private static class StringHolder {\n     String part1;\n     String part2;\n       this.part2 = part2;\n     }\n   }\n-  \n-  private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>, \n+\n+  private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>,\n       JsonDeserializer<StringHolder>, InstanceCreator<StringHolder> {\n \n     public StringHolder createInstance(Type type) {\n       return new StringHolder(\"unknown:thing\");\n     }\n \n-    public StringHolder deserialize(JsonElement src, Type type, \n+    public StringHolder deserialize(JsonElement src, Type type,\n         JsonDeserializationContext context) {\n       return new StringHolder(src.getAsString());\n     }\n \n-    public JsonElement serialize(StringHolder src, Type typeOfSrc, \n+    public JsonElement serialize(StringHolder src, Type typeOfSrc,\n         JsonSerializationContext context) {\n       String contents = src.part1 + ':' + src.part2;\n       return new JsonPrimitive(contents);\n     }\n   }\n-  \n+\n   // Test created from Issue 70\n   public void testCustomAdapterInvokedForCollectionElementSerializationWithType() {\n     Gson gson = new GsonBuilder()\n     assertEquals(\"Jacob\", foo.part1);\n     assertEquals(\"Tomaw\", foo.part2);\n   }\n-  \n+\n   // Test created from Issue 70\n   public void testCustomAdapterInvokedForMapElementSerializationWithType() {\n     Gson gson = new GsonBuilder()\n     String json = gson.toJson(mapOfHolders, mapType);\n     assertTrue(json.contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\"));\n   }\n-  \n+\n   // Test created from Issue 70\n   public void testCustomAdapterInvokedForMapElementSerialization() {\n     Gson gson = new GsonBuilder()\n       this.data = data;\n     }\n   }\n-  \n+\n   private static class DataHolderWrapper {\n     final DataHolder wrappedData;\n-    \n+\n     public DataHolderWrapper(DataHolder data) {\n       this.wrappedData = data;\n     }\n   }\n-  \n+\n   private static class DataHolderSerializer implements JsonSerializer<DataHolder> {\n     public JsonElement serialize(DataHolder src, Type typeOfSrc, JsonSerializationContext context) {\n       JsonObject obj = new JsonObject();", "timestamp": 1315549581, "metainfo": ""}