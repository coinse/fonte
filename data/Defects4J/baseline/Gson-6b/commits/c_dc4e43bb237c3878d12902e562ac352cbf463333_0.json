{"sha": "dc4e43bb237c3878d12902e562ac352cbf463333", "log": "Permit users to define type adapters for primitive types and strings.    Also expose an API to get the field naming strategy.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private final boolean htmlSafe;\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n+  private final FieldNamingStrategy fieldNamingPolicy;\n \n   final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n     @SuppressWarnings(\"unchecked\")\n     this.generateNonExecutableJson = generateNonExecutableGson;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n+    this.fieldNamingPolicy = fieldNamingPolicy;\n \n     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n \n     // built-in type adapters that cannot be overridden\n+    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n+    factories.add(ObjectTypeAdapter.FACTORY);\n+\n+    // user's type adapters\n+    factories.addAll(typeAdapterFactories);\n+\n+    // type adapters for basic platform types\n     factories.add(TypeAdapters.STRING_FACTORY);\n     factories.add(TypeAdapters.INTEGER_FACTORY);\n     factories.add(TypeAdapters.BOOLEAN_FACTORY);\n             doubleAdapter(serializeSpecialFloatingPointValues)));\n     factories.add(TypeAdapters.newFactory(float.class, Float.class,\n             floatAdapter(serializeSpecialFloatingPointValues)));\n-    factories.add(excluder);\n     factories.add(TypeAdapters.NUMBER_FACTORY);\n     factories.add(TypeAdapters.CHARACTER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n-    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n-    factories.add(ObjectTypeAdapter.FACTORY);\n-\n-    // user's type adapters\n-    factories.addAll(typeAdapterFactories);\n-\n-    // built-in type adapters that can be overridden\n     factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n     factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n-    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(TypeAdapters.URL_FACTORY);\n     factories.add(TypeAdapters.URI_FACTORY);\n     factories.add(TypeAdapters.UUID_FACTORY);\n     factories.add(TimeTypeAdapter.FACTORY);\n     factories.add(SqlDateTypeAdapter.FACTORY);\n     factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n-    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n     factories.add(ArrayTypeAdapter.FACTORY);\n     factories.add(TypeAdapters.ENUM_FACTORY);\n     factories.add(TypeAdapters.CLASS_FACTORY);\n+\n+    // the excluder must precede all adapters that handle user-defined types\n+    factories.add(excluder);\n+\n+    // type adapters for composite and user-defined types\n+    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n+    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n     factories.add(new ReflectiveTypeAdapterFactory(\n         constructorConstructor, fieldNamingPolicy, excluder));\n \n     this.factories = Collections.unmodifiableList(factories);\n+  }\n+\n+  /**\n+   * Returns the field naming policy used to translate Java field names to JSON\n+   * property names.\n+   */\n+  public FieldNamingStrategy getFieldNamingPolicy() {\n+    return fieldNamingPolicy;\n   }\n \n   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Excluder;\n-import com.google.gson.internal.Primitives;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n \n    * all the required interfaces for custom serialization with Gson. If a type adapter was\n    * previously registered for the specified {@code type}, it is overwritten.\n    *\n+   * <p>This registers the type specified and no other types: you must manually register related\n+   * types! For example, applications registering {@code boolean.class} should also register {@code\n+   * Boolean.class}.\n+   *\n    * @param type the type definition for the type adapter being registered\n    * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},\n    * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n         || typeAdapter instanceof JsonDeserializer<?>\n         || typeAdapter instanceof InstanceCreator<?>\n         || typeAdapter instanceof TypeAdapter<?>);\n-    if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type) || type == String.class) {\n-      throw new IllegalArgumentException(\n-          \"Cannot register type adapters for \" + type);\n-    }\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       instanceCreators.put(type, (InstanceCreator) typeAdapter);\n     }\n--- a/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n     assertEquals(\"{\\\"d\\\":\\\"d\\\"}\", gson.toJson(new HasModifiers()));\n   }\n \n-  public void testRegisterTypeAdapterForUnsupportedType() {\n+  public void testRegisterTypeAdapterForCoreType() {\n     Type[] types = {\n         byte.class,\n         int.class,\n         String.class,\n     };\n     for (Type type : types) {\n-      try {\n-        new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\n-        fail(type.toString());\n-      } catch (IllegalArgumentException e) {\n-      }\n+      new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\n     }\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.util.Locale;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Jesse Wilson\n+ */\n+public class OverrideCoreTypeAdaptersTest extends TestCase {\n+  private static final TypeAdapter<Boolean> booleanAsIntAdapter = new TypeAdapter<Boolean>() {\n+    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n+      out.value(value ? 1 : 0);\n+    }\n+    @Override public Boolean read(JsonReader in) throws IOException {\n+      int value = in.nextInt();\n+      return value != 0;\n+    }\n+  };\n+\n+  private static final TypeAdapter<String> swapCaseStringAdapter = new TypeAdapter<String>() {\n+    @Override public void write(JsonWriter out, String value) throws IOException {\n+      out.value(value.toUpperCase(Locale.US));\n+    }\n+    @Override public String read(JsonReader in) throws IOException {\n+      return in.nextString().toLowerCase(Locale.US);\n+    }\n+  };\n+\n+  public void testOverrideWrapperBooleanAdapter() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(Boolean.class, booleanAsIntAdapter)\n+        .create();\n+    assertEquals(\"true\", gson.toJson(true, boolean.class));\n+    assertEquals(\"1\", gson.toJson(true, Boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"true\", boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"1\", Boolean.class));\n+  }\n+\n+  public void testOverridePrimitiveBooleanAdapter() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(boolean.class, booleanAsIntAdapter)\n+        .create();\n+    assertEquals(\"1\", gson.toJson(true, boolean.class));\n+    assertEquals(\"true\", gson.toJson(true, Boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"1\", boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"true\", Boolean.class));\n+  }\n+\n+  public void testOverrideStringAdapter() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(String.class, swapCaseStringAdapter)\n+        .create();\n+    assertEquals(\"\\\"HELLO\\\"\", gson.toJson(\"Hello\", String.class));\n+    assertEquals(\"hello\", gson.fromJson(\"\\\"Hello\\\"\", String.class));\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n     }\n   }\n \n-  public void testCustomSerializerForbiddenForPrimitives() {\n-    try {\n-      new GsonBuilder().registerTypeAdapter(long.class, new JsonSerializer<Long>() {\n-        public JsonElement serialize(Long s, Type t, JsonSerializationContext c) {\n-          throw new AssertionError();\n-        }\n-      });\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n-  }\n-\n-  public void testCustomDeserializerForbiddenForPrimitives() {\n-    try {\n-      new GsonBuilder().registerTypeAdapter(long.class, new JsonDeserializer<Long>() {\n-        public Long deserialize(JsonElement json, Type t, JsonDeserializationContext c) {\n-          throw new AssertionError();\n-        }\n-      });\n-      fail();\n-    } catch (Exception expected) {\n-    }\n+  public void testCustomSerializerInvokedForPrimitives() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(boolean.class, new JsonSerializer<Boolean>() {\n+          public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {\n+            return new JsonPrimitive(s ? 1 : 0);\n+          }\n+        })\n+        .create();\n+    assertEquals(\"1\", gson.toJson(true, boolean.class));\n+    assertEquals(\"true\", gson.toJson(true, Boolean.class));\n+  }\n+\n+  public void testCustomDeserializerInvokedForPrimitives() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(boolean.class, new JsonDeserializer() {\n+          public Object deserialize(JsonElement json, Type t, JsonDeserializationContext context) {\n+            return json.getAsInt() != 0;\n+          }\n+        })\n+        .create();\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"1\", boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"true\", Boolean.class));\n   }\n \n   public void testCustomByteArraySerializer() {\n--- a/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\n     }\n     String json = gson.toJson(bags);\n     bags = gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>(){}.getType());\n-    // 11: 1 list object, and 10 entries. stats not invoked on individual fields of\n-    // BagOfPrimitives since those are primitives.\n-    assertEquals(11, stats.numReads);\n-    assertEquals(11, stats.numWrites);\n+    // 11: 1 list object, and 10 entries. stats invoked on all 5 fields\n+    assertEquals(51, stats.numReads);\n+    assertEquals(51, stats.numWrites);\n   }\n \n-  public void testDelegateNotInvokedOnStrings() {\n+  public void testDelegateInvokedOnStrings() {\n     String[] bags = {\"1\", \"2\", \"3\", \"4\"};\n     String json = gson.toJson(bags);\n     bags = gson.fromJson(json, String[].class);\n-    // Only 1 array object. stats not invoked on individual strings.\n-    assertEquals(1, stats.numReads);\n-    assertEquals(1, stats.numWrites);\n+    // 1 array object with 4 elements.\n+    assertEquals(5, stats.numReads);\n+    assertEquals(5, stats.numWrites);\n   }\n \n   private static class StatsTypeAdapterFactory implements TypeAdapterFactory {", "timestamp": 1341023869, "metainfo": ""}