{"sha": "8daf3aaeb4fd072d45df334dd8a6009be734c180", "log": "Inline position computation. This is uglier but faster.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   private int pos = 0;\n   private int limit = 0;\n \n-  /*\n-   * The offset of the first character in the buffer.\n-   */\n-  private int bufferStartLine = 1;\n-  private int bufferStartColumn = 1;\n+  private int lineNumber = 0;\n+  private int lineStart = 0;\n \n   private int peeked = PEEKED_NONE;\n \n       int l = limit;\n       /* the index of the first character not yet appended to the builder. */\n       int start = p;\n-      for (; p < l; p++) {\n-        int c = buffer[p];\n+      while (p < l) {\n+        int c = buffer[p++];\n \n         if (c == quote) {\n-          pos = p + 1;\n+          pos = p;\n           if (builder == null) {\n-            return new String(buffer, start, p - start);\n+            return new String(buffer, start, p - start - 1);\n           } else {\n-            builder.append(buffer, start, p - start);\n+            builder.append(buffer, start, p - start - 1);\n             return builder.toString();\n           }\n \n         } else if (c == '\\\\') {\n-          pos = p + 1;\n+          pos = p;\n           if (builder == null) {\n             builder = new StringBuilder();\n           }\n-          builder.append(buffer, start, p - start);\n+          builder.append(buffer, start, p - start - 1);\n           builder.append(readEscapeCharacter());\n           p = pos;\n           l = limit;\n           start = p;\n-          p--; // Prevent double-increment.\n+\n+        } else if (c == '\\n') {\n+          lineNumber++;\n+          lineStart = p;\n         }\n       }\n \n           readEscapeCharacter();\n           p = pos;\n           l = limit;\n+        } else if (c == '\\n') {\n+          lineNumber++;\n+          lineStart = p;\n         }\n       }\n       pos = p;\n    */\n   private boolean fillBuffer(int minimum) throws IOException {\n     char[] buffer = this.buffer;\n-\n-    // Before clobbering the old characters, update where buffer starts\n-    // Using locals here saves ~2%.\n-    int line = bufferStartLine;\n-    int column = bufferStartColumn;\n-    for (int i = 0, p = pos; i < p; i++) {\n-      if (buffer[i] == '\\n') {\n-        line++;\n-        column = 1;\n-      } else {\n-        column++;\n-      }\n-    }\n-    bufferStartLine = line;\n-    bufferStartColumn = column;\n-\n+    lineStart -= pos;\n     if (limit != pos) {\n       limit -= pos;\n       System.arraycopy(buffer, pos, buffer, 0, limit);\n       limit += total;\n \n       // if this is the first read, consume an optional byte order mark (BOM) if it exists\n-      if (bufferStartLine == 1 && bufferStartColumn == 1 && limit > 0 && buffer[0] == '\\ufeff') {\n+      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n         pos++;\n-        bufferStartColumn--;\n+        lineStart++;\n         minimum++;\n       }\n \n   }\n \n   private int getLineNumber() {\n-    int result = bufferStartLine;\n-    for (int i = 0; i < pos; i++) {\n-      if (buffer[i] == '\\n') {\n-        result++;\n-      }\n-    }\n-    return result;\n+    return lineNumber + 1;\n   }\n \n   private int getColumnNumber() {\n-    int result = bufferStartColumn;\n-    for (int i = 0; i < pos; i++) {\n-      if (buffer[i] == '\\n') {\n-        result = 1;\n-      } else {\n-        result++;\n-      }\n-    }\n-    return result;\n+    return pos - lineStart + 1;\n   }\n \n   /**\n       }\n \n       int c = buffer[p++];\n-      if (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t') {\n+      if (c == '\\n') {\n+        lineNumber++;\n+        lineStart = p;\n+        continue;\n+      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n         continue;\n       }\n \n   private void skipToEndOfLine() throws IOException {\n     while (pos < limit || fillBuffer(1)) {\n       char c = buffer[pos++];\n-      if (c == '\\r' || c == '\\n') {\n+      if (c == '\\n') {\n+        lineNumber++;\n+        lineStart = pos;\n         break;\n-      }\n-    }\n-  }\n-\n+      } else if (c == '\\r') {\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param toFind a string to search for. Must not contain a newline.\n+   */\n   private boolean skipTo(String toFind) throws IOException {\n     outer:\n     for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n+      if (buffer[pos] == '\\n') {\n+        lineNumber++;\n+        lineStart = pos + 1;\n+        continue;\n+      }\n       for (int c = 0; c < toFind.length(); c++) {\n         if (buffer[pos + c] != toFind.charAt(c)) {\n           continue outer;\n     case 'f':\n       return '\\f';\n \n+    case '\\n':\n+      lineNumber++;\n+      lineStart = pos;\n+      // fall-through\n+\n     case '\\'':\n     case '\"':\n     case '\\\\':\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.Reader;\n+import java.io.StringReader;\n import java.util.Arrays;\n import junit.framework.TestCase;\n \n   }\n \n   public void testFailWithPosition() throws IOException {\n-    testFailWithPosition(\"Expected value at line 6 column 3\",\n-        \"[\\n\\n\\n\\n\\n0,}]\");\n+    testFailWithPosition(\"Expected value at line 6 column 5\",\n+        \"[\\n\\n\\n\\n\\n\\\"a\\\",}]\");\n   }\n \n   public void testFailWithPositionGreaterThanBufferSize() throws IOException {\n     String spaces = repeat(' ', 8192);\n-    testFailWithPosition(\"Expected value at line 6 column 3\",\n-        \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n+    testFailWithPosition(\"Expected value at line 6 column 5\",\n+        \"[\\n\\n\" + spaces + \"\\n\\n\\n\\\"a\\\",}]\");\n+  }\n+\n+  public void testFailWithPositionOverSlashSlashEndOfLineComment() throws IOException {\n+    testFailWithPosition(\"Expected value at line 5 column 6\",\n+        \"\\n// foo\\n\\n//bar\\r\\n[\\\"a\\\",}\");\n+  }\n+\n+  public void testFailWithPositionOverHashEndOfLineComment() throws IOException {\n+    testFailWithPosition(\"Expected value at line 5 column 6\",\n+        \"\\n# foo\\n\\n#bar\\r\\n[\\\"a\\\",}\");\n+  }\n+\n+  public void testFailWithPositionOverCStyleComment() throws IOException {\n+    testFailWithPosition(\"Expected value at line 6 column 12\",\n+        \"\\n\\n/* foo\\n*\\n*\\r\\nbar */[\\\"a\\\",}\");\n+  }\n+\n+  public void testFailWithPositionOverQuotedString() throws IOException {\n+    testFailWithPosition(\"Expected value at line 5 column 3\", \"[\\\"foo\\nbar\\r\\nbaz\\n\\\",\\n  }\");\n+  }\n+\n+  public void testFailWithPositionOverUnquotedString() throws IOException {\n+    testFailWithPosition(\"Expected value at line 5 column 2\", \"[\\n\\nabcd\\n\\n,}\");\n+  }\n+\n+  public void testFailWithEscapedNewlineCharacter() throws IOException {\n+    testFailWithPosition(\"Expected value at line 5 column 3\", \"[\\n\\n\\\"\\\\\\n\\n\\\",}\");\n+  }\n+\n+  public void testFailWithPositionIsOffsetByBom() throws IOException {\n+    testFailWithPosition(\"Expected value at line 1 column 6\",\n+        \"\\ufeff[\\\"a\\\",}]\");\n+  }\n+\n+  private void testFailWithPosition(String message, String json) throws IOException {\n+    // Validate that it works reading the string normally.\n+    JsonReader reader1 = new JsonReader(reader(json));\n+    reader1.setLenient(true);\n+    reader1.beginArray();\n+    reader1.nextString();\n+    try {\n+      reader1.peek();\n+      fail();\n+    } catch (IOException expected) {\n+      assertEquals(message, expected.getMessage());\n+    }\n+\n+    // Also validate that it works when skipping.\n+    JsonReader reader2 = new JsonReader(reader(json));\n+    reader2.setLenient(true);\n+    reader2.beginArray();\n+    reader2.skipValue();\n+    try {\n+      reader2.peek();\n+      fail();\n+    } catch (IOException expected) {\n+      assertEquals(message, expected.getMessage());\n+    }\n   }\n \n   public void disabled_testVeryLongNumber() throws IOException {\n     reader.endArray();\n   }\n \n-  public void testFailWithPositionIsOffsetByBom() throws IOException {\n-    testFailWithPosition(\"Expected value at line 1 column 4\",\n-        \"\\ufeff[0,}]\");\n-  }\n-  \n-  private void testFailWithPosition(String message, String json) throws IOException {\n-    JsonReader reader = new JsonReader(reader(json));\n-    reader.beginArray();\n-    reader.nextInt();\n-    try {\n-      reader.peek();\n-      fail();\n-    } catch (IOException expected) {\n-      assertEquals(message, expected.getMessage());\n-    }\n-  }\n-  \n   public void testDeeplyNestedArrays() throws IOException {\n     // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer\n     JsonReader reader = new JsonReader(reader(\n    * Returns a reader that returns one character at a time.\n    */\n   private Reader reader(final String s) {\n+    if (true) return new StringReader(s);\n+\n     return new Reader() {\n       int position = 0;\n       @Override public int read(char[] buffer, int offset, int count) throws IOException {", "timestamp": 1346125938, "metainfo": ""}