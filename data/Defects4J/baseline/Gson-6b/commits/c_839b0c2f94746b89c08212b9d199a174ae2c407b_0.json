{"sha": "839b0c2f94746b89c08212b9d199a174ae2c407b", "log": "Refactored exclusion strategies so that they can easily be exposed as part of the public API.", "commit": "\n--- a/gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n \n /**\n  * Strategy for excluding anonymous and local classes.\n  */\n final class AnonymousAndLocalClassExclusionStrategy implements ExclusionStrategy {\n \n-  public boolean shouldSkipField(Field f) {\n-    return isAnonymousOrLocal(f.getType());\n+  public boolean shouldSkipField(FieldAttributes f) {\n+    return isAnonymousOrLocal(f.getDeclaredClass());\n   }\n \n   public boolean shouldSkipClass(Class<?> clazz) {\n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n import java.util.Collection;\n \n /**\n     this.strategies = strategies;\n   }\n \n-  public boolean shouldSkipField(Field f) {\n+  public boolean shouldSkipField(FieldAttributes f) {\n     for (ExclusionStrategy strategy : strategies) {\n       if (strategy.shouldSkipField(f)) {\n         return true;\n--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n-\n /**\n- * A strategy definition that is used by the {@link ObjectNavigator} to\n- * determine whether or not the field of the object should be ignored during\n- * navigation.\n+ * A strategy pattern (see \"Design Patterns\" written by GoF for some literature on this pattern)\n+ * definition that is used to decide whether or not a field or top-level class should be serialized\n+ * (or deserialized) as part of the JSON output/input.\n  *\n- * As well, for now this class is also responsible for excluding entire\n- * classes.  This is somewhat a mixing of concerns for this object, but\n- * it will suffice for now.  We can always break it down into two\n- * different strategies later.\n+ * <p>The following example show an implementation of an {@code ExclusionStrategy} where a specific\n+ * type will be excluded from the output.\n  *\n+ * <p><pre class=\"code\">\n+ * private static class UserDefinedExclusionStrategy implements ExclusionStrategy {\n+ *   private final Class&lt;?&gt; excludedThisClass;\n+ *\n+ *   UserDefinedExclusionStrategy(Class&lt;?&gt; excludedThisClass) {\n+ *     this.excludedThisClass = excludedThisClass;\n+ *   }\n+ *\n+ *   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {\n+ *     return excludedThisClass.equals(clazz);\n+ *   }\n+ *\n+ *   public boolean shouldSkipField(FieldAttributes f) {\n+ *     return excludedThisClass.equals(f.getDeclaredClass());\n+ *   }\n+ * }\n+ *\n+ * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);\n+ * Gson gson = new GsonBuilder()\n+ *     .setExclusionStrategies(excludeStrings)\n+ *     .create();\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n  * @author Joel Leitch\n+ *\n+ * @see GsonBuilder#setExclusionStrategies(ExclusionStrategy...)\n+ *\n+ * @since 1.4\n  */\n interface ExclusionStrategy {\n \n   /**\n    * @param f the field object that is under test\n-   * @return true if the field should be ignored otherwise false\n+   * @return true if the field should be ignored; otherwise false\n    */\n-  public boolean shouldSkipField(Field f);\n+  public boolean shouldSkipField(FieldAttributes f);\n \n   /**\n    * @param clazz the class object that is under test\n-   * @return true if the class should be ignored otherwise false\n+   * @return true if the class should be ignored; otherwise false\n    */\n   public boolean shouldSkipClass(Class<?> clazz);\n }\n--- a/gson/src/main/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategy.java\n  */\n package com.google.gson;\n \n-import java.lang.reflect.Field;\n-\n import com.google.gson.annotations.Expose;\n \n /**\n  * Excludes fields that do not have the {@link Expose} annotation\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n     return false;\n   }\n \n-  public boolean shouldSkipField(Field f) {\n+  public boolean shouldSkipField(FieldAttributes f) {\n     Expose annotation = f.getAnnotation(Expose.class);\n     if (annotation == null) {\n       return true;\n--- a/gson/src/main/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategy.java\n \n import com.google.gson.annotations.Expose;\n \n-import java.lang.reflect.Field;\n-\n /**\n  * Excludes fields that do not have the {@link Expose} annotation\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n     return false;\n   }\n \n-  public boolean shouldSkipField(Field f) {\n+  public boolean shouldSkipField(FieldAttributes f) {\n     Expose annotation = f.getAnnotation(Expose.class);\n     if (annotation == null) {\n       return true;\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A data object that stores attributes of a field.\n+ *\n+ * <p>This class is immutable; therefore, it can be safely shared across threads.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @since 1.4\n+ */\n+final class FieldAttributes {\n+  private final Field field;\n+\n+  /**\n+   * Constructs a Field Attributes object\n+   * @param f\n+   */\n+  FieldAttributes(Field f) {\n+    Preconditions.checkNotNull(f);\n+    field = f;\n+  }\n+\n+  /**\n+   * @return the name of the field\n+   */\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * <p>For example, assume the following class definition:\n+   * <pre class=\"code\">\n+   * public class Foo {\n+   *   private String bar;\n+   *   private List&lt;String&gt; red;\n+   * }\n+   *\n+   * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n+   * </pre>\n+   *\n+   * <p>This method would return {@code String.class} for the {@code bar} field and\n+   * {@code listParameterizedType} for the {@code red} field.\n+   *\n+   * @return the specific type declared for this field\n+   */\n+  public Type getDeclaredType() {\n+    return field.getGenericType();\n+  }\n+\n+  /**\n+   * Returns the {@code Class<?>} object that was declared for this field.\n+   *\n+   * <p>For example, assume the following class definition:\n+   * <pre class=\"code\">\n+   * public class Foo {\n+   *   private String bar;\n+   *   private List&lt;String&gt; red;\n+   * }\n+   * </pre>\n+   *\n+   * <p>This method would return {@code String.class} for the {@code bar} field and\n+   * {@code List.class} for the {@code red} field.\n+   *\n+   * @return the specific class object that was declared for the field\n+   */\n+  public Class<?> getDeclaredClass() {\n+    return field.getType();\n+  }\n+\n+  /**\n+   * Return the {@link T} annotation object from this field if it exist; otherwise returns\n+   * {@code null}.\n+   *\n+   * @param annotation the class of the annotation that will be retrieved\n+   * @return the annotation instance if it is bound to the field; otherwise {@code null}\n+   */\n+  public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n+    return field.getAnnotation(annotation);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the field is defined with the {@code modifier}.\n+   *\n+   * <p>This method is meant to be called as:\n+   * <pre class=\"code\">\n+   * boolean hasPublicModifier = fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);\n+   * </pre>\n+   *\n+   * @see java.lang.reflect.Modifier\n+   */\n+  public boolean hasModifier(int modifier) {\n+    return (field.getModifiers() & modifier) != 0;\n+  }\n+\n+  /**\n+   * This is exposed internally only for the\n+   * @return\n+   */\n+  boolean isSynthetic() {\n+    return field.isSynthetic();\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private static final String NULL_STRING = \"null\";\n \n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n-  \n+\n   // Default instances of plug-ins\n+  static final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\n+      new AnonymousAndLocalClassExclusionStrategy();\n+  static final SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY =\n+      new SyntheticFieldExclusionStrategy(true);\n   static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n-      new ModifierBasedExclusionStrategy(true, new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n+      new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n   static final JsonFormatter DEFAULT_JSON_FORMATTER = new JsonCompactFormatter();\n   static final FieldNamingStrategy DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n \n+  private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY =\n+      createExclusionStrategy(VersionConstants.IGNORE_VERSIONS);\n+\n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n   private final ExclusionStrategy serializationStrategy;\n \n   private final ExclusionStrategy deserializationStrategy;\n-  \n+\n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n \n    *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n    *   to change the default representation, you can do so by registering a type adapter through\n    *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n-   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format \n+   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n    *   ignores the millisecond portion of the date during serialization. You can change\n    *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n    *   {@link GsonBuilder#setDateFormat(String)}. </li>\n    * </ul>\n    */\n   public Gson() {\n-    this(createExclusionStrategy(VersionConstants.IGNORE_VERSIONS), DEFAULT_NAMING_POLICY);\n-  }\n-\n-  /**\n-   * Constructs a Gson object with the specified version and the mode of operation while\n-   * encountering inner class references.\n-   */\n-  Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n-    this(strategy, strategy, fieldNamingPolicy, \n-        new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n-        DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n-        DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE);\n-  }\n-\n-  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, \n-      FieldNamingStrategy fieldNamingPolicy, MappedObjectConstructor objectConstructor, \n-      JsonFormatter formatter, boolean serializeNulls, \n+    this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n+    new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n+    DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n+    DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE);\n+  }\n+\n+  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\n+      FieldNamingStrategy fieldNamingPolicy, MappedObjectConstructor objectConstructor,\n+      JsonFormatter formatter, boolean serializeNulls,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, \n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n       boolean generateNonExecutableGson) {\n     this.serializationStrategy = serializationStrategy;\n     this.deserializationStrategy = deserializationStrategy;\n     this.deserializers = deserializers;\n     this.generateNonExecutableJson = generateNonExecutableGson;\n   }\n-  \n+\n   private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\n     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n   }\n \n   private static ExclusionStrategy createExclusionStrategy(double version) {\n     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(new AnonymousAndLocalClassExclusionStrategy());\n+    strategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\n+    strategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\n     strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\n     if (version != VersionConstants.IGNORE_VERSIONS) {\n       strategies.add(new VersionExclusionStrategy(version));\n   }\n \n   /**\n-   * This method serializes the specified object into its equivalent representation as a tree of \n+   * This method serializes the specified object into its equivalent representation as a tree of\n    * {@link JsonElement}s. This method should be used when the specified object is not a generic\n    * type. This method uses {@link Class#getClass()} to get the type for the specified object, but\n    * the {@code getClass()} loses the generic type information because of the Type Erasure feature\n \n   /**\n    * This method serializes the specified object, including those of generic types, into its\n-   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the \n-   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)} \n-   * instead. \n+   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\n+   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\n+   * instead.\n    *\n    * @param src the object for which JSON representation is to be created\n    * @param typeOfSrc The specific genericized type of src. You can obtain\n \n   /**\n    * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.\n-   * \n+   *\n    * @param jsonElement root of a tree of {@link JsonElement}s\n    * @return JSON String representation of the tree\n    * @since 1.4\n     toJson(jsonElement, writer);\n     return writer.toString();\n   }\n-  \n+\n   /**\n    * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\n-   * \n+   *\n    * @param jsonElement root of a tree of {@link JsonElement}s\n    * @param writer Writer to which the Json representation needs to be written\n    * @since 1.4\n       formatter.format(jsonElement, writer, serializeNulls);\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n-    }    \n+    }\n   }\n \n   /**\n    * Therefore, this method should not be used if the desired type is a generic type. Note that\n    * this method works fine if the any of the fields of the specified object are generics, just the\n    * object itself should not be a generic type. For the cases when the object is of generic type,\n-   * invoke {@link #fromJson(JsonElement, Type)}. \n+   * invoke {@link #fromJson(JsonElement, Type)}.\n    * @param <T> the type of the desired object\n-   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to \n+   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n    * be deserialized\n    * @param classOfT The class of T\n    * @return an object of type T from the json\n   /**\n    * This method deserializes the Json read from the specified parse tree into an object of the\n    * specified type. This method is useful if the specified object is a generic type. For\n-   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead. \n+   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n    *\n    * @param <T> the type of the desired object\n-   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to \n+   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n    * be deserialized\n    * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n    * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n       return null;\n     }\n     JsonDeserializationContext context = new JsonDeserializationContextDefault(\n-        createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers, \n+        createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers,\n         objectConstructor);\n     T target = (T) context.deserialize(json, typeOfT);\n     return target;\n   private void writeOutNullString(Appendable writer) throws IOException {\n     writer.append(NULL_STRING);\n   }\n-  \n-  @Override \n+\n+  @Override\n   public String toString() {\n   \tStringBuilder sb = new StringBuilder(\"{\")\n   \t    .append(\"serializeNulls:\").append(serializeNulls)\n   \t    .append(\",serializers:\").append(serializers)\n   \t    .append(\",deserializers:\").append(deserializers)\n-  \t\n-      \t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are \n+\n+      \t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are\n       \t// more familiar with the concept of Instance Creators. Moreover, the objectConstructor is\n       \t// just a utility class around instance creators, and its toString() only displays them.\n         .append(\",instanceCreators:\").append(objectConstructor)\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import java.lang.reflect.Type;\n import java.text.DateFormat;\n+import java.util.Collection;\n import java.util.Date;\n+import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n \n  * @author Joel Leitch\n  */\n public final class GsonBuilder {\n-  private static final AnonymousAndLocalClassExclusionStrategy anonAndLocalClassExclusionStrategy =\n-      new AnonymousAndLocalClassExclusionStrategy();\n   private static final InnerClassExclusionStrategy innerClassExclusionStrategy =\n       new InnerClassExclusionStrategy();\n-  private static final ExposeAnnotationSerializationExclusionStrategy \n+  private static final ExposeAnnotationSerializationExclusionStrategy\n     exposeAnnotationSerializationExclusionStrategy =\n       new ExposeAnnotationSerializationExclusionStrategy();\n-  private static final ExposeAnnotationDeserializationExclusionStrategy \n+  private static final ExposeAnnotationDeserializationExclusionStrategy\n     exposeAnnotationDeserializationExclusionStrategy =\n       new ExposeAnnotationDeserializationExclusionStrategy();\n-  \n+\n+  private final Collection<ExclusionStrategy> exclusionStrategies =\n+      new HashSet<ExclusionStrategy>();\n+\n   private double ignoreVersionsAfter;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n   private boolean serializeInnerClasses;\n    * {@link #create()}.\n    */\n   public GsonBuilder() {\n+    // add default exclusion strategies\n+    exclusionStrategies.add(Gson.DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\n+    exclusionStrategies.add(Gson.DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\n+\n     // setup default values\n     ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS;\n     serializeInnerClasses = true;\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n-    boolean skipSynthetics = true;\n-    modifierBasedExclusionStrategy = new ModifierBasedExclusionStrategy(skipSynthetics, modifiers);\n+    modifierBasedExclusionStrategy = new ModifierBasedExclusionStrategy(modifiers);\n     return this;\n   }\n \n   /**\n    * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\n-   * special text. This prevents attacks from third-party sites through script sourcing. See \n-   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a> \n-   * for details. \n-   * \n+   * special text. This prevents attacks from third-party sites through script sourcing. See\n+   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a>\n+   * for details.\n+   *\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.3\n    */\n     this.generateNonExecutableJson = true;\n     return this;\n   }\n-  \n+\n   /**\n    * Configures Gson to exclude all fields from consideration for serialization or deserialization\n    * that do not have the {@link com.google.gson.annotations.Expose} annotation.\n    * @since 1.3\n    */\n   public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n-    this.fieldNamingPolicy = \n-      new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy);\n+    this.fieldNamingPolicy =\n+        new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy);\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to apply a set of exclusion strategies during both serialization and\n+   * deserialization. Each of the {@code strategies} will be applied as a disjunctive rule.\n+   * This means that if one of the {@code strategies} suggests that a field (or class) should be\n+   * skipped then that field (or object) is skipped during serializaiton/deserialization.\n+   *\n+   * @param strategies the set of strategy object to apply during object (de)serialization.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.4\n+   */\n+  GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\n+    for (ExclusionStrategy strategy : strategies) {\n+      exclusionStrategies.add(strategy);\n+    }\n     return this;\n   }\n \n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>();\n-    List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>();\n+    List<ExclusionStrategy> serializationStrategies =\n+        new LinkedList<ExclusionStrategy>(exclusionStrategies);\n+    List<ExclusionStrategy> deserializationStrategies =\n+        new LinkedList<ExclusionStrategy>(exclusionStrategies);\n+\n     serializationStrategies.add(modifierBasedExclusionStrategy);\n     deserializationStrategies.add(modifierBasedExclusionStrategy);\n-    serializationStrategies.add(anonAndLocalClassExclusionStrategy);\n-    deserializationStrategies.add(anonAndLocalClassExclusionStrategy);\n \n     if (!serializeInnerClasses) {\n       serializationStrategies.add(innerClassExclusionStrategy);\n       serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy);\n       deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy);\n     }\n-    ExclusionStrategy serializationExclusionStrategy = \n+    ExclusionStrategy serializationExclusionStrategy =\n       new DisjunctionExclusionStrategy(serializationStrategies);\n-    ExclusionStrategy deserializationExclusionStrategy = \n+    ExclusionStrategy deserializationExclusionStrategy =\n       new DisjunctionExclusionStrategy(deserializationStrategies);\n \n     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf();\n     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n         instanceCreators.copyOf();\n     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators());\n-    \n+\n     customSerializers.makeUnmodifiable();\n     customDeserializers.makeUnmodifiable();\n     instanceCreators.makeUnmodifiable();\n-    \n+\n     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators);\n \n     JsonFormatter formatter =  prettyPrinting ?\n         new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n-    Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, \n-        fieldNamingPolicy, objConstructor, formatter, serializeNulls, customSerializers, \n+    Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy,\n+        fieldNamingPolicy, objConstructor, formatter, serializeNulls, customSerializers,\n         customDeserializers, generateNonExecutableJson);\n     return gson;\n   }\n       } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n       }\n-      \n+\n       if (dateTypeAdapter != null) {\n         serializers.register(Date.class, dateTypeAdapter);\n         deserializers.register(Date.class, dateTypeAdapter);\n--- a/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n \n /**\n  */\n class InnerClassExclusionStrategy implements ExclusionStrategy {\n \n-  public boolean shouldSkipField(Field f) {\n-    return isInnerClass(f.getType());\n+  public boolean shouldSkipField(FieldAttributes f) {\n+    return isInnerClass(f.getDeclaredClass());\n   }\n \n   public boolean shouldSkipClass(Class<?> clazz) {\n   private boolean isInnerClass(Class<?> clazz) {\n     return clazz.isMemberClass() && !isStatic(clazz);\n   }\n-  \n+\n   private boolean isStatic(Class<?> clazz) {\n     return (clazz.getModifiers() & Modifier.STATIC) != 0;\n   }\n--- a/gson/src/main/java/com/google/gson/ModifierBasedExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ModifierBasedExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n import java.util.Collection;\n import java.util.HashSet;\n \n  * @author Joel Leitch\n  */\n final class ModifierBasedExclusionStrategy implements ExclusionStrategy {\n-  private final boolean skipSyntheticField;\n   private final Collection<Integer> modifiers;\n \n-  public ModifierBasedExclusionStrategy(boolean skipSyntheticFields, int... modifiers) {\n-    this.skipSyntheticField = skipSyntheticFields;\n+  public ModifierBasedExclusionStrategy(int... modifiers) {\n     this.modifiers = new HashSet<Integer>();\n     if (modifiers != null) {\n       for (int modifier : modifiers) {\n     }\n   }\n \n-  public boolean shouldSkipField(Field f) {\n-    if (skipSyntheticField && f.isSynthetic()) {\n-      return true;\n-    }\n-    int objectModifiers = f.getModifiers();\n+  public boolean shouldSkipField(FieldAttributes f) {\n     for (int modifier : modifiers) {\n-      if ((objectModifiers & modifier) != 0) {\n+      if (f.hasModifier(modifier)) {\n         return true;\n       }\n     }\n--- a/gson/src/main/java/com/google/gson/NullExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/NullExclusionStrategy.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Field;\n \n /**\n  * This acts as a \"Null Object\" pattern for the {@link ExclusionStrategy}.\n  */\n final class NullExclusionStrategy implements ExclusionStrategy {\n \n-  public boolean shouldSkipField(Field f) {\n+  public boolean shouldSkipField(FieldAttributes f) {\n     return false;\n   }\n \n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n      * This is called to visit a field of the current object using a custom handler\n      */\n     public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent);\n-    \n+\n     /**\n      * Retrieve the current target\n      */\n       if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\n         return;\n       }\n-      visitor.start(objTypePair);  \n+      visitor.start(objTypePair);\n       try {\n         if (objTypeInfo.isArray()) {\n           visitor.visitArray(objectToVisit, objTypePair.getType());\n     Field[] fields = clazz.getDeclaredFields();\n     AccessibleObject.setAccessible(fields, true);\n     for (Field f : fields) {\n-      if (exclusionStrategy.shouldSkipField(f)) {\n+      if (exclusionStrategy.shouldSkipField(new FieldAttributes(f))) {\n         continue; // skip\n       } else {\n         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.getType());\n         Type actualTypeOfField = fieldTypeInfo.getActualType();\n-        boolean visitedWithCustomHandler = \n+        boolean visitedWithCustomHandler =\n             visitor.visitFieldUsingCustomHandler(f, actualTypeOfField, obj);\n         if (!visitedWithCustomHandler) {\n           if (fieldTypeInfo.isArray()) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/SyntheticFieldExclusionStrategy.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A data object that stores attributes of a field.\n+ *\n+ * <p>This class is immutable; therefore, it can be safely shared across threads.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @since 1.4\n+ */\n+class SyntheticFieldExclusionStrategy implements ExclusionStrategy {\n+  private final boolean skipSyntheticFields;\n+\n+  SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) {\n+    this.skipSyntheticFields = skipSyntheticFields;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return false;\n+  }\n+\n+  public boolean shouldSkipField(FieldAttributes f) {\n+    return skipSyntheticFields && f.isSynthetic();\n+  }\n+\n+}\n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n \n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-\n /**\n  * This strategy will exclude any files and/or class that are passed the\n  * {@link #version} value.\n     this.version = version;\n   }\n \n-  public boolean shouldSkipField(Field f) {\n-    return !isValidVersion(f.getAnnotations());\n+  public boolean shouldSkipField(FieldAttributes f) {\n+    return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class));\n   }\n \n   public boolean shouldSkipClass(Class<?> clazz) {\n-    return !isValidVersion(clazz.getAnnotations());\n+    return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class));\n   }\n \n-  private boolean isValidVersion(Annotation[] annotations) {\n-    for (Annotation annotation : annotations) {\n-      if (!isValidSince(annotation) || !isValidUntil(annotation)) {\n-        return false;\n-      }\n-    }\n-    return true;\n+  private boolean isValidVersion(Since since, Until until) {\n+    return (isValidSince(since) && isValidUntil(until));\n   }\n-  \n-  private boolean isValidSince(Annotation annotation) {\n-    if (annotation instanceof Since) {\n-      double annotationVersion = ((Since) annotation).value();\n+\n+  private boolean isValidSince(Since annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n       if (annotationVersion > version) {\n         return false;\n       }\n     }\n     return true;\n   }\n-  \n-  private boolean isValidUntil(Annotation annotation) {\n-    if (annotation instanceof Until) {\n-      double annotationVersion = ((Until) annotation).value();\n+\n+  private boolean isValidUntil(Until annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n       if (annotationVersion <= version) {\n         return false;\n       }\n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n \n package com.google.gson;\n \n-import com.google.gson.DisjunctionExclusionStrategy;\n-import com.google.gson.ExclusionStrategy;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import junit.framework.TestCase;\n-\n-import java.lang.reflect.Field;\n-import java.util.LinkedList;\n-import java.util.List;\n \n /**\n  * Unit tests for the {@link DisjunctionExclusionStrategy} class.\n   private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);\n   private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);\n   private static final Class<?> CLAZZ = String.class;\n-  private static final Field FIELD = CLAZZ.getFields()[0];\n+  private static final FieldAttributes FIELD = new FieldAttributes(CLAZZ.getFields()[0]);\n \n   public void testBadInstantiation() throws Exception {\n     try {\n       List<ExclusionStrategy> constructorParam = null;\n       new DisjunctionExclusionStrategy(constructorParam);\n+      fail(\"Should throw an exception\");\n     } catch (IllegalArgumentException expected) { }\n   }\n \n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategyTest.java\n   public void testNeverSkipClasses() throws Exception {\n     assertFalse(strategy.shouldSkipClass(MockObject.class));\n   }\n-  \n+\n   public void testSkipNonAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"hiddenField\");\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   public void testSkipExplicitlySkippedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   public void testNeverSkipExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"exposedField\");\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyExposedField\");\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   @SuppressWarnings(\"unused\")\n \n     @Expose(deserialize=true)\n     public final int explicitlyExposedField = 0;\n-    \n+\n     @Expose(deserialize=false)\n     public final int explicitlyHiddenField = 0;\n \n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategyTest.java\n   public void testNeverSkipClasses() throws Exception {\n     assertFalse(strategy.shouldSkipClass(MockObject.class));\n   }\n-  \n+\n   public void testSkipNonAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"hiddenField\");\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   public void testSkipExplicitlySkippedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   public void testNeverSkipExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"exposedField\");\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyExposedField\");\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   @SuppressWarnings(\"unused\")\n \n     @Expose(serialize=true)\n     public final int explicitlyExposedField = 0;\n-    \n+\n     @Expose(serialize=false)\n     public final int explicitlyHiddenField = 0;\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Unit tests for the {@link FieldAttributes} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class FieldAttributesTest extends TestCase {\n+  private FieldAttributes fieldAttributes;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    fieldAttributes = new FieldAttributes(Foo.class.getField(\"bar\"));\n+  }\n+\n+  public void testNullField() throws Exception {\n+    try {\n+      new FieldAttributes(null);\n+      fail(\"Field parameter can not be null\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testModifiers() throws Exception {\n+    assertFalse(fieldAttributes.hasModifier(Modifier.STATIC));\n+    assertFalse(fieldAttributes.hasModifier(Modifier.FINAL));\n+    assertFalse(fieldAttributes.hasModifier(Modifier.ABSTRACT));\n+    assertFalse(fieldAttributes.hasModifier(Modifier.VOLATILE));\n+    assertFalse(fieldAttributes.hasModifier(Modifier.PROTECTED));\n+\n+    assertTrue(fieldAttributes.hasModifier(Modifier.PUBLIC));\n+    assertTrue(fieldAttributes.hasModifier(Modifier.TRANSIENT));\n+  }\n+\n+  public void testIsSynthetic() throws Exception {\n+    assertFalse(fieldAttributes.isSynthetic());\n+  }\n+\n+  public void testName() throws Exception {\n+    assertEquals(\"bar\", fieldAttributes.getName());\n+  }\n+\n+  public void testDeclaredTypeAndClass() throws Exception {\n+    Type expectedType = new TypeToken<List<String>>() {}.getType();\n+    assertEquals(expectedType, fieldAttributes.getDeclaredType());\n+    assertEquals(List.class, fieldAttributes.getDeclaredClass());\n+  }\n+\n+  private static class Foo {\n+    public transient List<String> bar;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n \n package com.google.gson;\n \n-import com.google.gson.common.TestTypes.ClassWithNoFields;\n+import java.lang.reflect.Modifier;\n+import java.util.LinkedList;\n \n import junit.framework.TestCase;\n \n-import java.lang.reflect.Modifier;\n+import com.google.gson.common.TestTypes;\n+import com.google.gson.common.TestTypes.ClassWithNoFields;\n \n /**\n  * Functional tests for Gson that depend on some internal package-protected elements of\n  */\n public class FunctionWithInternalDependenciesTest extends TestCase {\n \n-  public void testAnonymousLocalClassesSerialization() {\n-    Gson gson = new Gson(new ModifierBasedExclusionStrategy(\n-        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY);\n+  public void testAnonymousLocalClassesSerialization() throws Exception {\n+    LinkedList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    strategies.add(new SyntheticFieldExclusionStrategy(true));\n+    strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));\n+    ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n+    Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,\n+        new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n+        Gson.DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n+        DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE);\n     assertEquals(\"{}\", gson.toJson(new ClassWithNoFields() {\n       // empty anonymous class\n     }));\n   }\n+\n+  // TODO(Joel): Move this to some other functional test once exclusion policies are\n+  // available to the public\n+  public void testUserDefinedExclusionPolicies() throws Exception {\n+    Gson gson = new GsonBuilder()\n+        .setExclusionStrategies(new UserDefinedExclusionStrategy(String.class))\n+        .create();\n+\n+    String json = gson.toJson(new TestTypes.StringWrapper(\"someValue\"));\n+    assertEquals(\"{}\", json);\n+  }\n+\n+  private static class UserDefinedExclusionStrategy implements ExclusionStrategy {\n+    private final Class<?> excludedThisClass;\n+\n+    UserDefinedExclusionStrategy(Class<?> excludedThisClass) {\n+      this.excludedThisClass = excludedThisClass;\n+    }\n+\n+    public boolean shouldSkipClass(Class<?> clazz) {\n+      return excludedThisClass.equals(clazz);\n+    }\n+\n+    public boolean shouldSkipField(FieldAttributes f) {\n+      return excludedThisClass.equals(f.getDeclaredClass());\n+    }\n+\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n   public StaticNestedClass staticNestedClass;\n \n   private InnerClassExclusionStrategy strategy;\n-  \n+\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n     Class<?> clazz = innerClass.getClass();\n     assertTrue(strategy.shouldSkipClass(clazz));\n   }\n-  \n+\n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   public void testIncludeStaticNestedClassObject() throws Exception {\n     Class<?> clazz = staticNestedClass.getClass();\n     assertFalse(strategy.shouldSkipClass(clazz));\n   }\n-  \n+\n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n-  \n+\n   class InnerClass {\n   }\n-  \n+\n   static class StaticNestedClass {\n   }\n }\n--- a/gson/src/test/java/com/google/gson/MockExclusionStrategy.java\n+++ b/gson/src/test/java/com/google/gson/MockExclusionStrategy.java\n \n package com.google.gson;\n \n-import com.google.gson.ExclusionStrategy;\n-\n-import java.lang.reflect.Field;\n \n /**\n  * This is a configurable {@link ExclusionStrategy} that can be used for\n- * unit testing. \n+ * unit testing.\n  *\n  * @author Joel Leitch\n  */\n     this.skipField = skipField;\n   }\n \n-  public boolean shouldSkipField(Field f) {\n+  public boolean shouldSkipField(FieldAttributes f) {\n     return skipField;\n   }\n \n--- a/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n  */\n \n package com.google.gson;\n-\n-import com.google.gson.NullExclusionStrategy;\n \n import junit.framework.TestCase;\n \n   }\n \n   public void testNeverSkipsField() throws Exception {\n-    assertFalse(strategy.shouldSkipField(\"\".getClass().getFields()[0]));\n+    assertFalse(strategy.shouldSkipField(\n+        new FieldAttributes(\"\".getClass().getFields()[0])));\n   }\n }\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n \n package com.google.gson;\n \n-import com.google.gson.annotations.Since;\n+import java.lang.reflect.Field;\n \n import junit.framework.TestCase;\n \n-import java.lang.reflect.Field;\n+import com.google.gson.annotations.Since;\n \n /**\n  * Unit tests for the {@link VersionExclusionStrategy} class.\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n-    \n+\n     assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   public void testClassAndFieldAreBehindInVersion() throws Exception {\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n-    \n+\n     assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(f));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   public void testClassAndFieldAreAheadInVersion() throws Exception {\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n-    \n+\n     assertTrue(strategy.shouldSkipClass(clazz));\n-    assertTrue(strategy.shouldSkipField(f));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   @Since(VERSION)", "timestamp": 1254907394, "metainfo": ""}