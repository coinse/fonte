{"sha": "7a5cef93050be46ca738c6589c067b78ee79fd78", "log": "Revised to the new name getDelegateAdapter.", "commit": "\n--- a/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\n+++ b/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\n         return null;\n       }\n \n-      final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n+      final TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);\n       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\n       return new TypeAdapter<T>() {\n         @Override public void write(JsonWriter out, T value) throws IOException {\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n  */\n \n package com.google.gson.typeadapters;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n \n import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n \n /**\n  * Adapts values whose runtime type may differ from their declaration type. This\n     return registerSubtype(type, type.getSimpleName());\n   }\n \n-  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+  public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {\n     if (type.getRawType() != baseType) {\n       return null;\n     }\n     final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n         = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n     for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n-      TypeAdapter<?> delegate = gson.getNextAdapter(this, TypeToken.get(entry.getValue()));\n+      TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\n       labelToDelegate.put(entry.getKey(), delegate);\n       subtypeToDelegate.put(entry.getValue(), delegate);\n     }\n \n-    return new TypeAdapter<T>() {\n-      @Override public T read(JsonReader in) throws IOException {\n+    return new TypeAdapter<R>() {\n+      @Override public R read(JsonReader in) throws IOException {\n         JsonElement jsonElement = Streams.parse(in);\n         JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\n         if (labelJsonElement == null) {\n         }\n         String label = labelJsonElement.getAsString();\n         @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n-        TypeAdapter<T> delegate = (TypeAdapter<T>) labelToDelegate.get(label);\n+        TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);\n         if (delegate == null) {\n           throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n               + label + \"; did you forget to register a subtype?\");\n         return delegate.fromJsonTree(jsonElement);\n       }\n \n-      @Override public void write(JsonWriter out, T value) throws IOException {\n+      @Override public void write(JsonWriter out, R value) throws IOException {\n         Class<?> srcType = value.getClass();\n         String label = subtypeToLabel.get(srcType);\n         @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n-        TypeAdapter<T> delegate = (TypeAdapter<T>) subtypeToDelegate.get(srcType);\n+        TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);\n         if (delegate == null) {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \"; did you forget to register a subtype?\");", "timestamp": 1334430254, "metainfo": ""}