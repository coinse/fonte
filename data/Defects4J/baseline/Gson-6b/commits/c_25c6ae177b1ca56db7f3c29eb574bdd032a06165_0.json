{"sha": "25c6ae177b1ca56db7f3c29eb574bdd032a06165", "log": "Down to 22 failing tests.  Consolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don't need to ever do reflection to lookup a constructor at construction time.  Cleaned up some buggy type adapters, particularly around handling of null.  Removed dead code for object graph navigation.  Moved some classes into 'internal' so they are visible to the 'bind' subpackage.  Turned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.  Added an API to request the 'next' type adapter for a type. This allows type adapters to compose other type adapters. We're using this in two places:  - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.  - similarly when a DOM type serializer is registered but no deserializer, or vice versa. This is the biggest change to the MiniGson core.  For backwards compatibility, return null for the empty string.  Simplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.  More useful error messages when calling getAsBoolean on a JsonNull.  Remove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don't interject ourselves between the users' various type adapters.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import java.lang.reflect.Type;\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Calendar;\n-import java.util.Collection;\n import java.util.Date;\n import java.util.GregorianCalendar;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n import java.util.Locale;\n-import java.util.Map;\n-import java.util.Queue;\n-import java.util.Set;\n-import java.util.SortedSet;\n import java.util.TimeZone;\n-import java.util.TreeSet;\n \n /**\n  * List of all the default type adapters ({@link JsonSerializer}s, {@link JsonDeserializer}s,\n   @SuppressWarnings(\"unchecked\")\n   private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();\n   private static final BitSetTypeAdapter BIT_SET_ADAPTER = new BitSetTypeAdapter();\n-  private static final MapTypeAdapter MAP_TYPE_ADAPTER = new MapTypeAdapter();\n \n   private static final CharacterTypeAdapter CHARACTER_TYPE_ADAPTER = new CharacterTypeAdapter();\n   private static final NumberTypeAdapter NUMBER_TYPE_ADAPTER = new NumberTypeAdapter();\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n     map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER, true);\n-    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER, true);\n     map.makeUnmodifiable();\n     return map;\n   }\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n     map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER), true);\n-    map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER), true);\n     map.makeUnmodifiable();\n     return map;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\n-    ParameterizedTypeHandlerMap<InstanceCreator<?>> map =\n-        new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n-    DefaultConstructorAllocator allocator = new DefaultConstructorAllocator(50);\n-\n-    // Map Instance Creators\n-    map.registerForTypeHierarchy(Map.class,\n-        new DefaultConstructorCreator<Map>(LinkedHashMap.class, allocator), true);\n-\n-    // Add Collection type instance creators\n-    DefaultConstructorCreator<List> listCreator =\n-        new DefaultConstructorCreator<List>(ArrayList.class, allocator);\n-    DefaultConstructorCreator<Queue> queueCreator =\n-      new DefaultConstructorCreator<Queue>(LinkedList.class, allocator);\n-    DefaultConstructorCreator<Set> setCreator =\n-        new DefaultConstructorCreator<Set>(HashSet.class, allocator);\n-    DefaultConstructorCreator<SortedSet> sortedSetCreator =\n-        new DefaultConstructorCreator<SortedSet>(TreeSet.class, allocator);\n-    map.registerForTypeHierarchy(Collection.class, listCreator, true);\n-    map.registerForTypeHierarchy(Queue.class, queueCreator, true);\n-    map.registerForTypeHierarchy(Set.class, setCreator, true);\n-    map.registerForTypeHierarchy(SortedSet.class, sortedSetCreator, true);\n-\n+    ParameterizedTypeHandlerMap<InstanceCreator<?>> map\n+        = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n     map.makeUnmodifiable();\n     return map;\n   }\n       return CharacterTypeAdapter.class.getSimpleName();\n     }\n   }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  private static final class DefaultConstructorCreator<T> implements InstanceCreator<T> {\n-    private final Class<? extends T> defaultInstance;\n-    private final DefaultConstructorAllocator allocator;\n-\n-    public DefaultConstructorCreator(Class<? extends T> defaultInstance,\n-        DefaultConstructorAllocator allocator) {\n-      this.defaultInstance = defaultInstance;\n-      this.allocator = allocator;\n-    }\n-\n-    public T createInstance(Type type) {\n-      Class<?> rawType = $Gson$Types.getRawType(type);\n-      try {\n-        T specificInstance = (T) allocator.newInstance(rawType);\n-        return (specificInstance == null)\n-            ? allocator.newInstance(defaultInstance)\n-            : specificInstance;\n-      } catch (Exception e) {\n-        throw new JsonIOException(e);\n-      }\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return DefaultConstructorCreator.class.getSimpleName();\n-    }\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.$Gson$Types;\n \n+import com.google.gson.internal.Pair;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n-import com.google.gson.internal.bind.CollectionTypeAdapter;\n-import com.google.gson.internal.bind.GsonCompatibleMapTypeAdapter;\n+import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n+import com.google.gson.internal.bind.ExcludedTypeAdapterFactory;\n+import com.google.gson.internal.bind.MapTypeAdapterFactory;\n import com.google.gson.internal.bind.MiniGson;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n-import com.google.gson.internal.bind.ReflectiveTypeAdapter;\n+import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n-\n+import java.io.EOFException;\n import java.io.IOException;\n import java.io.Reader;\n import java.io.StringReader;\n   private final ExclusionStrategy deserializationExclusionStrategy;\n   private final ExclusionStrategy serializationExclusionStrategy;\n   private final FieldNamingStrategy2 fieldNamingPolicy;\n-  private final MappedObjectConstructor objectConstructor;\n+  private final ConstructorConstructor constructorConstructor;\n \n   /** Map containing Type or Class objects as keys */\n   private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n    */\n   public Gson() {\n     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n-        new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n+        DefaultTypeAdapters.getDefaultInstanceCreators(),\n         false, DefaultTypeAdapters.getAllDefaultSerializers(),\n         DefaultTypeAdapters.getAllDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false,\n         false, LongSerializationPolicy.DEFAULT);\n   Gson(final ExclusionStrategy deserializationExclusionStrategy,\n       final ExclusionStrategy serializationExclusionStrategy,\n       final FieldNamingStrategy2 fieldNamingPolicy,\n-      final MappedObjectConstructor objectConstructor, boolean serializeNulls,\n+      final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n       final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n       boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting,\n     this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n     this.serializationExclusionStrategy = serializationExclusionStrategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n-    this.objectConstructor = objectConstructor;\n+    this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.serializeNulls = serializeNulls;\n     this.serializers = serializers;\n     this.deserializers = deserializers;\n         serializeNulls\n         serializers\n      */\n-    TypeAdapter.Factory reflectiveTypeAdapterFactory =\n-      new ReflectiveTypeAdapter.FactoryImpl() {\n+    TypeAdapter.Factory reflectiveTypeAdapterFactory\n+        = new ReflectiveTypeAdapterFactory(constructorConstructor) {\n       @Override\n       public String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n         return fieldNamingPolicy.translateName(new FieldAttributes(declaringClazz, f, declaredType));\n       }\n       @Override\n       public boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-        return !Gson.this.serializationExclusionStrategy.shouldSkipField(\n-            new FieldAttributes(declaringClazz, f, declaredType));\n-      }\n+        ExclusionStrategy strategy = Gson.this.serializationExclusionStrategy;\n+        return !strategy.shouldSkipClass(f.getType())\n+            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f, declaredType));\n+      }\n+\n       @Override\n       public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-        return !Gson.this.deserializationExclusionStrategy.shouldSkipField(\n-            new FieldAttributes(declaringClazz, f, declaredType));\n-      }\n-    };\n-\n-    TypeAdapter.Factory excludedTypeFactory = new TypeAdapter.Factory() {\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n-        Class<?> rawType = type.getRawType();\n-        if (serializationExclusionStrategy.shouldSkipClass(rawType)\n-            || deserializationExclusionStrategy.shouldSkipClass(rawType)) {\n-          return TypeAdapters.EXCLUDED_TYPE_ADAPTER;\n-        } else {\n-          return null;\n-        }\n+        ExclusionStrategy strategy = Gson.this.deserializationExclusionStrategy;\n+        return !strategy.shouldSkipClass(f.getType())\n+            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f, declaredType));\n       }\n     };\n \n             doubleAdapter(serializeSpecialFloatingPointValues)))\n         .factory(TypeAdapters.newFactory(float.class, Float.class,\n             floatAdapter(serializeSpecialFloatingPointValues)))\n+        .factory(new ExcludedTypeAdapterFactory(\n+            serializationExclusionStrategy, deserializationExclusionStrategy))\n         .factory(TypeAdapters.STRING_FACTORY)\n         .factory(TypeAdapters.STRING_BUILDER_FACTORY)\n         .factory(TypeAdapters.STRING_BUFFER_FACTORY)\n         .factory(TypeAdapters.INET_ADDRESS_FACTORY)\n         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())\n         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())\n-        .factory(excludedTypeFactory)\n-        .factory(GsonCompatibleMapTypeAdapter.FACTORY)\n-        .factory(CollectionTypeAdapter.FACTORY)\n+        .factory(new MapTypeAdapterFactory(constructorConstructor))\n+        .factory(new CollectionTypeAdapterFactory(constructorConstructor))\n         .factory(ObjectTypeAdapter.FACTORY)\n-        .factory(new GsonToMiniGsonTypeAdapter(serializers, deserializers, serializeNulls))\n+        .factory(new GsonToMiniGsonTypeAdapterFactory(serializers, deserializers,\n+            new JsonDeserializationContext(this), new JsonSerializationContext(this), serializeNulls\n+        ))\n         .factory(ArrayTypeAdapter.FACTORY)\n         .factory(reflectiveTypeAdapterFactory);\n \n     }\n     return new TypeAdapter<Number>() {\n       @Override public Double read(JsonReader reader) throws IOException {\n+        if (reader.peek() == JsonToken.NULL) {\n+          reader.nextNull(); // TODO: does this belong here?\n+          return null;\n+        }\n         return reader.nextDouble();\n       }\n       @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        if (value == null) {\n+          writer.nullValue(); // TODO: better policy here?\n+          return;\n+        }\n         double doubleValue = value.doubleValue();\n         checkValidFloatingPoint(doubleValue);\n         writer.value(value);\n     }\n     return new TypeAdapter<Number>() {\n       @Override public Float read(JsonReader reader) throws IOException {\n+        if (reader.peek() == JsonToken.NULL) {\n+          reader.nextNull(); // TODO: does this belong here?\n+          return null;\n+        }\n         return (float) reader.nextDouble();\n       }\n       @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        if (value == null) {\n+          writer.nullValue(); // TODO: better policy here?\n+          return;\n+        }\n         float floatValue = value.floatValue();\n         checkValidFloatingPoint(floatValue);\n         writer.value(value);\n     }\n     return new TypeAdapter<Number>() {\n       @Override public Number read(JsonReader reader) throws IOException {\n+        if (reader.peek() == JsonToken.NULL) {\n+          reader.nextNull(); // TODO: does this belong here?\n+          return null;\n+        }\n         return reader.nextLong();\n       }\n       @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        if (value == null) {\n+          writer.nullValue(); // TODO: better policy here?\n+          return;\n+        }\n         writer.value(value.toString());\n       }\n     };\n    */\n   @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n+    boolean isEmpty = true;\n     boolean oldLenient = reader.isLenient();\n     reader.setLenient(true);\n     try {\n+      reader.peek();\n+      isEmpty = false;\n       TypeAdapter<T> typeAdapter = (TypeAdapter<T>) miniGson.getAdapter(TypeToken.get(typeOfT));\n       return typeAdapter.read(reader);\n+    } catch (EOFException e) {\n+      /*\n+       * For compatibility with JSON 1.5 and earlier, we return null for empty\n+       * documents instead of throwing.\n+       */\n+      if (isEmpty) {\n+        return null;\n+      }\n+      throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n       // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n       throw new JsonSyntaxException(e);\n       \t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are\n       \t// more familiar with the concept of Instance Creators. Moreover, the objectConstructor is\n       \t// just a utility class around instance creators, and its toString() only displays them.\n-        .append(\",instanceCreators:\").append(objectConstructor)\n+        .append(\",instanceCreators:\").append(constructorConstructor)\n         .append(\"}\");\n   \treturn sb.toString();\n   }\n+\n }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.internal.Primitives;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers,\n         customDeserializers);\n \n+    customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers());\n     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers());\n \n     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n     customDeserializers.makeUnmodifiable();\n     instanceCreators.makeUnmodifiable();\n \n-    MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators);\n-\n     return new Gson(new DisjunctionExclusionStrategy(deserializationStrategies),\n         new DisjunctionExclusionStrategy(serializationStrategies),\n-        fieldNamingPolicy, objConstructor, serializeNulls,\n+        fieldNamingPolicy, instanceCreators, serializeNulls,\n         customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars,\n         prettyPrinting, serializeSpecialFloatingPointValues, longSerializationPolicy);\n   }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+final class GsonToMiniGsonTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final JsonDeserializationContext deserializationContext;\n+  private final JsonSerializationContext serializationContext;\n+  private final boolean serializeNulls;\n+\n+  GsonToMiniGsonTypeAdapterFactory(ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      JsonDeserializationContext deserializationContext,\n+      JsonSerializationContext serializationContext, boolean serializeNulls) {\n+    this.serializers = serializers;\n+    this.deserializers = deserializers;\n+    this.serializeNulls = serializeNulls;\n+    this.deserializationContext = deserializationContext;\n+    this.serializationContext = serializationContext;\n+  }\n+\n+  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> typeToken) {\n+    final Type type = typeToken.getType();\n+\n+    @SuppressWarnings(\"unchecked\") // guaranteed to match typeOfT\n+    final JsonSerializer<T> serializer\n+        = (JsonSerializer<T>) serializers.getHandlerFor(type, false);\n+    @SuppressWarnings(\"unchecked\") // guaranteed to match typeOfT\n+    final JsonDeserializer<T> deserializer\n+        = (JsonDeserializer<T>) deserializers.getHandlerFor(type, false);\n+\n+    if (serializer == null && deserializer == null) {\n+      return null;\n+    }\n+\n+    return new TypeAdapter<T>() {\n+      /**\n+       * The delegate is lazily created because it may not be needed, and\n+       * creating it may fail.\n+       */\n+      private TypeAdapter<T> delegate;\n+\n+      @Override public T read(JsonReader reader) throws IOException {\n+        if (deserializer == null) {\n+          return delegate().read(reader);\n+        }\n+        JsonElement value = Streams.parse(reader);\n+        if (value.isJsonNull()) {\n+          return null;\n+        }\n+        return deserializer.deserialize(value, type, deserializationContext);\n+      }\n+\n+      @Override public void write(JsonWriter writer, T value) throws IOException {\n+        if (serializer == null) {\n+          delegate().write(writer, value);\n+          return;\n+        }\n+        if (value == null) {\n+          writer.nullValue();\n+          return;\n+        }\n+        JsonElement element = serializer.serialize(value, type, serializationContext);\n+        Streams.write(element, serializeNulls, writer);\n+      }\n+\n+      private TypeAdapter<T> delegate() {\n+        TypeAdapter<T> d = delegate;\n+        return d != null\n+            ? d\n+            : (delegate = context.getNextAdapter(GsonToMiniGsonTypeAdapterFactory.this, typeToken));\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n  * @author Joel Leitch\n  */\n public class JsonDeserializationContext {\n-  private final ObjectNavigator objectNavigator;\n-  private final FieldNamingStrategy2 fieldNamingPolicy;\n-  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n-  private final MappedObjectConstructor objectConstructor;\n+  private final Gson gson;\n \n-  JsonDeserializationContext(ObjectNavigator objectNavigator,\n-      FieldNamingStrategy2 fieldNamingPolicy,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n-      MappedObjectConstructor objectConstructor) {\n-    this.objectNavigator = objectNavigator;\n-    this.fieldNamingPolicy = fieldNamingPolicy;\n-    this.deserializers = deserializers;\n-    this.objectConstructor = objectConstructor;\n-  }\n-\n-  JsonDeserializationContext() {\n-    this(null, null, null, null);\n+  JsonDeserializationContext(Gson gson) {\n+    this.gson = gson;\n   }\n \n   /**\n    */\n   @SuppressWarnings(\"unchecked\") @Deprecated\n   public <T> T construct(Type type) {\n-    Object instance = objectConstructor.construct(type);\n-    return (T) instance;\n+    throw new UnsupportedOperationException();\n   }\n \n   public Object constructArray(Type type, int length) {\n-    return objectConstructor.constructArray(type, length);\n-  }\n-\n-\n-  private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,\n-      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n-    JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(\n-        jsonArray, arrayType, objectNavigator, fieldNamingPolicy,\n-        objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(null, arrayType, true, systemOnly), visitor);\n-    return visitor.getTarget();\n-  }\n-\n-  private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,\n-      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n-    JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n-        jsonObject, typeOfT, objectNavigator, fieldNamingPolicy,\n-        objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(null, typeOfT, true, systemOnly), visitor);\n-    return visitor.getTarget();\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,\n-      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n-    JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n-        json, typeOfT, objectNavigator, fieldNamingPolicy, objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(json.getAsObject(), typeOfT, true, systemOnly), visitor);\n-    Object target = visitor.getTarget();\n-    return (T) target;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    */\n   @SuppressWarnings(\"unchecked\")\n   public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n-    if (json == null || json.isJsonNull()) {\n-      return null;\n-    } else if (json.isJsonArray()) {\n-      Object array = fromJsonArray(typeOfT, json.getAsJsonArray(), this, false);\n-      return (T) array;\n-    } else if (json.isJsonObject()) {\n-      Object object = fromJsonObject(typeOfT, json.getAsJsonObject(), this, false);\n-      return (T) object;\n-    } else if (json.isJsonPrimitive()) {\n-      Object primitive = fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this, false);\n-      return (T) primitive;\n-    } else {\n-      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\");\n-    }\n+    return gson.fromJson(json, typeOfT);\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T deserializeDefault(JsonElement json, Type typeOfT) throws JsonParseException {\n-    if (json == null || json.isJsonNull()) {\n-      return null;\n-    } else if (json.isJsonArray()) {\n-      Object array = fromJsonArray(typeOfT, json.getAsJsonArray(), this, true);\n-      return (T) array;\n-    } else if (json.isJsonObject()) {\n-      Object object = fromJsonObject(typeOfT, json.getAsJsonObject(), this, true);\n-      return (T) object;\n-    } else if (json.isJsonPrimitive()) {\n-      Object primitive = fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this, true);\n-      return (T) primitive;\n-    } else {\n-      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\");\n-    }\n+    throw new UnsupportedOperationException();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/JsonElement.java\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n    * more than a single element.\n    */\n   public boolean getAsBoolean() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   Boolean getAsBooleanWrapper() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public Number getAsNumber() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public String getAsString() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public double getAsDouble() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public float getAsFloat() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public long getAsLong() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public int getAsInt() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * @since 1.3\n    */\n   public byte getAsByte() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * @since 1.3\n    */\n   public char getAsCharacter() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * @since 1.2\n    */\n   public BigDecimal getAsBigDecimal() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * @since 1.2\n    */\n   public BigInteger getAsBigInteger() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   public short getAsShort() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n    * more than a single element.\n    */\n   Object getAsObject() {\n-    throw new UnsupportedOperationException();\n+    throw new UnsupportedOperationException(getClass().getSimpleName());\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n  */\n public class JsonSerializationContext {\n \n-  private final ObjectNavigator objectNavigator;\n-  private final FieldNamingStrategy2 fieldNamingPolicy;\n-  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n-  private final boolean serializeNulls;\n-  private final MemoryRefStack ancestors;\n+  private final Gson gson;\n \n-  JsonSerializationContext(ObjectNavigator objectNavigator,\n-      FieldNamingStrategy2 fieldNamingPolicy, boolean serializeNulls,\n-      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\n-    this.objectNavigator = objectNavigator;\n-    this.fieldNamingPolicy = fieldNamingPolicy;\n-    this.serializeNulls = serializeNulls;\n-    this.serializers = serializers;\n-    this.ancestors = new MemoryRefStack();\n-  }\n-  \n-  JsonSerializationContext() {\n-    this(null, null, false, null);\n+  JsonSerializationContext(Gson gson) {\n+    this.gson = gson;\n   }\n \n   /**\n    * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n    */\n   public JsonElement serialize(Object src) {\n-    if (src == null) {\n-      return JsonNull.INSTANCE;\n-    }\n-    return serialize(src, src.getClass(), false, false);\n+    return gson.toJsonTree(src);\n   }\n \n   /**\n    * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n    */\n   public JsonElement serialize(Object src, Type typeOfSrc) {\n-    return serialize(src, typeOfSrc, true, false);\n+    return gson.toJsonTree(src, typeOfSrc);\n   }\n \n   public JsonElement serializeDefault(Object src, Type typeOfSrc) {\n-    return serialize(src, typeOfSrc, true, true);\n-  }\n-\n-  JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType, boolean defaultOnly) {\n-    if (src == null) {\n-      return JsonNull.INSTANCE;\n-    }\n-    JsonSerializationVisitor visitor = new JsonSerializationVisitor(\n-        objectNavigator, fieldNamingPolicy, serializeNulls, serializers, this, ancestors);\n-    ObjectTypePair objTypePair = new ObjectTypePair(src, typeOfSrc, preserveType, defaultOnly);\n-    objectNavigator.accept(objTypePair, visitor);\n-    return visitor.getJsonElement();\n+    throw new UnsupportedOperationException();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/MapAsArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/MapAsArrayTypeAdapter.java\n \n package com.google.gson;\n \n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.Map;\n \n /**\n  * object.\n  */\n final class MapAsArrayTypeAdapter\n-    extends BaseMapTypeAdapter\n     implements JsonSerializer<Map<?, ?>>, JsonDeserializer<Map<?, ?>> {\n \n   public Map<?, ?> deserialize(JsonElement json, Type typeOfT,\n       JsonDeserializationContext context) throws JsonParseException {\n-    Map<Object, Object> result = constructMapType(typeOfT, context);\n-    Type[] keyAndValueType = typeToTypeArguments(typeOfT);\n-    if (json.isJsonArray()) {\n-      JsonArray array = json.getAsJsonArray();\n-      for (int i = 0; i < array.size(); i++) {\n-        JsonArray entryArray = array.get(i).getAsJsonArray();\n-        Object k = context.deserialize(entryArray.get(0), keyAndValueType[0]);\n-        Object v = context.deserialize(entryArray.get(1), keyAndValueType[1]);\n-        result.put(k, v);\n-      }\n-      checkSize(array, array.size(), result, result.size());\n-    } else {\n-      JsonObject object = json.getAsJsonObject();\n-      for (Map.Entry<String, JsonElement> entry : object.entrySet()) {\n-        Object k = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueType[0]);\n-        Object v = context.deserialize(entry.getValue(), keyAndValueType[1]);\n-        result.put(k, v);\n-      }\n-      checkSize(object, object.entrySet().size(), result, result.size());\n-    }\n-    return result;\n+    // TODO\n+    throw new UnsupportedOperationException();\n   }\n \n   public JsonElement serialize(Map<?, ?> src, Type typeOfSrc, JsonSerializationContext context) {\n-    Type[] keyAndValueType = typeToTypeArguments(typeOfSrc);\n-    boolean serializeAsArray = false;\n-    List<JsonElement> keysAndValues = new ArrayList<JsonElement>();\n-    for (Map.Entry<?, ?> entry : src.entrySet()) {\n-      JsonElement key = serialize(context, entry.getKey(), keyAndValueType[0]);\n-      serializeAsArray |= key.isJsonObject() || key.isJsonArray();\n-      keysAndValues.add(key);\n-      keysAndValues.add(serialize(context, entry.getValue(), keyAndValueType[1]));\n-    }\n-\n-    if (serializeAsArray) {\n-      JsonArray result = new JsonArray();\n-      for (int i = 0; i < keysAndValues.size(); i+=2) {\n-        JsonArray entryArray = new JsonArray();\n-        entryArray.add(keysAndValues.get(i));\n-        entryArray.add(keysAndValues.get(i + 1));\n-        result.add(entryArray);\n-      }\n-      return result;\n-    } else {\n-      JsonObject result = new JsonObject();\n-      for (int i = 0; i < keysAndValues.size(); i+=2) {\n-        result.add(keysAndValues.get(i).getAsString(), keysAndValues.get(i + 1));\n-      }\n-      checkSize(src, src.size(), result, result.entrySet().size());\n-      return result;\n-    }\n-  }\n-\n-  private Type[] typeToTypeArguments(Type typeOfT) {\n-    if (typeOfT instanceof ParameterizedType) {\n-      Type[] typeArguments = ((ParameterizedType) typeOfT).getActualTypeArguments();\n-      if (typeArguments.length != 2) {\n-        throw new IllegalArgumentException(\"MapAsArrayTypeAdapter cannot handle \" + typeOfT);\n-      }\n-      return typeArguments;\n-    }\n-    return new Type[] { Object.class, Object.class };\n-  }\n-\n-  private void checkSize(Object input, int inputSize, Object output, int outputSize) {\n-    if (inputSize != outputSize) {\n-      throw new JsonSyntaxException(\"Input size \" + inputSize + \" != output size \" + outputSize\n-          + \" for input \" + input + \" and output \" + output);\n-    }\n+    // TODO\n+    throw new UnsupportedOperationException();\n   }\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.InstanceCreator;\n+import com.google.gson.reflect.TypeToken;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+/**\n+ * Returns a function that can construct an instance of a requested type.\n+ */\n+public final class ConstructorConstructor {\n+  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n+\n+  public ConstructorConstructor(ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n+    this.instanceCreators = instanceCreators;\n+  }\n+\n+  public ConstructorConstructor() {\n+    this(new ParameterizedTypeHandlerMap<InstanceCreator<?>>());\n+  }\n+\n+  public <T> ObjectConstructor<T> getConstructor(TypeToken<T> typeToken) {\n+    final Type type = typeToken.getType();\n+    final Class<? super T> rawType = typeToken.getRawType();\n+\n+    // first try an instance creator\n+\n+    @SuppressWarnings(\"unchecked\") // types must agree\n+    final InstanceCreator<T> creator\n+        = (InstanceCreator<T>) instanceCreators.getHandlerFor(type, false);\n+    if (creator != null) {\n+      return new ObjectConstructor<T>() {\n+        @Override public T construct() {\n+          return creator.createInstance(type);\n+        }\n+      };\n+    }\n+\n+    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\n+    if (defaultConstructor != null) {\n+      return defaultConstructor;\n+    }\n+\n+    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(rawType);\n+    if (defaultImplementation != null) {\n+      return defaultImplementation;\n+    }\n+\n+    // finally try unsafe\n+    return newUnsafeAllocator(type, rawType);\n+  }\n+\n+  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\n+    try {\n+      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n+      if (!constructor.isAccessible()) {\n+        constructor.setAccessible(true);\n+      }\n+      return new ObjectConstructor<T>() {\n+        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n+        @Override public T construct() {\n+          try {\n+            Object[] args = null;\n+            return (T) constructor.newInstance(args);\n+          } catch (InstantiationException e) {\n+            // TODO: JsonParseException ?\n+            throw new RuntimeException(e);\n+          } catch (InvocationTargetException e) {\n+            // TODO: don't wrap if cause is unchecked!\n+            // TODO: JsonParseException ?\n+            throw new RuntimeException(e.getTargetException());\n+          } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+          }\n+        }\n+      };\n+    } catch (NoSuchMethodException e) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Constructors for common interface types like Map and List and their\n+   * subytpes.\n+   */\n+  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n+  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(Class<? super T> rawType) {\n+    if (Collection.class.isAssignableFrom(rawType)) {\n+      if (SortedSet.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new TreeSet<Object>();\n+          }\n+        };\n+      } else if (Set.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new LinkedHashSet<Object>();\n+          }\n+        };\n+      } else if (Queue.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new LinkedList<Object>();\n+          }\n+        };\n+      } else {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new ArrayList<Object>();\n+          }\n+        };\n+      }\n+    }\n+\n+    if (Map.class.isAssignableFrom(rawType)) {\n+      return new ObjectConstructor<T>() {\n+        @Override public T construct() {\n+          return (T) new LinkedHashMap<Object, Object>();\n+        }\n+      };\n+      // TODO: SortedMap ?\n+    }\n+\n+    return null;\n+  }\n+\n+  private <T> ObjectConstructor<T> newUnsafeAllocator(\n+      final Type type, final Class<? super T> rawType) {\n+    return new ObjectConstructor<T>() {\n+      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n+      @Override public T construct() {\n+        try {\n+          return (T) unsafeAllocator.newInstance(rawType);\n+        } catch (Exception e) {\n+          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n+        }\n+      }\n+    };\n+  }\n+\n+  @Override public String toString() {\n+    return instanceCreators.toString();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * Defines a generic object construction factory.  The purpose of this class\n+ * is to construct a default instance of a class that can be used for object\n+ * navigation while deserialization from its JSON representation.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public interface ObjectConstructor<T> {\n+\n+  /**\n+   * Returns a new instance.\n+   */\n+  public T construct();\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Pair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n+public final class Pair<FIRST, SECOND> {\n+  public final FIRST first;\n+  public final SECOND second;\n+\n+  public Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    Pair<?, ?> that = (Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * A map that provides ability to associate handlers for a specific type or all\n+ * of its sub-types\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <T> The handler that will be looked up by type\n+ */\n+public final class ParameterizedTypeHandlerMap<T> {\n+  private static final Logger logger =\n+      Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n+  /**\n+   * Map that is meant for storing default type adapters\n+   */\n+  private final Map<Type, T> systemMap = new HashMap<Type, T>();\n+  private final Map<Type, T> userMap = new HashMap<Type, T>();\n+  /**\n+   * List of default type hierarchy adapters\n+   */\n+  private final List<Pair<Class<?>, T>> systemTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  private final List<Pair<Class<?>, T>> userTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  private boolean modifiable = true;\n+\n+  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value, boolean isSystem) {\n+    Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n+    registerForTypeHierarchy(pair, isSystem);\n+  }\n+\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair, boolean isSystem) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    List<Pair<Class<?>, T>> typeHierarchyList = isSystem ? systemTypeHierarchyList : userTypeHierarchyList;\n+    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first, typeHierarchyList);\n+    if (index >= 0) {\n+      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n+      typeHierarchyList.remove(index);\n+    }\n+    index = getIndexOfAnOverriddenHandler(pair.first, typeHierarchyList);\n+    if (index >= 0) {\n+      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n+          + \" hides the previously registered type hierarchy handler for \"\n+          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n+    }\n+    // We want stack behavior for adding to this list. A type adapter added subsequently should\n+    // override a previously registered one.\n+    typeHierarchyList.add(0, pair);\n+  }\n+\n+  private static <T> int getIndexOfAnOverriddenHandler(Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n+      if (type.isAssignableFrom(entry.first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public synchronized void register(Type typeOfT, T value, boolean isSystem) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    if (hasSpecificHandlerFor(typeOfT)) {\n+      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n+    }\n+    Map<Type, T> map = isSystem ? systemMap : userMap;\n+    map.put(typeOfT, value);\n+  }\n+\n+  public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n+      if (!userMap.containsKey(entry.getKey())) {\n+        register(entry.getKey(), entry.getValue(), false);\n+      }\n+    }\n+    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n+      if (!systemMap.containsKey(entry.getKey())) {\n+        register(entry.getKey(), entry.getValue(), true);\n+      }\n+    }\n+    // Quite important to traverse the typeHierarchyList from stack bottom first since\n+    // we want to register the handlers in the same order to preserve priority order\n+    for (int i = other.userTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n+      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, userTypeHierarchyList);\n+      if (index < 0) {\n+        registerForTypeHierarchy(entry, false);\n+      }\n+    }\n+    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n+      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, systemTypeHierarchyList);\n+      if (index < 0) {\n+        registerForTypeHierarchy(entry, true);\n+      }\n+    }\n+  }\n+\n+  public synchronized void register(ParameterizedTypeHandlerMap<T> other) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n+      register(entry.getKey(), entry.getValue(), false);\n+    }\n+    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n+      register(entry.getKey(), entry.getValue(), true);\n+    }\n+    // Quite important to traverse the typeHierarchyList from stack bottom first since\n+    // we want to register the handlers in the same order to preserve priority order\n+    for (int i = other.userTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n+      registerForTypeHierarchy(entry, false);\n+    }\n+    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n+      registerForTypeHierarchy(entry, true);\n+    }\n+  }\n+\n+  public synchronized void registerIfAbsent(Type typeOfT, T value) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    if (!userMap.containsKey(typeOfT)) {\n+      register(typeOfT, value, false);\n+    }\n+  }\n+\n+  public synchronized void makeUnmodifiable() {\n+    modifiable = false;\n+  }\n+\n+  public synchronized T getHandlerFor(Type type, boolean systemOnly) {\n+    T handler;\n+    if (!systemOnly) {\n+      handler = userMap.get(type);\n+      if (handler != null) {\n+        return handler;\n+      }\n+    }\n+    handler = systemMap.get(type);\n+    if (handler != null) {\n+      return handler;\n+    }\n+    Class<?> rawClass = $Gson$Types.getRawType(type);\n+    if (rawClass != type) {\n+      handler = getHandlerFor(rawClass, systemOnly);\n+      if (handler != null) {\n+        return handler;\n+      }\n+    }\n+    // check if something registered for type hierarchy\n+    handler = getHandlerForTypeHierarchy(rawClass, systemOnly);\n+    return handler;\n+  }\n+\n+  private T getHandlerForTypeHierarchy(Class<?> type, boolean systemOnly) {\n+    if (!systemOnly) {\n+      for (Pair<Class<?>, T> entry : userTypeHierarchyList) {\n+        if (entry.first.isAssignableFrom(type)) {\n+          return entry.second;\n+        }\n+      }\n+    }\n+    for (Pair<Class<?>, T> entry : systemTypeHierarchyList) {\n+      if (entry.first.isAssignableFrom(type)) {\n+        return entry.second;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  public synchronized boolean hasSpecificHandlerFor(Type type) {\n+    return userMap.containsKey(type) || systemMap.containsKey(type);\n+  }\n+\n+  private static <T> int getIndexOfSpecificHandlerForTypeHierarchy(\n+      Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      if (type.equals(typeHierarchyList.get(i).first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public synchronized ParameterizedTypeHandlerMap<T> copyOf() {\n+    ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>();\n+    // Instead of individually registering entries in the map, make an efficient copy\n+    // of the list and map\n+\n+    // TODO (inder): Performance optimization. We can probably just share the\n+    // systemMap and systemTypeHierarchyList instead of making copies\n+    copy.systemMap.putAll(systemMap);\n+    copy.userMap.putAll(userMap);\n+    copy.systemTypeHierarchyList.addAll(systemTypeHierarchyList);\n+    copy.userTypeHierarchyList.addAll(userTypeHierarchyList);\n+    return copy;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder(\"{userTypeHierarchyList:{\");\n+    appendList(sb, userTypeHierarchyList);\n+    sb.append(\"},systemTypeHierarchyList:{\");\n+    appendList(sb, systemTypeHierarchyList);\n+    sb.append(\"},userMap:{\");\n+    appendMap(sb, userMap);\n+    sb.append(\"},systemMap:{\");\n+    appendMap(sb, systemMap);\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  private void appendList(StringBuilder sb, List<Pair<Class<?>,T>> list) {\n+    boolean first = true;\n+    for (Pair<Class<?>, T> entry : list) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append(typeToString(entry.first)).append(':');\n+      sb.append(entry.second);\n+    }\n+  }\n+\n+  private void appendMap(StringBuilder sb, Map<Type, T> map) {\n+    boolean first = true;\n+    for (Map.Entry<Type, T> entry : map.entrySet()) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append(typeToString(entry.getKey())).append(':');\n+      sb.append(entry.getValue());\n+    }\n+  }\n+\n+  private String typeToString(Type type) {\n+    return $Gson$Types.getRawType(type).getSimpleName();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Primitives.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+\n+import com.google.gson.internal.$Gson$Preconditions;\n+import java.lang.reflect.Type;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains static utility methods pertaining to primitive types and their\n+ * corresponding wrapper types.\n+ *\n+ * @author Kevin Bourrillion\n+ */\n+public final class Primitives {\n+  private Primitives() {}\n+\n+  /** A map from primitive types to their corresponding wrapper types. */\n+  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n+\n+  /** A map from wrapper types to their corresponding primitive types. */\n+  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n+\n+  // Sad that we can't use a BiMap. :(\n+\n+  static {\n+    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\n+    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n+\n+    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);\n+    add(primToWrap, wrapToPrim, byte.class, Byte.class);\n+    add(primToWrap, wrapToPrim, char.class, Character.class);\n+    add(primToWrap, wrapToPrim, double.class, Double.class);\n+    add(primToWrap, wrapToPrim, float.class, Float.class);\n+    add(primToWrap, wrapToPrim, int.class, Integer.class);\n+    add(primToWrap, wrapToPrim, long.class, Long.class);\n+    add(primToWrap, wrapToPrim, short.class, Short.class);\n+    add(primToWrap, wrapToPrim, void.class, Void.class);\n+\n+    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\n+    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n+  }\n+\n+  private static void add(Map<Class<?>, Class<?>> forward,\n+      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n+    forward.put(key, value);\n+    backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public static boolean isPrimitive(Type type) {\n+    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n+  }\n+\n+  /**\n+   * Returns {@code true} if {@code type} is one of the nine\n+   * primitive-wrapper types, such as {@link Integer}.\n+   *\n+   * @see Class#isPrimitive\n+   */\n+  public static boolean isWrapperType(Type type) {\n+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n+        $Gson$Preconditions.checkNotNull(type));\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> wrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n+        $Gson$Preconditions.checkNotNull(type));\n+    return (wrapped == null) ? type : wrapped;\n+  }\n+\n+  /**\n+   * Returns the corresponding primitive type of {@code type} if it is a\n+   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     unwrap(Integer.class) == int.class\n+   *     unwrap(int.class) == int.class\n+   *     unwrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> unwrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n+        $Gson$Preconditions.checkNotNull(type));\n+    return (unwrapped == null) ? type : unwrapped;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n  *\n  * @author Joel Leitch\n  */\n-public class BigDecimalTypeAdapter extends TypeAdapter<BigDecimal> {\n+public final class BigDecimalTypeAdapter extends TypeAdapter<BigDecimal> {\n \n   @Override\n   public BigDecimal read(JsonReader reader) throws IOException {\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n  *\n  * @author Joel Leitch\n  */\n-public class BigIntegerTypeAdapter extends TypeAdapter<BigInteger> {\n+public final class BigIntegerTypeAdapter extends TypeAdapter<BigInteger> {\n \n   @Override\n   public BigInteger read(JsonReader reader) throws IOException {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * Adapt a homogeneous collection of objects.\n+ */\n+public final class CollectionTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ConstructorConstructor constructorConstructor;\n+\n+  public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+    this.constructorConstructor = constructorConstructor;\n+  }\n+\n+  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    Type type = typeToken.getType();\n+\n+    Class<? super T> rawType = typeToken.getRawType();\n+    if (!Collection.class.isAssignableFrom(rawType)) {\n+      return null;\n+    }\n+\n+    Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n+    TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));\n+    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n+\n+    @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n+    TypeAdapter<T> result = new Adapter(context, elementType, elementTypeAdapter, constructor);\n+    return result;\n+  }\n+\n+  private final class Adapter<E> extends TypeAdapter<Collection<E>> {\n+    private final TypeAdapter<E> elementTypeAdapter;\n+    private final ObjectConstructor<? extends Collection<E>> constructor;\n+\n+    public Adapter(MiniGson context, Type elementType,\n+        TypeAdapter<E> elementTypeAdapter,\n+        ObjectConstructor<? extends Collection<E>> constructor) {\n+      this.elementTypeAdapter =\n+          new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\n+      this.constructor = constructor;\n+    }\n+\n+    public Collection<E> read(JsonReader reader) throws IOException {\n+      if (reader.peek() == JsonToken.NULL) {\n+        reader.nextNull(); // TODO: does this belong here?\n+        return null;\n+      }\n+\n+      Collection<E> collection = constructor.construct();\n+      reader.beginArray();\n+      while (reader.hasNext()) {\n+        E instance = elementTypeAdapter.read(reader);\n+        collection.add(instance);\n+      }\n+      reader.endArray();\n+      return collection;\n+    }\n+\n+    public void write(JsonWriter writer, Collection<E> collection) throws IOException {\n+      if (collection == null) {\n+        writer.nullValue(); // TODO: better policy here?\n+        return;\n+      }\n+\n+      writer.beginArray();\n+      for (E element : collection) {\n+        elementTypeAdapter.write(writer, element);\n+      }\n+      writer.endArray();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.ExclusionStrategy;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+\n+/**\n+ * This type adapter skips values using an exclusion strategy. It may delegate\n+ * to another type adapter if only one direction is excluded.\n+ */\n+public final class ExcludedTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ExclusionStrategy serializationExclusionStrategy;\n+  private final ExclusionStrategy deserializationExclusionStrategy;\n+\n+  public ExcludedTypeAdapterFactory(ExclusionStrategy serializationExclusionStrategy,\n+      ExclusionStrategy deserializationExclusionStrategy) {\n+    this.serializationExclusionStrategy = serializationExclusionStrategy;\n+    this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n+  }\n+\n+  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> type) {\n+    Class<?> rawType = type.getRawType();\n+    final boolean skipSerialize = serializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipDeserialize = deserializationExclusionStrategy.shouldSkipClass(rawType);\n+\n+    if (!skipSerialize && !skipDeserialize) {\n+      return null;\n+    }\n+\n+    return new TypeAdapter<T>() {\n+      /**\n+       * The delegate is lazily created because it may not be needed, and\n+       * creating it may fail.\n+       */\n+      private TypeAdapter<T> delegate;\n+\n+      @Override public T read(JsonReader reader) throws IOException {\n+        if (skipDeserialize) {\n+          reader.skipValue();\n+          return null;\n+        }\n+        return delegate().read(reader);\n+      }\n+\n+      @Override public void write(JsonWriter writer, T value) throws IOException {\n+        if (skipSerialize) {\n+          writer.nullValue();\n+          return;\n+        }\n+        delegate().write(writer, value);\n+      }\n+\n+      private TypeAdapter<T> delegate() {\n+        TypeAdapter<T> d = delegate;\n+        return d != null\n+            ? d\n+            : (delegate = context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a map whose keys are any type.\n+ */\n+public final class MapTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ConstructorConstructor constructorConstructor;\n+\n+  public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+    this.constructorConstructor = constructorConstructor;\n+  }\n+\n+  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    Type type = typeToken.getType();\n+\n+    Class<? super T> rawType = typeToken.getRawType();\n+    if (!Map.class.isAssignableFrom(rawType)) {\n+      return null;\n+    }\n+\n+    Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n+    Type childGenericType = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n+    TypeAdapter valueAdapter = context.getAdapter(TypeToken.get(childGenericType));\n+    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n+\n+    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+    TypeAdapter<T> result = new Adapter(valueAdapter, constructor);\n+    return result;\n+  }\n+\n+  private final class Adapter<V> extends TypeAdapter<Map<?, V>> {\n+    private final TypeAdapter<V> valueTypeAdapter;\n+    private final ObjectConstructor<? extends Map<String, V>> constructor;\n+\n+    public Adapter(TypeAdapter<V> valueTypeAdapter,\n+        ObjectConstructor<? extends Map<String, V>> constructor) {\n+      this.valueTypeAdapter = valueTypeAdapter;\n+      this.constructor = constructor;\n+    }\n+\n+    public Map<?, V> read(JsonReader reader) throws IOException {\n+      if (reader.peek() == JsonToken.NULL) {\n+        reader.nextNull(); // TODO: does this belong here?\n+        return null;\n+      }\n+\n+      Map<String, V> map = constructor.construct();\n+\n+      reader.beginObject();\n+      while (reader.hasNext()) {\n+        String key = reader.nextName();\n+        V value = valueTypeAdapter.read(reader);\n+        map.put(key, value); // TODO: convert to the map's key type?\n+      }\n+      reader.endObject();\n+      return map;\n+    }\n+\n+    public void write(JsonWriter writer, Map<?, V> map) throws IOException {\n+      if (map == null) {\n+        writer.nullValue(); // TODO: better policy here?\n+        return;\n+      }\n+\n+      writer.beginObject();\n+      for (Map.Entry<?, V> entry : map.entrySet()) {\n+        String key = String.valueOf(entry.getKey());\n+        writer.name(key);\n+        valueTypeAdapter.write(writer, entry.getValue());\n+      }\n+      writer.endObject();\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonWriter;\n-\n /**\n  * A basic binding between JSON and Java objects.\n  */\n   private final List<TypeAdapter.Factory> factories;\n \n   private MiniGson(Builder builder) {\n+    ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n     if (builder.addDefaultFactories) {\n       factories.add(TypeAdapters.BOOLEAN_FACTORY);\n     }\n     factories.addAll(builder.factories);\n     if (builder.addDefaultFactories) {\n-      factories.add(CollectionTypeAdapter.FACTORY);\n-      factories.add(StringToValueMapTypeAdapter.FACTORY);\n+      factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n+      factories.add(new StringToValueMapTypeAdapterFactory(constructorConstructor));\n       factories.add(ArrayTypeAdapter.FACTORY);\n       factories.add(ObjectTypeAdapter.FACTORY);\n-      factories.add(ReflectiveTypeAdapter.FACTORY);\n+      factories.add(new ReflectiveTypeAdapterFactory(constructorConstructor));\n     }\n     this.factories = Collections.unmodifiableList(factories);\n   }\n     }\n   }\n \n+  /**\n+   * Returns a type adapter for {@code} type that isn't {@code skipPast}. This\n+   * can be used for type adapters to compose other, simpler type adapters.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getNextAdapter(TypeAdapter.Factory skipPast, TypeToken<T> type) {\n+    boolean skipPastFound = false;\n+\n+    for (TypeAdapter.Factory factory : factories) {\n+      if (!skipPastFound) {\n+        if (factory == skipPast) {\n+          skipPastFound = true;\n+        }\n+        continue;\n+      }\n+\n+      TypeAdapter<T> candidate = factory.create(this, type);\n+      if (candidate != null) {\n+        return candidate;\n+      }\n+    }\n+\n+    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+  }\n+\n   static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n     private TypeAdapter<T> delegate;\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/Reflection.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/Reflection.java\n  */\n package com.google.gson.internal.bind;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n \n   public static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\n     if (value != null\n         && (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>)) {\n-      type = (Class<?>) value.getClass();\n+      type = value.getClass();\n     }\n     return type;\n   }\n-\n-  // TODO: this should use Joel's unsafe constructor stuff\n-  public static <T> T newInstance(Constructor<T> constructor) {\n-    if (!constructor.isAccessible()) {\n-      constructor.setAccessible(true);\n-    }\n-    try {\n-      Object[] args = null;\n-      return constructor.newInstance(args);\n-    } catch (InstantiationException e) {\n-      // TODO: JsonParseException ?\n-      throw new RuntimeException(e);\n-    } catch (InvocationTargetException e) {\n-      // TODO: don't wrap if cause is unchecked!\n-      // TODO: JsonParseException ?\n-      throw new RuntimeException(e.getTargetException());\n-    } catch (IllegalAccessException e) {\n-      throw new AssertionError(e);\n-    }\n-  }\n-\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Type adapter that reflects over the fields and methods of a class.\n+ */\n+public class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ConstructorConstructor constructorConstructor;\n+\n+  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+    this.constructorConstructor = constructorConstructor;\n+  }\n+\n+  protected boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n+    return !f.isSynthetic();\n+  }\n+\n+  protected boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n+    return !f.isSynthetic();\n+  }\n+\n+  protected String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n+    return f.getName();\n+  }\n+\n+  public <T> TypeAdapter<T> create(MiniGson context, final TypeToken<T> type) {\n+    Class<? super T> raw = type.getRawType();\n+\n+    if (!Object.class.isAssignableFrom(raw)) {\n+      return null; // it's a primitive!\n+    }\n+\n+    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(type);\n+\n+    return new Adapter<T>(context, constructor, type,\n+        getBoundFields(context, type, raw));\n+  }\n+\n+  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n+      final MiniGson context, final Field field, final String name,\n+      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n+    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n+\n+    // special casing primitives here saves ~5% on Android...\n+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n+      final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n+      @SuppressWarnings(\"unchecked\") // the type adapter and field type always agree\n+      @Override void write(JsonWriter writer, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = field.get(value);\n+        TypeAdapter t =\n+          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n+        t.write(writer, fieldValue);\n+      }\n+      @Override void read(JsonReader reader, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = typeAdapter.read(reader);\n+        if (fieldValue != null || !isPrimitive) {\n+          field.set(value, fieldValue);\n+        }\n+      }\n+    };\n+  }\n+\n+  private Map<String, BoundField> getBoundFields(\n+      MiniGson context, TypeToken<?> type, Class<?> raw) {\n+    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n+    if (raw.isInterface()) {\n+      return result;\n+    }\n+\n+    Type declaredType = type.getType();\n+    while (raw != Object.class) {\n+      Field[] fields = raw.getDeclaredFields();\n+      AccessibleObject.setAccessible(fields, true);\n+      for (Field field : fields) {\n+        boolean serialize = serializeField(raw, field, declaredType);\n+        boolean deserialize = deserializeField(raw, field, declaredType);\n+        if (!serialize && !deserialize) {\n+          continue;\n+        }\n+        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+        BoundField boundField = createBoundField(context, field, getFieldName(raw, field, declaredType),\n+            TypeToken.get(fieldType), serialize, deserialize);\n+        BoundField previous = result.put(boundField.name, boundField);\n+        if (previous != null) {\n+          throw new IllegalArgumentException(declaredType\n+              + \" declares multiple JSON fields named \" + previous.name);\n+        }\n+      }\n+      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+      raw = type.getRawType();\n+    }\n+    return result;\n+  }\n+\n+  static abstract class BoundField {\n+    final String name;\n+    final boolean serialized;\n+    final boolean deserialized;\n+\n+    protected BoundField(String name, boolean serialized, boolean deserialized) {\n+      this.name = name;\n+      this.serialized = serialized;\n+      this.deserialized = deserialized;\n+    }\n+\n+    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n+    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n+  }\n+\n+  public final class Adapter<T> extends TypeAdapter<T> {\n+    private final MiniGson context;\n+    private final ObjectConstructor<T> constructor;\n+    private final TypeToken<T> type;\n+    private final Map<String, BoundField> boundFields;\n+\n+    private Adapter(MiniGson context, ObjectConstructor<T> constructor,\n+        TypeToken<T> type, Map<String, BoundField> boundFields) {\n+      this.context = context;\n+      this.constructor = constructor;\n+      this.type = type;\n+      this.boundFields = boundFields;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n+    public T read(JsonReader reader) throws IOException {\n+      if (reader.peek() == JsonToken.NULL) {\n+        reader.nextNull(); // TODO: does this belong here?\n+        return null;\n+      }\n+\n+      T instance = constructor.construct();\n+\n+      // TODO: null out the other fields?\n+\n+      try {\n+        reader.beginObject();\n+        while (reader.hasNext()) {\n+          String name = reader.nextName();\n+          BoundField field = boundFields.get(name);\n+          if (field == null || !field.deserialized) {\n+            // TODO: define a better policy\n+            reader.skipValue();\n+          } else {\n+            field.read(reader, instance);\n+          }\n+        }\n+      } catch (IllegalStateException e) {\n+        throw new JsonSyntaxException(e);\n+      } catch (IllegalAccessException e) {\n+        throw new AssertionError();\n+      }\n+      reader.endObject();\n+      return instance;\n+    }\n+\n+    public void write(JsonWriter writer, T value) throws IOException {\n+      if (value == null) {\n+        writer.nullValue(); // TODO: better policy here?\n+        return;\n+      }\n+\n+      // TODO: GSON includes subclass fields during serialization\n+      if (false) {\n+        Class<?> runtimeType = value.getClass();\n+        if (runtimeType != type.getRawType()) {\n+          TypeAdapter<?> adapter = context.getAdapter(runtimeType);\n+          ((TypeAdapter) adapter).write(writer, value);\n+          return;\n+        }\n+      }\n+\n+      writer.beginObject();\n+      try {\n+        for (BoundField boundField : boundFields.values()) {\n+          if (boundField.serialized) {\n+            writer.name(boundField.name);\n+            boundField.write(writer, value);\n+          }\n+        }\n+      } catch (IllegalAccessException e) {\n+        throw new AssertionError();\n+      }\n+      writer.endObject();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.ObjectConstructor;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a map whose keys are strings.\n+ */\n+public final class StringToValueMapTypeAdapterFactory implements TypeAdapter.Factory {\n+  private final ConstructorConstructor constructorConstructor;\n+\n+  public StringToValueMapTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+    this.constructorConstructor = constructorConstructor;\n+  }\n+\n+  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    Type type = typeToken.getType();\n+    if (!(type instanceof ParameterizedType)) {\n+      return null;\n+    }\n+\n+    Class<? super T> rawType = typeToken.getRawType();\n+    if (!Map.class.isAssignableFrom(rawType)) {\n+      return null;\n+    }\n+\n+    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);\n+    if (keyAndValueTypes[0] != String.class) {\n+      return null;\n+    }\n+    TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+\n+    ObjectConstructor<?> constructor = constructorConstructor.getConstructor(typeToken);\n+\n+    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+    TypeAdapter<T> result = new Adapter(valueAdapter, constructor);\n+    return result;\n+  }\n+\n+  private final class Adapter<V> extends TypeAdapter<Map<String, V>> {\n+    private final TypeAdapter<V> valueTypeAdapter;\n+    private final ObjectConstructor<? extends Map<String, V>> constructor;\n+\n+    public Adapter(TypeAdapter<V> valueTypeAdapter,\n+        ObjectConstructor<? extends Map<String, V>> constructor) {\n+      this.valueTypeAdapter = valueTypeAdapter;\n+      this.constructor = constructor;\n+    }\n+\n+    public Map<String, V> read(JsonReader reader) throws IOException {\n+      if (reader.peek() == JsonToken.NULL) {\n+        reader.nextNull(); // TODO: does this belong here?\n+        return null;\n+      }\n+\n+      Map<String, V> map = constructor.construct();\n+      reader.beginObject();\n+      while (reader.hasNext()) {\n+        String key = reader.nextName();\n+        V value = valueTypeAdapter.read(reader);\n+        map.put(key, value);\n+      }\n+      reader.endObject();\n+      return map;\n+    }\n+\n+    public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+      if (map == null) {\n+        writer.nullValue(); // TODO: better policy here?\n+        return;\n+      }\n+\n+      writer.beginObject();\n+      for (Map.Entry<String, V> entry : map.entrySet()) {\n+        writer.name(entry.getKey());\n+        valueTypeAdapter.write(writer, entry.getValue());\n+      }\n+      writer.endObject();\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n  */\n package com.google.gson.internal.bind;\n \n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n \n     Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(type, value);\n     if (runtimeType != type) {\n       TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));\n-      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapter)) {\n+      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n         // The user registered a type adapter for the runtime type, so we will use that\n         chosen = runtimeTypeAdapter;\n-      } else if (!(delegate instanceof ReflectiveTypeAdapter)) {\n+      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n         // The user registered a type adapter for Base class, so we prefer it over the\n         // reflective type adapter for the runtime type\n         chosen = delegate;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n   public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n     public String read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull(); // TODO: does this belong here?\n-        return null;\n+      JsonToken peek = reader.peek();\n+      if (peek == JsonToken.NULL) {\n+        reader.nextNull(); // TODO: does this belong here?\n+        return null;\n+      }\n+      /* coerce booleans to strings for backwards compatibility */\n+      if (peek == JsonToken.BOOLEAN) {\n+        return Boolean.toString(reader.nextBoolean());\n       }\n       return reader.nextString();\n     }\n \n   public static final TypeAdapter.Factory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n \n-  public static final TypeAdapter EXCLUDED_TYPE_ADAPTER = new TypeAdapter<Object>() {\n-    @Override public Object read(JsonReader reader) throws IOException {\n-      reader.skipValue();\n-      return null;\n-    }\n-    @Override public void write(JsonWriter writer, Object value) throws IOException {\n-      writer.nullValue();\n-    }\n-  };\n-\n   public static <T> TypeAdapter.Factory newFactory(\n       final TypeToken<T> type, final TypeAdapter<T> typeAdapter) {\n     return new TypeAdapter.Factory() {\n--- a/gson/src/test/java/com/google/gson/DefaultMapJsonSerializerTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultMapJsonSerializerTest.java\n package com.google.gson;\n \n import com.google.gson.reflect.TypeToken;\n-\n-import junit.framework.TestCase;\n-\n import java.lang.reflect.Type;\n import java.util.HashMap;\n import java.util.Map;\n+import junit.framework.TestCase;\n \n /**\n  * Unit test for the default JSON map serialization object located in the\n  * @author Joel Leitch\n  */\n public class DefaultMapJsonSerializerTest extends TestCase {\n-  private JsonSerializer<Map<?, ?>> mapSerializer;\n-\n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-    mapSerializer = new MapTypeAdapter();\n-  }\n+  private Gson gson = new Gson();\n \n   public void testEmptyMapNoTypeSerialization() {\n     Map<String, String> emptyMap = new HashMap<String, String>();\n-    JsonElement element = mapSerializer.serialize(emptyMap, emptyMap.getClass(), null);\n+    JsonElement element = gson.toJsonTree(emptyMap, emptyMap.getClass());\n     assertTrue(element instanceof JsonObject);\n     JsonObject emptyMapJsonObject = (JsonObject) element;\n     assertTrue(emptyMapJsonObject.entrySet().isEmpty());\n   public void testEmptyMapSerialization() {\n     Type mapType = new TypeToken<Map<String, String>>() { }.getType();\n     Map<String, String> emptyMap = new HashMap<String, String>();\n-    JsonElement element = mapSerializer.serialize(emptyMap, mapType, null);\n+    JsonElement element = gson.toJsonTree(emptyMap, mapType);\n \n     assertTrue(element instanceof JsonObject);\n     JsonObject emptyMapJsonObject = (JsonObject) element;\n     assertTrue(emptyMapJsonObject.entrySet().isEmpty());\n   }\n-  \n+\n   public void testNonEmptyMapSerialization() {\n     Type mapType = new TypeToken<Map<String, String>>() { }.getType();\n     Map<String, String> myMap = new HashMap<String, String>();\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n \n package com.google.gson;\n \n+import com.google.gson.common.TestTypes.ClassWithNoFields;\n import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n-\n import junit.framework.TestCase;\n-\n-import com.google.gson.common.TestTypes.ClassWithNoFields;\n \n /**\n  * Functional tests for Gson that depend on some internal package-protected elements of\n     strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));\n     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,\n-        new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n+        DefaultTypeAdapters.getDefaultInstanceCreators(),\n         false, DefaultTypeAdapters.getDefaultSerializers(),\n         DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE, true,\n         false, false, LongSerializationPolicy.DEFAULT);\n--- a/gson/src/test/java/com/google/gson/MixedStreamTest.java\n+++ b/gson/src/test/java/com/google/gson/MixedStreamTest.java\n     assertEquals(RED_MIATA, gson.fromJson(jsonReader, Car.class));\n     jsonReader.endArray();\n   }\n-  \n+\n   public void testReaderDoesNotMutateState() throws IOException {\n     Gson gson = new Gson();\n     JsonReader jsonReader = new JsonReader(new StringReader(CARS_JSON));\n     try {\n       gson.fromJson(jsonReader, String.class);\n       fail();\n-    } catch (IllegalArgumentException expected) {\n+    } catch (IllegalStateException expected) {\n     }\n   }\n \n     } catch (IllegalStateException expected) {\n     }\n   }\n-  \n+\n   public void testWriteNulls() {\n     Gson gson = new Gson();\n     try {\n     gson.toJson(null, new JsonWriter(stringWriter));\n     assertEquals(\"\", stringWriter.toString());\n   }\n-  \n+\n   public void testReadNulls() {\n     Gson gson = new Gson();\n     try {\n     try {\n       gson.fromJson(new JsonReader(new StringReader(\"true\")), null);\n       fail();\n-    } catch (IllegalArgumentException expected) {\n+    } catch (NullPointerException expected) {\n     }\n   }\n \n     assertEquals(\"[\\\"<\\\",\\\">\\\",\\\"&\\\",\\\"=\\\",\\\"'\\\"]\",\n         writer.toString());\n   }\n-  \n+\n   public void testWriteLenient() {\n     List<Double> doubles = Arrays.asList(Double.NaN, Double.NEGATIVE_INFINITY,\n         Double.POSITIVE_INFINITY, -0.0d, 0.5d, 0.0d);\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n import com.google.gson.internal.$Gson$Types;\n \n+import com.google.gson.internal.Primitives;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n--- a/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n+++ b/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Primitives;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n--- a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n     assertFalse(json.contains(\"\\\"annotatedField\\\"\"));\n     assertTrue(json.contains(\"\\\"longField\\\"\"));\n   }\n-  \n+\n   public void testExclusionStrategyDeserialization() throws Exception {\n     Gson gson = createGson(new MyExclusionStrategy(String.class), false);\n     JsonObject json = new JsonObject();\n     assertEquals(src.annotatedField, target.annotatedField);\n     assertEquals(src.stringField, target.stringField);\n   }\n-  \n+\n   public void testExclusionStrategyWithMode() throws Exception {\n     SampleObjectForTest testObj = new SampleObjectForTest(\n         src.annotatedField + 5, src.stringField + \"blah,blah\",\n         src.longField + 655L);\n \n-    Gson gson = createGson(new MyExclusionStrategy(String.class), false);    \n+    Gson gson = createGson(new MyExclusionStrategy(String.class), false);\n     JsonObject json = gson.toJsonTree(testObj).getAsJsonObject();\n     assertEquals(testObj.annotatedField, json.get(\"annotatedField\").getAsInt());\n     assertEquals(testObj.stringField, json.get(\"stringField\").getAsString());\n         .serializeNulls()\n         .create();\n   }\n-  \n+\n   @Retention(RetentionPolicy.RUNTIME)\n   @Target({ElementType.FIELD})\n   private static @interface Foo {\n     public SampleObjectForTest() {\n       this(5, \"someDefaultValue\", 12345L);\n     }\n-    \n+\n     public SampleObjectForTest(int annotatedField, String stringField, long longField) {\n       this.annotatedField = annotatedField;\n       this.stringField = stringField;\n--- a/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java\n \n package com.google.gson.functional;\n \n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-\n import junit.framework.TestCase;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n-import com.google.gson.JsonSyntaxException;\n-import com.google.gson.reflect.TypeToken;\n \n public class MapAsArrayTypeAdapterTest extends TestCase {\n \n     } catch (JsonSyntaxException expected) {\n     }\n   }\n-  \n+\n   public void testMultipleEnableComplexKeyRegistrationHasNoEffect() throws Exception {\n     Type type = new TypeToken<Map<Point, String>>() {}.getType();\n     Gson gson = new GsonBuilder()\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/ParameterizedTypeHandlerMapTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.common.TestTypes.Base;\n+import com.google.gson.common.TestTypes.Sub;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Unit tests for the {@link com.google.gson.internal.ParameterizedTypeHandlerMap} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ParameterizedTypeHandlerMapTest extends TestCase {\n+  private ParameterizedTypeHandlerMap<String> paramMap;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    paramMap = new ParameterizedTypeHandlerMap<String>();\n+  }\n+\n+  public void testNullMap() throws Exception {\n+    assertFalse(paramMap.hasSpecificHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class, false));\n+    assertNull(paramMap.getHandlerFor(String.class, false));\n+  }\n+\n+  public void testHasGenericButNotSpecific() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(List.class, handler, false);\n+\n+    assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n+    assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType, false));\n+    assertNotNull(paramMap.getHandlerFor(List.class, false));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType, false));\n+  }\n+\n+  public void testHasSpecificType() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(specificType, handler, false);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n+    assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType, false));\n+    assertNull(paramMap.getHandlerFor(List.class, false));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType, false));\n+  }\n+\n+  public void testTypeOverridding() throws Exception {\n+    String handler1 = \"blah1\";\n+    String handler2 = \"blah2\";\n+    paramMap.register(String.class, handler1, false);\n+    paramMap.register(String.class, handler2, false);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n+    assertEquals(handler2, paramMap.getHandlerFor(String.class, false));\n+  }\n+\n+  public void testMakeUnmodifiable() throws Exception {\n+    paramMap.makeUnmodifiable();\n+    try {\n+     paramMap.register(String.class, \"blah\", false);\n+     fail(\"Can not register handlers when map is unmodifiable\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+\n+  public void testTypeHierarchy() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    String handler = paramMap.getHandlerFor(Sub.class, false);\n+    assertEquals(\"baseHandler\", handler);\n+  }\n+\n+  public void testTypeHierarchyMultipleHandlers() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n+    String handler = paramMap.getHandlerFor(SubOfSub.class, false);\n+    assertEquals(\"subHandler\", handler);\n+  }\n+\n+  public void testTypeHierarchyRegisterIfAbsent() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>();\n+    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\", false);\n+    paramMap.registerIfAbsent(otherMap);\n+    String handler = paramMap.getHandlerFor(Base.class, false);\n+    assertEquals(\"baseHandler\", handler);\n+  }\n+\n+  public void testReplaceExistingTypeHierarchyHandler() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\", false);\n+    String handler = paramMap.getHandlerFor(Base.class, false);\n+    assertEquals(\"base2Handler\", handler);\n+  }\n+\n+  public void testHidingExistingTypeHierarchyHandlerIsDisallowed() {\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n+    try {\n+      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+      fail(\"A handler that hides an existing type hierarchy handler is not allowed\");\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+  private static class SubOfSub extends Sub {\n+  }\n+}", "timestamp": 1315724696, "metainfo": ""}