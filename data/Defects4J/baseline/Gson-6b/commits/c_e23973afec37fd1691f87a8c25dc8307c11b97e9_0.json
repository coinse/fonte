{"sha": "e23973afec37fd1691f87a8c25dc8307c11b97e9", "log": "Smash together ReflectiveTypeAdapterFactory and its subclass. The separation was useful earlier when we were contemplating keeping Gson and MiniGson separate.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n    *\n    * @param f the field to pull attributes from\n    */\n-  FieldAttributes(Class<?> declaringClazz, Field f) {\n-    this.declaringClazz = $Gson$Preconditions.checkNotNull(declaringClazz);\n+  public FieldAttributes(Field f) {\n+    this.declaringClazz = f.getDeclaringClass();\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n     return isSynthetic;\n   }\n \n-  /**\n-   * @deprecated remove this when {@link FieldNamingStrategy} is deleted.\n-   */\n-  @Deprecated\n-  Field getFieldObject() {\n-    return field;\n-  }\n-\n   @SuppressWarnings(\"unchecked\")\n   private static <T extends Annotation> T getAnnotationFromArray(\n       Collection<Annotation> annotations, Class<T> annotation) {\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n-import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n   @SuppressWarnings(\"rawtypes\")\n   static final TypeMap EMPTY_MAP = new TypeMap().makeUnmodifiable();\n \n-   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+  static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n \n   // Default instances of plug-ins\n   static final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\n   };\n \n   private final List<TypeAdapter.Factory> factories;\n-  private final ExclusionStrategy deserializationExclusionStrategy;\n-  private final ExclusionStrategy serializationExclusionStrategy;\n   private final ConstructorConstructor constructorConstructor;\n \n   /** Map containing Type or Class objects as keys */\n       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n       List<TypeAdapter.Factory> typeAdapterFactories) {\n-    this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n-    this.serializationExclusionStrategy = serializationExclusionStrategy;\n     this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.serializeNulls = serializeNulls;\n     this.serializers = serializers;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n \n-    TypeAdapter.Factory reflectiveTypeAdapterFactory\n-        = new ReflectiveTypeAdapterFactory(constructorConstructor) {\n-      @Override\n-      public String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n-        SerializedName serializedName = f.getAnnotation(SerializedName.class);\n-        return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n-      }\n-      @Override\n-      public boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-        ExclusionStrategy strategy = Gson.this.serializationExclusionStrategy;\n-        return !strategy.shouldSkipClass(f.getType())\n-            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f));\n-      }\n-\n-      @Override\n-      public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-        ExclusionStrategy strategy = Gson.this.deserializationExclusionStrategy;\n-        return !strategy.shouldSkipClass(f.getType())\n-            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f));\n-      }\n-    };\n+    TypeAdapter.Factory reflectiveTypeAdapterFactory = new ReflectiveTypeAdapterFactory(\n+        constructorConstructor, fieldNamingPolicy, serializationExclusionStrategy,\n+        deserializationExclusionStrategy);\n \n     ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.ExclusionStrategy;\n+import com.google.gson.FieldAttributes;\n+import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n /**\n  * Type adapter that reflects over the fields and methods of a class.\n  */\n-public class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {\n+public final class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {\n   private final ConstructorConstructor constructorConstructor;\n-\n-  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n+  private final FieldNamingStrategy fieldNamingPolicy;\n+  private final ExclusionStrategy serializationExclusionStrategy;\n+  private final ExclusionStrategy deserializationExclusionStrategy;\n+\n+  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n+      FieldNamingStrategy fieldNamingPolicy, ExclusionStrategy serializationExclusionStrategy,\n+      ExclusionStrategy deserializationExclusionStrategy) {\n     this.constructorConstructor = constructorConstructor;\n-  }\n-\n-  protected boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-    return !f.isSynthetic();\n-  }\n-\n-  protected boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-    return !f.isSynthetic();\n-  }\n-\n-  protected String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n-    return f.getName();\n+    this.fieldNamingPolicy = fieldNamingPolicy;\n+    this.serializationExclusionStrategy = serializationExclusionStrategy;\n+    this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n+  }\n+\n+  public boolean serializeField(Field f) {\n+    return !serializationExclusionStrategy.shouldSkipClass(f.getType())\n+        && !serializationExclusionStrategy.shouldSkipField(new FieldAttributes(f));\n+  }\n+\n+  private boolean deserializeField(Field f) {\n+    return !deserializationExclusionStrategy.shouldSkipClass(f.getType())\n+        && !deserializationExclusionStrategy.shouldSkipField(new FieldAttributes(f));\n+  }\n+\n+  private String getFieldName(Field f) {\n+    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n+    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n   }\n \n   public <T> TypeAdapter<T> create(Gson context, final TypeToken<T> type) {\n     };\n   }\n \n-  private Map<String, BoundField> getBoundFields(\n-      Gson context, TypeToken<?> type, Class<?> raw) {\n+  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n     if (raw.isInterface()) {\n       return result;\n       Field[] fields = raw.getDeclaredFields();\n       AccessibleObject.setAccessible(fields, true);\n       for (Field field : fields) {\n-        boolean serialize = serializeField(raw, field, declaredType);\n-        boolean deserialize = deserializeField(raw, field, declaredType);\n+        boolean serialize = serializeField(field);\n+        boolean deserialize = deserializeField(field);\n         if (!serialize && !deserialize) {\n           continue;\n         }\n         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-        BoundField boundField = createBoundField(context, field, getFieldName(raw, field, declaredType),\n+        BoundField boundField = createBoundField(context, field, getFieldName(field),\n             TypeToken.get(fieldType), serialize, deserialize);\n         BoundField previous = result.put(boundField.name, boundField);\n         if (previous != null) {\n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n  */\n public class DisjunctionExclusionStrategyTest extends TestCase {\n \n-  private static final ExclusionStrategy FALSE_STRATEGY = \n+  private static final ExclusionStrategy FALSE_STRATEGY =\n       new MockExclusionStrategy(false, false);\n-  private static final ExclusionStrategy TRUE_STRATEGY = \n+  private static final ExclusionStrategy TRUE_STRATEGY =\n       new MockExclusionStrategy(true, true);\n-  \n+\n   private static final Class<?> CLAZZ = String.class;\n   private static final FieldAttributes FIELD =\n-    new FieldAttributes(CLAZZ, CLAZZ.getFields()[0]);\n+    new FieldAttributes(CLAZZ.getFields()[0]);\n \n   public void testBadInstantiation() throws Exception {\n     try {\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n     assertFalse(deserializationStrategy.shouldSkipField(f));\n     assertFalse(serializationStrategy.shouldSkipField(f));\n   }\n-  \n+\n   public void testDifferentSerializeAndDeserializeField() throws Exception {\n     FieldAttributes f = createFieldAttributes(\"explicitlyDifferentModeField\");\n     assertTrue(deserializationStrategy.shouldSkipField(f));\n     assertFalse(serializationStrategy.shouldSkipField(f));\n   }\n-  \n+\n   private static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n     Field f = MockObject.class.getField(fieldName);\n-    return new FieldAttributes(MockObject.class, f);\n+    return new FieldAttributes(f);\n   }\n-  \n+\n   @SuppressWarnings(\"unused\")\n   private static class MockObject {\n     @Expose\n \n     @Expose(serialize=false, deserialize=false)\n     public final int explicitlyHiddenField = 0;\n-    \n+\n     @Expose(serialize=true, deserialize=false)\n     public final int explicitlyDifferentModeField = 0;\n \n--- a/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n+++ b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    fieldAttributes = new FieldAttributes(Foo.class, Foo.class.getField(\"bar\"));\n+    fieldAttributes = new FieldAttributes(Foo.class.getField(\"bar\"));\n   }\n \n   public void testNullField() throws Exception {\n     try {\n-      new FieldAttributes(Foo.class, null);\n+      new FieldAttributes(null);\n       fail(\"Field parameter can not be null\");\n     } catch (NullPointerException expected) { }\n   }\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   public void testIncludeStaticNestedClassObject() throws Exception {\n \n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n   }\n \n   class InnerClass {\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n     assertFalse(strategy.shouldSkipClass(clazz));\n \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+    FieldAttributes fieldAttributes = new FieldAttributes(f);\n     assertFalse(strategy.shouldSkipField(fieldAttributes));\n   }\n \n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n     assertFalse(strategy.shouldSkipClass(clazz));\n-    \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+\n+    FieldAttributes fieldAttributes = new FieldAttributes(f);\n     assertFalse(strategy.shouldSkipField(fieldAttributes));\n   }\n \n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n     assertTrue(strategy.shouldSkipClass(clazz));\n-    \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+\n+    FieldAttributes fieldAttributes = new FieldAttributes(f);\n     assertTrue(strategy.shouldSkipField(fieldAttributes));\n   }\n ", "timestamp": 1321854150, "metainfo": ""}