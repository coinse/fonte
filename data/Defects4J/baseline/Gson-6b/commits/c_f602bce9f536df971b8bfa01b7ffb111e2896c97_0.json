{"sha": "f602bce9f536df971b8bfa01b7ffb111e2896c97", "log": "Nice documentation for TypeAdapter.", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n     }\n \n     return new TypeAdapter<T>() {\n-      @Override public T read(JsonReader reader) throws IOException {\n-        JsonElement jsonElement = Streams.parse(reader);\n+      @Override public T read(JsonReader in) throws IOException {\n+        JsonElement jsonElement = Streams.parse(in);\n         JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\n         if (labelJsonElement == null) {\n           throw new JsonParseException(\"cannot deserialize \" + baseType\n         return delegate.fromJsonTree(jsonElement);\n       }\n \n-      @Override public void write(JsonWriter writer, T value) throws IOException {\n+      @Override public void write(JsonWriter out, T value) throws IOException {\n         Class<?> srcType = value.getClass();\n         String label = subtypeToLabel.get(srcType);\n         @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n         for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {\n           clone.add(e.getKey(), e.getValue());\n         }\n-        Streams.write(clone, writer);\n+        Streams.write(clone, out);\n       }\n     };\n   }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n       return TypeAdapters.DOUBLE;\n     }\n     return new TypeAdapter<Number>() {\n-      @Override public Double read(JsonReader reader) throws IOException {\n-        if (reader.peek() == JsonToken.NULL) {\n-          reader.nextNull();\n+      @Override public Double read(JsonReader in) throws IOException {\n+        if (in.peek() == JsonToken.NULL) {\n+          in.nextNull();\n           return null;\n         }\n-        return reader.nextDouble();\n-      }\n-      @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        return in.nextDouble();\n+      }\n+      @Override public void write(JsonWriter out, Number value) throws IOException {\n         if (value == null) {\n-          writer.nullValue();\n+          out.nullValue();\n           return;\n         }\n         double doubleValue = value.doubleValue();\n         checkValidFloatingPoint(doubleValue);\n-        writer.value(value);\n+        out.value(value);\n       }\n     };\n   }\n       return TypeAdapters.FLOAT;\n     }\n     return new TypeAdapter<Number>() {\n-      @Override public Float read(JsonReader reader) throws IOException {\n-        if (reader.peek() == JsonToken.NULL) {\n-          reader.nextNull();\n+      @Override public Float read(JsonReader in) throws IOException {\n+        if (in.peek() == JsonToken.NULL) {\n+          in.nextNull();\n           return null;\n         }\n-        return (float) reader.nextDouble();\n-      }\n-      @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        return (float) in.nextDouble();\n+      }\n+      @Override public void write(JsonWriter out, Number value) throws IOException {\n         if (value == null) {\n-          writer.nullValue();\n+          out.nullValue();\n           return;\n         }\n         float floatValue = value.floatValue();\n         checkValidFloatingPoint(floatValue);\n-        writer.value(value);\n+        out.value(value);\n       }\n     };\n   }\n       return TypeAdapters.LONG;\n     }\n     return new TypeAdapter<Number>() {\n-      @Override public Number read(JsonReader reader) throws IOException {\n-        if (reader.peek() == JsonToken.NULL) {\n-          reader.nextNull();\n+      @Override public Number read(JsonReader in) throws IOException {\n+        if (in.peek() == JsonToken.NULL) {\n+          in.nextNull();\n           return null;\n         }\n-        return reader.nextLong();\n-      }\n-      @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        return in.nextLong();\n+      }\n+      @Override public void write(JsonWriter out, Number value) throws IOException {\n         if (value == null) {\n-          writer.nullValue();\n+          out.nullValue();\n           return;\n         }\n-        writer.value(value.toString());\n+        out.value(value.toString());\n       }\n     };\n   }\n       delegate = typeAdapter;\n     }\n \n-    @Override public T read(JsonReader reader) throws IOException {\n+    @Override public T read(JsonReader in) throws IOException {\n       if (delegate == null) {\n         throw new IllegalStateException();\n       }\n-      return delegate.read(reader);\n-    }\n-\n-    @Override public void write(JsonWriter writer, T value) throws IOException {\n+      return delegate.read(in);\n+    }\n+\n+    @Override public void write(JsonWriter out, T value) throws IOException {\n       if (delegate == null) {\n         throw new IllegalStateException();\n       }\n-      delegate.write(writer, value);\n+      delegate.write(out, value);\n     }\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonDeserializer.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializer.java\n  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();\n  * </pre>\n  *\n+ * <p>New applications should prefer {@link TypeAdapter}, whose streaming API\n+ * is more efficient than this interface's tree API.\n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  *\n--- a/gson/src/main/java/com/google/gson/JsonSerializer.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializer.java\n  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();\n  * </pre>\n  *\n+ * <p>New applications should prefer {@link TypeAdapter}, whose streaming API\n+ * is more efficient than this interface's tree API.\n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  *\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n     this.skipPast = skipPast;\n   }\n \n-  @Override public T read(JsonReader reader) throws IOException {\n+  @Override public T read(JsonReader in) throws IOException {\n     if (deserializer == null) {\n-      return delegate().read(reader);\n+      return delegate().read(in);\n     }\n-    JsonElement value = Streams.parse(reader);\n+    JsonElement value = Streams.parse(in);\n     if (value.isJsonNull()) {\n       return null;\n     }\n     return deserializer.deserialize(value, typeToken.getType(), gson.deserializationContext);\n   }\n \n-  @Override public void write(JsonWriter writer, T value) throws IOException {\n+  @Override public void write(JsonWriter out, T value) throws IOException {\n     if (serializer == null) {\n-      delegate().write(writer, value);\n+      delegate().write(out, value);\n       return;\n     }\n     if (value == null) {\n-      writer.nullValue();\n+      out.nullValue();\n       return;\n     }\n     JsonElement tree = serializer.serialize(value, typeToken.getType(), gson.serializationContext);\n-    Streams.write(tree,writer);\n+    Streams.write(tree, out);\n   }\n \n   private TypeAdapter<T> delegate() {\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.internal.bind.JsonTreeReader;\n-import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n import java.io.StringWriter;\n import java.io.Writer;\n \n-// TODO: nice documentation\n-\n /**\n+ * Converts between Java objects and JSON. Applications use type adapters both\n+ * for customizing types' JSON forms, and for JSON conversions.\n+ *\n+ * <h3>Defining a type's JSON form</h3>\n+ * By default Gson converts application classes to JSON using its built-in type\n+ * adapters. Change your Java objects' JSON representation by subclassing {@code\n+ * TypeAdapter} and registering the subclass with a {@code GsonBuilder}. Here's\n+ * an example of a type adapter for an (X,Y) coordinate point: <pre>   {@code\n+ *\n+ *   public class PointAdapter extends TypeAdapter<Point> {\n+ *     public Point read(JsonReader reader) throws IOException {\n+ *       if (reader.peek() == JsonToken.NULL) {\n+ *         reader.nextNull();\n+ *         return null;\n+ *       }\n+ *       String xy = reader.nextString();\n+ *       String[] parts = xy.split(\",\");\n+ *       int x = Integer.parseInt(parts[0]);\n+ *       int y = Integer.parseInt(parts[1]);\n+ *       return new Point(x, y);\n+ *     }\n+ *     public void write(JsonWriter writer, Point value) throws IOException {\n+ *       if (value == null) {\n+ *         writer.nullValue();\n+ *         return;\n+ *       }\n+ *       String xy = value.getX() + \",\" + value.getY();\n+ *       writer.value(xy);\n+ *     }\n+ *   }}</pre>\n+ * With this type adapter installed, Gson will convert {@code Points} to JSON as\n+ * strings like {@code \"5,8\"} rather than objects like {@code {\"x\":5,\"y\":8}}. In\n+ * this case the type adapter binds a rich Java class to a compact JSON value.\n+ *\n+ * <p>The {@link #read(JsonReader) read()} method must read exactly one value\n+ * and {@link #write(JsonWriter,Object) write()} must write exactly one value.\n+ * For primitive types this is means readers should make exactly one call to\n+ * <code>next<i>Type</i>()</code> and writers should make exactly one call to\n+ * one of <code>value()</code> or <code>nullValue()</code>. For composite types,\n+ * type adapters should start with a call to <code>begin<i>Type</i>()</code>,\n+ * convert the entire contents of the object or array, and finish with a call\n+ * to <code>end<i>Type</i>()</code>. Failing to convert a value or converting\n+ * too many values will disrupt the cadence of the caller and may cause the\n+ * application to crash.\n+ *\n+ * <p>Type adapters should be prepared to read null from the stream and write it\n+ * to the stream. If your {@code Gson} instance has been configured to {@link\n+ * GsonBuilder#serializeNulls()}, these will be written to the final document.\n+ * Otherwise the value (and the corresponding name when writing to a JSON\n+ * object) will be omitted automatically. In either case your type adapter must\n+ * handle null.\n+ *\n+ * <p>To use a custom type adapter with Gson, you must <i>register</i> it with a\n+ * {@link GsonBuilder}: <pre>   {@code\n+ *\n+ *   GsonBuilder builder = new GsonBuilder();\n+ *   builder.registerTypeAdapter(Point.class, new PointAdapter());\n+ *   ...\n+ *   Gson gson = builder.create();\n+ * }</pre>\n+ *\n+ * <h3>JSON Conversion</h3>\n+ * <p>Retrieve a type adapter from a {@code Gson} instance to deserialize a JSON\n+ * document into a Java object: <pre>   {@code\n+ *\n+ *   String json = \"{'origin':'0,0','points':['1,2','3,4']}\";\n+ *   TypeAdapter<Graph> graphAdapter = gson.getAdapter(Graph.class);\n+ *   Graph graph = graphAdapter.fromJson(json);\n+ * }</pre>\n+ * ...or serialize a Java object to a JSON document: <pre>   {@code\n+ *\n+ *   Graph graph = new Graph(...);\n+ *   TypeAdapter<Graph> graphAdapter = gson.getAdapter(Graph.class);\n+ *   String json = graphAdapter.toJson(graph);\n+ * }</pre>\n+ *\n+ * <p>Type adapters are <strong>type-specific</strong>. For example, a {@code\n+ * TypeAdapter<Date>} can convert {@code Date} instances to JSON and JSON to\n+ * instances of {@code Date}, but cannot convert any other types.\n  *\n  * @since 2.1\n  */\n public abstract class TypeAdapter<T> {\n-  public abstract T read(JsonReader reader) throws IOException;\n-  public abstract void write(JsonWriter writer, T value) throws IOException;\n-\n+\n+  /**\n+   * Writes one JSON value (an array, object, string, number, boolean or null)\n+   * for {@code value}.\n+   *\n+   * @param value the Java object to write. May be null.\n+   */\n+  public abstract void write(JsonWriter out, T value) throws IOException;\n+\n+  /**\n+   * Converts {@code value} to a JSON document and writes it to {@code out}.\n+   * Unlike Gson's similar {@link Gson#toJson(JsonElement, Appendable) toJson}\n+   * method, this write is strict. Create a {@link\n+   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call\n+   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient\n+   * writing.\n+   *\n+   * @param value the Java object to convert. May be null.\n+   */\n+  public final void toJson(Writer out, T value) throws IOException {\n+    JsonWriter writer = new JsonWriter(out);\n+    write(writer, value);\n+  }\n+\n+  /**\n+   * Converts {@code value} to a JSON document. Unlike Gson's similar {@link\n+   * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link\n+   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call\n+   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient\n+   * writing.\n+   *\n+   * @param value the Java object to convert. May be null.\n+   */\n   public final String toJson(T value) throws IOException {\n     StringWriter stringWriter = new StringWriter();\n     toJson(stringWriter, value);\n     return stringWriter.toString();\n   }\n \n-  public final void toJson(Writer out, T value) throws IOException {\n-    JsonWriter writer = new JsonWriter(out);\n-    write(writer, value);\n-  }\n-\n-  public final T fromJson(String json) throws IOException {\n-    return fromJson(new StringReader(json));\n-  }\n-\n-  public final T fromJson(Reader in) throws IOException {\n-    JsonReader reader = new JsonReader(in);\n-    reader.setLenient(true);\n-    return read(reader);\n-  }\n-\n-  public JsonElement toJsonTree(T src) {\n+  /**\n+   * Converts {@code value} to a JSON tree.\n+   *\n+   * @param value the Java object to convert. May be null.\n+   * @return the converted JSON tree. May be {@link JsonNull}.\n+   */\n+  public JsonElement toJsonTree(T value) {\n     try {\n       JsonElementWriter jsonWriter = new JsonElementWriter();\n       jsonWriter.setLenient(true);\n-      write(jsonWriter, src);\n+      write(jsonWriter, value);\n       return jsonWriter.get();\n     } catch (IOException e) {\n       throw new JsonIOException(e);\n     }\n   }\n \n-  public T fromJsonTree(JsonElement json) {\n+  /**\n+   * Reads one JSON value (an array, object, string, number, boolean or null)\n+   * and converts it to a Java object. Returns the converted object.\n+   *\n+   * @return the converted Java object. May be null.\n+   */\n+  public abstract T read(JsonReader in) throws IOException;\n+\n+  /**\n+   * Converts the JSON document in {@code in} to a Java object. Unlike Gson's\n+   * similar {@link Gson#fromJson(java.io.Reader, Class) fromJson} method, this\n+   * read is strict. Create a {@link JsonReader#setLenient(boolean) lenient}\n+   * {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n+   *\n+   * @return the converted Java object. May be null.\n+   */\n+  public final T fromJson(Reader in) throws IOException {\n+    JsonReader reader = new JsonReader(in);\n+    reader.setLenient(true); // TODO: non-lenient?\n+    return read(reader);\n+  }\n+\n+  /**\n+   * Converts the JSON document in {@code json} to a Java object. Unlike Gson's\n+   * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is\n+   * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code\n+   * JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n+   *\n+   * @return the converted Java object. May be null.\n+   */\n+  public final T fromJson(String json) throws IOException {\n+    return fromJson(new StringReader(json));\n+  }\n+\n+  /**\n+   * Converts {@code jsonTree} to a Java object.\n+   *\n+   * @param jsonTree the Java object to convert. May be {@link JsonNull}.\n+   */\n+  public T fromJsonTree(JsonElement jsonTree) {\n     try {\n-      JsonReader jsonReader = new JsonTreeReader(json);\n+      JsonReader jsonReader = new JsonTreeReader(jsonTree);\n       jsonReader.setLenient(true);\n       return read(jsonReader);\n     } catch (IOException e) {\n   }\n \n   /**\n+   * Creates type adapters for set of related types. Type adapter factories are\n+   * most useful when several types share similar structure in their JSON form.\n+   *\n+   * <h3>Example: Converting enums to lowercase</h3>\n+   * In this example, we implement a factory that creates type adapters for all\n+   * enums. The type adapters will write enums in lowercase, despite the fact\n+   * that they're defined in {@code CONSTANT_CASE} in the corresponding Java\n+   * model: <pre>   {@code\n+   *\n+   *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapter.Factory {\n+   *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+   *       Class<T> rawType = (Class<T>) type.getRawType();\n+   *       if (!rawType.isEnum()) {\n+   *         return null;\n+   *       }\n+   *\n+   *       final Map<String, T> lowercaseToConstant = new HashMap<String, T>();\n+   *       for (T constant : rawType.getEnumConstants()) {\n+   *         lowercaseToConstant.put(toLowercase(constant), constant);\n+   *       }\n+   *\n+   *       return new TypeAdapter<T>() {\n+   *         public void write(JsonWriter out, T value) throws IOException {\n+   *           if (value == null) {\n+   *             out.nullValue();\n+   *           } else {\n+   *             out.value(toLowercase(value));\n+   *           }\n+   *         }\n+   *\n+   *         public T read(JsonReader reader) throws IOException {\n+   *           if (reader.peek() == JsonToken.NULL) {\n+   *             reader.nextNull();\n+   *             return null;\n+   *           } else {\n+   *             return lowercaseToConstant.get(reader.nextString());\n+   *           }\n+   *         }\n+   *       };\n+   *     }\n+   *\n+   *     private String toLowercase(Object o) {\n+   *       return o.toString().toLowerCase(Locale.US);\n+   *     }\n+   *   }\n+   * }</pre>\n+   *\n+   * <p>Type adapter factories select which types they provide type adapters\n+   * for. If a factory cannot support a given type, it must return null when\n+   * that type is passed to {@link #create}. Factories should expect {@code\n+   * create()} to be called on them for many types and should return null for\n+   * most of those types. In the above example the factory returns null for\n+   * calls to {@code create()} where {@code type} is not an enum.\n+   *\n+   * <p>A factory is typically called once per type, but the returned type\n+   * adapter may be used many times. It is most efficient to do expensive work\n+   * like reflection in {@code create()} so that the type adapter's {@code\n+   * read()} and {@code write()} methods can be very fast. In this example the\n+   * mapping from lowercase name to enum value is computed eagerly.\n+   *\n+   * <p>As with type adapters, factories must be <i>registered</i> with a {@link\n+   * GsonBuilder} for them to take effect: <pre>   {@code\n+   *\n+   *  GsonBuilder builder = new GsonBuilder();\n+   *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\n+   *  ...\n+   *  Gson gson = builder.create();\n+   * }</pre>\n+   * If multiple factories support the same type, the factory registered earlier\n+   * takes precedence.\n+   *\n+   * <h3>Example: composing other type adapters</h3>\n+   * In this example we implement a factory for Guava's {@code Multiset}\n+   * collection type. The factory can be used to create type adapters for\n+   * multisets of any element type: the type adapter for {@code\n+   * Multiset<String>} is different from the type adapter for {@code\n+   * Multiset<URL>}.\n+   *\n+   * <p>The type adapter <i>delegates</i> to another type adapter for the\n+   * multiset elements. It figures out the element type by reflecting on the\n+   * multiset's type token. A {@code Gson} is passed in to {@code create} for\n+   * just this purpose: <pre>   {@code\n+   *\n+   *   public class MultisetTypeAdapterFactory implements TypeAdapter.Factory {\n+   *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n+   *       Type type = typeToken.getType();\n+   *       if (typeToken.getRawType() != Multiset.class\n+   *           || !(type instanceof ParameterizedType)) {\n+   *         return null;\n+   *       }\n+   *\n+   *       Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n+   *       TypeAdapter<?> elementAdapter = gson.getAdapter(TypeToken.get(elementType));\n+   *       return (TypeAdapter<T>) newMultisetAdapter(elementAdapter);\n+   *     }\n+   *\n+   *     private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(\n+   *         final TypeAdapter<E> elementAdapter) {\n+   *       return new TypeAdapter<Multiset<E>>() {\n+   *         public void write(JsonWriter out, Multiset<E> value) throws IOException {\n+   *           if (value == null) {\n+   *             out.nullValue();\n+   *             return;\n+   *           }\n+   *\n+   *           out.beginArray();\n+   *           for (Multiset.Entry<E> entry : value.entrySet()) {\n+   *             out.value(entry.getCount());\n+   *             elementAdapter.write(out, entry.getElement());\n+   *           }\n+   *           out.endArray();\n+   *         }\n+   *\n+   *         public Multiset<E> read(JsonReader in) throws IOException {\n+   *           if (in.peek() == JsonToken.NULL) {\n+   *             in.nextNull();\n+   *             return null;\n+   *           }\n+   *\n+   *           Multiset<E> result = LinkedHashMultiset.create();\n+   *           in.beginArray();\n+   *           while (in.hasNext()) {\n+   *             int count = in.nextInt();\n+   *             E element = elementAdapter.read(in);\n+   *             result.add(element, count);\n+   *           }\n+   *           in.endArray();\n+   *           return result;\n+   *         }\n+   *       };\n+   *     }\n+   *   }\n+   * }</pre>\n+   * Delegating from one type adapter to another is extremely powerful; it's\n+   * the foundation of how Gson converts Java objects and collections. Whenever\n+   * possible your factory should retrieve its delegate type adapter in the\n+   * {@code create()} method; this ensures potentially-expensive type adapter\n+   * creation happens only once.\n+   *\n    * @since 2.1\n    */\n   public interface Factory {\n+\n+    /**\n+     * Returns a type adapter for {@code type}, or null if this factory doesn't\n+     * support {@code type}.\n+     */\n     <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n       /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n       private TypeAdapter<T> delegate;\n \n-      @Override public T read(JsonReader reader) throws IOException {\n+      @Override public T read(JsonReader in) throws IOException {\n         if (skipDeserialize) {\n-          reader.skipValue();\n+          in.skipValue();\n           return null;\n         }\n-        return delegate().read(reader);\n-      }\n-\n-      @Override public void write(JsonWriter writer, T value) throws IOException {\n+        return delegate().read(in);\n+      }\n+\n+      @Override public void write(JsonWriter out, T value) throws IOException {\n         if (skipSerialize) {\n-          writer.nullValue();\n+          out.nullValue();\n           return;\n         }\n-        delegate().write(writer, value);\n+        delegate().write(out, value);\n       }\n \n       private TypeAdapter<T> delegate() {\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n     this.componentType = componentType;\n   }\n \n-  public Object read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  public Object read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n \n     List<E> list = new ArrayList<E>();\n-    reader.beginArray();\n-    while (reader.hasNext()) {\n-      E instance = componentTypeAdapter.read(reader);\n+    in.beginArray();\n+    while (in.hasNext()) {\n+      E instance = componentTypeAdapter.read(in);\n       list.add(instance);\n     }\n-    reader.endArray();\n+    in.endArray();\n     Object array = Array.newInstance(componentType, list.size());\n     for (int i = 0; i < list.size(); i++) {\n       Array.set(array, i, list.get(i));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n-  @Override public void write(JsonWriter writer, Object array) throws IOException {\n+  @Override public void write(JsonWriter out, Object array) throws IOException {\n     if (array == null) {\n-      writer.nullValue();\n+      out.nullValue();\n       return;\n     }\n \n-    writer.beginArray();\n+    out.beginArray();\n     for (int i = 0, length = Array.getLength(array); i < length; i++) {\n       E value = (E) Array.get(array, i);\n-      componentTypeAdapter.write(writer, value);\n+      componentTypeAdapter.write(out, value);\n     }\n-    writer.endArray();\n+    out.endArray();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n public final class BigDecimalTypeAdapter extends TypeAdapter<BigDecimal> {\n \n   @Override\n-  public BigDecimal read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  public BigDecimal read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n     try {\n-      return new BigDecimal(reader.nextString());\n+      return new BigDecimal(in.nextString());\n     } catch (NumberFormatException e) {\n       throw new JsonSyntaxException(e);\n     }\n   }\n \n   @Override\n-  public void write(JsonWriter writer, BigDecimal value) throws IOException {\n-    writer.value(value);\n+  public void write(JsonWriter out, BigDecimal value) throws IOException {\n+    out.value(value);\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n public final class BigIntegerTypeAdapter extends TypeAdapter<BigInteger> {\n \n   @Override\n-  public BigInteger read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  public BigInteger read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n     try {\n-      return new BigInteger(reader.nextString());\n+      return new BigInteger(in.nextString());\n     } catch (NumberFormatException e) {\n       throw new JsonSyntaxException(e);\n     }\n   }\n \n   @Override\n-  public void write(JsonWriter writer, BigInteger value) throws IOException {\n-    writer.value(value);\n+  public void write(JsonWriter out, BigInteger value) throws IOException {\n+    out.value(value);\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n       this.constructor = constructor;\n     }\n \n-    public Collection<E> read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Collection<E> read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n \n       Collection<E> collection = constructor.construct();\n-      reader.beginArray();\n-      while (reader.hasNext()) {\n-        E instance = elementTypeAdapter.read(reader);\n+      in.beginArray();\n+      while (in.hasNext()) {\n+        E instance = elementTypeAdapter.read(in);\n         collection.add(instance);\n       }\n-      reader.endArray();\n+      in.endArray();\n       return collection;\n     }\n \n-    public void write(JsonWriter writer, Collection<E> collection) throws IOException {\n+    public void write(JsonWriter out, Collection<E> collection) throws IOException {\n       if (collection == null) {\n-        writer.nullValue(); // TODO: better policy here?\n+        out.nullValue(); // TODO: better policy here?\n         return;\n       }\n \n-      writer.beginArray();\n+      out.beginArray();\n       for (E element : collection) {\n-        elementTypeAdapter.write(writer, element);\n+        elementTypeAdapter.write(out, element);\n       }\n-      writer.endArray();\n+      out.endArray();\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n     return iso8601Format;\n   }\n \n-  @Override public Date read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  @Override public Date read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n-    return deserializeToDate(reader.nextString());\n+    return deserializeToDate(in.nextString());\n   }\n \n   private synchronized Date deserializeToDate(String json) {\n     }\n   }\n \n-  @Override public synchronized void write(JsonWriter writer, Date value) throws IOException {\n+  @Override public synchronized void write(JsonWriter out, Date value) throws IOException {\n     if (value == null) {\n-      writer.nullValue();\n+      out.nullValue();\n       return;\n     }\n     String dateFormatAsString = enUsFormat.format(value);\n-    writer.value(dateFormatAsString);\n+    out.value(dateFormatAsString);\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n       this.constructor = constructor;\n     }\n \n-    public Map<K, V> read(JsonReader reader) throws IOException {\n-      JsonToken peek = reader.peek();\n+    public Map<K, V> read(JsonReader in) throws IOException {\n+      JsonToken peek = in.peek();\n       if (peek == JsonToken.NULL) {\n-        reader.nextNull();\n+        in.nextNull();\n         return null;\n       }\n \n       Map<K, V> map = constructor.construct();\n \n       if (peek == JsonToken.BEGIN_ARRAY) {\n-        reader.beginArray();\n-        while (reader.hasNext()) {\n-          reader.beginArray(); // entry array\n-          K key = keyTypeAdapter.read(reader);\n-          V value = valueTypeAdapter.read(reader);\n+        in.beginArray();\n+        while (in.hasNext()) {\n+          in.beginArray(); // entry array\n+          K key = keyTypeAdapter.read(in);\n+          V value = valueTypeAdapter.read(in);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n           }\n-          reader.endArray();\n-        }\n-        reader.endArray();\n+          in.endArray();\n+        }\n+        in.endArray();\n       } else {\n-        reader.beginObject();\n-        while (reader.hasNext()) {\n-          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(reader);\n-          K key = keyTypeAdapter.read(reader);\n-          V value = valueTypeAdapter.read(reader);\n+        in.beginObject();\n+        while (in.hasNext()) {\n+          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n+          K key = keyTypeAdapter.read(in);\n+          V value = valueTypeAdapter.read(in);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n           }\n         }\n-        reader.endObject();\n+        in.endObject();\n       }\n       return map;\n     }\n \n-    public void write(JsonWriter writer, Map<K, V> map) throws IOException {\n+    public void write(JsonWriter out, Map<K, V> map) throws IOException {\n       if (map == null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n       }\n \n       if (!complexMapKeySerialization) {\n-        writer.beginObject();\n+        out.beginObject();\n         for (Map.Entry<K, V> entry : map.entrySet()) {\n-          writer.name(String.valueOf(entry.getKey()));\n-          valueTypeAdapter.write(writer, entry.getValue());\n-        }\n-        writer.endObject();\n+          out.name(String.valueOf(entry.getKey()));\n+          valueTypeAdapter.write(out, entry.getValue());\n+        }\n+        out.endObject();\n         return;\n       }\n \n       }\n \n       if (hasComplexKeys) {\n-        writer.beginArray();\n+        out.beginArray();\n         for (int i = 0; i < keys.size(); i++) {\n-          writer.beginArray(); // entry array\n-          Streams.write(keys.get(i), writer);\n-          valueTypeAdapter.write(writer, values.get(i));\n-          writer.endArray();\n-        }\n-        writer.endArray();\n+          out.beginArray(); // entry array\n+          Streams.write(keys.get(i), out);\n+          valueTypeAdapter.write(out, values.get(i));\n+          out.endArray();\n+        }\n+        out.endArray();\n       } else {\n-        writer.beginObject();\n+        out.beginObject();\n         for (int i = 0; i < keys.size(); i++) {\n           JsonElement keyElement = keys.get(i);\n-          writer.name(keyToString(keyElement));\n-          valueTypeAdapter.write(writer, values.get(i));\n-        }\n-        writer.endObject();\n+          out.name(keyToString(keyElement));\n+          valueTypeAdapter.write(out, values.get(i));\n+        }\n+        out.endObject();\n       }\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n     this.gson = gson;\n   }\n \n-  @Override public Object read(JsonReader reader) throws IOException {\n-    JsonToken token = reader.peek();\n+  @Override public Object read(JsonReader in) throws IOException {\n+    JsonToken token = in.peek();\n     switch (token) {\n     case BEGIN_ARRAY:\n       List<Object> list = new ArrayList<Object>();\n-      reader.beginArray();\n-      while (reader.hasNext()) {\n-        list.add(read(reader));\n+      in.beginArray();\n+      while (in.hasNext()) {\n+        list.add(read(in));\n       }\n-      reader.endArray();\n+      in.endArray();\n       return list;\n \n     case BEGIN_OBJECT:\n       Map<String, Object> map = new LinkedHashMap<String, Object>();\n-      reader.beginObject();\n-      while (reader.hasNext()) {\n-        map.put(reader.nextName(), read(reader));\n+      in.beginObject();\n+      while (in.hasNext()) {\n+        map.put(in.nextName(), read(in));\n       }\n-      reader.endObject();\n+      in.endObject();\n       return map;\n \n     case STRING:\n-      return reader.nextString();\n+      return in.nextString();\n \n     case NUMBER:\n-      return reader.nextDouble();\n+      return in.nextDouble();\n \n     case BOOLEAN:\n-      return reader.nextBoolean();\n+      return in.nextBoolean();\n \n     case NULL:\n-      reader.nextNull();\n+      in.nextNull();\n       return null;\n \n     }\n   }\n \n   @SuppressWarnings(\"unchecked\")\n-  @Override public void write(JsonWriter writer, Object value) throws IOException {\n+  @Override public void write(JsonWriter out, Object value) throws IOException {\n     if (value == null) {\n-      writer.nullValue();\n+      out.nullValue();\n       return;\n     }\n \n     TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());\n     if (typeAdapter instanceof ObjectTypeAdapter) {\n-      writer.beginObject();\n-      writer.endObject();\n+      out.beginObject();\n+      out.endObject();\n       return;\n     }\n \n-    typeAdapter.write(writer, value);\n+    typeAdapter.write(out, value);\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n     }\n \n     @Override\n-    public T read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public T read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n \n       // TODO: null out the other fields?\n \n       try {\n-        reader.beginObject();\n-        while (reader.hasNext()) {\n-          String name = reader.nextName();\n+        in.beginObject();\n+        while (in.hasNext()) {\n+          String name = in.nextName();\n           BoundField field = boundFields.get(name);\n           if (field == null || !field.deserialized) {\n             // TODO: define a better policy\n-            reader.skipValue();\n+            in.skipValue();\n           } else {\n-            field.read(reader, instance);\n+            field.read(in, instance);\n           }\n         }\n       } catch (IllegalStateException e) {\n       } catch (IllegalAccessException e) {\n         throw new AssertionError(e);\n       }\n-      reader.endObject();\n+      in.endObject();\n       return instance;\n     }\n \n     @Override\n-    public void write(JsonWriter writer, T value) throws IOException {\n+    public void write(JsonWriter out, T value) throws IOException {\n       if (value == null) {\n-        writer.nullValue(); // TODO: better policy here?\n+        out.nullValue(); // TODO: better policy here?\n         return;\n       }\n \n-      writer.beginObject();\n+      out.beginObject();\n       try {\n         for (BoundField boundField : boundFields.values()) {\n           if (boundField.serialized) {\n-            writer.name(boundField.name);\n-            boundField.write(writer, value);\n+            out.name(boundField.name);\n+            boundField.write(out, value);\n           }\n         }\n       } catch (IllegalAccessException e) {\n         throw new AssertionError();\n       }\n-      writer.endObject();\n+      out.endObject();\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n   private final DateFormat format = new SimpleDateFormat(\"MMM d, yyyy\");\n \n   @Override\n-  public synchronized java.sql.Date read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  public synchronized java.sql.Date read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n     try {\n-      final long utilDate = format.parse(reader.nextString()).getTime();\n+      final long utilDate = format.parse(in.nextString()).getTime();\n       return new java.sql.Date(utilDate);\n     } catch (ParseException e) {\n       throw new JsonSyntaxException(e);\n   }\n \n   @Override\n-  public synchronized void write(JsonWriter writer, java.sql.Date value) throws IOException {\n-    writer.value(value == null ? null : format.format(value));\n+  public synchronized void write(JsonWriter out, java.sql.Date value) throws IOException {\n+    out.value(value == null ? null : format.format(value));\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n \n   private final DateFormat format = new SimpleDateFormat(\"hh:mm:ss a\");\n \n-  @Override public synchronized Time read(JsonReader reader) throws IOException {\n-    if (reader.peek() == JsonToken.NULL) {\n-      reader.nextNull();\n+  @Override public synchronized Time read(JsonReader in) throws IOException {\n+    if (in.peek() == JsonToken.NULL) {\n+      in.nextNull();\n       return null;\n     }\n     try {\n-      Date date = format.parse(reader.nextString());\n+      Date date = format.parse(in.nextString());\n       return new Time(date.getTime());\n     } catch (ParseException e) {\n       throw new JsonSyntaxException(e);\n     }\n   }\n \n-  @Override public synchronized void write(JsonWriter writer, Time value) throws IOException {\n-    writer.value(value == null ? null : format.format(value));\n+  @Override public synchronized void write(JsonWriter out, Time value) throws IOException {\n+    out.value(value == null ? null : format.format(value));\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n   }\n \n   @Override\n-  public T read(JsonReader reader) throws IOException {\n-    return delegate.read(reader);\n+  public T read(JsonReader in) throws IOException {\n+    return delegate.read(in);\n   }\n \n   @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   @Override\n-  public void write(JsonWriter writer, T value) throws IOException {\n+  public void write(JsonWriter out, T value) throws IOException {\n     // Order of preference for choosing type adapters\n     // First preference: a type adapter registered for the runtime type\n     // Second preference: a type adapter registered for the declared type\n         chosen = runtimeTypeAdapter;\n       }\n     }\n-    chosen.write(writer, value);\n+    chosen.write(out, value);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n   private TypeAdapters() {}\n \n   public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n-    public BitSet read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public BitSet read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n \n       BitSet bitset = new BitSet();\n-      reader.beginArray();\n+      in.beginArray();\n       int i = 0;\n-      JsonToken tokenType = reader.peek();\n+      JsonToken tokenType = in.peek();\n       while (tokenType != JsonToken.END_ARRAY) {\n         boolean set;\n         switch (tokenType) {\n         case NUMBER:\n-          set = reader.nextInt() != 0;\n+          set = in.nextInt() != 0;\n           break;\n         case BOOLEAN:\n-          set = reader.nextBoolean();\n+          set = in.nextBoolean();\n           break;\n         case STRING:\n-          String stringValue = reader.nextString();\n+          String stringValue = in.nextString();\n           try {\n             set = Integer.parseInt(stringValue) != 0;\n           } catch (NumberFormatException e) {\n           bitset.set(i);\n         }\n         ++i;\n-        tokenType = reader.peek();\n-      }\n-      reader.endArray();\n+        tokenType = in.peek();\n+      }\n+      in.endArray();\n       return bitset;\n     }\n \n-    public void write(JsonWriter writer, BitSet src) throws IOException {\n+    public void write(JsonWriter out, BitSet src) throws IOException {\n       if (src == null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n       }\n \n-      writer.beginArray();\n+      out.beginArray();\n       for (int i = 0; i < src.length(); i++) {\n         int value = (src.get(i)) ? 1 : 0;\n-        writer.value(value);\n-      }\n-      writer.endArray();\n+        out.value(value);\n+      }\n+      out.endArray();\n     }\n   };\n \n \n   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n     @Override\n-    public Boolean read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      } else if (reader.peek() == JsonToken.STRING) {\n+    public Boolean read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      } else if (in.peek() == JsonToken.STRING) {\n         // support strings for compatibility with GSON 1.7\n-        return Boolean.parseBoolean(reader.nextString());\n-      }\n-      return reader.nextBoolean();\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Boolean value) throws IOException {\n+        return Boolean.parseBoolean(in.nextString());\n+      }\n+      return in.nextBoolean();\n+    }\n+    @Override\n+    public void write(JsonWriter out, Boolean value) throws IOException {\n       if (value == null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n       }\n-      writer.value(value);\n+      out.value(value);\n     }\n   };\n \n    * otherwise permitted.\n    */\n   public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n-    @Override public Boolean read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return Boolean.valueOf(reader.nextString());\n-    }\n-\n-    @Override public void write(JsonWriter writer, Boolean value) throws IOException {\n-      writer.value(value == null ? \"null\" : value.toString());\n+    @Override public Boolean read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return Boolean.valueOf(in.nextString());\n+    }\n+\n+    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n+      out.value(value == null ? \"null\" : value.toString());\n     }\n   };\n \n \n   public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n       try {\n-        int intValue = reader.nextInt();\n+        int intValue = in.nextInt();\n         return (byte) intValue;\n       } catch (NumberFormatException e) {\n         throw new JsonSyntaxException(e);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n \n   public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n       try {\n-        return (short) reader.nextInt();\n+        return (short) in.nextInt();\n       } catch (NumberFormatException e) {\n         throw new JsonSyntaxException(e);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n \n   public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n       try {\n-        return reader.nextInt();\n+        return in.nextInt();\n       } catch (NumberFormatException e) {\n         throw new JsonSyntaxException(e);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n \n   public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n       try {\n-        return reader.nextLong();\n+        return in.nextLong();\n       } catch (NumberFormatException e) {\n         throw new JsonSyntaxException(e);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n   public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return (float) reader.nextDouble();\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return (float) in.nextDouble();\n+    }\n+    @Override\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n   public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return reader.nextDouble();\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public Number read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return in.nextDouble();\n+    }\n+    @Override\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n   public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n     @Override\n-    public Number read(JsonReader reader) throws IOException {\n-      JsonToken jsonToken = reader.peek();\n+    public Number read(JsonReader in) throws IOException {\n+      JsonToken jsonToken = in.peek();\n       switch (jsonToken) {\n       case NULL:\n-        reader.nextNull();\n+        in.nextNull();\n         return null;\n       case NUMBER:\n-        return new LazilyParsedNumber(reader.nextString());\n+        return new LazilyParsedNumber(in.nextString());\n       default:\n         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Number value) throws IOException {\n-      writer.value(value);\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n \n   public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n     @Override\n-    public Character read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return reader.nextString().charAt(0);\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Character value) throws IOException {\n-      writer.value(value == null ? null : String.valueOf(value));\n+    public Character read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return in.nextString().charAt(0);\n+    }\n+    @Override\n+    public void write(JsonWriter out, Character value) throws IOException {\n+      out.value(value == null ? null : String.valueOf(value));\n     }\n   };\n \n \n   public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n     @Override\n-    public String read(JsonReader reader) throws IOException {\n-      JsonToken peek = reader.peek();\n+    public String read(JsonReader in) throws IOException {\n+      JsonToken peek = in.peek();\n       if (peek == JsonToken.NULL) {\n-        reader.nextNull();\n+        in.nextNull();\n         return null;\n       }\n       /* coerce booleans to strings for backwards compatibility */\n       if (peek == JsonToken.BOOLEAN) {\n-        return Boolean.toString(reader.nextBoolean());\n-      }\n-      return reader.nextString();\n-    }\n-    @Override\n-    public void write(JsonWriter writer, String value) throws IOException {\n-      writer.value(value);\n+        return Boolean.toString(in.nextBoolean());\n+      }\n+      return in.nextString();\n+    }\n+    @Override\n+    public void write(JsonWriter out, String value) throws IOException {\n+      out.value(value);\n     }\n   };\n \n \n   public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n     @Override\n-    public StringBuilder read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return new StringBuilder(reader.nextString());\n-    }\n-    @Override\n-    public void write(JsonWriter writer, StringBuilder value) throws IOException {\n-      writer.value(value == null ? null : value.toString());\n+    public StringBuilder read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return new StringBuilder(in.nextString());\n+    }\n+    @Override\n+    public void write(JsonWriter out, StringBuilder value) throws IOException {\n+      out.value(value == null ? null : value.toString());\n     }\n   };\n \n \n   public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n     @Override\n-    public StringBuffer read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return new StringBuffer(reader.nextString());\n-    }\n-    @Override\n-    public void write(JsonWriter writer, StringBuffer value) throws IOException {\n-      writer.value(value == null ? null : value.toString());\n+    public StringBuffer read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return new StringBuffer(in.nextString());\n+    }\n+    @Override\n+    public void write(JsonWriter out, StringBuffer value) throws IOException {\n+      out.value(value == null ? null : value.toString());\n     }\n   };\n \n \n   public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n     @Override\n-    public URL read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      String nextString = reader.nextString();\n+    public URL read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      String nextString = in.nextString();\n       return \"null\".equals(nextString) ? null : new URL(nextString);\n     }\n     @Override\n-    public void write(JsonWriter writer, URL value) throws IOException {\n-      writer.value(value == null ? null : value.toExternalForm());\n+    public void write(JsonWriter out, URL value) throws IOException {\n+      out.value(value == null ? null : value.toExternalForm());\n     }\n   };\n \n \n   public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n     @Override\n-    public URI read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public URI read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return null;\n       }\n       try {\n-        String nextString = reader.nextString();\n+        String nextString = in.nextString();\n         return \"null\".equals(nextString) ? null : new URI(nextString);\n       } catch (URISyntaxException e) {\n         throw new JsonIOException(e);\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, URI value) throws IOException {\n-      writer.value(value == null ? null : value.toASCIIString());\n+    public void write(JsonWriter out, URI value) throws IOException {\n+      out.value(value == null ? null : value.toASCIIString());\n     }\n   };\n \n \n   public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n     @Override\n-    public InetAddress read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return InetAddress.getByName(reader.nextString());\n-    }\n-    @Override\n-    public void write(JsonWriter writer, InetAddress value) throws IOException {\n-      writer.value(value == null ? null : value.getHostAddress());\n+    public InetAddress read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return InetAddress.getByName(in.nextString());\n+    }\n+    @Override\n+    public void write(JsonWriter out, InetAddress value) throws IOException {\n+      out.value(value == null ? null : value.getHostAddress());\n     }\n   };\n \n \n   public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n     @Override\n-    public UUID read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return java.util.UUID.fromString(reader.nextString());\n-    }\n-    @Override\n-    public void write(JsonWriter writer, UUID value) throws IOException {\n-      writer.value(value == null ? null : value.toString());\n+    public UUID read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return java.util.UUID.fromString(in.nextString());\n+    }\n+    @Override\n+    public void write(JsonWriter out, UUID value) throws IOException {\n+      out.value(value == null ? null : value.toString());\n     }\n   };\n \n \n       final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n       return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n-        @Override public Timestamp read(JsonReader reader) throws IOException {\n-          Date date = dateTypeAdapter.read(reader);\n+        @Override public Timestamp read(JsonReader in) throws IOException {\n+          Date date = dateTypeAdapter.read(in);\n           return date != null ? new Timestamp(date.getTime()) : null;\n         }\n \n-        @Override public void write(JsonWriter writer, Timestamp value) throws IOException {\n-          dateTypeAdapter.write(writer, value);\n+        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n+          dateTypeAdapter.write(out, value);\n         }\n       };\n     }\n     private static final String SECOND = \"second\";\n \n     @Override\n-    public Calendar read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n+    public Calendar read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n         return  null;\n       }\n-      reader.beginObject();\n+      in.beginObject();\n       int year = 0;\n       int month = 0;\n       int dayOfMonth = 0;\n       int hourOfDay = 0;\n       int minute = 0;\n       int second = 0;\n-      while (reader.peek() != JsonToken.END_OBJECT) {\n-        String name = reader.nextName();\n-        int value = reader.nextInt();\n+      while (in.peek() != JsonToken.END_OBJECT) {\n+        String name = in.nextName();\n+        int value = in.nextInt();\n         if (YEAR.equals(name)) {\n           year = value;\n         } else if (MONTH.equals(name)) {\n           second = value;\n         }\n       }\n-      reader.endObject();\n+      in.endObject();\n       return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n     }\n \n     @Override\n-    public void write(JsonWriter writer, Calendar value) throws IOException {\n+    public void write(JsonWriter out, Calendar value) throws IOException {\n       if (value == null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n       }\n-      writer.beginObject();\n-      writer.name(YEAR);\n-      writer.value(value.get(Calendar.YEAR));\n-      writer.name(MONTH);\n-      writer.value(value.get(Calendar.MONTH));\n-      writer.name(DAY_OF_MONTH);\n-      writer.value(value.get(Calendar.DAY_OF_MONTH));\n-      writer.name(HOUR_OF_DAY);\n-      writer.value(value.get(Calendar.HOUR_OF_DAY));\n-      writer.name(MINUTE);\n-      writer.value(value.get(Calendar.MINUTE));\n-      writer.name(SECOND);\n-      writer.value(value.get(Calendar.SECOND));\n-      writer.endObject();\n+      out.beginObject();\n+      out.name(YEAR);\n+      out.value(value.get(Calendar.YEAR));\n+      out.name(MONTH);\n+      out.value(value.get(Calendar.MONTH));\n+      out.name(DAY_OF_MONTH);\n+      out.value(value.get(Calendar.DAY_OF_MONTH));\n+      out.name(HOUR_OF_DAY);\n+      out.value(value.get(Calendar.HOUR_OF_DAY));\n+      out.name(MINUTE);\n+      out.value(value.get(Calendar.MINUTE));\n+      out.name(SECOND);\n+      out.value(value.get(Calendar.SECOND));\n+      out.endObject();\n     }\n   };\n \n \n   public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n     @Override\n-    public Locale read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      String locale = reader.nextString();\n+    public Locale read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      String locale = in.nextString();\n       StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n       String language = null;\n       String country = null;\n       }\n     }\n     @Override\n-    public void write(JsonWriter writer, Locale value) throws IOException {\n-      writer.value(value == null ? null : value.toString());\n+    public void write(JsonWriter out, Locale value) throws IOException {\n+      out.value(value == null ? null : value.toString());\n     }\n   };\n \n   public static final TypeAdapter.Factory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n \n   public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n-    @Override public JsonElement read(JsonReader reader) throws IOException {\n-      switch (reader.peek()) {\n+    @Override public JsonElement read(JsonReader in) throws IOException {\n+      switch (in.peek()) {\n       case STRING:\n-        return new JsonPrimitive(reader.nextString());\n+        return new JsonPrimitive(in.nextString());\n       case NUMBER:\n-        String number = reader.nextString();\n+        String number = in.nextString();\n         return new JsonPrimitive(new LazilyParsedNumber(number));\n       case BOOLEAN:\n-        return new JsonPrimitive(reader.nextBoolean());\n+        return new JsonPrimitive(in.nextBoolean());\n       case NULL:\n-        reader.nextNull();\n+        in.nextNull();\n         return JsonNull.INSTANCE;\n       case BEGIN_ARRAY:\n         JsonArray array = new JsonArray();\n-        reader.beginArray();\n-        while (reader.hasNext()) {\n-          array.add(read(reader));\n-        }\n-        reader.endArray();\n+        in.beginArray();\n+        while (in.hasNext()) {\n+          array.add(read(in));\n+        }\n+        in.endArray();\n         return array;\n       case BEGIN_OBJECT:\n         JsonObject object = new JsonObject();\n-        reader.beginObject();\n-        while (reader.hasNext()) {\n-          object.add(reader.nextName(), read(reader));\n-        }\n-        reader.endObject();\n+        in.beginObject();\n+        while (in.hasNext()) {\n+          object.add(in.nextName(), read(in));\n+        }\n+        in.endObject();\n         return object;\n       case END_DOCUMENT:\n       case NAME:\n       }\n     }\n \n-    @Override public void write(JsonWriter writer, JsonElement value) throws IOException {\n+    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n       if (value == null || value.isJsonNull()) {\n-        writer.nullValue();\n+        out.nullValue();\n       } else if (value.isJsonPrimitive()) {\n         JsonPrimitive primitive = value.getAsJsonPrimitive();\n         if (primitive.isNumber()) {\n-          writer.value(primitive.getAsNumber());\n+          out.value(primitive.getAsNumber());\n         } else if (primitive.isBoolean()) {\n-          writer.value(primitive.getAsBoolean());\n+          out.value(primitive.getAsBoolean());\n         } else {\n-          writer.value(primitive.getAsString());\n+          out.value(primitive.getAsString());\n         }\n \n       } else if (value.isJsonArray()) {\n-        writer.beginArray();\n+        out.beginArray();\n         for (JsonElement e : value.getAsJsonArray()) {\n-          write(writer, e);\n-        }\n-        writer.endArray();\n+          write(out, e);\n+        }\n+        out.endArray();\n \n       } else if (value.isJsonObject()) {\n-        writer.beginObject();\n+        out.beginObject();\n         for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n-          writer.name(e.getKey());\n-          write(writer, e.getValue());\n-        }\n-        writer.endObject();\n+          out.name(e.getKey());\n+          write(out, e.getValue());\n+        }\n+        out.endObject();\n \n       } else {\n         throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n     public EnumTypeAdapter(Class<T> classOfT) {\n       this.classOfT = classOfT;\n     }\n-    public T read(JsonReader reader) throws IOException {\n-      if (reader.peek() == JsonToken.NULL) {\n-        reader.nextNull();\n-        return null;\n-      }\n-      return Enum.valueOf(classOfT, reader.nextString());\n-    }\n-\n-    public void write(JsonWriter writer, T value) throws IOException {\n-      writer.value(value == null ? null : value.name());\n+    public T read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return Enum.valueOf(classOfT, in.nextString());\n+    }\n+\n+    public void write(JsonWriter out, T value) throws IOException {\n+      out.value(value == null ? null : value.name());\n     }\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java\n \n   private void usePersonNameAdapter() {\n     TypeAdapter<Person> personNameAdapter = new TypeAdapter<Person>() {\n-      @Override public Person read(JsonReader reader) throws IOException {\n-        String name = reader.nextString();\n+      @Override public Person read(JsonReader in) throws IOException {\n+        String name = in.nextString();\n         return new Person(name, -1);\n       }\n-      @Override public void write(JsonWriter writer, Person value) throws IOException {\n-        writer.value(value.name);\n+      @Override public void write(JsonWriter out, Person value) throws IOException {\n+        out.value(value.name);\n       }\n     };\n     miniGson = new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();\n--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n \n   private TypeAdapter<Foo> newTypeAdapter(final String name) {\n     return new TypeAdapter<Foo>() {\n-      @Override public Foo read(JsonReader reader) throws IOException {\n-        return new Foo(reader.nextString() + \" via \" + name);\n+      @Override public Foo read(JsonReader in) throws IOException {\n+        return new Foo(in.nextString() + \" via \" + name);\n       }\n-      @Override public void write(JsonWriter writer, Foo value) throws IOException {\n-        writer.value(value.name + \" via \" + name);\n+      @Override public void write(JsonWriter out, Foo value) throws IOException {\n+        out.value(value.name + \" via \" + name);\n       }\n     };\n   }", "timestamp": 1322941585, "metainfo": ""}