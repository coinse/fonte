{"sha": "2b9fd47b720f0743d69dfcc48bc04b471e37d240", "log": "Fixed issue 53 where default date instances were not getting serialized/deserialized properly. Added support for time style as well by using he default formatter that uses time style.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n final class DefaultTypeAdapters {\n \n   private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER =\n-    new DefaultDateTypeAdapter(DateFormat.DEFAULT);\n+    new DefaultDateTypeAdapter(DateFormat.getDateTimeInstance());\n   @SuppressWarnings(\"unchecked\")\n   private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();\n   private static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();\n     public DefaultDateTypeAdapter(String datePattern) {\n       this.format = new SimpleDateFormat(datePattern);\n     }\n+    \n+    DefaultDateTypeAdapter(DateFormat format) {\n+      this.format = format;\n+    }\n \n     public DefaultDateTypeAdapter(int style) {\n       this.format = DateFormat.getDateInstance(style);\n+    }\n+\n+    public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n+      this.format = DateFormat.getDateTimeInstance(dateStyle, timeStyle);\n     }\n \n     public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n    *   to change the default representation, you can do so by registering a type adapter through\n    *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n-   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. You can change\n+   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format \n+   *   ignores the millisecond portion of the date during serialization. You can change\n    *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n    *   {@link GsonBuilder#setDateFormat(String)}. </li>\n    *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private boolean serializeNulls;\n   private String datePattern;\n   private int dateStyle;\n+  private int timeStyle;\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n     deserializers = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n     serializeNulls = false;\n     dateStyle = DateFormat.DEFAULT;\n+    timeStyle = DateFormat.DEFAULT;\n   }\n \n   /**\n     return this;\n   }\n \n+  /**\n+   * Configures Gson to to serialize {@code Date} objects according to the style value provided.\n+   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n+   * invocation will be used to decide the serialization format.\n+   *\n+   * <p>Note that this style value should be one of the predefined constants in the\n+   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\n+   * information on the valid style constants.</p>\n+   *\n+   * @param dateStyle the predefined date style that date objects will be serialized/deserialized\n+   * to/from\n+   * @param timeStyle the predefined style for the time portion of the date objects\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.2\n+   */\n+  public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {\n+    this.dateStyle = dateStyle;\n+    this.timeStyle = timeStyle;\n+    this.datePattern = null;\n+    return this;\n+  }\n+  \n   /**\n    * Configures Gson for custom serialization or deserialization. This method combines the\n    * registration of an {@link InstanceCreator}, {@link JsonSerializer}, and a\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf();\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf();\n \n-    addTypeAdaptersForDate(datePattern, dateStyle, customSerializers, customDeserializers);\n+    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, \n+        customDeserializers);\n     customSerializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_SERIALIZERS);\n     customDeserializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n \n     return gson;\n   }\n \n-  private static void addTypeAdaptersForDate(String datePattern, int dateStyle,\n+  private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n     // NOTE: if a date pattern exists, then that style takes priority\n     DefaultDateTypeAdapter dateTypeAdapter = null;\n     if (datePattern != null && !\"\".equals(datePattern.trim())) {\n       dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n-    } else if (dateStyle != DateFormat.DEFAULT) {\n-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);\n+    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n+      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n     }\n     if (dateTypeAdapter != null\n         && !serializers.hasAnyHandlerFor(Date.class)\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n   public void testDefaultDateSerialization() {\n     Date now = new Date();\n     String json = gson.toJson(now);\n-    assertEquals(\"\\\"\" + DateFormat.getDateInstance().format(now) + \"\\\"\", json);\n+    assertEquals(\"\\\"\" + DateFormat.getDateTimeInstance().format(now) + \"\\\"\", json);\n   }\n \n   public void testDefaultDateDeserialization() {\n     Date date = new Date();\n-    assertEquals(date, gson.fromJson(gson.toJson(date), Date.class));    \n-  }\n-\n+    String json = gson.toJson(date);\n+    Date extracted = gson.fromJson(json, Date.class);\n+    // Using comparison of string forms since the extracted date has lost the millisecond portion.\n+    assertEquals(date.toString(), extracted.toString());    \n+  }\n+  \n   public void testDefaultDateSerializationUsingBuilder() throws Exception {\n     Gson gson = new GsonBuilder().create();\n     Date now = new Date();\n     String json = gson.toJson(now);\n-    assertEquals(\"\\\"\" + DateFormat.getDateInstance().format(now) + \"\\\"\", json);\n+    assertEquals(\"\\\"\" + DateFormat.getDateTimeInstance().format(now) + \"\\\"\", json);\n   }\n \n   public void testDefaultDateDeserializationUsingBuilder() throws Exception {\n     Gson gson = new GsonBuilder().create();\n     Date now = new Date();\n     String json = gson.toJson(now);\n-    assertEquals(now, gson.fromJson(json, Date.class));    \n+    Date extracted = gson.fromJson(json, Date.class);\n+    assertEquals(now.toString(), extracted.toString());    \n   }\n \n   public void testDateSerializationWithPattern() throws Exception {\n     String pattern = \"yyyy-MM-dd\";\n     DateFormat formatter = new SimpleDateFormat(pattern);\n-    Gson gson = new GsonBuilder().setDateFormat(DateFormat.LONG).setDateFormat(pattern).create();\n+    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\n     Date now = new Date();\n     String json = gson.toJson(now);\n     assertEquals(\"\\\"\" + formatter.format(now) + \"\\\"\", json);\n   }\n   \n+  @SuppressWarnings(\"deprecation\")\n   public void testDateDeserializationWithPattern() throws Exception {\n     String pattern = \"yyyy-MM-dd\";\n     DateFormat formatter = new SimpleDateFormat(pattern);\n-    Gson gson = new GsonBuilder().setDateFormat(DateFormat.LONG).setDateFormat(pattern).create();\n-    Date now = new Date();\n-    String json = gson.toJson(now);\n-    assertEquals(now, gson.fromJson(json, Date.class));    \n+    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\n+    Date now = new Date();\n+    String json = gson.toJson(now);\n+    Date extracted = gson.fromJson(json, Date.class);\n+    assertEquals(now.getYear(), extracted.getYear());    \n+    assertEquals(now.getMonth(), extracted.getMonth());    \n+    assertEquals(now.getDay(), extracted.getDay());    \n   }\n   \n   private static class ClassWithBigDecimal {", "timestamp": 1223923220, "metainfo": ""}