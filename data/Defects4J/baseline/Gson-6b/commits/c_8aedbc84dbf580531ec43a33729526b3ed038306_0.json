{"sha": "8aedbc84dbf580531ec43a33729526b3ed038306", "log": "Added a new GsonBuilder option to register a type adapter for a type hierarchy instead of a single type. Upgraded Gson version to 1.5 since a new API call is being added.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.LinkedList;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Properties;\n-import java.util.Queue;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.StringTokenizer;\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n \n-    map.register(Enum.class, ENUM_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\n     map.register(URL.class, URL_TYPE_ADAPTER);\n     map.register(URI.class, URI_TYPE_ADAPTER);\n     map.register(UUID.class, UUUID_TYPE_ADAPTER);\n     map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n-    map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n-    map.register(Map.class, MAP_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Set.class, COLLECTION_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n     map.register(Date.class, DATE_TYPE_ADAPTER);\n     map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\n     map.register(Timestamp.class, DATE_TYPE_ADAPTER);\n   private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n-    map.register(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\n+    map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\n     map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\n     map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\n     map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\n     map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\n-    map.register(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n-    map.register(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n+    map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n+    map.registerForTypeHierarchy(Set.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n+    map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n     map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\n     map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\n     map.register(Map.class, MAP_TYPE_ADAPTER);\n \n     // Add Collection type instance creators\n-    map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n-    map.register(List.class, COLLECTION_TYPE_ADAPTER);\n-    map.register(Queue.class, COLLECTION_TYPE_ADAPTER);\n+    map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n \n     map.register(Set.class, HASH_SET_CREATOR);\n     map.register(SortedSet.class, TREE_SET_CREATOR);\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   }\n \n   /**\n+   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n+   * This method combines the registration of an {@link InstanceCreator}, {@link JsonSerializer},\n+   * and a {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter}\n+   * implements all the required interfaces for custom serialization with Gson.\n+   * If an instance creator, serializer or deserializer was previously registered for the specified\n+   * type hierarchy, it is overwritten. If an instance creator, serializer or deserializer is\n+   * registered for a specific type in the type hierarchy, it will be invoked instead of the one\n+   * registered for the type hierarchy.\n+   *\n+   * @param baseType the class definition for the type adapter being registered for the base class\n+   *        or interface\n+   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n+   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.5\n+   */\n+  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n+    Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n+    || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+    if (typeAdapter instanceof InstanceCreator<?>) {\n+      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n+    }\n+    if (typeAdapter instanceof JsonSerializer<?>) {\n+      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter);\n+    }\n+    if (typeAdapter instanceof JsonDeserializer<?>) {\n+      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n+    }\n+    return this;\n+  }\n+\n+  private <T> GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT,\n+      InstanceCreator<? extends T> instanceCreator) {\n+    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator);\n+    return this;\n+  }\n+\n+  private <T> GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT,\n+      final JsonSerializer<T> serializer) {\n+    serializers.registerForTypeHierarchy(classOfT, serializer);\n+    return this;\n+  }\n+\n+  private <T> GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT,\n+      JsonDeserializer<T> deserializer) {\n+    deserializers.registerForTypeHierarchy(classOfT,\n+        new JsonDeserializerExceptionWrapper<T>(deserializer));\n+    return this;\n+  }\n+\n+  /**\n    * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n    * special double values (NaN, Infinity, -Infinity). However,\n    * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n package com.google.gson;\n \n import java.lang.reflect.Type;\n-import java.util.Collection;\n+import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n \n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  * \n- * @param <T>\n- *          The handler that will be looked up by type\n+ * @param <T> The handler that will be looked up by type\n  */\n final class ParameterizedTypeHandlerMap<T> {\n   private static final Logger logger =\n       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n   private final Map<Type, T> map = new HashMap<Type, T>();\n+  private final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n   private boolean modifiable = true;\n+\n+  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n+    Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n+    registerForTypeHierarchy(pair);\n+  }\n+\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n+    if (index >= 0) {\n+      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n+      typeHierarchyList.remove(index);\n+    }\n+    // We want stack behavior for adding to this list. A type adapter added subsequently should\n+    // override a previously registered one.\n+    typeHierarchyList.add(0, pair);\n+  }\n \n   public synchronized void register(Type typeOfT, T value) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\n-          \"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n     if (hasSpecificHandlerFor(typeOfT)) {\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n \n   public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\n-          \"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n-    for (Map.Entry<Type, T> entry : other.entrySet()) {\n+    for (Map.Entry<Type, T> entry : other.map.entrySet()) {\n       if (!map.containsKey(entry.getKey())) {\n         register(entry.getKey(), entry.getValue());\n+      }\n+    }\n+    for (Pair<Class<?>, T> entry : other.typeHierarchyList) {\n+      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\n+      if (index < 0) {\n+        registerForTypeHierarchy(entry);\n       }\n     }\n   }\n \n   public synchronized void registerIfAbsent(Type typeOfT, T value) {\n     if (!modifiable) {\n-      throw new IllegalStateException(\n-          \"Attempted to modify an unmodifiable map.\");\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n     if (!map.containsKey(typeOfT)) {\n       register(typeOfT, value);\n       if (rawClass != type) {\n         handler = getHandlerFor(rawClass);\n       }\n-\n-      // Check for map or collection\n       if (handler == null) {\n-        if (Map.class.isAssignableFrom(rawClass)) {\n-          handler = map.get(Map.class);\n-        } else if (Collection.class.isAssignableFrom(rawClass)) {\n-          handler = map.get(Collection.class);\n-        } else if (Enum.class.isAssignableFrom(rawClass)) {\n-          handler = map.get(Enum.class);\n-        }\n+        // check if something registered for type hierarchy\n+        handler = getHandlerForTypeHierarchy(rawClass);\n       }\n     }\n     return handler;\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n+  private T getHandlerForTypeHierarchy(Class<?> type) {\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+      if (entry.first.isAssignableFrom(type)) {\n+        return entry.second;\n+      }\n+    }\n+    return null;\n+  }\n+\n   public synchronized boolean hasSpecificHandlerFor(Type type) {\n     return map.containsKey(type);\n+  }\n+\n+  private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      if (type.equals(typeHierarchyList.get(i).first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n   }\n \n   public synchronized ParameterizedTypeHandlerMap<T> copyOf() {\n     for (Map.Entry<Type, T> entry : map.entrySet()) {\n       copy.register(entry.getKey(), entry.getValue());\n     }\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+      copy.registerForTypeHierarchy(entry);\n+    }\n     return copy;\n-  }\n-\n-  public synchronized Set<Map.Entry<Type, T>> entrySet() {\n-    return map.entrySet();\n   }\n \n   @Override\n   public String toString() {\n-    StringBuilder sb = new StringBuilder(\"{\");\n+    StringBuilder sb = new StringBuilder(\"{mapForTypeHierarchy:{\");\n     boolean first = true;\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append(typeToString(entry.first)).append(':');\n+      sb.append(entry.second);\n+    }\n+    sb.append(\"},map:{\");\n+    first = true;\n     for (Map.Entry<Type, T> entry : map.entrySet()) {\n       if (first) {\n         first = false;\n       sb.append(typeToString(entry.getKey())).append(':');\n       sb.append(entry.getValue());\n     }\n+    sb.append(\"}\");\n     return sb.toString();\n   }\n \n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n \n package com.google.gson;\n \n+import com.google.gson.common.TestTypes.Base;\n+import com.google.gson.common.TestTypes.Sub;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n      fail(\"Can not register handlers when map is unmodifiable\");\n     } catch (IllegalStateException expected) { }\n   }\n+\n+  public void testTypeHierarchy() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    String handler = paramMap.getHandlerFor(Sub.class);\n+    assertEquals(\"baseHandler\", handler);\n+  }\n+\n+  public void testTypeHierarchyMultipleHandlers() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    String handler = paramMap.getHandlerFor(SubOfSub.class);\n+    assertEquals(\"subHandler\", handler);\n+  }\n+\n+  public void testTypeHierarchyRegisterIfAbsent() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>();\n+    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\");\n+    paramMap.registerIfAbsent(otherMap);\n+    String handler = paramMap.getHandlerFor(Base.class);\n+    assertEquals(\"baseHandler\", handler);\n+  }\n+\n+  private static class SubOfSub extends Sub {\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n     assertTrue(json.contains(\"\\\"a\\\":\\\"b\\\"\"));\n   }\n   \n+  public void testMapStandardSubclassDeserialization() {\n+    String json = \"{a:'1',b:'2'}\";\n+    Type type = new TypeToken<LinkedHashMap<String, String>>() {}.getType();\n+    LinkedHashMap<String, Integer> map = gson.fromJson(json, type);\n+    assertEquals(\"1\", map.get(\"a\")); \n+    assertEquals(\"2\", map.get(\"b\")); \n+  }\n+  \n   public void disable_testMapSubclassDeserialization() {\n     Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {\n       public MyMap createInstance(Type type) {", "timestamp": 1277162766, "metainfo": ""}