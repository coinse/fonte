{"sha": "1f803bd37de5890f6da53f0b1a1b631eea4d1b8f", "log": "Merge pull request #761 from google/jw/nuke-synthetics  Remove synthetic accessors from being generated.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n    * Converts the field name that uses camel-case define word separation into\n    * separate words that are separated by the provided {@code separatorString}.\n    */\n-  private static String separateCamelCase(String name, String separator) {\n+  static String separateCamelCase(String name, String separator) {\n     StringBuilder translation = new StringBuilder();\n     for (int i = 0; i < name.length(); i++) {\n       char character = name.charAt(i);\n   /**\n    * Ensures the JSON field names begins with an upper case letter.\n    */\n-  private static String upperCaseFirstLetter(String name) {\n+  static String upperCaseFirstLetter(String name) {\n     StringBuilder fieldNameBuilder = new StringBuilder();\n     int index = 0;\n     char firstCharacter = name.charAt(index);\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     };\n   }\n \n-  private void checkValidFloatingPoint(double value) {\n+  static void checkValidFloatingPoint(double value) {\n     if (Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(value\n           + \" is not a valid double value as per JSON specification. To override this\"\n    *  }</pre>\n    *  Note that this call will skip all factories registered before {@code skipPast}. In case of\n    *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n-   *  that the order of registration does not prevent this method from reaching a factory they \n+   *  that the order of registration does not prevent this method from reaching a factory they\n    *  would expect to reply from this call.\n    *  Note that since you can not override type adapter factories for String and Java primitive\n    *  types, our stats factory will not count the number of String or primitives that will be\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n   /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n   private TypeAdapter<T> delegate;\n \n-  private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n+  TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n     this.serializer = serializer;\n     this.deserializer = deserializer;\n     private final JsonSerializer<?> serializer;\n     private final JsonDeserializer<?> deserializer;\n \n-    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n+    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n         Class<?> hierarchyType) {\n       serializer = typeAdapter instanceof JsonSerializer\n           ? (JsonSerializer<?>) typeAdapter\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n \n package com.google.gson.internal;\n \n-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n-\n import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n import java.util.NoSuchElementException;\n import java.util.Properties;\n \n+import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n+import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n+\n /**\n  * Static methods for working with types.\n  *\n     }\n   }\n \n-  private static int hashCodeOrZero(Object o) {\n+  static int hashCodeOrZero(Object o) {\n     return o != null ? o.hashCode() : 0;\n   }\n \n         : null;\n   }\n \n-  private static void checkNotPrimitive(Type type) {\n+  static void checkNotPrimitive(Type type) {\n     checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java\n     Node<K, V> lastReturned = null;\n     int expectedModCount = modCount;\n \n+    LinkedTreeMapIterator() {\n+    }\n+\n     public final boolean hasNext() {\n       return next != header;\n     }\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n     Node<K, V> lastReturned = null;\n     int expectedModCount = modCount;\n \n+    LinkedTreeMapIterator() {\n+    }\n+\n     public final boolean hasNext() {\n       return next != header;\n     }\n   private Object writeReplace() throws ObjectStreamException {\n     return new LinkedHashMap<K, V>(this);\n   }\n-}\n+}\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     private final Appendable appendable;\n     private final CurrentWrite currentWrite = new CurrentWrite();\n \n-    private AppendableWriter(Appendable appendable) {\n+    AppendableWriter(Appendable appendable) {\n       this.appendable = appendable;\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n  */\n public final class MapTypeAdapterFactory implements TypeAdapterFactory {\n   private final ConstructorConstructor constructorConstructor;\n-  private final boolean complexMapKeySerialization;\n+  final boolean complexMapKeySerialization;\n \n   public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n       boolean complexMapKeySerialization) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n \n   private final Gson gson;\n \n-  private ObjectTypeAdapter(Gson gson) {\n+  ObjectTypeAdapter(Gson gson) {\n     this.gson = gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n-\n-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n \n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n \n /**\n  * Type adapter that reflects over the fields and methods of a class.\n     };\n   }\n \n-  private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n+  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n     if (annotation != null) {\n       TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n     private final ObjectConstructor<T> constructor;\n     private final Map<String, BoundField> boundFields;\n \n-    private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n       this.constructor = constructor;\n       this.boundFields = boundFields;\n     }\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   private int lineNumber = 0;\n   private int lineStart = 0;\n \n-  private int peeked = PEEKED_NONE;\n+  int peeked = PEEKED_NONE;\n \n   /**\n    * A peeked value that was composed entirely of digits with an optional\n     }\n   }\n \n-  private int doPeek() throws IOException {\n+  int doPeek() throws IOException {\n     int peekStack = stack[stackSize - 1];\n     if (peekStack == JsonScope.EMPTY_ARRAY) {\n       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n     return false;\n   }\n \n-  private int getLineNumber() {\n+  int getLineNumber() {\n     return lineNumber + 1;\n   }\n \n-  private int getColumnNumber() {\n+  int getColumnNumber() {\n     return pos - lineStart + 1;\n   }\n \n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n+import java.text.ParsePosition;\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n import java.util.TimeZone;\n+\n+import com.google.gson.internal.bind.util.ISO8601Utils;\n \n /**\n  * This type adapter supports three subclasses of date: Date, Timestamp, and\n \n   private final DateFormat enUsFormat;\n   private final DateFormat localFormat;\n-  private final DateFormat iso8601Format;\n \n   DefaultDateTypeAdapter() {\n     this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n   DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n     this.enUsFormat = enUsFormat;\n     this.localFormat = localFormat;\n-    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n-    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n   }\n \n   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n   private Date deserializeToDate(JsonElement json) {\n     synchronized (localFormat) {\n       try {\n-        return localFormat.parse(json.getAsString());\n-      } catch (ParseException ignored) {\n-      }\n+      \treturn localFormat.parse(json.getAsString());\n+      } catch (ParseException ignored) {}\n       try {\n         return enUsFormat.parse(json.getAsString());\n-      } catch (ParseException ignored) {\n-      }\n+      } catch (ParseException ignored) {}\n       try {\n-        return iso8601Format.parse(json.getAsString());\n+        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n       } catch (ParseException e) {\n         throw new JsonSyntaxException(json.getAsString(), e);\n       }\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.bind.util.ISO8601Utils;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import java.io.IOException;\n import java.text.DateFormat;\n import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n+import java.text.ParsePosition;\n import java.util.Date;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n /**\n  * Adapter for Date. Although this class appears stateless, it is not.\n       = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);\n   private final DateFormat localFormat\n       = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);\n-  private final DateFormat iso8601Format = buildIso8601Format();\n-\n-  private static DateFormat buildIso8601Format() {\n-    DateFormat iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n-    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    return iso8601Format;\n-  }\n \n   @Override public Date read(JsonReader in) throws IOException {\n     if (in.peek() == JsonToken.NULL) {\n     } catch (ParseException ignored) {\n     }\n     try {\n-      return iso8601Format.parse(json);\n+    \treturn ISO8601Utils.parse(json, new ParsePosition(0));\n     } catch (ParseException e) {\n       throw new JsonSyntaxException(json, e);\n     }\n     String dateFormatAsString = enUsFormat.format(value);\n     out.value(dateFormatAsString);\n   }\n+  \n+  \n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n+package com.google.gson.internal.bind.util;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.*;\n+\n+/**\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\n+ * \n+ * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n+ */\n+//Date parsing code from Jackson databind ISO8601Utils.java\n+// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+public class ISO8601Utils\n+{\n+    /**\n+     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\n+     * \n+     * @since 2.7\n+     */\n+    private static final String UTC_ID = \"UTC\";\n+    /**\n+     * The UTC timezone, prefetched to avoid more lookups.\n+     * \n+     * @since 2.7\n+     */\n+    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n+\n+    /*\n+    /**********************************************************\n+    /* Formatting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n+     * \n+     * @param date the date to format\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n+     */\n+    public static String format(Date date) {\n+        return format(date, false, TIMEZONE_UTC);\n+    }\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n+     * \n+     * @param date the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n+     */\n+    public static String format(Date date, boolean millis) {\n+        return format(date, millis, TIMEZONE_UTC);\n+    }\n+\n+    /**\n+     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     * \n+     * @param date the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n+     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     */\n+    public static String format(Date date, boolean millis, TimeZone tz) {\n+        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n+        calendar.setTime(date);\n+\n+        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n+        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n+        capacity += millis ? \".sss\".length() : 0;\n+        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n+        StringBuilder formatted = new StringBuilder(capacity);\n+\n+        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n+        formatted.append('T');\n+        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n+        if (millis) {\n+            formatted.append('.');\n+            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n+        }\n+\n+        int offset = tz.getOffset(calendar.getTimeInMillis());\n+        if (offset != 0) {\n+            int hours = Math.abs((offset / (60 * 1000)) / 60);\n+            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n+            formatted.append(offset < 0 ? '-' : '+');\n+            padInt(formatted, hours, \"hh\".length());\n+            formatted.append(':');\n+            padInt(formatted, minutes, \"mm\".length());\n+        } else {\n+            formatted.append('Z');\n+        }\n+\n+        return formatted.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Parse a date from ISO-8601 formatted string. It expects a format\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * \n+     * @param date ISO string to parse in the appropriate format.\n+     * @param pos The position to start parsing from, updated to where parsing stopped.\n+     * @return the parsed date\n+     * @throws ParseException if the date is not in the appropriate format\n+     */\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n+        Exception fail = null;\n+        try {\n+            int offset = pos.getIndex();\n+\n+            // extract year\n+            int year = parseInt(date, offset, offset += 4);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n+\n+            // extract month\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n+\n+            // extract day\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n+            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n+\n+            // if the value has no time component (and no time zone), we are done\n+            boolean hasT = checkOffset(date, offset, 'T');\n+            \n+            if (!hasT && (date.length() <= offset)) {\n+                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+\n+                pos.setIndex(offset);\n+                return calendar.getTime();\n+            }\n+\n+            if (hasT) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            offset += 1;\n+                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n+                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n+                            int fraction = parseInt(date, offset, parseEndOffset);\n+                            // compensate for \"missing\" digits\n+                            switch (parseEndOffset - offset) { // number of digits parsed\n+                            case 2:\n+                                milliseconds = fraction * 10;\n+                                break;\n+                            case 1:\n+                                milliseconds = fraction * 100;\n+                                break;\n+                            default:\n+                                milliseconds = fraction;\n+                            }\n+                            offset = endOffset;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // extract timezone\n+            if (date.length() <= offset) {\n+                throw new IllegalArgumentException(\"No time zone indicator\");\n+            }\n+\n+            TimeZone timezone = null;\n+            char timezoneIndicator = date.charAt(offset);\n+\n+            if (timezoneIndicator == 'Z') {\n+                timezone = TIMEZONE_UTC;\n+                offset += 1;\n+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                String timezoneOffset = date.substring(offset);\n+                offset += timezoneOffset.length();\n+                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n+                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                    timezone = TIMEZONE_UTC;\n+                } else {\n+                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n+                    //    not sure why, but that's the way it looks. Further, Javadocs for\n+                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n+                    //    custom timezones... odd.\n+                    String timezoneId = \"GMT\" + timezoneOffset;\n+//                    String timezoneId = \"UTC\" + timezoneOffset;\n+\n+                    timezone = TimeZone.getTimeZone(timezoneId);\n+\n+                    String act = timezone.getID();\n+                    if (!act.equals(timezoneId)) {\n+                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n+                         *    one without. If so, don't sweat.\n+                         *   Yes, very inefficient. Hopefully not hit often.\n+                         *   If it becomes a perf problem, add 'loose' comparison instead.\n+                         */\n+                        String cleaned = act.replace(\":\", \"\");\n+                        if (!cleaned.equals(timezoneId)) {\n+                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n+                                    +timezone.getID());\n+                        }\n+                    }\n+                }\n+            } else {\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n+            }\n+\n+            Calendar calendar = new GregorianCalendar(timezone);\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n+            calendar.set(Calendar.HOUR_OF_DAY, hour);\n+            calendar.set(Calendar.MINUTE, minutes);\n+            calendar.set(Calendar.SECOND, seconds);\n+            calendar.set(Calendar.MILLISECOND, milliseconds);\n+\n+            pos.setIndex(offset);\n+            return calendar.getTime();\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n+        } catch (IndexOutOfBoundsException e) {\n+            fail = e;\n+        } catch (NumberFormatException e) {\n+            fail = e;\n+        } catch (IllegalArgumentException e) {\n+            fail = e;\n+        }\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        String msg = fail.getMessage();\n+        if (msg == null || msg.isEmpty()) {\n+            msg = \"(\"+fail.getClass().getName()+\")\";\n+        }\n+        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n+        ex.initCause(fail);\n+        throw ex;\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n+     * @param expected the expected character\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return (offset < value.length()) && (value.charAt(offset) == expected);\n+    }\n+\n+    /**\n+     * Parse an integer located between 2 given offsets in a string\n+     * \n+     * @param value the string to parse\n+     * @param beginIndex the start index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n+     * @return the int\n+     * @throws NumberFormatException if the value is not a number\n+     */\n+    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n+        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n+            throw new NumberFormatException(value);\n+        }\n+        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n+        int i = beginIndex;\n+        int result = 0;\n+        int digit;\n+        if (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n+            }\n+            result = -digit;\n+        }\n+        while (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n+            }\n+            result *= 10;\n+            result -= digit;\n+        }\n+        return -result;\n+    }\n+\n+    /**\n+     * Zero pad a number to a specified length\n+     * \n+     * @param buffer buffer to use for padding\n+     * @param value the integer value to pad if necessary.\n+     * @param length the length of the string we should zero pad\n+     */\n+    private static void padInt(StringBuilder buffer, int value, int length) {\n+        String strValue = Integer.toString(value);\n+        for (int i = length - strValue.length(); i > 0; i--) {\n+            buffer.append('0');\n+        }\n+        buffer.append(strValue);\n+    }\n+\n+    /**\n+     * Returns the index of the first character in the string that is not a digit, starting at offset.\n+     */\n+    private static int indexOfNonDigit(String string, int offset) {\n+        for (int i = offset; i < string.length(); i++) {\n+            char c = string.charAt(i);\n+            if (c < '0' || c > '9') return i;\n+        }\n+        return string.length();\n+    }\n+\n+}\n--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n     }\n   }\n \n+  public void testDateDeserializationISO8601() throws Exception {\n+  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n+    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n+    assertParsed(\"1970-01-01T00:00Z\", adapter);\n+    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n+    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n+  }\n+  \n   public void testDateSerialization() throws Exception {\n     int dateStyle = DateFormat.LONG;\n     DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);", "timestamp": 1451243303, "metainfo": ""}