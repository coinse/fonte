{"sha": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1", "log": "Rename GsonReader to Streams; check that class in.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonReader jsonReader = new JsonReader(json);\n     jsonReader.setLenient(true);\n-    JsonElement root = GsonReader.parse(jsonReader);\n+    JsonElement root = Streams.parse(jsonReader);\n     return (T) fromJson(root, typeOfT);\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n     try {\n       JsonReader jsonReader = new JsonReader(json);\n       jsonReader.setLenient(true);\n-      return GsonReader.parse(jsonReader);\n+      return Streams.parse(jsonReader);\n     } catch (StackOverflowError e) {\n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java\n     }\n     \n     try {\n-      return GsonReader.parse(parser);\n+      return Streams.parse(parser);\n     } catch (StackOverflowError e) {\n       throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n     } catch (OutOfMemoryError e) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Streams.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Map;\n+\n+/**\n+ * Reads and writes GSON parse trees over streams.\n+ */\n+final class Streams {\n+\n+  /**\n+   * Takes a reader in any state and returns the next value as a JsonElement.\n+   */\n+  static JsonElement parse(JsonReader reader) throws JsonParseException {\n+    try {\n+      switch (reader.peek()) {\n+      case STRING:\n+        return new JsonPrimitive(reader.nextString());\n+      case NUMBER:\n+        String number = reader.nextString();\n+        return new JsonPrimitive(JsonPrimitive.stringToNumber(number));\n+      case BOOLEAN:\n+        return new JsonPrimitive(reader.nextBoolean());\n+      case NULL:\n+        reader.nextNull();\n+        return JsonNull.createJsonNull();\n+      case BEGIN_ARRAY:\n+        JsonArray array = new JsonArray();\n+        reader.beginArray();\n+        while (reader.hasNext()) {\n+          array.add(parse(reader));\n+        }\n+        reader.endArray();\n+        return array;\n+      case BEGIN_OBJECT:\n+        JsonObject object = new JsonObject();\n+        reader.beginObject();\n+        while (reader.hasNext()) {\n+          object.add(reader.nextName(), parse(reader));\n+        }\n+        reader.endObject();\n+        return object;\n+      case END_DOCUMENT:\n+      case NAME:\n+      case END_OBJECT:\n+      case END_ARRAY:\n+      default:\n+        throw new IllegalArgumentException();\n+      }\n+    } catch (IOException e) {\n+      if (e instanceof EOFException) {\n+        return JsonNull.createJsonNull();\n+      }\n+      throw new JsonParseException(e);\n+    } catch (NumberFormatException e) {\n+      throw new JsonParseException(e);\n+    }\n+  }\n+\n+  /**\n+   * Writes the JSON element to the writer, recursively.\n+   */\n+  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer)\n+      throws IOException {\n+    if (element == null || element.isJsonNull()) {\n+      if (serializeNulls) {\n+        writer.nullValue();\n+      }\n+\n+    } else if (element.isJsonPrimitive()) {\n+      JsonPrimitive primitive = element.getAsJsonPrimitive();\n+      if (primitive.isNumber()) {\n+        writer.value(primitive.getAsNumber());\n+      } else if (primitive.isBoolean()) {\n+        writer.value(primitive.getAsBoolean());\n+      } else {\n+        writer.value(primitive.getAsString());\n+      }\n+\n+    } else if (element.isJsonArray()) {\n+      writer.beginArray();\n+      for (JsonElement e : element.getAsJsonArray()) {\n+        /* always print null when its parent element is an array! */\n+        if (e.isJsonNull()) {\n+          writer.nullValue();\n+          continue;\n+        }\n+        write(e, serializeNulls, writer);\n+      }\n+      writer.endArray();\n+\n+    } else if (element.isJsonObject()) {\n+      writer.beginObject();\n+      for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) {\n+        JsonElement value = e.getValue();\n+        if (!serializeNulls && value.isJsonNull()) {\n+          continue;\n+        }\n+        writer.name(e.getKey());\n+        write(value, serializeNulls, writer);\n+      }\n+      writer.endObject();\n+\n+    } else {\n+      throw new IllegalArgumentException(\"Couldn't write \" + element.getClass());\n+    }\n+  }\n+\n+  static Writer writerForAppendable(Appendable appendable) {\n+    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n+  }\n+\n+  /**\n+   * Adapts an {@link Appendable} so it can be passed anywhere a {@link Writer}\n+   * is used.\n+   */\n+  private static class AppendableWriter extends Writer {\n+    private final Appendable appendable;\n+    private final CurrentWrite currentWrite = new CurrentWrite();\n+\n+    private AppendableWriter(Appendable appendable) {\n+      this.appendable = appendable;\n+    }\n+\n+    @Override public void write(char[] chars, int offset, int length) throws IOException {\n+      currentWrite.chars = chars;\n+      appendable.append(currentWrite, offset, offset + length);\n+    }\n+\n+    @Override public void write(int i) throws IOException {\n+      appendable.append((char) i);\n+    }\n+\n+    @Override public void flush() throws IOException {}\n+    @Override public void close() throws IOException {}\n+\n+    /**\n+     * A mutable char sequence pointing at a single char[].\n+     */\n+    static class CurrentWrite implements CharSequence {\n+      char[] chars;\n+      public int length() {\n+        return chars.length;\n+      }\n+      public char charAt(int i) {\n+        return chars[i];\n+      }\n+      public CharSequence subSequence(int start, int end) {\n+        return new String(chars, start, end - start);\n+      }\n+    }\n+  }\n+}", "timestamp": 1283386202, "metainfo": ""}