{"sha": "777e17c723fa2c87d703326f6bcf1195645893bd", "log": "No more system type adapters.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n-    return registerTypeAdapter(type, typeAdapter, false);\n-  }\n-\n-  private GsonBuilder registerTypeAdapter(Type type, Object typeAdapter, boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n         || typeAdapter instanceof JsonDeserializer<?>\n         || typeAdapter instanceof InstanceCreator<?>\n           \"Cannot register type adapters for \" + type);\n     }\n     if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter, isSystem);\n+      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializer(type, (JsonSerializer<?>) typeAdapter, isSystem);\n+      registerSerializer(type, (JsonSerializer<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter, isSystem);\n+      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof TypeAdapter.Factory) {\n       typeAdapterFactories.add((TypeAdapter.Factory) typeAdapter);\n    * takes a type instead of a Class object, it can be used to register a specific handler for a\n    * generic type corresponding to a raw type.\n    *\n-   * @param <T> the type for which instance creator is being registered\n+   *\n    * @param typeOfT The Type definition for T\n    * @param instanceCreator the instance creator for T\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n-      InstanceCreator<? extends T> instanceCreator, boolean isSystem) {\n-    instanceCreators.register(typeOfT, instanceCreator, isSystem);\n+      InstanceCreator<? extends T> instanceCreator) {\n+    instanceCreators.register(typeOfT, instanceCreator);\n     return this;\n   }\n \n    * method if you want to register different serializers for different generic types corresponding\n    * to a raw type.\n    *\n-   * @param <T> the type for which the serializer is being registered\n+   *\n    * @param typeOfT The type definition for T\n    * @param serializer the custom serializer\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n-  private <T> GsonBuilder registerSerializer(Type typeOfT, JsonSerializer<T> serializer,\n-      boolean isSystem) {\n-    serializers.register(typeOfT, serializer, isSystem);\n+  private <T> GsonBuilder registerSerializer(Type typeOfT, JsonSerializer<T> serializer) {\n+    serializers.register(typeOfT, serializer);\n     return this;\n   }\n \n    * method if you want to register different deserializers for different generic types\n    * corresponding to a raw type.\n    *\n-   * @param <T> the type for which the deserializer is being registered\n+   *\n    * @param typeOfT The type definition for T\n    * @param deserializer the custom deserializer\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n-  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer,\n-      boolean isSystem) {\n-    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer), isSystem);\n+  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) {\n+    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer));\n     return this;\n   }\n \n    * @since 1.7\n    */\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n-    return registerTypeHierarchyAdapter(baseType, typeAdapter, false);\n-  }\n-\n-  private GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter,\n-      boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n         || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter, isSystem);\n+      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter, isSystem);\n+      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter, isSystem);\n+      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n     }\n     return this;\n   }\n \n   private <T> GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT,\n-      InstanceCreator<? extends T> instanceCreator, boolean isSystem) {\n-    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator, isSystem);\n+      InstanceCreator<? extends T> instanceCreator) {\n+    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator);\n     return this;\n   }\n \n   private <T> GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT,\n-      JsonSerializer<T> serializer, boolean isSystem) {\n-    serializers.registerForTypeHierarchy(classOfT, serializer, isSystem);\n+      JsonSerializer<T> serializer) {\n+    serializers.registerForTypeHierarchy(classOfT, serializer);\n     return this;\n   }\n \n   private <T> GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT,\n-      JsonDeserializer<T> deserializer, boolean isSystem) {\n+      JsonDeserializer<T> deserializer) {\n     deserializers.registerForTypeHierarchy(classOfT,\n-        new JsonDeserializerExceptionWrapper<T>(deserializer), isSystem);\n+        new JsonDeserializerExceptionWrapper<T>(deserializer));\n     return this;\n   }\n \n   private static <T> void registerIfAbsent(Class<?> type,\n       ParameterizedTypeHandlerMap<T> adapters, T adapter) {\n     if (!adapters.hasSpecificHandlerFor(type)) {\n-      adapters.register(type, adapter, false);\n+      adapters.register(type, adapter);\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java\n \n   private static final Logger logger =\n       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n-  /**\n-   * Map that is meant for storing default type adapters\n-   */\n-  private final Map<Type, T> systemMap = new HashMap<Type, T>();\n+\n+  /** Map that is meant for storing default type adapters */\n   private final Map<Type, T> userMap = new HashMap<Type, T>();\n-  /**\n-   * List of default type hierarchy adapters\n-   */\n-  private final List<Pair<Class<?>, T>> systemTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+\n+  /** List of default type hierarchy adapters */\n   private final List<Pair<Class<?>, T>> userTypeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n   private boolean modifiable = true;\n \n-  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value, boolean isSystem) {\n+  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n-    registerForTypeHierarchy(pair, isSystem);\n-  }\n-\n-  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair, boolean isSystem) {\n+    registerForTypeHierarchy(pair);\n+  }\n+\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n-    List<Pair<Class<?>, T>> typeHierarchyList = isSystem ? systemTypeHierarchyList : userTypeHierarchyList;\n+    List<Pair<Class<?>, T>> typeHierarchyList = userTypeHierarchyList;\n     int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first, typeHierarchyList);\n     if (index >= 0) {\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n     return -1;\n   }\n \n-  public synchronized void register(Type typeOfT, T value, boolean isSystem) {\n+  public synchronized void register(Type typeOfT, T value) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n     if (hasSpecificHandlerFor(typeOfT)) {\n       logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n     }\n-    Map<Type, T> map = isSystem ? systemMap : userMap;\n+    Map<Type, T> map = userMap;\n     map.put(typeOfT, value);\n   }\n \n     }\n     for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n       if (!userMap.containsKey(entry.getKey())) {\n-        register(entry.getKey(), entry.getValue(), false);\n-      }\n-    }\n-    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n-      if (!systemMap.containsKey(entry.getKey())) {\n-        register(entry.getKey(), entry.getValue(), true);\n+        register(entry.getKey(), entry.getValue());\n       }\n     }\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n       Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n       int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, userTypeHierarchyList);\n       if (index < 0) {\n-        registerForTypeHierarchy(entry, false);\n-      }\n-    }\n-    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n-      int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first, systemTypeHierarchyList);\n-      if (index < 0) {\n-        registerForTypeHierarchy(entry, true);\n+        registerForTypeHierarchy(entry);\n       }\n     }\n   }\n         return handler;\n       }\n     }\n-    handler = systemMap.get(type);\n-    if (handler != null) {\n-      return handler;\n-    }\n     Class<?> rawClass = $Gson$Types.getRawType(type);\n     if (rawClass != type) {\n       handler = getHandlerFor(rawClass, systemOnly);\n         }\n       }\n     }\n-    for (Pair<Class<?>, T> entry : systemTypeHierarchyList) {\n-      if (entry.first.isAssignableFrom(type)) {\n-        return entry.second;\n-      }\n-    }\n     return null;\n   }\n \n   public synchronized boolean hasSpecificHandlerFor(Type type) {\n-    return userMap.containsKey(type) || systemMap.containsKey(type);\n+    return userMap.containsKey(type);\n   }\n \n   private static <T> int getIndexOfSpecificHandlerForTypeHierarchy(\n \n     // TODO (inder): Performance optimization. We can probably just share the\n     // systemMap and systemTypeHierarchyList instead of making copies\n-    copy.systemMap.putAll(systemMap);\n     copy.userMap.putAll(userMap);\n-    copy.systemTypeHierarchyList.addAll(systemTypeHierarchyList);\n     copy.userTypeHierarchyList.addAll(userTypeHierarchyList);\n     return copy;\n   }\n   public String toString() {\n     StringBuilder sb = new StringBuilder(\"{userTypeHierarchyList:{\");\n     appendList(sb, userTypeHierarchyList);\n-    sb.append(\"},systemTypeHierarchyList:{\");\n-    appendList(sb, systemTypeHierarchyList);\n     sb.append(\"},userMap:{\");\n     appendMap(sb, userMap);\n-    sb.append(\"},systemMap:{\");\n-    appendMap(sb, systemMap);\n     sb.append(\"}\");\n     return sb.toString();\n   }\n--- a/gson/src/test/java/com/google/gson/internal/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/ParameterizedTypeHandlerMapTest.java\n   public void testHasGenericButNotSpecific() throws Exception {\n     Type specificType = new TypeToken<List<String>>() {}.getType();\n     String handler = \"blah\";\n-    paramMap.register(List.class, handler, false);\n+    paramMap.register(List.class, handler);\n \n     assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n     assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n   public void testHasSpecificType() throws Exception {\n     Type specificType = new TypeToken<List<String>>() {}.getType();\n     String handler = \"blah\";\n-    paramMap.register(specificType, handler, false);\n+    paramMap.register(specificType, handler);\n \n     assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n     assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n   public void testTypeOverridding() throws Exception {\n     String handler1 = \"blah1\";\n     String handler2 = \"blah2\";\n-    paramMap.register(String.class, handler1, false);\n-    paramMap.register(String.class, handler2, false);\n+    paramMap.register(String.class, handler1);\n+    paramMap.register(String.class, handler2);\n \n     assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n     assertEquals(handler2, paramMap.getHandlerFor(String.class, false));\n   public void testMakeUnmodifiable() throws Exception {\n     paramMap.makeUnmodifiable();\n     try {\n-     paramMap.register(String.class, \"blah\", false);\n+     paramMap.register(String.class, \"blah\");\n      fail(\"Can not register handlers when map is unmodifiable\");\n     } catch (IllegalStateException expected) { }\n   }\n \n   public void testTypeHierarchy() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n     String handler = paramMap.getHandlerFor(Sub.class, false);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testTypeHierarchyMultipleHandlers() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n-    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n     String handler = paramMap.getHandlerFor(SubOfSub.class, false);\n     assertEquals(\"subHandler\", handler);\n   }\n \n   public void testTypeHierarchyRegisterIfAbsent() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>();\n-    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\", false);\n+    otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\");\n     paramMap.registerIfAbsent(otherMap);\n     String handler = paramMap.getHandlerFor(Base.class, false);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testReplaceExistingTypeHierarchyHandler() {\n-    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n-    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\", false);\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\");\n     String handler = paramMap.getHandlerFor(Base.class, false);\n     assertEquals(\"base2Handler\", handler);\n   }\n \n   public void testHidingExistingTypeHierarchyHandlerIsDisallowed() {\n-    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n     try {\n-      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n+      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n       fail(\"A handler that hides an existing type hierarchy handler is not allowed\");\n     } catch (IllegalArgumentException expected) {\n     }", "timestamp": 1321812226, "metainfo": ""}