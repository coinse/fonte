{"sha": "4c629347da72dd07610ebce89a1ec32bcf79ced6", "log": "Only support string keys in string map. This rev passed all 655 applicable map tests in the Guava collections test suite.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n   // the order in which elements are inserted. This is needed to ensure\n   // that the fields of an object are inserted in the order they were\n   // defined in the class.\n-  private final StringMap<String, JsonElement> members = new StringMap<String, JsonElement>();\n+  private final StringMap<JsonElement> members = new StringMap<JsonElement>();\n \n   /**\n    * Creates an empty JsonObject.\n--- a/gson/src/main/java/com/google/gson/internal/StringMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/StringMap.java\n  * \n  * <p>This implementation was derived from Android 4.0's LinkedHashMap.\n  */\n-public final class StringMap<K, V> extends AbstractMap<K, V> {\n-  // TODO: defend against predictable hash collisions\n-  \n+public final class StringMap<V> extends AbstractMap<String, V> {\n   /**\n    * Min capacity (other than zero) for a HashMap. Must be a power of two\n    * greater than 1 (and less than 1 << 30).\n    * The first real entry is header.nxt, and the last is header.prv.\n    * If the map is empty, header.nxt == header && header.prv == header.\n    */\n-  private LinkedEntry<K, V> header;\n+  private LinkedEntry<V> header;\n \n   /**\n    * An empty table shared by all zero-capacity maps (typically from default\n    * The hash table. If this hash map contains a mapping for null, it is\n    * not represented this hash table.\n    */\n-  private LinkedEntry<K, V>[] table;\n+  private LinkedEntry<V>[] table;\n \n   /**\n    * The number of mappings in this hash map.\n   private int threshold;\n \n   // Views - lazily initialized\n-  private Set<K> keySet;\n-  private Set<Entry<K, V>> entrySet;\n+  private Set<String> keySet;\n+  private Set<Entry<String, V>> entrySet;\n   private Collection<V> values;\n \n   @SuppressWarnings(\"unchecked\")\n   public StringMap() {\n-    table = (LinkedEntry<K, V>[]) EMPTY_TABLE;\n+    table = (LinkedEntry<V>[]) EMPTY_TABLE;\n     threshold = -1; // Forces first put invocation to replace EMPTY_TABLE\n-    header = new LinkedEntry<K, V>();\n+    header = new LinkedEntry<V>();\n   }\n \n   @Override public int size() {\n   }\n \n   @Override public boolean containsKey(Object key) {\n-    return getEntry(key) != null;\n+    return key instanceof String && getEntry((String) key) != null;\n   }\n \n   @Override public V get(Object key) {\n-    LinkedEntry<K, V> entry = getEntry(key);\n-    return entry != null ? entry.value : null;\n-  }\n-\n-  private LinkedEntry<K, V> getEntry(Object key) {\n+    if (key instanceof String) {\n+      LinkedEntry<V> entry = getEntry((String) key);\n+      return entry != null ? entry.value : null;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private LinkedEntry<V> getEntry(String key) {\n     if (key == null) {\n       return null;\n     }\n \n-    int hash = secondaryHash(key.hashCode());\n-    LinkedEntry<K, V>[] tab = table;\n-    for (LinkedEntry<K, V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n-      K eKey = e.key;\n+    int hash = hash(key);\n+    LinkedEntry<V>[] tab = table;\n+    for (LinkedEntry<V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n+      String eKey = e.key;\n       if (eKey == key || (e.hash == hash && key.equals(eKey))) {\n         return e;\n       }\n     return null;\n   }\n \n-  @Override public V put(K key, V value) {\n+  @Override public V put(String key, V value) {\n     if (key == null) {\n       throw new NullPointerException(\"key == null\");\n     }\n \n-    int hash = secondaryHash(key.hashCode());\n-    LinkedEntry<K, V>[] tab = table;\n+    int hash = hash(key);\n+    LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n-    for (LinkedEntry<K, V> e = tab[index]; e != null; e = e.next) {\n+    for (LinkedEntry<V> e = tab[index]; e != null; e = e.next) {\n       if (e.hash == hash && key.equals(e.key)) {\n         V oldValue = e.value;\n         e.value = value;\n     return null;\n   }\n \n-  private void addNewEntry(K key, V value, int hash, int index) {\n-    LinkedEntry<K, V> header = this.header;\n+  private void addNewEntry(String key, V value, int hash, int index) {\n+    LinkedEntry<V> header = this.header;\n \n     // Create new entry, link it on to list, and put it into table\n-    LinkedEntry<K, V> oldTail = header.prv;\n-    LinkedEntry<K, V> newTail = new LinkedEntry<K, V>(\n+    LinkedEntry<V> oldTail = header.prv;\n+    LinkedEntry<V> newTail = new LinkedEntry<V>(\n         key, value, hash, table[index], header, oldTail);\n     table[index] = oldTail.nxt = header.prv = newTail;\n   }\n    * Allocate a table of the given capacity and set the threshold accordingly.\n    * @param newCapacity must be a power of two\n    */\n-  private LinkedEntry<K, V>[] makeTable(int newCapacity) {\n+  private LinkedEntry<V>[] makeTable(int newCapacity) {\n     @SuppressWarnings(\"unchecked\")\n-    LinkedEntry<K, V>[] newTable = (LinkedEntry<K, V>[]) new LinkedEntry[newCapacity];\n+    LinkedEntry<V>[] newTable = (LinkedEntry<V>[]) new LinkedEntry[newCapacity];\n     table = newTable;\n     threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity\n     return newTable;\n    * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which\n    * will be new unless we were already at MAXIMUM_CAPACITY.\n    */\n-  private LinkedEntry<K, V>[] doubleCapacity() {\n-    LinkedEntry<K, V>[] oldTable = table;\n+  private LinkedEntry<V>[] doubleCapacity() {\n+    LinkedEntry<V>[] oldTable = table;\n     int oldCapacity = oldTable.length;\n     if (oldCapacity == MAXIMUM_CAPACITY) {\n       return oldTable;\n     }\n     int newCapacity = oldCapacity * 2;\n-    LinkedEntry<K, V>[] newTable = makeTable(newCapacity);\n+    LinkedEntry<V>[] newTable = makeTable(newCapacity);\n     if (size == 0) {\n       return newTable;\n     }\n        * Rehash the bucket using the minimum number of field writes.\n        * This is the most subtle and delicate code in the class.\n        */\n-      LinkedEntry<K, V> e = oldTable[j];\n+      LinkedEntry<V> e = oldTable[j];\n       if (e == null) {\n         continue;\n       }\n       int highBit = e.hash & oldCapacity;\n-      LinkedEntry<K, V> broken = null;\n+      LinkedEntry<V> broken = null;\n       newTable[j | highBit] = e;\n-      for (LinkedEntry<K, V> n = e.next; n != null; e = n, n = n.next) {\n+      for (LinkedEntry<V> n = e.next; n != null; e = n, n = n.next) {\n         int nextHighBit = n.hash & oldCapacity;\n         if (nextHighBit != highBit) {\n           if (broken == null) {\n   }\n \n   @Override public V remove(Object key) {\n-    if (key == null) {\n+    if (key == null || !(key instanceof String)) {\n       return null;\n     }\n-    int hash = secondaryHash(key.hashCode());\n-    LinkedEntry<K, V>[] tab = table;\n+    int hash = hash((String) key);\n+    LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n-    for (LinkedEntry<K, V> e = tab[index], prev = null;\n+    for (LinkedEntry<V> e = tab[index], prev = null;\n         e != null; prev = e, e = e.next) {\n       if (e.hash == hash && key.equals(e.key)) {\n         if (prev == null) {\n     return null;\n   }\n \n-  private void unlink(LinkedEntry<K, V> e) {\n+  private void unlink(LinkedEntry<V> e) {\n     e.prv.nxt = e.nxt;\n     e.nxt.prv = e.prv;\n     e.nxt = e.prv = null; // Help the GC (for performance)\n     }\n \n     // Clear all links to help GC\n-    LinkedEntry<K, V> header = this.header;\n-    for (LinkedEntry<K, V> e = header.nxt; e != header; ) {\n-      LinkedEntry<K, V> nxt = e.nxt;\n+    LinkedEntry<V> header = this.header;\n+    for (LinkedEntry<V> e = header.nxt; e != header; ) {\n+      LinkedEntry<V> nxt = e.nxt;\n       e.nxt = e.prv = null;\n       e = nxt;\n     }\n     header.nxt = header.prv = header;\n   }\n \n-  @Override public Set<K> keySet() {\n-    Set<K> ks = keySet;\n+  @Override public Set<String> keySet() {\n+    Set<String> ks = keySet;\n     return (ks != null) ? ks : (keySet = new KeySet());\n   }\n \n     return (vs != null) ? vs : (values = new Values());\n   }\n \n-  public Set<Entry<K, V>> entrySet() {\n-    Set<Entry<K, V>> es = entrySet;\n+  public Set<Entry<String, V>> entrySet() {\n+    Set<Entry<String, V>> es = entrySet;\n     return (es != null) ? es : (entrySet = new EntrySet());\n   }\n \n-  static class LinkedEntry<K, V> implements Entry<K, V> {\n-    final K key;\n+  static class LinkedEntry<V> implements Entry<String, V> {\n+    final String key;\n     V value;\n     final int hash;\n-    LinkedEntry<K, V> next;\n-    LinkedEntry<K, V> nxt;\n-    LinkedEntry<K, V> prv;\n+    LinkedEntry<V> next;\n+    LinkedEntry<V> nxt;\n+    LinkedEntry<V> prv;\n \n     /** Create the header entry */\n     LinkedEntry() {\n       nxt = prv = this;\n     }\n \n-    LinkedEntry(K key, V value, int hash, LinkedEntry<K, V> next,\n-        LinkedEntry<K, V> nxt, LinkedEntry<K, V> prv) {\n+    LinkedEntry(String key, V value, int hash, LinkedEntry<V> next,\n+        LinkedEntry<V> nxt, LinkedEntry<V> prv) {\n       this.key = key;\n       this.value = value;\n       this.hash = hash;\n       this.prv = prv;\n     }\n \n-    public final K getKey() {\n+    public final String getKey() {\n       return key;\n     }\n \n    * exists; otherwise, returns does nothing and returns false.\n    */\n   private boolean removeMapping(Object key, Object value) {\n-    if (key == null) {\n+    if (key == null || !(key instanceof String)) {\n       return false;\n     }\n \n-    int hash = secondaryHash(key.hashCode());\n-    LinkedEntry<K, V>[] tab = table;\n+    int hash = hash((String) key);\n+    LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n-    for (LinkedEntry<K, V> e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n+    for (LinkedEntry<V> e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n       if (e.hash == hash && key.equals(e.key)) {\n         if (value == null ? e.value != null : !value.equals(e.value)) {\n           return false;  // Map has wrong value for key\n   }\n \n   private abstract class LinkedHashIterator<T> implements Iterator<T> {\n-    LinkedEntry<K, V> next = header.nxt;\n-    LinkedEntry<K, V> lastReturned = null;\n+    LinkedEntry<V> next = header.nxt;\n+    LinkedEntry<V> lastReturned = null;\n \n     public final boolean hasNext() {\n       return next != header;\n     }\n \n-    final LinkedEntry<K, V> nextEntry() {\n-      LinkedEntry<K, V> e = next;\n+    final LinkedEntry<V> nextEntry() {\n+      LinkedEntry<V> e = next;\n       if (e == header) {\n         throw new NoSuchElementException();\n       }\n     }\n   }\n \n-  private final class KeySet extends AbstractSet<K> {\n-    public Iterator<K> iterator() {\n-      return new LinkedHashIterator<K>() {\n-        public final K next() {\n+  private final class KeySet extends AbstractSet<String> {\n+    public Iterator<String> iterator() {\n+      return new LinkedHashIterator<String>() {\n+        public final String next() {\n           return nextEntry().key;\n         }\n       };\n     }\n   }\n \n-  private final class EntrySet extends AbstractSet<Entry<K, V>> {\n-    public Iterator<Entry<K, V>> iterator() {\n-      return new LinkedHashIterator<Map.Entry<K, V>>() {\n-        public final Map.Entry<K, V> next() {\n+  private final class EntrySet extends AbstractSet<Entry<String, V>> {\n+    public Iterator<Entry<String, V>> iterator() {\n+      return new LinkedHashIterator<Map.Entry<String, V>>() {\n+        public final Map.Entry<String, V> next() {\n           return nextEntry();\n         }\n       };\n     }\n   }\n \n-  /**\n-   * Applies a supplemental hash function to a given hashCode, which defends\n-   * against poor quality hash functions. This is critical because HashMap\n-   * uses power-of-two length hash tables, that otherwise encounter collisions\n-   * for hashCodes that do not differ in lower or upper bits.\n-   */\n-  private static int secondaryHash(int h) {\n-    // Doug Lea's supplemental hash function\n+  private static int hash(String key) {\n+    // TODO: use an unpredictable hash function\n+\n+    int h = 0;\n+    for (int i = 0; i < key.length(); i++) {\n+      h = 31 * h + key.charAt(i);\n+    }\n+\n+    /*\n+     * Apply Doug Lea's supplemental hash function to avoid collisions for\n+     * hashes that do not differ in lower or upper bits.\n+     */\n     h ^= (h >>> 20) ^ (h >>> 12);\n     return h ^ (h >>> 7) ^ (h >>> 4);\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n       return list;\n \n     case BEGIN_OBJECT:\n-      // TODO: string map doesn't support null values\n-      Map<String, Object> map = new StringMap<String, Object>();\n+      Map<String, Object> map = new StringMap<Object>();\n       in.beginObject();\n       while (in.hasNext()) {\n         map.put(in.nextName(), read(in));", "timestamp": 1331487286, "metainfo": ""}