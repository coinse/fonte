{"sha": "f777a192ee13fd59048aa7ba640cc8023051c89d", "log": "Remove dead code and fold contents of single-member helper classes into their clients.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n     serializeExclusionStrategies.add(Gson.DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\n \n     // setup default values\n-    ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS;\n+    ignoreVersionsAfter = VersionExclusionStrategy.IGNORE_VERSIONS;\n     serializeInnerClasses = true;\n     prettyPrinting = false;\n     escapeHtmlChars = true;\n       deserializationStrategies.add(innerClassExclusionStrategy);\n       serializationStrategies.add(innerClassExclusionStrategy);\n     }\n-    if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n+    if (ignoreVersionsAfter != VersionExclusionStrategy.IGNORE_VERSIONS) {\n       VersionExclusionStrategy versionExclusionStrategy =\n           new VersionExclusionStrategy(ignoreVersionsAfter);\n       deserializationStrategies.add(versionExclusionStrategy);\n--- a/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n  * @author Joel Leitch\n  */\n final class JsonDeserializerExceptionWrapper<T> implements JsonDeserializer<T> {\n-\n   private final JsonDeserializer<T> delegate;\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonIOException.java\n+++ b/gson/src/main/java/com/google/gson/JsonIOException.java\n  * @author Joel Leitch\n  */\n public final class JsonIOException extends JsonParseException {\n-\n   private static final long serialVersionUID = 1L;\n \n   public JsonIOException(String msg) {\n--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java\n  * @since 1.4\n  */\n public final class JsonStreamParser implements Iterator<JsonElement> {\n-\n   private final JsonReader parser;\n   private final Object lock;\n \n--- a/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n \n   public enum LetterModifier {\n     UPPER,\n-    LOWER;\n+    LOWER\n   }\n \n   private final LetterModifier letterModifier;\n--- a/gson/src/main/java/com/google/gson/SyntheticFieldExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/SyntheticFieldExclusionStrategy.java\n   public boolean shouldSkipField(FieldAttributes f) {\n     return skipSyntheticFields && f.isSynthetic();\n   }\n-\n }\n--- a/gson/src/main/java/com/google/gson/UpperCamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/UpperCamelCaseSeparatorNamingPolicy.java\n  * @author Joel Leitch\n  */\n final class UpperCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {\n-\n   public UpperCamelCaseSeparatorNamingPolicy(String separatorString) {\n     super(new CamelCaseSeparatorNamingPolicy(separatorString),\n         new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER));\n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n  * @author Joel Leitch\n  */\n final class VersionExclusionStrategy implements ExclusionStrategy {\n+  static final double IGNORE_VERSIONS = -1D;\n   private final double version;\n \n   VersionExclusionStrategy(double version) {\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java\n       throw new IllegalArgumentException();\n     }\n   }\n-\n-  public static void checkState(boolean condition) {\n-    if (!condition) {\n-      throw new IllegalStateException();\n-    }\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n   }\n \n   /**\n-   * Returns true if this type is an array.\n-   */\n-  public static boolean isArray(Type type) {\n-    return type instanceof GenericArrayType\n-        || (type instanceof Class && ((Class<?>) type).isArray());\n-  }\n-\n-  /**\n    * Returns the component type of this array type.\n    * @throws ClassCastException if this type is not an array.\n    */\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n \n       Type componentType = $Gson$Types.getArrayComponentType(type);\n       TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));\n-      // create() doesn't define a type parameter\n-      TypeAdapter<T> result = new ArrayTypeAdapter(\n+      return new ArrayTypeAdapter(\n           context, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n-      return result;\n     }\n   };\n \n   @SuppressWarnings(\"unchecked\")\n   @Override public void write(JsonWriter writer, Object array) throws IOException {\n     if (array == null) {\n-      writer.nullValue(); // TODO: better policy here?\n+      writer.nullValue();\n       return;\n     }\n \n     writer.beginArray();\n     for (int i = 0, length = Array.getLength(array); i < length; i++) {\n-      final E value = (E) Array.get(array, i);\n+      E value = (E) Array.get(array, i);\n       componentTypeAdapter.write(writer, value);\n     }\n     writer.endArray();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java\n     }\n \n     return new TypeAdapter<T>() {\n-      /**\n-       * The delegate is lazily created because it may not be needed, and\n-       * creating it may fail.\n-       */\n+      /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n       private TypeAdapter<T> delegate;\n \n       @Override public T read(JsonReader reader) throws IOException {\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n \n     public void write(JsonWriter writer, Map<K, V> map) throws IOException {\n       if (map == null) {\n-        writer.nullValue(); // TODO: better policy here?\n+        writer.nullValue();\n         return;\n       }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n   @SuppressWarnings(\"unchecked\")\n   @Override public void write(JsonWriter writer, Object value) throws IOException {\n     if (value == null) {\n-      writer.nullValue(); // TODO: better policy here?\n+      writer.nullValue();\n       return;\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n-\n   private final Gson context;\n   private final TypeAdapter<T> delegate;\n   private final Type type;\n     // Fourth preference: reflective type adapter for the declared type\n \n     TypeAdapter chosen = delegate;\n-    Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(type, value);\n+    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);\n     if (runtimeType != type) {\n       TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));\n       if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n     }\n     chosen.write(writer, value);\n   }\n+\n+  /**\n+   * Finds a compatible runtime type if it is more specific\n+   */\n+  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\n+    if (value != null\n+        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\n+      type = value.getClass();\n+    }\n+    return type;\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n     }\n   };\n \n-  public static final TypeAdapter.Factory LONG_FACTORY\n-      = newFactory(long.class, Long.class, LONG);\n-\n   public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n     @Override\n     public Number read(JsonReader reader) throws IOException {\n     }\n   };\n \n-  public static final TypeAdapter.Factory FLOAT_FACTORY\n-      = newFactory(float.class, Float.class, FLOAT);\n-\n   public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n     @Override\n     public Number read(JsonReader reader) throws IOException {\n       writer.value(value);\n     }\n   };\n-\n-  public static final TypeAdapter.Factory DOUBLE_FACTORY\n-      = newFactory(double.class, Double.class, DOUBLE);\n \n   public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n     @Override\n         reader.nextNull();\n         return null;\n       }\n-      return (T) Enum.valueOf((Class<T>) classOfT, reader.nextString());\n+      return Enum.valueOf(classOfT, reader.nextString());\n     }\n \n     public void write(JsonWriter writer, T value) throws IOException {\n       writer.value(value == null ? null : value.name());\n     }\n-  };\n+  }\n \n   public static final TypeAdapter.Factory ENUM_FACTORY = newEnumTypeHierarchyFactory(Enum.class);\n \n       }\n     };\n   }\n-\n }\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n  * @author Jesse Wilson\n  */\n public class TypeToken<T> {\n-\n   final Class<? super T> rawType;\n   final Type type;\n   final int hashCode;", "timestamp": 1321822946, "metainfo": ""}