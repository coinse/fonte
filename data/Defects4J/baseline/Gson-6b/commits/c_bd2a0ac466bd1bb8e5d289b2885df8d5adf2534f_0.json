{"sha": "bd2a0ac466bd1bb8e5d289b2885df8d5adf2534f", "log": "Support JsonReader API on DOM objects.  This still needs test coverage & documentation but it appears to work!", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ *\n+ */\n+public final class JsonElementReader extends JsonReader {\n+  private static final Reader UNREADABLE_READER = new Reader() {\n+    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n+      throw new AssertionError();\n+    }\n+    @Override public void close() throws IOException {\n+      throw new AssertionError();\n+    }\n+  };\n+\n+  private final List<Object> stack = new ArrayList<Object>();\n+\n+  /**\n+   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n+   */\n+  public JsonElementReader(JsonElement element) {\n+    super(UNREADABLE_READER);\n+    stack.add(element);\n+  }\n+\n+  @Override public void beginArray() throws IOException {\n+    expect(JsonToken.BEGIN_ARRAY);\n+    JsonArray array = (JsonArray) peekStack();\n+    stack.add(array.iterator());\n+  }\n+\n+  @Override public void endArray() throws IOException {\n+    expect(JsonToken.END_ARRAY);\n+    popStack(); // empty iterator\n+    popStack(); // array\n+  }\n+\n+  @Override public void beginObject() throws IOException {\n+    expect(JsonToken.BEGIN_OBJECT);\n+    JsonObject object = (JsonObject) peekStack();\n+    stack.add(object.entrySet().iterator());\n+  }\n+\n+  @Override public void endObject() throws IOException {\n+    expect(JsonToken.END_OBJECT);\n+    popStack(); // empty iterator\n+    popStack(); // object\n+  }\n+\n+  @Override public boolean hasNext() throws IOException {\n+    JsonToken token = peek();\n+    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n+  }\n+\n+  @Override public JsonToken peek() throws IOException {\n+    if (stack.isEmpty()) {\n+      return JsonToken.END_DOCUMENT;\n+    }\n+\n+    Object o = peekStack();\n+    if (o instanceof Iterator) {\n+      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n+      Iterator<?> iterator = (Iterator<?>) o;\n+      if (iterator.hasNext()) {\n+        if (isObject) {\n+          return JsonToken.NAME;\n+        } else {\n+          stack.add(iterator.next());\n+          return peek();\n+        }\n+      } else {\n+        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+      }\n+    } else if (o instanceof JsonObject) {\n+      return JsonToken.BEGIN_OBJECT;\n+    } else if (o instanceof JsonArray) {\n+      return JsonToken.BEGIN_ARRAY;\n+    } else if (o instanceof JsonPrimitive) {\n+      JsonPrimitive primitive = (JsonPrimitive) o;\n+      if (primitive.isString()) {\n+        return JsonToken.STRING;\n+      } else if (primitive.isBoolean()) {\n+        return JsonToken.BOOLEAN;\n+      } else if (primitive.isNumber()) {\n+        return JsonToken.NUMBER;\n+      } else {\n+        throw new AssertionError();\n+      }\n+    } else if (o instanceof JsonNull) {\n+      return JsonToken.NULL;\n+    } else {\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  private Object peekStack() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  private Object popStack() {\n+    return stack.remove(stack.size() - 1);\n+  }\n+\n+  private void expect(JsonToken expected) throws IOException {\n+    if (peek() != expected) {\n+      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+    }\n+  }\n+\n+  @Override public String nextName() throws IOException {\n+    expect(JsonToken.NAME);\n+    Iterator<?> i = (Iterator) peekStack();\n+    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+    stack.add(entry.getValue());\n+    return (String) entry.getKey();\n+  }\n+\n+  @Override public String nextString() throws IOException {\n+    expect(JsonToken.STRING);\n+    return ((JsonPrimitive) popStack()).getAsString();\n+  }\n+\n+  @Override public boolean nextBoolean() throws IOException {\n+    expect(JsonToken.BOOLEAN);\n+    return ((JsonPrimitive) popStack()).getAsBoolean();\n+  }\n+\n+  @Override public void nextNull() throws IOException {\n+    expect(JsonToken.NULL);\n+    popStack();\n+  }\n+\n+  @Override public double nextDouble() throws IOException {\n+    expect(JsonToken.NUMBER);\n+    return ((JsonPrimitive) popStack()).getAsDouble();\n+  }\n+\n+  @Override public long nextLong() throws IOException {\n+    expect(JsonToken.NUMBER);\n+    return ((JsonPrimitive) popStack()).getAsLong();\n+  }\n+\n+  @Override public int nextInt() throws IOException {\n+    expect(JsonToken.NUMBER);\n+    return ((JsonPrimitive) popStack()).getAsInt();\n+  }\n+\n+  @Override public void close() throws IOException {\n+  }\n+\n+  @Override public void skipValue() throws IOException {\n+    if (peek() == JsonToken.NAME) {\n+      nextName();\n+    } else {\n+      popStack();\n+    }\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName();\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n  * @author Jesse Wilson\n  * @since 1.6\n  */\n-public final class JsonReader implements Closeable {\n+public class JsonReader implements Closeable {\n \n   /** The only non-execute prefix this parser permits */\n   private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n    *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n    * </ul>\n    */\n-  public void setLenient(boolean lenient) {\n+  public final void setLenient(boolean lenient) {\n     this.lenient = lenient;\n   }\n \n   /**\n    * Returns true if this parser is liberal in what it accepts.\n    */\n-  public boolean isLenient() {\n+  public final boolean isLenient() {\n     return lenient;\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParser;\n+import com.google.gson.stream.JsonToken;\n+import java.io.IOException;\n+import junit.framework.TestCase;\n+\n+public final class JsonElementReaderTest extends TestCase {\n+\n+  public void testArray() throws IOException {\n+    JsonElement array = new JsonParser().parse(\"[1, 2, 3]\");\n+    JsonElementReader reader = new JsonElementReader(array);\n+    assertEquals(JsonToken.BEGIN_ARRAY, reader.peek());\n+    reader.beginArray();\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    assertEquals(1, reader.nextInt());\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    assertEquals(2, reader.nextInt());\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    assertEquals(3, reader.nextInt());\n+    assertEquals(JsonToken.END_ARRAY, reader.peek());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testObject() throws IOException {\n+    JsonElement array = new JsonParser().parse(\"{\\\"A\\\": 1, \\\"B\\\": 2}\");\n+    JsonElementReader reader = new JsonElementReader(array);\n+    assertEquals(JsonToken.BEGIN_OBJECT, reader.peek());\n+    reader.beginObject();\n+    assertEquals(JsonToken.NAME, reader.peek());\n+    assertEquals(\"A\", reader.nextName());\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    assertEquals(1, reader.nextInt());\n+    assertEquals(JsonToken.NAME, reader.peek());\n+    assertEquals(\"B\", reader.nextName());\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    assertEquals(2, reader.nextInt());\n+    assertEquals(JsonToken.END_OBJECT, reader.peek());\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testEmptyArray() throws IOException {\n+    JsonElement array = new JsonParser().parse(\"[]\");\n+    JsonElementReader reader = new JsonElementReader(array);\n+    reader.beginArray();\n+    reader.endArray();\n+  }\n+\n+  public void testEmptyObject() throws IOException {\n+    JsonElement array = new JsonParser().parse(\"{}\");\n+    JsonElementReader reader = new JsonElementReader(array);\n+    reader.beginObject();\n+    reader.endObject();\n+  }\n+\n+  // TODO: more test coverage\n+}", "timestamp": 1317343477, "metainfo": ""}