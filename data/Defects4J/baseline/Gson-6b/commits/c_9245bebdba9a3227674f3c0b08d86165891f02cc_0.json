{"sha": "9245bebdba9a3227674f3c0b08d86165891f02cc", "log": "For the Collection and Map types, using ObjectConstructor to create instance instead of hard-coding a specific type.  This helps is handling cases where the user is using their own subclass of Collection or Map.  Updated ParameterizedTypeHandlerMap to return the handler corresponding to Map and Collection for subclasses if user has not specified a specific handler.  Fixed the logic in JsonTreeNavigator to not output a comma if the first field of an object was null.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n import java.util.Iterator;\n   }\n \n   @SuppressWarnings({ \"unchecked\" })\n-  private static class CollectionTypeAdapter implements JsonSerializer<Collection>, JsonDeserializer<Collection>, InstanceCreator<Collection> {\n+  private static class CollectionTypeAdapter implements JsonSerializer<Collection>, \n+  JsonDeserializer<Collection>, InstanceCreator<Collection> {\n \n     public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) {\n       if (src == null) {\n       return array;\n     }\n \n-    public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-        throws JsonParseException {\n+    public Collection deserialize(JsonElement json, Type typeOfT, \n+        JsonDeserializationContext context) throws JsonParseException {\n       if (json.isJsonNull()) {\n         return null;\n       }\n-      // Using list to preserve order in which elements are entered\n-      List<Object> list = new LinkedList<Object>();\n+      // Use ObjectConstructor to create instance instead of hard-coding a specific type. \n+      // This handles cases where users are using their own subclass of Collection.\n+      Collection collection = constructCollectionType(typeOfT, context);\n       Type childType = new TypeInfoCollection(typeOfT).getElementType();\n       for (JsonElement childElement : json.getAsJsonArray()) {\n-        Object value = context.deserialize(childElement, childType);\n-        list.add(value);\n-      }\n-      return list;\n+        if (childElement == null || childElement.isJsonNull()) {\n+          collection.add(null);\n+        } else {\n+          Object value = context.deserialize(childElement, childType);\n+          collection.add(value);\n+        }\n+      }\n+      return collection;\n+    }\n+\n+    private Collection constructCollectionType(Type collectionType, \n+        JsonDeserializationContext context) {      \n+      JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context;\n+      ObjectConstructor objectConstructor = contextImpl.getObjectConstructor();\n+      return (Collection) objectConstructor.construct(collectionType);\n     }\n \n     public Collection createInstance(Type type) {\n   @SuppressWarnings(\"unchecked\")\n   static class MapTypeAdapter implements JsonSerializer<Map>, JsonDeserializer<Map>,\n       InstanceCreator<Map> {\n+    \n     public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) {\n       JsonObject map = new JsonObject();\n       Type childGenericType = null;\n       }\n       return map;\n     }\n+\n     public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n-      // Using linked hash map to preserve order in which elements are entered\n-      Map<String, Object> map = new LinkedHashMap<String, Object>();\n+      // Use ObjectConstructor to create instance instead of hard-coding a specific type. \n+      // This handles cases where users are using their own subclass of Map.\n+      Map<String, Object> map = constructMapType(typeOfT, context);\n       Type childType = new TypeInfoMap(typeOfT).getValueType();\n       for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n         Object value = context.deserialize(entry.getValue(), childType);\n       }\n       return map;\n     }\n+\n+    private Map constructMapType(Type mapType, JsonDeserializationContext context) {      \n+      JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context;\n+      ObjectConstructor objectConstructor = contextImpl.getObjectConstructor();\n+      return (Map) objectConstructor.construct(mapType);\n+    }\n+    \n     public Map createInstance(Type type) {\n       return new LinkedHashMap();\n     }\n+    \n     @Override\n     public String toString() {\n       return MapTypeAdapter.class.getSimpleName();\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n     this.deserializers = deserializers;\n     this.objectConstructor = objectConstructor;\n     this.typeAdapter = typeAdapter;\n+  }\n+\n+  ObjectConstructor getObjectConstructor() {\n+    return objectConstructor;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n \n   @SuppressWarnings(\"unchecked\")\n   public final boolean visitUsingCustomHandler(Object obj, Type objType) {\n-    JsonDeserializer deserializer = (JsonDeserializer) deserializers.getHandlerFor(objType);\n-    if (deserializer == null) {\n-      if (objType instanceof Map) {\n-        deserializer = deserializers.getHandlerFor(Map.class);\n-      } else if (objType instanceof Collection) {\n-        deserializer = deserializers.getHandlerFor(Collection.class);\n-      }\n-    }\n+    JsonDeserializer deserializer = deserializers.getHandlerFor(objType);\n     if (deserializer != null) {\n       target = (T) deserializer.deserialize(json, objType, context);\n       return true;\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   @SuppressWarnings(\"unchecked\")\n   public boolean visitUsingCustomHandler(Object obj, Type objType) {\n     JsonSerializer serializer = serializers.getHandlerFor(objType);\n-    if (serializer == null) {\n-      if (obj instanceof Map) {\n-        serializer = serializers.getHandlerFor(Map.class);\n-      } else if (obj instanceof Collection) {\n-        serializer = serializers.getHandlerFor(Collection.class);\n-      }\n-    }\n+//    if (serializer == null) {\n+//      if (obj instanceof Map) {\n+//        serializer = serializers.getHandlerFor(Map.class);\n+//      } else if (obj instanceof Collection) {\n+//        serializer = serializers.getHandlerFor(Collection.class);\n+//      }\n+//    }\n     if (serializer != null) {\n       if (obj == null) {\n         assignToRoot(JsonNull.INSTANCE);\n--- a/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n+++ b/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n       visitor.startObject(object);\n       boolean isFirst = true;\n       for (Map.Entry<String, JsonElement> member : object.entrySet()) {\n-        visitChild(object, member.getKey(), member.getValue(), isFirst);\n-        if (isFirst) {\n+        boolean visited = visitChild(object, member.getKey(), member.getValue(), isFirst);\n+        if (visited && isFirst) {\n           isFirst = false;\n         }\n       }\n     }    \n   }\n \n-  private void visitChild(JsonObject parent, String childName, JsonElement child, boolean isFirst) {\n+  /**\n+   * Returns true if the child was visited, false if it was skipped.\n+   */\n+  private boolean visitChild(JsonObject parent, String childName, JsonElement child, \n+      boolean isFirst) {\n     if (child != null) { \n       if (child.isJsonNull()) {\n         if (visitNulls) {\n           visitor.visitNullObjectMember(parent, childName, isFirst);\n           navigate(child.getAsJsonNull());\n+        } else { // Null value is being skipped.\n+          return false;\n         }\n       } else if (child.isJsonArray()) {\n         JsonArray childAsArray = child.getAsJsonArray();\n         visitor.visitObjectMember(parent, childName, child.getAsJsonPrimitive(), isFirst);          \n       }\n     }\n+    return true;\n   }\n \n+  /**\n+   * Returns true if the child was visited, false if it was skipped.\n+   */\n   private void visitChild(JsonArray parent, JsonElement child, boolean isFirst) {\n     if (child == null || child.isJsonNull()) {\n       visitor.visitNullArrayMember(parent, isFirst);\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Set;\n   }\n \n   public synchronized T getHandlerFor(Type type) {\n+    T handler = getRawHandlerFor(type);\n+    Type rawType = type;\n+    if (handler == null && type instanceof ParameterizedType) {\n+      // a handler for a non-generic version may be registered, so use that\n+      rawType = ((ParameterizedType)type).getRawType();\n+      handler = map.get(rawType);\n+    }\n+    // Check for map or collection \n+    if (handler == null) {\n+      if (rawType instanceof Class) {\n+        Class<?> rawClass = (Class<?>) rawType;\n+        if (Map.class.isAssignableFrom(rawClass)) {\n+          handler = map.get(Map.class);\n+        } else if (Collection.class.isAssignableFrom(rawClass)) {\n+          handler = map.get(Collection.class);\n+        }\n+      }\n+    }\n+    return handler;\n+  }\n+  \n+  private synchronized T getRawHandlerFor(Type type) {\n     T handler = map.get(type);\n-    if (handler == null && type instanceof ParameterizedType) {\n-      // a handler for a non-generic version is registered, so use that\n-      Type rawType = ((ParameterizedType)type).getRawType();\n-      handler = map.get(rawType);\n+    if (type instanceof Map) {\n+      handler = map.get(Map.class);\n+    } else if (type instanceof Collection) {\n+      handler = map.get(Collection.class);\n     }\n     return handler;\n   }\n--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Queue;\n \n /**\n  * Functional tests for Json serialization and deserialization of collections.\n     for (int i = 0; i < 3; i++) {\n       MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));\n     }\n+  }\n+  \n+  public void testLinkedListSerialization() {\n+    List<String> list = new LinkedList<String>();\n+    list.add(\"a1\");\n+    list.add(\"a2\");\n+    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();\n+    String json = gson.toJson(list, linkedListType);\n+    assertTrue(json.contains(\"a1\"));\n+    assertTrue(json.contains(\"a2\"));\n+  }\n+\n+  public void testLinkedListDeserialization() {\n+    String json = \"['a1','a2']\";\n+    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();\n+    List<String> list = gson.fromJson(json, linkedListType);\n+    assertEquals(\"a1\", list.get(0));\n+    assertEquals(\"a2\", list.get(1));\n+  }\n+\n+  public void testQueueSerialization() {\n+    Queue<String> queue = new LinkedList<String>();\n+    queue.add(\"a1\");\n+    queue.add(\"a2\");\n+    Type queueType = new TypeToken<Queue<String>>() {}.getType();\n+    String json = gson.toJson(queue, queueType);\n+    assertTrue(json.contains(\"a1\"));\n+    assertTrue(json.contains(\"a2\"));\n+  }\n+\n+  public void testQueueDeserialization() {\n+    String json = \"['a1','a2']\";\n+    Type queueType = new TypeToken<Queue<String>>() {}.getType();\n+    Queue<String> queue = gson.fromJson(json, queueType);\n+    assertEquals(\"a1\", queue.element()); \n+    queue.remove();\n+    assertEquals(\"a2\", queue.element());\n   }\n \n   public void testNullsInListSerialization() {\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n     String json = gson.toJson(map, typeOfMap);\n     assertEquals(\"{}\", json);\n   }\n+\n+  public void testParameterizedMapSubclassSerialization() {\n+    MyParameterizedMap<String, String> map = new MyParameterizedMap<String, String>();\n+    map.put(\"a\", \"b\");\n+    Type type = new TypeToken<MyParameterizedMap<String, String>>() {}.getType();\n+    String json = gson.toJson(map, type);\n+    assertTrue(json.contains(\"\\\"a\\\":\\\"b\\\"\"));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testParameterizedMapSubclassDeserialization() {\n+    Type type = new TypeToken<MyParameterizedMap<String, Integer>>() {}.getType();\n+    Gson gson = new GsonBuilder().registerTypeAdapter(type, \n+        new InstanceCreator<MyParameterizedMap>() {\n+      public MyParameterizedMap createInstance(Type type) {\n+        return new MyParameterizedMap();\n+      }      \n+    }).create();\n+    String json = \"{\\\"a\\\":1,\\\"b\\\":2}\";\n+    MyParameterizedMap<String, Integer> map = gson.fromJson(json, type);\n+    assertEquals(1, ((Integer) map.get(\"a\")).intValue()); \n+    assertEquals(2, ((Integer) map.get(\"b\")).intValue()); \n+  }\n+\n+  private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {\n+    int foo = 10;\n+  }\n   \n   public void testMapSubclassSerialization() {\n     MyMap map = new MyMap();\n     map.put(\"a\", \"b\");\n-    String json = gson.toJson(map);\n+    String json = gson.toJson(map, MyMap.class);\n     assertTrue(json.contains(\"\\\"a\\\":\\\"b\\\"\"));\n   }\n   \n--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n   }\n \n   @SuppressWarnings(\"unchecked\")\n+  public void testParameterizedTypeGenericArraysSerialization() throws Exception {\n+    List<Integer> list = new ArrayList<Integer>();\n+    list.add(1);\n+    list.add(2);\n+    List<Integer>[] arrayOfLists = new List[] { list, list };\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    assertEquals(\"{\\\"arrayOfListOfTypeParameters\\\":[[1,2],[1,2]]}\", json);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n   public void testParameterizedTypeGenericArraysDeserialization() throws Exception {\n     List<Integer> list = new ArrayList<Integer>();\n     list.add(1);", "timestamp": 1226628706, "metainfo": ""}