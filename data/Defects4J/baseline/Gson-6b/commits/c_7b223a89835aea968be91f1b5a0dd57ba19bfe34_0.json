{"sha": "7b223a89835aea968be91f1b5a0dd57ba19bfe34", "log": "Adding JavaDoc to the enableComplexMapKeySerialization method on GsonBuilder.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n  * <pre>\n  * Gson gson = new GsonBuilder()\n  *     .registerTypeAdapter(Id.class, new IdTypeAdapter())\n+ *     .enableComplexMapKeySerialization()\n  *     .serializeNulls()\n  *     .setDateFormat(DateFormat.LONG)\n  *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n     return this;\n   }\n   \n+  /**\n+   * Enabling this feature will only change the serialized form if the map key is\n+   * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON\n+   * form. The default implementation of map serialization uses {@code toString()}\n+   * on the key; however, when this is called then one of the following cases\n+   * apply:\n+   *\n+   * <h3>Maps as JSON objects</h3>\n+   * For this case, assume that a type adapter is registered to serialize and\n+   * deserialize some {@code Point} class, which contains an x and y coordinate,\n+   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would \n+   * then be serialized as a {@link JsonObject}.\n+   * \n+   * <p>Below is an example:\n+   * <pre>  {@code\n+   *   Gson gson = new GsonBuilder()\n+   *       .register(Point.class, new MyPointTypeAdapter())\n+   *       .enableComplexMapKeySerialization()\n+   *       .create();\n+   *\n+   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n+   *   original.put(new Point(5, 6), \"a\");\n+   *   original.put(new Point(8, 8), \"b\");\n+   *   System.out.println(gson.toJson(original, type));\n+   * }</pre>\n+   * The above code prints this JSON object:<pre>  {@code\n+   *   {\n+   *     \"(5,6)\": \"a\",\n+   *     \"(8,8)\": \"b\"\n+   *   }\n+   * }</pre>\n+   *\n+   * <h3>Maps as JSON arrays</h3>\n+   * For this case, assume that a type adapter was NOT registered for some\n+   * {@code Point} class, but rather the default Gson serialization is applied.\n+   * In this case, some {@code new Point(2,3)} would serialize as {@code\n+   * {\"x\":2,\"y\":5}}.\n+   * \n+   * <p>Given the assumption above, a {@code Map<Point, String>} will be\n+   * serialize as an array of arrays (can be viewed as an entry set of pairs).\n+   * \n+   * <p>Below is an example of serializing complex types as JSON arrays:\n+   * <pre> {@code\n+   *   Gson gson = new GsonBuilder()\n+   *       .enableComplexMapKeySerialization()\n+   *       .create();\n+   *\n+   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n+   *   original.put(new Point(5, 6), \"a\");\n+   *   original.put(new Point(8, 8), \"b\");\n+   *   System.out.println(gson.toJson(original, type));\n+   * }\n+   * \n+   * The JSON output would look as follows:\n+   * <pre>   {@code\n+   *   [\n+   *     [\n+   *       {\n+   *         \"x\": 5,\n+   *         \"y\": 6\n+   *       },\n+   *       \"a\",\n+   *     ],\n+   *     [\n+   *       {\n+   *         \"x\": 8,\n+   *         \"y\": 8\n+   *       },\n+   *       \"b\"\n+   *     ]\n+   *   ]\n+   * }</pre>\n+   * \n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.7\n+   */\n   public GsonBuilder enableComplexMapKeySerialization() {\n     registerTypeHierarchyAdapter(Map.class, COMPLEX_KEY_MAP_TYPE_ADAPTER);\n     return this;", "timestamp": 1300259124, "metainfo": ""}