{"sha": "d1ddab2e6ffcd938ac0d133fd46caf5fb2417009", "log": "Swap out GSON's type mechanics with the Type resolution code from Guice.  The most significant impact of this change is that fields whose types are type parameters should now GSONify just fine. For example, consider the class below.  abstract class Foo<A, B> {    A a;    B b;    List<A> list;    Map<A, List<B>> map; } class RealFoo extends Foo<String, Integer> {...}  This is a reasonable checkpoint but some work still needs to be done for this. In particular, the level of visibility of methods in TypeToken and Type should be reconsidered; we're exposing more than we need to!", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n       JsonArray array = new JsonArray();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = new TypeInfoCollection(typeOfSrc).getElementType();\n+        childGenericType = TypeToken.get(typeOfSrc).getCollectionElementType();\n       }\n       for (Object child : src) {\n         if (child == null) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Collection.\n       Collection collection = constructCollectionType(typeOfT, context);\n-      Type childType = new TypeInfoCollection(typeOfT).getElementType();\n+      Type childType = TypeToken.get(typeOfT).getCollectionElementType();\n       for (JsonElement childElement : json.getAsJsonArray()) {\n         if (childElement == null || childElement.isJsonNull()) {\n           collection.add(null);\n       JsonObject map = new JsonObject();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = new TypeInfoMap(typeOfSrc).getValueType();\n+        childGenericType = TypeToken.get(typeOfSrc).getMapKeyAndValueTypes()[1];\n       }\n \n       for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Map.\n       Map<Object, Object> map = constructMapType(typeOfT, context);\n-      TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT);\n+      Type[] keyAndValueTypes = TypeToken.get(typeOfT).getMapKeyAndValueTypes();\n       for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n-        Object key = context.deserialize(new JsonPrimitive(entry.getKey()), mapTypeInfo.getKeyType());\n-        Object value = context.deserialize(entry.getValue(), mapTypeInfo.getValueType());\n+        Object key = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueTypes[0]);\n+        Object value = context.deserialize(entry.getValue(), keyAndValueTypes[1]);\n         map.put(key, value);\n       }\n       return map;\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n \n   @SuppressWarnings(\"unchecked\")\n   protected T constructTarget() {\n \n-    TypeInfo typeInfo = new TypeInfo(targetType);\n+    TypeToken typeToken = TypeToken.get(targetType);\n \n     if (!json.isJsonArray()) {\n       throw new JsonParseException(\"Expecting array found: \" + json); \n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    if (typeInfo.isArray()) {\n-      TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType);\n+    if (typeToken.isArray()) {\n       // We know that we are getting back an array of the required type, so\n       // this typecasting is safe.\n-      return (T) objectConstructor.constructArray(arrayTypeInfo.getSecondLevelType(),\n+      return (T) objectConstructor.constructArray(typeToken.getArrayComponentType(),\n           jsonArray.size());\n     }\n     // is a collection\n-    return (T) objectConstructor.construct(typeInfo.getRawClass());\n+    return (T) objectConstructor.construct(typeToken.getRawType());\n   }\n \n   public void visitArray(Object array, Type arrayType) {\n       throw new JsonParseException(\"Expecting array found: \" + json); \n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType);\n+    TypeToken typeToken = TypeToken.get(arrayType);\n     for (int i = 0; i < jsonArray.size(); i++) {\n       JsonElement jsonChild = jsonArray.get(i);\n       Object child;\n       if (jsonChild == null || jsonChild.isJsonNull()) {\n         child = null;\n       } else if (jsonChild instanceof JsonObject) {\n-        child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild);\n+        child = visitChildAsObject(typeToken.getArrayComponentType(), jsonChild);\n       } else if (jsonChild instanceof JsonArray) {\n-        child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray());\n+        child = visitChildAsArray(typeToken.getArrayComponentType(), jsonChild.getAsJsonArray());\n       } else if (jsonChild instanceof JsonPrimitive) {\n-        child = visitChildAsObject(arrayTypeInfo.getComponentRawType(),\n+        child = visitChildAsObject(typeToken.getArrayComponentType(),\n             jsonChild.getAsJsonPrimitive());\n       } else {\n         throw new IllegalStateException();\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n \n /**\n         throw new JsonParseException(\"Expecting object found: \" + json); \n       }\n       JsonElement child = json.getAsJsonObject().get(fName);\n-      TypeInfo typeInfo = new TypeInfo(declaredTypeOfField);\n+      boolean isPrimitive = TypeToken.get(declaredTypeOfField).isPrimitive();\n       if (child == null) { // Child will be null if the field wasn't present in Json\n         return true;\n       } else if (child.isJsonNull()) {\n-        if (!typeInfo.isPrimitive()) {\n+        if (!isPrimitive) {\n           f.set(parent, null);\n         }\n         return true;\n         return false;\n       }      \n       Object value = invokeCustomDeserializer(child, pair);\n-      if (value != null || !typeInfo.isPrimitive()) {\n+      if (value != null || !isPrimitive) {\n         f.set(parent, value);\n       }\n       return true;\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n \n   public void visitArray(Object array, Type arrayType) {\n     assignToRoot(new JsonArray());\n     int length = Array.getLength(array);\n-    TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType);\n-    Type componentType = fieldTypeInfo.getSecondLevelType();\n+    Type componentType = TypeToken.get(arrayType).getArrayComponentType();\n     for (int i = 0; i < length; ++i) {\n       Object child = Array.get(array, i);\n-      Type childType = componentType;\n       // we should not get more specific component type yet since it is possible\n-      // that a custom\n-      // serializer is registered for the componentType\n-      addAsArrayElement(new ObjectTypePair(child, childType, false));\n+      // that a custom serializer is registered for the componentType\n+      addAsArrayElement(new ObjectTypePair(child, componentType, false));\n     }\n   }\n \n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Array;\n import java.lang.reflect.Constructor;\n   }\n \n   public Object constructArray(Type type, int length) {\n-    return Array.newInstance(TypeUtils.toRawClass(type), length);\n+    return Array.newInstance(TypeToken.get(type).getRawType(), length);\n   }\n \n   private <T> T constructWithNoArgConstructor(Type typeOfT) {\n \n   @SuppressWarnings({\"unchecked\", \"cast\"})\n   private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) {\n-    TypeInfo typeInfo = new TypeInfo(typeOfT);\n-    Class<T> clazz = (Class<T>) typeInfo.getRawClass();\n+    Class<?> clazz = TypeToken.get(typeOfT).getRawType();\n     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors();\n     AccessibleObject.setAccessible(declaredConstructors, true);\n     for (Constructor<T> constructor : declaredConstructors) {\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n    * does not get visited.\n    */\n   public void accept(Visitor visitor) {\n-    TypeInfo objTypeInfo = new TypeInfo(objTypePair.type);\n-    if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\n+    TypeToken<?> objTypeInfo = TypeToken.get(objTypePair.type);\n+    if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawType())) {\n       return;\n     }\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n       try {\n         if (objTypeInfo.isArray()) {\n           visitor.visitArray(objectToVisit, objTypePair.type);\n-        } else if (objTypeInfo.getActualType() == Object.class\n+        } else if (objTypeInfo.getType() == Object.class\n             && isPrimitiveOrString(objectToVisit)) {\n           // TODO(Joel): this is only used for deserialization of \"primitives\"\n           // we should rethink this!!!\n         } else {\n           visitor.startVisitingObject(objectToVisit);\n           ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n-          Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass();\n+          Class<?> topLevelClass = TypeToken.get(currObjTypePair.type).getRawType();\n           for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n               curr.getSuperclass()) {\n             if (!curr.isSynthetic()) {\n           || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n         continue; // skip\n       }\n-      TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type);\n-      Type declaredTypeOfField = fieldTypeInfo.getActualType();\n+      TypeToken<?> fieldTypeToken = getTypeInfoForField(f, objTypePair.type);\n+      Type declaredTypeOfField = fieldTypeToken.getType();\n       boolean visitedWithCustomHandler =\n         visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n       if (!visitedWithCustomHandler) {\n-        if (fieldTypeInfo.isArray()) {\n+        if (fieldTypeToken.isArray()) {\n           visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n         } else {\n           visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n       }\n     }\n   }\n+\n+\n+  /**\n+   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n+   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n+   *\n+   * @param f the actual field object to retrieve the type from\n+   * @param typeDefiningF the type that contains the field {@code f}\n+   * @return the type information for the field\n+   */\n+  public static TypeToken<?> getTypeInfoForField(Field f, Type typeDefiningF) {\n+    TypeToken<?> typeToken = TypeToken.get(typeDefiningF);\n+    if (!f.getDeclaringClass().isAssignableFrom(typeToken.getRawType())) {\n+      // this field is unrelated to the type; the user probably omitted type information\n+      return TypeToken.get(f.getGenericType());\n+    }\n+    return typeToken.getFieldType(f);\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.HashMap;\n   public synchronized T getHandlerFor(Type type) {\n     T handler = map.get(type);\n     if (handler == null) {\n-      Class<?> rawClass = TypeUtils.toRawClass(type);\n+      Class<?> rawClass = TypeToken.get(type).getRawType();\n       if (rawClass != type) {\n         handler = getHandlerFor(rawClass);\n       }\n   }\n \n   private String typeToString(Type type) {\n-    return TypeUtils.toRawClass(type).getSimpleName();\n+    return TypeToken.get(type).getRawType().getSimpleName();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n package com.google.gson.reflect;\n \n-import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Represents a generic type {@code T}.\n- *\n- * You can use this class to get the generic type for a class. For example,\n- * to get the generic type for <code>Collection&lt;Foo&gt;</code>, you can use:\n+ * Represents a generic type {@code T}. Java doesn't yet provide a way to\n+ * represent generic types, so this class does. Forces clients to create a\n+ * subclass of this class which enables retrieval the type information even at\n+ * runtime.\n+ *\n+ * <p>For example, to create a type literal for {@code List<String>}, you can\n+ * create an empty anonymous inner class:\n+ *\n  * <p>\n- * <code>Type typeOfCollectionOfFoo = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType()\n- * </code>\n- * \n- * <p>Assumes {@code Type} implements {@code equals()} and {@code hashCode()}\n- * as a value (as opposed to identity) comparison.\n- *\n- * Also implements {@link #isAssignableFrom(Type)} to check type-safe\n- * assignability.\n+ * {@code TypeLiteral<List<String>> list = new TypeToken<List<String>>() {};}\n+ *\n+ * <p>This syntax cannot be used to create type literals that have wildcard\n+ * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n+ * Such type literals must be constructed programatically, either by {@link\n+ * Method#getGenericReturnType extracting types from members} or by using the\n+ * {@link Types} factory class.\n+ *\n+ * <p>Along with modeling generic types, this class can resolve type parameters.\n+ * For example, to figure out what type {@code keySet()} returns on a {@code\n+ * Map<Integer, String>}, use this code:<pre>   {@code\n+ *\n+ *   TypeLiteral<Map<Integer, String>> mapType\n+ *       = new TypeToken<Map<Integer, String>>() {};\n+ *   TypeToken<?> keySetType\n+ *       = mapType.getReturnType(Map.class.getMethod(\"keySet\"));\n+ *   System.out.println(keySetType); // prints \"Set<Integer>\"}</pre>\n  *\n  * @author Bob Lee\n  * @author Sven Mawson\n+ * @author Jesse Wilson\n  */\n-public abstract class TypeToken<T> {\n+public class TypeToken<T> {\n \n   final Class<? super T> rawType;\n   final Type type;\n-\n-  /**\n-   * Constructs a new type token. Derives represented class from type\n+  final int hashCode;\n+\n+  /**\n+   * Constructs a new type literal. Derives represented class from type\n    * parameter.\n    *\n    * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n-   * parameter in the anonymous class's type hierarchy so we can reconstitute\n-   * it at runtime despite erasure.\n-   *\n-   * <p>For example:\n-   * <code>\n-   * {@literal TypeToken<List<String>> t = new TypeToken<List<String>>}(){}\n-   * </code>\n+   * parameter in the anonymous class's type hierarchy so we can reconstitute it\n+   * at runtime despite erasure.\n    */\n   @SuppressWarnings(\"unchecked\")\n   protected TypeToken() {\n     this.type = getSuperclassTypeParameter(getClass());\n-    this.rawType = (Class<? super T>) getRawType(type);\n-  }\n-\n-  /**\n-   * Unsafe. Constructs a type token manually.\n-   */\n-  @SuppressWarnings({\"unchecked\"})\n-  private TypeToken(Type type) {\n-    this.rawType = (Class<? super T>) getRawType(nonNull(type, \"type\"));\n-    this.type = type;\n-  }\n-\n-  private static <T> T nonNull(T o, String message) {\n-    if (o == null) {\n-      throw new NullPointerException(message);\n-    }\n-    return o;\n-  }\n-  \n-  /**\n-   * Gets type from super class's type parameter.\n+    this.rawType = (Class<? super T>) Types.getRawType(type);\n+    this.hashCode = type.hashCode();\n+  }\n+\n+  /**\n+   * Unsafe. Constructs a type literal manually.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  TypeToken(Type type) {\n+    checkNotNull(type);\n+    this.type = Types.canonicalize(type);\n+    this.rawType = (Class<? super T>) Types.getRawType(this.type);\n+    this.hashCode = this.type.hashCode();\n+  }\n+\n+  /**\n+   * Returns the type from super class's type parameter in {@link Types#canonicalize(java.lang.reflect.Type)\n+   * canonical form}.\n    */\n   static Type getSuperclassTypeParameter(Class<?> subclass) {\n     Type superclass = subclass.getGenericSuperclass();\n-    if (superclass instanceof Class<?>) {\n+    if (superclass instanceof Class) {\n       throw new RuntimeException(\"Missing type parameter.\");\n     }\n-    return ((ParameterizedType) superclass).getActualTypeArguments()[0];\n-  }\n-\n-  /**\n-   * Gets type token from super class's type parameter.\n+    ParameterizedType parameterized = (ParameterizedType) superclass;\n+    return Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n+  }\n+\n+  /**\n+   * Gets type literal from super class's type parameter.\n    */\n   static TypeToken<?> fromSuperclassTypeParameter(Class<?> subclass) {\n-    return new SimpleTypeToken<Object>(subclass);\n-  }\n-\n-  private static Class<?> getRawType(Type type) {\n-    if (type instanceof Class<?>) {\n-      // type is a normal class.\n-      return (Class<?>) type;\n-    } else if (type instanceof ParameterizedType) {\n-      ParameterizedType parameterizedType = (ParameterizedType) type;\n-\n-      // I'm not exactly sure why getRawType() returns Type instead of Class.\n-      // Neal isn't either but suspects some pathological case related\n-      // to nested classes exists.\n-      Type rawType = parameterizedType.getRawType();\n-      if (rawType instanceof Class<?>) {\n-        return (Class<?>) rawType;\n-      }\n-      throw buildUnexpectedTypeError(rawType, Class.class);\n-    } else if (type instanceof GenericArrayType) {\n-      GenericArrayType genericArrayType = (GenericArrayType) type;\n-\n-      // TODO(jleitch): This is not the most efficient way to handle generic\n-      // arrays, but is there another way to extract the array class in a\n-      // non-hacky way (i.e. using String value class names- \"[L...\")?\n-      Object rawArrayType = Array.newInstance(\n-          getRawType(genericArrayType.getGenericComponentType()), 0);\n-      return rawArrayType.getClass();\n-    } else {\n-      throw buildUnexpectedTypeError(\n-          type, ParameterizedType.class, GenericArrayType.class);\n-    }\n-  }\n-\n-  /**\n-   * Gets the raw type.\n-   */\n-  public Class<? super T> getRawType() {\n+    return new TypeToken<Object>(getSuperclassTypeParameter(subclass));\n+  }\n+\n+  /**\n+   * Returns the raw (non-generic) type for this type.\n+   */\n+  public final Class<? super T> getRawType() {\n     return rawType;\n   }\n \n   /**\n    * Gets underlying {@code Type} instance.\n    */\n-  public Type getType() {\n+  public final Type getType() {\n     return type;\n   }\n \n    * Check if this type is assignable from the given Type.\n    */\n   public boolean isAssignableFrom(Type from) {\n+    // TODO: resolve from first, then do something lightweight?\n+\n     if (from == null) {\n       return false;\n     }\n     }\n \n     if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom(getRawType(from));\n+      return rawType.isAssignableFrom(Types.getRawType(from));\n     } else if (type instanceof ParameterizedType) {\n       return isAssignableFrom(from, (ParameterizedType) type,\n           new HashMap<String, Type>());\n     } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom(getRawType(from))\n+      return rawType.isAssignableFrom(Types.getRawType(from))\n           && isAssignableFrom(from, (GenericArrayType) type);\n     } else {\n       throw buildUnexpectedTypeError(\n     }\n \n     // First figure out the class and any type information.\n-    Class<?> clazz = getRawType(from);\n+    Class<?> clazz = Types.getRawType(from);\n     ParameterizedType ptype = null;\n     if (from instanceof ParameterizedType) {\n       ptype = (ParameterizedType) from;\n     return false;\n   }\n \n-  /**\n-   * Checks if two types are the same or are equivalent under a variable mapping\n-   * given in the type map that was provided.\n-   */\n-  private static boolean matches(Type from, Type to,\n-      Map<String, Type> typeMap) {\n-    if (to.equals(from)) return true;\n-\n-    if (from instanceof TypeVariable<?>) {\n-      return to.equals(typeMap.get(((TypeVariable<?>)from).getName()));\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * Hashcode for this object.\n-   * @return hashcode for this object.\n-   */\n-  @Override public int hashCode() {\n-    return type.hashCode();\n-  }\n-\n-  /**\n-   * Method to test equality. \n-   * \n-   * @return true if this object is logically equal to the specified object, false otherwise.\n-   */\n-  @Override public boolean equals(Object o) {\n-    if (o == this) {\n-      return true;\n-    }\n-    if (!(o instanceof TypeToken<?>)) {\n-      return false;\n-    }\n-    TypeToken<?> t = (TypeToken<?>) o;\n-    return type.equals(t.type);\n-  }\n-\n-  /**\n-   * Returns a string representation of this object.\n-   * @return a string representation of this object.\n-   */\n-  @Override public String toString() {\n-    return type instanceof Class<?>\n-        ? ((Class<?>) type).getName()\n-        : type.toString();\n-  }\n-\n   private static AssertionError buildUnexpectedTypeError(\n       Type token, Class<?>... expected) {\n \n   }\n \n   /**\n-   * Gets type token for the given {@code Type} instance.\n+   * Checks if two types are the same or are equivalent under a variable mapping\n+   * given in the type map that was provided.\n+   */\n+  private static boolean matches(Type from, Type to,\n+      Map<String, Type> typeMap) {\n+    if (to.equals(from)) return true;\n+\n+    if (from instanceof TypeVariable<?>) {\n+      return to.equals(typeMap.get(((TypeVariable<?>)from).getName()));\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override public final int hashCode() {\n+    return this.hashCode;\n+  }\n+\n+  @Override public final boolean equals(Object o) {\n+    return o instanceof TypeToken<?>\n+        && Types.equals(type, ((TypeToken) o).type);\n+  }\n+\n+  @Override public final String toString() {\n+    return Types.typeToString(type);\n+  }\n+\n+  /**\n+   * Gets type literal for the given {@code Type} instance.\n    */\n   public static TypeToken<?> get(Type type) {\n-    return new SimpleTypeToken<Object>(type);\n-  }\n-\n-  /**\n-   * Gets type token for the given {@code Class} instance.\n+    return new TypeToken<Object>(type);\n+  }\n+\n+  /**\n+   * Gets type literal for the given {@code Class} instance.\n    */\n   public static <T> TypeToken<T> get(Class<T> type) {\n-    return new SimpleTypeToken<T>(type);\n-  }\n-\n-  /**\n-   * Private static class to not create more anonymous classes than\n-   * necessary.\n-   */\n-  private static class SimpleTypeToken<T> extends TypeToken<T> {\n-    public SimpleTypeToken(Type type) {\n-      super(type);\n-    }\n+    return new TypeToken<T>(type);\n+  }\n+\n+\n+  /** Returns an immutable list of the resolved types. */\n+  private List<TypeToken<?>> resolveAll(Type[] types) {\n+    TypeToken<?>[] result = new TypeToken<?>[types.length];\n+    for (int t = 0; t < types.length; t++) {\n+      result[t] = resolve(types[t]);\n+    }\n+    return Arrays.asList(result);\n+  }\n+\n+  /**\n+   * Resolves known type parameters in {@code toResolve} and returns the result.\n+   */\n+  TypeToken<?> resolve(Type toResolve) {\n+    return TypeToken.get(resolveType(toResolve));\n+  }\n+\n+  Type resolveType(Type toResolve) {\n+    // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    while (true) {\n+      if (toResolve instanceof TypeVariable) {\n+        TypeVariable original = (TypeVariable) toResolve;\n+        toResolve = Types.resolveTypeVariable(type, rawType, original);\n+        if (toResolve == original) {\n+          return toResolve;\n+        }\n+\n+      } else if (toResolve instanceof GenericArrayType) {\n+        GenericArrayType original = (GenericArrayType) toResolve;\n+        Type componentType = original.getGenericComponentType();\n+        Type newComponentType = resolveType(componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : Types.arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof ParameterizedType) {\n+        ParameterizedType original = (ParameterizedType) toResolve;\n+        Type ownerType = original.getOwnerType();\n+        Type newOwnerType = resolveType(ownerType);\n+        boolean changed = newOwnerType != ownerType;\n+\n+        Type[] args = original.getActualTypeArguments();\n+        for (int t = 0, length = args.length; t < length; t++) {\n+          Type resolvedTypeArgument = resolveType(args[t]);\n+          if (resolvedTypeArgument != args[t]) {\n+            if (!changed) {\n+              args = args.clone();\n+              changed = true;\n+            }\n+            args[t] = resolvedTypeArgument;\n+          }\n+        }\n+\n+        return changed\n+            ? Types.newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n+            : original;\n+\n+      } else if (toResolve instanceof WildcardType) {\n+        WildcardType original = (WildcardType) toResolve;\n+        Type[] originalLowerBound = original.getLowerBounds();\n+        Type[] originalUpperBound = original.getUpperBounds();\n+\n+        if (originalLowerBound.length == 1) {\n+          Type lowerBound = resolveType(originalLowerBound[0]);\n+          if (lowerBound != originalLowerBound[0]) {\n+            return Types.supertypeOf(lowerBound);\n+          }\n+        } else if (originalUpperBound.length == 1) {\n+          Type upperBound = resolveType(originalUpperBound[0]);\n+          if (upperBound != originalUpperBound[0]) {\n+            return Types.subtypeOf(upperBound);\n+          }\n+        }\n+        return original;\n+\n+      } else {\n+        return toResolve;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the generic form of {@code supertype}. For example, if this is {@code\n+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n+   * Iterable.class}.\n+   *\n+   * @param supertype a superclass of, or interface implemented by, this.\n+   */\n+  public TypeToken<?> getSupertype(Class<?> supertype) {\n+    checkArgument(supertype.isAssignableFrom(rawType));\n+    return resolve(Types.getGenericSupertype(type, rawType, supertype));\n+  }\n+\n+  /**\n+   * Returns the resolved generic type of {@code field}.\n+   *\n+   * @param field a field defined by this or any superclass.\n+   */\n+  public TypeToken<?> getFieldType(Field field) {\n+    if (!field.getDeclaringClass().isAssignableFrom(rawType)) {\n+      throw new IllegalArgumentException(rawType.getName() + \" does not declare field \" + field);\n+    }\n+    return resolve(field.getGenericType());\n+  }\n+\n+  /**\n+   * Returns the resolved generic parameter types of {@code methodOrConstructor}.\n+   *\n+   * @param methodOrConstructor a method or constructor defined by this or any supertype.\n+   */\n+  public List<TypeToken<?>> getParameterTypes(Member methodOrConstructor) {\n+    Type[] genericParameterTypes;\n+\n+    if (methodOrConstructor instanceof Method) {\n+      Method method = (Method) methodOrConstructor;\n+      checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n+      genericParameterTypes = method.getGenericParameterTypes();\n+\n+    } else if (methodOrConstructor instanceof Constructor) {\n+      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;\n+      checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType));\n+      genericParameterTypes = constructor.getGenericParameterTypes();\n+\n+    } else {\n+      throw new IllegalArgumentException(\"Not a method or a constructor: \" + methodOrConstructor);\n+    }\n+\n+    return resolveAll(genericParameterTypes);\n+  }\n+\n+  /**\n+   * Returns the resolved generic exception types thrown by {@code constructor}.\n+   *\n+   * @param methodOrConstructor a method or constructor defined by this or any supertype.\n+   */\n+  public List<TypeToken<?>> getExceptionTypes(Member methodOrConstructor) {\n+    Type[] genericExceptionTypes;\n+\n+    if (methodOrConstructor instanceof Method) {\n+      Method method = (Method) methodOrConstructor;\n+      checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n+      genericExceptionTypes = method.getGenericExceptionTypes();\n+\n+    } else if (methodOrConstructor instanceof Constructor) {\n+      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;\n+      checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType));\n+      genericExceptionTypes = constructor.getGenericExceptionTypes();\n+\n+    } else {\n+      throw new IllegalArgumentException(\"Not a method or a constructor: \" + methodOrConstructor);\n+    }\n+\n+    return resolveAll(genericExceptionTypes);\n+  }\n+\n+  /**\n+   * Returns the resolved generic return type of {@code method}.\n+   *\n+   * @param method a method defined by this or any supertype.\n+   */\n+  public TypeToken<?> getReturnType(Method method) {\n+    checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n+    return resolve(method.getGenericReturnType());\n+  }\n+\n+  static void checkNotNull(Object obj) {\n+    checkArgument(obj != null);\n+  }\n+\n+  static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException(\"condition failed: \" + condition);\n+    }\n+  }\n+\n+  // TODO: these methods are required by GSON but don't need to be public. Remove?\n+\n+  /**\n+   * Returns true if this type is an array.\n+   */\n+  public boolean isArray() {\n+    return type instanceof GenericArrayType;\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public boolean isPrimitive() {\n+    return type == boolean.class\n+        || type == byte.class\n+        || type == char.class\n+        || type == double.class\n+        || type == float.class\n+        || type == int.class\n+        || type == long.class\n+        || type == short.class\n+        || type == void.class;\n+  }\n+\n+  /**\n+   * Returns the component type of this array type.\n+   * @throws ClassCastException if this type is not an array.\n+   */\n+  public Type getArrayComponentType() {\n+    return ((GenericArrayType) type).getGenericComponentType();\n+  }\n+\n+  /**\n+   * Returns the element type of this collection type.\n+   * @throws IllegalArgumentException if this type is not a collection.\n+   */\n+  public Type getCollectionElementType() {\n+    TypeToken<?> collectionType = getSupertype(Collection.class);\n+    return ((ParameterizedType) collectionType.getType()).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Returns a two element array containing this map's key and value types in\n+   * positions 0 and 1 respectively.\n+   */\n+  public Type[] getMapKeyAndValueTypes() {\n+    /*\n+     * Work around a problem with the declaration of java.util.Properties. That\n+     * class should extend Hashtable<String, String>, but it's declared to\n+     * extend Hashtable<Object, Object>.\n+     */\n+    if (type == Properties.class) {\n+      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n+    }\n+\n+    TypeToken<?> mapTypeToken = TypeToken.get(type).getSupertype(Map.class);\n+    ParameterizedType mapParameterizedType = (ParameterizedType) mapTypeToken.getType();\n+    return mapParameterizedType.getActualTypeArguments();\n   }\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/reflect/Types.java\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.reflect;\n+\n+import static com.google.gson.reflect.TypeToken.checkArgument;\n+import static com.google.gson.reflect.TypeToken.checkNotNull;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * Static methods for working with types.\n+ *\n+ * @author Bob Lee\n+ * @author Jesse Wilson\n+ */\n+public final class Types {\n+  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private Types() {}\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType}. The returned type does not have an owner type.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedType(Type rawType, Type... typeArguments) {\n+    return newParameterizedTypeWithOwner(null, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType} and enclosed by {@code ownerType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedTypeWithOwner(\n+      Type ownerType, Type rawType, Type... typeArguments) {\n+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns an array type whose elements are all instances of\n+   * {@code componentType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} generic array type.\n+   */\n+  public static GenericArrayType arrayOf(Type componentType) {\n+    return new GenericArrayTypeImpl(componentType);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}.\n+   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n+   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n+   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For\n+   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n+   * super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+  }\n+\n+  /**\n+   * Returns a type modelling a {@link List} whose elements are of type\n+   * {@code elementType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType listOf(Type elementType) {\n+    return newParameterizedType(List.class, elementType);\n+  }\n+\n+  /**\n+   * Returns a type modelling a {@link Set} whose elements are of type\n+   * {@code elementType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType setOf(Type elementType) {\n+    return newParameterizedType(Set.class, elementType);\n+  }\n+\n+  /**\n+   * Returns a type modelling a {@link Map} whose keys are of type\n+   * {@code keyType} and whose values are of type {@code valueType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType mapOf(Type keyType, Type valueType) {\n+    return newParameterizedType(Map.class, keyType, valueType);\n+  }\n+\n+  /**\n+   * Returns a type that is functionally equal but not necessarily equal\n+   * according to {@link Object#equals(Object) Object.equals()}. The returned\n+   * type is {@link java.io.Serializable}.\n+   */\n+  static Type canonicalize(Type type) {\n+    if (type instanceof Class) {\n+      Class<?> c = (Class<?>) type;\n+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType p = (ParameterizedType) type;\n+      return new ParameterizedTypeImpl(p.getOwnerType(),\n+          p.getRawType(), p.getActualTypeArguments());\n+\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType g = (GenericArrayType) type;\n+      return new GenericArrayTypeImpl(g.getGenericComponentType());\n+\n+    } else if (type instanceof WildcardType) {\n+      WildcardType w = (WildcardType) type;\n+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+\n+    } else {\n+      // type is either serializable as-is or unsupported\n+      return type;\n+    }\n+  }\n+\n+  static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      checkArgument(rawType instanceof Class);\n+      return (Class<?>) rawType;\n+\n+    } else if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n+      return Array.newInstance(getRawType(componentType), 0).getClass();\n+\n+    } else if (type instanceof TypeVariable) {\n+      // we could use the variable's bounds, but that won't work if there are multiple.\n+      // having a raw type that's more general than necessary is okay\n+      return Object.class;\n+\n+    } else if (type instanceof WildcardType) {\n+      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n+\n+    } else {\n+      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+          + \"GenericArrayType, but <\" + type + \"> is of type \" + type.getClass().getName());\n+    }\n+  }\n+\n+  static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Returns true if {@code a} and {@code b} are equal.\n+   */\n+  static boolean equals(Type a, Type b) {\n+    if (a == b) {\n+      // also handles (a == null && b == null)\n+      return true;\n+\n+    } else if (a instanceof Class) {\n+      // Class already specifies equals().\n+      return a.equals(b);\n+\n+    } else if (a instanceof ParameterizedType) {\n+      if (!(b instanceof ParameterizedType)) {\n+        return false;\n+      }\n+\n+      // TODO: save a .clone() call\n+      ParameterizedType pa = (ParameterizedType) a;\n+      ParameterizedType pb = (ParameterizedType) b;\n+      return equal(pa.getOwnerType(), pb.getOwnerType())\n+          && pa.getRawType().equals(pb.getRawType())\n+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n+\n+    } else if (a instanceof GenericArrayType) {\n+      if (!(b instanceof GenericArrayType)) {\n+        return false;\n+      }\n+\n+      GenericArrayType ga = (GenericArrayType) a;\n+      GenericArrayType gb = (GenericArrayType) b;\n+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n+\n+    } else if (a instanceof WildcardType) {\n+      if (!(b instanceof WildcardType)) {\n+        return false;\n+      }\n+\n+      WildcardType wa = (WildcardType) a;\n+      WildcardType wb = (WildcardType) b;\n+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n+\n+    } else if (a instanceof TypeVariable) {\n+      if (!(b instanceof TypeVariable)) {\n+        return false;\n+      }\n+      TypeVariable<?> va = (TypeVariable) a;\n+      TypeVariable<?> vb = (TypeVariable) b;\n+      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n+          && va.getName().equals(vb.getName());\n+\n+    } else {\n+      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n+      return false;\n+    }\n+  }\n+\n+  private static int hashCodeOrZero(Object o) {\n+    return o != null ? o.hashCode() : 0;\n+  }\n+\n+  static String typeToString(Type type) {\n+    return type instanceof Class ? ((Class) type).getName() : type.toString();\n+  }\n+\n+  /**\n+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n+   */\n+  static Type getGenericSupertype(Type type, Class<?> rawType, Class<?> toResolve) {\n+    if (toResolve == rawType) {\n+      return type;\n+    }\n+\n+    // we skip searching through interfaces if unknown is an interface\n+    if (toResolve.isInterface()) {\n+      Class[] interfaces = rawType.getInterfaces();\n+      for (int i = 0, length = interfaces.length; i < length; i++) {\n+        if (interfaces[i] == toResolve) {\n+          return rawType.getGenericInterfaces()[i];\n+        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+        }\n+      }\n+    }\n+\n+    // check our supertypes\n+    if (!rawType.isInterface()) {\n+      while (rawType != Object.class) {\n+        Class<?> rawSupertype = rawType.getSuperclass();\n+        if (rawSupertype == toResolve) {\n+          return rawType.getGenericSuperclass();\n+        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+        }\n+        rawType = rawSupertype;\n+      }\n+    }\n+\n+    // we can't resolve this further\n+    return toResolve;\n+  }\n+\n+  static Type resolveTypeVariable(Type type, Class<?> rawType, TypeVariable unknown) {\n+    Class<?> declaredByRaw = declaringClassOf(unknown);\n+\n+    // we can't reduce this further\n+    if (declaredByRaw == null) {\n+      return unknown;\n+    }\n+\n+    Type declaredBy = getGenericSupertype(type, rawType, declaredByRaw);\n+    if (declaredBy instanceof ParameterizedType) {\n+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n+    }\n+\n+    return unknown;\n+  }\n+\n+  private static int indexOf(Object[] array, Object toFind) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (toFind.equals(array[i])) {\n+        return i;\n+      }\n+    }\n+    throw new NoSuchElementException();\n+  }\n+\n+  /**\n+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n+   * a class.\n+   */\n+  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n+    return genericDeclaration instanceof Class\n+        ? (Class<?>) genericDeclaration\n+        : null;\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkArgument(!(type instanceof Class<?>) || !((Class) type).isPrimitive());\n+  }\n+\n+  private static class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n+    private final Type ownerType;\n+    private final Type rawType;\n+    private final Type[] typeArguments;\n+\n+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n+      // require an owner type if the raw type needs it\n+      if (rawType instanceof Class<?>) {\n+        Class rawTypeAsClass = (Class) rawType;\n+        checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n+        checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n+      }\n+\n+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n+      this.rawType = canonicalize(rawType);\n+      this.typeArguments = typeArguments.clone();\n+      for (int t = 0; t < this.typeArguments.length; t++) {\n+        checkNotNull(this.typeArguments[t]);\n+        checkNotPrimitive(this.typeArguments[t]);\n+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n+      }\n+    }\n+\n+    public Type[] getActualTypeArguments() {\n+      return typeArguments.clone();\n+    }\n+\n+    public Type getRawType() {\n+      return rawType;\n+    }\n+\n+    public Type getOwnerType() {\n+      return ownerType;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof ParameterizedType\n+          && Types.equals(this, (ParameterizedType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      return Arrays.hashCode(typeArguments)\n+          ^ rawType.hashCode()\n+          ^ hashCodeOrZero(ownerType);\n+    }\n+\n+    @Override public String toString() {\n+      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));\n+      stringBuilder.append(typeToString(rawType));\n+\n+      if (typeArguments.length == 0) {\n+        return stringBuilder.toString();\n+      }\n+\n+      stringBuilder.append(\"<\").append(typeToString(typeArguments[0]));\n+      for (int i = 1; i < typeArguments.length; i++) {\n+        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n+      }\n+      return stringBuilder.append(\">\").toString();\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n+    private final Type componentType;\n+\n+    public GenericArrayTypeImpl(Type componentType) {\n+      this.componentType = canonicalize(componentType);\n+    }\n+\n+    public Type getGenericComponentType() {\n+      return componentType;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof GenericArrayType\n+          && Types.equals(this, (GenericArrayType) o);\n+    }\n+\n+    @Override public int hashCode() {\n+      return componentType.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return typeToString(componentType) + \"[]\";\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  /**\n+   * The WildcardType interface supports multiple upper bounds and multiple\n+   * lower bounds. We only support what the Java 6 language needs - at most one\n+   * bound. If a lower bound is set, the upper bound must be Object.class.\n+   */\n+  private static class WildcardTypeImpl implements WildcardType, Serializable {\n+    private final Type upperBound;\n+    private final Type lowerBound;\n+\n+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+      checkArgument(lowerBounds.length <= 1);\n+      checkArgument(upperBounds.length == 1);\n+\n+      if (lowerBounds.length == 1) {\n+        checkNotNull(lowerBounds[0]);\n+        checkNotPrimitive(lowerBounds[0]);\n+        checkArgument(upperBounds[0] == Object.class);\n+        this.lowerBound = canonicalize(lowerBounds[0]);\n+        this.upperBound = Object.class;\n+\n+      } else {\n+        checkNotNull(upperBounds[0]);\n+        checkNotPrimitive(upperBounds[0]);\n+        this.lowerBound = null;\n+        this.upperBound = canonicalize(upperBounds[0]);\n+      }\n+    }\n+\n+    public Type[] getUpperBounds() {\n+      return new Type[] { upperBound };\n+    }\n+\n+    public Type[] getLowerBounds() {\n+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof WildcardType\n+          && Types.equals(this, (WildcardType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n+          ^ (31 + upperBound.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      if (lowerBound != null) {\n+        return \"? super \" + typeToString(lowerBound);\n+      } else if (upperBound == Object.class) {\n+        return \"?\";\n+      } else {\n+        return \"? extends \" + typeToString(upperBound);\n+      }\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n package com.google.gson;\n \n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n \n \n     @SuppressWarnings(\"unchecked\")\n     public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n-      Type genericClass = TypeUtils.getActualTypeForFirstTypeVariable(typeOfT);\n-      TypeInfo typeInfo = new TypeInfo(genericClass);\n-      String className = typeInfo.getRawClass().getSimpleName();\n+      Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n+      TypeToken<?> typeToken = TypeToken.get(genericClass);\n+      String className = typeToken.getRawType().getSimpleName();\n       T value = (T) json.getAsJsonObject().get(className).getAsObject();\n-      if (typeInfo.isPrimitive()) {\n+      if (typeToken.isPrimitive()) {\n         PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n-        value = (T) typeAdapter.adaptType(value, typeInfo.getRawClass());\n+        value = (T) typeAdapter.adaptType(value, typeToken.getRawType());\n       }\n       return new MyParameterizedType<T>(value);\n     }", "timestamp": 1291363633, "metainfo": ""}