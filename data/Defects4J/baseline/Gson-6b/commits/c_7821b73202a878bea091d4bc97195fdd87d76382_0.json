{"sha": "7821b73202a878bea091d4bc97195fdd87d76382", "log": "Added support for AtomicInteger, AtomicBoolean, AtomicLong and AtomicIntegerArray.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n     factories.add(TypeAdapters.BOOLEAN_FACTORY);\n     factories.add(TypeAdapters.BYTE_FACTORY);\n     factories.add(TypeAdapters.SHORT_FACTORY);\n-    factories.add(TypeAdapters.newFactory(long.class, Long.class,\n-            longAdapter(longSerializationPolicy)));\n+    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\n+    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n     factories.add(TypeAdapters.newFactory(double.class, Double.class,\n             doubleAdapter(serializeSpecialFloatingPointValues)));\n     factories.add(TypeAdapters.newFactory(float.class, Float.class,\n             floatAdapter(serializeSpecialFloatingPointValues)));\n     factories.add(TypeAdapters.NUMBER_FACTORY);\n+    factories.add(TypeAdapters.newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER));\n+    factories.add(TypeAdapters.newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN));\n+    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n+    factories.add(TypeAdapters.newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY));\n     factories.add(TypeAdapters.CHARACTER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n     };\n   }\n \n+  private TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\n+    return new TypeAdapter<AtomicLong>() {\n+      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {\n+        longAdapter.write(out, value.get());\n+      }\n+      @Override public AtomicLong read(JsonReader in) throws IOException {\n+        Number value = longAdapter.read(in);\n+        return new AtomicLong(value.longValue());\n+      }\n+    }.nullSafe();\n+  }\n   /**\n    * Returns the type adapter for {@code} type.\n    *\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n  */\n \n package com.google.gson.internal.bind;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n \n import com.google.gson.Gson;\n import com.google.gson.JsonArray;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.net.InetAddress;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.sql.Timestamp;\n-import java.util.BitSet;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-import java.util.UUID;\n \n /**\n  * Type adapters for basic types.\n       out.value(value);\n     }\n   };\n-\n   public static final TypeAdapterFactory INTEGER_FACTORY\n       = newFactory(int.class, Integer.class, INTEGER);\n+\n+  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n+    @Override public AtomicInteger read(JsonReader in) throws IOException {\n+      try {\n+        return new AtomicInteger(in.nextInt());\n+      } catch (NumberFormatException e) {\n+        throw new JsonSyntaxException(e);\n+      }\n+    }\n+    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n+      out.value(value.get());\n+    }\n+  }.nullSafe();\n+\n+  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n+    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n+      return new AtomicBoolean(in.nextBoolean());\n+    }\n+    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n+      out.value(value.get());\n+    }\n+  }.nullSafe();\n+\n+  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n+    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n+        List<Integer> list = new ArrayList<Integer>();\n+        in.beginArray();\n+        while (in.hasNext()) {\n+          try {\n+            int integer = in.nextInt();\n+            list.add(integer);\n+          } catch (NumberFormatException e) {\n+            throw new JsonSyntaxException(e);\n+          }\n+        }\n+        in.endArray();\n+        int length = list.size();\n+        AtomicIntegerArray array = new AtomicIntegerArray(length);\n+        for (int i = 0; i < length; ++i) {\n+          array.set(i, list.get(i));\n+        }\n+        return array;\n+    }\n+    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n+      out.beginArray();\n+      for (int i = 0, length = value.length(); i < length; i++) {\n+        out.value(value.get(i));\n+      }\n+      out.endArray();\n+    }\n+  }.nullSafe();\n \n   public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n     @Override\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentLocksTest.java\n+/*\n+ * Copyright (C) 2015 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.google.gson.Gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional test for Json serialization and deserialization for java.util.concurrent.locks classes\n+ */\n+public class JavaUtilConcurrentLocksTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testAtomicBoolean() throws Exception {\n+    AtomicBoolean target = gson.fromJson(\"true\", AtomicBoolean.class);\n+    assertTrue(target.get());\n+    String json = gson.toJson(target);\n+    assertEquals(\"true\", json);\n+  }\n+\n+  public void testAtomicInteger() throws Exception {\n+    AtomicInteger target = gson.fromJson(\"10\", AtomicInteger.class);\n+    assertEquals(10, target.get());\n+    String json = gson.toJson(target);\n+    assertEquals(\"10\", json);\n+  }\n+\n+  public void testAtomicLong() throws Exception {\n+    AtomicLong target = gson.fromJson(\"10\", AtomicLong.class);\n+    assertEquals(10, target.get());\n+    String json = gson.toJson(target);\n+    assertEquals(\"10\", json);\n+  }\n+\n+  public void testAtomicIntegerArray() throws Exception {\n+    AtomicIntegerArray target = gson.fromJson(\"[10, 13, 14]\", AtomicIntegerArray.class);\n+    assertEquals(3, target.length());\n+    assertEquals(10, target.get(0));\n+    assertEquals(13, target.get(1));\n+    assertEquals(14, target.get(2));\n+    String json = gson.toJson(target);\n+    assertEquals(\"[10,13,14]\", json);\n+  }\n+}", "timestamp": 1446749123, "metainfo": ""}