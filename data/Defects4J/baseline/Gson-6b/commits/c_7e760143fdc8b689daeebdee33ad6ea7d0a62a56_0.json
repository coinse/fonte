{"sha": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56", "log": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable 'Gson' objects.   The most notable impact of this change is that it adds several new public APIs:  - The TypeAdapter abstract class  - The TypeAdapter.Factory interface  - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)  - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter)   Still outstanding:  - Write beautiful prose to document the new APIs above  - Change GsonBuilder's precedence so that both old and new-style type adapters are registered in one lot", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.JsonElementReader;\n import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n-import com.google.gson.internal.bind.MiniGson;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n import com.google.gson.internal.bind.SqlDateTypeAdapter;\n import com.google.gson.internal.bind.TimeTypeAdapter;\n-import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n+  /**\n+   * This thread local guards against reentrant calls to getAdapter(). In\n+   * certain object graphs, creating an adapter for a type may recursively\n+   * require an adapter for the same type! Without intervention, the recursive\n+   * lookup would stack overflow. We cheat by returning a proxy type adapter.\n+   * The proxy is wired up once the initial adapter has been created.\n+   */\n+  private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n+      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>() {\n+    @Override protected Map<TypeToken<?>, FutureTypeAdapter<?>> initialValue() {\n+      return new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n+    }\n+  };\n+\n+  private final List<TypeAdapter.Factory> factories;\n   private final ExclusionStrategy deserializationExclusionStrategy;\n   private final ExclusionStrategy serializationExclusionStrategy;\n   private final ConstructorConstructor constructorConstructor;\n   private final boolean htmlSafe;\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n-\n-  private final MiniGson miniGson;\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n       }\n     };\n \n-    MiniGson.Builder builder = new MiniGson.Builder()\n-        .withoutDefaultFactories()\n-        .factory(TypeAdapters.STRING_FACTORY)\n-        .factory(TypeAdapters.INTEGER_FACTORY)\n-        .factory(TypeAdapters.BOOLEAN_FACTORY)\n-        .factory(TypeAdapters.BYTE_FACTORY)\n-        .factory(TypeAdapters.SHORT_FACTORY)\n-        .factory(TypeAdapters.newFactory(long.class, Long.class,\n-            longAdapter(longSerializationPolicy)))\n-        .factory(TypeAdapters.newFactory(double.class, Double.class,\n-            doubleAdapter(serializeSpecialFloatingPointValues)))\n-        .factory(TypeAdapters.newFactory(float.class, Float.class,\n-            floatAdapter(serializeSpecialFloatingPointValues)))\n-        .factory(new ExcludedTypeAdapterFactory(\n-            serializationExclusionStrategy, deserializationExclusionStrategy))\n-        .factory(TypeAdapters.NUMBER_FACTORY)\n-        .factory(TypeAdapters.CHARACTER_FACTORY)\n-        .factory(TypeAdapters.STRING_BUILDER_FACTORY)\n-        .factory(TypeAdapters.STRING_BUFFER_FACTORY)\n-        .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())\n-        .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())\n-        .factory(TypeAdapters.JSON_ELEMENT_FACTORY)\n-        .factory(ObjectTypeAdapter.FACTORY);\n+    ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n+    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    factories.add(TypeAdapters.STRING_FACTORY);\n+    factories.add(TypeAdapters.INTEGER_FACTORY);\n+    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n+    factories.add(TypeAdapters.BYTE_FACTORY);\n+    factories.add(TypeAdapters.SHORT_FACTORY);\n+    factories.add(TypeAdapters.newFactory(long.class, Long.class,\n+            longAdapter(longSerializationPolicy)));\n+    factories.add(TypeAdapters.newFactory(double.class, Double.class,\n+            doubleAdapter(serializeSpecialFloatingPointValues)));\n+    factories.add(TypeAdapters.newFactory(float.class, Float.class,\n+            floatAdapter(serializeSpecialFloatingPointValues)));\n+    factories.add(new ExcludedTypeAdapterFactory(\n+            serializationExclusionStrategy, deserializationExclusionStrategy));\n+    factories.add(TypeAdapters.NUMBER_FACTORY);\n+    factories.add(TypeAdapters.CHARACTER_FACTORY);\n+    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n+    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n+    factories.add(TypeAdapters.newFactory(BigDecimal.class, new BigDecimalTypeAdapter()));\n+    factories.add(TypeAdapters.newFactory(BigInteger.class, new BigIntegerTypeAdapter()));\n+    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n+    factories.add(ObjectTypeAdapter.FACTORY);\n \n     for (TypeAdapter.Factory factory : typeAdapterFactories) {\n-      builder.factory(factory);\n-    }\n-\n-    builder\n-        .factory(new GsonToMiniGsonTypeAdapterFactory(this, serializers, deserializers))\n-        .factory(new CollectionTypeAdapterFactory(constructorConstructor))\n-        .factory(TypeAdapters.URL_FACTORY)\n-        .factory(TypeAdapters.URI_FACTORY)\n-        .factory(TypeAdapters.UUID_FACTORY)\n-        .factory(TypeAdapters.LOCALE_FACTORY)\n-        .factory(TypeAdapters.INET_ADDRESS_FACTORY)\n-        .factory(TypeAdapters.BIT_SET_FACTORY)\n-        .factory(DateTypeAdapter.FACTORY)\n-        .factory(TypeAdapters.CALENDAR_FACTORY)\n-        .factory(TimeTypeAdapter.FACTORY)\n-        .factory(SqlDateTypeAdapter.FACTORY)\n-        .factory(TypeAdapters.TIMESTAMP_FACTORY)\n-        .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))\n-        .factory(ArrayTypeAdapter.FACTORY)\n-        .factory(TypeAdapters.ENUM_FACTORY)\n-        .factory(reflectiveTypeAdapterFactory);\n-\n-    this.miniGson = builder.build();\n+      factories.add(factory);\n+    }\n+\n+    factories.add(new GsonToMiniGsonTypeAdapterFactory(this, serializers, deserializers));\n+    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n+    factories.add(TypeAdapters.URL_FACTORY);\n+    factories.add(TypeAdapters.URI_FACTORY);\n+    factories.add(TypeAdapters.UUID_FACTORY);\n+    factories.add(TypeAdapters.LOCALE_FACTORY);\n+    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n+    factories.add(TypeAdapters.BIT_SET_FACTORY);\n+    factories.add(DateTypeAdapter.FACTORY);\n+    factories.add(TypeAdapters.CALENDAR_FACTORY);\n+    factories.add(TimeTypeAdapter.FACTORY);\n+    factories.add(SqlDateTypeAdapter.FACTORY);\n+    factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n+    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n+    factories.add(ArrayTypeAdapter.FACTORY);\n+    factories.add(TypeAdapters.ENUM_FACTORY);\n+    factories.add(reflectiveTypeAdapterFactory);\n+\n+    this.factories = Collections.unmodifiableList(factories);\n   }\n \n   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n     strategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\n     strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\n     return new DisjunctionExclusionStrategy(strategies);\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n+    // TODO: cache?\n+\n+    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n+    @SuppressWarnings(\"unchecked\") // the key and value type parameters always agree\n+    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n+    if (ongoingCall != null) {\n+      return ongoingCall;\n+    }\n+\n+    FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n+    threadCalls.put(type, call);\n+    try {\n+      for (TypeAdapter.Factory factory : factories) {\n+        TypeAdapter<T> candidate = factory.create(this, type);\n+        if (candidate != null) {\n+          call.setDelegate(candidate);\n+          return candidate;\n+        }\n+      }\n+      throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n+    } finally {\n+      threadCalls.remove(type);\n+    }\n+  }\n+\n+  /**\n+   * Returns a type adapter for {@code} type that isn't {@code skipPast}. This\n+   * can be used for type adapters to compose other, simpler type adapters.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getNextAdapter(TypeAdapter.Factory skipPast, TypeToken<T> type) {\n+    boolean skipPastFound = false;\n+\n+    for (TypeAdapter.Factory factory : factories) {\n+      if (!skipPastFound) {\n+        if (factory == skipPast) {\n+          skipPastFound = true;\n+        }\n+        continue;\n+      }\n+\n+      TypeAdapter<T> candidate = factory.create(this, type);\n+      if (candidate != null) {\n+        return candidate;\n+      }\n+    }\n+\n+    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(Class<T> type) {\n+    return getAdapter(TypeToken.get(type));\n   }\n \n   /**\n    */\n   @SuppressWarnings(\"unchecked\")\n   public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\n-    TypeAdapter<?> adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));\n+    TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\n     boolean oldLenient = writer.isLenient();\n     writer.setLenient(true);\n     boolean oldHtmlSafe = writer.isHtmlSafe();\n     try {\n       reader.peek();\n       isEmpty = false;\n-      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) miniGson.getAdapter(TypeToken.get(typeOfT));\n+      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(TypeToken.get(typeOfT));\n       return typeAdapter.read(reader);\n     } catch (EOFException e) {\n       /*\n     return (T) fromJson(new JsonElementReader(json), typeOfT);\n   }\n \n+  static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n+    private TypeAdapter<T> delegate;\n+\n+    public void setDelegate(TypeAdapter<T> typeAdapter) {\n+      if (delegate != null) {\n+        throw new AssertionError();\n+      }\n+      delegate = typeAdapter;\n+    }\n+\n+    @Override public T read(JsonReader reader) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      return delegate.read(reader);\n+    }\n+\n+    @Override public void write(JsonWriter writer, T value) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      delegate.write(writer, value);\n+    }\n+  }\n+\n   @Override\n   public String toString() {\n   \tStringBuilder sb = new StringBuilder(\"{\")\n         .append(\"}\");\n   \treturn sb.toString();\n   }\n-\n }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.internal.bind.TypeAdapters;\n+import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n     generateNonExecutableJson = false;\n   }\n \n+  // TODO: nice documentation\n+  public GsonBuilder factory(TypeAdapter.Factory factory) {\n+    typeAdapterFactories.add(factory);\n+    return this;\n+  }\n+\n+  // TODO: nice documentation\n+  public <T> GsonBuilder typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n+    return this;\n+  }\n+\n+  // TODO: nice documentation\n+  // TODO: accept a Type instead of a TypeToken? It's less typesafe but more Gson-like\n+  public <T> GsonBuilder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n+    return this;\n+  }\n+\n+  // TODO: nice documentation\n+  public <T> GsonBuilder typeHierarchyAdapter(Class<T> type, TypeAdapter<T> typeAdapter) {\n+    typeAdapterFactories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n+    return this;\n+  }\n+\n   /**\n    * Configures Gson to enable versioning support.\n    *\n--- a/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java\n \n import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.bind.MiniGson;\n-import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n     };\n   }\n \n-  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> typeToken) {\n     final Type type = typeToken.getType();\n \n     @SuppressWarnings(\"unchecked\") // guaranteed to match typeOfT\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.internal.bind.JsonElementReader;\n+import com.google.gson.internal.bind.JsonElementWriter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+// TODO: nice documentation\n+\n+public abstract class TypeAdapter<T> {\n+  public abstract T read(JsonReader reader) throws IOException;\n+  public abstract void write(JsonWriter writer, T value) throws IOException;\n+\n+  public final String toJson(T value) throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    write(stringWriter, value);\n+    return stringWriter.toString();\n+  }\n+\n+  public final void write(Writer out, T value) throws IOException {\n+    JsonWriter writer = new JsonWriter(out);\n+    write(writer, value);\n+  }\n+\n+  public final T fromJson(String json) throws IOException {\n+    return read(new StringReader(json));\n+  }\n+\n+  public final T read(Reader in) throws IOException {\n+    JsonReader reader = new JsonReader(in);\n+    reader.setLenient(true);\n+    return read(reader);\n+  }\n+\n+  public JsonElement toJsonElement(T src) {\n+    try {\n+      JsonElementWriter jsonWriter = new JsonElementWriter();\n+      jsonWriter.setLenient(true);\n+      write(jsonWriter, src);\n+      return jsonWriter.get();\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    }\n+  }\n+\n+  public T fromJsonElement(JsonElement json) {\n+    try {\n+      JsonReader jsonReader = new JsonElementReader(json);\n+      jsonReader.setLenient(true);\n+      return read(jsonReader);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    }\n+  }\n+\n+  public interface Factory {\n+    <T> TypeAdapter<T> create(Gson context, TypeToken<T> type);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import java.io.IOException;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n         return null;\n   private final Class<E> componentType;\n   private final TypeAdapter<E> componentTypeAdapter;\n \n-  public ArrayTypeAdapter(MiniGson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+  public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n     this.componentTypeAdapter =\n       new TypeAdapterRuntimeTypeWrapper<E>(context, componentTypeAdapter, componentType);\n     this.componentType = componentType;\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java\n package com.google.gson.internal.bind;\n \n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n--- a/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java\n package com.google.gson.internal.bind;\n \n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n     this.constructorConstructor = constructorConstructor;\n   }\n \n-  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n     Type type = typeToken.getType();\n \n     Class<? super T> rawType = typeToken.getRawType();\n     private final TypeAdapter<E> elementTypeAdapter;\n     private final ObjectConstructor<? extends Collection<E>> constructor;\n \n-    public Adapter(MiniGson context, Type elementType,\n+    public Adapter(Gson context, Type elementType,\n         TypeAdapter<E> elementTypeAdapter,\n         ObjectConstructor<? extends Collection<E>> constructor) {\n       this.elementTypeAdapter =\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n public final class DateTypeAdapter extends TypeAdapter<Date> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n     }\n   };\n--- a/gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java\n package com.google.gson.internal.bind;\n \n import com.google.gson.ExclusionStrategy;\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n     this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n   }\n \n-  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> type) {\n+  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> type) {\n     Class<?> rawType = type.getRawType();\n     final boolean skipSerialize = serializationExclusionStrategy.shouldSkipClass(rawType);\n     final boolean skipDeserialize = deserializationExclusionStrategy.shouldSkipClass(rawType);\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n     this.complexMapKeySerialization = complexMapKeySerialization;\n   }\n \n-  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n     Type type = typeToken.getType();\n \n     Class<? super T> rawType = typeToken.getRawType();\n   /**\n    * Returns a type adapter that writes the value as a string.\n    */\n-  private TypeAdapter<?> getKeyAdapter(MiniGson context, Type keyType) {\n+  private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\n     return (keyType == boolean.class || keyType == Boolean.class)\n         ? TypeAdapters.BOOLEAN_AS_STRING\n         : context.getAdapter(TypeToken.get(keyType));\n     private final TypeAdapter<V> valueTypeAdapter;\n     private final ObjectConstructor<? extends Map<K, V>> constructor;\n \n-    public Adapter(MiniGson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\n+    public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\n         Type valueType, TypeAdapter<V> valueTypeAdapter,\n         ObjectConstructor<? extends Map<K, V>> constructor) {\n       this.keyTypeAdapter =\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n public final class ObjectTypeAdapter extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\")\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n       if (type.getRawType() == Object.class) {\n         return (TypeAdapter<T>) new ObjectTypeAdapter(context);\n       }\n     }\n   };\n \n-  private final MiniGson miniGson;\n+  private final Gson gson;\n \n-  private ObjectTypeAdapter(MiniGson miniGson) {\n-    this.miniGson = miniGson;\n+  private ObjectTypeAdapter(Gson gson) {\n+    this.gson = gson;\n   }\n \n   @Override public Object read(JsonReader reader) throws IOException {\n       return;\n     }\n \n-    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) miniGson.getAdapter(value.getClass());\n+    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());\n     if (typeAdapter instanceof ObjectTypeAdapter) {\n       writer.beginObject();\n       writer.endObject();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n     return f.getName();\n   }\n \n-  public <T> TypeAdapter<T> create(MiniGson context, final TypeToken<T> type) {\n+  public <T> TypeAdapter<T> create(Gson context, final TypeToken<T> type) {\n     Class<? super T> raw = type.getRawType();\n \n     if (!Object.class.isAssignableFrom(raw)) {\n   }\n \n   private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n-      final MiniGson context, final Field field, final String name,\n+      final Gson context, final Field field, final String name,\n       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n \n   }\n \n   private Map<String, BoundField> getBoundFields(\n-      MiniGson context, TypeToken<?> type, Class<?> raw) {\n+      Gson context, TypeToken<?> type, Class<?> raw) {\n     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n     if (raw.isInterface()) {\n       return result;\n--- a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == java.sql.Date.class\n           ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n     }\n--- a/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n     this.constructorConstructor = constructorConstructor;\n   }\n \n-  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n     Type type = typeToken.getType();\n     if (!(type instanceof ParameterizedType)) {\n       return null;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n public final class TimeTypeAdapter extends TypeAdapter<Time> {\n   public static final Factory FACTORY = new Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n     }\n   };\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n  */\n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n \n-  private final MiniGson context;\n+  private final Gson context;\n   private final TypeAdapter<T> delegate;\n   private final Type type;\n \n-  TypeAdapterRuntimeTypeWrapper(MiniGson context, TypeAdapter<T> delegate, Type type) {\n+  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\n     this.context = context;\n     this.delegate = delegate;\n     this.type = type;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.Gson;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonIOException;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.LazilyParsedNumber;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n \n   public static final TypeAdapter.Factory TIMESTAMP_FACTORY = new TypeAdapter.Factory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n       if (typeToken.getRawType() != Timestamp.class) {\n         return null;\n       }\n   public static <TT> TypeAdapter.Factory newEnumTypeHierarchyFactory(final Class<TT> clazz) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return clazz.isAssignableFrom(rawType)\n           ? (TypeAdapter<T>) new EnumTypeAdapter(rawType) : null;\n       final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n     };\n       final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       @Override public String toString() {\n       final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       final Class<TT> clazz, final TypeAdapter<TT> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\")\n-      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n         return clazz.isAssignableFrom(typeToken.getRawType()) ? (TypeAdapter<T>) typeAdapter : null;\n       }\n       @Override public String toString() {\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n package com.google.gson;\n \n import com.google.gson.common.TestTypes.ClassWithNoFields;\n-import com.google.gson.internal.bind.TypeAdapter;\n import java.lang.reflect.Modifier;\n import java.util.Collections;\n import java.util.LinkedList;\n--- a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.bind.MiniGson;\n-import com.google.gson.internal.bind.TypeAdapter;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Map;\n import junit.framework.TestCase;\n \n public final class ObjectTypeAdapterTest extends TestCase {\n-  private final MiniGson gson = new MiniGson.Builder().build();\n+  private final Gson gson = new GsonBuilder().create();\n   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);\n \n   public void testDeserialize() throws Exception {\n \n   @SuppressWarnings(\"unused\")\n   public void testSerialize() throws Exception {\n-    Object object = new Object() {\n-      Object a = 5;\n-      Object b = Arrays.asList(1, 2, null);\n-    };\n+    Object object = new RuntimeType();\n     assertEquals(\"{'a':5,'b':[1,2,null]}\", adapter.toJson(object).replace(\"\\\"\", \"'\"));\n   }\n \n   public void testSerializeObject() throws Exception {\n     assertEquals(\"{}\", adapter.toJson(new Object()));\n   }\n+\n+  private class RuntimeType {\n+    Object a = 5;\n+    Object b = Arrays.asList(1, 2, null);\n+  }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+public final class StreamingTypeAdaptersTest extends TestCase {\n+  private Gson miniGson = new GsonBuilder().create();\n+  private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n+  private TypeAdapter<Map<String, Double>> mapAdapter\n+      = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});\n+\n+  public void testSerialize() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n+    truck.horsePower = 300;\n+\n+    assertEquals(\"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserialize() throws IOException {\n+    String json = \"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\";\n+    Truck truck = truckAdapter.fromJson(json);\n+    assertEquals(300.0, truck.horsePower);\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29)), truck.passengers);\n+  }\n+\n+  public void testSerializeNullField() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = null;\n+    assertEquals(\"{'horsePower':0.0,'passengers':null}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeNullField() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':null}\");\n+    assertNull(truck.passengers);\n+  }\n+\n+  public void testSerializeNullObject() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList((Person) null);\n+    assertEquals(\"{'horsePower':0.0,'passengers':[null]}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeNullObject() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':[null]}\");\n+    assertEquals(Arrays.asList((Person) null), truck.passengers);\n+  }\n+\n+  public void testSerializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n+    assertEquals(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\");\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", -1), new Person(\"Jodie\", -1)), truck.passengers);\n+  }\n+\n+  private void usePersonNameAdapter() {\n+    TypeAdapter<Person> personNameAdapter = new TypeAdapter<Person>() {\n+      @Override public Person read(JsonReader reader) throws IOException {\n+        String name = reader.nextString();\n+        return new Person(name, -1);\n+      }\n+      @Override public void write(JsonWriter writer, Person value) throws IOException {\n+        writer.value(value.name);\n+      }\n+    };\n+    miniGson = new GsonBuilder().typeAdapter(Person.class, personNameAdapter).create();\n+    truckAdapter = miniGson.getAdapter(Truck.class);\n+  }\n+\n+  public void testSerializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(\"{'a':5.0,'b':10.0}\", mapAdapter.toJson(map).replace('\"', '\\''));\n+  }\n+\n+  public void testDeserializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(map, mapAdapter.fromJson(\"{'a':5.0,'b':10.0}\"));\n+  }\n+\n+  public void testSerialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    assertEquals(\"[1.0,2.0,3.0]\", arrayAdapter.toJson(new double[]{1.0, 2.0, 3.0}));\n+  }\n+\n+  public void testDeserialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    double[] array = arrayAdapter.fromJson(\"[1.0,2.0,3.0]\");\n+    assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));\n+  }\n+\n+  public void testSerialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = { {1.0, 2.0 }, { 3.0 } };\n+    assertEquals(\"[[1.0,2.0],[3.0]]\", arrayAdapter.toJson(array));\n+  }\n+\n+  public void testDeserialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = arrayAdapter.fromJson(\"[[1.0,2.0],[3.0]]\");\n+    double[][] expected = { {1.0, 2.0 }, { 3.0 } };\n+    assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));\n+  }\n+\n+  public void testSerializeRecursive() throws IOException {\n+    TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);\n+    Node root = new Node(\"root\");\n+    root.left = new Node(\"left\");\n+    root.right = new Node(\"right\");\n+    assertEquals(\"{'label':'root',\"\n+        + \"'left':{'label':'left','left':null,'right':null},\"\n+        + \"'right':{'label':'right','left':null,'right':null}}\",\n+        nodeAdapter.toJson(root).replace('\"', '\\''));\n+  }\n+\n+  static class Truck {\n+    double horsePower;\n+    List<Person> passengers = Collections.emptyList();\n+  }\n+\n+  static class Person {\n+    int age;\n+    String name;\n+    Person(String name, int age) {\n+      this.name = name;\n+      this.age = age;\n+    }\n+\n+    public Person() {} // TODO: use Joel's constructor code so we don't need this\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Person\n+          && ((Person) o).name.equals(name)\n+          && ((Person) o).age == age;\n+    }\n+    @Override public int hashCode() {\n+      return name.hashCode() ^ age;\n+    }\n+  }\n+\n+  static class Node {\n+    String label;\n+    Node left;\n+    Node right;\n+    Node(String label) {\n+      this.label = label;\n+    }\n+    public Node() {} // TODO: use Joel's constructor code so we don't need this\n+  }\n+}", "timestamp": 1321802588, "metainfo": ""}