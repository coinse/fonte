{"sha": "f6a332971f1f27be44fc40d2e8d9b8a34017f776", "log": "Warning fixes.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n   private static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =\n     new DefaultTimestampDeserializer();\n \n-  @SuppressWarnings({ \"rawtypes\" })\n+  @SuppressWarnings(\"unchecked\")\n   private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();\n   private static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();\n   private static final UriTypeAdapter URI_TYPE_ADAPTER = new UriTypeAdapter();\n   private static final PropertiesCreator PROPERTIES_CREATOR = new PropertiesCreator();\n   private static final TreeSetCreator TREE_SET_CREATOR = new TreeSetCreator();\n   private static final HashSetCreator HASH_SET_CREATOR = new HashSetCreator();\n-  private static final GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER = \n+  private static final GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER =\n     new GregorianCalendarTypeAdapter();\n \n   // The constants DEFAULT_SERIALIZERS, DEFAULT_DESERIALIZERS, and DEFAULT_INSTANCE_CREATORS\n     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n     map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n-    \n+\n     // Add primitive serializers\n     map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n     map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\n     map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\n-    \n+\n     // Add primitive deserializers\n     map.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\n     map.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\n     return map;\n   }\n \n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  @SuppressWarnings(\"unchecked\")\n   private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\n     return new JsonDeserializerExceptionWrapper(deserializer);\n   }\n   static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n     return getDefaultSerializers(false, LongSerializationPolicy.DEFAULT);\n   }\n-      \n+\n   static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\n       boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) {\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n-    \n+\n     // Double primitive\n-    DefaultTypeAdapters.DoubleSerializer doubleSerializer = \n+    DefaultTypeAdapters.DoubleSerializer doubleSerializer =\n         new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues);\n     serializers.registerIfAbsent(Double.class, doubleSerializer);\n     serializers.registerIfAbsent(double.class, doubleSerializer);\n \n     // Float primitive\n-    DefaultTypeAdapters.FloatSerializer floatSerializer = \n+    DefaultTypeAdapters.FloatSerializer floatSerializer =\n         new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues);\n     serializers.registerIfAbsent(Float.class, floatSerializer);\n     serializers.registerIfAbsent(float.class, floatSerializer);\n \n     // Long primitive\n-    DefaultTypeAdapters.LongSerializer longSerializer = \n+    DefaultTypeAdapters.LongSerializer longSerializer =\n         new DefaultTypeAdapters.LongSerializer(longSerializationPolicy);\n     serializers.registerIfAbsent(Long.class, longSerializer);\n     serializers.registerIfAbsent(long.class, longSerializer);\n     serializers.registerIfAbsent(DEFAULT_SERIALIZERS);\n     return serializers;\n   }\n-  \n+\n   static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() {\n     return DEFAULT_DESERIALIZERS;\n   }\n-  \n+\n   static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() {\n     return DEFAULT_INSTANCE_CREATORS;\n   }\n     DefaultDateTypeAdapter(final String datePattern) {\n       this.format = new SimpleDateFormat(datePattern);\n     }\n-    \n+\n     DefaultDateTypeAdapter(final int style) {\n       this.format = DateFormat.getDateInstance(style);\n     }\n         throw new JsonSyntaxException(e);\n       }\n     }\n-    \n+\n     @Override\n     public String toString() {\n       StringBuilder sb = new StringBuilder();\n         String dateFormatAsString = format.format(src);\n         return new JsonPrimitive(dateFormatAsString);\n       }\n-    }    \n+    }\n+\n     public java.sql.Date deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       if (!(json instanceof JsonPrimitive)) {\n     }\n   }\n \n-  private static class GregorianCalendarTypeAdapter \n+  private static class GregorianCalendarTypeAdapter\n       implements JsonSerializer<GregorianCalendar>, JsonDeserializer<GregorianCalendar> {\n \n     private static final String YEAR = \"year\";\n       obj.addProperty(MONTH, src.get(Calendar.MONTH));\n       obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH));\n       obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY));\n-      obj.addProperty(MINUTE, src.get(Calendar.MINUTE));      \n-      obj.addProperty(SECOND, src.get(Calendar.SECOND));      \n+      obj.addProperty(MINUTE, src.get(Calendar.MINUTE));\n+      obj.addProperty(SECOND, src.get(Calendar.SECOND));\n       return obj;\n     }\n-    \n+\n     public GregorianCalendar deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       JsonObject obj = json.getAsJsonObject();\n       int month = obj.get(MONTH).getAsInt();\n       int dayOfMonth = obj.get(DAY_OF_MONTH).getAsInt();\n       int hourOfDay = obj.get(HOUR_OF_DAY).getAsInt();\n-      int minute = obj.get(MINUTE).getAsInt();      \n-      int second = obj.get(SECOND).getAsInt();      \n+      int minute = obj.get(MINUTE).getAsInt();\n+      int second = obj.get(SECOND).getAsInt();\n       return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n     }\n-    \n+\n     @Override\n     public String toString() {\n       return GregorianCalendarTypeAdapter.class.getSimpleName();\n     }\n   }\n-  \n+\n   @SuppressWarnings(\"unchecked\")\n   private static class EnumTypeAdapter<T extends Enum<T>>\n       implements JsonSerializer<T>, JsonDeserializer<T> {\n     @Override\n     public String toString() {\n       return UrlTypeAdapter.class.getSimpleName();\n-    }    \n+    }\n   }\n \n   private static class UriTypeAdapter implements JsonSerializer<URI>, JsonDeserializer<URI> {\n       return UriTypeAdapter.class.getSimpleName();\n     }\n   }\n-  \n+\n   private static class UuidTypeAdapter implements JsonSerializer<UUID>, JsonDeserializer<UUID> {\n     public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src.toString());\n     }\n \n-    public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) \n-        throws JsonParseException {     \n+    public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n       return UUID.fromString(json.getAsString());\n     }\n \n     }\n   }\n \n-  private static class LocaleTypeAdapter \n+  private static class LocaleTypeAdapter\n       implements JsonSerializer<Locale>, JsonDeserializer<Locale> {\n     public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src.toString());\n     }\n   }\n \n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-  private static class CollectionTypeAdapter implements JsonSerializer<Collection>, \n+  @SuppressWarnings(\"unchecked\")\n+  private static class CollectionTypeAdapter implements JsonSerializer<Collection>,\n       JsonDeserializer<Collection>, InstanceCreator<Collection> {\n     public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) {\n       if (src == null) {\n       JsonArray array = new JsonArray();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = new TypeInfoCollection(typeOfSrc).getElementType();        \n+        childGenericType = new TypeInfoCollection(typeOfSrc).getElementType();\n       }\n       for (Object child : src) {\n         if (child == null) {\n       return array;\n     }\n \n-    public Collection deserialize(JsonElement json, Type typeOfT, \n+    public Collection deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       if (json.isJsonNull()) {\n         return null;\n       }\n-      // Use ObjectConstructor to create instance instead of hard-coding a specific type. \n+      // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Collection.\n       Collection collection = constructCollectionType(typeOfT, context);\n       Type childType = new TypeInfoCollection(typeOfT).getElementType();\n       return collection;\n     }\n \n-    private Collection constructCollectionType(Type collectionType, \n-        JsonDeserializationContext context) {      \n+    private Collection constructCollectionType(Type collectionType,\n+        JsonDeserializationContext context) {\n       JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context;\n       ObjectConstructor objectConstructor = contextImpl.getObjectConstructor();\n       return (Collection) objectConstructor.construct(collectionType);\n \n     public Collection createInstance(Type type) {\n       return new LinkedList();\n-    }    \n+    }\n   }\n \n   private static class PropertiesCreator implements InstanceCreator<Properties> {\n     public Properties createInstance(Type type) {\n       return new Properties();\n-    }    \n-  }\n-  \n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n   static class MapTypeAdapter implements JsonSerializer<Map>, JsonDeserializer<Map>,\n       InstanceCreator<Map> {\n-    \n+\n     public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) {\n       JsonObject map = new JsonObject();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = new TypeInfoMap(typeOfSrc).getValueType();        \n+        childGenericType = new TypeInfoMap(typeOfSrc).getValueType();\n       }\n \n       for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) {\n \n     public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n-      // Use ObjectConstructor to create instance instead of hard-coding a specific type. \n+      // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Map.\n       Map<Object, Object> map = constructMapType(typeOfT, context);\n       TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT);\n       return map;\n     }\n \n-    private Map constructMapType(Type mapType, JsonDeserializationContext context) {      \n+    private Map constructMapType(Type mapType, JsonDeserializationContext context) {\n       JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context;\n       ObjectConstructor objectConstructor = contextImpl.getObjectConstructor();\n       return (Map) objectConstructor.construct(mapType);\n     }\n-    \n+\n     public Map createInstance(Type type) {\n       return new LinkedHashMap();\n     }\n-    \n+\n     @Override\n     public String toString() {\n       return MapTypeAdapter.class.getSimpleName();\n     }\n   }\n \n-  private static class BigIntegerTypeAdapter \n+  private static class BigIntegerTypeAdapter\n       implements JsonSerializer<BigInteger>, JsonDeserializer<BigInteger> {\n \n     public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context) {\n       return BigIntegerTypeAdapter.class.getSimpleName();\n     }\n   }\n-  \n+\n   private static class NumberTypeAdapter\n       implements JsonSerializer<Number>, JsonDeserializer<Number> {\n     public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src);\n     }\n-    \n+\n     public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       return json.getAsNumber();\n     }\n-    \n+\n     @Override\n     public String toString() {\n       return NumberTypeAdapter.class.getSimpleName();\n     }\n   }\n-  \n+\n   private static class LongSerializer implements JsonSerializer<Long> {\n     private final LongSerializationPolicy longSerializationPolicy;\n-    \n+\n     private LongSerializer(LongSerializationPolicy longSerializationPolicy) {\n       this.longSerializationPolicy = longSerializationPolicy;\n     }\n     }\n   }\n \n-  private static class IntegerTypeAdapter \n+  private static class IntegerTypeAdapter\n       implements JsonSerializer<Integer>, JsonDeserializer<Integer> {\n     public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src);\n         throws JsonParseException {\n       return json.getAsShort();\n     }\n-    \n+\n     @Override\n     public String toString() {\n       return ShortTypeAdapter.class.getSimpleName();\n     public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) {\n       if (!serializeSpecialFloatingPointValues) {\n         if (Float.isNaN(src) || Float.isInfinite(src)) {\n-          throw new IllegalArgumentException(src \n+          throw new IllegalArgumentException(src\n               + \" is not a valid float value as per JSON specification. To override this\"\n               + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n         }\n       return new JsonPrimitive(src);\n     }\n   }\n-  \n+\n   private static class FloatDeserializer implements JsonDeserializer<Float> {\n     public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n     public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) {\n       if (!serializeSpecialFloatingPointValues) {\n         if (Double.isNaN(src) || Double.isInfinite(src)) {\n-          throw new IllegalArgumentException(src \n+          throw new IllegalArgumentException(src\n               + \" is not a valid double value as per JSON specification. To override this\"\n               + \" behavior, use GsonBuilder.serializeSpecialDoubleValues() method.\");\n         }\n     }\n   }\n \n-  private static class CharacterTypeAdapter \n+  private static class CharacterTypeAdapter\n       implements JsonSerializer<Character>, JsonDeserializer<Character> {\n     public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src);\n       return CharacterTypeAdapter.class.getSimpleName();\n     }\n   }\n-  \n+\n   private static class StringTypeAdapter\n       implements JsonSerializer<String>, JsonDeserializer<String> {\n     public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src);\n     }\n-    \n+\n     public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       return json.getAsString();\n     }\n-    \n+\n     @Override\n     public String toString() {\n       return StringTypeAdapter.class.getSimpleName();\n     }\n   }\n \n-  private static class BooleanTypeAdapter \n+  private static class BooleanTypeAdapter\n       implements JsonSerializer<Boolean>, JsonDeserializer<Boolean> {\n     public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context) {\n       return new JsonPrimitive(src);\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   /**\n    * objTypePair.getObject() must not be null\n    */\n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  @SuppressWarnings(\"unchecked\")\n   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\n     Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n     if (pair == null) {", "timestamp": 1288997233, "metainfo": ""}