{"sha": "8380d28e6fd1c320ad3f13aef257a907b8f04a47", "log": "removed compiler warnings", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n \n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Array;\n import java.lang.reflect.Constructor;\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.Properties;\n \n /**\n  * Provides ability to apply a visitor to an object and all of its fields\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.HashMap;\n--- a/gson/src/main/java/com/google/gson/Types.java\n+++ b/gson/src/main/java/com/google/gson/Types.java\n       if (!(b instanceof TypeVariable)) {\n         return false;\n       }\n-      TypeVariable<?> va = (TypeVariable) a;\n-      TypeVariable<?> vb = (TypeVariable) b;\n+      TypeVariable<?> va = (TypeVariable<?>) a;\n+      TypeVariable<?> vb = (TypeVariable<?>) b;\n       return va.getGenericDeclaration() == vb.getGenericDeclaration()\n           && va.getName().equals(vb.getName());\n \n   }\n \n   public static String typeToString(Type type) {\n-    return type instanceof Class ? ((Class) type).getName() : type.toString();\n+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n   }\n \n   /**\n \n     // we skip searching through interfaces if unknown is an interface\n     if (toResolve.isInterface()) {\n-      Class[] interfaces = rawType.getInterfaces();\n+      Class<?>[] interfaces = rawType.getInterfaces();\n       for (int i = 0, length = interfaces.length; i < length; i++) {\n         if (interfaces[i] == toResolve) {\n           return rawType.getGenericInterfaces()[i];\n     // this implementation is made a little more complicated in an attempt to avoid object-creation\n     while (true) {\n       if (toResolve instanceof TypeVariable) {\n-        TypeVariable typeVariable = (TypeVariable) toResolve;\n+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n         if (toResolve == typeVariable) {\n           return toResolve;\n     }\n   }\n \n+  @SuppressWarnings(\"rawtypes\")\n   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n     Class<?> declaredByRaw = declaringClassOf(unknown);\n \n    * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n    * a class.\n    */\n+  @SuppressWarnings(\"rawtypes\")\n   private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n     GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n     return genericDeclaration instanceof Class\n   }\n \n   private static void checkNotPrimitive(Type type) {\n-    checkArgument(!(type instanceof Class<?>) || !((Class) type).isPrimitive());\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n   }\n \n   private static class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n     private final Type rawType;\n     private final Type[] typeArguments;\n \n+    @SuppressWarnings(\"rawtypes\")\n     public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n       // require an owner type if the raw type needs it\n       if (rawType instanceof Class<?>) {\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n   @Override public final boolean equals(Object o) {\n     return o instanceof TypeToken<?>\n-        && Types.equals(type, ((TypeToken) o).type);\n+        && Types.equals(type, ((TypeToken<?>) o).type);\n   }\n \n   @Override public final String toString() {\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n-  public void testLenientPartialNonExecutePrefix() throws IOException {\n+  public void testLenientPartialNonExecutePrefix() {\n     JsonReader reader = new JsonReader(new StringReader(\")]}' []\"));\n     reader.setLenient(true);\n     try {", "timestamp": 1291664861, "metainfo": ""}