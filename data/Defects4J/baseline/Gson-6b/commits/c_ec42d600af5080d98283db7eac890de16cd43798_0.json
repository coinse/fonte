{"sha": "ec42d600af5080d98283db7eac890de16cd43798", "log": "Decode JSON literal types eagerly and with our own decoder.  Previously we relied on Double.parseDouble() to decode tokens. Since that method is expensive, we deferred calling it unless absolutely necessary. Now we decode the literal type immediately. For efficiency we decode the token right out of the char buffer. This makes things more complicated but it saves many calls to charAt().  It also opens up the possibility to deferring string creation.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n  * Within JSON objects, name/value pairs are represented by a single token.\n  *\n  * <h3>Parsing JSON</h3>\n- * To create a recursive descent parser your own JSON streams, first create an\n- * entry point method that creates a {@code JsonReader}.\n+ * To create a recursive descent parser for your own JSON streams, first create\n+ * an entry point method that creates a {@code JsonReader}.\n  *\n  * <p>Next, create handler methods for each structure in your JSON text. You'll\n  * need a method for each object type and for each array type.\n  *\n  *   public List<Message> readJsonStream(InputStream in) throws IOException {\n  *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n- *     return readMessagesArray(reader);\n+ *     try {\n+ *       return readMessagesArray(reader);\n+ *     } finally {\n+ *       reader.close();\n+ *     }\n  *   }\n  *\n  *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n   /** The only non-execute prefix this parser permits */\n   private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n \n+  private static final String TRUE = \"true\";\n+  private static final String FALSE = \"false\";\n+\n   private final StringPool stringPool = new StringPool();\n \n   /** The input JSON. */\n   /**\n    * Use a manual buffer to easily read and unread upcoming characters, and\n    * also so we can create strings without an intermediate StringBuilder.\n+   * We decode literals directly out of this buffer, so it must be at least as\n+   * long as the longest token that can be reported as a number.\n    */\n   private final char[] buffer = new char[1024];\n   private int pos = 0;\n   }\n \n   /**\n-   * True if we've already read the next token. If we have, the string value\n-   * for that token will be assigned to {@code value} if such a string value\n-   * exists. And the token type will be assigned to {@code token} if the token\n-   * type is known. The token type may be null for literals, since we derive\n-   * that lazily.\n-   */\n-  private boolean hasToken;\n-\n-  /**\n    * The type of the next token to be returned by {@link #peek} and {@link\n-   * #advance}, or {@code null} if it is unknown and must first be derived\n-   * from {@code value}. This value is undefined if {@code hasToken} is false.\n+   * #advance}. If null, peek() will assign a value.\n    */\n   private JsonToken token;\n \n   /** The text of the next name. */\n   private String name;\n \n-  /** The text of the next literal value. */\n+  /*\n+   * For the next literal value, we may have the text value, or the position\n+   * and length in the buffer.\n+   */\n   private String value;\n+  private int valuePos;\n+  private int valueLength;\n \n   /** True if we're currently handling a skipValue() call. */\n   private boolean skipping = false;\n    * Consumes {@code expected}.\n    */\n   private void expect(JsonToken expected) throws IOException {\n-    quickPeek();\n+    peek();\n     if (token != expected) {\n       throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n     }\n    * Returns true if the current array or object has another element.\n    */\n   public boolean hasNext() throws IOException {\n-    quickPeek();\n+    peek();\n     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n   }\n \n    * Returns the type of the next token without consuming it.\n    */\n   public JsonToken peek() throws IOException {\n-    quickPeek();\n-\n-    if (token == null) {\n-      decodeLiteral();\n-    }\n-\n-    return token;\n-  }\n-\n-  /**\n-   * Ensures that a token is ready. After this call either {@code token} or\n-   * {@code value} will be non-null. To ensure {@code token} has a definitive\n-   * value, use {@link #peek()}\n-   */\n-  private JsonToken quickPeek() throws IOException {\n-    if (hasToken) {\n+    if (token != null) {\n       return token;\n     }\n \n       }\n       replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n       JsonToken firstToken = nextValue();\n-      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n-        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n+      if (!lenient && token != JsonToken.BEGIN_ARRAY && token != JsonToken.BEGIN_OBJECT) {\n+        throw new IOException(\n+            \"Expected JSON document to start with '[' or '{' but was \" + token);\n       }\n       return firstToken;\n     case EMPTY_ARRAY:\n         }\n         throw syntaxError(\"Expected EOF\");\n       } catch (EOFException e) {\n-        hasToken = true; // TODO: avoid throwing here?\n-        return token = JsonToken.END_DOCUMENT;\n+        return token = JsonToken.END_DOCUMENT; // TODO: avoid throwing here?\n       }\n     case CLOSED:\n       throw new IllegalStateException(\"JsonReader is closed\");\n    * Advances the cursor in the JSON stream to the next token.\n    */\n   private JsonToken advance() throws IOException {\n-    quickPeek();\n+    peek();\n \n     JsonToken result = token;\n-    hasToken = false;\n     token = null;\n     value = null;\n     name = null;\n    *     name.\n    */\n   public String nextName() throws IOException {\n-    quickPeek();\n+    peek();\n     if (token != JsonToken.NAME) {\n       throw new IllegalStateException(\"Expected a name but was \" + peek());\n     }\n    */\n   public String nextString() throws IOException {\n     peek();\n-    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n+    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n       throw new IllegalStateException(\"Expected a string but was \" + peek());\n     }\n \n    *     this reader is closed.\n    */\n   public boolean nextBoolean() throws IOException {\n-    quickPeek();\n-    if (value == null || token == JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n-    }\n-\n-    boolean result;\n-    if (value.equalsIgnoreCase(\"true\")) {\n-      result = true;\n-    } else if (value.equalsIgnoreCase(\"false\")) {\n-      result = false;\n-    } else {\n-      throw new IllegalStateException(\"Not a boolean: \" + value);\n-    }\n-\n+    peek();\n+    if (token != JsonToken.BOOLEAN) {\n+        throw new IllegalStateException(\"Expected a boolean but was \" + token);\n+    }\n+\n+    boolean result = (value == TRUE);\n     advance();\n     return result;\n   }\n    *     reader is closed.\n    */\n   public void nextNull() throws IOException {\n-    quickPeek();\n-    if (value == null || token == JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected null but was \" + peek());\n-    }\n-\n-    if (!value.equalsIgnoreCase(\"null\")) {\n-      throw new IllegalStateException(\"Not a null: \" + value);\n+    peek();\n+    if (token != JsonToken.NULL) {\n+      throw new IllegalStateException(\"Expected null but was \" + token);\n     }\n \n     advance();\n   /**\n    * Returns the {@link JsonToken#NUMBER double} value of the next token,\n    * consuming it. If the next token is a string, this method will attempt to\n-   * parse it as a double.\n+   * parse it as a double using {@link Double#parseDouble(String)}.\n    *\n    * @throws IllegalStateException if the next token is not a literal value.\n    * @throws NumberFormatException if the next literal value cannot be parsed\n    *     as a double, or is non-finite.\n    */\n   public double nextDouble() throws IOException {\n-    quickPeek();\n-    if (value == null) {\n-      throw new IllegalStateException(\"Expected a double but was \" + peek());\n+    peek();\n+    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+      throw new IllegalStateException(\"Expected a double but was \" + token);\n     }\n \n     double result = Double.parseDouble(value);\n \n     if ((result >= 1.0d && value.startsWith(\"0\"))) {\n-      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n-    }\n-\n+      throw new MalformedJsonException(\"JSON forbids octal prefixes: \" + value);\n+    }\n     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n+      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + value);\n     }\n \n     advance();\n    *     as a number, or exactly represented as a long.\n    */\n   public long nextLong() throws IOException {\n-    quickPeek();\n-    if (value == null) {\n-      throw new IllegalStateException(\"Expected a long but was \" + peek());\n+    peek();\n+    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+      throw new IllegalStateException(\"Expected a long but was \" + token);\n     }\n \n     long result;\n     }\n \n     if (result >= 1L && value.startsWith(\"0\")) {\n-      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n+      throw new MalformedJsonException(\"JSON forbids octal prefixes: \" + value);\n     }\n \n     advance();\n    *     as a number, or exactly represented as an int.\n    */\n   public int nextInt() throws IOException {\n-    quickPeek();\n-    if (value == null) {\n-      throw new IllegalStateException(\"Expected an int but was \" + peek());\n+    peek();\n+    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+      throw new IllegalStateException(\"Expected an int but was \" + token);\n     }\n \n     int result;\n     }\n \n     if (result >= 1L && value.startsWith(\"0\")) {\n-      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n+      throw new MalformedJsonException(\"JSON forbids octal prefixes: \" + value);\n     }\n \n     advance();\n    * Closes this JSON reader and the underlying {@link Reader}.\n    */\n   public void close() throws IOException {\n-    hasToken = false;\n     value = null;\n     token = null;\n     stack.clear();\n       switch (nextNonWhitespace()) {\n       case ']':\n         pop();\n-        hasToken = true;\n         return token = JsonToken.END_ARRAY;\n       case ';':\n         checkLenient(); // fall-through\n     case ']':\n       if (firstElement) {\n         pop();\n-        hasToken = true;\n         return token = JsonToken.END_ARRAY;\n       }\n       // fall-through to handle \",]\"\n       /* In lenient mode, a 0-length literal means 'null' */\n       checkLenient();\n       pos--;\n-      hasToken = true;\n       value = \"null\";\n       return token = JsonToken.NULL;\n     default:\n       switch (nextNonWhitespace()) {\n       case '}':\n         pop();\n-        hasToken = true;\n         return token = JsonToken.END_OBJECT;\n       default:\n         pos--;\n       switch (nextNonWhitespace()) {\n       case '}':\n         pop();\n-        hasToken = true;\n         return token = JsonToken.END_OBJECT;\n       case ';':\n       case ',':\n     default:\n       checkLenient();\n       pos--;\n-      name = nextLiteral();\n+      name = nextLiteral(false);\n       if (name.length() == 0) {\n         throw syntaxError(\"Expected name\");\n       }\n     }\n \n     replaceTop(JsonScope.DANGLING_NAME);\n-    hasToken = true;\n     return token = JsonToken.NAME;\n   }\n \n     switch (c) {\n     case '{':\n       push(JsonScope.EMPTY_OBJECT);\n-      hasToken = true;\n       return token = JsonToken.BEGIN_OBJECT;\n \n     case '[':\n       push(JsonScope.EMPTY_ARRAY);\n-      hasToken = true;\n       return token = JsonToken.BEGIN_ARRAY;\n \n     case '\\'':\n       checkLenient(); // fall-through\n     case '\"':\n       value = nextString((char) c);\n-      hasToken = true;\n       return token = JsonToken.STRING;\n \n     default:\n   }\n \n   /**\n-   * Returns the string up to but not including any delimiter characters. This\n+   * Reads the value up to but not including any delimiter characters. This\n    * does not consume the delimiter character.\n+   *\n+   * @param assignOffsetsOnly true for this method to only set the valuePos\n+   *     and valueLength fields and return a null result. This only works if\n+   *     the literal is short; a string is returned otherwise.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private String nextLiteral() throws IOException {\n+  private String nextLiteral(boolean assignOffsetsOnly) throws IOException {\n     StringBuilder builder = null;\n-    do {\n-      /* the index of the first character not yet appended to the builder. */\n-      int start = pos;\n-      while (pos < limit) {\n-        int c = buffer[pos++];\n-        switch (c) {\n+    valuePos = -1;\n+    valueLength = 0;\n+    int i = 0;\n+\n+    findNonLiteralCharacter:\n+    while (true) {\n+      for (; pos + i < limit; i++) {\n+        switch (buffer[pos + i]) {\n         case '/':\n         case '\\\\':\n         case ';':\n         case '#':\n         case '=':\n-          checkLenient(); // fall-through\n-\n+            checkLenient(); // fall-through\n         case '{':\n         case '}':\n         case '[':\n         case '\\f':\n         case '\\r':\n         case '\\n':\n-          pos--;\n-          if (skipping) {\n-            return \"skipped!\";\n-          } else if (builder == null) {\n-            return stringPool.get(buffer, start, pos - start);\n-          } else {\n-            builder.append(buffer, start, pos - start);\n-            return builder.toString();\n-          }\n+            break findNonLiteralCharacter;\n         }\n       }\n \n+      /*\n+       * Attempt to load the entire literal into the buffer at once. If\n+       * we run out of input, add a non-literal character at the end so\n+       * that decoding doesn't need to do bounds checks.\n+       */\n+      if (i < buffer.length) {\n+        if (fillBuffer(i + 1)) {\n+          continue;\n+        } else {\n+          buffer[limit] = '\\0';\n+          break;\n+        }\n+      }\n+\n+      // use a StringBuilder when the value is too long. It must be an unquoted string.\n       if (builder == null) {\n         builder = new StringBuilder();\n       }\n-      builder.append(buffer, start, pos - start);\n-    } while (fillBuffer(1));\n-\n-    return builder.toString();\n+      builder.append(buffer, pos, i);\n+      valueLength += i;\n+      pos += i;\n+      i = 0;\n+      if (!fillBuffer(1)) {\n+        break;\n+      }\n+    }\n+\n+    String result;\n+    if (assignOffsetsOnly && builder == null) {\n+      valuePos = pos;\n+      result = null;\n+    } else if (skipping) {\n+      result = \"skipped!\";\n+    } else if (builder == null) {\n+      result = stringPool.get(buffer, pos, i);\n+    } else {\n+      builder.append(buffer, pos, i);\n+      result = builder.toString();\n+    }\n+    valueLength += i;\n+    pos += i;\n+    return result;\n   }\n \n   @Override public String toString() {\n    * Reads a null, boolean, numeric or unquoted string literal value.\n    */\n   private JsonToken readLiteral() throws IOException {\n-    String literal = nextLiteral();\n-    if (literal.length() == 0) {\n+    value = nextLiteral(true);\n+    if (valueLength == 0) {\n       throw syntaxError(\"Expected literal value\");\n     }\n-    value = literal;\n-    hasToken = true;\n-    return token = null; // use decodeLiteral() to get the token type\n+    token = decodeLiteral();\n+    if (token == JsonToken.STRING) {\n+      checkLenient();\n+    }\n+    return token;\n   }\n \n   /**\n    * Assigns {@code nextToken} based on the value of {@code nextValue}.\n    */\n-  private void decodeLiteral() throws IOException {\n-    if (value.equalsIgnoreCase(\"null\")) {\n-      token = JsonToken.NULL;\n-    } else if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")) {\n-      token = JsonToken.BOOLEAN;\n+  private JsonToken decodeLiteral() throws IOException {\n+    if (valuePos == -1) {\n+      // it was too long to fit in the buffer so it can only be a string\n+      return JsonToken.STRING;\n+    } else if (valueLength == 4\n+        && ('n' == buffer[valuePos    ] || 'N' == buffer[valuePos    ])\n+        && ('u' == buffer[valuePos + 1] || 'U' == buffer[valuePos + 1])\n+        && ('l' == buffer[valuePos + 2] || 'L' == buffer[valuePos + 2])\n+        && ('l' == buffer[valuePos + 3] || 'L' == buffer[valuePos + 3])) {\n+      value = \"null\";\n+      return JsonToken.NULL;\n+    } else if (valueLength == 4\n+        && ('t' == buffer[valuePos    ] || 'T' == buffer[valuePos    ])\n+        && ('r' == buffer[valuePos + 1] || 'R' == buffer[valuePos + 1])\n+        && ('u' == buffer[valuePos + 2] || 'U' == buffer[valuePos + 2])\n+        && ('e' == buffer[valuePos + 3] || 'E' == buffer[valuePos + 3])) {\n+      value = TRUE;\n+      return JsonToken.BOOLEAN;\n+    } else if (valueLength == 5\n+        && ('f' == buffer[valuePos    ] || 'F' == buffer[valuePos    ])\n+        && ('a' == buffer[valuePos + 1] || 'A' == buffer[valuePos + 1])\n+        && ('l' == buffer[valuePos + 2] || 'L' == buffer[valuePos + 2])\n+        && ('s' == buffer[valuePos + 3] || 'S' == buffer[valuePos + 3])\n+        && ('e' == buffer[valuePos + 4] || 'E' == buffer[valuePos + 4])) {\n+      value = FALSE;\n+      return JsonToken.BOOLEAN;\n     } else {\n-      try {\n-        Double.parseDouble(value); // this work could potentially be cached\n-        token = JsonToken.NUMBER;\n-      } catch (NumberFormatException ignored) {\n-        // this must be an unquoted string\n-        checkLenient();\n-        token = JsonToken.STRING;\n-      }\n+      value = stringPool.get(buffer, valuePos, valueLength);\n+      return decodeNumber(buffer, valuePos, valueLength);\n+    }\n+  }\n+\n+  /**\n+   * Determine whether the characters is a JSON number. Numbers are of the\n+   * form -12.34e+56. Fractional and exponential parts are optional. Leading\n+   * zeroes are not allowed in the value or exponential part, but are allowed\n+   * in the fraction.\n+   */\n+  private JsonToken decodeNumber(char[] chars, int offset, int length) {\n+    int i = offset;\n+    int c = chars[i];\n+\n+    if (c == '-') {\n+      c = chars[++i];\n+    }\n+\n+    if (c == '0') {\n+      c = chars[++i];\n+    } else if (c >= '1' && c <= '9') {\n+      c = chars[++i];\n+      while (c >= '0' && c <= '9') {\n+        c = chars[++i];\n+      }\n+    } else {\n+      return JsonToken.STRING;\n+    }\n+\n+    if (c == '.') {\n+      c = chars[++i];\n+      while (c >= '0' && c <= '9') {\n+        c = chars[++i];\n+      }\n+    }\n+\n+    if (c == 'e' || c == 'E') {\n+      c = chars[++i];\n+      if (c == '+' || c == '-') {\n+        c = chars[++i];\n+      }\n+      if (c >= '0' && c <= '9') {\n+        c = chars[++i];\n+        while (c >= '0' && c <= '9') {\n+          c = chars[++i];\n+        }\n+      } else {\n+        return JsonToken.STRING;\n+      }\n+    }\n+\n+    if (i == offset + length) {\n+      return JsonToken.NUMBER;\n+    } else {\n+      return JsonToken.STRING;\n     }\n   }\n \n   static {\n     JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n       @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n-        reader.quickPeek();\n+        reader.peek();\n         if (reader.token != JsonToken.NAME) {\n           throw new IllegalStateException(\"Expected a name but was \" + reader.peek());\n         }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     try {\n       reader.nextDouble();\n       fail();\n-    } catch (NumberFormatException expected) {\n+    } catch (MalformedJsonException expected) {\n     }\n   }\n \n     JsonReader reader = new JsonReader(new StringReader(json));\n     reader.beginArray();\n     try {\n+      reader.peek();\n+      fail();\n+    } catch (MalformedJsonException expected) {\n+    }\n+    try {\n       reader.nextInt();\n       fail();\n-    } catch (NumberFormatException expected) {\n+    } catch (MalformedJsonException expected) {\n     }\n     try {\n       reader.nextLong();\n       fail();\n-    } catch (NumberFormatException expected) {\n+    } catch (MalformedJsonException expected) {\n     }\n     try {\n       reader.nextDouble();\n       fail();\n-    } catch (NumberFormatException expected) {\n+    } catch (MalformedJsonException expected) {\n     }\n     assertEquals(\"01\", reader.nextString());\n     reader.endArray();", "timestamp": 1322412645, "metainfo": ""}