{"sha": "51881c7f4a60d62e0b71ff0dfef78c18bdb1005f", "log": "Added a GsonBuilder setting to enable serialization of special double types, NaN, Infinity, and -Infinity.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n     map.register(byte.class, BYTE_TYPE_ADAPTER);\n     map.register(Character.class, CHARACTER_TYPE_ADAPTER);\n     map.register(char.class, CHARACTER_TYPE_ADAPTER);\n-    map.register(Double.class, DOUBLE_TYPE_ADAPTER);\n-    map.register(double.class, DOUBLE_TYPE_ADAPTER);\n-    map.register(Float.class, FLOAT_TYPE_ADAPTER);\n-    map.register(float.class, FLOAT_TYPE_ADAPTER);\n     map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n     map.register(int.class, INTEGER_TYPE_ADAPTER);\n     map.register(Long.class, LONG_TYPE_ADAPTER);\n     return new JsonDeserializerExceptionWrapper(deserializer);\n   }\n \n+  static void registerSerializersForFloatingPoints(boolean serializeSpecialFloatingPointValues,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\n+    DefaultTypeAdapters.DoubleSerializer doubleSerializer = \n+      new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues);\n+    DefaultTypeAdapters.FloatSerializer floatSerializer = \n+      new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues);\n+    serializers.registerIfAbsent(Double.class, doubleSerializer);\n+    serializers.registerIfAbsent(double.class, doubleSerializer);\n+    serializers.registerIfAbsent(Float.class, floatSerializer);\n+    serializers.registerIfAbsent(float.class, floatSerializer);\n+  }\n+\n   static class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n \n     private final DateFormat format;\n     }\n   }\n \n-  private static class FloatTypeAdapter\n-      implements InstanceCreator<Float>, JsonSerializer<Float>, JsonDeserializer<Float> {\n+  static class FloatSerializer implements JsonSerializer<Float> {\n+    private final boolean serializeSpecialFloatingPointValues;\n+\n+    FloatSerializer(boolean serializeSpecialDoubleValues) {\n+      this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n+    }\n+\n     public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) {\n-      if (Float.isNaN(src) || Float.isInfinite(src)) {\n-        throw new IllegalArgumentException(src + \" is not a valid double value as per JavaScript specification.\");\n-      }\n-      return new JsonPrimitive(src);\n-    }\n+      if (!serializeSpecialFloatingPointValues) {\n+        if (Float.isNaN(src) || Float.isInfinite(src)) {\n+          throw new IllegalArgumentException(src \n+              + \" is not a valid float value as per JSON specification. To override this\"\n+              + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n+        }\n+      }\n+      return new JsonPrimitive(src);\n+    }\n+  }\n+  \n+  private static class FloatTypeAdapter implements InstanceCreator<Float>, JsonDeserializer<Float> {\n \n     public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n     }\n   }\n \n-  private static class DoubleTypeAdapter\n-      implements InstanceCreator<Double>, JsonSerializer<Double>, JsonDeserializer<Double> {\n+  static class DoubleSerializer implements JsonSerializer<Double> {\n+    private final boolean serializeSpecialFloatingPointValues;\n+\n+    DoubleSerializer(boolean serializeSpecialDoubleValues) {\n+      this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n+    }\n     public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) {\n-      if (Double.isNaN(src) || Double.isInfinite(src)) {\n-        throw new IllegalArgumentException(src + \" is not a valid double value as per JavaScript specification.\");\n-      }\n-      return new JsonPrimitive(src);\n-    }\n-\n+      if (!serializeSpecialFloatingPointValues) {\n+        if (Double.isNaN(src) || Double.isInfinite(src)) {\n+          throw new IllegalArgumentException(src \n+              + \" is not a valid double value as per JSON specification. To override this\"\n+              + \" behavior, use GsonBuilder.serializeSpecialDoubleValues() method.\");\n+        }\n+      }\n+      return new JsonPrimitive(src);\n+    }\n+  }\n+\n+  private static class DoubleTypeAdapter implements InstanceCreator<Double>, \n+      JsonDeserializer<Double> {\n+    \n     public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       return json.getAsDouble();\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    * encountering inner class references.\n    */\n   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n-    this(strategy, fieldNamingPolicy, createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),\n+    this(strategy, fieldNamingPolicy, \n+        createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),\n         DEFAULT_JSON_FORMATTER, false,\n-        DefaultTypeAdapters.DEFAULT_SERIALIZERS, DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n+        getDefaultSerializers(), DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n   }\n \n   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy, \n     this.deserializers = deserializers;\n   }\n \n+  private static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n+    ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = \n+      DefaultTypeAdapters.DEFAULT_SERIALIZERS.copyOf();\n+    DefaultTypeAdapters.registerSerializersForFloatingPoints(false, serializers);    \n+    return serializers;\n+  }\n+  \n   static MappedObjectConstructor createObjectConstructor(\n       ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n     MappedObjectConstructor objectConstructor = new MappedObjectConstructor();\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private String datePattern;\n   private int dateStyle;\n   private int timeStyle;\n+  private boolean serializeSpecialFloatingPointValues;\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n     serializeNulls = false;\n     dateStyle = DateFormat.DEFAULT;\n     timeStyle = DateFormat.DEFAULT;\n+    serializeSpecialFloatingPointValues = false;\n   }\n \n   /**\n   }\n \n   /**\n+   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n+   * special double values (NaN, Infinity, -Infinity). However, \n+   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript \n+   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n+   * values. Moreover, most JavaScript engines will accept these special values in JSON without \n+   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n+   * though JSON specification disallows them. \n+   * \n+   * <p>Gson always accepts these special values during deserialization. However, it outputs \n+   * strictly compliant JSON. Hence, if it encounters a float value {@link Float.NaN}, \n+   * {@link Float.POSITIVE_INFINITY}, {@link Float.NEGATIVE_INFINITY}, or a double value \n+   * {@link Double.NaN}, {@link Double.POSITIVE_INFINITY}, {@link Double.NEGATIVE_INFINITY}, it \n+   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n+   * default behavior when you know that the JSON receiver will be able to handle these special\n+   * values.   \n+   * \n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @Since 1.3\n+   */\n+  public GsonBuilder serializeSpecialFloatingPointValues() {\n+    this.serializeSpecialFloatingPointValues = true;\n+    return this;\n+  }\n+\n+  /**\n    * Creates a {@link Gson} instance based on the current configuration. This method is free of\n    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n    *\n     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, \n         customDeserializers);\n     customSerializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_SERIALIZERS);\n+    DefaultTypeAdapters.registerSerializersForFloatingPoints(serializeSpecialFloatingPointValues,\n+       customSerializers);\n     customDeserializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n-\n+    \n     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n       instanceCreators.copyOf();\n     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS);\n         formatter, serializeNulls, customSerializers, customDeserializers);\n     return gson;\n   }\n-\n+  \n   private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n       if (!map.containsKey(entry.getKey())) {\n         register(entry.getKey(), entry.getValue());\n       }\n+    }\n+  }\n+\n+  public synchronized void registerIfAbsent(Type typeOfT, T value) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    if (!map.containsKey(typeOfT)) {\n+      register(typeOfT, value);\n     }\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n     return json.substring(json.indexOf('[') + 1, json.indexOf(']'));\n   }\n   \n-  public void testDoubleNaNSerializationNotSupported() {\n-    double nan = (double) Double.NaN;\n+  public void testDoubleNaNSerializationNotSupportedByDefault() {\n+    double nan = Double.NaN;\n     try {\n       gson.toJson(nan);\n       gson.toJson(Double.NaN);\n     } catch (IllegalArgumentException expected) {      \n     }\n   }\n-  \n-  public void testDoubleNaNDeserializationNotSupported() {\n+    \n+  public void testDoubleNaNSerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    double nan = Double.NaN;\n+    assertEquals(\"NaN\", gson.toJson(nan));\n+    assertEquals(\"NaN\", gson.toJson(Double.NaN));\n+  }\n+  \n+  public void testDoubleNaNDeserialization() {\n     assertTrue(Double.isNaN(gson.fromJson(\"NaN\", Double.class)));\n     assertTrue(Double.isNaN(gson.fromJson(\"NaN\", double.class)));\n   }\n-  public void testFloatNaNSerializationNotSupported() {\n-    float nan = (float) Float.NaN;\n+  \n+  public void testFloatNaNSerializationNotSupportedByDefault() {\n+    float nan = Float.NaN;\n     try {\n       gson.toJson(nan);\n       gson.toJson(Float.NaN);\n     }\n   }\n   \n-  public void testFloatNaNDeserializationNotSupported() {\n+  public void testFloatNaNSerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    float nan = Float.NaN;\n+    assertEquals(\"NaN\", gson.toJson(nan));\n+    assertEquals(\"NaN\", gson.toJson(Float.NaN));\n+  }\n+  \n+  public void testFloatNaNDeserialization() {\n     assertTrue(Float.isNaN(gson.fromJson(\"NaN\", Float.class)));\n     assertTrue(Float.isNaN(gson.fromJson(\"NaN\", float.class)));\n   }\n   public void testBigDecimalNaNDeserializationNotSupported() {\n     try {\n       gson.fromJson(\"NaN\", BigDecimal.class);\n-      fail(\"Gson should not accept NaN for deserialization\");\n+      fail(\"Gson should not accept NaN for deserialization by default.\");\n     } catch (JsonParseException expected) {      \n     }\n   }\n \n-  public void testDoubleInfinitySerializationNotSupported() {\n-    double infinity = (double)Double.POSITIVE_INFINITY;\n+  public void testDoubleInfinitySerializationNotSupportedByDefault() {\n+    double infinity = Double.POSITIVE_INFINITY;\n     try {\n       gson.toJson(infinity);\n       gson.toJson(Double.POSITIVE_INFINITY);\n-      fail(\"Gson should not accept positive infinity for serialization\");\n+      fail(\"Gson should not accept positive infinity for serialization by default.\");\n     } catch (IllegalArgumentException expected) {      \n     }\n   }\n   \n-  public void testDoubleInfinityDeserializationNotSupported() {\n+  public void testDoubleInfinitySerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    double infinity = Double.POSITIVE_INFINITY;\n+    assertEquals(\"Infinity\", gson.toJson(infinity));\n+    assertEquals(\"Infinity\", gson.toJson(Double.POSITIVE_INFINITY));\n+  }\n+  \n+  public void testDoubleInfinityDeserialization() {\n     assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", Double.class)));\n     assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", double.class)));\n   }\n   \n-  public void testFloatInfinitySerializationNotSupported() {\n-    float infinity = (float) Float.POSITIVE_INFINITY;\n+  public void testFloatInfinitySerializationNotSupportedByDefault() {\n+    float infinity = Float.POSITIVE_INFINITY;\n     try {\n       gson.toJson(infinity);\n       gson.toJson(Float.POSITIVE_INFINITY);\n-      fail(\"Gson should not accept positive infinity for serialization\");\n+      fail(\"Gson should not accept positive infinity for serialization by default\");\n     } catch (IllegalArgumentException expected) {      \n     }\n   }\n   \n-  public void testFloatInfinityDeserializationNotSupported() {\n+  public void testFloatInfinitySerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    float infinity = Float.POSITIVE_INFINITY;\n+    assertEquals(\"Infinity\", gson.toJson(infinity));\n+    assertEquals(\"Infinity\", gson.toJson(Float.POSITIVE_INFINITY));\n+  }\n+  \n+  public void testFloatInfinityDeserialization() {\n     assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", Float.class)));\n     assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", float.class)));\n   }\n   public void testBigDecimalInfinityDeserializationNotSupported() {\n     try {\n       gson.fromJson(\"Infinity\", BigDecimal.class);\n-      fail(\"Gson should not accept positive infinity for deserialization\");\n+      fail(\"Gson should not accept positive infinity for deserialization with BigDecimal\");\n     } catch (JsonParseException expected) {      \n     }\n   }\n   \n-  public void testNegativeInfinitySerializationNotSupported() {\n-    double negativeInfinity = (double)Double.NEGATIVE_INFINITY;\n+  public void testNegativeInfinitySerializationNotSupportedByDefault() {\n+    double negativeInfinity = Double.NEGATIVE_INFINITY;\n     try {\n       gson.toJson(negativeInfinity);\n       gson.toJson(Double.NEGATIVE_INFINITY);\n-      fail(\"Gson should not accept positive infinity for serialization\");\n+      fail(\"Gson should not accept negative infinity for serialization by default\");\n     } catch (IllegalArgumentException expected) {      \n     }\n   }\n   \n-  public void testNegativeInfinityDeserializationNotSupported() {\n+  public void testNegativeInfinitySerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    double negativeInfinity = Double.NEGATIVE_INFINITY;\n+    assertEquals(\"-Infinity\", gson.toJson(negativeInfinity));\n+    assertEquals(\"-Infinity\", gson.toJson(Double.NEGATIVE_INFINITY));\n+  }\n+  \n+  public void testNegativeInfinityDeserialization() {\n     assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", double.class)));\n     assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", Double.class)));\n   }\n   \n-  public void testNegativeInfinityFloatSerializationNotSupported() {\n-    float negativeInfinity = (float) Float.NEGATIVE_INFINITY;\n+  public void testNegativeInfinityFloatSerializationNotSupportedByDefault() {\n+    float negativeInfinity = Float.NEGATIVE_INFINITY;\n     try {\n       gson.toJson(negativeInfinity);\n       gson.toJson(Float.NEGATIVE_INFINITY);\n-      fail(\"Gson should not accept positive infinity for serialization\");\n+      fail(\"Gson should not accept negative infinity for serialization by default\");\n     } catch (IllegalArgumentException expected) {      \n     }\n   }\n   \n-  public void testNegativeInfinityFloatDeserializationNotSupported() {\n+  public void testNegativeInfinityFloatSerialization() {\n+    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n+    float negativeInfinity = Float.NEGATIVE_INFINITY;\n+    assertEquals(\"-Infinity\", gson.toJson(negativeInfinity));\n+    assertEquals(\"-Infinity\", gson.toJson(Float.NEGATIVE_INFINITY));\n+  }\n+  \n+  public void testNegativeInfinityFloatDeserialization() {\n     assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", float.class)));\n     assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", Float.class)));\n   }\n   \n-  public void testNegativeInfinityBigDecimalDeserializationNotSupported() {\n+  public void testBigDecimalNegativeInfinityDeserializationNotSupported() {\n     try {\n       gson.fromJson(\"-Infinity\", BigDecimal.class);\n       fail(\"Gson should not accept positive infinity for deserialization\");\n     } catch (JsonParseException expected) {      \n     }\n-  }\n+  }  \n }", "timestamp": 1229736374, "metainfo": ""}