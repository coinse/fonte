{"sha": "907082102dad9f93d20ccf4a53ea626d5dc559eb", "log": "Added code to ensure that circular reference situations with custom handlers are detected. Split CircularReferenceTest out of ObjectTest.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/CircularReferenceException.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Exception class to indicate a circular reference error.\n+ * This class is not part of the public API and hence is not public.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class CircularReferenceException extends RuntimeException {\n+  private static final long serialVersionUID = 7444343294106513081L;\n+  private final Object offendingNode;\n+\n+  CircularReferenceException(Object offendingNode) {\n+    super(\"circular reference error\");\n+    this.offendingNode = offendingNode;\n+  }\n+  \n+  public IllegalStateException createDetailedException(Field offendingField) {\n+    StringBuilder msg = new StringBuilder(getMessage());\n+    if (offendingField != null) {\n+      msg.append(\"\\n  \").append(\"Offending field: \").append(offendingField.getName() + \"\\n\");\n+    }\n+    if (offendingNode != null) {\n+      msg.append(\"\\n  \").append(\"Offending object: \").append(offendingNode);\n+    }\n+    return new IllegalStateException(msg.toString(), this);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/JsonPrintFormatter.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrintFormatter.java\n package com.google.gson;\n \n import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.util.Stack;\n \n /**\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n       return;\n     }\n     if (ancestors.contains(node)) {\n-      throw new IllegalStateException(\"Circular reference found: \" + node);\n+      throw new CircularReferenceException(node);\n     }\n     ancestors.push(node);\n   }\n   }\n \n   public void visitArrayField(Field f, Type typeOfF, Object obj) {\n-    if (isFieldNull(f, obj)) {\n-      if (serializeNulls) {\n-        addChildAsElement(f, JsonNull.createJsonNull());\n-      }\n-    } else {\n-      Object array = getFieldValue(f, obj);\n-      addAsChildOfObject(f, typeOfF, array);\n+    try {\n+      if (isFieldNull(f, obj)) {\n+        if (serializeNulls) {\n+          addChildAsElement(f, JsonNull.createJsonNull());\n+        }\n+      } else {\n+        Object array = getFieldValue(f, obj);\n+        addAsChildOfObject(f, typeOfF, array);\n+      }\n+    } catch (CircularReferenceException e) {\n+      throw e.createDetailedException(f);\n     }\n   }\n \n   public void visitObjectField(Field f, Type typeOfF, Object obj) {\n-    if (isFieldNull(f, obj)) {\n-      if (serializeNulls) {\n-        addChildAsElement(f, JsonNull.createJsonNull());\n-      }\n-    } else {\n-      Object fieldValue = getFieldValue(f, obj);\n-      if (fieldValue != null) {\n-        typeOfF = getActualTypeIfMoreSpecific(typeOfF, fieldValue.getClass());\n-      }\n-      addAsChildOfObject(f, typeOfF, fieldValue);\n+    try {\n+      if (isFieldNull(f, obj)) {\n+        if (serializeNulls) {\n+          addChildAsElement(f, JsonNull.createJsonNull());\n+        }\n+      } else {\n+        Object fieldValue = getFieldValue(f, obj);\n+        if (fieldValue != null) {\n+          typeOfF = getActualTypeIfMoreSpecific(typeOfF, fieldValue.getClass());\n+        }\n+        addAsChildOfObject(f, typeOfF, fieldValue);\n+      }\n+    } catch (CircularReferenceException e) {\n+      throw e.createDetailedException(f);\n     }\n   }\n \n \n   @SuppressWarnings(\"unchecked\")\n   public boolean visitUsingCustomHandler(Object obj, Type objType) {\n-    JsonSerializer serializer = serializers.getHandlerFor(objType);\n-    if (serializer == null && obj != null) {\n-      serializer = serializers.getHandlerFor(obj.getClass());\n-    }\n-\n-    if (serializer != null) {\n-      if (obj == null) {\n-        assignToRoot(JsonNull.createJsonNull());\n-      } else {\n-        assignToRoot(serializer.serialize(obj, objType, context));\n-      }\n-      return true;\n-    }\n-    return false;\n+    try {\n+      JsonSerializer serializer = serializers.getHandlerFor(objType);\n+      if (serializer == null && obj != null) {\n+        serializer = serializers.getHandlerFor(obj.getClass());\n+      }\n+\n+      if (serializer != null) {\n+        if (obj == null) {\n+          assignToRoot(JsonNull.createJsonNull());\n+        } else {\n+          assignToRoot(invokeCustomHandler(obj, objType, serializer));\n+        }\n+        return true;\n+      }\n+      return false;\n+    } catch (CircularReferenceException e) {\n+      throw e.createDetailedException(null);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private JsonElement invokeCustomHandler(Object obj, Type objType, JsonSerializer serializer) {\n+    start(obj);\n+    try {\n+      return serializer.serialize(obj, objType, context);\n+    } finally {\n+      end(obj);\n+    }\n   }\n \n   @SuppressWarnings(\"unchecked\")\n       }\n       JsonSerializer serializer = serializers.getHandlerFor(actualTypeOfField);\n       if (serializer != null) {\n-        JsonElement child = serializer.serialize(obj, actualTypeOfField, context);\n+        JsonElement child = invokeCustomHandler(obj, actualTypeOfField, serializer);\n         addChildAsElement(f, child);\n         return true;\n       }\n       return false;\n     } catch (IllegalAccessException e) {\n       throw new RuntimeException();\n+    } catch (CircularReferenceException e) {\n+      throw e.createDetailedException(f);\n     }\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.common.TestTypes.ClassOverridingEquals;\n+\n+/**\n+ * Functional tests related to circular reference detection and error reporting.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class CircularReferenceTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testCircularSerialization() throws Exception {\n+    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n+    a.children.add(b);\n+    b.children.add(a);\n+    try {\n+      gson.toJson(a);\n+      fail(\"Circular types should not get printed!\");\n+    } catch (IllegalStateException expected) { \n+      assertTrue(expected.getMessage().contains(\"children\"));      \n+    }\n+  }\n+\n+  public void testSelfReferenceSerialization() throws Exception {\n+    ClassOverridingEquals objA = new ClassOverridingEquals();\n+    objA.ref = objA;\n+\n+    try {\n+      gson.toJson(objA);\n+      fail(\"Circular reference to self can not be serialized!\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+\n+  public void testSelfReferenceArrayFieldSerialization() throws Exception {\n+    ClassWithSelfReferenceArray objA = new ClassWithSelfReferenceArray();\n+    objA.children = new ClassWithSelfReferenceArray[]{objA};\n+\n+    try {\n+      gson.toJson(objA);\n+      fail(\"Circular reference to self can not be serialized!\");\n+    } catch (IllegalStateException expected) { \n+      assertTrue(expected.getMessage().contains(\"children\"));\n+    }\n+  }\n+\n+  public void testSelfReferenceCustomHandlerSerialization() throws Exception {\n+    ClassWithSelfReference obj = new ClassWithSelfReference();\n+    obj.child = obj;\n+    Gson gson = new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer<ClassWithSelfReference>() {\n+      public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        JsonObject obj = new JsonObject();\n+        obj.addProperty(\"property\", \"value\");\n+        obj.add(\"child\", context.serialize(src.child));\n+        return obj;\n+      }      \n+    }).create();\n+    try {\n+      gson.toJson(obj);\n+      fail(\"Circular reference to self can not be serialized!\");\n+    } catch (IllegalStateException expected) { \n+      assertTrue(expected.getMessage().contains(\"Offending\"));\n+    }\n+  }\n+\n+  public void testDirectedAcyclicGraphSerialization() throws Exception {\n+    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();\n+    a.children.add(b);\n+    a.children.add(c);\n+    b.children.add(c);\n+    assertNotNull(gson.toJson(a));\n+  }\n+\n+  public void testDirectedAcyclicGraphDeserialization() throws Exception {\n+    String json = \"{\\\"children\\\":[{\\\"children\\\":[{\\\"children\\\":[]}]},{\\\"children\\\":[]}]}\";\n+    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);\n+    assertNotNull(target);\n+    assertEquals(2, target.children.size());\n+  }\n+\n+  private static class ContainsReferenceToSelfType {\n+    Collection<ContainsReferenceToSelfType> children = new ArrayList<ContainsReferenceToSelfType>();\n+  }\n+  \n+  private static class ClassWithSelfReference {\n+    ClassWithSelfReference child;\n+  }\n+\n+  private static class ClassWithSelfReferenceArray {\n+    @SuppressWarnings(\"unused\")\n+    ClassWithSelfReferenceArray[] children;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n import com.google.gson.common.TestTypes.ArrayOfObjects;\n import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n-import com.google.gson.common.TestTypes.ClassOverridingEquals;\n import com.google.gson.common.TestTypes.ClassWithArray;\n import com.google.gson.common.TestTypes.ClassWithNoFields;\n import com.google.gson.common.TestTypes.ClassWithObjects;\n     String jsonString = target.getExpectedJson();\n     target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);\n     assertEquals(jsonString, target.getExpectedJson());\n-  }\n-\n-  public void testDirectedAcyclicGraphSerialization() throws Exception {\n-    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n-    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n-    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();\n-    a.children.add(b);\n-    a.children.add(c);\n-    b.children.add(c);\n-    assertNotNull(gson.toJson(a));\n-  }\n-\n-  public void testDirectedAcyclicGraphDeserialization() throws Exception {\n-    String json = \"{\\\"children\\\":[{\\\"children\\\":[{\\\"children\\\":[]}]},{\\\"children\\\":[]}]}\";\n-    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);\n-    assertNotNull(target);\n-    assertEquals(2, target.children.size());\n   }\n \n   public void testClassWithTransientFieldsSerialization() throws Exception {\n \n   public void testEmptyCollectionInAnObjectDeserialization() throws Exception {\n     String json = \"{\\\"children\\\":[]}\";\n-    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);\n+    ClassWithCollectionField target = gson.fromJson(json, ClassWithCollectionField.class);\n     assertNotNull(target);\n     assertTrue(target.children.isEmpty());\n+  }\n+\n+  private static class ClassWithCollectionField {\n+    Collection<String> children = new ArrayList<String>();\n   }\n \n   public void testPrimitiveArrayInAnObjectDeserialization() throws Exception {\n   }\n \n   public void testEmptyCollectionInAnObjectSerialization() throws Exception {\n-    ContainsReferenceToSelfType target = new ContainsReferenceToSelfType();\n+    ClassWithCollectionField target = new ClassWithCollectionField();\n     assertEquals(\"{\\\"children\\\":[]}\", gson.toJson(target));\n-  }\n-\n-  public void testCircularSerialization() throws Exception {\n-    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n-    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n-    a.children.add(b);\n-    b.children.add(a);\n-    try {\n-      gson.toJson(a);\n-      fail(\"Circular types should not get printed!\");\n-    } catch (IllegalStateException expected) { }\n-  }\n-\n-  public void testSelfReferenceSerialization() throws Exception {\n-    ClassOverridingEquals objA = new ClassOverridingEquals();\n-    objA.ref = objA;\n-\n-    try {\n-      gson.toJson(objA);\n-      fail(\"Circular reference to self can not be serialized!\");\n-    } catch (IllegalStateException expected) { }\n   }\n \n   public void testPrivateNoArgConstructorDeserialization() throws Exception {\n     private class Child {\n       int value2 = 2;\n     }\n-  }\n-\n-  private static class ContainsReferenceToSelfType {\n-    public Collection<ContainsReferenceToSelfType> children =\n-        new ArrayList<ContainsReferenceToSelfType>();\n   }\n \n   private static class ArrayOfArrays {", "timestamp": 1254257011, "metainfo": ""}