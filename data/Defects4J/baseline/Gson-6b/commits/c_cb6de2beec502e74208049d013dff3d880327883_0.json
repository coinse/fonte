{"sha": "cb6de2beec502e74208049d013dff3d880327883", "log": "Merge pull request #699 from google/639  Implemented support for multiple values for SerializedName annotation.", "commit": "\n--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java\n+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java\n  *\n  * <p>Here is an example of how this annotation is meant to be used:</p>\n  * <pre>\n- * public class SomeClassWithFields {\n- *   &#64SerializedName(\"name\") private final String someField;\n- *   private final String someOtherField;\n+ * public class MyClass {\n+ *   &#64SerializedName(\"name\") String a;\n+ *   &#64SerializedName(value=\"name1\", alternate={\"name2\", \"name3\"}) String b;\n+ *   String c;\n  *\n- *   public SomeClassWithFields(String a, String b) {\n- *     this.someField = a;\n- *     this.someOtherField = b;\n+ *   public MyClass(String a, String b, String c) {\n+ *     this.a = a;\n+ *     this.b = b;\n+ *     this.c = c;\n  *   }\n  * }\n  * </pre>\n  * <p>The following shows the output that is generated when serializing an instance of the\n  * above example class:</p>\n  * <pre>\n- * SomeClassWithFields objectToSerialize = new SomeClassWithFields(\"a\", \"b\");\n+ * MyClass target = new MyClass(\"v1\", \"v2\", \"v3\");\n  * Gson gson = new Gson();\n- * String jsonRepresentation = gson.toJson(objectToSerialize);\n- * System.out.println(jsonRepresentation);\n+ * String json = gson.toJson(target);\n+ * System.out.println(json);\n  *\n  * ===== OUTPUT =====\n- * {\"name\":\"a\",\"someOtherField\":\"b\"}\n+ * {\"name\":\"v1\",\"name1\":\"v2\",\"c\":\"v3\"}\n  * </pre>\n  *\n  * <p>NOTE: The value you specify in this annotation must be a valid JSON field name.</p>\n+ * While deserializing, all values specified in the annotation will be deserialized into the field.\n+ * For example:\n+ * <pre>\n+ *   MyClass target = gson.fromJson(\"{'name1':'v1'}\", MyClass.class);\n+ *   assertEquals(\"v1\", target.b);\n+ *   target = gson.fromJson(\"{'name2':'v2'}\", MyClass.class);\n+ *   assertEquals(\"v2\", target.b);\n+ *   target = gson.fromJson(\"{'name3':'v3'}\", MyClass.class);\n+ *   assertEquals(\"v3\", target.b);\n+ * </pre>\n+ * Note that MyClass.b is now deserialized from either name1, name2 or name3.\n  *\n  * @see com.google.gson.FieldNamingPolicy\n  *\n public @interface SerializedName {\n \n   /**\n-   * @return the desired name of the field when it is serialized\n+   * @return the desired names of the field when it is deserialized or serialized. All of the specified names will be deserialized from.\n+   *   The specified first name is what is used for serialization.\n    */\n   String value();\n+  String[] alternate() default {};\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n+\n+import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n \n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-\n-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n \n /**\n  * Type adapter that reflects over the fields and methods of a class.\n     return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n   }\n \n-  private String getFieldName(Field f) {\n+  /** first element holds the default name */\n+  private List<String> getFieldNames(Field f) {\n     return getFieldName(fieldNamingPolicy, f);\n   }\n \n-  static String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n+  /** first element holds the default name */\n+  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n     SerializedName serializedName = f.getAnnotation(SerializedName.class);\n-    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n+    List<String> fieldNames = new LinkedList<String>();\n+    if (serializedName == null) {\n+      fieldNames.add(fieldNamingPolicy.translateName(f));\n+    } else {\n+      fieldNames.add(serializedName.value());\n+      for (String alternate : serializedName.alternate()) {\n+        fieldNames.add(alternate);\n+      }\n+    }\n+    return fieldNames;\n   }\n \n   public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n         }\n         field.setAccessible(true);\n         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-        BoundField boundField = createBoundField(context, field, getFieldName(field),\n-            TypeToken.get(fieldType), serialize, deserialize);\n-        BoundField previous = result.put(boundField.name, boundField);\n+        List<String> fieldNames = getFieldNames(field);\n+        BoundField previous = null;\n+        for (int i = 0; i < fieldNames.size(); ++i) {\n+          String name = fieldNames.get(i);\n+          if (i != 0) serialize = false; // only serialize the default name\n+          BoundField boundField = createBoundField(context, field, name,\n+              TypeToken.get(fieldType), serialize, deserialize);\n+          BoundField replaced = result.put(name, boundField);\n+          if (previous == null) previous = replaced;\n+        }\n         if (previous != null) {\n           throw new IllegalArgumentException(declaredType\n               + \" declares multiple JSON fields named \" + previous.name);\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n           SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n           if (annotation != null) {\n             name = annotation.value();\n+            for (String alternate : annotation.alternate()) {\n+              nameToConstant.put(alternate, constant);\n+            }\n           }\n           nameToConstant.put(name, constant);\n           constantToName.put(constant, name);\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java\n+/*\n+ * Copyright (C) 2015 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+import junit.framework.TestCase;\n+\n+public final class SerializedNameTest extends TestCase {\n+  private final Gson gson = new Gson();\n+\n+  public void testFirstNameIsChosenForSerialization() {\n+    MyClass target = new MyClass(\"v1\", \"v2\");\n+    // Ensure name1 occurs exactly once, and name2 and name3 dont appear\n+    assertEquals(\"{\\\"name\\\":\\\"v1\\\",\\\"name1\\\":\\\"v2\\\"}\", gson.toJson(target));\n+  }\n+\n+  public void testMultipleNamesDeserializedCorrectly() {\n+    assertEquals(\"v1\", gson.fromJson(\"{'name':'v1'}\", MyClass.class).a);\n+\n+    // Both name1 and name2 gets deserialized to b\n+    assertEquals(\"v11\", gson.fromJson(\"{'name1':'v11'}\", MyClass.class).b);\n+    assertEquals(\"v2\", gson.fromJson(\"{'name2':'v2'}\", MyClass.class).b);\n+    assertEquals(\"v3\", gson.fromJson(\"{'name3':'v3'}\", MyClass.class).b);\n+  }\n+\n+  public void testMultipleNamesInTheSameString() {\n+    // The last value takes precedence\n+    assertEquals(\"v3\", gson.fromJson(\"{'name1':'v1','name2':'v2','name3':'v3'}\", MyClass.class).b);\n+  }\n+\n+  private static final class MyClass {\n+    @SerializedName(\"name\") String a;\n+    @SerializedName(value=\"name1\", alternate={\"name2\", \"name3\"}) String b;\n+    MyClass(String a, String b) {\n+      this.a = a;\n+      this.b = b;\n+    }\n+  }\n+}", "timestamp": 1443871547, "metainfo": ""}