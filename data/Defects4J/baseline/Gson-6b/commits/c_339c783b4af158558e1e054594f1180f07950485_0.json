{"sha": "339c783b4af158558e1e054594f1180f07950485", "log": "Updated the ProtoTypeAdapter to a version that works smoothly and supports field name/value customization. - Lets you customize the proto field name serialization per field     - Lets you use different cases for serialization (e.g. you could use UpperCamelCase for your proto field names and willing to serialize them using LowerHyphen)     - Lets you choose to serialize enum values with their value (0, 1, 2, ...) instead of their name.", "commit": "\n--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n \n package com.google.gson.protobuf;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.CaseFormat;\n+import com.google.common.base.Converter;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonParseException;\n import com.google.gson.JsonSerializationContext;\n import com.google.gson.JsonSerializer;\n+import com.google.protobuf.DescriptorProtos.EnumValueOptions;\n+import com.google.protobuf.DescriptorProtos.FieldOptions;\n import com.google.protobuf.Descriptors.Descriptor;\n+import com.google.protobuf.Descriptors.EnumDescriptor;\n+import com.google.protobuf.Descriptors.EnumValueDescriptor;\n import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.Extension;\n import com.google.protobuf.GeneratedMessage;\n+import com.google.protobuf.Message;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n- * Gson type adapter for protocol buffers\n+ * GSON type adapter for protocol buffers that knows how to serialize enums either by using their\n+ * values or their names, and also supports custom proto field names.\n+ * <p>\n+ * You can specify which case representation is used for the proto fields when writing/reading the\n+ * JSON payload by calling {@link Builder#setFieldNameSerializationFormat(CaseFormat, CaseFormat)}.\n+ * <p>\n+ * An example of default serialization/deserialization using custom proto field names is show below:\n+ *\n+ * <pre>\n+ * message MyMessage {\n+ *   // Will be serialized as 'osBuildID' instead of the default 'osBuildId'.\n+ *   string os_build_id = 1 [(serialized_name) = \"osBuildID\"];\n+ * }\n+ * </pre>\n+ * <p>\n  *\n  * @author Inderjeet Singh\n+ * @author Emmanuel Cron\n+ * @author Stanley Wang\n  */\n-public class ProtoTypeAdapter implements JsonSerializer<GeneratedMessage>,\n-    JsonDeserializer<GeneratedMessage> {\n+public class ProtoTypeAdapter\n+    implements JsonSerializer<GeneratedMessage>, JsonDeserializer<GeneratedMessage> {\n+  /**\n+   * Determines how enum <u>values</u> should be serialized.\n+   */\n+  public static enum EnumSerialization {\n+    /**\n+     * Serializes and deserializes enum values using their <b>number</b>. When this is used, custom\n+     * value names set on enums are ignored.\n+     */\n+    NUMBER,\n+    /** Serializes and deserializes enum values using their <b>name</b>. */\n+    NAME;\n+  }\n+\n+  /**\n+   * Builder for {@link ProtoTypeAdapter}s.\n+   */\n+  public static class Builder {\n+    private final Set<Extension<FieldOptions, String>> serializedNameExtensions;\n+    private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;\n+    private EnumSerialization enumSerialization;\n+    private Converter<String, String> fieldNameSerializationFormat;\n+\n+    private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,\n+        CaseFormat toFieldNameFormat) {\n+      this.serializedNameExtensions = new HashSet<Extension<FieldOptions, String>>();\n+      this.serializedEnumValueExtensions = new HashSet<Extension<EnumValueOptions, String>>();\n+      setEnumSerialization(enumSerialization);\n+      setFieldNameSerializationFormat(fromFieldNameFormat, toFieldNameFormat);\n+    }\n+\n+    public Builder setEnumSerialization(EnumSerialization enumSerialization) {\n+      this.enumSerialization = checkNotNull(enumSerialization);\n+      return this;\n+    }\n+\n+    /**\n+     * Sets the field names serialization format. The first parameter defines how to read the format\n+     * of the proto field names you are converting to JSON. The second parameter defines which\n+     * format to use when serializing them.\n+     * <p>\n+     * For example, if you use the following parameters: {@link CaseFormat#LOWER_UNDERSCORE},\n+     * {@link CaseFormat#LOWER_CAMEL}, the following conversion will occur:\n+     *\n+     * <pre>\n+     * PROTO     <->  JSON\n+     * my_field       myField\n+     * foo            foo\n+     * n__id_ct       nIdCt\n+     * </pre>\n+     */\n+    public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,\n+        CaseFormat toFieldNameFormat) {\n+      fieldNameSerializationFormat = fromFieldNameFormat.converterTo(toFieldNameFormat);\n+      return this;\n+    }\n+\n+    /**\n+     * Adds a field proto annotation that, when set, overrides the default field name\n+     * serialization/deserialization. For example, if you add the ' {@code serialized_name}'\n+     * annotation and you define a field in your proto like the one below:\n+     *\n+     * <pre>\n+     * string client_app_id = 1[(serialized_name) = \"appId\"];\n+     * </pre>\n+     *\n+     * ...the adapter will serialize the field using '{@code appId}' instead of the default '\n+     * {@code clientAppId}'. This lets you customize the name serialization of any field of your\n+     * proto.\n+     */\n+    public Builder addSerializedNameExtension(\n+        Extension<FieldOptions, String> serializedNameExtension) {\n+      serializedNameExtensions.add(checkNotNull(serializedNameExtension));\n+      return this;\n+    }\n+\n+    /**\n+     * Adds an enum proto annotation that, when set, overrides the default <b>enum</b> value\n+     * serialization/deerialization of this adapter. For example, if you add the '\n+     * {@code serialized_value}' annotation and you define an enum in your proto like the one below:\n+     *\n+     * <pre>\n+     * enum MyEnum {\n+     *   UNKNOWN = 0;\n+     *   CLIENT_APP_ID = 1 [(serialized_value) = \"APP_ID\"];\n+     *   TWO = 2 [(serialized_value) = \"2\"];\n+     * }\n+     * </pre>\n+     *\n+     * ...the adapter will serialize the value {@code CLIENT_APP_ID} as \"{@code APP_ID}\" and the\n+     * value {@code TWO} as \"{@code 2}\". This works for both serialization and deserialization.\n+     * <p>\n+     * Note that you need to set the enum serialization of this adapter to\n+     * {@link EnumSerialization#NAME}, otherwise these annotations will be ignored.\n+     */\n+    public Builder addSerializedEnumValueExtension(\n+        Extension<EnumValueOptions, String> serializedEnumValueExtension) {\n+      serializedEnumValueExtensions.add(checkNotNull(serializedEnumValueExtension));\n+      return this;\n+    }\n+\n+    public ProtoTypeAdapter build() {\n+      return new ProtoTypeAdapter(enumSerialization, fieldNameSerializationFormat,\n+          serializedNameExtensions, serializedEnumValueExtensions);\n+    }\n+  }\n+\n+  /**\n+   * Creates a new {@link ProtoTypeAdapter} builder, defaulting enum serialization to\n+   * {@link EnumSerialization#NAME} and converting field serialization from\n+   * {@link CaseFormat#LOWER_UNDERSCORE} to {@link CaseFormat#LOWER_CAMEL}.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder(EnumSerialization.NAME, CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_CAMEL);\n+  }\n+\n+  private static final com.google.protobuf.Descriptors.FieldDescriptor.Type ENUM_TYPE =\n+      com.google.protobuf.Descriptors.FieldDescriptor.Type.ENUM;\n+\n+  private final EnumSerialization enumSerialization;\n+  private final Converter<String, String> fieldNameSerializationFormat;\n+  private final Set<Extension<FieldOptions, String>> serializedNameExtensions;\n+  private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;\n+\n+  private ProtoTypeAdapter(EnumSerialization enumSerialization,\n+      Converter<String, String> fieldNameSerializationFormat,\n+      Set<Extension<FieldOptions, String>> serializedNameExtensions,\n+      Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {\n+    this.enumSerialization = enumSerialization;\n+    this.fieldNameSerializationFormat = fieldNameSerializationFormat;\n+    this.serializedNameExtensions = serializedNameExtensions;\n+    this.serializedEnumValueExtensions = serializedEnumValueExtensions;\n+  }\n \n   @Override\n   public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,\n \n     for (Map.Entry<FieldDescriptor, Object> fieldPair : fields.entrySet()) {\n       final FieldDescriptor desc = fieldPair.getKey();\n-      if (desc.isRepeated()) {\n-        List<?> fieldList = (List<?>) fieldPair.getValue();\n-        if (fieldList.size() != 0) {\n+      String name = getCustSerializedName(desc.getOptions(), desc.getName());\n+\n+      if (desc.getType() == ENUM_TYPE) {\n+        // Enum collections are also returned as ENUM_TYPE\n+        if (fieldPair.getValue() instanceof Collection) {\n+          // Build the array to avoid infinite loop\n           JsonArray array = new JsonArray();\n-          for (Object o : fieldList) {\n-            array.add(context.serialize(o));\n+          @SuppressWarnings(\"unchecked\")\n+          Collection<EnumValueDescriptor> enumDescs =\n+              (Collection<EnumValueDescriptor>) fieldPair.getValue();\n+          for (EnumValueDescriptor enumDesc : enumDescs) {\n+            array.add(context.serialize(getEnumValue(enumDesc)));\n+            ret.add(name, array);\n           }\n-          ret.add(desc.getName(), array);\n+        } else {\n+          EnumValueDescriptor enumDesc = ((EnumValueDescriptor) fieldPair.getValue());\n+          ret.add(name, context.serialize(getEnumValue(enumDesc)));\n         }\n       } else {\n-        ret.add(desc.getName(), context.serialize(fieldPair.getValue()));\n+        ret.add(name, context.serialize(fieldPair.getValue()));\n       }\n     }\n     return ret;\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Override\n   public GeneratedMessage deserialize(JsonElement json, Type typeOfT,\n       JsonDeserializationContext context) throws JsonParseException {\n     try {\n       JsonObject jsonObject = json.getAsJsonObject();\n-      Class<? extends GeneratedMessage> protoClass =\n-        (Class<? extends GeneratedMessage>) typeOfT; \n+      @SuppressWarnings(\"unchecked\")\n+      Class<? extends GeneratedMessage> protoClass = (Class<? extends GeneratedMessage>) typeOfT;\n+\n       try {\n         // Invoke the ProtoClass.newBuilder() method\n-        Object protoBuilder = getCachedMethod(protoClass, \"newBuilder\")\n-          .invoke(null);\n-        Class<?> builderClass = protoBuilder.getClass();\n-\n-        Descriptor protoDescriptor = (Descriptor) getCachedMethod(\n-            protoClass, \"getDescriptor\").invoke(null);\n+        GeneratedMessage.Builder<?> protoBuilder =\n+            (GeneratedMessage.Builder<?>) getCachedMethod(protoClass, \"newBuilder\").invoke(null);\n+\n+        Descriptor protoDescriptor =\n+            (Descriptor) getCachedMethod(protoClass, \"getDescriptor\").invoke(null);\n         // Call setters on all of the available fields\n         for (FieldDescriptor fieldDescriptor : protoDescriptor.getFields()) {\n-          String name = fieldDescriptor.getName();\n-          if (jsonObject.has(name)) {\n-            JsonElement jsonElement = jsonObject.get(name);\n-            String fieldName = name + \"_\";\n-            Field field = protoClass.getDeclaredField(fieldName);\n-            Type fieldType = field.getGenericType();\n-            Object fieldValue = context.deserialize(jsonElement, fieldType);\n-            Method method = getCachedMethod(\n-              builderClass, \"setField\", FieldDescriptor.class, Object.class);\n-            method.invoke(protoBuilder, fieldDescriptor, fieldValue);\n+          String jsonFieldName =\n+              getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\n+\n+          if (jsonObject.has(jsonFieldName)) {\n+            JsonElement jsonElement = jsonObject.get(jsonFieldName);\n+            // Do not reuse jsonFieldName here, it might have a custom value\n+            Object fieldValue;\n+            if (fieldDescriptor.getType() == ENUM_TYPE) {\n+              if (jsonElement.isJsonArray()) {\n+                // Handling array\n+                Collection<EnumValueDescriptor> enumCollection =\n+                    new ArrayList<EnumValueDescriptor>();\n+                for (JsonElement element : jsonElement.getAsJsonArray()) {\n+                  enumCollection.add(\n+                      findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));\n+                }\n+                fieldValue = enumCollection;\n+              } else {\n+                // No array, just a plain value\n+                fieldValue =\n+                    findValueByNameAndExtension(fieldDescriptor.getEnumType(), jsonElement);\n+              }\n+              protoBuilder.setField(fieldDescriptor, fieldValue);\n+            } else if (fieldDescriptor.isRepeated()) {\n+              // If the type is an array, then we have to grab the type from the class.\n+              String protoArrayFieldName =\n+                  fieldNameSerializationFormat.convert(fieldDescriptor.getName()) + \"_\";\n+              Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);\n+              Type protoArrayFieldType = protoArrayField.getGenericType();\n+              fieldValue = context.deserialize(jsonElement, protoArrayFieldType);\n+              protoBuilder.setField(fieldDescriptor, fieldValue);\n+            } else {\n+              Message prototype = protoBuilder.build();\n+              Object field = prototype.getField(fieldDescriptor);\n+              fieldValue = context.deserialize(jsonElement, field.getClass());\n+              protoBuilder.setField(fieldDescriptor, fieldValue);\n+            }\n           }\n         }\n-        \n-        // Invoke the build method to return the final proto\n-        return (GeneratedMessage) getCachedMethod(builderClass, \"build\")\n-            .invoke(protoBuilder);\n+        return (GeneratedMessage) protoBuilder.build();\n       } catch (SecurityException e) {\n         throw new JsonParseException(e);\n-      } catch (NoSuchMethodException e) {\n+      } catch (NoSuchMethodException  e) {\n         throw new JsonParseException(e);\n       } catch (IllegalArgumentException e) {\n         throw new JsonParseException(e);\n         throw new JsonParseException(e);\n       }\n     } catch (Exception e) {\n-      throw new JsonParseException(\"Error while parsing proto: \", e);\n-    }\n-  }\n-\n-  private static Method getCachedMethod(Class<?> clazz, String methodName,\n-      Class<?>... methodParamTypes) throws NoSuchMethodException {\n+      throw new JsonParseException(\"Error while parsing proto\", e);\n+    }\n+  }\n+\n+  /**\n+   * Retrieves the custom field name from the given options, and if not found, returns the specified\n+   * default name.\n+   */\n+  private String getCustSerializedName(FieldOptions options, String defaultName) {\n+    for (Extension<FieldOptions, String> extension : serializedNameExtensions) {\n+      if (options.hasExtension(extension)) {\n+        return options.getExtension(extension);\n+      }\n+    }\n+    return fieldNameSerializationFormat.convert(defaultName);\n+  }\n+\n+  /**\n+   * Retrieves the custom enum value name from the given options, and if not found, returns the\n+   * specified default value.\n+   */\n+  private String getCustSerializedEnumValue(EnumValueOptions options, String defaultValue) {\n+    for (Extension<EnumValueOptions, String> extension : serializedEnumValueExtensions) {\n+      if (options.hasExtension(extension)) {\n+        return options.getExtension(extension);\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  /**\n+   * Returns the enum value to use for serialization, depending on the value of\n+   * {@link EnumSerialization} that was given to this adapter.\n+   */\n+  private Object getEnumValue(EnumValueDescriptor enumDesc) {\n+    if (enumSerialization == EnumSerialization.NAME) {\n+      return getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\n+    } else {\n+      return enumDesc.getNumber();\n+    }\n+  }\n+\n+  /**\n+   * Finds an enum value in the given {@link EnumDescriptor} that matches the given JSON element,\n+   * either by name if the current adapter is using {@link EnumSerialization#NAME}, otherwise by\n+   * number. If matching by name, it uses the extension value if it is defined, otherwise it uses\n+   * its default value.\n+   *\n+   * @throws IllegalArgumentException if a matching name/number was not found\n+   */\n+  private EnumValueDescriptor findValueByNameAndExtension(EnumDescriptor desc,\n+      JsonElement jsonElement) {\n+    if (enumSerialization == EnumSerialization.NAME) {\n+      // With enum name\n+      for (EnumValueDescriptor enumDesc : desc.getValues()) {\n+        String enumValue = getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\n+        if (enumValue.equals(jsonElement.getAsString())) {\n+          return enumDesc;\n+        }\n+      }\n+      throw new IllegalArgumentException(\n+          String.format(\"Unrecognized enum name: %s\", jsonElement.getAsString()));\n+    } else {\n+      // With enum value\n+      EnumValueDescriptor fieldValue = desc.findValueByNumber(jsonElement.getAsInt());\n+      if (fieldValue == null) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Unrecognized enum value: %s\", jsonElement.getAsInt()));\n+      }\n+      return fieldValue;\n+    }\n+  }\n+\n+  private static Method getCachedMethod(Class<?> clazz, String methodName)\n+      throws NoSuchMethodException {\n+    if (!mapOfMapOfMethods.containsKey(methodName)) {\n+      mapOfMapOfMethods.put(methodName, new HashMap<Class<?>, Method>());\n+    }\n     Map<Class<?>, Method> mapOfMethods = mapOfMapOfMethods.get(methodName);\n-    if (mapOfMethods == null) {\n-      mapOfMethods = new HashMap<Class<?>, Method>();\n-      mapOfMapOfMethods.put(methodName, mapOfMethods);\n-    }\n-    Method method = mapOfMethods.get(clazz);\n-    if (method == null) {\n-      method = clazz.getMethod(methodName, methodParamTypes);\n-      mapOfMethods.put(clazz, method);\n-    }\n-    return method;\n+    if (!mapOfMethods.containsKey(clazz)) {\n+      mapOfMethods.put(clazz, clazz.getMethod(methodName));\n+    }\n+    return mapOfMethods.get(clazz);\n   }\n \n   private static Map<String, Map<Class<?>, Method>> mapOfMapOfMethods =\n-    new HashMap<String, Map<Class<?>, Method>>();\n-}\n+      new HashMap<String, Map<Class<?>, Method>>();\n+}\n--- /dev/null\n+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.protobuf.functional;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assert_;\n+\n+import com.google.common.base.CaseFormat;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.protobuf.ProtoTypeAdapter;\n+import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;\n+import com.google.gson.protobuf.generated.Annotations;\n+import com.google.gson.protobuf.generated.Bag.OuterMessage;\n+import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations;\n+import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage;\n+import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data;\n+import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type;\n+import com.google.protobuf.GeneratedMessage;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for protocol buffers using annotations for field names and enum values.\n+ *\n+ * @author Emmanuel Cron\n+ */\n+public class ProtosWithAnnotationsTest extends TestCase {\n+  private Gson gson;\n+  private Gson gsonWithEnumNumbers;\n+  private Gson gsonWithLowerHyphen;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    ProtoTypeAdapter.Builder protoTypeAdapter = ProtoTypeAdapter.newBuilder()\n+        .setEnumSerialization(EnumSerialization.NAME)\n+        .addSerializedNameExtension(Annotations.serializedName)\n+        .addSerializedEnumValueExtension(Annotations.serializedValue);\n+    gson = new GsonBuilder()\n+        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter.build())\n+        .create();\n+    gsonWithEnumNumbers = new GsonBuilder()\n+        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter\n+            .setEnumSerialization(EnumSerialization.NUMBER)\n+            .build())\n+        .create();\n+    gsonWithLowerHyphen = new GsonBuilder()\n+        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter\n+            .setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN)\n+            .build())\n+        .create();\n+  }\n+\n+  public void testProtoWithAnnotations_deserialize() {\n+    String json = String.format(\"{  %n\"\n+        + \"   \\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",%n\"\n+        + \"   \\\"expiration_date\\\":{  %n\"\n+        + \"      \\\"month\\\":\\\"12\\\",%n\"\n+        + \"      \\\"year\\\":\\\"2017\\\",%n\"\n+        + \"      \\\"timeStamp\\\":\\\"9864653135687\\\",%n\"\n+        + \"      \\\"countryCode5f55\\\":\\\"en_US\\\"%n\"\n+        + \"   },%n\"\n+        // Don't define innerMessage1\n+        + \"   \\\"innerMessage2\\\":{  %n\"\n+        // Set a number as a string; it should work\n+        + \"      \\\"nIdCt\\\":\\\"98798465\\\",%n\"\n+        + \"      \\\"content\\\":\\\"text/plain\\\",%n\"\n+        + \"      \\\"$binary_data$\\\":[  %n\"\n+        + \"         {  %n\"\n+        + \"            \\\"data\\\":\\\"OFIN8e9fhwoeh8((\u20798efywoih\\\",%n\"\n+        // Don't define width\n+        + \"            \\\"height\\\":665%n\"\n+        + \"         },%n\"\n+        + \"         {  %n\"\n+        // Define as an int; it should work\n+        + \"            \\\"data\\\":65,%n\"\n+        + \"            \\\"width\\\":-56684%n\"\n+        // Don't define height\n+        + \"         }%n\"\n+        + \"      ]%n\"\n+        + \"   },%n\"\n+        // Define a bunch of non recognizable data\n+        + \"   \\\"non_existing\\\":\\\"foobar\\\",%n\"\n+        + \"   \\\"stillNot\\\":{  %n\"\n+        + \"      \\\"bunch\\\":\\\"of_useless data\\\"%n\"\n+        + \"   }%n\"\n+        + \"}\");\n+    ProtoWithAnnotations proto = gson.fromJson(json, ProtoWithAnnotations.class);\n+    assertThat(proto.getId()).isEqualTo(\"41e5e7fd6065d101b97018a465ffff01\");\n+    assertThat(proto.getOuterMessage()).isEqualTo(OuterMessage.newBuilder()\n+        .setMonth(12)\n+        .setYear(2017)\n+        .setLongTimestamp(9864653135687L)\n+        .setCountryCode5F55(\"en_US\")\n+        .build());\n+    assertThat(proto.hasInnerMessage1()).isFalse();\n+    assertThat(proto.getInnerMessage2()).isEqualTo(InnerMessage.newBuilder()\n+        .setNIdCt(98798465)\n+        .setContent(Type.TEXT)\n+        .addData(Data.newBuilder()\n+            .setData(\"OFIN8e9fhwoeh8((\u20798efywoih\")\n+            .setHeight(665))\n+        .addData(Data.newBuilder()\n+            .setData(\"65\")\n+            .setWidth(-56684))\n+        .build());\n+\n+    String rebuilt = gson.toJson(proto);\n+    assertThat(rebuilt).isEqualTo(\"{\"\n+        + \"\\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",\"\n+        + \"\\\"expiration_date\\\":{\"\n+        + \"\\\"month\\\":12,\"\n+        + \"\\\"year\\\":2017,\"\n+        + \"\\\"timeStamp\\\":9864653135687,\"\n+        + \"\\\"countryCode5f55\\\":\\\"en_US\\\"\"\n+        + \"},\"\n+        + \"\\\"innerMessage2\\\":{\"\n+        + \"\\\"nIdCt\\\":98798465,\"\n+        + \"\\\"content\\\":\\\"text/plain\\\",\"\n+        + \"\\\"$binary_data$\\\":[\"\n+        + \"{\"\n+        + \"\\\"data\\\":\\\"OFIN8e9fhwoeh8((\u20798efywoih\\\",\"\n+        + \"\\\"height\\\":665\"\n+        + \"},\"\n+        + \"{\"\n+        + \"\\\"data\\\":\\\"65\\\",\"\n+        + \"\\\"width\\\":-56684\"\n+        + \"}]}}\");\n+  }\n+\n+  public void testProtoWithAnnotations_deserializeUnknownEnumValue() {\n+    String json = String.format(\"{  %n\"\n+        + \"   \\\"content\\\":\\\"UNKNOWN\\\"%n\"\n+        + \"}\");\n+    InnerMessage proto = gson.fromJson(json, InnerMessage.class);\n+    assertThat(proto.getContent()).isEqualTo(Type.UNKNOWN);\n+  }\n+\n+  public void testProtoWithAnnotations_deserializeUnrecognizedEnumValue() {\n+    String json = String.format(\"{  %n\"\n+        + \"   \\\"content\\\":\\\"UNRECOGNIZED\\\"%n\"\n+        + \"}\");\n+    try {\n+      gson.fromJson(json, InnerMessage.class);\n+      assert_().fail(\"Should have thrown\");\n+    } catch (JsonParseException e) {\n+      // expected\n+    }\n+  }\n+\n+  public void testProtoWithAnnotations_deserializeWithEnumNumbers() {\n+    String json = String.format(\"{  %n\"\n+        + \"   \\\"content\\\":\\\"0\\\"%n\"\n+        + \"}\");\n+    InnerMessage proto = gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\n+    assertThat(proto.getContent()).isEqualTo(Type.UNKNOWN);\n+\n+    json = String.format(\"{  %n\"\n+        + \"   \\\"content\\\":\\\"2\\\"%n\"\n+        + \"}\");\n+    proto = gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\n+    assertThat(proto.getContent()).isEqualTo(Type.IMAGE);\n+  }\n+\n+  public void testProtoWithAnnotations_serialize() {\n+    ProtoWithAnnotations proto = ProtoWithAnnotations.newBuilder()\n+        .setId(\"09f3j20839h032y0329hf30932h0nffn\")\n+        .setOuterMessage(OuterMessage.newBuilder()\n+            .setMonth(14)\n+            .setYear(6650)\n+            .setLongTimestamp(468406876880768L))\n+        .setInnerMessage1(InnerMessage.newBuilder()\n+            .setNIdCt(12)\n+            .setContent(Type.IMAGE)\n+            .addData(Data.newBuilder()\n+                .setData(\"data$$\")\n+                .setWidth(200))\n+            .addData(Data.newBuilder()\n+                .setHeight(56)))\n+        .build();\n+\n+    String json = gsonWithLowerHyphen.toJson(proto);\n+    assertThat(json).isEqualTo(\n+        \"{\\\"id\\\":\\\"09f3j20839h032y0329hf30932h0nffn\\\",\"\n+        + \"\\\"expiration_date\\\":{\"\n+            + \"\\\"month\\\":14,\"\n+            + \"\\\"year\\\":6650,\"\n+            + \"\\\"timeStamp\\\":468406876880768\"\n+        + \"},\"\n+        // This field should be using hyphens\n+        + \"\\\"inner-message-1\\\":{\"\n+            + \"\\\"n--id-ct\\\":12,\"\n+            + \"\\\"content\\\":2,\"\n+            + \"\\\"$binary_data$\\\":[\"\n+              + \"{\"\n+                  + \"\\\"data\\\":\\\"data$$\\\",\"\n+                  + \"\\\"width\\\":200\"\n+              + \"},\"\n+              + \"{\"\n+                  + \"\\\"height\\\":56\"\n+              + \"}]\"\n+            + \"}\"\n+        + \"}\");\n+\n+    ProtoWithAnnotations rebuilt = gsonWithLowerHyphen.fromJson(json, ProtoWithAnnotations.class);\n+    assertThat(rebuilt).isEqualTo(proto);\n+  }\n+}\n--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java\n+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.protobuf.ProtoTypeAdapter;\n+import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;\n import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;\n import com.google.gson.protobuf.generated.Bag.SimpleProto;\n import com.google.protobuf.GeneratedMessage;\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    gson = new GsonBuilder().registerTypeHierarchyAdapter(\n-      GeneratedMessage.class, new ProtoTypeAdapter()).create();\n+    gson =\n+        new GsonBuilder()\n+            .registerTypeHierarchyAdapter(GeneratedMessage.class,\n+                ProtoTypeAdapter.newBuilder()\n+                    .setEnumSerialization(EnumSerialization.NUMBER)\n+                    .build())\n+            .create();\n   }\n \n   public void testSerializeRepeatedFields() {\n--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.protobuf.ProtoTypeAdapter;\n+import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;\n import com.google.gson.protobuf.generated.Bag.SimpleProto;\n import com.google.protobuf.Descriptors.Descriptor;\n import com.google.protobuf.GeneratedMessage;\n   protected void setUp() throws Exception {\n     super.setUp();\n     gson = new GsonBuilder().registerTypeHierarchyAdapter(\n-      GeneratedMessage.class, new ProtoTypeAdapter()).create();\n+      GeneratedMessage.class, ProtoTypeAdapter.newBuilder()\n+          .setEnumSerialization(EnumSerialization.NUMBER)\n+          .build())\n+      .create();\n   }\n \n   public void testSerializeEmptyProto() {", "timestamp": 1444173637, "metainfo": ""}