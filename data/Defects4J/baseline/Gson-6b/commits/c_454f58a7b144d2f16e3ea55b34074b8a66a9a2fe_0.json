{"sha": "454f58a7b144d2f16e3ea55b34074b8a66a9a2fe", "log": "Adding in instance creator to instantiate the concrete Collection or Map class if known, otherwise fallback to a default instance.  Also, added some caching as part of the default constructor lookups.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/DefaultConstructorAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.internal.Cache;\n+import com.google.gson.internal.LruCache;\n+\n+import java.lang.reflect.Constructor;\n+\n+/**\n+ * Use the default constructor on the class to instantiate an object.\n+ *\n+ * @author Joel Leitch\n+ */\n+class DefaultConstructorAllocator {\n+  private static final Constructor<Null> NULL_CONSTRUCTOR = createNullConstructor();\n+\n+  // Package private for testing purposes.\n+  final Cache<Class<?>, Constructor<?>> constructorCache;\n+\n+  public DefaultConstructorAllocator() {\n+    this(200);\n+  }\n+\n+  public DefaultConstructorAllocator(int cacheSize) {\n+    constructorCache = new LruCache<Class<?>, Constructor<?>>(cacheSize);\n+  }\n+\n+  private static final Constructor<Null> createNullConstructor() {\n+    try {\n+      return getNoArgsConstructor(Null.class);\n+    } catch (Exception e) {\n+      return null;\n+    }\n+  }\n+\n+  public <T> T newInstance(Class<T> c) throws Exception {\n+    Constructor<T> constructor = findConstructor(c);\n+    return (constructor != null) ? constructor.newInstance() : null;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> Constructor<T> findConstructor(Class<T> c) {\n+    Constructor<T> cachedElement = (Constructor<T>) constructorCache.getElement(c);\n+    if (cachedElement != null) {\n+      if (cachedElement == NULL_CONSTRUCTOR) {\n+        return null;\n+      } else {\n+        return cachedElement;\n+      }\n+    }\n+\n+    Constructor<T> noArgsConstructor = getNoArgsConstructor(c);\n+    if (noArgsConstructor != null) {\n+      constructorCache.addElement(c, noArgsConstructor);\n+    } else {\n+      constructorCache.addElement(c, NULL_CONSTRUCTOR);\n+    }\n+    return noArgsConstructor;\n+  }\n+\n+  private static <T> Constructor<T> getNoArgsConstructor(Class<T> c) {\n+    try {\n+      Constructor<T> declaredConstructor = c.getDeclaredConstructor();\n+      declaredConstructor.setAccessible(true);\n+      return declaredConstructor;\n+    } catch (Exception e) {\n+      return null;\n+    }\n+  }\n+\n+  // placeholder class for Null constructor\n+  private static final class Null {\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Collection;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.HashSet;\n+import java.util.LinkedHashMap;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n-import java.util.Properties;\n+import java.util.Queue;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.StringTokenizer;\n   private static final LocaleTypeAdapter LOCALE_TYPE_ADAPTER = new LocaleTypeAdapter();\n   private static final DefaultInetAddressAdapter INET_ADDRESS_ADAPTER =\n       new DefaultInetAddressAdapter();\n-  private static final CollectionTypeAdapter COLLECTION_TYPE_ADAPTER = new CollectionTypeAdapter();\n+      private static final CollectionTypeAdapter COLLECTION_TYPE_ADAPTER = new CollectionTypeAdapter();\n   private static final MapTypeAdapter MAP_TYPE_ADAPTER = new MapTypeAdapter();\n   private static final BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER = new BigDecimalTypeAdapter();\n   private static final BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER = new BigIntegerTypeAdapter();\n   private static final ShortTypeAdapter SHORT_TYPE_ADAPTER = new ShortTypeAdapter();\n   private static final StringTypeAdapter STRING_TYPE_ADAPTER = new StringTypeAdapter();\n   private static final StringBuilderTypeAdapter STRING_BUILDER_TYPE_ADAPTER =\n-    new StringBuilderTypeAdapter();\n+      new StringBuilderTypeAdapter();\n   private static final StringBufferTypeAdapter STRING_BUFFER_TYPE_ADAPTER =\n-    new StringBufferTypeAdapter();\n-\n-  private static final PropertiesCreator PROPERTIES_CREATOR = new PropertiesCreator();\n-  private static final TreeSetCreator TREE_SET_CREATOR = new TreeSetCreator();\n-  private static final HashSetCreator HASH_SET_CREATOR = new HashSetCreator();\n+      new StringBufferTypeAdapter();\n+\n   private static final GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER =\n       new GregorianCalendarTypeAdapter();\n \n     return map;\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n   private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\n     ParameterizedTypeHandlerMap<InstanceCreator<?>> map =\n         new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n-    map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n+    DefaultConstructorAllocator allocator = new DefaultConstructorAllocator(50);\n+\n+    // Map Instance Creators\n+    map.registerForTypeHierarchy(Map.class,\n+        new DefaultConstructorCreator<Map>(LinkedHashMap.class, allocator));\n \n     // Add Collection type instance creators\n-    map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n-\n-    map.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR);\n-    map.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR);\n-    map.register(Properties.class, PROPERTIES_CREATOR);\n+    DefaultConstructorCreator<List> listCreator =\n+        new DefaultConstructorCreator<List>(ArrayList.class, allocator);\n+    DefaultConstructorCreator<Queue> queueCreator =\n+      new DefaultConstructorCreator<Queue>(LinkedList.class, allocator);\n+    DefaultConstructorCreator<Set> setCreator =\n+        new DefaultConstructorCreator<Set>(HashSet.class, allocator);\n+    DefaultConstructorCreator<SortedSet> sortedSetCreator =\n+        new DefaultConstructorCreator<SortedSet>(TreeSet.class, allocator);\n+    map.registerForTypeHierarchy(Collection.class, listCreator);\n+    map.registerForTypeHierarchy(Queue.class, queueCreator);\n+    map.registerForTypeHierarchy(Set.class, setCreator);\n+    map.registerForTypeHierarchy(SortedSet.class, sortedSetCreator);\n+\n     map.makeUnmodifiable();\n     return map;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   private static final class CollectionTypeAdapter implements JsonSerializer<Collection>,\n-      JsonDeserializer<Collection>, InstanceCreator<Collection> {\n+      JsonDeserializer<Collection> {\n     public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) {\n       if (src == null) {\n         return JsonNull.createJsonNull();\n       ObjectConstructor objectConstructor = contextImpl.getObjectConstructor();\n       return (Collection) objectConstructor.construct(collectionType);\n     }\n-\n-    public Collection createInstance(Type type) {\n-      return new LinkedList();\n-    }\n-  }\n-\n-  private static class PropertiesCreator implements InstanceCreator<Properties> {\n-    public Properties createInstance(Type type) {\n-      return new Properties();\n-    }\n   }\n \n   private static final class BigDecimalTypeAdapter\n         throw new JsonSyntaxException(e);\n       } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n-      }        \n+      }\n     }\n \n     @Override\n     }\n   }\n \n-  private static final class TreeSetCreator implements InstanceCreator<TreeSet<?>> {\n-    public TreeSet<?> createInstance(Type type) {\n-      return new TreeSet<Object>();\n-    }\n-    @Override\n-    public String toString() {\n-      return TreeSetCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static final class HashSetCreator implements InstanceCreator<HashSet<?>> {\n-    public HashSet<?> createInstance(Type type) {\n-      return new HashSet<Object>();\n-    }\n-    @Override\n-    public String toString() {\n-      return HashSetCreator.class.getSimpleName();\n+  @SuppressWarnings(\"unchecked\")\n+  private static final class DefaultConstructorCreator<T> implements InstanceCreator<T> {\n+    private final Class<? extends T> defaultInstance;\n+    private final DefaultConstructorAllocator allocator;\n+\n+    public DefaultConstructorCreator(Class<? extends T> defaultInstance,\n+        DefaultConstructorAllocator allocator) {\n+      this.defaultInstance = defaultInstance;\n+      this.allocator = allocator;\n+    }\n+\n+    public T createInstance(Type type) {\n+      Class<?> rawType = Types.getRawType(type);\n+      try {\n+        T specificInstance = (T) allocator.newInstance(rawType);\n+        return (specificInstance == null)\n+            ? allocator.newInstance(defaultInstance)\n+            : specificInstance;\n+      } catch (Exception e) {\n+        throw new JsonIOException(e);\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return DefaultConstructorCreator.class.getSimpleName();\n     }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n \n  *\n  * @author Joel Leitch\n  */\n-@SuppressWarnings(\"unchecked\") \n+@SuppressWarnings(\"unchecked\")\n final class MapTypeAdapter implements JsonSerializer<Map<?, ?>>,\n-    JsonDeserializer<Map<?, ?>>, InstanceCreator<Map<?, ?>> {\n-\n+    JsonDeserializer<Map<?, ?>> {\n   public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) {\n     JsonObject map = new JsonObject();\n     Type childGenericType = null;\n     return (Map) objectConstructor.construct(mapType);\n   }\n \n-  public Map<Object, Object> createInstance(Type type) {\n-    return new LinkedHashMap();\n-  }\n-\n   @Override\n   public String toString() {\n     return MapTypeAdapter.class.getSimpleName();\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.LruCache;\n import com.google.gson.internal.Types;\n import com.google.gson.internal.UnsafeAllocator;\n \n import java.lang.reflect.Array;\n-import java.lang.reflect.Constructor;\n import java.lang.reflect.Type;\n \n /**\n  */\n final class MappedObjectConstructor implements ObjectConstructor {\n   private static final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n+  private static final DefaultConstructorAllocator defaultConstructorAllocator =\n+      new DefaultConstructorAllocator(500);\n \n-  private static final LruCache<Class<?>, Constructor<?>> noArgsConstructorsCache =\n-      new LruCache<Class<?>, Constructor<?>>(500);\n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap;\n-  /**\n-   * We need a special null value to indicate that the class does not have a no-args constructor.\n-   * This helps avoid using reflection over and over again for such classes. For convenience, we\n-   * use the no-args constructor of this class itself since this class would never be\n-   * deserialized using Gson.\n-   */\n-  private static final Constructor<MappedObjectConstructor> NULL_VALUE =\n-    getNoArgsConstructorUsingReflection(MappedObjectConstructor.class);\n-  \n-  @SuppressWarnings(\"unused\")\n-  private MappedObjectConstructor() {\n-    this(null);\n-  }\n \n   public MappedObjectConstructor(\n       ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n     if (creator != null) {\n       return creator.createInstance(typeOfT);\n     }\n-    return (T) constructWithNoArgConstructor(typeOfT);\n+    return (T) constructWithAllocators(typeOfT);\n   }\n \n   public Object constructArray(Type type, int length) {\n   }\n \n   @SuppressWarnings({\"unchecked\", \"cast\"})\n-  private <T> T constructWithNoArgConstructor(Type typeOfT) {\n+  private <T> T constructWithAllocators(Type typeOfT) {\n     try {\n       Class<T> clazz = (Class<T>) Types.getRawType(typeOfT);\n-      Constructor<T> constructor = getNoArgsConstructor(clazz);\n-      return constructor == null\n+      T obj = defaultConstructorAllocator.newInstance(clazz);\n+      return (obj == null)\n           ? unsafeAllocator.newInstance(clazz)\n-          : constructor.newInstance();\n+          : obj;\n     } catch (Exception e) {\n       throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n           + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n-    }\n-  }\n-\n-  private <T> Constructor<T> getNoArgsConstructor(Class<T> clazz) {\n-    @SuppressWarnings(\"unchecked\")\n-    Constructor<T> constructor = (Constructor<T>)noArgsConstructorsCache.getElement(clazz);\n-    if (constructor == NULL_VALUE) {\n-      return null;\n-    }\n-    if (constructor == null) {\n-      constructor = getNoArgsConstructorUsingReflection(clazz);\n-      noArgsConstructorsCache.addElement(clazz, constructor);\n-    }\n-    return constructor == NULL_VALUE ? null : constructor;\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  private static <T> Constructor<T> getNoArgsConstructorUsingReflection(Class<T> clazz) {\n-    try {\n-      Constructor<T> constructor = clazz.getDeclaredConstructor();\n-      constructor.setAccessible(true);\n-      return constructor;\n-    } catch (Exception e) {\n-      return (Constructor<T>) NULL_VALUE;\n     }\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/DefaultConstructorAllocatorTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DefaultConstructorAllocator;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+\n+/**\n+ * Unit tests for the default constructor allocator class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class DefaultConstructorAllocatorTest extends TestCase {\n+  private DefaultConstructorAllocator allocator;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    allocator = new DefaultConstructorAllocator();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testObjectConstructor() throws Exception {\n+    ArrayList<Object> arrayList = allocator.newInstance(ArrayList.class);\n+    assertTrue(arrayList.isEmpty());\n+    assertInCache(ArrayList.class);\n+\n+    LinkedList<Object> linkedList = allocator.newInstance(LinkedList.class);\n+    assertTrue(linkedList.isEmpty());\n+    assertInCache(LinkedList.class);\n+  }\n+\n+  public void testMissingDefaultConstructor() throws Exception {\n+    assertNull(allocator.newInstance(NoDefaultConstructor.class));\n+    assertInCache(NoDefaultConstructor.class);\n+  }\n+\n+  private void assertInCache(Class<?> clazz) {\n+    assertNotNull(allocator.constructorCache.getElement(clazz));\n+  }\n+\n+  private static class NoDefaultConstructor {\n+    @SuppressWarnings(\"unused\")\n+    public NoDefaultConstructor(int i) {\n+      // do nothing\n+    }\n+  }\n+}", "timestamp": 1301417848, "metainfo": ""}