{"sha": "fed332906debe74d0879c77a03825b66f7970c41", "log": "Create a single, monolithic class to manage all exclusion strategies. This gets our file size within target of 177KiB.  I intend to follow this up with a builder for our new class to avoid multiple-argument constructor calls.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n+import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n \n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n \n-  private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY = createExclusionStrategy();\n+  private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY = new GsonExclusionStrategy(\n+      GsonExclusionStrategy.IGNORE_VERSIONS, Modifier.TRANSIENT | Modifier.STATIC,\n+      true, true, true, false, false);\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n     };\n   }\n \n-  private static ExclusionStrategy createExclusionStrategy() {\n-    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(GsonBuilder.EXCLUDE_ANONYMOUS_AND_LOCAL);\n-    strategies.add(GsonBuilder.EXCLUDE_SYNTHETIC_FIELDS);\n-    strategies.add(GsonBuilder.EXCLUDE_TRANSIENT_AND_STATIC);\n-    return new DisjunctionExclusionStrategy(strategies);\n-  }\n-\n   /**\n    * Returns the type adapter for {@code} type.\n    *\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n-import com.google.gson.annotations.Expose;\n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.TypeMap;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Date;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n  * @author Joel Leitch\n  */\n public final class GsonBuilder {\n-  /** Strategy for excluding inner classes. */\n-  static final ExclusionStrategy EXCLUDE_INNER_CLASSES = new ExclusionStrategy() {\n-    public boolean shouldSkipField(FieldAttributes f) {\n-      return isInnerClass(f.getDeclaredClass());\n-    }\n-    public boolean shouldSkipClass(Class<?> clazz) {\n-      return isInnerClass(clazz);\n-    }\n-    private boolean isInnerClass(Class<?> clazz) {\n-      return clazz.isMemberClass() && !isStatic(clazz);\n-    }\n-    private boolean isStatic(Class<?> clazz) {\n-      return (clazz.getModifiers() & Modifier.STATIC) != 0;\n-    }\n-  };\n-\n-  /** Excludes fields that do not have the {@link Expose} annotation */\n-  static final ExclusionStrategy REQUIRE_EXPOSE_DESERIALIZE = new ExclusionStrategy() {\n-    public boolean shouldSkipClass(Class<?> clazz) {\n-      return false;\n-    }\n-    public boolean shouldSkipField(FieldAttributes f) {\n-      Expose annotation = f.getAnnotation(Expose.class);\n-      return annotation == null || !annotation.deserialize();\n-    }\n-  };\n-\n-  /** Excludes fields that do not have the {@link Expose} annotation */\n-  static final ExclusionStrategy REQUIRE_EXPOSE_SERIALIZE = new ExclusionStrategy() {\n-    public boolean shouldSkipClass(Class<?> clazz) {\n-      return false;\n-    }\n-    public boolean shouldSkipField(FieldAttributes f) {\n-      Expose annotation = f.getAnnotation(Expose.class);\n-      return annotation == null || !annotation.serialize();\n-    }\n-  };\n-\n-  static final ExclusionStrategy EXCLUDE_ANONYMOUS_AND_LOCAL = new ExclusionStrategy() {\n-    public boolean shouldSkipField(FieldAttributes f) {\n-      return isAnonymousOrLocal(f.getDeclaredClass());\n-    }\n-    public boolean shouldSkipClass(Class<?> clazz) {\n-      return isAnonymousOrLocal(clazz);\n-    }\n-    private boolean isAnonymousOrLocal(Class<?> clazz) {\n-      return !Enum.class.isAssignableFrom(clazz)\n-          && (clazz.isAnonymousClass() || clazz.isLocalClass());\n-    }\n-  };\n-\n-  static final ExclusionStrategy EXCLUDE_SYNTHETIC_FIELDS = new ExclusionStrategy() {\n-    public boolean shouldSkipClass(Class<?> clazz) {\n-      return false;\n-    }\n-    public boolean shouldSkipField(FieldAttributes f) {\n-      return f.isSynthetic();\n-    }\n-  };\n-\n-  static final ModifierBasedExclusionStrategy EXCLUDE_TRANSIENT_AND_STATIC\n-      = new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC);\n-\n-  private final Set<ExclusionStrategy> serializeExclusionStrategies =\n-      new HashSet<ExclusionStrategy>();\n-  private final Set<ExclusionStrategy> deserializeExclusionStrategies =\n-      new HashSet<ExclusionStrategy>();\n-\n-  private double ignoreVersionsAfter;\n-  private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n-  private boolean serializeInnerClasses;\n-  private boolean excludeFieldsWithoutExposeAnnotation;\n+  private ExclusionStrategy serializeExclusionStrategy;\n+  private ExclusionStrategy deserializeExclusionStrategy;\n+  private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\n+  private double ignoreVersionsAfter = GsonExclusionStrategy.IGNORE_VERSIONS;\n+  private boolean serializeInnerClasses = true;\n+  private boolean excludeFieldsWithoutExposeAnnotation = false;\n+\n   private LongSerializationPolicy longSerializationPolicy;\n   private FieldNamingStrategy fieldNamingPolicy;\n   private final TypeMap<InstanceCreator<?>> instanceCreators;\n    * {@link #create()}.\n    */\n   public GsonBuilder() {\n-    // add default exclusion strategies\n-    deserializeExclusionStrategies.add(EXCLUDE_ANONYMOUS_AND_LOCAL);\n-    deserializeExclusionStrategies.add(EXCLUDE_SYNTHETIC_FIELDS);\n-    serializeExclusionStrategies.add(EXCLUDE_ANONYMOUS_AND_LOCAL);\n-    serializeExclusionStrategies.add(EXCLUDE_SYNTHETIC_FIELDS);\n-\n     // setup default values\n-    ignoreVersionsAfter = VersionExclusionStrategy.IGNORE_VERSIONS;\n-    serializeInnerClasses = true;\n     prettyPrinting = false;\n     escapeHtmlChars = true;\n-    modifierBasedExclusionStrategy = EXCLUDE_TRANSIENT_AND_STATIC;\n-    excludeFieldsWithoutExposeAnnotation = false;\n     longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n     fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n     instanceCreators = new TypeMap<InstanceCreator<?>>();\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n-    modifierBasedExclusionStrategy = new ModifierBasedExclusionStrategy(modifiers);\n+    this.modifiers = 0;\n+    for (int modifier : modifiers) {\n+      this.modifiers |= modifier;\n+    }\n     return this;\n   }\n \n    * @since 1.4\n    */\n   public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\n-    List<ExclusionStrategy> strategyList = Arrays.asList(strategies);\n-    serializeExclusionStrategies.addAll(strategyList);\n-    deserializeExclusionStrategies.addAll(strategyList);\n+    for (ExclusionStrategy strategy : strategies) {\n+      addSerializationExclusionStrategy(strategy);\n+      addDeserializationExclusionStrategy(strategy);\n+    }\n     return this;\n   }\n \n    * @since 1.7\n    */\n   public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\n-    serializeExclusionStrategies.add(strategy);\n+    serializeExclusionStrategy = combine(serializeExclusionStrategy, strategy);\n     return this;\n   }\n \n    * @since 1.7\n    */\n   public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\n-    deserializeExclusionStrategies.add(strategy);\n+    deserializeExclusionStrategy = combine(deserializeExclusionStrategy, strategy);\n     return this;\n   }\n \n   }\n \n   /**\n+   * Unions two exclusion strategies. If the first is null, this returns the\n+   * second.\n+   */\n+  private static ExclusionStrategy combine(final ExclusionStrategy a, final ExclusionStrategy b) {\n+    if (b == null) {\n+      throw new IllegalArgumentException();\n+    }\n+    if (a == null) {\n+      return b;\n+    }\n+    return new ExclusionStrategy() {\n+      public boolean shouldSkipField(FieldAttributes f) {\n+        return a.shouldSkipField(f) || b.shouldSkipField(f);\n+      }\n+      public boolean shouldSkipClass(Class<?> clazz) {\n+        return a.shouldSkipClass(clazz) || b.shouldSkipClass(clazz);\n+      }\n+    };\n+  }\n+\n+  /**\n    * Creates a {@link Gson} instance based on the current configuration. This method is free of\n    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n    *\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<ExclusionStrategy> deserializationStrategies =\n-        new LinkedList<ExclusionStrategy>(deserializeExclusionStrategies);\n-    List<ExclusionStrategy> serializationStrategies =\n-        new LinkedList<ExclusionStrategy>(serializeExclusionStrategies);\n-    deserializationStrategies.add(modifierBasedExclusionStrategy);\n-    serializationStrategies.add(modifierBasedExclusionStrategy);\n-\n-    if (!serializeInnerClasses) {\n-      deserializationStrategies.add(EXCLUDE_INNER_CLASSES);\n-      serializationStrategies.add(EXCLUDE_INNER_CLASSES);\n-    }\n-    if (ignoreVersionsAfter != VersionExclusionStrategy.IGNORE_VERSIONS) {\n-      VersionExclusionStrategy versionExclusionStrategy =\n-          new VersionExclusionStrategy(ignoreVersionsAfter);\n-      deserializationStrategies.add(versionExclusionStrategy);\n-      serializationStrategies.add(versionExclusionStrategy);\n-    }\n-    if (excludeFieldsWithoutExposeAnnotation) {\n-      deserializationStrategies.add(REQUIRE_EXPOSE_DESERIALIZE);\n-      serializationStrategies.add(REQUIRE_EXPOSE_SERIALIZE);\n-    }\n     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers);\n \n-    return new Gson(new DisjunctionExclusionStrategy(deserializationStrategies),\n-        new DisjunctionExclusionStrategy(serializationStrategies),\n-        fieldNamingPolicy, instanceCreators.copyOf().makeUnmodifiable(), serializeNulls,\n+    ExclusionStrategy deserializeExclusionStrategy = combine(this.deserializeExclusionStrategy,\n+        new GsonExclusionStrategy(ignoreVersionsAfter, modifiers, true,\n+        true, serializeInnerClasses, false, excludeFieldsWithoutExposeAnnotation));\n+    ExclusionStrategy serializeExclusionStrategy = combine(this.serializeExclusionStrategy,\n+        new GsonExclusionStrategy(ignoreVersionsAfter, modifiers, true, true,\n+            serializeInnerClasses, excludeFieldsWithoutExposeAnnotation, false));\n+\n+    return new Gson(deserializeExclusionStrategy, serializeExclusionStrategy, fieldNamingPolicy,\n+        instanceCreators.copyOf().makeUnmodifiable(), serializeNulls,\n         serializers.copyOf().makeUnmodifiable(), deserializers.copyOf().makeUnmodifiable(),\n         complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n         serializeSpecialFloatingPointValues, longSerializationPolicy, typeAdapterFactories);\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/GsonExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.Since;\n+import com.google.gson.annotations.Until;\n+import java.lang.reflect.Modifier;\n+\n+/**\n+ * A configurable exclusion strategy. This strategy supports version attributes\n+ * {@link Since} and {@link Until}, modifiers, synthetic fields, anonymous and\n+ * local classes, inner classes, and fields with the {@link Expose} annotation.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+final class GsonExclusionStrategy implements ExclusionStrategy {\n+  static final double IGNORE_VERSIONS = -1D;\n+  private final double version;\n+  private final int modifiers;\n+  private final boolean excludeSyntheticFields;\n+  private final boolean excludeAnonymousAndLocal;\n+  private final boolean serializeInnerClasses;\n+  private final boolean requireExposeOnSerialize;\n+  private final boolean requireExposeOnDeserialize;\n+\n+  GsonExclusionStrategy(double version, int modifiers, boolean excludeSyntheticFields,\n+      boolean excludeAnonymousAndLocal, boolean serializeInnerClasses,\n+      boolean requireExposeOnSerialize, boolean requireExposeOnDeserialize) {\n+    this.version = version;\n+    this.modifiers = modifiers;\n+    this.excludeSyntheticFields = excludeSyntheticFields;\n+    this.excludeAnonymousAndLocal = excludeAnonymousAndLocal;\n+    this.serializeInnerClasses = serializeInnerClasses;\n+    this.requireExposeOnSerialize = requireExposeOnSerialize;\n+    this.requireExposeOnDeserialize = requireExposeOnDeserialize;\n+  }\n+\n+  public boolean shouldSkipField(FieldAttributes f) {\n+    if (f.hasModifier(modifiers)) {\n+      return true;\n+    }\n+    if (version != GsonExclusionStrategy.IGNORE_VERSIONS\n+        && !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class))) {\n+      return true;\n+    }\n+    if (excludeSyntheticFields && f.isSynthetic()) {\n+      return true;\n+    }\n+    if (requireExposeOnSerialize || requireExposeOnDeserialize) {\n+      Expose annotation = f.getAnnotation(Expose.class);\n+      if (annotation == null\n+          || requireExposeOnSerialize && !annotation.serialize()\n+          || requireExposeOnDeserialize && !annotation.deserialize()) {\n+        return true;\n+      }\n+    }\n+    if (!serializeInnerClasses && isInnerClass(f.getDeclaredClass())) {\n+      return true;\n+    }\n+    if (excludeAnonymousAndLocal && isAnonymousOrLocal(f.getDeclaredClass())) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    if (version != GsonExclusionStrategy.IGNORE_VERSIONS\n+        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n+      return true;\n+    }\n+    if (!serializeInnerClasses && isInnerClass(clazz)) {\n+      return true;\n+    }\n+    if (excludeAnonymousAndLocal && isAnonymousOrLocal(clazz)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isAnonymousOrLocal(Class<?> clazz) {\n+    return !Enum.class.isAssignableFrom(clazz)\n+        && (clazz.isAnonymousClass() || clazz.isLocalClass());\n+  }\n+\n+  private boolean isInnerClass(Class<?> clazz) {\n+    return clazz.isMemberClass() && !isStatic(clazz);\n+  }\n+\n+  private boolean isStatic(Class<?> clazz) {\n+    return (clazz.getModifiers() & Modifier.STATIC) != 0;\n+  }\n+\n+  private boolean isValidVersion(Since since, Until until) {\n+    return isValidSince(since) && isValidUntil(until);\n+  }\n+\n+  private boolean isValidSince(Since annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n+      if (annotationVersion > version) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isValidUntil(Until annotation) {\n+    if (annotation != null) {\n+      double annotationVersion = annotation.value();\n+      if (annotationVersion <= version) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n  * @author Joel Leitch\n  */\n public class ExposeAnnotationExclusionStrategyTest extends TestCase {\n-  private ExclusionStrategy deserializationStrategy = GsonBuilder.REQUIRE_EXPOSE_DESERIALIZE;\n-  private ExclusionStrategy serializationStrategy = GsonBuilder.REQUIRE_EXPOSE_SERIALIZE;\n+  private ExclusionStrategy serializationStrategy = new GsonExclusionStrategy(\n+      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, true, true, true, false);\n+  private ExclusionStrategy deserializationStrategy = new GsonExclusionStrategy(\n+      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, true, true, false, true);\n \n   public void testNeverSkipClasses() throws Exception {\n     assertFalse(deserializationStrategy.shouldSkipClass(MockObject.class));\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n import com.google.gson.common.TestTypes.ClassWithNoFields;\n import java.lang.reflect.Modifier;\n import java.util.Collections;\n-import java.util.LinkedList;\n import junit.framework.TestCase;\n \n /**\n \n   @SuppressWarnings(\"unchecked\")\n   public void testAnonymousLocalClassesSerialization() throws Exception {\n-    LinkedList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(GsonBuilder.EXCLUDE_SYNTHETIC_FIELDS);\n-    strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));\n-    ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n+    ExclusionStrategy exclusionStrategy = new GsonExclusionStrategy(\n+        GsonExclusionStrategy.IGNORE_VERSIONS, Modifier.TRANSIENT | Modifier.STATIC,\n+        true, false, true, false, false);\n     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, FieldNamingPolicy.IDENTITY,\n         Gson.EMPTY_MAP, false, Gson.EMPTY_MAP, Gson.EMPTY_MAP, false,\n         Gson.DEFAULT_JSON_NON_EXECUTABLE,\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n package com.google.gson;\n \n+import java.lang.reflect.Field;\n import junit.framework.TestCase;\n-\n-import java.lang.reflect.Field;\n \n /**\n  * Unit test for GsonBuilder.EXCLUDE_INNER_CLASSES.\n  * @author Joel Leitch\n  */\n public class InnerClassExclusionStrategyTest extends TestCase {\n-  public InnerClass innerClass;\n-  public StaticNestedClass staticNestedClass;\n-\n-  private ExclusionStrategy strategy;\n-\n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-    innerClass = new InnerClass();\n-    staticNestedClass = new StaticNestedClass();\n-    strategy = GsonBuilder.EXCLUDE_INNER_CLASSES;\n-  }\n+  public InnerClass innerClass = new InnerClass();\n+  public StaticNestedClass staticNestedClass = new StaticNestedClass();\n+  private ExclusionStrategy strategy = new GsonExclusionStrategy(\n+      GsonExclusionStrategy.IGNORE_VERSIONS, 0, true, false, false, false, false);\n \n   public void testExcludeInnerClassObject() throws Exception {\n     Class<?> clazz = innerClass.getClass();\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n \n package com.google.gson;\n \n+import com.google.gson.annotations.Since;\n import java.lang.reflect.Field;\n-\n import junit.framework.TestCase;\n \n-import com.google.gson.annotations.Since;\n-\n /**\n- * Unit tests for the {@link VersionExclusionStrategy} class.\n+ * Unit tests for the {@link GsonExclusionStrategy} class.\n  *\n  * @author Joel Leitch\n  */\n public class VersionExclusionStrategyTest extends TestCase {\n   private static final double VERSION = 5.0D;\n \n-  public void testDisallowNegativeValuesAndFailFast() throws Exception {\n-    try {\n-      new VersionExclusionStrategy(-1.0D);\n-      fail(\"should have thrown an exception.\");\n-    } catch (IllegalArgumentException expected) { }\n-  }\n-\n   public void testClassAndFieldAreAtSameVersion() throws Exception {\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n-    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n+    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION, 0,\n+        true, true, true, false, false);\n     assertFalse(strategy.shouldSkipClass(clazz));\n \n     FieldAttributes fieldAttributes = new FieldAttributes(f);\n   public void testClassAndFieldAreBehindInVersion() throws Exception {\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n-    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n+    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION + 1, 0,\n+        true, true, true, false, false);\n     assertFalse(strategy.shouldSkipClass(clazz));\n \n     FieldAttributes fieldAttributes = new FieldAttributes(f);\n   public void testClassAndFieldAreAheadInVersion() throws Exception {\n     Class<MockObject> clazz = MockObject.class;\n     Field f = clazz.getField(\"someField\");\n-    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n+    GsonExclusionStrategy strategy = new GsonExclusionStrategy(VERSION - 1, 0,\n+        true, true, true, false, false);\n     assertTrue(strategy.shouldSkipClass(clazz));\n \n     FieldAttributes fieldAttributes = new FieldAttributes(f);", "timestamp": 1321942038, "metainfo": ""}