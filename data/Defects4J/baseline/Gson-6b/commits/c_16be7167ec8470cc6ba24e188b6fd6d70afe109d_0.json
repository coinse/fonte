{"sha": "16be7167ec8470cc6ba24e188b6fd6d70afe109d", "log": "Updated Gson grammar to support floating point numbers without a +/- after the E. So, 1.234567899E8 is now accepted by Gson as a valid floating point number. This fixed the bug http://code.google.com/p/google-gson/issues/detail?id=94  Also, updated Gson to use Javacc 4.2.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonParserImpl.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImpl.java\n   final public JsonElement parse() throws ParseException {\n   JsonElement json = null;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 25:\n+    case 26:\n       json = JsonObject();\n       break;\n-    case 29:\n+    case 30:\n       json = JsonArray();\n       break;\n     case DIGITS:\n     case BOOLEAN:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n-    case 31:\n+    case 32:\n       json = JsonPrimitive();\n       break;\n     case NULL:\n \n   final private JsonObject JsonObject() throws ParseException {\n   JsonObject o = new JsonObject();\n-    jj_consume_token(25);\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case IDENTIFIER:\n+    jj_consume_token(26);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER_SANS_EXPONENT:\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n       Members(o);\n       jj_la1[1] = jj_gen;\n       ;\n     }\n-    jj_consume_token(26);\n+    jj_consume_token(27);\n     {if (true) return o;}\n     throw new Error(\"Missing return statement in function\");\n   }\n   final private void Members(JsonObject o) throws ParseException {\n     Pair(o);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 27:\n-      jj_consume_token(27);\n+    case 28:\n+      jj_consume_token(28);\n       Members(o);\n       break;\n     default:\n   JsonPrimitive property;\n   JsonElement value;\n     property = JsonMemberName();\n-    jj_consume_token(28);\n+    jj_consume_token(29);\n     value = JsonValue();\n     o.add(property.getAsString(), value);\n   }\n   final private JsonPrimitive JsonMemberName() throws ParseException {\n   Token t; JsonPrimitive value;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case IDENTIFIER:\n-      t = jj_consume_token(IDENTIFIER);\n-                   {if (true) return new JsonPrimitive(t.image);}\n+    case IDENTIFIER_SANS_EXPONENT:\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n+      t = Identifier();\n+                    {if (true) return new JsonPrimitive(t.image);}\n       break;\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n \n   final private JsonArray JsonArray() throws ParseException {\n   JsonArray array = new JsonArray();\n-    jj_consume_token(29);\n+    jj_consume_token(30);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case DIGITS:\n     case NULL:\n     case BOOLEAN:\n     case SINGLE_QUOTE_LITERAL:\n     case DOUBLE_QUOTE_LITERAL:\n-    case 25:\n-    case 29:\n-    case 31:\n+    case 26:\n+    case 30:\n+    case 32:\n       Elements(array);\n       break;\n     default:\n       jj_la1[4] = jj_gen;\n       ;\n     }\n-    jj_consume_token(30);\n+    jj_consume_token(31);\n     array.reverse();\n     {if (true) return array;}\n     throw new Error(\"Missing return statement in function\");\n   JsonElement element;\n     element = JsonValue();\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 27:\n-      jj_consume_token(27);\n+    case 28:\n+      jj_consume_token(28);\n       Elements(array);\n       break;\n     default:\n     case DIGITS:\n     case NAN:\n     case INFINITY:\n-    case 31:\n+    case 32:\n       o = JsonNumber();\n       break;\n-    case 25:\n+    case 26:\n       o = JsonObject();\n       break;\n-    case 29:\n+    case 30:\n       o = JsonArray();\n       break;\n     case BOOLEAN:\n     case DIGITS:\n     case NAN:\n     case INFINITY:\n-    case 31:\n+    case 32:\n       value = JsonNumber();\n                           {if (true) return value;}\n       break;\n     } else {\n       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n       case DIGITS:\n-      case 31:\n+      case 32:\n         intpart = JsonInt();\n         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-        case 32:\n+        case 33:\n           fracpart = JsonFrac();\n           break;\n         default:\n           ;\n         }\n         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-        case E:\n+        case EXPONENT:\n           exppart = JsonExp();\n           break;\n         default:\n            {if (true) return new JsonPrimitive(Double.NaN);}\n       break;\n     case INFINITY:\n-    case 31:\n+    case 32:\n       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-      case 31:\n-        jj_consume_token(31);\n+      case 32:\n+        jj_consume_token(32);\n          negative = true;\n         break;\n       default:\n   String digits;\n   boolean negative = false;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 31:\n-      jj_consume_token(31);\n+    case 32:\n+      jj_consume_token(32);\n          negative = true;\n       break;\n     default:\n \n   final private String JsonFrac() throws ParseException {\n   String digits;\n-    jj_consume_token(32);\n+    jj_consume_token(33);\n     digits = Digits();\n     {if (true) return \".\" + digits;}\n     throw new Error(\"Missing return statement in function\");\n \n   final private String JsonExp() throws ParseException {\n   Token t;\n-  String digits;\n-    t = jj_consume_token(E);\n-    digits = Digits();\n-    {if (true) return t.image + digits;}\n+    t = jj_consume_token(EXPONENT);\n+                  {if (true) return t.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private Token Identifier() throws ParseException {\n+  Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER_STARTS_WITH_EXPONENT:\n+      t = jj_consume_token(IDENTIFIER_STARTS_WITH_EXPONENT);\n+      break;\n+    case IDENTIFIER_SANS_EXPONENT:\n+      t = jj_consume_token(IDENTIFIER_SANS_EXPONENT);\n+      break;\n+    default:\n+      jj_la1[14] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+                                                                            {if (true) return t;}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n       t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n       break;\n     default:\n-      jj_la1[14] = jj_gen;\n+      jj_la1[15] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n     throw new Error(\"Missing return statement in function\");\n   }\n \n-  final private boolean jj_2_1(int xla) {\n+  private boolean jj_2_1(int xla) {\n     jj_la = xla; jj_lastpos = jj_scanpos = token;\n     try { return !jj_3_1(); }\n     catch(LookaheadSuccess ls) { return true; }\n     finally { jj_save(0, xla); }\n   }\n \n-  final private boolean jj_3R_4() {\n-    if (jj_scan_token(31)) return true;\n+  private boolean jj_3R_4() {\n+    if (jj_scan_token(32)) return true;\n     return false;\n   }\n \n-  final private boolean jj_3R_3() {\n+  private boolean jj_3R_3() {\n     Token xsp;\n     xsp = jj_scanpos;\n     if (jj_3R_4()) jj_scanpos = xsp;\n     return false;\n   }\n \n-  final private boolean jj_3_1() {\n+  private boolean jj_3_1() {\n     if (jj_3R_1()) return true;\n     return false;\n   }\n \n-  final private boolean jj_3R_2() {\n+  private boolean jj_3R_2() {\n     if (jj_scan_token(NAN)) return true;\n     return false;\n   }\n \n-  final private boolean jj_3R_1() {\n+  private boolean jj_3R_1() {\n     Token xsp;\n     xsp = jj_scanpos;\n     if (jj_3R_2()) {\n     return false;\n   }\n \n+  /** Generated Token Manager. */\n   public JsonParserImplTokenManager token_source;\n   SimpleCharStream jj_input_stream;\n-  public Token token, jj_nt;\n+  /** Current token. */\n+  public Token token;\n+  /** Next token. */\n+  public Token jj_nt;\n   private int jj_ntk;\n   private Token jj_scanpos, jj_lastpos;\n   private int jj_la;\n-  public boolean lookingAhead = false;\n-  private boolean jj_semLA;\n   private int jj_gen;\n-  final private int[] jj_la1 = new int[15];\n+  final private int[] jj_la1 = new int[16];\n   static private int[] jj_la1_0;\n   static private int[] jj_la1_1;\n   static {\n-      jj_la1_0();\n-      jj_la1_1();\n+      jj_la1_init_0();\n+      jj_la1_init_1();\n    }\n-   private static void jj_la1_0() {\n-      jj_la1_0 = new int[] {0xa20187c0,0x18800,0x8000000,0x18800,0xa20187c0,0x8000000,0xa20187c0,0x80018740,0x0,0x20,0x80000040,0x80000000,0x80000300,0x80000000,0x18000,};\n+   private static void jj_la1_init_0() {\n+      jj_la1_0 = new int[] {0x440307c0,0x31800,0x10000000,0x31800,0x440307c0,0x10000000,0x440307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n    }\n-   private static void jj_la1_1() {\n-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,};\n+   private static void jj_la1_init_1() {\n+      jj_la1_1 = new int[] {0x1,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x2,0x0,0x1,0x1,0x1,0x1,0x0,0x0,};\n    }\n   final private JJCalls[] jj_2_rtns = new JJCalls[1];\n   private boolean jj_rescan = false;\n   private int jj_gc = 0;\n \n+  /** Constructor with InputStream. */\n   public JsonParserImpl(java.io.InputStream stream) {\n      this(stream, null);\n   }\n+  /** Constructor with InputStream and supplied encoding */\n   public JsonParserImpl(java.io.InputStream stream, String encoding) {\n     try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n     token_source = new JsonParserImplTokenManager(jj_input_stream);\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n+  /** Reinitialise. */\n   public void ReInit(java.io.InputStream stream) {\n      ReInit(stream, null);\n   }\n+  /** Reinitialise. */\n   public void ReInit(java.io.InputStream stream, String encoding) {\n     try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n     token_source.ReInit(jj_input_stream);\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n+  /** Constructor. */\n   public JsonParserImpl(java.io.Reader stream) {\n     jj_input_stream = new SimpleCharStream(stream, 1, 1);\n     token_source = new JsonParserImplTokenManager(jj_input_stream);\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n+  /** Reinitialise. */\n   public void ReInit(java.io.Reader stream) {\n     jj_input_stream.ReInit(stream, 1, 1);\n     token_source.ReInit(jj_input_stream);\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n+  /** Constructor with generated Token Manager. */\n   public JsonParserImpl(JsonParserImplTokenManager tm) {\n     token_source = tm;\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n+  /** Reinitialise. */\n   public void ReInit(JsonParserImplTokenManager tm) {\n     token_source = tm;\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 16; i++) jj_la1[i] = -1;\n     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n   }\n \n-  final private Token jj_consume_token(int kind) throws ParseException {\n+  private Token jj_consume_token(int kind) throws ParseException {\n     Token oldToken;\n     if ((oldToken = token).next != null) token = token.next;\n     else token = token.next = token_source.getNextToken();\n \n   static private final class LookaheadSuccess extends java.lang.Error { }\n   final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n-  final private boolean jj_scan_token(int kind) {\n+  private boolean jj_scan_token(int kind) {\n     if (jj_scanpos == jj_lastpos) {\n       jj_la--;\n       if (jj_scanpos.next == null) {\n     return false;\n   }\n \n+\n+/** Get the next Token. */\n   final public Token getNextToken() {\n     if (token.next != null) token = token.next;\n     else token = token.next = token_source.getNextToken();\n     return token;\n   }\n \n+/** Get the specific Token. */\n   final public Token getToken(int index) {\n-    Token t = lookingAhead ? jj_scanpos : token;\n+    Token t = token;\n     for (int i = 0; i < index; i++) {\n       if (t.next != null) t = t.next;\n       else t = t.next = token_source.getNextToken();\n     return t;\n   }\n \n-  final private int jj_ntk() {\n+  private int jj_ntk() {\n     if ((jj_nt=token.next) == null)\n       return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n     else\n       return (jj_ntk = jj_nt.kind);\n   }\n \n-  private java.util.Vector jj_expentries = new java.util.Vector();\n+  private java.util.List jj_expentries = new java.util.ArrayList();\n   private int[] jj_expentry;\n   private int jj_kind = -1;\n   private int[] jj_lasttokens = new int[100];\n       for (int i = 0; i < jj_endpos; i++) {\n         jj_expentry[i] = jj_lasttokens[i];\n       }\n-      boolean exists = false;\n-      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {\n-        int[] oldentry = (int[])(e.nextElement());\n+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {\n+        int[] oldentry = (int[])(it.next());\n         if (oldentry.length == jj_expentry.length) {\n-          exists = true;\n           for (int i = 0; i < jj_expentry.length; i++) {\n             if (oldentry[i] != jj_expentry[i]) {\n-              exists = false;\n-              break;\n+              continue jj_entries_loop;\n             }\n           }\n-          if (exists) break;\n+          jj_expentries.add(jj_expentry);\n+          break jj_entries_loop;\n         }\n       }\n-      if (!exists) jj_expentries.addElement(jj_expentry);\n       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n     }\n   }\n \n+  /** Generate ParseException. */\n   public ParseException generateParseException() {\n-    jj_expentries.removeAllElements();\n-    boolean[] la1tokens = new boolean[33];\n-    for (int i = 0; i < 33; i++) {\n-      la1tokens[i] = false;\n-    }\n+    jj_expentries.clear();\n+    boolean[] la1tokens = new boolean[34];\n     if (jj_kind >= 0) {\n       la1tokens[jj_kind] = true;\n       jj_kind = -1;\n     }\n-    for (int i = 0; i < 15; i++) {\n+    for (int i = 0; i < 16; i++) {\n       if (jj_la1[i] == jj_gen) {\n         for (int j = 0; j < 32; j++) {\n           if ((jj_la1_0[i] & (1<<j)) != 0) {\n         }\n       }\n     }\n-    for (int i = 0; i < 33; i++) {\n+    for (int i = 0; i < 34; i++) {\n       if (la1tokens[i]) {\n         jj_expentry = new int[1];\n         jj_expentry[0] = i;\n-        jj_expentries.addElement(jj_expentry);\n+        jj_expentries.add(jj_expentry);\n       }\n     }\n     jj_endpos = 0;\n     jj_add_error_token(0, 0);\n     int[][] exptokseq = new int[jj_expentries.size()][];\n     for (int i = 0; i < jj_expentries.size(); i++) {\n-      exptokseq[i] = (int[])jj_expentries.elementAt(i);\n+      exptokseq[i] = (int[])jj_expentries.get(i);\n     }\n     return new ParseException(token, exptokseq, tokenImage);\n   }\n \n+  /** Enable tracing. */\n   final public void enable_tracing() {\n   }\n \n+  /** Disable tracing. */\n   final public void disable_tracing() {\n   }\n \n-  final private void jj_rescan_token() {\n+  private void jj_rescan_token() {\n     jj_rescan = true;\n     for (int i = 0; i < 1; i++) {\n     try {\n     jj_rescan = false;\n   }\n \n-  final private void jj_save(int index, int xla) {\n+  private void jj_save(int index, int xla) {\n     JJCalls p = jj_2_rtns[index];\n     while (p.gen > jj_gen) {\n       if (p.next == null) { p = p.next = new JJCalls(); break; }\n--- a/gson/src/main/java/com/google/gson/JsonParserImplConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImplConstants.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserImplConstants.java */\n package com.google.gson;\n \n+\n+/**\n+ * Token literal values and constants.\n+ * Generated by org.javacc.parser.OtherFilesGen#start()\n+ */\n @SuppressWarnings(\"all\")\n interface JsonParserImplConstants {\n \n+  /** End of File. */\n   int EOF = 0;\n-  int E = 5;\n+  /** RegularExpression Id. */\n+  int EXPONENT = 5;\n+  /** RegularExpression Id. */\n   int DIGITS = 6;\n+  /** RegularExpression Id. */\n   int NULL = 7;\n+  /** RegularExpression Id. */\n   int NAN = 8;\n+  /** RegularExpression Id. */\n   int INFINITY = 9;\n+  /** RegularExpression Id. */\n   int BOOLEAN = 10;\n-  int IDENTIFIER = 11;\n-  int HEX_CHAR = 12;\n-  int UNICODE_CHAR = 13;\n-  int ESCAPE_CHAR = 14;\n-  int SINGLE_QUOTE_LITERAL = 15;\n-  int DOUBLE_QUOTE_LITERAL = 16;\n-  int QUOTE = 17;\n-  int ENDQUOTE = 19;\n-  int CHAR = 20;\n-  int CNTRL_ESC = 21;\n-  int HEX = 23;\n-  int HEX_ESC = 24;\n+  /** RegularExpression Id. */\n+  int IDENTIFIER_SANS_EXPONENT = 11;\n+  /** RegularExpression Id. */\n+  int IDENTIFIER_STARTS_WITH_EXPONENT = 12;\n+  /** RegularExpression Id. */\n+  int HEX_CHAR = 13;\n+  /** RegularExpression Id. */\n+  int UNICODE_CHAR = 14;\n+  /** RegularExpression Id. */\n+  int ESCAPE_CHAR = 15;\n+  /** RegularExpression Id. */\n+  int SINGLE_QUOTE_LITERAL = 16;\n+  /** RegularExpression Id. */\n+  int DOUBLE_QUOTE_LITERAL = 17;\n+  /** RegularExpression Id. */\n+  int QUOTE = 18;\n+  /** RegularExpression Id. */\n+  int ENDQUOTE = 20;\n+  /** RegularExpression Id. */\n+  int CHAR = 21;\n+  /** RegularExpression Id. */\n+  int CNTRL_ESC = 22;\n+  /** RegularExpression Id. */\n+  int HEX = 24;\n+  /** RegularExpression Id. */\n+  int HEX_ESC = 25;\n \n+  /** Lexical state. */\n   int DEFAULT = 0;\n+  /** Lexical state. */\n   int STRING_STATE = 1;\n+  /** Lexical state. */\n   int ESC_STATE = 2;\n+  /** Lexical state. */\n   int HEX_STATE = 3;\n \n+  /** Literal token values. */\n   String[] tokenImage = {\n     \"<EOF>\",\n     \"\\\" \\\"\",\n     \"\\\"\\\\t\\\"\",\n     \"\\\"\\\\n\\\"\",\n     \"\\\"\\\\r\\\"\",\n-    \"<E>\",\n+    \"<EXPONENT>\",\n     \"<DIGITS>\",\n     \"\\\"null\\\"\",\n     \"\\\"NaN\\\"\",\n     \"\\\"Infinity\\\"\",\n     \"<BOOLEAN>\",\n-    \"<IDENTIFIER>\",\n+    \"<IDENTIFIER_SANS_EXPONENT>\",\n+    \"<IDENTIFIER_STARTS_WITH_EXPONENT>\",\n     \"<HEX_CHAR>\",\n     \"<UNICODE_CHAR>\",\n     \"<ESCAPE_CHAR>\",\n--- a/gson/src/main/java/com/google/gson/JsonParserImplTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserImplTokenManager.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserImplTokenManager.java */\n package com.google.gson;\n \n+/** Token Manager. */\n @SuppressWarnings(\"all\")\n final class JsonParserImplTokenManager implements JsonParserImplConstants\n {\n+\n+  /** Debug output. */\n   public  java.io.PrintStream debugStream = System.out;\n+  /** Set debug output. */\n   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\n-private final int jjMoveStringLiteralDfa0_3()\n+private int jjMoveStringLiteralDfa0_3()\n {\n    return jjMoveNfa_3(0, 0);\n }\n-private final void jjCheckNAdd(int state)\n-{\n-   if (jjrounds[state] != jjround)\n-   {\n-      jjstateSet[jjnewStateCnt++] = state;\n-      jjrounds[state] = jjround;\n-   }\n-}\n-private final void jjAddStates(int start, int end)\n-{\n-   do {\n-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n-   } while (start++ != end);\n-}\n-private final void jjCheckNAddTwoStates(int state1, int state2)\n-{\n-   jjCheckNAdd(state1);\n-   jjCheckNAdd(state2);\n-}\n-private final void jjCheckNAddStates(int start, int end)\n-{\n-   do {\n-      jjCheckNAdd(jjnextStates[start]);\n-   } while (start++ != end);\n-}\n-private final void jjCheckNAddStates(int start)\n-{\n-   jjCheckNAdd(jjnextStates[start]);\n-   jjCheckNAdd(jjnextStates[start + 1]);\n-}\n-private final int jjMoveNfa_3(int startState, int curPos)\n-{\n-   int[] nextStates;\n+private int jjMoveNfa_3(int startState, int curPos)\n+{\n    int startsAt = 0;\n    jjnewStateCnt = 4;\n    int i = 1;\n    jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n+   int kind = 0x7fffffff;\n    for (;;)\n    {\n       if (++jjround == 0x7fffffff)\n       if (curChar < 64)\n       {\n          long l = 1L << curChar;\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                      jjstateSet[jjnewStateCnt++] = 3;\n                   break;\n                case 3:\n-                  if ((0x3ff000000000000L & l) != 0L && kind > 24)\n-                     kind = 24;\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 25)\n+                     kind = 25;\n                   break;\n                default : break;\n             }\n       else if (curChar < 128)\n       {\n          long l = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                      jjstateSet[jjnewStateCnt++] = 3;\n                   break;\n                case 3:\n-                  if ((0x7e0000007eL & l) != 0L && kind > 24)\n-                     kind = 24;\n+                  if ((0x7e0000007eL & l) != 0L && kind > 25)\n+                     kind = 25;\n                   break;\n                default : break;\n             }\n          long l1 = 1L << (hiByte & 077);\n          int i2 = (curChar & 0xff) >> 6;\n          long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n          if ((active0 & 0x380L) != 0L)\n          {\n             jjmatchedKind = 11;\n-            return 12;\n+            return 10;\n          }\n-         if ((active0 & 0x20000L) != 0L)\n-            return 41;\n+         if ((active0 & 0x40000L) != 0L)\n+            return 43;\n          return -1;\n       case 1:\n          if ((active0 & 0x380L) != 0L)\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 1;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       case 2:\n          if ((active0 & 0x100L) != 0L)\n-            return 12;\n+            return 10;\n          if ((active0 & 0x280L) != 0L)\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 2;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       case 3:\n          if ((active0 & 0x80L) != 0L)\n-            return 12;\n+            return 10;\n          if ((active0 & 0x200L) != 0L)\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 3;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       case 4:\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 4;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       case 5:\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 5;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       case 6:\n          {\n             jjmatchedKind = 11;\n             jjmatchedPos = 6;\n-            return 12;\n+            return 10;\n          }\n          return -1;\n       default :\n {\n    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);\n }\n-private final int jjStopAtPos(int pos, int kind)\n+private int jjStopAtPos(int pos, int kind)\n {\n    jjmatchedKind = kind;\n    jjmatchedPos = pos;\n    return pos + 1;\n }\n-private final int jjStartNfaWithStates_0(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_0(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_0()\n+private int jjMoveStringLiteralDfa0_0()\n {\n    switch(curChar)\n    {\n       case 34:\n-         return jjStartNfaWithStates_0(0, 17, 41);\n+         return jjStartNfaWithStates_0(0, 18, 43);\n       case 44:\n-         return jjStopAtPos(0, 27);\n+         return jjStopAtPos(0, 28);\n       case 45:\n-         return jjStopAtPos(0, 31);\n+         return jjStopAtPos(0, 32);\n       case 46:\n-         return jjStopAtPos(0, 32);\n+         return jjStopAtPos(0, 33);\n       case 58:\n-         return jjStopAtPos(0, 28);\n+         return jjStopAtPos(0, 29);\n       case 73:\n          return jjMoveStringLiteralDfa1_0(0x200L);\n       case 78:\n          return jjMoveStringLiteralDfa1_0(0x100L);\n       case 91:\n-         return jjStopAtPos(0, 29);\n+         return jjStopAtPos(0, 30);\n       case 93:\n-         return jjStopAtPos(0, 30);\n+         return jjStopAtPos(0, 31);\n       case 110:\n          return jjMoveStringLiteralDfa1_0(0x80L);\n       case 123:\n-         return jjStopAtPos(0, 25);\n+         return jjStopAtPos(0, 26);\n       case 125:\n-         return jjStopAtPos(0, 26);\n-      default :\n-         return jjMoveNfa_0(0, 0);\n-   }\n-}\n-private final int jjMoveStringLiteralDfa1_0(long active0)\n+         return jjStopAtPos(0, 27);\n+      default :\n+         return jjMoveNfa_0(4, 0);\n+   }\n+}\n+private int jjMoveStringLiteralDfa1_0(long active0)\n {\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n    }\n    return jjStartNfa_0(0, active0);\n }\n-private final int jjMoveStringLiteralDfa2_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa2_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(0, old0); \n+      return jjStartNfa_0(0, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(1, active0);\n    {\n       case 78:\n          if ((active0 & 0x100L) != 0L)\n-            return jjStartNfaWithStates_0(2, 8, 12);\n+            return jjStartNfaWithStates_0(2, 8, 10);\n          break;\n       case 102:\n          return jjMoveStringLiteralDfa3_0(active0, 0x200L);\n    }\n    return jjStartNfa_0(1, active0);\n }\n-private final int jjMoveStringLiteralDfa3_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa3_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(1, old0); \n+      return jjStartNfa_0(1, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(2, active0);\n          return jjMoveStringLiteralDfa4_0(active0, 0x200L);\n       case 108:\n          if ((active0 & 0x80L) != 0L)\n-            return jjStartNfaWithStates_0(3, 7, 12);\n+            return jjStartNfaWithStates_0(3, 7, 10);\n          break;\n       default :\n          break;\n    }\n    return jjStartNfa_0(2, active0);\n }\n-private final int jjMoveStringLiteralDfa4_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa4_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(2, old0); \n+      return jjStartNfa_0(2, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(3, active0);\n    }\n    return jjStartNfa_0(3, active0);\n }\n-private final int jjMoveStringLiteralDfa5_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa5_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(3, old0); \n+      return jjStartNfa_0(3, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(4, active0);\n    }\n    return jjStartNfa_0(4, active0);\n }\n-private final int jjMoveStringLiteralDfa6_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa6_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(4, old0); \n+      return jjStartNfa_0(4, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(5, active0);\n    }\n    return jjStartNfa_0(5, active0);\n }\n-private final int jjMoveStringLiteralDfa7_0(long old0, long active0)\n+private int jjMoveStringLiteralDfa7_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(5, old0); \n+      return jjStartNfa_0(5, old0);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(6, active0);\n    {\n       case 121:\n          if ((active0 & 0x200L) != 0L)\n-            return jjStartNfaWithStates_0(7, 9, 12);\n+            return jjStartNfaWithStates_0(7, 9, 10);\n          break;\n       default :\n          break;\n    }\n    return jjStartNfa_0(6, active0);\n+}\n+private int jjStartNfaWithStates_0(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_0(state, pos + 1);\n }\n static final long[] jjbitVec0 = {\n    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n static final long[] jjbitVec2 = {\n    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n };\n-private final int jjMoveNfa_0(int startState, int curPos)\n-{\n-   int[] nextStates;\n+private int jjMoveNfa_0(int startState, int curPos)\n+{\n    int startsAt = 0;\n-   jjnewStateCnt = 41;\n+   jjnewStateCnt = 43;\n    int i = 1;\n    jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n+   int kind = 0x7fffffff;\n    for (;;)\n    {\n       if (++jjround == 0x7fffffff)\n       if (curChar < 64)\n       {\n          long l = 1L << curChar;\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n-               case 41:\n+               case 43:\n                   if ((0xfffffffbffffdbffL & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   else if (curChar == 34)\n                   {\n-                     if (kind > 16)\n-                        kind = 16;\n+                     if (kind > 17)\n+                        kind = 17;\n                   }\n                   break;\n-               case 0:\n+               case 4:\n                   if ((0x3ff000000000000L & l) != 0L)\n                   {\n                      if (kind > 6)\n                         kind = 6;\n-                     jjCheckNAdd(2);\n+                     jjCheckNAdd(0);\n                   }\n                   else if (curChar == 34)\n                      jjCheckNAddStates(0, 3);\n                   else if (curChar == 39)\n                      jjCheckNAddStates(4, 7);\n                   break;\n-               case 1:\n-                  if ((0x280000000000L & l) != 0L && kind > 5)\n-                     kind = 5;\n-                  break;\n-               case 2:\n+               case 0:\n                   if ((0x3ff000000000000L & l) == 0L)\n                      break;\n                   if (kind > 6)\n                      kind = 6;\n-                  jjCheckNAdd(2);\n-                  break;\n-               case 12:\n+                  jjCheckNAdd(0);\n+                  break;\n+               case 10:\n                   if ((0x3ff000000000000L & l) == 0L)\n                      break;\n                   if (kind > 11)\n                      kind = 11;\n-                  jjstateSet[jjnewStateCnt++] = 12;\n+                  jjstateSet[jjnewStateCnt++] = 10;\n+                  break;\n+               case 12:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n+                  break;\n+               case 13:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 14;\n                   break;\n                case 14:\n                   if ((0x3ff000000000000L & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 15;\n                   break;\n                case 15:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 16;\n-                  break;\n-               case 16:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 17;\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 14)\n+                     kind = 14;\n                   break;\n                case 17:\n-                  if ((0x3ff000000000000L & l) != 0L && kind > 13)\n-                     kind = 13;\n-                  break;\n-               case 19:\n                   if (curChar == 39)\n                      jjCheckNAddStates(4, 7);\n                   break;\n-               case 20:\n+               case 18:\n                   if ((0xffffff7fffffdbffL & l) != 0L)\n                      jjCheckNAddStates(4, 7);\n                   break;\n-               case 22:\n+               case 20:\n                   if ((0x808400000000L & l) != 0L)\n                      jjCheckNAddStates(4, 7);\n                   break;\n+               case 22:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 23;\n+                  break;\n+               case 23:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 24;\n+                  break;\n                case 24:\n                   if ((0x3ff000000000000L & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 25;\n                   break;\n                case 25:\n                   if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 26;\n-                  break;\n-               case 26:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 27;\n+                     jjCheckNAddStates(4, 7);\n                   break;\n                case 27:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 29:\n-                  if (curChar == 39 && kind > 15)\n-                     kind = 15;\n-                  break;\n-               case 30:\n+                  if (curChar == 39 && kind > 16)\n+                     kind = 16;\n+                  break;\n+               case 28:\n                   if (curChar == 34)\n                      jjCheckNAddStates(0, 3);\n                   break;\n-               case 31:\n+               case 29:\n                   if ((0xfffffffbffffdbffL & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   break;\n-               case 33:\n+               case 31:\n                   if ((0x808400000000L & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   break;\n+               case 33:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  break;\n+               case 34:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 35;\n+                  break;\n                case 35:\n                   if ((0x3ff000000000000L & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 36;\n                   break;\n                case 36:\n                   if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 37;\n-                  break;\n-               case 37:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 38;\n+                     jjCheckNAddStates(0, 3);\n                   break;\n                case 38:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n+                  if (curChar == 34 && kind > 17)\n+                     kind = 17;\n                   break;\n                case 40:\n-                  if (curChar == 34 && kind > 16)\n-                     kind = 16;\n+                  if ((0x3ff280000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 5)\n+                     kind = 5;\n+                  jjCheckNAdd(41);\n+                  break;\n+               case 41:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 5)\n+                     kind = 5;\n+                  jjCheckNAdd(41);\n+                  break;\n+               case 42:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjstateSet[jjnewStateCnt++] = 42;\n                   break;\n                default : break;\n             }\n       else if (curChar < 128)\n       {\n          long l = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n-               case 41:\n+               case 43:\n                   if ((0xffffffffefffffffL & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   else if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 34;\n+                     jjstateSet[jjnewStateCnt++] = 32;\n                   if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 33;\n-                  break;\n-               case 0:\n-                  if ((0x7fffffe87fffffeL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 31;\n+                  break;\n+               case 4:\n+                  if ((0x7ffffde87ffffdeL & l) != 0L)\n                   {\n                      if (kind > 11)\n                         kind = 11;\n-                     jjCheckNAdd(12);\n+                     jjCheckNAdd(10);\n+                  }\n+                  else if ((0x2000000020L & l) != 0L)\n+                  {\n+                     if (kind > 12)\n+                        kind = 12;\n+                     jjCheckNAddTwoStates(40, 42);\n                   }\n                   else if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 13;\n-                  if ((0x2000000020L & l) != 0L)\n-                  {\n-                     if (kind > 5)\n-                        kind = 5;\n-                     jjstateSet[jjnewStateCnt++] = 1;\n-                  }\n-                  else if (curChar == 102)\n-                     jjstateSet[jjnewStateCnt++] = 9;\n+                     jjstateSet[jjnewStateCnt++] = 11;\n+                  if (curChar == 102)\n+                     jjstateSet[jjnewStateCnt++] = 7;\n                   else if (curChar == 116)\n-                     jjstateSet[jjnewStateCnt++] = 5;\n-                  break;\n-               case 3:\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 1:\n                   if (curChar == 101 && kind > 10)\n                      kind = 10;\n                   break;\n-               case 4:\n+               case 2:\n                   if (curChar == 117)\n-                     jjCheckNAdd(3);\n+                     jjCheckNAdd(1);\n+                  break;\n+               case 3:\n+                  if (curChar == 114)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n                   break;\n                case 5:\n-                  if (curChar == 114)\n-                     jjstateSet[jjnewStateCnt++] = 4;\n+                  if (curChar == 115)\n+                     jjCheckNAdd(1);\n                   break;\n                case 6:\n-                  if (curChar == 116)\n+                  if (curChar == 108)\n                      jjstateSet[jjnewStateCnt++] = 5;\n                   break;\n                case 7:\n-                  if (curChar == 115)\n-                     jjCheckNAdd(3);\n+                  if (curChar == 97)\n+                     jjstateSet[jjnewStateCnt++] = 6;\n                   break;\n                case 8:\n-                  if (curChar == 108)\n+                  if (curChar == 102)\n                      jjstateSet[jjnewStateCnt++] = 7;\n                   break;\n                case 9:\n-                  if (curChar == 97)\n-                     jjstateSet[jjnewStateCnt++] = 8;\n+                  if ((0x7ffffde87ffffdeL & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjCheckNAdd(10);\n                   break;\n                case 10:\n-                  if (curChar == 102)\n-                     jjstateSet[jjnewStateCnt++] = 9;\n-                  break;\n-               case 11:\n-               case 12:\n                   if ((0x7fffffe87fffffeL & l) == 0L)\n                      break;\n                   if (kind > 11)\n                      kind = 11;\n-                  jjCheckNAdd(12);\n+                  jjCheckNAdd(10);\n+                  break;\n+               case 11:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 12;\n+                  break;\n+               case 12:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n                   break;\n                case 13:\n-                  if (curChar == 117)\n+                  if ((0x7e0000007eL & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 14;\n                   break;\n                case 14:\n                      jjstateSet[jjnewStateCnt++] = 15;\n                   break;\n                case 15:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 16;\n+                  if ((0x7e0000007eL & l) != 0L && kind > 14)\n+                     kind = 14;\n                   break;\n                case 16:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 17;\n-                  break;\n-               case 17:\n-                  if ((0x7e0000007eL & l) != 0L && kind > 13)\n-                     kind = 13;\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 11;\n                   break;\n                case 18:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 13;\n-                  break;\n-               case 20:\n                   if ((0xffffffffefffffffL & l) != 0L)\n                      jjCheckNAddStates(4, 7);\n                   break;\n-               case 21:\n+               case 19:\n                   if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 22;\n-                  break;\n-               case 22:\n+                     jjstateSet[jjnewStateCnt++] = 20;\n+                  break;\n+               case 20:\n                   if ((0x14404410000000L & l) != 0L)\n                      jjCheckNAddStates(4, 7);\n                   break;\n+               case 21:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 22;\n+                  break;\n+               case 22:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 23;\n+                  break;\n                case 23:\n-                  if (curChar == 117)\n+                  if ((0x7e0000007eL & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 24;\n                   break;\n                case 24:\n                   break;\n                case 25:\n                   if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 26;\n+                     jjCheckNAddStates(4, 7);\n                   break;\n                case 26:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 27;\n-                  break;\n-               case 27:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 28:\n                   if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 23;\n-                  break;\n-               case 31:\n+                     jjstateSet[jjnewStateCnt++] = 21;\n+                  break;\n+               case 29:\n                   if ((0xffffffffefffffffL & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   break;\n-               case 32:\n+               case 30:\n                   if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 33;\n-                  break;\n-               case 33:\n+                     jjstateSet[jjnewStateCnt++] = 31;\n+                  break;\n+               case 31:\n                   if ((0x14404410000000L & l) != 0L)\n                      jjCheckNAddStates(0, 3);\n                   break;\n+               case 32:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 33;\n+                  break;\n+               case 33:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  break;\n                case 34:\n-                  if (curChar == 117)\n+                  if ((0x7e0000007eL & l) != 0L)\n                      jjstateSet[jjnewStateCnt++] = 35;\n                   break;\n                case 35:\n                   break;\n                case 36:\n                   if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 37;\n+                     jjCheckNAddStates(0, 3);\n                   break;\n                case 37:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 38;\n-                  break;\n-               case 38:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 32;\n                   break;\n                case 39:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 34;\n+                  if ((0x2000000020L & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjCheckNAddTwoStates(40, 42);\n+                  break;\n+               case 42:\n+                  if ((0x7fffffe87fffffeL & l) == 0L)\n+                     break;\n+                  if (kind > 12)\n+                     kind = 12;\n+                  jjCheckNAdd(42);\n                   break;\n                default : break;\n             }\n          long l1 = 1L << (hiByte & 077);\n          int i2 = (curChar & 0xff) >> 6;\n          long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n-               case 41:\n-               case 31:\n+               case 43:\n+               case 29:\n                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                      jjCheckNAddStates(0, 3);\n                   break;\n-               case 20:\n+               case 18:\n                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                      jjAddStates(4, 7);\n                   break;\n          kind = 0x7fffffff;\n       }\n       ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 41 - (jjnewStateCnt = startsAt)))\n+      if ((i = jjnewStateCnt) == (startsAt = 43 - (jjnewStateCnt = startsAt)))\n          return curPos;\n       try { curChar = input_stream.readChar(); }\n       catch(java.io.IOException e) { return curPos; }\n {\n    return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);\n }\n-private final int jjStartNfaWithStates_2(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_2(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_2()\n+private int jjMoveStringLiteralDfa0_2()\n {\n    switch(curChar)\n    {\n       case 117:\n-         return jjStopAtPos(0, 22);\n+         return jjStopAtPos(0, 23);\n       default :\n          return jjMoveNfa_2(0, 0);\n    }\n }\n-private final int jjMoveNfa_2(int startState, int curPos)\n-{\n-   int[] nextStates;\n+private int jjMoveNfa_2(int startState, int curPos)\n+{\n    int startsAt = 0;\n    jjnewStateCnt = 1;\n    int i = 1;\n    jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n+   int kind = 0x7fffffff;\n    for (;;)\n    {\n       if (++jjround == 0x7fffffff)\n       if (curChar < 64)\n       {\n          long l = 1L << curChar;\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                case 0:\n                   if ((0x800400000000L & l) != 0L)\n-                     kind = 21;\n+                     kind = 22;\n                   break;\n                default : break;\n             }\n       else if (curChar < 128)\n       {\n          long l = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                case 0:\n                   if ((0x14404410000000L & l) != 0L)\n-                     kind = 21;\n+                     kind = 22;\n                   break;\n                default : break;\n             }\n          long l1 = 1L << (hiByte & 077);\n          int i2 = (curChar & 0xff) >> 6;\n          long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n {\n    return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);\n }\n-private final int jjStartNfaWithStates_1(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_1(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_1()\n+private int jjMoveStringLiteralDfa0_1()\n {\n    switch(curChar)\n    {\n       case 92:\n-         return jjStopAtPos(0, 18);\n+         return jjStopAtPos(0, 19);\n       default :\n          return jjMoveNfa_1(0, 0);\n    }\n }\n-private final int jjMoveNfa_1(int startState, int curPos)\n-{\n-   int[] nextStates;\n+private int jjMoveNfa_1(int startState, int curPos)\n+{\n    int startsAt = 0;\n    jjnewStateCnt = 2;\n    int i = 1;\n    jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n+   int kind = 0x7fffffff;\n    for (;;)\n    {\n       if (++jjround == 0x7fffffff)\n       if (curChar < 64)\n       {\n          long l = 1L << curChar;\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                case 0:\n                   if ((0xfffffffbffffffffL & l) != 0L)\n                   {\n+                     if (kind > 21)\n+                        kind = 21;\n+                  }\n+                  else if (curChar == 34)\n+                  {\n                      if (kind > 20)\n                         kind = 20;\n                   }\n-                  else if (curChar == 34)\n-                  {\n-                     if (kind > 19)\n-                        kind = 19;\n-                  }\n                   break;\n                case 1:\n                   if ((0xfffffffbffffffffL & l) != 0L)\n-                     kind = 20;\n+                     kind = 21;\n                   break;\n                default : break;\n             }\n       else if (curChar < 128)\n       {\n          long l = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                case 0:\n                   if ((0xffffffffefffffffL & l) != 0L)\n-                     kind = 20;\n+                     kind = 21;\n                   break;\n                default : break;\n             }\n          long l1 = 1L << (hiByte & 077);\n          int i2 = (curChar & 0xff) >> 6;\n          long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n+         do\n          {\n             switch(jjstateSet[--i])\n             {\n                case 0:\n-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 20)\n-                     kind = 20;\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 21)\n+                     kind = 21;\n                   break;\n                default : break;\n             }\n    }\n }\n static final int[] jjnextStates = {\n-   31, 32, 39, 40, 20, 21, 28, 29, \n+   29, 30, 37, 38, 18, 19, 26, 27, \n };\n private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n {\n    {\n       case 0:\n          return ((jjbitVec2[i2] & l2) != 0L);\n-      default : \n+      default :\n          if ((jjbitVec0[i1] & l1) != 0L)\n             return true;\n          return false;\n    }\n }\n+\n+/** Token literal values. */\n public static final String[] jjstrLiteralImages = {\n \"\", null, null, null, null, null, null, \"\\156\\165\\154\\154\", \"\\116\\141\\116\", \n-\"\\111\\156\\146\\151\\156\\151\\164\\171\", null, null, null, null, null, null, null, \"\\42\", null, null, null, null, null, \n-null, null, \"\\173\", \"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n+\"\\111\\156\\146\\151\\156\\151\\164\\171\", null, null, null, null, null, null, null, null, \"\\42\", null, null, null, null, \n+null, null, null, \"\\173\", \"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n+\n+/** Lexer state names. */\n public static final String[] lexStateNames = {\n-   \"DEFAULT\", \n-   \"STRING_STATE\", \n-   \"ESC_STATE\", \n-   \"HEX_STATE\", \n+   \"DEFAULT\",\n+   \"STRING_STATE\",\n+   \"ESC_STATE\",\n+   \"HEX_STATE\",\n };\n+\n+/** Lex State array. */\n public static final int[] jjnewLexState = {\n-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, \n-   -1, -1, -1, -1, -1, -1, -1, -1, \n+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, \n+   1, -1, -1, -1, -1, -1, -1, -1, -1, \n };\n static final long[] jjtoToken = {\n-   0x1ff3bafe1L, \n+   0x3fe775fe1L, \n };\n static final long[] jjtoSkip = {\n    0x1eL, \n };\n static final long[] jjtoMore = {\n-   0x440000L, \n+   0x880000L, \n };\n protected SimpleCharStream input_stream;\n-private final int[] jjrounds = new int[41];\n-private final int[] jjstateSet = new int[82];\n+private final int[] jjrounds = new int[43];\n+private final int[] jjstateSet = new int[86];\n protected char curChar;\n+/** Constructor. */\n public JsonParserImplTokenManager(SimpleCharStream stream){\n    if (SimpleCharStream.staticFlag)\n       throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n    input_stream = stream;\n }\n+\n+/** Constructor. */\n public JsonParserImplTokenManager(SimpleCharStream stream, int lexState){\n    this(stream);\n    SwitchTo(lexState);\n }\n+\n+/** Reinitialise parser. */\n public void ReInit(SimpleCharStream stream)\n {\n    jjmatchedPos = jjnewStateCnt = 0;\n    input_stream = stream;\n    ReInitRounds();\n }\n-private final void ReInitRounds()\n+private void ReInitRounds()\n {\n    int i;\n    jjround = 0x80000001;\n-   for (i = 41; i-- > 0;)\n+   for (i = 43; i-- > 0;)\n       jjrounds[i] = 0x80000000;\n }\n+\n+/** Reinitialise parser. */\n public void ReInit(SimpleCharStream stream, int lexState)\n {\n    ReInit(stream);\n    SwitchTo(lexState);\n }\n+\n+/** Switch to specified lex state. */\n public void SwitchTo(int lexState)\n {\n    if (lexState >= 4 || lexState < 0)\n \n protected Token jjFillToken()\n {\n-   Token t = Token.newToken(jjmatchedKind);\n+   final Token t;\n+   final String curTokenImage;\n+   final int beginLine;\n+   final int endLine;\n+   final int beginColumn;\n+   final int endColumn;\n+   String im = jjstrLiteralImages[jjmatchedKind];\n+   curTokenImage = (im == null) ? input_stream.GetImage() : im;\n+   beginLine = input_stream.getBeginLine();\n+   beginColumn = input_stream.getBeginColumn();\n+   endLine = input_stream.getEndLine();\n+   endColumn = input_stream.getEndColumn();\n+   t = Token.newToken(jjmatchedKind);\n    t.kind = jjmatchedKind;\n-   String im = jjstrLiteralImages[jjmatchedKind];\n-   t.image = (im == null) ? input_stream.GetImage() : im;\n-   t.beginLine = input_stream.getBeginLine();\n-   t.beginColumn = input_stream.getBeginColumn();\n-   t.endLine = input_stream.getEndLine();\n-   t.endColumn = input_stream.getEndColumn();\n+   t.image = curTokenImage;\n+\n+   t.beginLine = beginLine;\n+   t.endLine = endLine;\n+   t.beginColumn = beginColumn;\n+   t.endColumn = endColumn;\n+\n    return t;\n }\n \n int jjmatchedPos;\n int jjmatchedKind;\n \n+/** Get the next Token. */\n public Token getNextToken() \n {\n-  int kind;\n-  Token specialToken = null;\n   Token matchedToken;\n   int curPos = 0;\n \n   EOFLoop :\n   for (;;)\n-  {   \n-   try   \n-   {     \n+  {\n+   try\n+   {\n       curChar = input_stream.BeginToken();\n-   }     \n+   }\n    catch(java.io.IOException e)\n-   {        \n+   {\n       jjmatchedKind = 0;\n       matchedToken = jjFillToken();\n       return matchedToken;\n   }\n }\n \n-}\n+private void jjCheckNAdd(int state)\n+{\n+   if (jjrounds[state] != jjround)\n+   {\n+      jjstateSet[jjnewStateCnt++] = state;\n+      jjrounds[state] = jjround;\n+   }\n+}\n+private void jjAddStates(int start, int end)\n+{\n+   do {\n+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n+   } while (start++ != end);\n+}\n+private void jjCheckNAddTwoStates(int state1, int state2)\n+{\n+   jjCheckNAdd(state1);\n+   jjCheckNAdd(state2);\n+}\n+\n+private void jjCheckNAddStates(int start, int end)\n+{\n+   do {\n+      jjCheckNAdd(jjnextStates[start]);\n+   } while (start++ != end);\n+}\n+\n+}\n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n     assertEquals(expected.doubleValue(), actual1);\n   }\n \n+  public void testLargeDoubleDeserialization() {\n+    String doubleValue = \"1.234567899E8\";\n+    Double expected = Double.valueOf(doubleValue);\n+    Double actual = gson.fromJson(doubleValue, Double.class);\n+    assertEquals(expected, actual);\n+\n+    double actual1 = gson.fromJson(doubleValue, double.class);\n+    assertEquals(expected.doubleValue(), actual1);\n+  }\n+\n   public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() {\n     double expected = -122.08;\n     double actual = gson.fromJson(\"[-122.08]\", double.class);", "timestamp": 1236294329, "metainfo": ""}