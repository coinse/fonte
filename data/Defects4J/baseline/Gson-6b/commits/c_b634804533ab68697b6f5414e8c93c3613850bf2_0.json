{"sha": "b634804533ab68697b6f5414e8c93c3613850bf2", "log": "Ensured that a base class custom serializer is run when the type is specified explicitly during serialization. For all other situations, ensured that the actual type of the object is taken into consideration while serializing. First a custom handler corresponding to the actual type is looked up, then a custom handler for the specified type.  Created some serialization specific tests regarding custom serializers. Revised some tests to use toJsonTree for better asserts instead of string matching.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     if (src == null) {\n       return JsonNull.createJsonNull();\n     }\n-    return toJsonTree(src, src.getClass());\n+    return toJsonTree(src, src.getClass(), false);\n   }\n \n   /**\n    * @since 1.4\n    */\n   public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n+    return toJsonTree(src, typeOfSrc, true);\n+  }\n+\n+  private JsonElement toJsonTree(Object src, Type typeOfSrc, boolean preserveType) {\n     if (src == null) {\n       return JsonNull.createJsonNull();\n     }\n-    JsonSerializationContext context = new JsonSerializationContextDefault(\n+    JsonSerializationContextDefault context = new JsonSerializationContextDefault(\n         createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\n-    return context.serialize(src, typeOfSrc);\n+    return context.serialize(src, typeOfSrc, preserveType);\n   }\n \n   /**\n     if (src == null) {\n       return serializeNulls ? NULL_STRING : \"\";\n     }\n-    return toJson(src, src.getClass());\n+    return toJson(src, src.getClass(), false);\n   }\n \n   /**\n    * @return Json representation of {@code src}\n    */\n   public String toJson(Object src, Type typeOfSrc) {\n+    return toJson(src, typeOfSrc, true);\n+  }\n+\n+  private String toJson(Object src, Type typeOfSrc, boolean preserveType) {\n     StringWriter writer = new StringWriter();\n-    toJson(src, typeOfSrc, writer);\n+    toJson(src, typeOfSrc, writer, preserveType);\n     return writer.toString();\n   }\n \n   public void toJson(Object src, Appendable writer) {\n     try {\n       if (src != null) {\n-        toJson(src, src.getClass(), writer);\n+        toJson(src, src.getClass(), writer, false);\n       } else if (serializeNulls) {\n         writeOutNullString(writer);\n       }\n    * @since 1.2\n    */\n   public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n-    JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n+    toJson(src, typeOfSrc, writer, true);\n+  }\n+\n+  private void toJson(Object src, Type typeOfSrc, Appendable writer, boolean preserveType) {\n+    JsonElement jsonElement = toJsonTree(src, typeOfSrc, preserveType);\n     toJson(jsonElement, writer);\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n       JsonDeserializationContext context) throws JsonParseException {\n     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(\n         jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context);\n-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType));\n+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true));\n     on.accept(visitor);\n     return visitor.getTarget();\n   }\n       JsonDeserializationContext context) throws JsonParseException {\n     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n         jsonObject, typeOfT, navigatorFactory, objectConstructor, deserializers, context);\n-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT));\n+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT, true));\n     on.accept(visitor);\n     return visitor.getTarget();\n   }\n       JsonDeserializationContext context) throws JsonParseException {\n     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n         json, typeOfT, navigatorFactory, objectConstructor, deserializers, context);\n-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT));\n+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true));\n     on.accept(visitor);\n     Object target = visitor.getTarget();\n     return (T) target;\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n   }\n \n   private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) {\n-    ObjectNavigator on = factory.create(new ObjectTypePair(null, type));\n+    ObjectNavigator on = factory.create(new ObjectTypePair(null, type, true));\n     on.accept(childVisitor);\n     // the underlying object may have changed during the construction phase\n     // This happens primarily because of custom deserializers\n     return childVisitor.getTarget();\n   }\n+\n+  public ObjectTypePair getActualTypeIfMoreSpecific(ObjectTypePair objTypePair) {\n+    return objTypePair;\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n     if (src == null) {\n       return JsonNull.createJsonNull();\n     }\n-    return serialize(src, src.getClass());\n+    return serialize(src, src.getClass(), false);\n   }\n \n   public JsonElement serialize(Object src, Type typeOfSrc) {\n-    ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc));\n+    return serialize(src, typeOfSrc, true);\n+  }\n+\n+  public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\n+    ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType));\n     JsonSerializationVisitor visitor =\n         new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);\n     on.accept(visitor);\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n /**\n  * A visitor that adds JSON elements corresponding to each field of an object\n- *\n+ * \n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n   private JsonElement root;\n \n   JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls,\n-      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      JsonSerializationContext context, MemoryRefStack ancestors) {\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context,\n+      MemoryRefStack ancestors) {\n     this.factory = factory;\n     this.serializeNulls = serializeNulls;\n     this.serializers = serializers;\n     this.context = context;\n     this.ancestors = ancestors;\n   }\n-  \n+\n   public Object getTarget() {\n     return null;\n   }\n     for (int i = 0; i < length; ++i) {\n       Object child = Array.get(array, i);\n       Type childType = componentType;\n-      if (child != null) {\n-        childType = getActualTypeIfMoreSpecific(childType, child.getClass());\n-      }\n-      addAsArrayElement(new ObjectTypePair(child, childType));\n+      // we should not get more specific component type yet since it is possible\n+      // that a custom\n+      // serializer is registered for the componentType\n+      addAsArrayElement(new ObjectTypePair(child, childType, false));\n     }\n   }\n \n         }\n       } else {\n         Object array = getFieldValue(f, obj);\n-        addAsChildOfObject(f, new ObjectTypePair(array, typeOfF));\n+        addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false));\n       }\n     } catch (CircularReferenceException e) {\n       throw e.createDetailedException(f);\n         }\n       } else {\n         Object fieldValue = getFieldValue(f, obj);\n-        if (fieldValue != null) {\n-          typeOfF = getActualTypeIfMoreSpecific(typeOfF, fieldValue.getClass());\n-        }\n-        addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF));\n+        // we should not get more specific component type yet since it is\n+        // possible that a custom\n+        // serializer is registered for the componentType\n+        addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false));\n       }\n     } catch (CircularReferenceException e) {\n       throw e.createDetailedException(f);\n     }\n-  }\n-\n-  // This takes care of situations where the field was declared as an Object, but the\n-  // actual value contains something more specific. See Issue 54.\n-  // TODO (inder): This solution will not work if the field is of a generic type, but \n-  // the actual object is of a raw type (which is a sub-class of the generic type).\n-  private Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) {\n-    if (type instanceof Class<?>) {\n-      Class<?> typeAsClass = (Class<?>) type;\n-      if (typeAsClass.isAssignableFrom(actualClass)) {\n-        type = actualClass;\n-      }\n-      if (type == Object.class) {\n-        type = actualClass;\n-      } \n-    }\n-    return type;\n   }\n \n   public void visitPrimitive(Object obj) {\n   public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n     try {\n       Object obj = objTypePair.getObject();\n-      Type objType = objTypePair.getType();\n-      JsonSerializer serializer = serializers.getHandlerFor(objType);\n-      if (serializer == null && obj != null) {\n-        serializer = serializers.getHandlerFor(obj.getClass());\n-      }\n-\n-      if (serializer != null) {\n-        if (obj == null) {\n+      if (obj == null) {\n+        if (serializeNulls) {\n           assignToRoot(JsonNull.createJsonNull());\n-        } else {\n-          assignToRoot(invokeCustomHandler(objTypePair, serializer));\n-        }\n-        return true;\n-      }\n-      return false;\n+        }\n+        return true;\n+      }\n+      JsonElement element = findAndInvokeCustomSerializer(objTypePair);\n+      if (element != null) {\n+        assignToRoot(element);\n+        return true;\n+      } else {\n+        return false;\n+      }\n     } catch (CircularReferenceException e) {\n       throw e.createDetailedException(null);\n     }\n   }\n \n+  /**\n+   * objTypePair.getObject() must not be null\n+   */\n   @SuppressWarnings(\"unchecked\")\n-  private JsonElement invokeCustomHandler(ObjectTypePair objTypePair, JsonSerializer serializer) {\n+  private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\n+    Pair<JsonSerializer, ObjectTypePair> pair = objTypePair.getMatchingSerializer(serializers);\n+    if (pair == null) {\n+      return null;\n+    }\n+    JsonSerializer serializer = pair.getFirst();\n+    objTypePair = pair.getSecond();\n     start(objTypePair);\n     try {\n       return serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);\n   }\n \n   @SuppressWarnings(\"unchecked\")\n-  public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent) {\n+  public boolean visitFieldUsingCustomHandler(Field f, Type declaredTypeOfField, Object parent) {\n     try {\n       Preconditions.checkState(root.isJsonObject());\n       Object obj = f.get(parent);\n         }\n         return true;\n       }\n-      JsonSerializer serializer = serializers.getHandlerFor(actualTypeOfField);\n-      if (serializer != null) {\n-        ObjectTypePair objTypePair = new ObjectTypePair(obj, actualTypeOfField);\n-        JsonElement child = invokeCustomHandler(objTypePair, serializer);\n+      ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false);\n+      JsonElement child = findAndInvokeCustomSerializer(objTypePair);\n+      if (child != null) {\n         addChildAsElement(f, child);\n         return true;\n-      }\n-      return false;\n+      } else {\n+        return false;\n+      }\n     } catch (IllegalAccessException e) {\n       throw new RuntimeException();\n     } catch (CircularReferenceException e) {\n   public JsonElement getJsonElement() {\n     return root;\n   }\n+\n+  public ObjectTypePair getActualTypeIfMoreSpecific(ObjectTypePair objTypePair) {\n+    return objTypePair.toMoreSpecificType();\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n      */\n     public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent);\n \n+    public ObjectTypePair getActualTypeIfMoreSpecific(ObjectTypePair objTypePair);\n+\n     /**\n      * Retrieve the current target\n      */\n           objectToVisit = visitor.getTarget();\n         } else {\n           visitor.startVisitingObject(objectToVisit);\n-          // For all classes in the inheritance hierarchy (including the current class),\n-          // visit all fields\n-          Class<?> topLevelClass = (objTypeInfo.getRawClass() == Object.class)\n-              ? objectToVisit.getClass() : objTypeInfo.getRawClass();\n+          ObjectTypePair currObjTypePair = visitor.getActualTypeIfMoreSpecific(objTypePair);\n+          Class<?> topLevelClass = new TypeInfo(currObjTypePair.getType()).getRawClass();\n           for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class);\n               curr = curr.getSuperclass()) {\n             if (!curr.isSynthetic()) {\n         continue; // skip\n       } else {\n         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.getType());\n-        Type actualTypeOfField = fieldTypeInfo.getActualType();\n+        Type declaredTypeOfField = fieldTypeInfo.getActualType();\n         boolean visitedWithCustomHandler =\n-            visitor.visitFieldUsingCustomHandler(f, actualTypeOfField, obj);\n+            visitor.visitFieldUsingCustomHandler(f, declaredTypeOfField, obj);\n         if (!visitedWithCustomHandler) {\n           if (fieldTypeInfo.isArray()) {\n-            visitor.visitArrayField(f, actualTypeOfField, obj);\n+            visitor.visitArrayField(f, declaredTypeOfField, obj);\n           } else {\n-            visitor.visitObjectField(f, actualTypeOfField, obj);\n+            visitor.visitObjectField(f, declaredTypeOfField, obj);\n           }\n         }\n       }\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n \n   private final Object obj;\n   private final Type type;\n+  private final boolean preserveType;\n \n-  public ObjectTypePair(Object obj, Type type) {\n+  ObjectTypePair(Object obj, Type type, boolean preserveType) {\n     this.obj = obj;\n     this.type = type;\n+    this.preserveType = preserveType;\n   }\n \n-  public Object getObject() {\n+  Object getObject() {\n     return obj;\n   }\n \n-  public Type getType() {\n+  Type getType() {\n+    return type;\n+  }\n+  \n+  @SuppressWarnings(\"unchecked\")\n+  Pair<JsonSerializer, ObjectTypePair> getMatchingSerializer(\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\n+    if (obj == null) {\n+      return null;\n+    }\n+    JsonSerializer serializer = null;\n+    if (!preserveType) {\n+      // First try looking up the serializer for the actual type\n+      ObjectTypePair moreSpecificType = toMoreSpecificType();    \n+      serializer = serializers.getHandlerFor(moreSpecificType.type);\n+      if (serializer != null) {\n+        return new Pair<JsonSerializer, ObjectTypePair>(serializer, moreSpecificType);\n+      }\n+    }\n+    // Try the specified type\n+    serializer = serializers.getHandlerFor(type);\n+    return serializer == null ? null : new Pair<JsonSerializer, ObjectTypePair>(serializer, this);\n+  }\n+\n+  ObjectTypePair toMoreSpecificType() {    \n+    if (preserveType || obj == null) {\n+      return this;\n+    }\n+    Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass());\n+    if (actualType == type) {\n+      return this;\n+    }\n+    return new ObjectTypePair(obj, actualType, preserveType);\n+  }\n+\n+  // This takes care of situations where the field was declared as an Object, but the\n+  // actual value contains something more specific. See Issue 54.\n+  // TODO (inder): This solution will not work if the field is of a generic type, but \n+  // the actual object is of a raw type (which is a sub-class of the generic type).\n+  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) {\n+    if (type instanceof Class<?>) {\n+      Class<?> typeAsClass = (Class<?>) type;\n+      if (typeAsClass.isAssignableFrom(actualClass)) {\n+        type = actualClass;\n+      }\n+      if (type == Object.class) {\n+        type = actualClass;\n+      } \n+    }\n     return type;\n   }\n \n     } else if (!type.equals(other.type)) {\n       return false;\n     }\n-    return true;\n+    return preserveType == other.preserveType;\n   }\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Pair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+final class Pair<FIRST, SECOND> {\n+\n+  private final FIRST first;\n+  private final SECOND second;\n+\n+  Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  public FIRST getFirst() {\n+    return first;\n+  }\n+\n+  public SECOND getSecond() {\n+    return second;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n+++ b/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n   }\n \n   public void testPushPeekAndPop() throws Exception {\n-    ObjectTypePair obj = new ObjectTypePair(this, getClass());\n+    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true);\n \n     assertEquals(obj, stack.push(obj));\n     assertEquals(obj, stack.peek());\n   }\n \n   public void testPopTooMany() throws Exception {\n-    ObjectTypePair obj = new ObjectTypePair(this, getClass());\n+    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true);\n     stack.push(obj);\n     assertEquals(obj, stack.pop());\n \n     MockObject objA = new MockObject();\n     MockObject objB = new MockObject();\n     assertEquals(objA, objB);\n-    stack.push(new ObjectTypePair(objA, MockObject.class));\n-    assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class)));\n-    assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class)));\n+    stack.push(new ObjectTypePair(objA, MockObject.class, true));\n+    assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true)));\n+    assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true)));\n   }\n \n   private static class MockObject {\n--- a/gson/src/test/java/com/google/gson/common/TestTypes.java\n+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java\n \n package com.google.gson.common;\n \n-import java.lang.reflect.Type;\n-\n import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n import com.google.gson.JsonParseException;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSerializationContext;\n import com.google.gson.JsonSerializer;\n import com.google.gson.annotations.SerializedName;\n+\n+import java.lang.reflect.Type;\n \n /**\n  * Types used for testing JSON serialization and deserialization\n  * @author Joel Leitch\n  */\n public class TestTypes {\n-\n-  public static class BaseClass {\n-    final String baseField;\n-    public BaseClass() {\n-      this(\"baseFieldValue\");\n-    }\n-    public BaseClass(String value) {\n-      this.baseField = value;\n-    }\n-    public String getExpectedJson() {\n-      return String.format(\"{\\\"baseField\\\":\\\"%s\\\"}\", baseField);\n-    }\n-  }\n-\n-  public static class SubClass extends BaseClass {\n-    final String subField;\n-    public SubClass() {\n-      this(\"subFieldValue\");\n-    }\n-    public SubClass(String subFieldValue) {\n-      this.subField = subFieldValue;\n-    }\n-    @Override\n-    public String getExpectedJson() {\n-      return String.format(\"{\\\"subField\\\":\\\"%s\\\",\\\"baseField\\\":\\\"%s\\\"}\", subField, baseField);\n-    }\n+  \n+  public static class Base {\n+    public static final String BASE_NAME = Base.class.getSimpleName();\n+    public static final String BASE_FIELD_KEY = \"baseName\";\n+    public static final String SERIALIZER_KEY = \"serializerName\";\n+    public String baseName = BASE_NAME;\n+    public String serializerName;\n+  }\n+\n+  public static class Sub extends Base {\n+    public static final String SUB_NAME = Sub.class.getSimpleName();\n+    public static final String SUB_FIELD_KEY = \"subName\";\n+    public final String subName = SUB_NAME;\n+  }\n+\n+  public static class ClassWithBaseField {\n+    public static final String FIELD_KEY = \"base\";\n+    public final Base base;\n+    @SuppressWarnings(\"unused\")\n+    private ClassWithBaseField() {\n+      this(null);\n+    }\n+    public ClassWithBaseField(Base base) {\n+      this.base = base;\n+    }\n+  }\n+\n+  public static class ClassWithBaseArrayField {\n+    public static final String FIELD_KEY = \"base\";\n+    public final Base[] base;\n+    @SuppressWarnings(\"unused\")\n+    private ClassWithBaseArrayField() {\n+      this(null);\n+    }\n+    public ClassWithBaseArrayField(Base[] base) {\n+      this.base = base;\n+    }\n+  }\n+\n+  public static class BaseSerializer implements JsonSerializer<Base> {\n+    public static final String NAME = BaseSerializer.class.getSimpleName(); \n+    public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n+      JsonObject obj = new JsonObject();\n+      obj.addProperty(Base.SERIALIZER_KEY, NAME);\n+      return obj;\n+    }    \n+  }\n+  public static class SubSerializer implements JsonSerializer<Sub> {\n+    public static final String NAME = SubSerializer.class.getSimpleName(); \n+    public JsonElement serialize(Sub src, Type typeOfSrc, JsonSerializationContext context) {\n+      JsonObject obj = new JsonObject();\n+      obj.addProperty(Base.SERIALIZER_KEY, NAME);\n+      return obj;\n+    }    \n   }\n \n   public static class StringWrapper {\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.common.TestTypes.Base;\n+import com.google.gson.common.TestTypes.BaseSerializer;\n+import com.google.gson.common.TestTypes.ClassWithBaseArrayField;\n+import com.google.gson.common.TestTypes.ClassWithBaseField;\n+import com.google.gson.common.TestTypes.Sub;\n+import com.google.gson.common.TestTypes.SubSerializer;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional Test exercising custom serialization only.  When test applies to both \n+ * serialization and deserialization then add it to CustomTypeAdapterTest.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class CustomSerializerTest extends TestCase {\n+  \n+   public void testBaseClassSerializerInvokedForBaseClassFields() {\n+     Gson gson = new GsonBuilder()\n+       .registerTypeAdapter(Base.class, new BaseSerializer())\n+       .registerTypeAdapter(Sub.class, new SubSerializer())\n+       .create();\n+     ClassWithBaseField target = new ClassWithBaseField(new Base());\n+     JsonObject json = (JsonObject) gson.toJsonTree(target);\n+     JsonObject base = json.get(\"base\").getAsJsonObject();\n+     assertEquals(BaseSerializer.NAME, base.get(Base.SERIALIZER_KEY).getAsString());\n+   }\n+\n+   public void testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {\n+     Gson gson = new GsonBuilder()\n+       .registerTypeAdapter(Base.class, new BaseSerializer())\n+       .registerTypeAdapter(Sub.class, new SubSerializer())\n+       .create();\n+     ClassWithBaseField target = new ClassWithBaseField(new Sub());\n+     JsonObject json = (JsonObject) gson.toJsonTree(target);\n+     JsonObject base = json.get(\"base\").getAsJsonObject();\n+     assertEquals(SubSerializer.NAME, base.get(Base.SERIALIZER_KEY).getAsString());\n+   }\n+\n+   public void testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClassInstances() {\n+     Gson gson = new GsonBuilder()\n+       .registerTypeAdapter(Base.class, new BaseSerializer())\n+       .registerTypeAdapter(Sub.class, new SubSerializer())\n+       .create();\n+     ClassWithBaseArrayField target = new ClassWithBaseArrayField(new Base[] {new Sub(), new Sub()});\n+     JsonObject json = (JsonObject) gson.toJsonTree(target);\n+     JsonArray array = json.get(\"base\").getAsJsonArray();\n+     for (JsonElement element : array) {\n+       JsonElement serializerKey = element.getAsJsonObject().get(Base.SERIALIZER_KEY);\n+      assertEquals(SubSerializer.NAME, serializerKey.getAsString());\n+     }\n+   }\n+    \n+   public void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {\n+     Gson gson = new GsonBuilder()\n+       .registerTypeAdapter(Base.class, new BaseSerializer())\n+       .create();\n+     ClassWithBaseField target = new ClassWithBaseField(new Sub());\n+     JsonObject json = (JsonObject) gson.toJsonTree(target);\n+     JsonObject base = json.get(\"base\").getAsJsonObject();\n+     assertEquals(BaseSerializer.NAME, base.get(Base.SERIALIZER_KEY).getAsString());\n+   }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n       return new DataHolder(jsonElement.getAsString());\n     }\n   }\n-\n }\n--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n  */\n package com.google.gson.functional;\n \n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.Base;\n+import com.google.gson.common.TestTypes.ClassWithBaseArrayField;\n+import com.google.gson.common.TestTypes.ClassWithBaseField;\n+import com.google.gson.common.TestTypes.Nested;\n+import com.google.gson.common.TestTypes.Sub;\n+\n+import junit.framework.TestCase;\n+\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.SortedSet;\n import java.util.TreeSet;\n \n-import junit.framework.TestCase;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.common.TestTypes.BagOfPrimitives;\n-import com.google.gson.common.TestTypes.BaseClass;\n-import com.google.gson.common.TestTypes.Nested;\n-import com.google.gson.common.TestTypes.SubClass;\n-\n /**\n  * Functional tests for Json serialization and deserialization of classes with \n  * inheritance hierarchies.\n     assertEquals(json, target.getExpectedJson());\n   }\n \n-  public void testClassWithBaseFieldSerialization() throws Exception {\n-    ClassWithBaseFields sub = new ClassWithBaseFields();\n-    sub.field = new SubClass();\n-    String json = gson.toJson(sub);\n-    String expectedJson = sub.field.getExpectedJson();\n-    assertTrue(json.contains(expectedJson));\n-  }\n-\n-  public void testClassWithBaseArrayFieldSerialization() throws Exception {\n-    ClassWithBaseFields sub = new ClassWithBaseFields();\n-    sub.array = new BaseClass[]{ new SubClass(\"sub1\"), new SubClass(\"sub2\")};\n-    String json = gson.toJson(sub);\n-    assertTrue(json.contains(\"sub1\"));\n-    assertTrue(json.contains(\"sub2\"));\n-  }\n-\n-  private static class ClassWithBaseFields {\n-    BaseClass field;\n-    @SuppressWarnings(\"unused\")\n-    BaseClass[] array;\n+  public void testClassWithBaseFieldSerialization() {\n+    ClassWithBaseField sub = new ClassWithBaseField(new Sub());\n+    JsonObject json = (JsonObject) gson.toJsonTree(sub);\n+    JsonElement base = json.getAsJsonObject().get(ClassWithBaseField.FIELD_KEY);\n+    assertEquals(Sub.SUB_NAME, base.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString());\n+  }\n+\n+  public void testClassWithBaseArrayFieldSerialization() {\n+    Base[] baseClasses = new Base[]{ new Sub(), new Sub()};\n+    ClassWithBaseArrayField sub = new ClassWithBaseArrayField(baseClasses);\n+    JsonObject json = gson.toJsonTree(sub).getAsJsonObject();\n+    JsonArray bases = json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\n+    for (JsonElement element : bases) { \n+      assertEquals(Sub.SUB_NAME, element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString());\n+    }\n+  }\n+\n+  public void testBaseSerializedAsSub() {\n+    Base base = new Sub();\n+    JsonObject json = gson.toJsonTree(base).getAsJsonObject();\n+    assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString());\n+  }\n+\n+  public void testBaseSerializedAsBaseWhenSpecifiedWithExplicitType() {\n+    Base base = new Sub();\n+    JsonObject json = gson.toJsonTree(base, Base.class).getAsJsonObject();\n+    assertEquals(Base.BASE_NAME, json.get(Base.BASE_FIELD_KEY).getAsString());\n+    assertNull(json.get(Sub.SUB_FIELD_KEY));\n+  }\n+\n+  public void testBaseSerializedAsSubWhenSpecifiedWithExplicitType() {\n+    Base base = new Sub();\n+    JsonObject json = gson.toJsonTree(base, Sub.class).getAsJsonObject();\n+    assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString());\n   }\n \n   private static class SubTypeOfNested extends Nested {", "timestamp": 1255030133, "metainfo": ""}