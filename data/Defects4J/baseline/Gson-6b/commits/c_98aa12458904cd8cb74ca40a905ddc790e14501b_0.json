{"sha": "98aa12458904cd8cb74ca40a905ddc790e14501b", "log": "Unsafe allocation for reflective type adapters.", "commit": "\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n import com.google.gson.internal.$Gson$Types;\n \n+import com.google.gson.internal.UnsafeAllocator;\n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Do sneaky things to allocate objects without invoking their constructors.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+public abstract class UnsafeAllocator {\n+  public abstract <T> T newInstance(Class<T> c) throws Exception;\n+\n+  public static UnsafeAllocator create() {\n+    // try JVM\n+    // public class Unsafe {\n+    //   public Object allocateInstance(Class<?> type);\n+    // }\n+    try {\n+      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n+      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      final Object unsafe = f.get(null);\n+      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) allocateInstance.invoke(unsafe, c);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, pre-gingerbread\n+    // public class ObjectInputStream {\n+    //   private static native Object newInstance(\n+    //     Class<?> instantiationClass, Class<?> constructorClass);\n+    // }\n+    try {\n+      final Method newInstance = ObjectInputStream.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, Object.class);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, post-gingerbread\n+    // public class ObjectStreamClass {\n+    //   private static native int getConstructorId(Class<?> c);\n+    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n+    // }\n+    try {\n+      Method getConstructorId = ObjectStreamClass.class\n+          .getDeclaredMethod(\"getConstructorId\", Class.class);\n+      getConstructorId.setAccessible(true);\n+      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n+      final Method newInstance = ObjectStreamClass.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, constructorId);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // give up\n+    return new UnsafeAllocator() {\n+      @Override\n+      public <T> T newInstance(Class<T> c) {\n+        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n package com.google.gson.internal.bind;\n \n import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.UnsafeAllocator;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n public final class ReflectiveTypeAdapter<T> extends TypeAdapter<T>  {\n   public static final Factory FACTORY = new FactoryImpl();\n \n+  private static final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n+  private final Class<? super T> rawType;\n   private final Constructor<? super T> constructor;\n   private final Map<String, BoundField> map;\n   private final BoundField[] boundFields;\n \n-  ReflectiveTypeAdapter(Constructor<? super T> constructor, Map<String, BoundField> map) {\n+  ReflectiveTypeAdapter(Class<? super T> rawType, Constructor<? super T> constructor, Map<String, BoundField> map) {\n+    this.rawType = rawType;\n     this.constructor = constructor;\n     this.map = map;\n     this.boundFields = map.values().toArray(new BoundField[map.size()]);\n   }\n \n+  @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n   public T read(JsonReader reader) throws IOException {\n     if (reader.peek() == JsonToken.NULL) {\n       reader.nextNull(); // TODO: does this belong here?\n       return null;\n     }\n \n-    @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n-    T instance = (T) MiniGson.newInstance(constructor);\n+    T instance;\n+    if (constructor != null) {\n+      instance = (T) MiniGson.newInstance(constructor);\n+    } else {\n+      try {\n+        instance = (T) unsafeAllocator.newInstance(rawType);\n+      } catch (Exception e) {\n+        throw new RuntimeException((\"Unable to invoke no-args constructor for \" + rawType.getName()\n+            + \". Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n+      }\n+    }\n \n     // TODO: null out the other fields?\n \n         return null; // it's a primitive!\n       }\n \n-      // TODO: use Joel's constructor calling code (with setAccessible)\n-      Constructor<? super T> constructor;\n+      Constructor<? super T> constructor = null;\n       try {\n         constructor = raw.getDeclaredConstructor();\n-      } catch (NoSuchMethodException e) {\n-        return null;\n+      } catch (NoSuchMethodException ignored) {\n       }\n \n-      return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n+      return new ReflectiveTypeAdapter<T>(raw, constructor, getBoundFields(context, type, raw));\n     }\n \n     private Map<String, BoundField> getBoundFields(", "timestamp": 1312334751, "metainfo": ""}