{"sha": "e2cfc0cc19fb917ad5d9923706fe33846628ca36", "log": "Update GsonBuilder API to accept an enum for the serialize Long as string.  This will be useful if/when we implement support to serialize a long type as an array of integers.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n   }\n \n   static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n-    return getDefaultSerializers(false, false);\n+    return getDefaultSerializers(false, LongSerializationPolicy.DEFAULT);\n   }\n       \n   static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\n-      boolean serializeSpecialFloatingPointValues, boolean serializeLongsAsString) {\n+      boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) {\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n     \n \n     // Long primitive\n     DefaultTypeAdapters.LongSerializer longSerializer = \n-        new DefaultTypeAdapters.LongSerializer(serializeLongsAsString);\n+        new DefaultTypeAdapters.LongSerializer(longSerializationPolicy);\n     serializers.registerIfAbsent(Long.class, longSerializer);\n     serializers.registerIfAbsent(long.class, longSerializer);\n \n   }\n   \n   private static class LongSerializer implements JsonSerializer<Long> {\n-    private final boolean serializeAsString;\n-    \n-    private LongSerializer(boolean serializeAsString) {\n-      this.serializeAsString = serializeAsString;\n+    private final LongSerializationPolicy longSerializationPolicy;\n+    \n+    private LongSerializer(LongSerializationPolicy longSerializationPolicy) {\n+      this.longSerializationPolicy = longSerializationPolicy;\n     }\n \n     public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {\n-      if (src == null) {\n-        return JsonNull.createJsonNull();\n-      } else if (serializeAsString) {\n-        return new JsonPrimitive(String.valueOf(src));\n-      } else {\n-        return new JsonPrimitive(src);\n-      }\n+      return longSerializationPolicy.serialize(src);\n     }\n \n     @Override\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n-\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.util.Date;\n import java.util.LinkedList;\n import java.util.List;\n+\n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n public final class GsonBuilder {\n \n   private double ignoreVersionsAfter;\n-  private boolean serializeLongAsString;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n   private boolean serializeInnerClasses;\n   private final AnonymousAndLocalClassExclusionStrategy anonAndLocalClassExclusionStrategy;\n   private final InnerClassExclusionStrategy innerClassExclusionStrategy;\n   private boolean excludeFieldsWithoutExposeAnnotation;\n+  private LongSerializationPolicy longSerializationPolicy;\n   private FieldNamingStrategy fieldNamingPolicy;\n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n   private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n   public GsonBuilder() {\n     // setup default values\n     ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS;\n-    serializeLongAsString = false;\n     serializeInnerClasses = true;\n     prettyPrinting = false;\n     escapeHtmlChars = true;\n     innerClassExclusionStrategy = new InnerClassExclusionStrategy();\n     modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY;\n     excludeFieldsWithoutExposeAnnotation = false;\n+    longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n     fieldNamingPolicy = Gson.DEFAULT_NAMING_POLICY;\n     instanceCreators = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n     serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n     this.serializeNulls = true;\n     return this;\n   }\n-  \n-  /**\n-   * Configures Gson to output fields of type {@code long} as {@code String}s instead of a number.\n-   *\n-   * @param value the boolean value on whether or not {@code Gson} should serialize a {@code long}\n-   * field as a {@code String}\n-   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n-   * @since 1.3\n-   */\n-  public GsonBuilder serializeLongFieldsAsString(boolean value) {\n-    serializeLongAsString = value;\n-    return this;\n-  }\n \n   /**\n    * Configures Gson to exclude inner classes during serialization.\n-   * \n+   *\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.3\n    */\n     serializeInnerClasses = false;\n     return this;\n   }\n-  \n+\n+  /**\n+   * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\n+   * objects.\n+   *\n+   * @param serializationPolicy the particular policy to use for serializing longs.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.3\n+   */\n+  public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\n+    this.longSerializationPolicy = serializationPolicy;\n+    return this;\n+  }\n+\n   /**\n    * Configures Gson to apply a specific naming policy to an object's field during serialization\n    * and deserialization.\n     prettyPrinting = true;\n     return this;\n   }\n-  \n+\n   /**\n    * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\n    * Gson to pass-through HTML characters as is.\n-   * \n+   *\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.3\n    */\n     this.datePattern = null;\n     return this;\n   }\n-  \n+\n   /**\n    * Configures Gson for custom serialization or deserialization. This method combines the\n    * registration of an {@link InstanceCreator}, {@link JsonSerializer}, and a\n \n   /**\n    * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n-   * special double values (NaN, Infinity, -Infinity). However, \n-   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript \n+   * special double values (NaN, Infinity, -Infinity). However,\n+   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n    * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n-   * values. Moreover, most JavaScript engines will accept these special values in JSON without \n+   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n    * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n-   * though JSON specification disallows them. \n-   * \n-   * <p>Gson always accepts these special values during deserialization. However, it outputs \n-   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN}, \n-   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value \n-   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it \n+   * though JSON specification disallows them.\n+   *\n+   * <p>Gson always accepts these special values during deserialization. However, it outputs\n+   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n+   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n+   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n    * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n    * default behavior when you know that the JSON receiver will be able to handle these special\n-   * values.   \n-   * \n+   * values.\n+   *\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.3\n    */\n         customDeserializers);\n \n     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(\n-        serializeSpecialFloatingPointValues, serializeLongAsString));\n-    \n+        serializeSpecialFloatingPointValues, longSerializationPolicy));\n+\n     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers());\n-    \n+\n     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n       instanceCreators.copyOf();\n     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators());\n     MappedObjectConstructor objConstructor = Gson.createObjectConstructor(customInstanceCreators);\n \n-    JsonFormatter formatter =  prettyPrinting ? \n-        new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars); \n-    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor, \n+    JsonFormatter formatter =  prettyPrinting ?\n+        new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n+    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor,\n         formatter, serializeNulls, customSerializers, customDeserializers);\n     return gson;\n   }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Defines the expected format for a {@code long} or {@code Long} type when its serialized.\n+ *\n+ * @since 1.3\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public enum LongSerializationPolicy {\n+  /**\n+   * This is the \"default\" serialization policy that will output a {@code long} object as a JSON\n+   * number.  For example, assume an object has a long field named \"f\" then the serialized output\n+   * would be:\n+   * {@code {\"f\":123}}.\n+   */\n+  DEFAULT(new DefaultStrategy()),\n+  \n+  /**\n+   * Serializes a long value as a quoted string.  For example, assume an object has a long field \n+   * named \"f\" then the serialized output would be:\n+   * {@code {\"f\":\"123\"}}.\n+   */\n+  STRING(new StringStrategy());\n+  \n+  private final Strategy strategy;\n+  \n+  private LongSerializationPolicy(Strategy strategy) {\n+    this.strategy = strategy;\n+  }\n+\n+  /**\n+   * Serialize this {@code value} using this serialization policy.\n+   *\n+   * @param value the long value to be serialized into a {@link JsonElement}\n+   * @return the serialized version of {@code value}\n+   */\n+  public JsonElement serialize(Long value) {\n+    return strategy.serialize(value);\n+  }\n+  \n+  private interface Strategy {\n+    JsonElement serialize(Long value);\n+  }\n+  \n+  private static class DefaultStrategy implements Strategy {\n+    public JsonElement serialize(Long value) {\n+      return new JsonPrimitive(value);\n+    }\n+  }\n+  \n+  private static class StringStrategy implements Strategy {\n+    public JsonElement serialize(Long value) {\n+      return new JsonPrimitive(String.valueOf(value));\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link LongSerializationPolicy} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class LongSerializationPolicyTest extends TestCase {\n+\n+  public void testDefaultLongSerialization() throws Exception {\n+    JsonElement element = LongSerializationPolicy.DEFAULT.serialize(1556L);\n+    assertTrue(element.isJsonPrimitive());\n+    \n+    JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();\n+    assertFalse(jsonPrimitive.isString());\n+    assertTrue(jsonPrimitive.isNumber());\n+    assertEquals(1556L, element.getAsLong());\n+  }\n+  \n+  public void testStringLongSerialization() throws Exception {\n+    JsonElement element = LongSerializationPolicy.STRING.serialize(1556L);\n+    assertTrue(element.isJsonPrimitive());\n+    \n+    JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();\n+    assertFalse(jsonPrimitive.isNumber());\n+    assertTrue(jsonPrimitive.isString());\n+    assertEquals(\"1556\", element.getAsString());\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.JsonParseException;\n+import com.google.gson.LongSerializationPolicy;\n import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n \n /**\n   }  \n   \n   public void testLongAsStringSerialization() throws Exception {\n-    gson = new GsonBuilder().serializeLongFieldsAsString(true).create();\n+    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\n     String result = gson.toJson(15L);\n     assertEquals(\"\\\"15\\\"\", result);\n     \n     long value = gson.fromJson(\"\\\"15\\\"\", long.class);\n     assertEquals(15, value);\n \n-    gson = new GsonBuilder().serializeLongFieldsAsString(true).create();\n+    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\n     value = gson.fromJson(\"\\\"25\\\"\", long.class);\n     assertEquals(25, value);\n   }", "timestamp": 1231654289, "metainfo": ""}