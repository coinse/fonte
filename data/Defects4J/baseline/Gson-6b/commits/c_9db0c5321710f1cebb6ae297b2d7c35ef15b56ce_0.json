{"sha": "9db0c5321710f1cebb6ae297b2d7c35ef15b56ce", "log": "Adapt bytes", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n-import java.lang.reflect.ParameterizedType;\n+import com.google.gson.internal.$Gson$Types;\n import java.lang.reflect.Type;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.util.TimeZone;\n import java.util.TreeSet;\n \n-import com.google.gson.internal.$Gson$Types;\n-\n /**\n  * List of all the default type adapters ({@link JsonSerializer}s, {@link JsonDeserializer}s,\n  * and {@link InstanceCreator}s.\n   private static final BitSetTypeAdapter BIT_SET_ADAPTER = new BitSetTypeAdapter();\n   private static final MapTypeAdapter MAP_TYPE_ADAPTER = new MapTypeAdapter();\n \n-  private static final ByteTypeAdapter BYTE_TYPE_ADAPTER = new ByteTypeAdapter();\n   private static final CharacterTypeAdapter CHARACTER_TYPE_ADAPTER = new CharacterTypeAdapter();\n   private static final LongDeserializer LONG_DESERIALIZER = new LongDeserializer();\n   private static final NumberTypeAdapter NUMBER_TYPE_ADAPTER = new NumberTypeAdapter();\n     map.register(BitSet.class, BIT_SET_ADAPTER, true);\n \n     // Add primitive serializers\n-    map.register(Byte.class, BYTE_TYPE_ADAPTER, true);\n-    map.register(byte.class, BYTE_TYPE_ADAPTER, true);\n     map.register(Character.class, CHARACTER_TYPE_ADAPTER, true);\n     map.register(Number.class, NUMBER_TYPE_ADAPTER, true);\n \n     map.register(BitSet.class, BIT_SET_ADAPTER, true);\n \n     // Add primitive deserializers\n-    map.register(Byte.class, BYTE_TYPE_ADAPTER, true);\n-    map.register(byte.class, BYTE_TYPE_ADAPTER, true);\n     map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER), true);\n     map.register(Long.class, LONG_DESERIALIZER, true);\n     map.register(long.class, LONG_DESERIALIZER, true);\n     }\n   }\n \n-  private static final class ByteTypeAdapter implements JsonSerializer<Byte>, JsonDeserializer<Byte> {\n-    public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context) {\n-      return new JsonPrimitive(src);\n-    }\n-\n-    public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-        throws JsonParseException {\n-      try {\n-        return json.getAsByte();\n-      } catch (NumberFormatException e) {\n-        throw new JsonSyntaxException(e);\n-      } catch (UnsupportedOperationException e) {\n-        throw new JsonSyntaxException(e);\n-      } catch (IllegalStateException e) {\n-        throw new JsonSyntaxException(e);\n-      }\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return ByteTypeAdapter.class.getSimpleName();\n-    }\n-  }\n-\n   static final class FloatSerializer implements JsonSerializer<Float> {\n     private final boolean serializeSpecialFloatingPointValues;\n \n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     MiniGson.Builder builder = new MiniGson.Builder()\n         .withoutDefaultFactories()\n         .factory(TypeAdapters.BOOLEAN_FACTORY)\n+        .factory(TypeAdapters.BYTE_FACTORY)\n         .factory(TypeAdapters.SHORT_FACTORY)\n         .factory(TypeAdapters.INTEGER_FACTORY)\n+        .factory(TypeAdapters.newFactory(long.class, Long.class,\n+            longAdapter(longSerializationPolicy)))\n         .factory(TypeAdapters.newFactory(double.class, Double.class,\n             doubleAdapter(serializeSpecialFloatingPointValues)))\n         .factory(TypeAdapters.newFactory(float.class, Float.class,\n             floatAdapter(serializeSpecialFloatingPointValues)))\n-        .factory(TypeAdapters.newFactory(long.class, Long.class,\n-            longAdapter(longSerializationPolicy)))\n         .factory(TypeAdapters.STRING_FACTORY)\n         .factory(TypeAdapters.STRING_BUILDER_FACTORY)\n         .factory(TypeAdapters.STRING_BUFFER_FACTORY)\n     this.miniGson = builder.build();\n   }\n \n-  private TypeAdapter<Double> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n+  private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n     if (serializeSpecialFloatingPointValues) {\n       return TypeAdapters.DOUBLE;\n     }\n-    return new TypeAdapter<Double>() {\n+    return new TypeAdapter<Number>() {\n       @Override public Double read(JsonReader reader) throws IOException {\n         return reader.nextDouble();\n       }\n-      @Override public void write(JsonWriter writer, Double value) throws IOException {\n-        checkValidFloatingPoint(value);\n+      @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        double doubleValue = value.doubleValue();\n+        checkValidFloatingPoint(doubleValue);\n         writer.value(value);\n       }\n     };\n   }\n \n-  private TypeAdapter<Float> floatAdapter(boolean serializeSpecialFloatingPointValues) {\n+  private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\n     if (serializeSpecialFloatingPointValues) {\n       return TypeAdapters.FLOAT;\n     }\n-    return new TypeAdapter<Float>() {\n+    return new TypeAdapter<Number>() {\n       @Override public Float read(JsonReader reader) throws IOException {\n         return (float) reader.nextDouble();\n       }\n-      @Override public void write(JsonWriter writer, Float value) throws IOException {\n-        checkValidFloatingPoint(value);\n+      @Override public void write(JsonWriter writer, Number value) throws IOException {\n+        float floatValue = value.floatValue();\n+        checkValidFloatingPoint(floatValue);\n         writer.value(value);\n       }\n     };\n     }\n   }\n \n-  private TypeAdapter<Long> longAdapter(LongSerializationPolicy longSerializationPolicy) {\n+  private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\n     if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\n       return TypeAdapters.LONG;\n     }\n-    return new TypeAdapter<Long>() {\n-      @Override public Long read(JsonReader reader) throws IOException {\n+    return new TypeAdapter<Number>() {\n+      @Override public Number read(JsonReader reader) throws IOException {\n         return reader.nextLong();\n       }\n-      @Override public void write(JsonWriter writer, Long value) throws IOException {\n+      @Override public void write(JsonWriter writer, Number value) throws IOException {\n         writer.value(value.toString());\n       }\n     };\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.URI;\n import java.util.StringTokenizer;\n import java.util.UUID;\n \n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n-import com.google.gson.stream.JsonWriter;\n-\n /**\n  * Type adapters for basic types.\n  */\n   public static final TypeAdapter.Factory BOOLEAN_FACTORY\n       = newFactory(boolean.class, Boolean.class, BOOLEAN);\n \n-  public static final TypeAdapter<Integer> INTEGER = new TypeAdapter<Integer>() {\n-    public Integer read(JsonReader reader) throws IOException {\n+  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n+      int intValue = reader.nextInt();\n+      return (byte) intValue;\n+    }\n+    public void write(JsonWriter writer, Number value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory BYTE_FACTORY\n+      = newFactory(byte.class, Byte.class, BYTE);\n+\n+  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n+      return (short) reader.nextInt();\n+    }\n+    public void write(JsonWriter writer, Number value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory SHORT_FACTORY\n+      = newFactory(short.class, Short.class, SHORT);\n+\n+  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n       return reader.nextInt();\n     }\n-    public void write(JsonWriter writer, Integer value) throws IOException {\n+    public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n   };\n   public static final TypeAdapter.Factory INTEGER_FACTORY\n       = newFactory(int.class, Integer.class, INTEGER);\n \n-  public static final TypeAdapter<Short> SHORT = new TypeAdapter<Short>() {\n-    public Short read(JsonReader reader) throws IOException {\n-      return (short) reader.nextInt();\n-    }\n-    public void write(JsonWriter writer, Short value) throws IOException {\n-      writer.value(value);\n-    }\n-  };\n-\n-  public static final TypeAdapter.Factory SHORT_FACTORY\n-      = newFactory(short.class, Short.class, SHORT);\n-\n-  public static final TypeAdapter<Long> LONG = new TypeAdapter<Long>() {\n-    public Long read(JsonReader reader) throws IOException {\n+  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n       return reader.nextLong();\n     }\n-    public void write(JsonWriter writer, Long value) throws IOException {\n+    public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n   };\n   public static final TypeAdapter.Factory LONG_FACTORY\n       = newFactory(long.class, Long.class, LONG);\n \n-  public static final TypeAdapter<Double> DOUBLE = new TypeAdapter<Double>() {\n-    public Double read(JsonReader reader) throws IOException {\n+  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n+      return (float) reader.nextDouble();\n+    }\n+    public void write(JsonWriter writer, Number value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory FLOAT_FACTORY\n+      = newFactory(float.class, Float.class, FLOAT);\n+\n+  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n+    public Number read(JsonReader reader) throws IOException {\n       return reader.nextDouble();\n     }\n-    public void write(JsonWriter writer, Double value) throws IOException {\n+    public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n   };\n \n   public static final TypeAdapter.Factory DOUBLE_FACTORY\n       = newFactory(double.class, Double.class, DOUBLE);\n-\n-  public static final TypeAdapter<Float> FLOAT = new TypeAdapter<Float>() {\n-    public Float read(JsonReader reader) throws IOException {\n-      return (float) reader.nextDouble();\n-    }\n-    public void write(JsonWriter writer, Float value) throws IOException {\n-      writer.value(value);\n-    }\n-  };\n-\n-  public static final TypeAdapter.Factory FLOAT_FACTORY\n-      = newFactory(float.class, Float.class, FLOAT);\n \n   public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n     public String read(JsonReader reader) throws IOException {\n   }\n \n   public static <T> TypeAdapter.Factory newFactory(\n-      final Class<T> unboxed, final Class<T> boxed, final TypeAdapter<T> typeAdapter) {\n+      final Class<T> unboxed, final Class<T> boxed, final TypeAdapter<? super T> typeAdapter) {\n     return new TypeAdapter.Factory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n       public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n     assertEquals(\"1\", gson.toJson(1, Byte.class));\n   }\n \n+  public void testShortSerialization() {\n+    assertEquals(\"1\", gson.toJson(1, short.class));\n+    assertEquals(\"1\", gson.toJson(1, Short.class));\n+  }\n+\n   public void testByteDeserialization() {\n     Byte target = gson.fromJson(\"1\", Byte.class);\n     assertEquals(1, (byte)target);", "timestamp": 1315543169, "metainfo": ""}