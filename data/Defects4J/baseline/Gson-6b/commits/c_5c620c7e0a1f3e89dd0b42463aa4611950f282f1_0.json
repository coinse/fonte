{"sha": "5c620c7e0a1f3e89dd0b42463aa4611950f282f1", "log": "Changed Gson behavior to reject duplicate fields in a class.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n             Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField boundField = createBoundField(context, field, getFieldName(raw, field, declaredType),\n                 TypeToken.get(fieldType), serialize, deserialize);\n-            result.put(boundField.name, boundField);\n+            BoundField previous = result.put(boundField.name, boundField);\n+            if (previous != null) {\n+              throw new IllegalArgumentException(declaredType\n+                  + \" declares multiple JSON fields named \" + previous.name);\n+            }\n           }\n         }\n         type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n \n   public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() {\n     Gson gson = builder.create();\n-    ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);\n-    String actual = gson.toJson(target);\n-    assertEquals(\"{\\\"a\\\":10}\", actual);\n-\n-    target = new ClassWithDuplicateFields(3.0D);\n-    actual = gson.toJson(target);\n-    assertEquals(\"{\\\"a\\\":3.0}\", actual);\n+    try {\n+      ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);\n+      gson.toJson(target);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n   }\n \n   public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {", "timestamp": 1312340712, "metainfo": ""}