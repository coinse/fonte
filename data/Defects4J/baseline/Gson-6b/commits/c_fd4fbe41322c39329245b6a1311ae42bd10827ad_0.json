{"sha": "fd4fbe41322c39329245b6a1311ae42bd10827ad", "log": "Added support for collections, maps, and arbitrary depth of type adapters for Intercept annotation. Added more tests for the features.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n       TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n       TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n       T object = typeAdapter.read(reader);\n-      invokeInterceptorIfNeeded(object, typeToken);\n+      invokeInterceptorIfNeeded(object, typeToken.getRawType());\n       return object;\n     } catch (EOFException e) {\n       /*\n     }\n   }\n \n+  private <T> void invokeInterceptorIfNeeded(T object, Type type) {\n+    @SuppressWarnings(\"unchecked\")\n+    TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(type);\n+    Class<? super T> clazz = typeToken.getRawType();\n+    invokeInterceptorIfNeeded(object, clazz);\n+  }\n+\n   @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-  private <T> void invokeInterceptorIfNeeded(T object, TypeToken<T> type) {\n-    Class<? super T> clazz = type.getRawType();\n+  private <T> void invokeInterceptorIfNeeded(T object, Class<T> clazz) {\n     Intercept interceptor = clazz.getAnnotation(Intercept.class);\n     if (interceptor == null) return;\n     // TODO: We don't need to construct an instance of postDeserializer every time. we can\n         .append(\"}\");\n   \treturn sb.toString();\n   }\n+\n+  /**\n+   * Not part of the Gson API. Do not use.\n+   */\n+  public static final class $Internal$Access {\n+    public static <T> void invokeInterceptor(Gson gson, T instance, Type type) {\n+      gson.invokeInterceptorIfNeeded(instance, type);\n+    }\n+    public static <T> void invokeInterceptor(Gson gson, T instance, Class<T> clazz) {\n+      gson.invokeInterceptorIfNeeded(instance, clazz);\n+    }\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.Gson;\n-import com.google.gson.TypeAdapter;\n-import com.google.gson.TypeAdapterFactory;\n import java.io.IOException;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n import java.util.ArrayList;\n import java.util.List;\n \n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n     }\n   };\n \n+  private final Gson context;\n   private final Class<E> componentType;\n   private final TypeAdapter<E> componentTypeAdapter;\n \n   public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+    this.context = context;\n     this.componentTypeAdapter =\n       new TypeAdapterRuntimeTypeWrapper<E>(context, componentTypeAdapter, componentType);\n     this.componentType = componentType;\n     in.beginArray();\n     while (in.hasNext()) {\n       E instance = componentTypeAdapter.read(in);\n+      Gson.$Internal$Access.invokeInterceptor(context, instance, componentType);\n       list.add(instance);\n     }\n     in.endArray();\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n   }\n \n   private final class Adapter<E> extends TypeAdapter<Collection<E>> {\n+    private final Gson context;\n+    private final Type elementType;\n     private final TypeAdapter<E> elementTypeAdapter;\n     private final ObjectConstructor<? extends Collection<E>> constructor;\n \n     public Adapter(Gson context, Type elementType,\n         TypeAdapter<E> elementTypeAdapter,\n         ObjectConstructor<? extends Collection<E>> constructor) {\n+      this.context = context;\n+      this.elementType = elementType;\n       this.elementTypeAdapter =\n           new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\n       this.constructor = constructor;\n       in.beginArray();\n       while (in.hasNext()) {\n         E instance = elementTypeAdapter.read(in);\n+        Gson.$Internal$Access.invokeInterceptor(context, instance, elementType);\n         collection.add(instance);\n       }\n       in.endArray();\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n   }\n \n   private final class Adapter<K, V> extends TypeAdapter<Map<K, V>> {\n+    private final Gson context;\n+    private final Type keyType;\n+    private final Type valueType;\n     private final TypeAdapter<K> keyTypeAdapter;\n     private final TypeAdapter<V> valueTypeAdapter;\n     private final ObjectConstructor<? extends Map<K, V>> constructor;\n     public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\n         Type valueType, TypeAdapter<V> valueTypeAdapter,\n         ObjectConstructor<? extends Map<K, V>> constructor) {\n+      this.context = context;\n+      this.keyType = keyType;\n+      this.valueType = valueType;\n       this.keyTypeAdapter =\n         new TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\n       this.valueTypeAdapter =\n         while (in.hasNext()) {\n           in.beginArray(); // entry array\n           K key = keyTypeAdapter.read(in);\n+          Gson.$Internal$Access.invokeInterceptor(context, key, keyType);\n+\n           V value = valueTypeAdapter.read(in);\n+          Gson.$Internal$Access.invokeInterceptor(context, value, valueType);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n         while (in.hasNext()) {\n           JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n           K key = keyTypeAdapter.read(in);\n+          Gson.$Internal$Access.invokeInterceptor(context, key, keyType);\n           V value = valueTypeAdapter.read(in);\n+          Gson.$Internal$Access.invokeInterceptor(context, value, valueType);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n+        Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());\n         if (fieldValue != null || !isPrimitive) {\n           field.set(value, fieldValue);\n         }\n--- a/gson/src/test/java/com/google/gson/functional/InterceptorTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/InterceptorTest.java\n  */\n package com.google.gson.functional;\n \n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n \n import junit.framework.TestCase;\n \n import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n import com.google.gson.JsonParseException;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n import com.google.gson.internal.alpha.Intercept;\n import com.google.gson.internal.alpha.JsonPostDeserializer;\n import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n \n /**\n  * Unit tests for {@link Intercept} and {@link JsonPostDeserializer}.\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    this.gson = new Gson();\n+    this.gson = new GsonBuilder().enableComplexMapKeySerialization().create();\n   }\n \n   public void testExceptionsPropagated() {\n     } catch (JsonParseException expected) {}\n   }\n \n-  public void testPostDeserializeTopLevelClass() {\n+  public void testTopLevelClass() {\n     User user = gson.fromJson(\"{name:'bob',password:'pwd'}\", User.class);\n     assertEquals(User.DEFAULT_EMAIL, user.email);\n   }\n \n-  public void testPostDeserializeList() {\n+  public void testList() {\n     List<User> list = gson.fromJson(\"[{name:'bob',password:'pwd'}]\", new TypeToken<List<User>>(){}.getType());\n     User user = list.get(0);\n     assertEquals(User.DEFAULT_EMAIL, user.email);\n   }\n \n-  public void testPostDeserializeField() {\n+  public void testCollection() {\n+    Collection<User> list = gson.fromJson(\"[{name:'bob',password:'pwd'}]\", new TypeToken<Collection<User>>(){}.getType());\n+    User user = list.iterator().next();\n+    assertEquals(User.DEFAULT_EMAIL, user.email);\n+  }\n+\n+  public void testMapKeyAndValues() {\n+    Type mapType = new TypeToken<Map<User, Address>>(){}.getType();\n+    try {\n+      gson.fromJson(\"[[{name:'bob',password:'pwd'},{}]]\", mapType);\n+      fail();\n+    } catch (JsonSyntaxException expected) {}\n+    Map<User, Address> map = gson.fromJson(\"[[{name:'bob',password:'pwd'},{city:'Mountain View',state:'CA',zip:'94043'}]]\",\n+        mapType);\n+    Entry<User, Address> entry = map.entrySet().iterator().next();\n+    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);\n+    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);\n+  }\n+\n+  public void testField() {\n     UserGroup userGroup = gson.fromJson(\"{user:{name:'bob',password:'pwd'}}\", UserGroup.class);\n     assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n   }\n \n+  public void testCustomTypeAdapter() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(User.class, new TypeAdapter<User>() {\n+        @Override public void write(JsonWriter out, User value) throws IOException {\n+          throw new UnsupportedOperationException();\n+        }\n+        @Override public User read(JsonReader in) throws IOException {\n+          in.beginObject();\n+          in.nextName();\n+          String name = in.nextString();\n+          in.nextName();\n+          String password = in.nextString();\n+          in.endObject();\n+          return new User(name, password);\n+        }})\n+      .create();\n+    UserGroup userGroup = gson.fromJson(\"{user:{name:'bob',password:'pwd'}}\", UserGroup.class);\n+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n+  }\n+\n+  public void testDirectInvocationOfTypeAdapter() throws Exception {\n+    TypeAdapter<UserGroup> adapter = gson.getAdapter(UserGroup.class);\n+    UserGroup userGroup = adapter.fromJson(\"{\\\"user\\\":{\\\"name\\\":\\\"bob\\\",\\\"password\\\":\\\"pwd\\\"}}\");\n+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n   private static final class UserGroup {\n     User user;\n     String city;\n   }\n \n   @Intercept(postDeserialize = UserValidator.class)\n+  @SuppressWarnings(\"unused\")\n   private static final class User {\n     static final String DEFAULT_EMAIL = \"invalid@invalid.com\";\n     String name;\n     String password;\n     String email;\n+    Address address;\n+    public User(String name, String password) {\n+      this.name = name;\n+      this.password = password;\n+    }\n   }\n \n   private static final class UserValidator implements JsonPostDeserializer<User> {\n     public void postDeserialize(User user) {\n       if (user.name == null || user.password == null) {\n-        throw new JsonParseException(\"name and password are required fields.\");\n+        throw new JsonSyntaxException(\"name and password are required fields.\");\n       }\n       if (user.email == null) user.email = User.DEFAULT_EMAIL;\n     }\n   }\n-}\n+\n+  @Intercept(postDeserialize = AddressValidator.class)\n+  @SuppressWarnings(\"unused\")\n+  private static final class Address {\n+    static final String DEFAULT_FIRST_LINE = \"unknown\";\n+    String firstLine;\n+    String secondLine;\n+    String city;\n+    String state;\n+    String zip;\n+  }\n+\n+  private static final class AddressValidator implements JsonPostDeserializer<Address> {\n+    public void postDeserialize(Address address) {\n+      if (address.city == null || address.state == null || address.zip == null) {\n+        throw new JsonSyntaxException(\"Address city, state and zip are required fields.\");\n+      }\n+      if (address.firstLine == null) address.firstLine = Address.DEFAULT_FIRST_LINE;\n+    }\n+  }\n+}", "timestamp": 1350527863, "metainfo": ""}