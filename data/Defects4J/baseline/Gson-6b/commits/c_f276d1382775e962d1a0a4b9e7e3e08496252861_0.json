{"sha": "f276d1382775e962d1a0a4b9e7e3e08496252861", "log": "Added support for deserialization exclusion strategy.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.util.List;\n import java.util.Map;\n \n+import com.google.gson.internal.bind.ArrayTypeAdapter;\n+import com.google.gson.internal.bind.CollectionTypeAdapter;\n import com.google.gson.internal.bind.MiniGson;\n import com.google.gson.internal.bind.ReflectiveTypeAdapter;\n+import com.google.gson.internal.bind.StringToValueMapTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n         serializeNulls\n         serializers\n      */\n-    TypeAdapter.Factory factory = new ReflectiveTypeAdapter.FactoryImpl() {\n+    TypeAdapter.Factory reflectiveTypeAdapterFactory =\n+      new ReflectiveTypeAdapter.FactoryImpl() {\n       @Override\n-      public boolean skipField(Class<?> declaringClazz, Field f, Type declaredType) {\n-        // TODO: support deserialization policy as well\n-        return Gson.this.serializationExclusionStrategy.shouldSkipField(\n+      public boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n+        return !Gson.this.serializationExclusionStrategy.shouldSkipField(\n+            new FieldAttributes(declaringClazz, f, declaredType));\n+      }\n+      @Override\n+      public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n+        return !Gson.this.deserializationExclusionStrategy.shouldSkipField(\n             new FieldAttributes(declaringClazz, f, declaredType));\n       }\n     };\n     \n     this.miniGson = new MiniGson.Builder()\n-        .factory(factory)\n+        .withoutDefaultFactories()\n+        .factory(TypeAdapters.BOOLEAN_FACTORY)\n+        .factory(TypeAdapters.INTEGER_FACTORY)\n+        .factory(TypeAdapters.DOUBLE_FACTORY)\n+        .factory(TypeAdapters.LONG_FACTORY)\n+        .factory(TypeAdapters.STRING_FACTORY)\n+        .factory(CollectionTypeAdapter.FACTORY)\n+        .factory(StringToValueMapTypeAdapter.FACTORY)\n+        .factory(ArrayTypeAdapter.FACTORY)\n+        .factory(reflectiveTypeAdapterFactory)\n         .build();\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.internal.$Gson$Types;\n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n-import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n import java.util.ArrayList;\n import java.util.List;\n \n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+\n /**\n  * Adapt an array of objects.\n  */\n-final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n+public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.internal.$Gson$Types;\n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n-import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.ParameterizedType;\n import java.util.List;\n import java.util.Set;\n \n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+\n /**\n  * Adapt a homogeneous collection of objects.\n  */\n-final class CollectionTypeAdapter<E> extends TypeAdapter<Collection<E>> {\n+public final class CollectionTypeAdapter<E> extends TypeAdapter<Collection<E>> {\n   public static final Factory FACTORY = new Factory() {\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n--- a/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n \n   private MiniGson(Builder builder) {\n     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n-    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n-    factories.add(TypeAdapters.INTEGER_FACTORY);\n-    factories.add(TypeAdapters.DOUBLE_FACTORY);\n-    factories.add(TypeAdapters.LONG_FACTORY);\n-    factories.add(TypeAdapters.STRING_FACTORY);\n+    if (builder.addDefaultFactories) {\n+      factories.add(TypeAdapters.BOOLEAN_FACTORY);\n+      factories.add(TypeAdapters.INTEGER_FACTORY);\n+      factories.add(TypeAdapters.DOUBLE_FACTORY);\n+      factories.add(TypeAdapters.LONG_FACTORY);\n+      factories.add(TypeAdapters.STRING_FACTORY);\n+    }\n     factories.addAll(builder.factories);\n-    factories.add(CollectionTypeAdapter.FACTORY);\n-    factories.add(StringToValueMapTypeAdapter.FACTORY);\n-    factories.add(ArrayTypeAdapter.FACTORY);\n-    factories.add(ReflectiveTypeAdapter.FACTORY);\n+    if (builder.addDefaultFactories) {\n+      factories.add(CollectionTypeAdapter.FACTORY);\n+      factories.add(StringToValueMapTypeAdapter.FACTORY);\n+      factories.add(ArrayTypeAdapter.FACTORY);\n+      factories.add(ReflectiveTypeAdapter.FACTORY);\n+    }\n     this.factories = Collections.unmodifiableList(factories);\n   }\n \n \n   public static final class Builder {\n     private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    boolean addDefaultFactories = true;\n \n     public Builder factory(TypeAdapter.Factory factory) {\n       factories.add(factory);\n+      return this;\n+    }\n+\n+    public Builder withoutDefaultFactories() {\n+      this.addDefaultFactories = false;\n       return this;\n     }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n       while (reader.hasNext()) {\n         String name = reader.nextName();\n         BoundField field = map.get(name);\n-        if (field == null) {\n+        if (field == null || !field.deserialized) {\n           // TODO: define a better policy\n           reader.skipValue();\n         } else {\n     writer.beginObject();\n     try {\n       for (BoundField boundField : boundFields) {\n-        writer.name(boundField.name);\n-        boundField.write(writer, value);\n+        if (boundField.serialized) {\n+          writer.name(boundField.name);\n+          boundField.write(writer, value);\n+        }\n       }\n     } catch (IllegalAccessException e) {\n       throw new AssertionError();\n   }\n \n   static BoundField createBoundField(\n-      final MiniGson context, final Field field, final TypeToken<?> fieldType) {\n+      final MiniGson context, final Field field, final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     // special casing primitives here saves ~5% on Android...\n-    return new BoundField(field.getName()) {\n+    return new BoundField(field.getName(), serialize, deserialize) {\n       final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n       @SuppressWarnings(\"unchecked\") // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n   }\n \n   public static class FactoryImpl implements Factory {\n-    public boolean skipField(Class<?> declaringClazz, Field f, Type declaringType) {\n-      return false;\n+    public boolean serializeField(Class<?> declaringClazz, Field f, Type declaringType) {\n+      return true;\n+    }\n+    public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaringType) {\n+      return true;\n     }\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n       Class<? super T> raw = type.getRawType();\n       Type declaredType = type.getType();\n       while (raw != Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n-          if (skipField(raw, field, declaredType)) {\n-            continue;\n+          boolean serialize = serializeField(raw, field, declaredType);\n+          boolean deserialize = deserializeField(raw, field, declaredType);\n+          if (serialize || deserialize) {\n+            field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n+            Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+            BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n+            result.put(boundField.name, boundField);\n           }\n-          field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n-          Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-          BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType));\n-          result.put(boundField.name, boundField);\n         }\n         type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw = type.getRawType();\n \n   static abstract class BoundField {\n     final String name;\n+    final boolean serialized;\n+    final boolean deserialized;\n \n-    protected BoundField(String name) {\n+    protected BoundField(String name, boolean serialized, boolean deserialized) {\n       this.name = name;\n+      this.serialized = serialized;\n+      this.deserialized = deserialized;\n     }\n \n     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n--- a/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java\n /**\n  * Adapt a map whose keys are strings.\n  */\n-final class StringToValueMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+public final class StringToValueMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n   public static final Factory FACTORY = new Factory() {\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n /**\n  * Type adapters for basic types.\n  */\n-final class TypeAdapters {\n+public final class TypeAdapters {\n   private TypeAdapters() {}\n \n   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {", "timestamp": 1312334366, "metainfo": ""}