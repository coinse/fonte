{"sha": "8383f5c7fa34ae68323fe2816ef8c1307b5d0f84", "log": "Merge pull request #769 from paniko0/master  timezones without minutes should be valid according RFC3339", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n \n     /**\n      * Parse a date from ISO-8601 formatted string. It expects a format\n-     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n      * \n      * @param date ISO string to parse in the appropriate format.\n      * @param pos The position to start parsing from, updated to where parsing stopped.\n                 offset += 1;\n             } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                 String timezoneOffset = date.substring(offset);\n+\n+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n+\n                 offset += timezoneOffset.length();\n                 // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                 if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n     assertParsed(\"1970-01-01T00:00Z\", adapter);\n     assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n     assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n+    assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n   }\n   \n   public void testDateSerialization() throws Exception {\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  */\n public final class Gson {\n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+  static final boolean DEFAULT_LENIENT = false;\n+  static final boolean DEFAULT_PRETTY_PRINT = false;\n+  static final boolean DEFAULT_ESCAPE_HTML = true;\n+  static final boolean DEFAULT_SERIALIZE_NULLS = false;\n+  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\n+  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n   private final boolean htmlSafe;\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n+  private final boolean lenient;\n \n   final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n     @SuppressWarnings(\"unchecked\")\n    */\n   public Gson() {\n     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n-        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\n-        true, false, false, LongSerializationPolicy.DEFAULT,\n-        Collections.<TypeAdapterFactory>emptyList());\n+        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n+        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n+        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n   }\n \n   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n-      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n+      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n       List<TypeAdapterFactory> typeAdapterFactories) {\n     this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.generateNonExecutableJson = generateNonExecutableGson;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n+    this.lenient = lenient;\n \n     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n \n   }\n \n   /**\n+   * Returns a new JSON writer configured for the settings on this Gson instance.\n+   */\n+  public JsonReader newJsonReader(Reader reader) {\n+    JsonReader jsonReader = new JsonReader(reader);\n+    jsonReader.setLenient(lenient);\n+    return jsonReader;\n+  }\n+\n+  /**\n    * Writes the JSON for {@code jsonElement} to {@code writer}.\n    * @throws JsonIOException if there was a problem writing to the writer\n    */\n    * @since 1.2\n    */\n   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n-    JsonReader jsonReader = new JsonReader(json);\n+    JsonReader jsonReader = newJsonReader(json);\n     Object object = fromJson(jsonReader, classOfT);\n     assertFullConsumption(object, jsonReader);\n     return Primitives.wrap(classOfT).cast(object);\n    */\n   @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n-    JsonReader jsonReader = new JsonReader(json);\n+    JsonReader jsonReader = newJsonReader(json);\n     T object = (T) fromJson(jsonReader, typeOfT);\n     assertFullConsumption(object, jsonReader);\n     return object;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n+import com.google.gson.stream.JsonReader;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n+\n+import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;\n+import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;\n+import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;\n+import static com.google.gson.Gson.DEFAULT_LENIENT;\n+import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;\n+import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;\n+import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();\n-  private boolean serializeNulls;\n+  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;\n   private String datePattern;\n   private int dateStyle = DateFormat.DEFAULT;\n   private int timeStyle = DateFormat.DEFAULT;\n-  private boolean complexMapKeySerialization;\n-  private boolean serializeSpecialFloatingPointValues;\n-  private boolean escapeHtmlChars = true;\n-  private boolean prettyPrinting;\n-  private boolean generateNonExecutableJson;\n+  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\n+  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\n+  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\n+  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;\n+  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\n+  private boolean lenient = DEFAULT_LENIENT;\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n   }\n \n   /**\n+   * By default, Gson is strict and only accepts JSON as specified by\n+   * <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. This option makes the parser\n+   * liberal in what it accepts.\n+   *\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @see JsonReader#setLenient(boolean)\n+   */\n+  public GsonBuilder setLenient() {\n+    lenient = true;\n+    return this;\n+  }\n+\n+  /**\n    * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\n    * Gson to pass-through HTML characters as is.\n    *\n \n     return new Gson(excluder, fieldNamingPolicy, instanceCreators,\n         serializeNulls, complexMapKeySerialization,\n-        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n+        generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,\n         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonArray.java\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n   }\n \n   /**\n-   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,\n+   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,\n    * the iterator navigates the elements in the order they were inserted.\n    *\n    * @return an iterator to navigate the elements of the array.\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n       TypeToken<?> fieldType, JsonAdapter annotation) {\n     Class<?> value = annotation.value();\n+    final TypeAdapter<?> typeAdapter;\n     if (TypeAdapter.class.isAssignableFrom(value)) {\n-          Class<TypeAdapter<?>> typeAdapter = (Class<TypeAdapter<?>>) value;\n-      return constructorConstructor.get(TypeToken.get(typeAdapter)).construct();\n-    }\n-    if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n-          Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n-      return constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n+      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n+    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n+      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n           .construct()\n           .create(gson, fieldType);\n+    } else {\n+      throw new IllegalArgumentException(\n+          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n     }\n \n-    throw new IllegalArgumentException(\n-        \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n+    return typeAdapter.nullSafe();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n import java.io.Reader;\n \n /**\n- * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n  * encoded value as a stream of tokens. This stream includes both literal\n  * values (strings, numbers, booleans, and nulls) as well as the begin and\n  * end delimiters of objects and arrays. The tokens are traversed in\n   }\n \n   /**\n-   * Configure this parser to be  be liberal in what it accepts. By default,\n+   * Configure this parser to be liberal in what it accepts. By default,\n    * this parser is strict and only accepts JSON as specified by <a\n    * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n    * parser to lenient causes it to ignore the following syntax errors:\n       checkLenient();\n       return peeked = PEEKED_SINGLE_QUOTED;\n     case '\"':\n-      if (stackSize == 1) {\n-        checkLenient();\n-      }\n       return peeked = PEEKED_DOUBLE_QUOTED;\n     case '[':\n       return peeked = PEEKED_BEGIN_ARRAY;\n       return peeked = PEEKED_BEGIN_OBJECT;\n     default:\n       pos--; // Don't consume the first character in a literal value.\n-    }\n-\n-    if (stackSize == 1) {\n-      checkLenient(); // Top-level value isn't an array or an object.\n     }\n \n     int result = peekKeyword();\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n \n /**\n- * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n  * encoded value to a stream, one token at a time. The stream includes both\n  * literal values (strings, numbers, booleans and nulls) as well as the begin\n  * and end delimiters of objects and arrays.\n public class JsonWriter implements Closeable, Flushable {\n \n   /*\n-   * From RFC 4627, \"All Unicode characters may be placed within the\n+   * From RFC 7159, \"All Unicode characters may be placed within the\n    * quotation marks except for the characters that must be escaped:\n    * quotation mark, reverse solidus, and the control characters\n    * (U+0000 through U+001F).\"\n   /**\n    * Configure this writer to relax its syntax rules. By default, this writer\n    * only emits well-formed JSON as specified by <a\n-   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the writer\n+   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n    * to lenient permits the following:\n    * <ul>\n    *   <li>Top-level values of any type. With strict writing, the top-level\n    * bracket.\n    */\n   private JsonWriter open(int empty, String openBracket) throws IOException {\n-    beforeValue(true);\n+    beforeValue();\n     push(empty);\n     out.write(openBracket);\n     return this;\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     string(value);\n     return this;\n   }\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.append(value);\n     return this;\n   }\n         return this; // skip the name and the value\n       }\n     }\n-    beforeValue(false);\n+    beforeValue();\n     out.write(\"null\");\n     return this;\n   }\n    */\n   public JsonWriter value(boolean value) throws IOException {\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.write(value ? \"true\" : \"false\");\n     return this;\n   }\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.append(Double.toString(value));\n     return this;\n   }\n    */\n   public JsonWriter value(long value) throws IOException {\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.write(Long.toString(value));\n     return this;\n   }\n         && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n-    beforeValue(false);\n+    beforeValue();\n     out.append(string);\n     return this;\n   }\n    * Inserts any necessary separators and whitespace before a literal value,\n    * inline array, or inline object. Also adjusts the stack to expect either a\n    * closing bracket or another element.\n-   *\n-   * @param root true if the value is a new array or object, the two values\n-   *     permitted as top-level elements.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private void beforeValue(boolean root) throws IOException {\n+  private void beforeValue() throws IOException {\n     switch (peek()) {\n     case NONEMPTY_DOCUMENT:\n       if (!lenient) {\n       }\n       // fall-through\n     case EMPTY_DOCUMENT: // first in document\n-      if (!lenient && !root) {\n-        throw new IllegalStateException(\n-            \"JSON must start with an array or an object.\");\n-      }\n       replaceTop(NONEMPTY_DOCUMENT);\n       break;\n \n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n     assertFalse(json.contains(\"jsonAdapter\"));\n   }\n \n+  public void testNullSafeObjectFromJson() {\n+    Gson gson = new Gson();\n+    NullableClass fromJson = gson.fromJson(\"null\", NullableClass.class);\n+    assertNull(fromJson);\n+  }\n+\n   @JsonAdapter(A.JsonAdapter.class)\n   private static class A {\n     final String value;\n     }\n   }\n \n+  @JsonAdapter(value = NullableClassJsonAdapter.class)\n+  private static class NullableClass {\n+  }\n+\n+  private static class NullableClassJsonAdapter extends TypeAdapter<NullableClass> {\n+    @Override\n+    public void write(JsonWriter out, NullableClass value) throws IOException {\n+      out.value(\"nullable\");\n+    }\n+\n+    @Override\n+    public NullableClass read(JsonReader in) throws IOException {\n+      in.nextString();\n+      return new NullableClass();\n+    }\n+  }\n+\n   @JsonAdapter(FooJsonAdapter.class)\n   private static enum Foo { BAR, BAZ }\n   private static class FooJsonAdapter extends TypeAdapter<Foo> {\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n       this.part2 = part2;\n     }\n   }\n+\n+  public void testJsonAdapterWrappedInNullSafeAsRequested() {\n+    Gson gson = new Gson();\n+    String fromJson = \"{'part':null}\";\n+\n+    GadgetWithOptionalPart gadget = gson.fromJson(fromJson, GadgetWithOptionalPart.class);\n+    assertNull(gadget.part);\n+\n+    String toJson = gson.toJson(gadget);\n+    assertFalse(toJson.contains(\"PartJsonFieldAnnotationAdapter\"));\n+  }\n+\n+  private static final class GadgetWithOptionalPart {\n+    @JsonAdapter(value = PartJsonFieldAnnotationAdapter.class)\n+    final Part part;\n+\n+    private GadgetWithOptionalPart(Part part) {\n+      this.part = part;\n+    }\n+  }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java\n+/*\n+ * Copyright (C) 2016 The Gson Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.reflect.TypeToken;\n+import java.util.List;\n+import junit.framework.TestCase;\n+\n+import static java.util.Collections.singletonList;\n+\n+/**\n+ * Functional tests for leniency option.\n+ */\n+public class LeniencyTest extends TestCase {\n+\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new GsonBuilder().setLenient().create();\n+  }\n+\n+  public void testLenientFromJson() {\n+    List<String> json = gson.fromJson(\"\"\n+        + \"[ # One!\\n\"\n+        + \"  'Hi' #Element!\\n\"\n+        + \"] # Array!\", new TypeToken<List<String>>() {}.getType());\n+    assertEquals(singletonList(\"Hi\"), json);\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     }\n     try {\n       new JsonReader(reader(\"\")).beginObject();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testNoTopLevelObject() {\n-    try {\n-      new JsonReader(reader(\"true\")).nextBoolean();\n       fail();\n     } catch (IOException expected) {\n     }\n     }\n   }\n \n-  public void testStrictTopLevelString() {\n-    JsonReader reader = new JsonReader(reader(\"\\\"a\\\"\"));\n-    try {\n-      reader.nextString();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testLenientTopLevelString() throws IOException {\n-    JsonReader reader = new JsonReader(reader(\"\\\"a\\\"\"));\n-    reader.setLenient(true);\n-    assertEquals(\"a\", reader.nextString());\n-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n-  }\n-\n-  public void testStrictTopLevelValueType() {\n+  public void testTopLevelValueTypes() throws IOException {\n+    JsonReader reader1 = new JsonReader(reader(\"true\"));\n+    assertTrue(reader1.nextBoolean());\n+    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());\n+\n+    JsonReader reader2 = new JsonReader(reader(\"false\"));\n+    assertFalse(reader2.nextBoolean());\n+    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());\n+\n+    JsonReader reader3 = new JsonReader(reader(\"null\"));\n+    assertEquals(JsonToken.NULL, reader3.peek());\n+    reader3.nextNull();\n+    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());\n+\n+    JsonReader reader4 = new JsonReader(reader(\"123\"));\n+    assertEquals(123, reader4.nextInt());\n+    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());\n+\n+    JsonReader reader5 = new JsonReader(reader(\"123.4\"));\n+    assertEquals(123.4, reader5.nextDouble());\n+    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());\n+\n+    JsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\n+    assertEquals(\"a\", reader6.nextString());\n+    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n+  }\n+\n+  public void testTopLevelValueTypeWithSkipValue() throws IOException {\n     JsonReader reader = new JsonReader(reader(\"true\"));\n-    try {\n-      reader.nextBoolean();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testLenientTopLevelValueType() throws IOException {\n-    JsonReader reader = new JsonReader(reader(\"true\"));\n-    reader.setLenient(true);\n-    assertEquals(true, reader.nextBoolean());\n-  }\n-\n-  public void testStrictTopLevelValueTypeWithSkipValue() {\n-    JsonReader reader = new JsonReader(reader(\"true\"));\n-    try {\n-      reader.skipValue();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n+    reader.skipValue();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n   public void testStrictNonExecutePrefix() {\n     } catch (MalformedJsonException expected) {\n     }\n   }\n-  \n+\n   public void testVeryLongQuotedString() throws IOException {\n     char[] stringChars = new char[1024 * 16];\n     Arrays.fill(stringChars, 'x');\n--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n @SuppressWarnings(\"resource\")\n public final class JsonWriterTest extends TestCase {\n \n-  public void testWrongTopLevelType() throws IOException {\n-    StringWriter stringWriter = new StringWriter();\n-    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n-    try {\n-      jsonWriter.value(\"a\");\n+  public void testTopLevelValueTypes() throws IOException {\n+    StringWriter string1 = new StringWriter();\n+    JsonWriter writer1 = new JsonWriter(string1);\n+    writer1.value(true);\n+    writer1.close();\n+    assertEquals(\"true\", string1.toString());\n+\n+    StringWriter string2 = new StringWriter();\n+    JsonWriter writer2 = new JsonWriter(string2);\n+    writer2.nullValue();\n+    writer2.close();\n+    assertEquals(\"null\", string2.toString());\n+\n+    StringWriter string3 = new StringWriter();\n+    JsonWriter writer3 = new JsonWriter(string3);\n+    writer3.value(123);\n+    writer3.close();\n+    assertEquals(\"123\", string3.toString());\n+\n+    StringWriter string4 = new StringWriter();\n+    JsonWriter writer4 = new JsonWriter(string4);\n+    writer4.value(123.4);\n+    writer4.close();\n+    assertEquals(\"123.4\", string4.toString());\n+\n+    StringWriter string5 = new StringWriter();\n+    JsonWriter writert = new JsonWriter(string5);\n+    writert.value(\"a\");\n+    writert.close();\n+    assertEquals(\"\\\"a\\\"\", string5.toString());\n+  }\n+\n+  public void testInvalidTopLevelTypes() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.name(\"hello\");\n+    try {\n+      jsonWriter.value(\"world\");\n       fail();\n     } catch (IllegalStateException expected) {\n     }", "timestamp": 1454473432, "metainfo": ""}