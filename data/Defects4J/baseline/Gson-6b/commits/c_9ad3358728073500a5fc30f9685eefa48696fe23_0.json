{"sha": "9ad3358728073500a5fc30f9685eefa48696fe23", "log": "Document RuntimeTypeAdapter", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapter.java\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n-public final class RuntimeTypeAdapter<T>\n-    implements JsonSerializer<T>, JsonDeserializer<T> {\n-\n+/**\n+ * Adapts values whose runtime type may differ from their declaration type. This\n+ * is necessary when a field's type is not the same type that GSON should create\n+ * when deserializing that field. For example, consider these types:\n+ * <pre>   {@code\n+ *   abstract class Shape {\n+ *     int x;\n+ *     int y;\n+ *   }\n+ *   class Circle extends Shape {\n+ *     int radius;\n+ *   }\n+ *   class Rectangle extends Shape {\n+ *     int width;\n+ *     int height;\n+ *   }\n+ *   class Diamond extends Shape {\n+ *     int width;\n+ *     int height;\n+ *   }\n+ *   class Drawing {\n+ *     Shape bottomShape;\n+ *     Shape topShape;\n+ *   }\n+ * }</pre>\n+ * <p>Without additional type information, the serialized JSON is ambiguous. Is\n+ * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code\n+ *   {\n+ *     \"bottomShape\": {\n+ *       \"width\": 10,\n+ *       \"height\": 5,\n+ *       \"x\": 0,\n+ *       \"y\": 0\n+ *     },\n+ *     \"topShape\": {\n+ *       \"radius\": 2,\n+ *       \"x\": 4,\n+ *       \"y\": 1\n+ *     }\n+ *   }}</pre>\n+ * This class addresses this problem by adding type information to the\n+ * serialized JSON and honoring that type information when the JSON is\n+ * deserialized: <pre>   {@code\n+ *   {\n+ *     \"bottomShape\": {\n+ *       \"type\": \"Diamond\",\n+ *       \"width\": 10,\n+ *       \"height\": 5,\n+ *       \"x\": 0,\n+ *       \"y\": 0\n+ *     },\n+ *     \"topShape\": {\n+ *       \"type\": \"Circle\",\n+ *       \"radius\": 2,\n+ *       \"x\": 4,\n+ *       \"y\": 1\n+ *     }\n+ *   }}</pre>\n+ * Both the type field name ({@code \"type\"}) and the type labels ({@code\n+ * \"Rectangle\"}) are configurable.\n+ *\n+ * <h3>Registering Types</h3>\n+ * Create a {@code RuntimeTypeAdapter} by passing the base type and type field\n+ * name to the {@link #create} factory method. If you don't supply an explicit\n+ * type field name, {@code \"type\"} will be used. <pre>   {@code\n+ *   RuntimeTypeAdapter<Shape> shapeAdapter\n+ *       = RuntimeTypeAdapter.create(Shape.class, \"type\");\n+ * }</pre>\n+ * Next register all of your subtypes. Every subtype must be explicitly\n+ * registered. This protects your application from injection attacks. If you\n+ * don't supply an explicit type label, the type's simple name will be used.\n+ * <pre>   {@code\n+ *   shapeAdapter.registerSubtype(Rectangle.class, \"Rectangle\");\n+ *   shapeAdapter.registerSubtype(Circle.class, \"Circle\");\n+ *   shapeAdapter.registerSubtype(Diamond.class, \"Diamond\");\n+ * }</pre>\n+ * Finally, register the type adapter in your application's GSON builder:\n+ * <pre>   {@code\n+ *   Gson gson = new GsonBuilder()\n+ *       .registerTypeAdapter(Shape.class, shapeAdapter)\n+ *       .create();\n+ * }</pre>\n+ * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n+ *   RuntimeTypeAdapter<Shape> shapeAdapter = RuntimeTypeAdapter.create(Shape.class)\n+ *       .registerSubtype(Rectangle.class)\n+ *       .registerSubtype(Circle.class)\n+ *       .registerSubtype(Diamond.class);\n+ * }</pre>\n+ */\n+public final class RuntimeTypeAdapter<T> implements JsonSerializer<T>, JsonDeserializer<T> {\n   private final Class<?> baseType;\n   private final String typeFieldName;\n   private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();\n   private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();\n \n-  public RuntimeTypeAdapter(Class<?> baseType, String typeFieldName) {\n+  private RuntimeTypeAdapter(Class<?> baseType, String typeFieldName) {\n+    if (typeFieldName == null || baseType == null) {\n+      throw new NullPointerException();\n+    }\n     this.baseType = baseType;\n     this.typeFieldName = typeFieldName;\n   }\n \n+  /**\n+   * Creates a new runtime type adapter for {@code c} using {@code \"type\"} as\n+   * the type field name.\n+   */\n   public static <T> RuntimeTypeAdapter<T> create(Class<T> c) {\n-    return new RuntimeTypeAdapter<T>(c, \"type\");\n-  }\n-\n+    return create(c, \"type\");\n+  }\n+\n+  /**\n+   * Creates a new runtime type adapter using for {@code c} using {@code\n+   * typeFieldName} as the type field name. Type field names are case sensitive.\n+   */\n   public static <T> RuntimeTypeAdapter<T> create(Class<T> c, String typeFieldName) {\n     return new RuntimeTypeAdapter<T>(c, typeFieldName);\n   }\n \n+  /**\n+   * Registers {@code type} identified by {@code label}. Labels are case\n+   * sensitive.\n+   *\n+   * @throws IllegalArgumentException if either {@code type} or {@code label}\n+   *     have already been registered on this type adapter.\n+   */\n   public RuntimeTypeAdapter<T> registerSubtype(Class<? extends T> type, String label) {\n+    if (type == null || label == null) {\n+      throw new NullPointerException();\n+    }\n     if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\n       throw new IllegalArgumentException(\"types and labels must be unique\");\n     }\n     return this;\n   }\n \n+  /**\n+   * Registers {@code type} identified by its {@link Class#getSimpleName simple\n+   * name}. Labels are case sensitive.\n+   *\n+   * @throws IllegalArgumentException if either {@code type} or its simple name\n+   *     have already been registered on this type adapter.\n+   */\n   public RuntimeTypeAdapter<T> registerSubtype(Class<? extends T> type) {\n     return registerSubtype(type, type.getSimpleName());\n   }\n     Class<?> srcType = src.getClass();\n     String label = subtypeToLabel.get(srcType);\n     if (label == null) {\n-      throw new IllegalArgumentException(\"cannot serialize \" + srcType.getName()\n+      throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n           + \"; did you forget to register a subtype?\");\n     }\n     JsonElement serialized = context.serialize(src, srcType);\n     final JsonObject jsonObject = serialized.getAsJsonObject();\n     if (jsonObject.has(typeFieldName)) {\n-      throw new IllegalArgumentException(\"cannot serialize \" + srcType.getName()\n+      throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n           + \" because it already defines a field named \" + typeFieldName);\n     }\n     JsonObject clone = new JsonObject();\n--- a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterTest.java\n+++ b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterTest.java\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n import junit.framework.TestCase;\n \n public final class RuntimeTypeAdapterTest extends TestCase {\n     assertEquals(\"Jesse\", deserialized.ownerName);\n   }\n \n+  public void testNullBaseType() {\n+    try {\n+      RuntimeTypeAdapter.create(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullTypeFieldName() {\n+    try {\n+      RuntimeTypeAdapter.create(BillingInstrument.class, null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullSubtype() {\n+    RuntimeTypeAdapter<BillingInstrument> rta = RuntimeTypeAdapter.create(BillingInstrument.class);\n+    try {\n+      rta.registerSubtype(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullLabel() {\n+    RuntimeTypeAdapter<BillingInstrument> rta = RuntimeTypeAdapter.create(BillingInstrument.class);\n+    try {\n+      rta.registerSubtype(CreditCard.class, null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testDuplicateSubtype() {\n+    RuntimeTypeAdapter<BillingInstrument> rta = RuntimeTypeAdapter.create(BillingInstrument.class);\n+    rta.registerSubtype(CreditCard.class, \"CC\");\n+    try {\n+      rta.registerSubtype(CreditCard.class, \"Visa\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testDuplicateLabel() {\n+    RuntimeTypeAdapter<BillingInstrument> rta = RuntimeTypeAdapter.create(BillingInstrument.class);\n+    rta.registerSubtype(CreditCard.class, \"CC\");\n+    try {\n+      rta.registerSubtype(BankTransfer.class, \"CC\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testDeserializeMissingTypeField() {\n+    Object billingAdapter = RuntimeTypeAdapter.create(BillingInstrument.class)\n+        .registerSubtype(CreditCard.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.fromJson(\"{ownerName:'Jesse'}\", BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testDeserializeMissingSubtype() {\n+    Object billingAdapter = RuntimeTypeAdapter.create(BillingInstrument.class)\n+        .registerSubtype(BankTransfer.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.fromJson(\"{type:'CreditCard',ownerName:'Jesse'}\", BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testSerializeMissingSubtype() {\n+    Object billingAdapter = RuntimeTypeAdapter.create(BillingInstrument.class)\n+        .registerSubtype(BankTransfer.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testSerializeCollidingTypeFieldName() {\n+    Object billingAdapter = RuntimeTypeAdapter.create(BillingInstrument.class, \"cvv\")\n+        .registerSubtype(CreditCard.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  static class BillingInstrument {\n+    private final String ownerName;\n+    BillingInstrument(String ownerName) {\n+      this.ownerName = ownerName;\n+    }\n+  }\n+\n   static class CreditCard extends BillingInstrument {\n     int cvv;\n-\n     CreditCard(String ownerName, int cvv) {\n       super(ownerName);\n       this.cvv = cvv;\n     }\n   }\n \n-  static class BillingInstrument {\n-    private final String ownerName;\n-\n-    BillingInstrument(String ownerName) {\n-      this.ownerName = ownerName;\n+  static class BankTransfer extends BillingInstrument {\n+    int bankAccount;\n+    BankTransfer(String ownerName, int bankAccount) {\n+      super(ownerName);\n+      this.bankAccount = bankAccount;\n     }\n   }\n }", "timestamp": 1307338813, "metainfo": ""}