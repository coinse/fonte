{"sha": "6dc6b4be9208221caad81b52aec665f133b5e9af", "log": "Fix object leak from ThreadLocal.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     }\n \n     Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n+    boolean requiresThreadLocalCleanup = false;\n     if (threadCalls == null) {\n       threadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n       calls.set(threadCalls);\n+      requiresThreadLocalCleanup = true;\n     }\n \n     // the key and value type parameters always agree\n       return ongoingCall;\n     }\n \n-    FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n-    threadCalls.put(type, call);\n     try {\n+      FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n+      threadCalls.put(type, call);\n+\n       for (TypeAdapterFactory factory : factories) {\n         TypeAdapter<T> candidate = factory.create(this, type);\n         if (candidate != null) {\n       throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n       threadCalls.remove(type);\n+\n+      if (requiresThreadLocalCleanup) {\n+        calls.remove();\n+      }\n     }\n   }\n ", "timestamp": 1358201128, "metainfo": ""}