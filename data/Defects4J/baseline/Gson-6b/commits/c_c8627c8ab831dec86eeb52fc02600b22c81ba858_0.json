{"sha": "c8627c8ab831dec86eeb52fc02600b22c81ba858", "log": "Update reader and writer for RFC 7159.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n import java.io.Reader;\n \n /**\n- * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n  * encoded value as a stream of tokens. This stream includes both literal\n  * values (strings, numbers, booleans, and nulls) as well as the begin and\n  * end delimiters of objects and arrays. The tokens are traversed in\n       checkLenient();\n       return peeked = PEEKED_SINGLE_QUOTED;\n     case '\"':\n-      if (stackSize == 1) {\n-        checkLenient();\n-      }\n       return peeked = PEEKED_DOUBLE_QUOTED;\n     case '[':\n       return peeked = PEEKED_BEGIN_ARRAY;\n       return peeked = PEEKED_BEGIN_OBJECT;\n     default:\n       pos--; // Don't consume the first character in a literal value.\n-    }\n-\n-    if (stackSize == 1) {\n-      checkLenient(); // Top-level value isn't an array or an object.\n     }\n \n     int result = peekKeyword();\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n \n /**\n- * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n  * encoded value to a stream, one token at a time. The stream includes both\n  * literal values (strings, numbers, booleans and nulls) as well as the begin\n  * and end delimiters of objects and arrays.\n public class JsonWriter implements Closeable, Flushable {\n \n   /*\n-   * From RFC 4627, \"All Unicode characters may be placed within the\n+   * From RFC 7159, \"All Unicode characters may be placed within the\n    * quotation marks except for the characters that must be escaped:\n    * quotation mark, reverse solidus, and the control characters\n    * (U+0000 through U+001F).\"\n   /**\n    * Configure this writer to relax its syntax rules. By default, this writer\n    * only emits well-formed JSON as specified by <a\n-   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the writer\n+   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n    * to lenient permits the following:\n    * <ul>\n    *   <li>Top-level values of any type. With strict writing, the top-level\n    * bracket.\n    */\n   private JsonWriter open(int empty, String openBracket) throws IOException {\n-    beforeValue(true);\n+    beforeValue();\n     push(empty);\n     out.write(openBracket);\n     return this;\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     string(value);\n     return this;\n   }\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.append(value);\n     return this;\n   }\n         return this; // skip the name and the value\n       }\n     }\n-    beforeValue(false);\n+    beforeValue();\n     out.write(\"null\");\n     return this;\n   }\n    */\n   public JsonWriter value(boolean value) throws IOException {\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.write(value ? \"true\" : \"false\");\n     return this;\n   }\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.append(Double.toString(value));\n     return this;\n   }\n    */\n   public JsonWriter value(long value) throws IOException {\n     writeDeferredName();\n-    beforeValue(false);\n+    beforeValue();\n     out.write(Long.toString(value));\n     return this;\n   }\n         && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n-    beforeValue(false);\n+    beforeValue();\n     out.append(string);\n     return this;\n   }\n    * Inserts any necessary separators and whitespace before a literal value,\n    * inline array, or inline object. Also adjusts the stack to expect either a\n    * closing bracket or another element.\n-   *\n-   * @param root true if the value is a new array or object, the two values\n-   *     permitted as top-level elements.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private void beforeValue(boolean root) throws IOException {\n+  private void beforeValue() throws IOException {\n     switch (peek()) {\n     case NONEMPTY_DOCUMENT:\n       if (!lenient) {\n       }\n       // fall-through\n     case EMPTY_DOCUMENT: // first in document\n-      if (!lenient && !root) {\n-        throw new IllegalStateException(\n-            \"JSON must start with an array or an object.\");\n-      }\n       replaceTop(NONEMPTY_DOCUMENT);\n       break;\n \n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     }\n     try {\n       new JsonReader(reader(\"\")).beginObject();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testNoTopLevelObject() {\n-    try {\n-      new JsonReader(reader(\"true\")).nextBoolean();\n       fail();\n     } catch (IOException expected) {\n     }\n     }\n   }\n \n-  public void testStrictTopLevelString() {\n-    JsonReader reader = new JsonReader(reader(\"\\\"a\\\"\"));\n-    try {\n-      reader.nextString();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testLenientTopLevelString() throws IOException {\n-    JsonReader reader = new JsonReader(reader(\"\\\"a\\\"\"));\n-    reader.setLenient(true);\n-    assertEquals(\"a\", reader.nextString());\n-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n-  }\n-\n-  public void testStrictTopLevelValueType() {\n+  public void testTopLevelValueTypes() throws IOException {\n+    JsonReader reader1 = new JsonReader(reader(\"true\"));\n+    assertTrue(reader1.nextBoolean());\n+    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());\n+\n+    JsonReader reader2 = new JsonReader(reader(\"false\"));\n+    assertFalse(reader2.nextBoolean());\n+    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());\n+\n+    JsonReader reader3 = new JsonReader(reader(\"null\"));\n+    assertEquals(JsonToken.NULL, reader3.peek());\n+    reader3.nextNull();\n+    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());\n+\n+    JsonReader reader4 = new JsonReader(reader(\"123\"));\n+    assertEquals(123, reader4.nextInt());\n+    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());\n+\n+    JsonReader reader5 = new JsonReader(reader(\"123.4\"));\n+    assertEquals(123.4, reader5.nextDouble());\n+    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());\n+\n+    JsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\n+    assertEquals(\"a\", reader6.nextString());\n+    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n+  }\n+\n+  public void testTopLevelValueTypeWithSkipValue() throws IOException {\n     JsonReader reader = new JsonReader(reader(\"true\"));\n-    try {\n-      reader.nextBoolean();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n-  }\n-\n-  public void testLenientTopLevelValueType() throws IOException {\n-    JsonReader reader = new JsonReader(reader(\"true\"));\n-    reader.setLenient(true);\n-    assertEquals(true, reader.nextBoolean());\n-  }\n-\n-  public void testStrictTopLevelValueTypeWithSkipValue() {\n-    JsonReader reader = new JsonReader(reader(\"true\"));\n-    try {\n-      reader.skipValue();\n-      fail();\n-    } catch (IOException expected) {\n-    }\n+    reader.skipValue();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n   public void testStrictNonExecutePrefix() {\n     } catch (MalformedJsonException expected) {\n     }\n   }\n-  \n+\n   public void testVeryLongQuotedString() throws IOException {\n     char[] stringChars = new char[1024 * 16];\n     Arrays.fill(stringChars, 'x');\n--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n @SuppressWarnings(\"resource\")\n public final class JsonWriterTest extends TestCase {\n \n-  public void testWrongTopLevelType() throws IOException {\n-    StringWriter stringWriter = new StringWriter();\n-    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n-    try {\n-      jsonWriter.value(\"a\");\n+  public void testTopLevelValueTypes() throws IOException {\n+    StringWriter string1 = new StringWriter();\n+    JsonWriter writer1 = new JsonWriter(string1);\n+    writer1.value(true);\n+    writer1.close();\n+    assertEquals(\"true\", string1.toString());\n+\n+    StringWriter string2 = new StringWriter();\n+    JsonWriter writer2 = new JsonWriter(string2);\n+    writer2.nullValue();\n+    writer2.close();\n+    assertEquals(\"null\", string2.toString());\n+\n+    StringWriter string3 = new StringWriter();\n+    JsonWriter writer3 = new JsonWriter(string3);\n+    writer3.value(123);\n+    writer3.close();\n+    assertEquals(\"123\", string3.toString());\n+\n+    StringWriter string4 = new StringWriter();\n+    JsonWriter writer4 = new JsonWriter(string4);\n+    writer4.value(123.4);\n+    writer4.close();\n+    assertEquals(\"123.4\", string4.toString());\n+\n+    StringWriter string5 = new StringWriter();\n+    JsonWriter writert = new JsonWriter(string5);\n+    writert.value(\"a\");\n+    writert.close();\n+    assertEquals(\"\\\"a\\\"\", string5.toString());\n+  }\n+\n+  public void testInvalidTopLevelTypes() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.name(\"hello\");\n+    try {\n+      jsonWriter.value(\"world\");\n       fail();\n     } catch (IllegalStateException expected) {\n     }", "timestamp": 1453147653, "metainfo": ""}