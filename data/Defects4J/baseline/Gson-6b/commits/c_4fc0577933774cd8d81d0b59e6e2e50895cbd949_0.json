{"sha": "4fc0577933774cd8d81d0b59e6e2e50895cbd949", "log": "Split up benchmarks into specific types for serialization and deserialization.", "commit": "\n--- /dev/null\n+++ b/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitivesDeserializationBenchmark.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.metrics;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.lang.reflect.Field;\n+\n+import com.google.caliper.Runner;\n+import com.google.caliper.SimpleBenchmark;\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * Caliper based micro benchmarks for Gson\n+ *\n+ * @author Inderjeet Singh\n+ * @author Jesse Wilson\n+ * @author Joel Leitch\n+ */\n+public class BagOfPrimitivesDeserializationBenchmark extends SimpleBenchmark {\n+\n+  private Gson gson;\n+  private String json;\n+\n+  public static void main(String[] args) {\n+    Runner.main(BagOfPrimitivesDeserializationBenchmark.class, args);\n+  }\n+  \n+  @Override\n+  protected void setUp() throws Exception {\n+    this.gson = new Gson();\n+    BagOfPrimitives bag = new BagOfPrimitives(10L, 1, false, \"foo\");\n+    this.json = gson.toJson(bag);\n+  }\n+\n+  /** \n+   * Benchmark to measure Gson performance for deserializing an object\n+   */\n+  public void timeBagOfPrimitivesDefault(int reps) {\n+    for (int i=0; i<reps; ++i) {\n+      gson.fromJson(json, BagOfPrimitives.class);\n+    }\n+  }\n+\n+  /**\n+   * Benchmark to measure deserializing objects by hand\n+   */\n+  public void timeBagOfPrimitivesStreaming(int reps) throws IOException {\n+    for (int i=0; i<reps; ++i) {\n+      StringReader reader = new StringReader(json);\n+      JsonReader jr = new JsonReader(reader);\n+      jr.beginObject();\n+      long longValue = 0;\n+      int intValue = 0;\n+      boolean booleanValue = false;\n+      String stringValue = null;\n+      while(jr.hasNext()) {\n+        String name = jr.nextName();\n+        if (name.equals(\"longValue\")) {\n+          longValue = jr.nextLong();\n+        } else if (name.equals(\"intValue\")) {\n+          intValue = jr.nextInt();\n+        } else if (name.equals(\"booleanValue\")) {\n+          booleanValue = jr.nextBoolean();\n+        } else if (name.equals(\"stringValue\")) {\n+          stringValue = jr.nextString();\n+        } else {\n+          throw new IOException(\"Unexpected name: \" + name);\n+        }\n+      }\n+      jr.endObject();\n+      new BagOfPrimitives(longValue, intValue, booleanValue, stringValue);\n+    }\n+  }\n+\n+  /**\n+   * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\n+   * setting object values by reflection. We should strive to reduce the discrepancy between this\n+   * and {@link #timeBagOfPrimitivesDefault(int)} .\n+   */\n+  public void timeBagOfPrimitivesReflectionStreaming(int reps) throws Exception {\n+    for (int i=0; i<reps; ++i) {\n+      StringReader reader = new StringReader(json);\n+      JsonReader jr = new JsonReader(reader);\n+      jr.beginObject();\n+      BagOfPrimitives bag = new BagOfPrimitives();\n+      while(jr.hasNext()) {\n+        String name = jr.nextName();\n+        for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\n+          if (field.getName().equals(name)) {\n+            Class<?> fieldType = field.getType();\n+            if (fieldType.equals(long.class)) {\n+              field.setLong(bag, jr.nextLong());\n+            } else if (fieldType.equals(int.class)) {\n+              field.setInt(bag, jr.nextInt());\n+            } else if (fieldType.equals(boolean.class)) {\n+              field.setBoolean(bag, jr.nextBoolean());\n+            } else if (fieldType.equals(String.class)) {\n+              field.set(bag, jr.nextString());\n+            } else {\n+              throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\n+            }\n+          }\n+        }\n+      }\n+      jr.endObject();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.metrics;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.google.caliper.Runner;\n+import com.google.caliper.SimpleBenchmark;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * Caliper based micro benchmarks for Gson\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class CollectionsDeserializationBenchmark extends SimpleBenchmark {\n+\n+  private static final Type LIST_TYPE = new TypeToken<List<BagOfPrimitives>>(){}.getType();\n+  private Gson gson;\n+  private String json;\n+\n+  public static void main(String[] args) {\n+    Runner.main(CollectionsDeserializationBenchmark.class, args);\n+  }\n+  \n+  @Override\n+  protected void setUp() throws Exception {\n+    this.gson = new Gson();\n+    List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();\n+    for (int i = 0; i < 100; ++i) {\n+      bags.add(new BagOfPrimitives(10L, 1, false, \"foo\"));\n+    }\n+    this.json = gson.toJson(bags, LIST_TYPE);\n+  }\n+\n+  /** \n+   * Benchmark to measure Gson performance for deserializing an object\n+   */\n+  public void timeCollectionsDefault(int reps) {\n+    for (int i=0; i<reps; ++i) {\n+      gson.fromJson(json, LIST_TYPE);\n+    }\n+  }\n+\n+  /**\n+   * Benchmark to measure deserializing objects by hand\n+   */\n+  public void timeCollectionsStreaming(int reps) throws IOException {\n+    for (int i=0; i<reps; ++i) {\n+      StringReader reader = new StringReader(json);\n+      JsonReader jr = new JsonReader(reader);\n+      jr.beginArray();\n+      List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();\n+      while(jr.hasNext()) {\n+        jr.beginObject();\n+        long longValue = 0;\n+        int intValue = 0;\n+        boolean booleanValue = false;\n+        String stringValue = null;\n+        while(jr.hasNext()) {\n+          String name = jr.nextName();\n+          if (name.equals(\"longValue\")) {\n+            longValue = jr.nextLong();\n+          } else if (name.equals(\"intValue\")) {\n+            intValue = jr.nextInt();\n+          } else if (name.equals(\"booleanValue\")) {\n+            booleanValue = jr.nextBoolean();\n+          } else if (name.equals(\"stringValue\")) {\n+            stringValue = jr.nextString();\n+          } else {\n+            throw new IOException(\"Unexpected name: \" + name);\n+          }\n+        }\n+        jr.endObject();\n+        bags.add(new BagOfPrimitives(longValue, intValue, booleanValue, stringValue));\n+      }\n+      jr.endArray();\n+    }\n+  }\n+\n+  /**\n+   * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\n+   * setting object values by reflection. We should strive to reduce the discrepancy between this\n+   * and {@link #timeCollectionsDefault(int)} .\n+   */\n+  public void timeCollectionsReflectionStreaming(int reps) throws Exception {\n+    for (int i=0; i<reps; ++i) {\n+      StringReader reader = new StringReader(json);\n+      JsonReader jr = new JsonReader(reader);\n+      jr.beginArray();\n+      List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();\n+      while(jr.hasNext()) {\n+        jr.beginObject();\n+        BagOfPrimitives bag = new BagOfPrimitives();\n+        while(jr.hasNext()) {\n+          String name = jr.nextName();\n+          for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\n+            if (field.getName().equals(name)) {\n+              Class<?> fieldType = field.getType();\n+              if (fieldType.equals(long.class)) {\n+                field.setLong(bag, jr.nextLong());\n+              } else if (fieldType.equals(int.class)) {\n+                field.setInt(bag, jr.nextInt());\n+              } else if (fieldType.equals(boolean.class)) {\n+                field.setBoolean(bag, jr.nextBoolean());\n+              } else if (fieldType.equals(String.class)) {\n+                field.set(bag, jr.nextString());\n+              } else {\n+                throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\n+              }\n+            }\n+          }\n+        }\n+        jr.endObject();\n+        bags.add(bag);\n+      }\n+      jr.endArray();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.metrics;\n+\n+import com.google.caliper.Param;\n+import com.google.caliper.Runner;\n+import com.google.caliper.SimpleBenchmark;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * Caliper based micro benchmarks for Gson serialization\n+ *\n+ * @author Inderjeet Singh\n+ * @author Jesse Wilson\n+ * @author Joel Leitch\n+ */\n+public class SerializationBenchmark extends SimpleBenchmark {\n+\n+  private Gson gson;\n+  private BagOfPrimitives bag;\n+  @Param\n+  private boolean pretty;\n+\n+  public static void main(String[] args) {\n+    Runner.main(SerializationBenchmark.class, args);\n+  }\n+  \n+  @Override\n+  protected void setUp() throws Exception {\n+    this.gson = pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();\n+    this.bag = new BagOfPrimitives(10L, 1, false, \"foo\");\n+  }\n+\n+  public void timeObjectSerialization(int reps) {\n+    for (int i=0; i<reps; ++i) {\n+      gson.toJson(bag);\n+    }\n+  }\n+}", "timestamp": 1296959540, "metainfo": ""}