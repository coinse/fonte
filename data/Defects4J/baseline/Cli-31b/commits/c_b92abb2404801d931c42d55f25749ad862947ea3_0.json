{"sha": "b92abb2404801d931c42d55f25749ad862947ea3", "log": "Fixed second bug where infinite loops could occur.  This  time it was over eager processing of anonymous arguments in  a group.  Test case included.  Reported by Steve Alberty  ", "commit": "\n--- a/src/java/org/apache/commons/cli2/commandline/Parser.java\n+++ b/src/java/org/apache/commons/cli2/commandline/Parser.java\n \n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.ListIterator;\n     public CommandLine parse(final String[] arguments) throws OptionException {\n         \n         // build a mutable list for the arguments\n-        final List argumentList = new LinkedList(Arrays.asList(arguments));\n+        final List argumentList = new LinkedList();\n+        \n+        // copy the arguments into the new list\n+        for (int i = 0; i < arguments.length; i++) {\n+            final String argument = arguments[i];\n+            \n+            // ensure non intern'd strings are used \n+            // so that == comparisons work as expected\n+            argumentList.add(new String(argument));\n+        }\n+        \n+        // wet up a command line for this group\n         final WriteableCommandLine commandLine =\n             new WriteableCommandLineImpl(group, new ArrayList());\n         \n         \n         // process the options as far as possible\n         final ListIterator iterator = argumentList.listIterator();\n+        Object previous = null;\n         while (group.canProcess(commandLine, iterator)) {\n+            \n+            // peek at the next item and backtrack\n+            final Object next = iterator.next();\n+            iterator.previous();\n+            \n+            // if we have just tried to process this instance\n+            if(next==previous) {\n+                // abort\n+                break;\n+            }\n+            // remember previous\n+            previous = next;\n+            \n             group.process(commandLine, iterator);\n         }\n         \n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n         final WriteableCommandLine commandLine,\n         final ListIterator arguments)\n         throws OptionException {\n+        \n+        String previous = null;\n \n         // [START process each command line token\n         while (arguments.hasNext()) {\n-       \n+            \n+            // grab the next argument\n             final String arg = (String)arguments.next();\n+            \n+            // if we have just tried to process this instance\n+            if(arg==previous) {\n+                // rollback and abort\n+                arguments.previous();\n+                break;\n+            }\n+            // remember last processed instance\n+            previous = arg;\n+            \n             final Option opt = (Option)optionMap.get(arg);\n \n             // option found\n--- a/src/test/org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.builder.ArgumentBuilder;\n import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n import org.apache.commons.cli2.builder.GroupBuilder;\n import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.SourceDestArgument;\n \n /**\n  * The first is a loop in Parser.parse() if I set a non-declared option. This \n             assertEquals(\"Unexpected -abcdef while processing ant\",e.getMessage());\n         }\n     }\n+    \n+    public void testLoopingOptionLookAlike2() {\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+        final Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();\n+        final Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\n+        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);\n+        final Group options = gbuilder.withOption(targets).create();\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        try {\n+            parser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });\n+            fail(\"OptionException\");\n+        } catch (OptionException e) {\n+            assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());\n+        }\n+    }    \n }", "timestamp": 1118873636, "metainfo": ""}