{"sha": "bb639974b0928a338b4bf60b17b1f612d619e0db", "log": "Start adding basic JSON Pointer support", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+package com.fasterxml.jackson.core;\n+\n+import com.fasterxml.jackson.core.io.NumberInput;\n+\n+/**\n+ * Implementation of\n+ * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n+ * specification.\n+ * Pointer instances can be used to locate logical JSON nodes for things like\n+ * tree traversal (see {@link TreeNode#find}) and filtering of streaming JSON content\n+ * (see {@link JsonParser#filter}).\n+ *<p>\n+ * Instances are fully immutable and can be shared, cached.\n+ * \n+ * @author Tatu Saloranta\n+ * \n+ * @since 2.3\n+ */\n+public class JsonPointer\n+{\n+    /**\n+     * Marker instance used to represent segment that matches current\n+     * node or position.\n+     */\n+    protected final static JsonPointer EMPTY = new JsonPointer();\n+    \n+    /**\n+     * Reference to rest of the pointer beyond currently matching\n+     * segment (if any); null if this pointer refers to a matching\n+     * segment.\n+     */\n+    protected final JsonPointer _nextSegment;\n+    \n+    /**\n+     * We will retain representation of the pointer, as a String,\n+     * so that {@link #toString} should be as efficient as possible.\n+     */\n+    protected final String _asString;\n+    \n+    protected final String _matchingPropertyName;\n+\n+    protected final int _matchingElementIndex;\n+\n+    /*\n+    /**********************************************************\n+    /* Cosntruction\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Constructor used for creating \"empty\" instance, used to represent\n+     * state that matches current node.\n+     */\n+    protected JsonPointer()\n+    {\n+        _nextSegment = null;\n+        _matchingPropertyName = \"\";\n+        _matchingElementIndex = -1;\n+        _asString = \"\";\n+    }\n+\n+    /**\n+     * Constructor used for creating non-empty Segments\n+     */\n+    protected JsonPointer(String fullString, String segment, JsonPointer next)\n+    {\n+        _asString = fullString;\n+        _nextSegment = next;\n+        // Ok; may always be a property\n+        _matchingPropertyName = segment;\n+        _matchingElementIndex = _parseInt(segment);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method that parses given input and construct matching pointer\n+     * instance, if it represents a valid JSON Pointer: if not, a\n+     * {@link IllegalArgumentException} is thrown.\n+     * \n+     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n+     *   expression: currently the only such expression is one that does NOT start with\n+     *   a slash ('/').\n+     */\n+    public static JsonPointer parse(String input)\n+        throws IllegalArgumentException\n+    {\n+        // First quick checks for well-known 'empty' pointer\n+        if ((input == null) || input.length() == 0) {\n+            return EMPTY;\n+        }\n+        // And then quick validity check:\n+        if (input.charAt(0) != '/') {\n+            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"\n+                    +\"\\\"\"+input+\"\\\"\");\n+        }\n+        return _parseTail(input);\n+    }\n+\n+    /*\n+    \n+    /**\n+     * Factory method that composes a pointer instance, given a set\n+     * of 'raw' segments: raw meaning that no processing will be done,\n+     * no escaping may is present.\n+     * \n+     * @param segments\n+     * \n+     * @return Constructed path instance\n+     */\n+    /* TODO!\n+    public static JsonPointer fromSegment(String... segments)\n+    {\n+        if (segments.length == 0) {\n+            return EMPTY;\n+        }\n+        JsonPointer prev = null;\n+                \n+        for (String segment : segments) {\n+            JsonPointer next = new JsonPointer()\n+        }\n+    }\n+    */\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public boolean matches() {\n+        return _nextSegment == null;\n+    }\n+    \n+    public String getMatchingProperty() {\n+        return _matchingPropertyName;\n+    }\n+\n+    public int getMatchingIndex() {\n+        return _matchingElementIndex;\n+    }\n+\n+    public boolean mayMatchProperty() {\n+        return _matchingPropertyName != null;\n+    }\n+\n+    public boolean mayMatchElement() {\n+        return _matchingElementIndex >= 0;\n+    }\n+\n+    public JsonPointer matchProperty(String name) {\n+        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n+            return null;\n+        }\n+        return _nextSegment;\n+    }\n+\n+    public JsonPointer matchElement (int index) {\n+        if ((index != _matchingElementIndex) || (index < 0)) {\n+            return null;\n+        }\n+        return _nextSegment;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard method overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString() {\n+        return _asString;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _asString.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (!(o instanceof JsonPointer)) {\n+            return false;\n+        }\n+        return _asString.equals(((JsonPointer) o)._asString);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private final static int _parseInt(String str)\n+    {\n+        final int len = str.length();\n+        if (len == 0) {\n+            return -1;\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            char c = str.charAt(i++);\n+            if (c > '9' || c < '0') {\n+                return -1;\n+            }\n+        }\n+        // for now, we'll assume 32-bit indexes are fine\n+        return NumberInput.parseInt(str);\n+    }\n+    \n+    protected static JsonPointer _parseTail(String input)\n+    {\n+        final int end = input.length();\n+\n+        // first char is the contextual slash, skip\n+        for (int i = 1; i < end; ++i) {\n+            char c = input.charAt(i++);\n+            if (c == '/') { // common case, got a segment\n+                return new JsonPointer(input, input.substring(1, i-1),\n+                        _parseTail(input.substring(i)));\n+            }\n+            // quoting is different; offline this case\n+            if (c == '~' && i < end) { // possibly, quote\n+                return _parseQuotedTail(input, i);\n+            }\n+            // otherwise, loop on\n+        }\n+        // end of the road, no escapes\n+        return new JsonPointer(input, input.substring(1), EMPTY);\n+    }\n+\n+    /**\n+     * Method called to parse tail of pointer path, when a potentially\n+     * escaped character has been seen.\n+     * \n+     * @param input Full input for the tail being parsed\n+     * @param i Offset to character after tilde\n+     */\n+    protected static JsonPointer _parseQuotedTail(String input, int i)\n+    {\n+        final int end = input.length();\n+        StringBuilder sb = new StringBuilder(Math.max(16, end));\n+        if (i > 2) {\n+            sb.append(input, 1, i-1);\n+        }\n+        _appendEscape(sb, input.charAt(i++));\n+        while (i < end) {\n+            char c = input.charAt(i++);\n+            if (c == '/') { // end is nigh!\n+                return new JsonPointer(input, sb.toString(),\n+                        _parseTail(input.substring(i)));\n+            }\n+            if (c == '~' && i < end) {\n+                _appendEscape(sb, c);\n+                continue;\n+            }\n+            sb.append(c);\n+        }\n+        // end of the road, last segment\n+        return new JsonPointer(input, sb.toString(), EMPTY);\n+    }\n+    \n+    private static void _appendEscape(StringBuilder sb, char c)\n+    {\n+        if (c == '0') {\n+            c = '~';\n+        } else if ( c == '1') {\n+            c = '/';\n+        } else {\n+            sb.append('~');\n+        }\n+        sb.append(c);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n  * than mutable trees. It should also be possible to move actual\n  * Tree Model implementation out of databind package eventually\n  * (Jackson 3?).\n+ * \n+ * @since 2.2\n  */\n public interface TreeNode\n {\n      * @since 2.2\n      */\n     boolean isObject();\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic traversal through structured entries (Arrays, Objects)\n      * @since 2.2\n      */\n     Iterator<String> fieldNames();\n+\n+    /**\n+     * Method for traversing node using given JSON Pointer instance\n+     * \n+     * @return Node that matches given JSON Pointer: if no match exists,\n+     *   will return a node for which {@link TreeNode#isMissingNode()} returns\n+     *   true.\n+     * \n+     * @since 2.3\n+     */\n+    <T extends TreeNode> T find(JsonPointer ptr);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n      * now expect a value\n      */\n     protected boolean _gotName;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle", "timestamp": 1377924313, "metainfo": ""}