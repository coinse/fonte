{"sha": "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5", "log": "Fix Checkstyle: Format for 120 line length.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n /**\n  * The format specification of a CSV file.\n- * \n+ *\n  * This class is immutable.\n  */\n public class CSVFormat implements Serializable {\n      * locale dependent, it might be necessary to customize this format to accomodate to your regional settings.\n      * <p/>\n      * For example for parsing or generating a CSV file on a French system the following format will be used:\n-     * \n+     *\n      * <pre>\n      * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n      * </pre>\n      * a tab-delimited format with a LF character as the line separator. Values are not quoted and special characters\n      * are escaped with '\\'.\n      * \n-     * @see <a\n-     *      href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n+     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n+     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n             PRISTINE\n \n     /**\n      * Creates a customized CSV format.\n-     * \n+     *\n      * @param delimiter\n      *            the char used for value separation\n      * @param encapsulator\n \n     /**\n      * Returns true if the given character is a line break character.\n-     * \n+     *\n      * @param c\n      *            the character to check\n-     * \n+     *\n      * @return true if <code>c</code> is a line break character\n      */\n     private static boolean isLineBreak(char c) {\n \n     /**\n      * Returns the character delimiting the values (typically ';', ',' or '\\t').\n-     * \n+     *\n      * @return the delimiter character\n      */\n     public char getDelimiter() {\n \n     /**\n      * Returns a copy of this format using the specified delimiter character.\n-     * \n+     *\n      * @param delimiter\n      *            the delimiter character\n      * @return A copy of this format using the specified delimiter character\n \n     /**\n      * Returns the character used to encapsulate values containing special characters.\n-     * \n+     *\n      * @return the encapsulator character\n      */\n     public char getEncapsulator() {\n \n     /**\n      * Returns a copy of this format using the specified encapsulator character.\n-     * \n+     *\n      * @param encapsulator\n      *            the encapsulator character\n      * @return A copy of this format using the specified encapsulator character\n \n     /**\n      * Returns whether an encapsulator has been defined.\n-     * \n+     *\n      * @return {@code true} if an encapsulator is defined\n      */\n     public boolean isEncapsulating() {\n \n     /**\n      * Returns the character marking the start of a line comment.\n-     * \n+     *\n      * @return the comment start marker.\n      */\n     public char getCommentStart() {\n \n     /**\n      * Returns a copy of this format using the specified character as the comment start marker.\n-     * \n+     *\n      * Note that the comment introducer character is only recognised at the start of a line.\n-     * \n+     *\n      * @param commentStart\n      *            the comment start marker\n      * @return A copy of this format using the specified character as the comment start marker\n \n     /**\n      * Specifies whether comments are supported by this format.\n-     * \n+     *\n      * Note that the comment introducer character is only recognised at the start of a line.\n-     * \n+     *\n      * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n      */\n     public boolean isCommentingEnabled() {\n \n     /**\n      * Returns the escape character.\n-     * \n+     *\n      * @return the escape character\n      */\n     public char getEscape() {\n \n     /**\n      * Returns a copy of this format using the specified escape character.\n-     * \n+     *\n      * @param escape\n      *            the escape character\n      * @return A copy of this format using the specified escape character\n \n     /**\n      * Returns whether escape are being processed.\n-     * \n+     *\n      * @return {@code true} if escapes are processed\n      */\n     public boolean isEscaping() {\n \n     /**\n      * Specifies whether spaces around values are ignored when parsing input.\n-     * \n+     *\n      * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n      *         value.\n      */\n \n     /**\n      * Returns a copy of this format with the specified trimming behavior.\n-     * \n+     *\n      * @param surroundingSpacesIgnored\n      *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n      *            spaces as is.\n \n     /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n-     * \n+     *\n      * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n      *         records.\n      */\n \n     /**\n      * Returns a copy of this format with the specified empty line skipping behavior.\n-     * \n+     *\n      * @param emptyLinesIgnored\n      *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n      *            <tt>false</tt> to translate empty lines to empty records.\n \n     /**\n      * Returns the line separator delimiting output records.\n-     * \n+     *\n      * @return the line separator\n      */\n     public String getLineSeparator() {\n \n     /**\n      * Returns a copy of this format using the specified output line separator.\n-     * \n+     *\n      * @param lineSeparator\n      *            the line separator to be used for output.\n-     * \n+     *\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n     /**\n      * Returns a copy of this format using the specified header. The header can either be parsed automatically from the\n      * input file with:\n-     * \n+     *\n      * <pre>\n      * CSVFormat format = aformat.withHeader();\n      * </pre>\n-     * \n+     *\n      * or specified manually with:\n-     * \n+     *\n      * <pre>\n      * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n      * </pre>\n-     * \n+     *\n      * @param header\n      *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-     * \n+     *\n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(String... header) {\n \n     /**\n      * Parses the specified content.\n-     * \n+     *\n      * @param in\n      *            the input stream\n      */\n \n     /**\n      * Format the specified values.\n-     * \n+     *\n      * @param values\n      *            the values to format\n      */\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n      * Returns the next token.\n      * <p/>\n      * A token corresponds to a term, a record change or an end-of-file indicator.\n-     * \n+     *\n      * @param token\n      *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n      * @return the next token found\n      * <li>end of stream has been reached (EOF)</li>\n      * <li>an unescaped delimiter has been reached (TOKEN)</li>\n      * </ul>\n-     * \n+     *\n      * @param tkn\n      *            the current token\n      * @param c\n      * <li>end of line (EORECORD)</li>\n      * </ul>\n      * <li>end of stream has been reached (EOF)</li> </ul>\n-     * \n+     *\n      * @param tkn\n      *            the current token\n      * @return a valid token object\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-\n import static org.apache.commons.csv.Token.Type.*;\n \n /**\n  * Parses CSV files according to the specified configuration.\n  *\n- * Because CSV appears in many different dialects, the parser supports many\n- * configuration settings by allowing the specification of a {@link CSVFormat}.\n- *\n- * <p>Parsing of a csv-string having tabs as separators,\n- * '\"' as an optional value encapsulator, and comments starting with '#':</p>\n+ * Because CSV appears in many different dialects, the parser supports many configuration settings by allowing the\n+ * specification of a {@link CSVFormat}.\n+ *\n+ * <p>\n+ * Parsing of a csv-string having tabs as separators, '\"' as an optional value encapsulator, and comments starting with\n+ * '#':\n+ * </p>\n+ *\n  * <pre>\n- * CSVFormat format = new CSVFormat('\\t', '\"', '#');\n- * Reader in = new StringReader(\"a\\tb\\nc\\td\");\n- * List&lt;CSVRecord> records = new CSVParser(in, format).getRecords();\n+ * CSVFormat format = new CSVFormat('\\t', '&quot;', '#');\n+ * Reader in = new StringReader(&quot;a\\tb\\nc\\td&quot;);\n+ * List&lt;CSVRecord&gt; records = new CSVParser(in, format).getRecords();\n  * </pre>\n  *\n- * <p>Parsing of a csv-string in Excel CSV format, using a for-each loop:</p>\n+ * <p>\n+ * Parsing of a csv-string in Excel CSV format, using a for-each loop:\n+ * </p>\n+ *\n  * <pre>\n  * Reader in = new StringReader(\"a;b\\nc;d\");\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n  * </pre>\n  *\n  * <p>\n- * Internal parser state is completely covered by the format\n- * and the reader-state.</p>\n- *\n- * <p>see <a href=\"package-summary.html\">package documentation</a>\n- * for more details</p>\n+ * Internal parser state is completely covered by the format and the reader-state.\n+ * </p>\n+ *\n+ * <p>\n+ * see <a href=\"package-summary.html\">package documentation</a> for more details\n+ * </p>\n  */\n public class CSVParser implements Iterable<CSVRecord> {\n \n     /**\n      * CSV parser using the default {@link CSVFormat}.\n      *\n-     * @param input a Reader containing \"csv-formatted\" input\n-     * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n+     * @param input\n+     *            a Reader containing \"csv-formatted\" input\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent\n      */\n     public CSVParser(Reader input) throws IOException {\n         this(input, CSVFormat.DEFAULT);\n     /**\n      * Customized CSV parser using the given {@link CSVFormat}\n      *\n-     * @param input    a Reader containing \"csv-formatted\" input\n-     * @param format the CSVFormat used for CSV parsing\n-     * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n+     * @param input\n+     *            a Reader containing \"csv-formatted\" input\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent\n      */\n     public CSVParser(Reader input, CSVFormat format) throws IOException {\n         format.validate();\n     /**\n      * Customized CSV parser using the given {@link CSVFormat}\n      *\n-     * @param input    a String containing \"csv-formatted\" input\n-     * @param format the CSVFormat used for CSV parsing\n-     * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n-     */\n-    public CSVParser(String input, CSVFormat format) throws IOException{\n+     * @param input\n+     *            a String containing \"csv-formatted\" input\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent\n+     */\n+    public CSVParser(String input, CSVFormat format) throws IOException {\n         this(new StringReader(input), format);\n     }\n \n-\n-    /**\n-     * Parses the CSV input according to the given format and returns the content\n-     * as an array of {@link CSVRecord} entries.\n+    /**\n+     * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n+     * entries.\n      * <p/>\n      * The returned content starts at the current parse-position in the stream.\n      *\n      * @return list of {@link CSVRecord} entries, may be empty\n-     * @throws IOException on parse error or input read-failure\n+     * @throws IOException\n+     *             on parse error or input read-failure\n      */\n     public List<CSVRecord> getRecords() throws IOException {\n         List<CSVRecord> records = new ArrayList<CSVRecord>();\n      * Parses the next record from the current point in the stream.\n      *\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n-     * @throws IOException on parse error or input read-failure\n+     * @throws IOException\n+     *             on parse error or input read-failure\n      */\n     CSVRecord getRecord() throws IOException {\n         CSVRecord result = new CSVRecord(null, headerMapping, null);\n             reusableToken.reset();\n             lexer.nextToken(reusableToken);\n             switch (reusableToken.type) {\n-                case TOKEN:\n+            case TOKEN:\n+                record.add(reusableToken.content.toString());\n+                break;\n+            case EORECORD:\n+                record.add(reusableToken.content.toString());\n+                break;\n+            case EOF:\n+                if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n-                    break;\n-                case EORECORD:\n-                    record.add(reusableToken.content.toString());\n-                    break;\n-                case EOF:\n-                    if (reusableToken.isReady) {\n-                        record.add(reusableToken.content.toString());\n-                    } else {\n-                        result = null;\n-                    }\n-                    break;\n-                case INVALID:\n-                    throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n-                case COMMENT: // Ignored currently\n-                    if (sb == null) { // first comment for this record\n-                        sb = new StringBuilder();\n-                    } else {\n-                        sb.append(\"\\n\");\n-                    }\n-                    sb.append(reusableToken.content);\n-                    reusableToken.type = TOKEN; // Read another token\n-                    break;\n+                } else {\n+                    result = null;\n+                }\n+                break;\n+            case INVALID:\n+                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+            case COMMENT: // Ignored currently\n+                if (sb == null) { // first comment for this record\n+                    sb = new StringBuilder();\n+                } else {\n+                    sb.append(\"\\n\");\n+                }\n+                sb.append(reusableToken.content);\n+                reusableToken.type = TOKEN; // Read another token\n+                break;\n             }\n         } while (reusableToken.type == TOKEN);\n \n         if (!record.isEmpty()) {\n-            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping,\n-                    sb == null ? null : sb.toString());\n+            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb == null ? null\n+                    : sb.toString());\n         }\n         return result;\n     }\n     }\n \n     /**\n-     * Returns an iterator on the records. IOExceptions occuring\n-     * during the iteration are wrapped in a RuntimeException.\n+     * Returns an iterator on the records. IOExceptions occuring during the iteration are wrapped in a\n+     * RuntimeException.\n      */\n     public Iterator<CSVRecord> iterator() {\n         return new Iterator<CSVRecord>() {\n     /**\n      * Returns the current line number in the input stream.\n      * <p/>\n-     * ATTENTION: in case your csv has multiline-values the returned\n-     * number does not correspond to the record-number\n+     * ATTENTION: in case your csv has multiline-values the returned number does not correspond to the record-number\n      *\n      * @return current line number\n      */\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n     /**\n      * Create a printer that will print values to the given stream following the CSVFormat.\n      * <p/>\n-     * Currently, only a pure encapsulation format or a pure escaping format\n-     * is supported. Hybrid formats (encapsulation and escaping with a different character) are not supported.\n-     *\n-     * @param out    stream to which to print.\n-     * @param format the CSV format. If null the default format is used ({@link CSVFormat#DEFAULT})\n-     * @throws IllegalArgumentException thrown if the parameters of the format are inconsistent\n+     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats\n+     * (encapsulation and escaping with a different character) are not supported.\n+     *\n+     * @param out\n+     *            stream to which to print.\n+     * @param format\n+     *            the CSV format. If null the default format is used ({@link CSVFormat#DEFAULT})\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent\n      */\n     public CSVPrinter(Appendable out, CSVFormat format) {\n         this.out = out;\n     }\n \n     // ======================================================\n-    //  printing implementation\n+    // printing implementation\n     // ======================================================\n \n     /**\n     }\n \n     /**\n-     * Print a single line of comma separated values.\n-     * The values will be quoted if needed.  Quotes and\n-     * newLine characters will be escaped.\n-     *\n-     * @param values values to be outputted.\n+     * Print a single line of comma separated values. The values will be quoted if needed. Quotes and newLine\n+     * characters will be escaped.\n+     *\n+     * @param values\n+     *            values to be outputted.\n      */\n     public void println(String... values) throws IOException {\n         for (String value : values) {\n         println();\n     }\n \n-\n-    /**\n-     * Put a comment on a new line among the comma separated values. Comments\n-     * will always begin on a new line and occupy a least one full line. The\n-     * character specified to start comments and a space will be inserted at\n-     * the beginning of each new line in the comment.\n+    /**\n+     * Put a comment on a new line among the comma separated values. Comments will always begin on a new line and\n+     * occupy a least one full line. The character specified to start comments and a space will be inserted at the\n+     * beginning of each new line in the comment.\n      * <p/>\n      * If comments are disabled in the current CSV format this method does nothing.\n      *\n-     * @param comment the comment to output\n+     * @param comment\n+     *            the comment to output\n      */\n     public void printComment(String comment) throws IOException {\n         if (!format.isCommentingEnabled()) {\n         for (int i = 0; i < comment.length(); i++) {\n             char c = comment.charAt(i);\n             switch (c) {\n-                case '\\r':\n-                    if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n-                        i++;\n-                    }\n+            case '\\r':\n+                if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n+                    i++;\n+                }\n                 //$FALL-THROUGH$ break intentionally excluded.\n             case '\\n':\n-                    println();\n-                    out.append(format.getCommentStart());\n-                    out.append(' ');\n-                    break;\n-                default:\n-                    out.append(c);\n-                    break;\n+                println();\n+                out.append(format.getCommentStart());\n+                out.append(' ');\n+                break;\n+            default:\n+                out.append(c);\n+                break;\n             }\n         }\n         println();\n     }\n-\n \n     private void print(CharSequence value, int offset, int len) throws IOException {\n         if (format.isEncapsulating()) {\n     }\n \n     void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n-        boolean first = newLine;  // is this the first value on this line?\n+        boolean first = newLine; // is this the first value on this line?\n         boolean quote = false;\n         int start = offset;\n         int pos = offset;\n             char c = value.charAt(pos);\n \n             // Hmmm, where did this rule come from?\n-            if (first\n-                    && (c < '0'\n-                    || (c > '9' && c < 'A')\n-                    || (c > 'Z' && c < 'a')\n-                    || (c > 'z'))) {\n+            if (first && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                 quote = true;\n                 // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n             } else if (c <= '#') {\n                 // Some other chars at the start of a value caused the parser to fail, so for now\n-                // encapsulate if we start in anything less than '#'.  We are being conservative\n+                // encapsulate if we start in anything less than '#'. We are being conservative\n                 // by including the default comment char too.\n                 quote = true;\n             } else {\n     }\n \n     /**\n-     * Print the string as the next value on the line. The value\n-     * will be escaped or encapsulated as needed if checkForEscape==true\n-     *\n-     * @param value value to be outputted.\n+     * Print the string as the next value on the line. The value will be escaped or encapsulated as needed if\n+     * checkForEscape==true\n+     *\n+     * @param value\n+     *            value to be outputted.\n      */\n     public void print(String value, boolean checkForEscape) throws IOException {\n         if (value == null) {\n     }\n \n     /**\n-     * Print the string as the next value on the line. The value\n-     * will be escaped or encapsulated as needed.\n-     *\n-     * @param value value to be outputted.\n+     * Print the string as the next value on the line. The value will be escaped or encapsulated as needed.\n+     *\n+     * @param value\n+     *            value to be outputted.\n      */\n     public void print(String value) throws IOException {\n         print(value, true);\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     /**\n      * Returns a value by index.\n      *\n-     * @param i the index of the column retrieved\n+     * @param i\n+     *            the index of the column retrieved\n      */\n     public String get(int i) {\n         return values[i];\n     /**\n      * Returns a value by name.\n      *\n-     * @param name the name of the column to be retrieved\n+     * @param name\n+     *            the name of the column to be retrieved\n      * @return the column value, or {@code null} if the column name is not found\n-     * @throws IllegalStateException if no header mapping was provided\n+     * @throws IllegalStateException\n+     *             if no header mapping was provided\n      */\n     public String get(String name) {\n         if (mapping == null) {\n     public String getComment() {\n         return comment;\n     }\n+\n     /**\n      * Returns the number of values in this record.\n      */\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n import java.io.Reader;\n \n /**\n- * A special reader decorator which supports more\n- * sophisticated access to the underlying reader object.\n+ * A special reader decorator which supports more sophisticated access to the underlying reader object.\n  * <p>\n- * In particular the reader supports a look-ahead option,\n- * which allows you to see the next char returned by\n+ * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n  * {@link #read()}.\n  */\n class ExtendedBufferedReader extends BufferedReader {\n     }\n \n     /**\n-     * Returns the last character that was read as an integer (0 to 65535). This\n-     * will be the last character returned by any of the read methods. This will\n-     * not include a character read using the {@link #peek()} method. If no\n-     * character has been read then this will return {@link #UNDEFINED}. If the\n-     * end of the stream was reached on the last read then this will return\n-     * {@link #END_OF_STREAM}.\n+     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n+     * any of the read methods. This will not include a character read using the {@link #peek()} method. If no\n+     * character has been read then this will return {@link #UNDEFINED}. If the end of the stream was reached on the\n+     * last read then this will return {@link #END_OF_STREAM}.\n      *\n      * @return the last character that was read\n      */\n             for (int i = offset; i < offset + len; i++) {\n                 char ch = buf[i];\n                 if (ch == LF) {\n-                    if (CR != (i > 0 ? buf[i-1]: lastChar)) {\n+                    if (CR != (i > 0 ? buf[i - 1] : lastChar)) {\n                         lineCounter++;\n                     }\n                 } else if (ch == CR) {\n     }\n \n     /**\n-     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).\n-     * This method should only be called when processing a comment, otherwise\n-     * information can be lost.\n+     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n+     * when processing a comment, otherwise information can be lost.\n      * <p>\n-     * Increments  {@link #lineCounter}\n+     * Increments {@link #lineCounter}\n      * <p>\n-     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF,\n-     * otherwise to LF\n+     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, otherwise to LF\n      *\n      * @return the line that was read, or null if reached EOF.\n      */\n     }\n \n     /**\n-     * Returns the next character in the current reader without consuming it. So\n-     * the next call to {@link #read()} will still return this value.\n+     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n+     * still return this value.\n      *\n      * @return the next character\n      *\n-     * @throws IOException if there is an error in reading\n+     * @throws IOException\n+     *             if there is an error in reading\n      */\n     int lookAhead() throws IOException {\n         super.mark(1);\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         // assume c is the escape char (normally a backslash)\n         int c = in.read();\n         switch (c) {\n-            case 'r':\n-                return '\\r';\n-            case 'n':\n-                return '\\n';\n-            case 't':\n-                return '\\t';\n-            case 'b':\n-                return '\\b';\n-            case 'f':\n-                return '\\f';\n-            case ExtendedBufferedReader.END_OF_STREAM:\n-                throw new IOException(\"EOF whilst processing escape sequence\");\n-            default:\n-                return c;\n+        case 'r':\n+            return '\\r';\n+        case 'n':\n+            return '\\n';\n+        case 't':\n+            return '\\t';\n+        case 'b':\n+            return '\\b';\n+        case 'f':\n+            return '\\f';\n+        case ExtendedBufferedReader.END_OF_STREAM:\n+            throw new IOException(\"EOF whilst processing escape sequence\");\n+        default:\n+            return c;\n         }\n     }\n \n     }\n \n     /**\n-     * Greedy - accepts \\n, \\r and \\r\\n\n-     * This checker consumes silently the second control-character...\n+     * Greedy - accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n      *\n      * @return true if the given character is a line-terminator\n      */\n     }\n \n     /**\n-     * Checks if the current character represents the start of a line:\n-     * a CR, LF or is at the start of the file.\n+     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n      *\n      * @param c\n      * @return true if the character is at the start of a line.\n     boolean isStartOfLine(int c) {\n         return c == '\\n' || c == '\\r' || c == ExtendedBufferedReader.UNDEFINED;\n     }\n+\n     /**\n      * @return true if the given character indicates end of file\n      */\n--- a/src/main/java/org/apache/commons/csv/Token.java\n+++ b/src/main/java/org/apache/commons/csv/Token.java\n     // Provide toString method for IDE debugging\n     @Override\n     public String toString() {\n-        return type.name()+\" [\"+content.toString()+\"]\";\n+        return type.name() + \" [\" + content.toString() + \"]\";\n     }\n }", "timestamp": 1347394347, "metainfo": ""}