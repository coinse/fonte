{"sha": "42476f4b08fe4b075aa36f688f0801857f3635d9", "log": "CSVStrategy is now immutable (SANDBOX-279)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      * @param input a Reader containing \"csv-formatted\" input\n      */\n     public CSVParser(Reader input) {\n-        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());\n+        this(input, CSVStrategy.DEFAULT_STRATEGY);\n     }\n \n     /**\n         c = in.readAgain();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n-        while (strategy.getIgnoreEmptyLines() && eol\n+        while (strategy.isEmptyLinesIgnored() && eol\n                 && (lastChar == '\\n'\n                 || lastChar == '\\r'\n                 || lastChar == ExtendedBufferedReader.UNDEFINED)\n         //  important: make sure a new char gets consumed in each iteration\n         while (!tkn.isReady && tkn.type != TT_EOF) {\n             // ignore whitespaces at beginning of a token\n-            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {\n+            while (strategy.isLeadingSpacesIgnored() && isWhitespace(c) && !eol) {\n                 wsBuf.append((char) c);\n                 c = in.read();\n                 eol = isEndOfLine(c);\n             } else {\n                 // next token must be a simple token\n                 // add removed blanks when not ignoring whitespace chars...\n-                if (!strategy.getIgnoreLeadingWhitespaces()) {\n+                if (!strategy.isLeadingSpacesIgnored()) {\n                     tkn.content.append(wsBuf);\n                 }\n                 simpleTokenLexer(tkn, c);\n                 tkn.type = TT_TOKEN;\n                 tkn.isReady = true;\n                 break;\n-            } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n+            } else if (c == '\\\\' && strategy.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n                 // interpret unicode escaped chars (like \\u0070 -> p)\n                 tkn.content.append((char) unicodeEscapeLexer(c));\n             } else if (c == strategy.getEscape()) {\n             c = in.read();\n         }\n \n-        if (strategy.getIgnoreTrailingWhitespaces()) {\n+        if (strategy.isTrailingSpacesIgnored()) {\n             tkn.content.trimTrailingWhitespace();\n         }\n \n         for (; ;) {\n             c = in.read();\n \n-            if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n+            if (c == '\\\\' && strategy.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n                 tkn.content.append((char) unicodeEscapeLexer(c));\n             } else if (c == strategy.getEscape()) {\n                 tkn.content.append((char) readEscape(c));\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      * Output a blank line\n      */\n     public void println() throws IOException {\n-        out.write(strategy.getPrinterNewline());\n+        out.write(strategy.getLineSeparator());\n         newLine = true;\n     }\n \n--- a/src/main/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/main/java/org/apache/commons/csv/CSVStrategy.java\n  */\n public class CSVStrategy implements Cloneable, Serializable {\n \n-    private char delimiter;\n-    private char encapsulator;\n-    private char commentStart;\n-    private char escape;\n-    private boolean ignoreLeadingWhitespaces;\n-    private boolean ignoreTrailingWhitespaces;\n-    private boolean interpretUnicodeEscapes;\n-    private boolean ignoreEmptyLines;\n-\n-    // controls for output\n-    private String printerNewline = \"\\n\";\n+    private char delimiter = ',';\n+    private char encapsulator = '\"';\n+    private char commentStart = COMMENTS_DISABLED;\n+    private char escape = ESCAPE_DISABLED;\n+    private boolean leadingSpacesIgnored = true;\n+    private boolean trailingSpacesIgnored = true;\n+    private boolean unicodeEscapesInterpreted = false;\n+    private boolean emptyLinesIgnored = true;\n+    private String lineSeparator = \"\\n\";\n \n     // -2 is used to signal disabled, because it won't be confused with\n     // an EOF signal (-1), and because \\ufffe in UTF-16 would be\n     public static final char ESCAPE_DISABLED = (char) -2;\n     public static final char ENCAPSULATOR_DISABLED = (char) -2;\n \n+    /** Standard comma separated format. */\n     public static final CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true, false, true);\n+    \n+    /** Excel file format (using a comma as the value delimiter). */\n     public static final CSVStrategy EXCEL_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, false, false, false);\n+    \n+    /** Tabulation delimited format. */\n     public static final CSVStrategy TDF_STRATEGY = new CSVStrategy('\\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true, false, true);\n \n+\n+    /**\n+     * Creates a CSVStrategy with the default parameters.\n+     */\n+    public CSVStrategy() {\n+    }\n \n     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n         this(delimiter, encapsulator, commentStart, ESCAPE_DISABLED, true, true, false, true);\n      * @param encapsulator              a char used as value encapsulation marker\n      * @param commentStart              a char used for comment identification\n      * @param escape                    a char used to escape special characters in values\n-     * @param ignoreLeadingWhitespaces  TRUE when leading whitespaces should be ignored\n-     * @param ignoreTrailingWhitespaces TRUE when trailing whitespaces should be ignored\n-     * @param interpretUnicodeEscapes   TRUE when unicode escapes should be interpreted\n-     * @param ignoreEmptyLines          TRUE when the parser should skip emtpy lines\n+     * @param leadingSpacesIgnored      TRUE when leading whitespaces should be ignored\n+     * @param trailingSpacesIgnored     TRUE when trailing whitespaces should be ignored\n+     * @param unicodeEscapesInterpreted TRUE when unicode escapes should be interpreted\n+     * @param emptyLinesIgnored         TRUE when the parser should skip emtpy lines\n      */\n     public CSVStrategy(\n             char delimiter,\n             char encapsulator,\n             char commentStart,\n             char escape,\n-            boolean ignoreLeadingWhitespaces,\n-            boolean ignoreTrailingWhitespaces,\n-            boolean interpretUnicodeEscapes,\n-            boolean ignoreEmptyLines) {\n+            boolean leadingSpacesIgnored,\n+            boolean trailingSpacesIgnored,\n+            boolean unicodeEscapesInterpreted,\n+            boolean emptyLinesIgnored) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n         this.escape = escape;\n-        this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces;\n-        this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces;\n-        this.interpretUnicodeEscapes = interpretUnicodeEscapes;\n-        this.ignoreEmptyLines = ignoreEmptyLines;\n-    }\n-\n-    public void setDelimiter(char delimiter) {\n-        this.delimiter = delimiter;\n+        this.leadingSpacesIgnored = leadingSpacesIgnored;\n+        this.trailingSpacesIgnored = trailingSpacesIgnored;\n+        this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n+        this.emptyLinesIgnored = emptyLinesIgnored;\n     }\n \n     public char getDelimiter() {\n-        return this.delimiter;\n+        return delimiter;\n     }\n \n-    public void setEncapsulator(char encapsulator) {\n-        this.encapsulator = encapsulator;\n+    public CSVStrategy withDelimiter(char delimiter) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        this.delimiter = delimiter;\n+        return strategy;\n     }\n \n     public char getEncapsulator() {\n-        return this.encapsulator;\n+        return encapsulator;\n     }\n \n-    public void setCommentStart(char commentStart) {\n-        this.commentStart = commentStart;\n+    public CSVStrategy withEncapsulator(char encapsulator) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.encapsulator = encapsulator;\n+        return strategy;\n     }\n \n     public char getCommentStart() {\n-        return this.commentStart;\n+        return commentStart;\n+    }\n+\n+    public CSVStrategy withCommentStart(char commentStart) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.commentStart = commentStart;\n+        return strategy;\n     }\n \n     public boolean isCommentingDisabled() {\n         return this.commentStart == COMMENTS_DISABLED;\n     }\n \n-    public void setEscape(char escape) {\n-        this.escape = escape;\n+    public char getEscape() {\n+        return escape;\n     }\n \n-    public char getEscape() {\n-        return this.escape;\n+    public CSVStrategy withEscape(char escape) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.escape = escape;\n+        return strategy;\n     }\n \n-    public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) {\n-        this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces;\n+    public boolean isLeadingSpacesIgnored() {\n+        return leadingSpacesIgnored;\n     }\n \n-    public boolean getIgnoreLeadingWhitespaces() {\n-        return this.ignoreLeadingWhitespaces;\n+    public CSVStrategy withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.leadingSpacesIgnored = leadingSpacesIgnored;\n+        return strategy;\n     }\n \n-    public void setIgnoreTrailingWhitespaces(boolean ignoreTrailingWhitespaces) {\n-        this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces;\n+    public boolean isTrailingSpacesIgnored() {\n+        return trailingSpacesIgnored;\n     }\n \n-    public boolean getIgnoreTrailingWhitespaces() {\n-        return this.ignoreTrailingWhitespaces;\n+    public CSVStrategy withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.trailingSpacesIgnored = trailingSpacesIgnored;\n+        return strategy;\n     }\n \n-    public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) {\n-        this.interpretUnicodeEscapes = interpretUnicodeEscapes;\n+    public boolean isUnicodeEscapesInterpreted() {\n+        return unicodeEscapesInterpreted;\n     }\n \n-    public boolean getUnicodeEscapeInterpretation() {\n-        return this.interpretUnicodeEscapes;\n+    public CSVStrategy withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n+        return strategy;\n     }\n \n-    public boolean getIgnoreEmptyLines() {\n-        return this.ignoreEmptyLines;\n+    public boolean isEmptyLinesIgnored() {\n+        return emptyLinesIgnored;\n     }\n \n-    public String getPrinterNewline() {\n-        return this.printerNewline;\n+    public CSVStrategy withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.emptyLinesIgnored = emptyLinesIgnored;\n+        return strategy;\n     }\n \n-    public Object clone() {\n+    public String getLineSeparator() {\n+        return lineSeparator;\n+    }\n+\n+    public CSVStrategy withLineSeparator(String lineSeparator) {\n+        CSVStrategy strategy = (CSVStrategy) clone();\n+        strategy.lineSeparator = lineSeparator;\n+        return strategy;\n+    }\n+\n+    protected Object clone() {\n         try {\n             return super.clone();\n         } catch (CloneNotSupportedException e) {\n-            throw new RuntimeException(e);  // impossible\n+            throw (Error) new InternalError().initCause(e);\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         *\n         */\n         String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n-        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n-        // strategy.setIgnoreEmptyLines(false);\n-        strategy.setCommentStart('#');\n-\n+        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY.withCommentStart('#');\n+        \n         TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n \n \n         *       \\,,\n         */\n         String code = \"a,\\\\,,b\\n\\\\,,\";\n-        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n-        strategy.setCommentStart('#');\n+        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY.withCommentStart('#');\n         TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n \n         assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n \n     public void testUnicodeEscape() throws IOException {\n         String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        parser.getStrategy().setUnicodeEscapeInterpretation(true);\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.DEFAULT_STRATEGY.withUnicodeEscapesInterpreted(true));\n         String[] data = parser.getLine();\n         assertEquals(2, data.length);\n         assertEquals(\"abc\", data[0]);\n--- a/src/test/java/org/apache/commons/csv/CSVStrategyTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVStrategyTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.csv;\n \n import junit.framework.TestCase;\n \n-/**\n- * CSVStrategyTest\n- *\n- * The test are organized in three different sections:\n- * The 'setter/getter' section, the lexer section and finally the strategy\n- * section. In case a test fails, you should follow a top-down approach for\n- * fixing a potential bug (its likely that the strategy itself fails if the lexer\n- * has problems...).\n- */\n public class CSVStrategyTest extends TestCase {\n \n-    // ======================================================\n-    //   getters / setters\n-    // ======================================================\n-    public void testGetSetCommentStart() {\n-        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n-        strategy.setCommentStart('#');\n-        assertEquals(strategy.getCommentStart(), '#');\n-        strategy.setCommentStart('!');\n-        assertEquals(strategy.getCommentStart(), '!');\n-    }\n+    public void testImmutalibity() {\n+        CSVStrategy strategy1 = new CSVStrategy('!', '!', '!', '!', true, true, true, true);\n+        CSVStrategy strategy2 = strategy1.withDelimiter('?')\n+                                         .withEncapsulator('?')\n+                                         .withCommentStart('?')\n+                                         .withLineSeparator(\"?\")\n+                                         .withEscape('?')\n+                                         .withLeadingSpacesIgnored(false)\n+                                         .withTrailingSpacesIgnored(false)\n+                                         .withEmptyLinesIgnored(false)\n+                                         .withUnicodeEscapesInterpreted(false);\n \n-    public void testGetSetEncapsulator() {\n-        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n-        strategy.setEncapsulator('\"');\n-        assertEquals(strategy.getEncapsulator(), '\"');\n-        strategy.setEncapsulator('\\'');\n-        assertEquals(strategy.getEncapsulator(), '\\'');\n-    }\n-\n-    public void testGetSetDelimiter() {\n-        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n-        strategy.setDelimiter(';');\n-        assertEquals(strategy.getDelimiter(), ';');\n-        strategy.setDelimiter(',');\n-        assertEquals(strategy.getDelimiter(), ',');\n-        strategy.setDelimiter('\\t');\n-        assertEquals(strategy.getDelimiter(), '\\t');\n-    }\n-\n-    public void testSetCSVStrategy() {\n-        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n-        // default settings\n-        assertEquals(strategy.getDelimiter(), ',');\n-        assertEquals(strategy.getEncapsulator(), '\"');\n-        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-        assertEquals(true, strategy.getIgnoreLeadingWhitespaces());\n-        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-        assertEquals(true, strategy.getIgnoreEmptyLines());\n-        // explicit csv settings\n-        assertEquals(strategy.getDelimiter(), ',');\n-        assertEquals(strategy.getEncapsulator(), '\"');\n-        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-        assertEquals(true, strategy.getIgnoreLeadingWhitespaces());\n-        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-        assertEquals(true, strategy.getIgnoreEmptyLines());\n-    }\n-\n-    public void testSetExcelStrategy() {\n-        CSVStrategy strategy = CSVStrategy.EXCEL_STRATEGY;\n-        assertEquals(strategy.getDelimiter(), ',');\n-        assertEquals(strategy.getEncapsulator(), '\"');\n-        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-        assertEquals(false, strategy.getIgnoreLeadingWhitespaces());\n-        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-        assertEquals(false, strategy.getIgnoreEmptyLines());\n+        assertNotSame(strategy1.getDelimiter(), strategy2.getDelimiter());\n+        assertNotSame(strategy1.getEncapsulator(), strategy2.getEncapsulator());\n+        assertNotSame(strategy1.getCommentStart(), strategy2.getCommentStart());\n+        assertNotSame(strategy1.getEscape(), strategy2.getEscape());\n+        assertNotSame(strategy1.getLineSeparator(), strategy2.getLineSeparator());\n+        \n+        assertNotSame(strategy1.isTrailingSpacesIgnored(), strategy2.isTrailingSpacesIgnored());\n+        assertNotSame(strategy1.isLeadingSpacesIgnored(), strategy2.isLeadingSpacesIgnored());\n+        assertNotSame(strategy1.isEmptyLinesIgnored(), strategy2.isEmptyLinesIgnored());\n+        assertNotSame(strategy1.isUnicodeEscapesInterpreted(), strategy2.isUnicodeEscapesInterpreted());\n     }\n \n } ", "timestamp": 1320855683, "metainfo": ""}