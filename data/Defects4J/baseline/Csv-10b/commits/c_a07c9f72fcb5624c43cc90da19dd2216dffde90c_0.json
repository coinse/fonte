{"sha": "a07c9f72fcb5624c43cc90da19dd2216dffde90c", "log": "Improve escape tests Fix bug in readEscape() - was not handling EOF  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         return in.getLineNumber();\n     }\n \n+    // TODO escape handling needs more work\n     int readEscape() throws IOException {\n         // assume c is the escape char (normally a backslash)\n         int c = in.read();\n                 return '\\b';\n             case 'f':\n                 return '\\f';\n+            case ExtendedBufferedReader.END_OF_STREAM:\n+                throw new IOException(\"EOF whilst processing escape sequence\");\n             default:\n                 return c;\n         }\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n \n     }\n \n-    // simple token with escaping\n+    // simple token with escaping not enabled\n     @Test\n     public void testNextToken3() throws IOException {\n         /* file: a,\\,,b\n         *       \\,,\n         */\n-        String code = \"a,\\\\,,b\\n\\\\,,\";\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n+        CSVFormat format = CSVFormat.DEFAULT;\n+        assertFalse(format.isEscaping());\n         Lexer parser = getLexer(code, format);\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         // an unquoted single backslash is not an escape char\n         assertTokenEquals(TOKEN, \"\\\\\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n-        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\\\\\", parser.nextToken(new Token()));\n         // an unquoted single backslash is not an escape char\n         assertTokenEquals(TOKEN, \"\\\\\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n         assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n     }\n \n-    // encapsulator tokenizer (sinle line)\n+    // simple token with escaping enabled\n+    @Test\n+    public void testNextToken3Escaping() throws IOException {\n+        /* file: a,\\,,b\n+        *       \\,,\n+        */\n+        String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\n\";\n+        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n+        assertTrue(format.isEscaping());\n+        Lexer parser = getLexer(code, format);\n+\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\\\\\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"\\nc\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"d\\n\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n+    }\n+\n+    // simple token with escaping enabled\n+    @Test\n+    public void testNextToken3BadEscaping() throws IOException {\n+        String code = \"a,b,c\\\\\";\n+        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n+        assertTrue(format.isEscaping());\n+        Lexer parser = getLexer(code, format);\n+\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"b\", parser.nextToken(new Token()));\n+        try {\n+            Token tkn = parser.nextToken(new Token());\n+            fail(\"Expected IOE, found \"+tkn);\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    // encapsulator tokenizer (single line)\n     @Test\n     public void testNextToken4() throws IOException {\n         /* file:  a,\"foo\",b", "timestamp": 1333033264, "metainfo": ""}