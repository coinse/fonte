{"sha": "68352ee98fdb3d07be160357514abe2558a90c0d", "log": "Use the final keyword where possible.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      *            the char used for value separation, must not be a line break character\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    public static CSVFormatBuilder newBuilder(char delimiter) {\n+    public static CSVFormatBuilder newBuilder(final char delimiter) {\n         return new CSVFormatBuilder(delimiter);\n     }\n \n          *            the char used for value separation, must not be a line break character\n          * @throws IllegalArgumentException if the delimiter is a line break character\n          */\n-        private CSVFormatBuilder(char delimiter){\n+        private CSVFormatBuilder(final char delimiter){\n             this(delimiter, null, null, null, null, false, false, null, null);\n         }\n \n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         println();\n     }\n \n-    private void print(Object object, final CharSequence value, final int offset, final int len) throws IOException {\n+    private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n         if (format.isQuoting()) {\n             printAndQuote(object, value, offset, len);\n         } else if (format.isEscaping()) {\n     /*\n      * Note: must only be called if quoting is enabled, otherwise will generate NPE\n      */\n-    void printAndQuote(Object object, final CharSequence value, final int offset, final int len) throws IOException {\n+    void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n         final boolean first = newLine; // is this the first value on this line?\n         boolean quote = false;\n         int start = offset;\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public void printRecords(Object[] values) throws IOException {\n-        for (Object value : values) {\n+    public void printRecords(final Object[] values) throws IOException {\n+        for (final Object value : values) {\n             if (value instanceof Object[]) {\n                 this.printRecord((Object[]) value);\n             } else if (value instanceof Iterable) {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public void printRecords(Iterable<?> values) throws IOException {\n-        for (Object value : values) {\n+    public void printRecords(final Iterable<?> values) throws IOException {\n+        for (final Object value : values) {\n             if (value instanceof Object[]) {\n                 this.printRecord((Object[]) value);\n             } else if (value instanceof Iterable) {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public void printRecords(ResultSet resultSet) throws SQLException, IOException {\n-        int columnCount = resultSet.getMetaData().getColumnCount();\n+    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n+        final int columnCount = resultSet.getMetaData().getColumnCount();\n         while (resultSet.next()) {\n             for (int i = 1; i <= columnCount; i++) {\n                 print(resultSet.getString(i));\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     /** The record number. */\n     private final long recordNumber;\n \n-    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, long recordNumber) {\n+    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n     }\n \n-    private final char mapNullToDisabled(Character c) {\n+    private final char mapNullToDisabled(final Character c) {\n         return c == null ? DISABLED : c.charValue();\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n-        CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n+        final CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n         CSVFormat fmt = builder.build(); \n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testRoundtrip() throws Exception {\n-        StringWriter out = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n+        final StringWriter out = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n         final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n         for (final CSVRecord record : CSVFormat.DEFAULT.parse(new StringReader(input))) {\n             printer.printRecord(record);\n         validateRecordNumbers(String.valueOf(CR));\n     }\n \n-    private void validateRecordNumbers(String lineSeparator) throws IOException {\n+    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n         final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertEquals(3, parser.getRecordNumber());\n     }\n \n-    private void validateLineNumbers(String lineSeparator) throws IOException {\n+    private void validateLineNumbers(final String lineSeparator) throws IOException {\n         final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.nextRecord());\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n         return new BufferedReader(new FileReader(BIG_FILE));\n     }\n \n-    private long parse(final Reader in, boolean traverseColumns) throws IOException {\n+    private long parse(final Reader in, final boolean traverseColumns) throws IOException {\n         final CSVFormat format = CSVFormat.newBuilder().withIgnoreSurroundingSpaces(false).build();\n         long recordCount = 0;\n         for (final CSVRecord record : format.parse(in)) {\n             recordCount++;\n             if (traverseColumns) {\n-                for (String value : record) {\n+                for (final String value : record) {\n                     // do nothing for now\n                 }\n             }\n         return count;\n     }\n \n-    public long testParseBigFile(boolean traverseColumns) throws Exception {\n+    public long testParseBigFile(final boolean traverseColumns) throws Exception {\n         final long startMillis = System.currentTimeMillis();\n         final long count = this.parse(this.getBufferedReader(), traverseColumns);\n         final long totalMillis = System.currentTimeMillis() - startMillis;", "timestamp": 1352930289, "metainfo": ""}