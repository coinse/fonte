{"sha": "bf06bed9b8905ccf5409179263707074167ccfc4", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n     /** According to RFC 4180, line breaks are delimited by CRLF */\n     public static final String CRLF = \"\\r\\n\";\n-    \n+\n     private final char delimiter;\n     private final char encapsulator;\n     private final char commentStart;\n      */\n     static final CSVFormat PRISTINE = new CSVFormat(DISABLED, DISABLED, DISABLED, DISABLED, false, false, null, null);\n \n-    /** \n-     * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines. \n+    /**\n+     * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n      * <ul>\n      * <li>withDelimiter(',')</li>\n      * <li>withEncapsulator('\"')</li>\n      * <li>withEmptyLinesIgnored(true)</li>\n      * <li>withLineSeparator(CRLF)</li>\n-     * </ul> \n+     * </ul>\n      */\n     public static final CSVFormat DEFAULT =\n             PRISTINE.\n      * <li>withEncapsulator('\"')</li>\n      * <li>withLineSeparator(CRLF)</li>\n      * <li></li>\n-     * </ul> \n+     * </ul>\n      */\n     public static final CSVFormat RFC4180 =\n             PRISTINE.\n      * <p/>\n      * For example for parsing or generating a CSV file on a French system\n      * the following format will be used:\n-     * \n+     *\n      * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>\n      */\n     public static final CSVFormat EXCEL =\n      * <tt>LOAD DATA INFILE</tt> operations. This is a tab-delimited\n      * format with a LF character as the line separator. Values are not quoted\n      * and special characters are escaped with '\\'.\n-     * \n+     *\n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n \n     /**\n      * Returns true if the given character is a line break character.\n-     * \n+     *\n      * @param c the character to check\n-     * \n+     *\n      * @return true if <code>c</code> is a line break character\n      */\n     private static boolean isLineBreak(char c) {\n         if (delimiter == encapsulator) {\n             throw new IllegalArgumentException(\"The encapsulator character and the delimiter cannot be the same (\\\"\" + encapsulator + \"\\\")\");\n         }\n-        \n+\n         if (delimiter == escape) {\n             throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same (\\\"\" + escape + \"\\\")\");\n         }\n-        \n+\n         if (delimiter == commentStart) {\n             throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same (\\\"\" + commentStart + \"\\\")\");\n         }\n-        \n+\n         if (encapsulator != DISABLED && encapsulator == commentStart) {\n             throw new IllegalArgumentException(\"The comment start character and the encapsulator cannot be the same (\\\"\" + commentStart + \"\\\")\");\n         }\n-        \n+\n         if (escape != DISABLED && escape == commentStart) {\n             throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same (\\\"\" + commentStart + \"\\\")\");\n         }\n \n     /**\n      * Returns the character delimiting the values (typically ';', ',' or '\\t').\n-     * \n+     *\n      * @return the delimiter character\n      */\n     public char getDelimiter() {\n \n     /**\n      * Returns a copy of this format using the specified delimiter character.\n-     * \n+     *\n      * @param delimiter the delimiter character\n      * @return A copy of this format using the specified delimiter character\n      * @throws IllegalArgumentException thrown if the specified character is a line break\n \n     /**\n      * Returns the character used to encapsulate values containing special characters.\n-     * \n+     *\n      * @return the encapsulator character\n      */\n     public char getEncapsulator() {\n \n     /**\n      * Returns a copy of this format using the specified encapsulator character.\n-     * \n+     *\n      * @param encapsulator the encapsulator character\n      * @return A copy of this format using the specified encapsulator character\n      * @throws IllegalArgumentException thrown if the specified character is a line break\n         if (isLineBreak(encapsulator)) {\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n-        \n+\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns whether an encapsulator has been defined.\n-     * \n+     *\n      * @return {@code true} if an encapsulator is defined\n      */\n     public boolean isEncapsulating() {\n \n     /**\n      * Returns the character marking the start of a line comment.\n-     * \n+     *\n      * @return the comment start marker.\n      */\n     public char getCommentStart() {\n \n     /**\n      * Returns a copy of this format using the specified character as the comment start marker.\n-     * \n+     *\n      * Note that the comment introducer character is only recognised\n      * at the start of a line.\n-     * \n+     *\n      * @param commentStart the comment start marker\n      * @return A copy of this format using the specified character as the comment start marker\n      * @throws IllegalArgumentException thrown if the specified character is a line break\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n-        \n+\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Specifies whether comments are supported by this format.\n-     * \n+     *\n      * Note that the comment introducer character is only recognised\n      * at the start of a line.\n-     * \n+     *\n      * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n      */\n     public boolean isCommentingEnabled() {\n \n     /**\n      * Returns the escape character.\n-     * \n+     *\n      * @return the escape character\n      */\n     public char getEscape() {\n \n     /**\n      * Returns a copy of this format using the specified escape character.\n-     * \n+     *\n      * @param escape the escape character\n      * @return A copy of this format using the specified escape character\n      * @throws IllegalArgumentException thrown if the specified character is a line break\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        \n+\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns whether escape are being processed.\n-     * \n+     *\n      * @return {@code true} if escapes are processed\n      */\n     public boolean isEscaping() {\n \n     /**\n      * Specifies whether spaces around values are ignored when parsing input.\n-     * \n+     *\n      * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the value.\n      */\n     public boolean isSurroundingSpacesIgnored() {\n \n     /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n-     * \n+     *\n      * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty records.\n      */\n     public boolean isEmptyLinesIgnored() {\n \n     /**\n      * Returns the line separator delimiting output records.\n-     * \n+     *\n      * @return the line separator\n      */\n     public String getLineSeparator() {\n \n     /**\n      * Returns a copy of this format using the specified output line separator.\n-     * \n+     *\n      * @param lineSeparator the line separator to be used for output.\n-     * \n+     *\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n \n     /**\n      * Parses the specified content.\n-     * \n+     *\n      * @param in the input stream\n      */\n     public Iterable<CSVRecord> parse(Reader in) throws IOException {\n \n     /**\n      * Format the specified values.\n-     * \n+     *\n      * @param values the values to format\n      */\n     public String format(String... values) {\n         } catch (IOException e) {\n             // should not happen\n             throw new IllegalStateException(e);\n-        }        \n+        }\n     }\n \n     @Override\n         }\n         if (isEncapsulating()) {\n             sb.append(' ');\n-            sb.append(\"Encapsulator=<\").append(encapsulator).append('>');            \n+            sb.append(\"Encapsulator=<\").append(encapsulator).append('>');\n         }\n         if (isCommentingEnabled()) {\n             sb.append(' ');\n             sb.append(\"CommentStart=<\").append(commentStart).append('>');\n         }\n         if (isEmptyLinesIgnored()) {\n-            sb.append(\" EmptyLines:ignored\");            \n+            sb.append(\" EmptyLines:ignored\");\n         }\n         if (isSurroundingSpacesIgnored()) {\n-            sb.append(\" SurroundingSpaces:ignored\");            \n+            sb.append(\" SurroundingSpaces:ignored\");\n         }\n         return sb.toString();\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n     public CSVLexer(CSVFormat format, ExtendedBufferedReader in) {\n         super(format, in);\n     }\n-    \n+\n     /**\n      * Returns the next token.\n      * <p/>\n                     eol = isEndOfLine(c);\n                 }\n             }\n-            \n+\n             // ok, start of token reached: encapsulated, or token\n             if (isDelimiter(c)) {\n                 // empty token return TOKEN(\"\")\n      *\n      * @param tkn the current token\n      * @return a valid token object\n-     * @throws IOException on invalid state: \n+     * @throws IOException on invalid state:\n      *  EOF before closing encapsulator or invalid character before delimiter or EOL\n      */\n     private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n         int c;\n         while (true) {\n             c = in.read();\n-            \n+\n             if (isEscape(c)) {\n                 tkn.content.append((char) readEscape());\n             } else if (isEncapsulator(c)) {\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final Map<String, Integer> headerMapping;\n \n     // the following objects are shared to reduce garbage\n-    \n+\n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n     private final Token reusableToken = new Token();\n      */\n     public CSVParser(Reader input, CSVFormat format) throws IOException {\n         format.validate();\n-        \n+\n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n-        \n+\n         this.headerMapping = initializeHeader(format);\n     }\n \n                     break;\n             }\n         } while (reusableToken.type == TOKEN);\n-        \n+\n         if (!record.isEmpty()) {\n-            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping, \n+            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping,\n                     sb == null ? null : sb.toString());\n         }\n         return result;\n     public Iterator<CSVRecord> iterator() {\n         return new Iterator<CSVRecord>() {\n             private CSVRecord current;\n-            \n+\n             public boolean hasNext() {\n                 if (current == null) {\n                     current = getNextRecord();\n                 }\n-                \n+\n                 return current != null;\n             }\n \n                         throw new NoSuchElementException(\"No more CSV records available\");\n                     }\n                 }\n-                \n+\n                 return next;\n             }\n-            \n+\n             private CSVRecord getNextRecord() {\n                 try {\n                     return getRecord();\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n     /**\n      * Flush the underlying stream.\n-     * \n+     *\n      * @throws IOException\n      */\n     public void flush() throws IOException {\n     }\n \n \n-    private void print(CharSequence value, int offset, int len) throws IOException {        \n+    private void print(CharSequence value, int offset, int len) throws IOException {\n         if (format.isEncapsulating()) {\n             printAndEncapsulate(value, offset, len);\n         } else if (format.isEscaping()) {\n             // null values are considered empty\n             value = \"\";\n         }\n-        \n+\n         if (!checkForEscape) {\n             // write directly from string\n             printSep();\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n  * A CSV record\n  */\n public class CSVRecord implements Serializable, Iterable<String> {\n-    \n+\n     private static final long serialVersionUID = 1L;\n \n     private static final String[] EMPTY_STRING_ARRAY = new String[0];\n-    \n+\n     /** The values of the record */\n     private final String[] values;\n \n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n      * character has been read then this will return {@link #UNDEFINED}. If the\n      * end of the stream was reached on the last read then this will return\n      * {@link #END_OF_STREAM}.\n-     * \n+     *\n      * @return the last character that was read\n      */\n     int readAgain() {\n         if (length == 0) {\n             return 0;\n         }\n-        \n+\n         int len = super.read(buf, offset, length);\n-        \n+\n         if (len > 0) {\n \n             for (int i = offset; i < offset + len; i++) {\n                 char ch = buf[i];\n                 if (ch == LF) {\n                     if (CR != (i > 0 ? buf[i-1]: lastChar)) {\n-                        lineCounter++;                        \n+                        lineCounter++;\n                     }\n                 } else if (ch == CR) {\n                     lineCounter++;\n         } else if (len == -1) {\n             lastChar = END_OF_STREAM;\n         }\n-        \n+\n         return len;\n     }\n \n      * <p>\n      * Increments  {@link #lineCounter}\n      * <p>\n-     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, \n-     * otherwise to LF \n-     * \n+     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF,\n+     * otherwise to LF\n+     *\n      * @return the line that was read, or null if reached EOF.\n      */\n     @Override\n     /**\n      * Returns the next character in the current reader without consuming it. So\n      * the next call to {@link #read()} will still return this value.\n-     * \n+     *\n      * @return the next character\n-     * \n+     *\n      * @throws IOException if there is an error in reading\n      */\n     int lookAhead() throws IOException {\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     private final boolean isEncapsulating;\n     private final boolean isEscaping;\n     private final boolean isCommentEnabled;\n-    \n+\n     private final char delimiter;\n     private final char escape;\n     private final char encapsulator;\n     private final char commmentStart;\n-    \n+\n     final boolean surroundingSpacesIgnored;\n     final boolean emptyLinesIgnored;\n-    \n+\n     final CSVFormat format;\n-    \n+\n     /** The input stream */\n     final ExtendedBufferedReader in;\n \n     /**\n      * Checks if the current character represents the start of a line:\n      * a CR, LF or is at the start of the file.\n-     * \n+     *\n      * @param c\n      * @return true if the character is at the start of a line.\n      */\n     }\n \n     abstract Token nextToken(Token reusableToken) throws IOException;\n-    \n+\n     boolean isDelimiter(int c) {\n         return c == delimiter;\n     }\n--- a/src/main/java/org/apache/commons/csv/Token.java\n+++ b/src/main/java/org/apache/commons/csv/Token.java\n \n     /** length of the initial token (content-)buffer */\n     private static final int INITIAL_TOKEN_LENGTH = 50;\n-    \n+\n     enum Type {\n         /** Token has no valid content, i.e. is in its initialized state. */\n         INVALID,\n-        \n+\n         /** Token with content, at beginning or in the middle of a line. */\n         TOKEN,\n-        \n+\n         /** Token (which can have content) when end of file is reached. */\n         EOF,\n-        \n+\n         /** Token with content when end of a line is reached. */\n         EORECORD,\n-        \n+\n         /** Token is a comment line */\n         COMMENT\n     }\n-    \n+\n     /** Token type */\n     Token.Type type = INVALID;\n-    \n+\n     /** The content buffer. */\n     StringBuilder content = new StringBuilder(INITIAL_TOKEN_LENGTH);\n-    \n+\n     /** Token ready flag: indicates a valid token with content (ready for the parser). */\n     boolean isReady;\n \n--- a/src/main/java/org/apache/commons/csv/package-info.java\n+++ b/src/main/java/org/apache/commons/csv/package-info.java\n \n /**\n  * Apache Commons CSV Format Support.\n- * \n+ *\n  * <p>CSV (or its dialects) are widely used as interfaces to legacy systems or\n  *    manual data-imports. Basically CSV stands for \"Comma Separated Values\" but\n  *    this simple abbreviation leads to more confusion than definitions.</p>\n- *    \n+ *\n  * <p>Common to all file dialects is its basic structure: The CSV data-format\n  *    is record oriented, whereas each record starts on a new textual line. A\n  *    record is build of a list of values. Keep in mind that not all records\n  *       csv    := records*\n  *       record := values*\n  * </pre>\n- * \n+ *\n  * <p>The following list contains the csv aspects the Commons CSV parser supports:</p>\n  * <dl>\n  *   <dt>Separators (for lines)</dt>\n  *   <dd>The record separators are hardcoded and cannot be changed. The must be '\\r', '\\n' or '\\r\\n'.</dd>\n- * \n+ *\n  *   <dt>Delimiter (for values)</dt>\n  *   <dd>The delimiter for values is freely configurable (default ',').</dd>\n- * \n+ *\n  *   <dt>Comments</dt>\n  *   <dd>Some CSV-dialects support a simple comment syntax. A comment is a record\n  *       which must start with a designated character (the commentStarter). A record\n  *       of this kind is treated as comment and gets removed from the input (default none)</dd>\n- * \n+ *\n  *   <dt>Encapsulator</dt>\n  *  <dd>Two encapsulator characters (default '\"') are used to enclose -&gt; complex values.</dd>\n- *       \n+ *\n  *   <dt>Simple values</dt>\n- *   <dd>A simple value consist of all characters (except the delimiter) until \n+ *   <dd>A simple value consist of all characters (except the delimiter) until\n  *       (but not including) the next delimiter or a record-terminator. Optionally\n  *       all surrounding whitespaces of a simple value can be ignored (default: true).</dd>\n- *      \n+ *\n  *   <dt>Complex values</dt>\n  *   <dd>Complex values are encapsulated within a pair of the defined encapsulator characters.\n  *       The encapsulator itself must be escaped or doubled when used inside complex values.\n  *       Complex values preserve all kind of formatting (including newlines -&gt; multiline-values)</dd>\n- * \n+ *\n  *  <dt>Empty line skipping</dt>\n- *   <dd>Optionally empty lines in CSV files can be skipped. \n+ *   <dd>Optionally empty lines in CSV files can be skipped.\n  *       Otherwise, empty lines will return a record with a single empty value.</dd>\n  * </dl>\n- * \n- * <p>In addition to individually defined dialects, two predefined dialects (strict-csv, and excel-csv) \n+ *\n+ * <p>In addition to individually defined dialects, two predefined dialects (strict-csv, and excel-csv)\n  *    can be set directly.</p> <!-- TODO fix -->\n- * \n+ *\n  * <p>Example usage:</p>\n  * <blockquote><pre>\n  * Reader in = new StringReader(\"a,b,c\");\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class CSVFileParserTest {\n \n     private static final File BASE = new File(\"src/test/resources/CSVFileParser\");\n-    \n+\n     private final BufferedReader testData;\n     private final String testName;\n \n     public static Collection<Object[]> generateData()\n     {\n         List<Object[]> list = new ArrayList<Object[]>();\n-        \n+\n         final FilenameFilter filenameFilter = new FilenameFilter() {\n             public boolean accept(File dir, String name) {\n                 return name.startsWith(\"test\") && name.endsWith(\".txt\");\n         }\n         return list;\n     }\n-    \n+\n     @Test\n     public void testCSVFile() throws Exception {\n         String line = readTestData();\n         }\n         line = readTestData(); // get string version of format\n         assertEquals(testName+\" Expected format \", line, fmt.toString());\n-        \n+\n         // Now parse the file and compare against the expected results\n         for(CSVRecord rec : fmt.parse(csvFile)) {\n             String parsed = rec.toString();\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     @Test\n     public void testImmutalibity() {\n         CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n-        \n+\n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n         format.withCommentStart('?');\n         format.withEscape('?');\n         format.withSurroundingSpacesIgnored(false);\n         format.withEmptyLinesIgnored(false);\n-        \n+\n         assertEquals('!', format.getDelimiter());\n         assertEquals('!', format.getEncapsulator());\n         assertEquals('!', format.getCommentStart());\n         assertEquals('!', format.getEscape());\n         assertEquals(CSVFormat.CRLF, format.getLineSeparator());\n-        \n+\n         assertTrue(format.isSurroundingSpacesIgnored());\n         assertTrue(format.isEmptyLinesIgnored());\n     }\n     @Test\n     public void testMutators() {\n         CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n-        \n+\n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n         assertEquals('?', format.withCommentStart('?').getCommentStart());\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n         assertEquals('?', format.withEscape('?').getEscape());\n-        \n+\n         assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored());\n         assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());\n     }\n     @Test\n     public void testFormat() {\n         CSVFormat format = CSVFormat.DEFAULT;\n-        \n+\n         assertEquals(\"\", format.format());\n         assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n         assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\n     }\n-    \n+\n     @Test\n     public void testValidation() {\n         CSVFormat format = CSVFormat.DEFAULT;\n-        \n+\n         try {\n             format.withDelimiter('\\n');\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withEscape('\\r');\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withEncapsulator('\\n');\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withCommentStart('\\r');\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withDelimiter('!').withEscape('!').validate();\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withDelimiter('!').withCommentStart('!').validate();\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             format.withEncapsulator('!').withCommentStart('!').validate();\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         format.withEncapsulator(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();\n-        \n+\n         try {\n             format.withEscape('!').withCommentStart('!').validate();\n             fail();\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         format.withEscape(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();\n-        \n-        \n+\n+\n         try {\n             format.withEncapsulator('!').withDelimiter('!').validate();\n             fail();\n     @Test\n     public void testSerialization() throws Exception {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        \n+\n         ObjectOutputStream oos = new ObjectOutputStream(out);\n         oos.writeObject(CSVFormat.DEFAULT);\n         oos.flush();\n         oos.close();\n-        \n+\n         ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n         CSVFormat format = (CSVFormat) in.readObject();\n-        \n+\n         assertNotNull(format);\n         assertEquals(\"delimiter\", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());\n         assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getEncapsulator(), format.getEncapsulator());\n         assertEquals(\"trim\", CSVFormat.DEFAULT.isSurroundingSpacesIgnored(), format.isSurroundingSpacesIgnored());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());\n     }\n-} \n+}\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n class CSVLexer1 extends Lexer {\n \n     private final StringBuilder wsBuf = new StringBuilder();\n-    \n+\n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n     public CSVLexer1(CSVFormat format, ExtendedBufferedReader in) {\n         super(format, in);\n     }\n-    \n+\n     /**\n      * Returns the next token.\n      * <p/>\n                     eol = isEndOfLine(c);\n                 }\n             }\n-            \n+\n             // ok, start of token reached: comment, encapsulated, or token\n             if (c == format.getCommentStart()) {\n                 // ignore everything till end of line and continue (incr linecount)\n         // assert c == delimiter;\n         while (true) {\n             c = in.read();\n-            \n+\n             if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape());\n             } else if (c == format.getEncapsulator()) {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public CSVLexer1306663(CSVFormat format, ExtendedBufferedReader in) {\n         super(format, in);\n     }\n-    \n+\n     /**\n      * Returns the next token.\n      * <p/>\n                     eol = isEndOfLine(c);\n                 }\n             }\n-            \n+\n             // ok, start of token reached: encapsulated, or token\n             if (isDelimiter(c)) {\n                 // empty token return TOKEN(\"\")\n         int c;\n         while (true) {\n             c = in.read();\n-            \n+\n             if (isEscape(c)) {\n                 tkn.content.append((char) readEscape());\n             } else if (isEncapsulator(c)) {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public CSVLexer1306667(CSVFormat format, ExtendedBufferedReader in) {\n         super(format, in);\n     }\n-    \n+\n     /**\n      * Returns the next token.\n      * <p/>\n                     eol = isEndOfLine(c);\n                 }\n             }\n-            \n+\n             // ok, start of token reached: encapsulated, or token\n             if (isDelimiter(c)) {\n                 // empty token return TOKEN(\"\")\n         int c;\n         while (true) {\n             c = in.read();\n-            \n+\n             if (isEscape(c)) {\n                 tkn.content.append((char) readEscape());\n             } else if (isEncapsulator(c)) {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer3.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer3.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Experimental Lexer using enums to keep track of state and character type.\n  * Unfortunately it is twice as slow.\n  * For reference purpose only.\n- *  \n+ *\n  */\n class CSVLexer3 extends Lexer {\n \n     private final char escape;\n-    \n+\n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n     public CSVLexer3(CSVFormat format, ExtendedBufferedReader in) {\n         super(format, in);\n         this.escape = format.getEscape();\n     }\n-    \n+\n     /**\n      * Classify the character types\n      */\n                         case WHITESPACE:\n                             if (!surroundingSpacesIgnored){\n                                 tkn.content.append((char) intch);\n-                                state = State.PLAIN;                                \n+                                state = State.PLAIN;\n                             }\n                             break;\n                     }\n                             break;\n                         case EOFCHAR:\n                             throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in quoted string\");\n-                        default:    \n+                        default:\n                             tkn.content.append((char) intch);\n                             break;\n                     }\n                             break;\n                         case COMMENT_START: // TODO should comment be escaped?\n                         case ENCAP: // TODO is this correct?\n-                        case OTHER: // TODO may need to escape further \n+                        case OTHER: // TODO may need to escape further\n                         case WHITESPACE:\n                             tkn.content.append(escape);\n                             tkn.content.append((char) intch);\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import static org.junit.Assert.*;\n \n public class CSVLexerTest {\n-    \n+\n     private Lexer getLexer(String input, CSVFormat format) {\n         return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n         assertEquals(\"Token type\", expectedType, token.type);\n         assertEquals(\"Token content\", expectedContent, token.content.toString());\n     }\n-    \n+\n     // Single line (without comment)\n     @Test\n     public void testNextToken1() throws IOException {\n     // multiline including comments (and empty lines)\n     @Test\n     public void testNextToken2() throws IOException {\n-        final String code = \n+        final String code =\n                 \"1,2,3,\\n\"+                // 1\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"# Final comment\\n\";       // 7\n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         assertTrue(\"Should ignore empty lines\", format.isEmptyLinesIgnored());\n-        \n+\n         Lexer parser = getLexer(code, format);\n \n \n     // multiline including comments (and empty lines)\n     @Test\n     public void testNextToken2EmptyLines() throws IOException {\n-        final String code = \n+        final String code =\n                 \"1,2,3,\\n\"+                // 1\n                 \"\\n\"+                      // 1b\n                 \"\\n\"+                      // 1c\n                 \"# Final comment\\n\";       // 7\n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withEmptyLinesIgnored(false);\n         assertFalse(\"Should not ignore empty lines\", format.isEmptyLinesIgnored());\n-        \n+\n         Lexer parser = getLexer(code, format);\n \n \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         for (String[] re : RESULT) {\n             assertArrayEquals(re, parser.getRecord().values());\n         }\n-        \n+\n         assertNull(parser.getRecord());\n     }\n \n                 {\"\"},  // Excel format does not ignore empty lines\n                 {\"world\", \"\"}\n         };\n-        \n+\n         for (String code : codes) {\n             CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n             List<CSVRecord> records = parser.getRecords();\n         format = CSVFormat.DEFAULT.withCommentStart('#');\n         parser = new CSVParser(code, format);\n         records = parser.getRecords();\n-        \n+\n         Utils.compare(\"Failed to parse with comments\", res_comments, records);\n     }\n \n     @Test\n     public void testForEach() throws Exception {\n         List<CSVRecord> records = new ArrayList<CSVRecord>();\n-        \n+\n         Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        \n+\n         for (CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n             records.add(record);\n         }\n-        \n+\n         assertEquals(3, records.size());\n         assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, records.get(0).values());\n         assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, records.get(1).values());\n     @Test\n     public void testIterator() throws Exception {\n         Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        \n+\n         Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n-        \n+\n         assertTrue(iterator.hasNext());\n         try {\n             iterator.remove();\n         assertTrue(iterator.hasNext());\n         assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values());\n         assertFalse(iterator.hasNext());\n-        \n+\n         try {\n             iterator.next();\n             fail(\"NoSuchElementException expected\");\n             // expected\n         }\n     }\n-    \n+\n     @Test\n     public void testHeader() throws Exception {\n         Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n         Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n-        \n+\n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n             CSVRecord record = records.next();\n             assertEquals(record.get(1), record.get(\"b\"));\n             assertEquals(record.get(2), record.get(\"c\"));\n         }\n-        \n+\n         assertFalse(records.hasNext());\n     }\n \n         Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n         Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n-        \n+\n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n             CSVRecord record = records.next();\n             assertEquals(record.get(1), record.get(\"b\"));\n             assertEquals(record.get(2), record.get(\"c\"));\n         }\n-        \n+\n         assertFalse(records.hasNext());\n     }\n \n     @Test\n     public void testGetLineNumberWithLF() throws Exception {\n         CSVParser parser = new CSVParser(\"a\\nb\\nc\", CSVFormat.DEFAULT.withLineSeparator(\"\\n\"));\n-        \n+\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n         assertEquals(1, parser.getLineNumber());\n     @Test\n     public void testGetLineNumberWithCRLF() throws Exception {\n         CSVParser parser = new CSVParser(\"a\\r\\nb\\r\\nc\", CSVFormat.DEFAULT.withLineSeparator(CSVFormat.CRLF));\n-        \n+\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n         assertEquals(1, parser.getLineNumber());\n     @Test\n     public void testGetLineNumberWithCR() throws Exception {\n         CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n-        \n+\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n         assertEquals(1, parser.getLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         StringWriter sw = new StringWriter();\n         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.printComment(\"This is a comment\");\n-        \n+\n         assertEquals(\"\", sw.toString());\n     }\n \n         StringWriter sw = new StringWriter();\n         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\");\n-        \n+\n         assertEquals(\"# This is a comment\" + lineSeparator, sw.toString());\n     }\n \n         StringWriter sw = new StringWriter();\n         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\\non multiple lines\");\n-        \n+\n         assertEquals(\"# This is a comment\" + lineSeparator + \"# on multiple lines\" + lineSeparator, sw.toString());\n     }\n \n \n     public void doOneRandom(CSVFormat format) throws Exception {\n         Random r = new Random();\n-        \n+\n         int nLines = r.nextInt(4) + 1;\n         int nCol = r.nextInt(3) + 1;\n         // nLines=1;nCol=2;\n \n     public String randStr() {\n         Random r = new Random();\n-        \n+\n         int sz = r.nextInt(20);\n         // sz = r.nextInt(3);\n         char[] buf = new char[sz];\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public void testReadLookahead2() throws Exception {\n         char[] ref = new char[5];\n         char[] res = new char[5];\n-        \n+\n         ExtendedBufferedReader br = getBufferedReader(\"abcdefg\");\n         ref[0] = 'a';\n         ref[1] = 'b';\n \n     /*\n      * Test to illustrate  https://issues.apache.org/jira/browse/CSV-75\n-     * \n+     *\n      */\n     @Test\n     public void testReadChar() throws Exception {\n         //                EOL        eol        EOL  EOL        eol  eol        EOL+CR        EOL\n         final int EOLeolct=9;\n         ExtendedBufferedReader br;\n-        \n+\n         br = getBufferedReader(test);\n         assertEquals(0, br.getLineNumber());\n         while(br.readLine()!=null) {}\n--- a/src/test/java/org/apache/commons/csv/Utils.java\n+++ b/src/test/java/org/apache/commons/csv/Utils.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- * \n+ *\n  */\n \n package org.apache.commons.csv;\n \n     private Utils() {\n     }\n-    \n+\n     /**\n      * Checks if the two 2d arrays have identical contents.\n-     * \n+     *\n      * @param message the message to be displayed\n      * @param expected the 2d array of expected results\n      * @param actual the 2d array of actual results\n             Assert.assertArrayEquals(message+\" (entry \"+i+\")\",expected[i], actual[i]);\n         }\n     }\n-    \n+\n     /**\n      * Checks if the 2d array has the same contents as the list of records.\n-     * \n+     *\n      * @param message the message to be displayed\n      * @param expected the 2d array of expected results\n      * @param actual the List of {@link CSVRecord} entries, each containing an array of values\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Tests performance.\n- * \n+ *\n  * Only enable for your own development.\n  */\n public class PerformanceTest {", "timestamp": 1347392437, "metainfo": ""}