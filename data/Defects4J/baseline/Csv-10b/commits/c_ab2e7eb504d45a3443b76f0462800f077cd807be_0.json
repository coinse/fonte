{"sha": "ab2e7eb504d45a3443b76f0462800f077cd807be", "log": "- Add final modifier to method parameters. - Add final modifier to local variables.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n                 final Quote quotePolicy, final Character commentStart,\n                 final Character escape, final boolean ignoreSurroundingSpaces,\n                 final boolean ignoreEmptyLines, final String recordSeparator,\n-                String nullToString, final String[] header) {\n+                final String nullToString, final String[] header) {\n             if (isLineBreak(delimiter)) {\n                 throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n             }\n             final Quote quotePolicy, final Character commentStart,\n             final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator,\n-            String nullToString, final String[] header) {\n+            final String nullToString, final String[] header) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n         final Integer index = mapping.get(name);\n         try {\n             return index != null ? values[index.intValue()] : null;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n+        } catch (final ArrayIndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n                     String.format(\n                             \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n     @Test\n     public void testIterator() {\n         int i = 0;\n-        for (Iterator<String> itr = record.iterator(); itr.hasNext();) {\n-            String value = itr.next();\n+        for (final Iterator<String> itr = record.iterator(); itr.hasNext();) {\n+            final String value = itr.next();\n             assertEquals(values[i], value);\n             i++;\n         }\n--- a/src/test/java/org/apache/commons/csv/TokenMatchers.java\n+++ b/src/test/java/org/apache/commons/csv/TokenMatchers.java\n     public static Matcher<Token> hasType(final Token.Type expectedType) {\n         return new TypeSafeDiagnosingMatcher<Token>() {\n \n-            public void describeTo(Description description) {\n+            public void describeTo(final Description description) {\n                 description.appendText(\"token has type \");\n                 description.appendValue(expectedType);\n             }\n \n             @Override\n-            protected boolean matchesSafely(Token item,\n-                    Description mismatchDescription) {\n+            protected boolean matchesSafely(final Token item,\n+                    final Description mismatchDescription) {\n                 mismatchDescription.appendText(\"token type is \");\n                 mismatchDescription.appendValue(item.type);\n                 if (item.type == expectedType) {\n     public static Matcher<Token> hasContent(final String expectedContent) {\n         return new TypeSafeDiagnosingMatcher<Token>() {\n \n-            public void describeTo(Description description) {\n+            public void describeTo(final Description description) {\n                 description.appendText(\"token has content \");\n                 description.appendValue(expectedContent);\n             }\n \n             @Override\n-            protected boolean matchesSafely(Token item,\n-                    Description mismatchDescription) {\n+            protected boolean matchesSafely(final Token item,\n+                    final Description mismatchDescription) {\n                 mismatchDescription.appendText(\"token content is \");\n                 mismatchDescription.appendValue(item.content.toString());\n                 if (expectedContent.equals(item.content.toString())) {\n     public static Matcher<Token> isReady() {\n         return new TypeSafeDiagnosingMatcher<Token>() {\n \n-            public void describeTo(Description description) {\n+            public void describeTo(final Description description) {\n                 description.appendText(\"token is ready \");\n             }\n \n             @Override\n-            protected boolean matchesSafely(Token item,\n-                    Description mismatchDescription) {\n+            protected boolean matchesSafely(final Token item,\n+                    final Description mismatchDescription) {\n                 mismatchDescription.appendText(\"token is not ready \");\n                 return item.isReady;\n             }", "timestamp": 1371764393, "metainfo": ""}