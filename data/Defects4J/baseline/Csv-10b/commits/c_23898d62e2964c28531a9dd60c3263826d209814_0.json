{"sha": "23898d62e2964c28531a9dd60c3263826d209814", "log": "Format JavaDoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n /**\n  * Specifies the format of a CSV file and parses input.\n+ *\n  * <h4>Using predefined formats</h4>\n+ *\n  * <p>\n  * You can use one of the predefined formats:\n  * </p>\n+ *\n  * <ul>\n  *      <li>{@link #DEFAULT}</li>\n  *      <li>{@link #EXCEL}</li>\n  *      <li>{@link #RFC4180}</li>\n  *      <li>{@link #TDF}</li>\n  * </ul>\n- * <p>For example:</p>\n- * <pre>CSVParser parser = CSVFormat.EXCEL.parse(reader);</pre>\n- * <p>The {@link CSVRecord} provides static methods to parse other input types, for example:</p>\n+ *\n+ * <p>\n+ * For example:\n+ * </p>\n+ *\n+ * <pre>\n+ * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n+ * </pre>\n+ *\n+ * <p>\n+ * The {@link CSVRecord} provides static methods to parse other input types, for example:\n+ * </p>\n+ *\n  * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n+ *\n  * <h4>Defining formats</h4>\n+ *\n  * <p>\n  * You can extend a format by calling the {@code with} methods. For example:\n  * </p>\n- * <pre>CSVFormat.EXCEL\n+ *\n+ * <pre>\n+ * CSVFormat.EXCEL\n  *   .withNullString(&quot;N/A&quot;)\n- *   .withIgnoreSurroundingSpaces(true);</pre>\n+ *   .withIgnoreSurroundingSpaces(true);\n+ * </pre>\n+ *\n  * <h4>Defining column names</h4>\n+ *\n  * <p>\n  * To define the column names you want to use to access records, write:\n  * </p>\n- * <pre>CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);</pre>\n+ *\n+ * <pre>\n+ * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n+ * </pre>\n+ *\n  * <p>\n  * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n- * assumes that your CSV source does not contain a first record that also defines column names. If it does, then\n- * you are overriding this metadata with your names and you should skip the first record by calling\n+ * assumes that your CSV source does not contain a first record that also defines column names.\n+ *\n+ * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n  * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n  * </p>\n+ *\n  * <h4>Parsing</h4>\n+ *\n  * <p>\n  * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n  * </p>\n- * <pre>Reader in = ...;\n- *CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);</pre>\n+ *\n+ * <pre>\n+ * Reader in = ...;\n+ * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n+ * </pre>\n+ *\n  * <p>\n  * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n  * </p>\n+ *\n  * <h4>Referencing columns safely</h4>\n+ *\n  * <p>\n  * If your source contains a header record, you can simplify your code and safely reference columns,\n  * by using {@link #withHeader(String...)} with no arguments:\n  * </p>\n- * <pre>CSVFormat.EXCEL.withHeader();</pre>\n+ *\n+ * <pre>\n+ * CSVFormat.EXCEL.withHeader();\n+ * </pre>\n+ *\n  * <p>\n  * This causes the parser to read the first record and use its values as column names.\n+ *\n  * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n  * </p>\n- * <pre>String value = record.get(&quot;Col1&quot;);</pre>\n+ *\n+ * <pre>\n+ * String value = record.get(&quot;Col1&quot;);\n+ * </pre>\n+ *\n  * <p>\n  * This makes your code impervious to changes in column order in the CSV file.\n  * </p>\n+ *\n  * <h4>Notes</h4>\n+ *\n  * <p>\n  * This class is immutable.\n  * </p>\n+ *\n  * @version $Id$\n  */\n public class CSVFormat implements Serializable {", "timestamp": 1379070088, "metainfo": ""}