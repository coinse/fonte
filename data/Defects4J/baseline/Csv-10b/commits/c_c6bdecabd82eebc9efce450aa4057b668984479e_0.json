{"sha": "c6bdecabd82eebc9efce450aa4057b668984479e", "log": "Fixes for typos in comments and javadoc.   ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n   private static final int INITIAL_TOKEN_LENGTH = 50;\n   \n   // the token types\n-  /** Token has no valid content, i.e. is in its initilized state. */\n+  /** Token has no valid content, i.e. is in its initialized state. */\n   protected static final int TT_INVALID = -1;\n   /** Token with content, at beginning or in the middle of a line. */\n   protected static final int TT_TOKEN = 0;\n    * @throws IOException on stream access error\n    */\n   protected Token nextToken(Token tkn) throws IOException {\n-    wsBuf.clear(); // resuse\n+    wsBuf.clear(); // reuse\n     \n     // get the last read char (required for empty line detection)\n     int lastChar = in.readAgain();\n     \n     //  read the next char and set eol\n-    /* note: unfourtunately isEndOfLine may consumes a character silently.\n+    /* note: unfortunately isEndOfLine may consumes a character silently.\n      *       this has no effect outside of the method. so a simple workaround\n      *       is to call 'readAgain' on the stream...\n      *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)\n       }\n     }\n \n-    // did we reached eof during the last iteration already ? TT_EOF\n+    // did we reach eof during the last iteration already ? TT_EOF\n     if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {\n       tkn.type = TT_EOF;\n       return tkn;", "timestamp": 1296470876, "metainfo": ""}