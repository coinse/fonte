{"sha": "b55fb21d78e30748ae19f1c8d16902439643799a", "log": "SANDBOX-206: add escape to strategy, turn off backslash-style escaping by default  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n    * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.\n    */\n   public CSVParser(Reader input, char delimiter) {\n-    this(input, delimiter, '\"', (char) 0);\n+    this(input, delimiter, '\"', CSVStrategy.COMMENTS_DISABLED);\n   }\n   \n   /**\n         eol = isEndOfLine(c);\n       }\n       // ok, start of token reached: comment, encapsulated, or token\n-      if (!strategy.isCommentingDisabled() && c == strategy.getCommentStart()) {\n+      if (c == strategy.getCommentStart()) {\n         // ignore everything till end of line and continue (incr linecount)\n         in.readLine();\n         tkn = nextToken(tkn.reset());\n    */\n   private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n     wsBuf.clear();\n-    while (!tkn.isReady) {\n+    for (;;) {\n       if (isEndOfLine(c)) {\n         // end of record\n         tkn.type = TT_EORECORD;\n         tkn.isReady = true;\n+        return tkn;\n       } else if (isEndOfFile(c)) {\n         // end of file\n         tkn.type = TT_EOF;\n         tkn.isReady = true;\n+        return tkn;\n       } else if (c == strategy.getDelimiter()) {\n         // end of token\n         tkn.type = TT_TOKEN;\n         tkn.isReady = true;\n+        return tkn;\n       } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n         // interpret unicode escaped chars (like \\u0070 -> p)\n         tkn.content.append((char) unicodeEscapeLexer(c));\n         if (tkn.content.length() > 0) {\n           wsBuf.append((char) c);\n         }\n+      } else if (c == strategy.getEscape()) {\n+        tkn.content.append((char)readEscape(c));\n       } else {\n         // prepend whitespaces (if we have)\n         if (wsBuf.length() > 0) {\n         c = in.read();\n       }\n     }\n-    return tkn;\n   }\n   \n   \n     int startLineNumber = getLineNumber();\n     // ignore the given delimiter\n     // assert c == delimiter;\n-    c = in.read();\n-    while (!tkn.isReady) {\n-      boolean skipRead = false;\n-      if (c == strategy.getEncapsulator() || c == '\\\\') {\n-        // check lookahead\n+    for (;;) {\n+      c = in.read();\n+\n+      if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {\n+        tkn.content.append((char) unicodeEscapeLexer(c));\n+      } else if (c == strategy.getEscape()) {\n+        tkn.content.append((char)readEscape(c));\n+      } else if (c == strategy.getEncapsulator()) {\n         if (in.lookAhead() == strategy.getEncapsulator()) {\n           // double or escaped encapsulator -> add single encapsulator to token\n           c = in.read();\n           tkn.content.append((char) c);\n-        } else if (c == '\\\\' && in.lookAhead() == '\\\\') {\n-          // doubled escape char, it does not escape itself, only encapsulator \n-          // -> add both escape chars to stream\n-          tkn.content.append((char) c);\n-          c = in.read();\n-          tkn.content.append((char) c);\n-        } else if (\n-          strategy.getUnicodeEscapeInterpretation()\n-          && c == '\\\\' \n-          && in.lookAhead() == 'u') {\n-          // interpret unicode escaped chars (like \\u0070 -> p)\n-          tkn.content.append((char) unicodeEscapeLexer(c));\n-        } else if (c == '\\\\') {\n-          // use a single escape character -> add it to stream\n-          tkn.content.append((char) c);\n         } else {\n           // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n-          while (!tkn.isReady) {\n+          for (;;) {\n             c = in.read();\n             if (c == strategy.getDelimiter()) {\n               tkn.type = TT_TOKEN;\n               tkn.isReady = true;\n+              return tkn;\n             } else if (isEndOfFile(c)) {\n               tkn.type = TT_EOF;\n               tkn.isReady = true;\n+              return tkn;\n             } else if (isEndOfLine(c)) {\n               // ok eo token reached\n               tkn.type = TT_EORECORD;\n               tkn.isReady = true;\n+              return tkn;\n             } else if (!isWhitespace(c)) {\n-                // error invalid char between token and next delimiter\n-                throw new IOException(\n-                  \"(line \" + getLineNumber() \n-                  + \") invalid char between encapsulated token end delimiter\"\n-                );\n-              }\n+              // error invalid char between token and next delimiter\n+              throw new IOException(\n+                      \"(line \" + getLineNumber()\n+                              + \") invalid char between encapsulated token end delimiter\"\n+              );\n+            }\n           }\n-          skipRead = true;\n         }\n       } else if (isEndOfFile(c)) {\n         // error condition (end of file before end of token)\n         throw new IOException(\n-          \"(startline \" + startLineNumber + \")\"\n-          + \"eof reached before encapsulated token finished\"\n-          );\n+                \"(startline \" + startLineNumber + \")\"\n+                        + \"eof reached before encapsulated token finished\"\n+        );\n       } else {\n         // consume character\n         tkn.content.append((char) c);\n       }\n-      // get the next char\n-      if (!tkn.isReady && !skipRead) {\n-        c = in.read();\n-      }\n-    }\n-    return tkn;\n+    }\n   }\n   \n   \n     }\n     return ret;\n   }\n+\n+  private int readEscape(int c) throws IOException {\n+    // assume c is the escape char (normally a backslash)\n+    c = in.read();\n+    int out;\n+    switch (c) {\n+      case 'r': out='\\r'; break;\n+      case 'n': out='\\n'; break;\n+      case 't': out='\\t'; break;\n+      case 'b': out='\\b'; break;\n+      case 'f': out='\\f'; break;\n+      default : out=c;\n+    }\n+    return out;\n+  }\n   \n   // ======================================================\n   //  strategies\n--- a/src/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n     private char delimiter;\n     private char encapsulator;\n     private char commentStart;\n+    private char escape;\n     private boolean ignoreLeadingWhitespaces;\n     private boolean interpretUnicodeEscapes;\n     private boolean ignoreEmptyLines;\n \n-    public static char COMMENTS_DISABLED       = (char) 0;\n+    // -2 is used to signal disabled, because it won't be confused with\n+    // an EOF signal (-1), and because \\ufffe in UTF-16 would be\n+    // encoded as two chars (using surrogates) and thus there should never\n+    // be a collision with a real text char.\n+    public static char COMMENTS_DISABLED       = (char)-2;\n+    public static char ESCAPE_DISABLED         = (char)-2;\n \n-    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, true,  false, true);\n-    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, false, false, false);\n-    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '\"', COMMENTS_DISABLED, true,  false, true);\n+    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,  false, true);\n+    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, false, false);\n+    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,  false, true);\n \n \n     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n     public CSVStrategy(\n         char delimiter, \n         char encapsulator, \n-        char commentStart, \n+        char commentStart,\n+        char escape,\n         boolean ignoreLeadingWhitespace, \n         boolean interpretUnicodeEscapes,\n         boolean ignoreEmptyLines) \n         setDelimiter(delimiter);\n         setEncapsulator(encapsulator);\n         setCommentStart(commentStart);\n+        setEscape(escape);\n         setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n         setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n         setIgnoreEmptyLines(ignoreEmptyLines);\n     }\n+\n+    /** @deprecated */\n+    public CSVStrategy(\n+        char delimiter,\n+        char encapsulator,\n+        char commentStart,\n+        boolean ignoreLeadingWhitespace,\n+        boolean interpretUnicodeEscapes,\n+        boolean ignoreEmptyLines)\n+    {\n+        this(delimiter,encapsulator,commentStart,CSVStrategy.ESCAPE_DISABLED,ignoreLeadingWhitespace,interpretUnicodeEscapes,ignoreEmptyLines);\n+    }\n+\n \n     public void setDelimiter(char delimiter) { this.delimiter = delimiter; }\n     public char getDelimiter() { return this.delimiter; }\n     public void setCommentStart(char commentStart) { this.commentStart = commentStart; }\n     public char getCommentStart() { return this.commentStart; }\n     public boolean isCommentingDisabled() { return this.commentStart == COMMENTS_DISABLED; }\n+\n+    public void setEscape(char escape) { this.escape = escape; }\n+    public char getEscape() { return this.escape; }\n \n     public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; }\n     public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n   // encapsulator tokenizer (multi line, delimiter in string)\n   public void testNextToken5() throws IOException {   \n     String code = \n-      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\",\\\"\\\\\\\"\\\"\"\n-      + \",\\\"\\\\,\\\"\" \n-      + \",\\\"\\\"\\\"\\\"\";\n+      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n     parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\",\n         parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";\\n\\t \\n;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";\\\";\", parser.testNextToken());\n-    // escape char in quoted input only escapes delimiter\n-    assertEquals(CSVParser.TT_TOKEN + \";\\\\,;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";\\\";\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";\\n\\t \\n;\", parser.testNextToken());\n+\n   }\n   \n   // change delimiters, comment, encapsulater\n      *       !comment;;;;\n      *       ;;\n      */\n-    String code = \"a;'b and \\\\' more\\n'\\n!comment;;;;\\n;;\";\n+    String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n     parser.setStrategy( new CSVStrategy(';', '\\'', '!') );\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     \"a,b,c,d\\n\"\n     + \" a , b , 1 2 \\n\"\n     + \"\\\"foo baar\\\", b,\\n\"\n-    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n-  String[][] res = { \n+   // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+      + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\";   // changed to use standard CSV escaping\n+  String[][] res = {\n     {\"a\", \"b\", \"c\", \"d\"},\n     {\"a\", \"b\", \"1 2\"}, \n     {\"foo baar\", \"b\", \"\"}, \n     }\n   }\n   \n-  public void testBackslashEscaping() throws IOException {\n+  public void OLDtestBackslashEscaping() throws IOException {\n     String code =\n       \"one,two,three\\n\"\n       + \"on\\\\\\\"e,two\\n\"\n     }\n   }\n   \n+  public void testBackslashEscaping() throws IOException {\n+\n+    // To avoid confusion over the need for escaping chars in java code,\n+    // We will test with a forward slash as the escape char, and a single\n+    // quote as the encapsulator.\n+\n+    String code =\n+      \"one,two,three\\n\" // 0\n+      + \"'',''\\n\"       // 1) empty encapsulators\n+      + \"/',/'\\n\"       // 2) single encapsulators\n+      + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n+      + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n+      + \"/,,/,\\n\"       // 5) separator escaped\n+      + \"//,//\\n\"       // 6) escape escaped\n+      + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n+      + \"\";\n+    String[][] res = {\n+        { \"one\", \"two\", \"three\" }, // 0\n+        { \"\", \"\" },                // 1\n+        { \"'\", \"'\" },              // 2\n+        { \"'\", \"'\" },              // 3\n+        { \"'\", \"'\" },              // 4\n+        { \",\", \",\" },              // 5\n+        { \"/\", \"/\" },              // 6\n+        { \"/\", \"/\" },              // 7\n+      };\n+\n+\n+    CSVStrategy strategy = new CSVStrategy(',','\\'',CSVStrategy.COMMENTS_DISABLED,'/',true,true,true);\n+\n+    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[][] tmp = parser.getAllValues();\n+    assertTrue(tmp.length > 0);\n+    for (int i = 0; i < res.length; i++) {\n+      for (int j = 0; j < tmp[i].length; j++) {\n+        System.out.println(\"'\" + tmp[i][j] + \"'  should be '\" + res[i][j] + \"'\");\n+      }\n+      assertTrue(Arrays.equals(res[i], tmp[i]));\n+    }\n+  }\n+\n+\n     public void testUnicodeEscape() throws IOException {\n       String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n       CSVParser parser = new CSVParser(new StringReader(code));\n--- a/src/test/org/apache/commons/csv/CSVStrategyTest.java\n+++ b/src/test/org/apache/commons/csv/CSVStrategyTest.java\n     // default settings\n     assertEquals(strategy.getDelimiter(), ',');\n     assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n     assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n     assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n     assertEquals(true,  strategy.getIgnoreEmptyLines());\n     parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     assertEquals(strategy.getDelimiter(), ',');\n     assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n     assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n     assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n     assertEquals(true,  strategy.getIgnoreEmptyLines());\n     CSVStrategy strategy = CSVStrategy.EXCEL_STRATEGY;\n     assertEquals(strategy.getDelimiter(), ',');\n     assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n     assertEquals(false,  strategy.getIgnoreLeadingWhitespaces());\n     assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n     assertEquals(false, strategy.getIgnoreEmptyLines());", "timestamp": 1199547446, "metainfo": ""}