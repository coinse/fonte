{"sha": "25f4b3e9985684ed07bfbf8238d9148960001e7e", "log": "Sort methods in AB order.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     }\n \n     /**\n-     * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n-     * entries.\n+     * Returns the current line number in the input stream.\n      * <p/>\n-     * The returned content starts at the current parse-position in the stream.\n-     *\n-     * @return list of {@link CSVRecord} entries, may be empty\n-     * @throws IOException\n-     *             on parse error or input read-failure\n-     */\n-    public List<CSVRecord> getRecords() throws IOException {\n-        List<CSVRecord> records = new ArrayList<CSVRecord>();\n-        CSVRecord rec;\n-        while ((rec = getRecord()) != null) {\n-            records.add(rec);\n-        }\n-        return records;\n+     * ATTENTION: in case your csv has multiline-values the returned number does not correspond to the record-number\n+     *\n+     * @return current line number\n+     */\n+    public int getLineNumber() {\n+        return lexer.getLineNumber();\n     }\n \n     /**\n     }\n \n     /**\n+     * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n+     * entries.\n+     * <p/>\n+     * The returned content starts at the current parse-position in the stream.\n+     *\n+     * @return list of {@link CSVRecord} entries, may be empty\n+     * @throws IOException\n+     *             on parse error or input read-failure\n+     */\n+    public List<CSVRecord> getRecords() throws IOException {\n+        List<CSVRecord> records = new ArrayList<CSVRecord>();\n+        CSVRecord rec;\n+        while ((rec = getRecord()) != null) {\n+            records.add(rec);\n+        }\n+        return records;\n+    }\n+\n+    /**\n      * Initializes the name to index mapping if the format defines a header.\n      */\n     private Map<String, Integer> initializeHeader(CSVFormat format) throws IOException {\n         return new Iterator<CSVRecord>() {\n             private CSVRecord current;\n \n+            private CSVRecord getNextRecord() {\n+                try {\n+                    return getRecord();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n             public boolean hasNext() {\n                 if (current == null) {\n                     current = getNextRecord();\n                 return next;\n             }\n \n-            private CSVRecord getNextRecord() {\n-                try {\n-                    return getRecord();\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n             public void remove() {\n                 throw new UnsupportedOperationException();\n             }\n         };\n     }\n-\n-    /**\n-     * Returns the current line number in the input stream.\n-     * <p/>\n-     * ATTENTION: in case your csv has multiline-values the returned number does not correspond to the record-number\n-     *\n-     * @return current line number\n-     */\n-    public int getLineNumber() {\n-        return lexer.getLineNumber();\n-    }\n }", "timestamp": 1347455688, "metainfo": ""}