{"sha": "0831a08ea788e93c68159318fe8880d435d40c23", "log": "Performance optimisation in parsing.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n      @return HTML\n      */\n     public String html() {\n-        return String.format(\"%s=\\\"%s\\\"\", key, StringEscapeUtils.escapeHtml(value));\n+        return key + \"=\\\"\" + StringEscapeUtils.escapeHtml(value) + \"\\\"\";\n+        // return String.format(\"%s=\\\"%s\\\"\", key, StringEscapeUtils.escapeHtml(value));\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n \n         // pc data only tags (textarea, script): chomp to end tag, add content as text node\n         if (tag.isData()) {\n-            String data = tq.chompTo(\"</\" + tagName);\n+            String data = tq.chompToIgnoreCase(\"</\" + tagName);\n             tq.chompTo(\">\");\n             popStackToClose(tag);\n             \n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n         createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n         createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n         createInline(\"OPTGROUP\").setParent(\"SELECT\"); //  only contain option\n-        createInline(\"OPTION\").setParent(\"SELECT\").setContainDataOnly();\n+        createInline(\"OPTION\").setParent(\"SELECT\").setOptionalClosing();\n         createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n         createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n  */\n public class TokenQueue {\n     private StringBuilder queue;\n-    private StringBuilder lcQueue; // lower-cased clone of the queue, for faster matching \n     private int pos = 0;\n     \n     private static final Character ESC = '\\\\'; // escape char for chomp balanced.\n      */\n     public TokenQueue(String data) {\n         Validate.notNull(data);\n-\n         queue = new StringBuilder(data);\n-        lcQueue = new StringBuilder(data.toLowerCase());\n     }\n \n     /**\n     }\n \n     /**\n-     * Retrieves but does not remove the first characater from the queue.\n+     * Retrieves but does not remove the first character from the queue.\n      * @return First character, or null if empty.\n      */\n     public Character peek() {\n      */\n     public void addFirst(Character c) {\n         queue.insert(pos, c);\n-        lcQueue.insert(pos, Character.toLowerCase(c));\n     }\n \n     /**\n      */\n     public void addFirst(String seq) {\n         queue.insert(pos, seq);\n-        lcQueue.insert(pos, seq.toLowerCase());\n     }\n \n     /**\n      * @return true if the next characters match.\n      */\n     public boolean matches(String seq) {\n-        int len = seq.length();\n-        if (len > remainingLength())\n+        int count = seq.length();\n+        if (count > remainingLength())\n             return false;\n-        String check = lcQueue.substring(pos, pos+len);\n-        return seq.toLowerCase().equals(check);\n+\n+        while (--count >= 0) {\n+            if (Character.toLowerCase(seq.charAt(count)) != Character.toLowerCase(queue.charAt(pos+count)))\n+                return false;\n+        }\n+        return true;\n     }\n     \n \n \n     /**\n      * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n-     * @param seq String to end on (and not include in return, but leave on queue)\n+     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n      * @return The matched data consumed from queue.\n      */\n     public String consumeTo(String seq) {\n-        int offset = lcQueue.indexOf(seq.toLowerCase(), pos);\n+        int offset = queue.indexOf(seq, pos);\n         if (offset != -1) {\n             String consumed = queue.substring(pos, offset);\n             pos += consumed.length();\n             return remainder();\n         }\n     }\n+    \n+    public String consumeToIgnoreCase(String seq) {\n+        int start = pos;\n+        String first = seq.substring(0, 1);\n+        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n+        while (!isEmpty() && !matches(seq)) {\n+            if (canScan) {\n+                int skip = queue.indexOf(first, pos) - pos;\n+                if (skip <= 0)\n+                    pos++;\n+                else if (skip < 0) // no chance of finding, grab to end\n+                    pos = queue.length() - 1;\n+                else\n+                    pos += skip;\n+            }\n+            else\n+                pos++;\n+        }\n+\n+        String data = queue.substring(start, pos); \n+        return data; \n+    }\n \n     /**\n      Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n-     @param seq any number of terminators to consume to\n-     @return consumed string\n-     */\n+     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n+     @return consumed string   \n+     */\n+    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n+    // is is a case sensitive time...\n     public String consumeToAny(String... seq) {\n-        StringBuilder accum = new StringBuilder();\n-        while (!isEmpty() && !matchesAny(seq))\n-            accum.append(consume());\n-\n-        return accum.toString();\n+        int start = pos;\n+        while (!isEmpty() && !matchesAny(seq)) {\n+            pos++;\n+        }\n+\n+        String data = queue.substring(start, pos); \n+        return data; \n     }\n \n     /**\n      * <p>\n      * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n      * isEmpty() == true).\n-     * @param seq String to match up to, and not include in return, and to pull off queue\n+     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n      * @return Data matched from queue.\n      */\n     public String chompTo(String seq) {\n         String data = consumeTo(seq);\n+        matchChomp(seq);\n+        return data;\n+    }\n+    \n+    public String chompToIgnoreCase(String seq) {\n+        String data = consumeToIgnoreCase(seq); // case insensitive scan\n         matchChomp(seq);\n         return data;\n     }\n     }\n     \n     public String toString() {\n-        return queue.toString();\n+        return queue.substring(pos);\n     }\n }\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n         assertNotNull(p);\n         assertEquals(\"p\", p.tagName());\n     }\n+    \n+    @Test public void parsesUnterminatedTextarea() {\n+        Document doc = Jsoup.parse(\"<body><p><textarea>one<p>two\");\n+        Element t = doc.select(\"textarea\").first();\n+        assertEquals(\"one<p>two\", t.text());\n+    }\n+    \n+    @Test public void parsesUnterminatedOption() {\n+        Document doc = Jsoup.parse(\"<body><p><select><option>One<option>Two</p><p>Three</p>\");\n+        Elements options = doc.select(\"option\");\n+        assertEquals(2, options.size());\n+        assertEquals(\"One\", options.first().text());\n+        assertEquals(\"Two\", options.last().text());\n+    }\n \n     @Test public void createsDocumentStructure() {\n         String html = \"<meta name=keywords /><link rel=stylesheet /><title>jsoup</title><p>Hello world</p>\";\n--- a/src/test/java/org/jsoup/parser/TokenQueueTest.java\n+++ b/src/test/java/org/jsoup/parser/TokenQueueTest.java\n     @Test public void unescape() {\n         assertEquals(\"one ( ) \\\\\", TokenQueue.unescape(\"one \\\\( \\\\) \\\\\\\\\"));\n     }\n+    \n+    @Test public void chompToIgnoreCase() {\n+        String t = \"<textarea>one < two </TEXTarea>\";\n+        TokenQueue tq = new TokenQueue(t);\n+        String data = tq.chompToIgnoreCase(\"</textarea\");\n+        assertEquals(\"<textarea>one < two \", data);\n+        \n+        tq = new TokenQueue(\"<textarea> one two < three </oops>\");\n+        data = tq.chompToIgnoreCase(\"</textarea\");\n+        assertEquals(\"<textarea> one two < three </oops>\", data);\n+    }\n }", "timestamp": 1309605114, "metainfo": ""}