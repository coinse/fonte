{"sha": "19aecf27292e894fefe4552309549325387163d2", "log": "TokenQueue optimisations", "commit": "\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n \n     private Document parse() {\n         while (!tq.isEmpty()) {\n-            if (tq.matches(\"<!--\")) {\n+            if (tq.matchesStartTag()) {\n+                parseStartTag();\n+            } else if (tq.matchesCS(\"</\")) {\n+                parseEndTag();\n+            } else if (tq.matchesCS(\"<!--\")) {\n                 parseComment();\n             } else if (tq.matches(\"<![CDATA[\")) {\n                 parseCdata();\n-            } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) {\n+            } else if (tq.matchesCS(\"<?\") || tq.matchesCS(\"<!\")) {\n                 parseXmlDecl();\n-            } else if (tq.matches(\"</\")) {\n-                parseEndTag();\n-            } else if (tq.matches(\"<\")) {\n-                parseStartTag();\n             } else {\n                 parseTextNode();\n             }\n     private void parseStartTag() {\n         tq.consume(\"<\");\n         String tagName = tq.consumeTagName();\n-\n-        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n-            tq.addFirst(\"&lt;\");\n-            parseTextNode();\n-            return;\n-        }\n+        Validate.notEmpty(tagName, \"Unexpectedly empty tagname. (This should not occur, please report!)\");\n         \n         tq.consumeWhitespace();\n         Attributes attributes = new Attributes();\n     }\n \n     private void parseTextNode() {\n-        String text = tq.consumeTo(\"<\");\n-        TextNode textNode = TextNode.createFromEncoded(text, baseUri);\n+        TextNode textNode;\n+        // special case: handle string like \"hello < there\". first char will be \"<\", because of matchStartTag\n+        if (tq.peek().equals('<')) {\n+            tq.advance();\n+            textNode = new TextNode(\"<\", baseUri);\n+        } else {\n+            String text = tq.consumeTo(\"<\");\n+            textNode = TextNode.createFromEncoded(text, baseUri);\n+        }\n         last().appendChild(textNode);\n     }\n \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n         }\n         return true;\n     }\n-    \n-\n-    /**\n-     Tests if the next characters match any of the sequences.\n+\n+    /**\n+     * Case sensitive match test.\n+     * @param seq\n+     * @return\n+     */\n+    public boolean matchesCS(String seq) {\n+        return queue.startsWith(seq, pos);\n+    }\n+    \n+\n+    /**\n+     Tests if the next characters match any of the sequences. Case insensitive.\n      @param seq\n      @return\n      */\n         return false;\n     }\n \n+    public boolean matchesAny(char... seq) {\n+        if (isEmpty())\n+            return false;\n+\n+        for (char c: seq) {\n+            if (queue.charAt(pos) == c)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean matchesStartTag() {\n+        // micro opt for matching \"<x\"\n+        return (remainingLength() > 2 && queue.charAt(pos) == '<' && Character.isLetterOrDigit(queue.charAt(pos+1)));\n+    }\n+\n     /**\n      * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n      * queue.\n      */\n     public boolean matchChomp(String seq) {\n         if (matches(seq)) {\n-            consume(seq);\n+            pos += seq.length();\n             return true;\n         } else {\n             return false;\n      @return if starts with whitespace\n      */\n     public boolean matchesWhitespace() {\n-        return !isEmpty() && Character.isWhitespace(peek());\n+        return !isEmpty() && Character.isWhitespace(queue.charAt(pos));\n     }\n \n     /**\n      @return if matches a word character\n      */\n     public boolean matchesWord() {\n-        return !isEmpty() && Character.isLetterOrDigit(peek());\n+        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n     }\n \n     /**\n      * @return first character on queue.\n      */\n     public Character consume() {\n-        Character c= queue.charAt(pos);\n+        Character c = queue.charAt(pos);\n         pos++;\n         return c;\n     }\n     public boolean consumeWhitespace() {\n         boolean seen = false;\n         while (matchesWhitespace()) {\n-            consume();\n+            pos++;\n             seen = true;\n         }\n         return seen;\n      */\n     public String consumeTagName() {\n         int start = pos;\n-        while (!isEmpty() && (matchesWord() || matchesAny(\":\", \"_\", \"-\")))\n+        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n             pos++;\n         \n         return queue.substring(start, pos);\n      */\n     public String consumeElementSelector() {\n         int start = pos;\n-        while (!isEmpty() && (matchesWord() || matchesAny(\"|\", \"_\", \"-\")))\n+        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\n             pos++;\n         \n         return queue.substring(start, pos);\n      @return identifier\n      */\n     public String consumeCssIdentifier() {\n-        StringBuilder accum = new StringBuilder();\n-        Character c = peek();\n-        while (!isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) {\n-            accum.append(consume());\n-            c = peek();\n-        }\n-        return accum.toString();\n+        int start = pos;\n+        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n+            pos++;\n+\n+        return queue.substring(start, pos);\n     }\n \n     /**\n      */\n     public String consumeAttributeKey() {\n         int start = pos;\n-        while (!isEmpty() && (matchesWord() || matchesAny(\"-\", \"_\", \":\")))\n+        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n             pos++;\n         \n         return queue.substring(start, pos);", "timestamp": 1309605117, "metainfo": ""}