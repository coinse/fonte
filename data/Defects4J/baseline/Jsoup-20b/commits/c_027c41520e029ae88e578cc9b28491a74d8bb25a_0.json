{"sha": "027c41520e029ae88e578cc9b28491a74d8bb25a", "log": "Parsing optimisation.  Modified TokenQueue to use a StringBuilder + offset to back the queue, instead of a linked list. Reduces memory and CPU use.", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n  * @author Jonathan Hedley\n  */\n public class TokenQueue {\n-    private LinkedList<Character> queue;\n+    private StringBuilder queue;\n+    private int pos = 0;\n     private static final Character ESC = '\\\\'; // escape char for chomp balanced.\n \n     /**\n     public TokenQueue(String data) {\n         Validate.notNull(data);\n \n-        queue = new LinkedList<Character>();\n-        char[] chars = data.toCharArray();\n-        for (char c : chars) {\n-            queue.add(c);\n-        }\n+        queue = new StringBuilder(data);\n     }\n \n     /**\n      * @return true if no data left in queue.\n      */\n     public boolean isEmpty() {\n-        return queue.isEmpty();\n+        return remainingLength() == 0;\n+    }\n+    \n+    private int remainingLength() {\n+        return queue.length() - pos;\n     }\n \n     /**\n      * @return First character, or null if empty.\n      */\n     public Character peek() {\n-        return queue.peek();\n+        return isEmpty() ? null : queue.charAt(pos);\n     }\n \n     /**\n      @param c character to add\n      */\n     public void addFirst(Character c) {\n-        queue.addFirst(c);\n+        queue.insert(pos, c);\n     }\n \n     /**\n      @param seq string to add.\n      */\n     public void addFirst(String seq) {\n-        char[] chars = seq.toCharArray();\n-        for (int i = chars.length - 1; i >= 0; i--) {\n-            addFirst(chars[i]);\n-        }\n+        queue.insert(pos, seq);\n     }\n \n     /**\n      */\n     public boolean matches(String seq) {\n         int len = seq.length();\n-        if (len > queue.size())\n+        if (len > remainingLength())\n             return false;\n-        List<Character> chars = queue.subList(0, len);\n-        char[] seqChars = seq.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            Character found = Character.toLowerCase(chars.get(i));\n-            Character check = Character.toLowerCase(seqChars[i]);\n-            if (!found.equals(check))\n-                return false;\n-        }\n-        return true;\n+        String check = queue.substring(pos, pos+len);\n+        return seq.equalsIgnoreCase(check);\n     }\n \n     /**\n      @return if starts with whitespace\n      */\n     public boolean matchesWhitespace() {\n-        return !queue.isEmpty() && Character.isWhitespace(queue.peek());\n+        return !isEmpty() && Character.isWhitespace(peek());\n     }\n \n     /**\n      @return if matches a word character\n      */\n     public boolean matchesWord() {\n-        return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek());\n+        return !isEmpty() && Character.isLetterOrDigit(peek());\n     }\n \n     /**\n      * @return first character on queue.\n      */\n     public Character consume() {\n-        return queue.removeFirst();\n+        Character c= queue.charAt(pos);\n+        pos++;\n+        return c;\n     }\n \n     /**\n         if (!matches(seq))\n             throw new IllegalStateException(\"Queue did not match expected sequence\");\n         int len = seq.length();\n-        if (len > queue.size())\n+        if (len > remainingLength())\n             throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n-        for (int i = 0; i < len; i++) {\n-            consume();\n-        }\n+        \n+        pos += len;\n     }\n \n     /**\n      */\n     public String consumeToAny(String... seq) {\n         StringBuilder accum = new StringBuilder();\n-        while (!queue.isEmpty() && !matchesAny(seq))\n+        while (!isEmpty() && !matchesAny(seq))\n             accum.append(consume());\n \n         return accum.toString();\n         Character last = null;\n \n         do {\n-            if (queue.isEmpty()) break;\n+            if (isEmpty()) break;\n             Character c = consume();\n             if (last == null || !last.equals(ESC)) {\n                 if (c.equals(open))\n      */\n     public boolean consumeWhitespace() {\n         boolean seen = false;\n-        while (!queue.isEmpty() && Character.isWhitespace(queue.peek())) {\n+        while (matchesWhitespace()) {\n             consume();\n             seen = true;\n         }\n      */\n     public String consumeWord() {\n         StringBuilder wordAccum = new StringBuilder();\n-        while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) {\n-            wordAccum.append(queue.removeFirst());\n+        while (matchesWord()) {\n+            wordAccum.append(consume());\n         }\n         return wordAccum.toString();\n     }\n      */\n     public String consumeCssIdentifier() {\n         StringBuilder accum = new StringBuilder();\n-        Character c = queue.peek();\n-        while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) {\n-            accum.append(queue.removeFirst());\n-            c = queue.peek();\n+        Character c = peek();\n+        while (!isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) {\n+            accum.append(consume());\n+            c = peek();\n         }\n         return accum.toString();\n     }\n      */\n     public String consumeAttributeKey() {\n         StringBuilder accum = new StringBuilder();\n-        while (!queue.isEmpty() && (Character.isLetterOrDigit(queue.peek()) || matchesAny(\"-\", \"_\", \":\"))) {\n-            accum.append(queue.removeFirst());\n+        while (!isEmpty() && (matchesWord() || matchesAny(\"-\", \"_\", \":\"))) {\n+            accum.append(consume());\n         }\n         return accum.toString();\n     }\n      */\n     public String remainder() {\n         StringBuilder accum = new StringBuilder();\n-        while (!queue.isEmpty()) {\n+        while (!isEmpty()) {\n             accum.append(consume());\n         }\n         return accum.toString();", "timestamp": 1309605114, "metainfo": ""}