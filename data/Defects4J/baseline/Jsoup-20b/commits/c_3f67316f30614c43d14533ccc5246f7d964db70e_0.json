{"sha": "3f67316f30614c43d14533ccc5246f7d964db70e", "log": "Parser javadoc", "commit": "\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import java.util.*;\n \n /**\n- Parses HTML into a {@link Document}\n+ Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Parser {\n         }\n     }\n \n+    /**\n+     Parse HTML into a Document.\n+     @param html HTML to parse\n+     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     @return parsed Document\n+     */\n     public static Document parse(String html, String baseUri) {\n         Parser parser = new Parser(html, baseUri, false);\n         return parser.parse();\n     }\n-    \n+\n+    /**\n+     Parse a fragment of HTML into the {@code body} of a Document.\n+     @param bodyHtml fragment of HTML\n+     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     @return Document, with empty head, and HTML parsed into body\n+     */\n     public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n         Parser parser = new Parser(bodyHtml, baseUri, true);\n         return parser.parse();\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n         return true;\n     }\n \n+    /**\n+     Gets if this is a block tag.\n+     @return if block tag\n+     */\n     public boolean isBlock() {\n         return isBlock;\n     }\n \n+    /**\n+     Gets if this tag can contain block tags.\n+     @return if tag can contain block tags\n+     */\n     public boolean canContainBlock() {\n         return canContainBlock;\n     }\n \n+    /**\n+     Gets if this tag is an inline tag.\n+     @return if this tag is an inline tag.\n+     */\n     public boolean isInline() {\n         return !isBlock;\n     }\n \n+    /**\n+     Gets if this tag is a data only tag.\n+     @return if this tag is a data only tag\n+     */\n     public boolean isData() {\n         return !canContainInline && !isEmpty();\n     }\n \n+    /**\n+     Get if this is an empty tag\n+     @return if this is an emtpy tag\n+     */\n     public boolean isEmpty() {\n         return empty;\n     }\n \n+    /**\n+     Get if this tag should preserve whitespace within child text nodes.\n+     @return if preserve whitepace\n+     */\n     public boolean preserveWhitespace() {\n         return preserveWhitespace;\n     }\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n public class TokenQueue {\n     private LinkedList<Character> queue;\n \n+    /**\n+     Create a new TokenQueue.\n+     @param data string of data to back queue.\n+     */\n     public TokenQueue(String data) {\n         Validate.notNull(data);\n \n         return queue.peek();\n     }\n \n+    /**\n+     Add a character to the start of the queue (will be the next character retrieved).\n+     @param c character to add\n+     */\n     public void addFirst(Character c) {\n         queue.addFirst(c);\n     }\n \n+    /**\n+     Add a string to the start of the queue.\n+     @param seq string to add.\n+     */\n     public void addFirst(String seq) {\n         char[] chars = seq.toCharArray();\n         for (int i = chars.length - 1; i >= 0; i--) {\n         }\n     }\n \n+    /**\n+     Tests if queue starts with a whitespace character.\n+     @return if starts with whitespace\n+     */\n     public boolean matchesWhitespace() {\n         return !queue.isEmpty() && Character.isWhitespace(queue.peek());\n     }\n \n+    /**\n+     Test if the queue matches a word character (letter or digit).\n+     @return if matches a word character\n+     */\n     public boolean matchesWord() {\n         return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek());\n     }\n         return consumeToAny(seq);\n     }\n \n+    /**\n+     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n+     @param seq any number of terminators to consume to\n+     @return consumed string\n+     */\n     public String consumeToAny(String... seq) {\n         StringBuilder accum = new StringBuilder();\n         while (!queue.isEmpty() && !matchesAny(seq))\n         return wordAccum.toString();\n     }\n \n+    /**\n+     Consume a HTML class name off the queue (letter, digit, -, _)\n+     @return classname\n+     */\n     public String consumeClassName() {\n         StringBuilder accum = new StringBuilder();\n         Character c = queue.peek();\n         return accum.toString();\n     }\n \n+    /**\n+     Consume an attribute key off the queue (letter, digit, -, _, :\")\n+     @return attribute key\n+     */\n     public String consumeAttributeKey() {\n         StringBuilder accum = new StringBuilder();\n         while (!queue.isEmpty() && (Character.isLetterOrDigit(queue.peek()) || matchesAny(\"-\", \"_\", \":\"))) {\n         return accum.toString();\n     }\n \n+    /**\n+     Consume and return whatever is left on the queue.\n+     @return remained of queue.\n+     */\n     public String remainder() {\n         StringBuilder accum = new StringBuilder();\n         while (!queue.isEmpty()) {", "timestamp": 1309605108, "metainfo": ""}