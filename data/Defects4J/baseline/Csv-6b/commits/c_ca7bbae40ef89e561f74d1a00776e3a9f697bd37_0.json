{"sha": "ca7bbae40ef89e561f74d1a00776e3a9f697bd37", "log": "Extracted the lexer from CSVParser in a distinct class (suggested by Bob Smith)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import java.util.List;\n import java.util.NoSuchElementException;\n \n-import static org.apache.commons.csv.CSVParser.Token.Type.*;\n+import org.apache.commons.csv.CSVLexer.Token;\n+\n+import static org.apache.commons.csv.CSVLexer.Token.Type.*;\n \n /**\n  * Parses CSV files according to the specified configuration.\n  */\n public class CSVParser implements Iterable<String[]> {\n \n-    /** length of the initial token (content-)buffer */\n-    private static final int INITIAL_TOKEN_LENGTH = 50;\n-\n     /** Immutable empty String array. */\n     private static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n-    /** The input stream */\n-    private final ExtendedBufferedReader in;\n-\n-    private final CSVFormat format;\n-\n+    private CSVLexer lexer;\n+    \n     // the following objects are shared to reduce garbage\n     \n     /** A record buffer for getLine(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n     private final Token reusableToken = new Token();\n-    private final CharBuffer wsBuf = new CharBuffer();\n-\n-    /**\n-     * Token is an internal token representation.\n-     * <p/>\n-     * It is used as contract between the lexer and the parser.\n-     */\n-    static class Token {\n-\n-        enum Type {\n-            /** Token has no valid content, i.e. is in its initialized state. */\n-            INVALID,\n-            \n-            /** Token with content, at beginning or in the middle of a line. */\n-            TOKEN,\n-            \n-            /** Token (which can have content) when end of file is reached. */\n-            EOF,\n-            \n-            /** Token with content when end of a line is reached. */\n-            EORECORD\n-        }\n-        \n-        /** Token type */\n-        Type type = INVALID;\n-        \n-        /** The content buffer. */\n-        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n-        \n-        /** Token ready flag: indicates a valid token with content (ready for the parser). */\n-        boolean isReady;\n-\n-        Token reset() {\n-            content.clear();\n-            type = INVALID;\n-            isReady = false;\n-            return this;\n-        }\n-    }\n-\n-    // ======================================================\n-    //  the constructor\n-    // ======================================================\n \n     /**\n      * CSV parser using the default {@link CSVFormat}.\n             input = new UnicodeUnescapeReader(input);\n         }\n         \n-        this.in = new ExtendedBufferedReader(input);\n-        this.format = format;\n+        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n     }\n \n     /**\n         this(new StringReader(input), format);\n     }\n \n-    // ======================================================\n-    //  the parser\n-    // ======================================================\n \n     /**\n      * Parses the CSV according to the given format and returns the content\n         record.clear();\n         while (true) {\n             reusableToken.reset();\n-            nextToken(reusableToken);\n+            lexer.nextToken(reusableToken);\n             switch (reusableToken.type) {\n                 case TOKEN:\n                     record.add(reusableToken.content.toString());\n      * @return current line number\n      */\n     public int getLineNumber() {\n+        return lexer.getLineNumber();\n+    }\n+}\n+\n+\n+class CSVLexer {\n+\n+    /** length of the initial token (content-)buffer */\n+    private static final int INITIAL_TOKEN_LENGTH = 50;\n+    \n+    private final CharBuffer wsBuf = new CharBuffer();\n+    \n+    private CSVFormat format;\n+    \n+    /** The input stream */\n+    private ExtendedBufferedReader in;\n+\n+    /**\n+     * Token is an internal token representation.\n+     * <p/>\n+     * It is used as contract between the lexer and the parser.\n+     */\n+    static class Token {\n+\n+        enum Type {\n+            /** Token has no valid content, i.e. is in its initialized state. */\n+            INVALID,\n+            \n+            /** Token with content, at beginning or in the middle of a line. */\n+            TOKEN,\n+            \n+            /** Token (which can have content) when end of file is reached. */\n+            EOF,\n+            \n+            /** Token with content when end of a line is reached. */\n+            EORECORD\n+        }\n+        \n+        /** Token type */\n+        Type type = INVALID;\n+        \n+        /** The content buffer. */\n+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n+        \n+        /** Token ready flag: indicates a valid token with content (ready for the parser). */\n+        boolean isReady;\n+\n+        Token reset() {\n+            content.clear();\n+            type = INVALID;\n+            isReady = false;\n+            return this;\n+        }\n+    }\n+\n+    CSVLexer(CSVFormat format, ExtendedBufferedReader in) {\n+        this.format = format;\n+        this.in = in;\n+    }\n+\n+    public int getLineNumber() {\n         return in.getLineNumber();\n     }\n-\n-    // ======================================================\n-    //  the lexer(s)\n-    // ======================================================\n \n     /**\n      * Returns the next token.\n     }\n \n     /**\n-     * Obtain the specified CSV format.\n-     *\n-     * @return format currently being used\n-     */\n-    public CSVFormat getFormat() {\n-        return this.format;\n-    }\n-\n-    // ======================================================\n-    //  Character class checker\n-    // ======================================================\n-\n-    /**\n      * @return true if the given char is a whitespace character\n      */\n     private boolean isWhitespace(int c) {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.csv.CSVLexer.Token;\n+\n+import static org.apache.commons.csv.CSVLexer.Token.Type.*;\n+\n+public class CSVLexerTest extends TestCase {\n+    \n+    private CSVLexer getLexer(String input, CSVFormat format) {\n+        return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n+    }\n+\n+    private void assertTokenEquals(Token.Type expectedType, String expectedContent, Token token) {\n+        assertEquals(\"Token type\", expectedType, token.type);\n+        assertEquals(\"Token content\", expectedContent, token.content.toString());\n+    }\n+    \n+    // Single line (without comment)\n+    public void testNextToken1() throws IOException {\n+        String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n+        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"lmnop\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"qrst\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"uv\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"wxy\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"z\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n+    }\n+\n+    // multiline including comments (and empty lines)\n+    public void testNextToken2() throws IOException {\n+        /*   file:   1,2,3,\n+        *           a,b x,c\n+        *\n+        *           # this is a comment\n+        *           d,e,\n+        *\n+        */\n+        String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n+        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        \n+        CSVLexer parser = getLexer(code, format);\n+\n+\n+        assertTokenEquals(TOKEN, \"1\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"2\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"3\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"b x\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"c\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"d\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"e\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n+\n+    }\n+\n+    // simple token with escaping\n+    public void testNextToken3() throws IOException {\n+        /* file: a,\\,,b\n+        *       \\,,\n+        */\n+        String code = \"a,\\\\,,b\\n\\\\,,\";\n+        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        CSVLexer parser = getLexer(code, format);\n+\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        // an unquoted single backslash is not an escape char\n+        assertTokenEquals(TOKEN, \"\\\\\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        // an unquoted single backslash is not an escape char\n+        assertTokenEquals(TOKEN, \"\\\\\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n+    }\n+\n+    // encapsulator tokenizer (sinle line)\n+    public void testNextToken4() throws IOException {\n+        /* file:  a,\"foo\",b\n+        *        a,   \" foo\",b\n+        *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n+        *        a,  \" foo \" ,b\n+        */\n+        String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n+        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \" foo\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"foo \", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \" foo \", parser.nextToken(new Token()));\n+//      assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"b\", parser.nextToken(new Token()));\n+    }\n+\n+    // encapsulator tokenizer (multi line, delimiter in string)\n+    public void testNextToken5() throws IOException {\n+        String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n+        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"foo\\n\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"foo\\n  baar ,,,\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"\\n\\t \\n\", parser.nextToken(new Token()));\n+\n+    }\n+\n+    // change delimiters, comment, encapsulater\n+    public void testNextToken6() throws IOException {\n+        /* file: a;'b and \\' more\n+        *       '\n+        *       !comment;;;;\n+        *       ;;\n+        */\n+        String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n+        CSVFormat format = new CSVFormat(';', '\\'', '!');\n+        CSVLexer parser = getLexer(code, format);\n+        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n+        assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n+    }\n+\n+    // From SANDBOX-153\n+    public void testDelimiterIsWhitespace() throws IOException {\n+        String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n+        CSVLexer parser = getLexer(code, CSVFormat.TDF);\n+        assertTokenEquals(TOKEN, \"one\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"two\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"four\", parser.nextToken(new Token()));\n+        assertTokenEquals(TOKEN, \"five\", parser.nextToken(new Token()));\n+        assertTokenEquals(EOF, \"six\", parser.nextToken(new Token()));\n+    }\n+}\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n import junit.framework.TestCase;\n \n-import static org.apache.commons.csv.CSVParser.Token.Type.*;\n-\n /**\n  * CSVParserTest\n  *\n  */\n public class CSVParserTest extends TestCase {\n \n-    /**\n-     * TestCSVParser.\n-     */\n-    class TestCSVParser extends CSVParser {\n-        /**\n-         * Test parser to investigate the type of the internal Token.\n-         *\n-         * @param in a Reader\n-         */\n-        TestCSVParser(Reader in) {\n-            super(in);\n-        }\n-\n-        TestCSVParser(Reader in, CSVFormat format) {\n-            super(in, format);\n-        }\n-\n-        /**\n-         * Calls super.nextToken() and prints out a String representation of token\n-         * type and content.\n-         *\n-         * @return String representation of token type and content\n-         * @throws IOException like {@link CSVParser#nextToken(Token)}\n-         */\n-        public String testNextToken() throws IOException {\n-            Token t = super.nextToken(new Token());\n-            return t.type.name() + \";\" + t.content + \";\";\n-        }\n-    }\n-\n-    // ======================================================\n-    //   lexer tests\n-    // ======================================================\n-\n-    // Single line (without comment)\n-    public void testNextToken1() throws IOException {\n-        String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(TOKEN + \";abc;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";def;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";hijk;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";lmnop;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";qrst;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";uv;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";wxy;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";z;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(EOF + \";;\", parser.testNextToken());\n-    }\n-\n-    // multiline including comments (and empty lines)\n-    public void testNextToken2() throws IOException {\n-        /*   file:   1,2,3,\n-        *           a,b x,c\n-        *\n-        *           # this is a comment\n-        *           d,e,\n-        *\n-        */\n-        String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        \n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n-\n-\n-        assertEquals(TOKEN + \";1;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";2;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";3;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";b x;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";c;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";d;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";e;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(EOF + \";;\", parser.testNextToken());\n-        assertEquals(EOF + \";;\", parser.testNextToken());\n-\n-    }\n-\n-    // simple token with escaping\n-    public void testNextToken3() throws IOException {\n-        /* file: a,\\,,b\n-        *       \\,,\n-        */\n-        String code = \"a,\\\\,,b\\n\\\\,,\";\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n-\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        // an unquoted single backslash is not an escape char\n-        assertEquals(TOKEN + \";\\\\;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        // an unquoted single backslash is not an escape char\n-        assertEquals(TOKEN + \";\\\\;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(EOF + \";;\", parser.testNextToken());\n-    }\n-\n-    // encapsulator tokenizer (sinle line)\n-    public void testNextToken4() throws IOException {\n-        /* file:  a,\"foo\",b\n-        *        a,   \" foo\",b\n-        *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n-        *        a,  \" foo \" ,b\n-        */\n-        String code =\n-                \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";foo;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \"; foo;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";foo ;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \"; foo ;\", parser.testNextToken());\n-//     assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(EOF + \";b;\", parser.testNextToken());\n-    }\n-\n-    // encapsulator tokenizer (multi line, delimiter in string)\n-    public void testNextToken5() throws IOException {\n-        String code =\n-                \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";foo\\n;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(EORECORD + \";foo\\n  baar ,,,;\",\n-                parser.testNextToken());\n-        assertEquals(EOF + \";\\n\\t \\n;\", parser.testNextToken());\n-\n-    }\n-\n-    // change delimiters, comment, encapsulater\n-    public void testNextToken6() throws IOException {\n-        /* file: a;'b and \\' more\n-        *       '\n-        *       !comment;;;;\n-        *       ;;\n-        */\n-        String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVFormat(';', '\\'', '!'));\n-        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(\n-                EORECORD + \";b and ' more\\n;\",\n-                parser.testNextToken());\n-    }\n-\n-\n-    // ======================================================\n-    //   parser tests\n-    // ======================================================\n-\n-    String code =\n-            \"a,b,c,d\\n\"\n+    String code = \"a,b,c,d\\n\"\n                     + \" a , b , 1 2 \\n\"\n                     + \"\\\"foo baar\\\", b,\\n\"\n                     // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n                 + \"\";\n         String[][] res = {\n                 {\" \", \" \", \" \"},         // 1\n-                {\" \\t \", \"  \", \" \"},         // 2\n-                {\" / \", \" , \", \" ,\"},         //3\n+                {\" \\t \", \"  \", \" \"},     // 2\n+                {\" / \", \" , \", \" ,\"},    // 3\n         };\n \n \n         CSVParser parser = new CSVParser(new StringReader(code));\n         String[][] data = parser.getRecords();\n         assertEquals(3, data.length);\n-    }\n-\n-    // From SANDBOX-153\n-    public void testDelimiterIsWhitespace() throws IOException {\n-        String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVFormat.TDF);\n-        assertEquals(TOKEN + \";one;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";two;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";four;\", parser.testNextToken());\n-        assertEquals(TOKEN + \";five;\", parser.testNextToken());\n-        assertEquals(EOF + \";six;\", parser.testNextToken());\n     }\n \n     public void testForEach() {", "timestamp": 1331144512, "metainfo": ""}