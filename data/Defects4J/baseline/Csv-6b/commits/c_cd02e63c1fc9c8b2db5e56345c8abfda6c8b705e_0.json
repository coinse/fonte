{"sha": "cd02e63c1fc9c8b2db5e56345c8abfda6c8b705e", "log": "CSVLexer has been renamed to Lexer. Rename test the same way  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/LexerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.BACKSPACE;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.FF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.TAB;\n+import static org.apache.commons.csv.Token.Type.COMMENT;\n+import static org.apache.commons.csv.Token.Type.EOF;\n+import static org.apache.commons.csv.Token.Type.EORECORD;\n+import static org.apache.commons.csv.Token.Type.TOKEN;\n+import static org.apache.commons.csv.TokenMatchers.hasContent;\n+import static org.apache.commons.csv.TokenMatchers.matches;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ *\n+ * @version $Id$\n+ */\n+public class CSVLexerTest {\n+\n+    private CSVFormat formatWithEscaping;\n+\n+    @Before\n+    public void setUp() {\n+        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n+    }\n+\n+    private Lexer getLexer(final String input, final CSVFormat format) {\n+        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n+    }\n+\n+    @Test\n+    public void testSurroundingSpacesAreDeleted() throws IOException {\n+        final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingSpaces\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+    }\n+\n+    @Test\n+    public void testSurroundingTabsAreDeleted() throws IOException {\n+        final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingTabs\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+    }\n+\n+    @Test\n+    public void testIgnoreEmptyLines() throws IOException {\n+        final String code =\n+                \"first,line,\\n\"+\n+                \"\\n\"+\n+                \"\\n\"+\n+                \"second,line\\n\"+\n+                \"\\n\"+\n+                \"\\n\"+\n+                \"third line \\n\"+\n+                \"\\n\"+\n+                \"\\n\"+\n+                \"last, line \\n\"+\n+                \"\\n\"+\n+                \"\\n\"+\n+                \"\\n\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines(true);\n+        final Lexer parser = getLexer(code, format);\n+\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"line\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"third line \"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"last\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \" line \"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+    }\n+\n+    @Test\n+    public void testComments() throws IOException {\n+        final String code =\n+                \"first,line,\\n\"+\n+                \"second,line,tokenWith#no-comment\\n\"+\n+                \"# comment line \\n\"+\n+                \"third,line,#no-comment\\n\"+\n+                \"# penultimate comment\\n\"+\n+                \"# Final comment\\n\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        final Lexer parser = getLexer(code, format);\n+\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"tokenWith#no-comment\"));\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"comment line\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"third\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\"));\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\"));\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+    }\n+\n+    @Test\n+    public void testCommentsAndEmptyLines() throws IOException {\n+        final String code =\n+                \"1,2,3,\\n\"+                // 1\n+                \"\\n\"+                      // 1b\n+                \"\\n\"+                      // 1c\n+                \"a,b x,c#no-comment\\n\"+    // 2\n+                \"#foo\\n\"+                  // 3\n+                \"\\n\"+                      // 4\n+                \"\\n\"+                      // 4b\n+                \"d,e,#no-comment\\n\"+       // 5\n+                \"\\n\"+                      // 5b\n+                \"\\n\"+                      // 5c\n+                \"# penultimate comment\\n\"+ // 6\n+                \"\\n\"+                      // 6b\n+                \"\\n\"+                      // 6c\n+                \"# Final comment\\n\";       // 7\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n+        assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n+\n+        final Lexer parser = getLexer(code, format);\n+\n+\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"1\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"2\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"3\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1b\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1c\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b x\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"c#no-comment\")); // 2\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"foo\"));           // 3\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 4\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 4b\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"d\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"e\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\"));  // 5\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 5b\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 5c\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\"));              // 6\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 6b\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 6c\n+        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\"));              // 7\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+\n+    }\n+\n+    // simple token with escaping not enabled\n+    @Test\n+    public void testBackslashWithoutEscaping() throws IOException {\n+        /* file: a,\\,,b\n+        *       \\,,\n+        */\n+        final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        assertFalse(format.isEscaping());\n+        final Lexer parser = getLexer(code, format);\n+\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        // an unquoted single backslash is not an escape char\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n+        // an unquoted single backslash is not an escape char\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+    }\n+\n+    // simple token with escaping enabled\n+    @Test\n+    public void testBackslashWithEscaping() throws IOException {\n+        /* file: a,\\,,b\n+        *       \\,,\n+        */\n+        final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n+        final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n+        assertTrue(format.isEscaping());\n+        final Lexer parser = getLexer(code, format);\n+\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\nc\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"d\\r\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"e\"));\n+    }\n+\n+    // encapsulator tokenizer (single line)\n+    @Test\n+    public void testNextToken4() throws IOException {\n+        /* file:  a,\"foo\",b\n+        *        a,   \" foo\",b\n+        *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n+        *        a,  \" foo \" ,b\n+        */\n+        final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo \"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo \"));\n+//      assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"b\"));\n+    }\n+\n+    // encapsulator tokenizer (multi line, delimiter in string)\n+    @Test\n+    public void testNextToken5() throws IOException {\n+        final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\\n\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"foo\\n  baar ,,,\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"\\n\\t \\n\"));\n+\n+    }\n+\n+    // change delimiters, comment, encapsulater\n+    @Test\n+    public void testNextToken6() throws IOException {\n+        /* file: a;'b and \\' more\n+        *       '\n+        *       !comment;;;;\n+        *       ;;\n+        */\n+        final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentStart('!').withDelimiter(';');\n+        final Lexer parser = getLexer(code, format);\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n+    }\n+\n+    // From CSV-1\n+    @Test\n+    public void testDelimiterIsWhitespace() throws IOException {\n+        final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n+        final Lexer parser = getLexer(code, CSVFormat.TDF);\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"one\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"two\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"four\"));\n+        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"five\"));\n+        assertThat(parser.nextToken(new Token()), matches(EOF, \"six\"));\n+    }\n+\n+    @Test\n+    public void testEscapedCR() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testCR() throws Exception {\n+        final Lexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedLF() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testLF() throws Exception {\n+        final Lexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+    }\n+\n+    @Test // TODO is this correct? Do we expect <esc>TAB to be unescaped?\n+    public void testEscapedTab() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testTab() throws Exception {\n+        final Lexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"NotEscaped\"));\n+    }\n+\n+    @Test // TODO is this correct? Do we expect <esc>BACKSPACE to be unescaped?\n+    public void testEscapedBackspace() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testBackspace() throws Exception {\n+        final Lexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"NotEscaped\"));\n+    }\n+\n+    @Test // TODO is this correct? Do we expect <esc>FF to be unescaped?\n+    public void testEscapedFF() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testFF() throws Exception {\n+        final Lexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"NotEscaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedMySqlNullValue() throws Exception {\n+        // MySQL uses \\N to symbolize null values. We have to restore this\n+        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedCharacter() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedControlCharacter() throws Exception {\n+        // we are explicitly using an escape different from \\ here\n+        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedControlCharacter2() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void testEscapingAtEOF() throws Exception {\n+        final String code = \"escaping at EOF is evil\\\\\";\n+        final Lexer lexer = getLexer(code, formatWithEscaping);\n+\n+        lexer.nextToken(new Token());\n+    }\n+}", "timestamp": 1379071543, "metainfo": ""}