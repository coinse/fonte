{"sha": "0383fd51df6ef72e41338d37748959639b788871", "log": "[CSV-68] Use the Builder pattern for CSVFormat.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      * For example for parsing or generating a CSV file on a French system the following format will be used:\n      *\n      * <pre>\n-     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n+     * CSVFormat fmt = CSVFormat.newBuilder(EXCEL).withDelimiter(';').build();\n      * </pre>\n      * Settings are:\n      * <ul>\n         return new CSVFormatBuilder(delimiter);\n     }\n \n+    public static CSVFormatBuilder newBuilder(final CSVFormat format) {\n+        return new CSVFormatBuilder(format);\n+    }\n+    \n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n      * <ul>\n             this.recordSeparator = lineSeparator;\n             this.header = header;\n         }\n+        \n+        /**\n+         * \n+         * Creates a CSVFormatBuilder, using the values of the given CSVFormat.\n+         * \n+         * @param format\n+         *            The format to use values from\n+         */\n+        private CSVFormatBuilder(CSVFormat format) {\n+            this(format.delimiter, format.quoteChar, format.quotePolicy,\n+                    format.commentStart, format.escape,\n+                    format.ignoreSurroundingSpaces, format.ignoreEmptyLines,\n+                    format.recordSeparator, format.header);\n+        }\n \n         /**\n          * Creates a basic CSVFormatBuilder.\n--- a/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.CSVFormat.RFC4180;\n import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n import org.junit.Before;\n     public void testIgnoreEmptyLines() {\n         assertFalse(builder.withIgnoreEmptyLines(false).build().getIgnoreEmptyLines());\n     }\n+    \n+    @Test\n+    public void testCopiedFormatIsEqualToOriginal() {\n+        CSVFormat copyOfRCF4180 = CSVFormat.newBuilder(RFC4180).build();\n+        assertEqualFormats(RFC4180, copyOfRCF4180);\n+    }\n+\n+    @Test\n+    public void testCopiedFormatWithChanges() {\n+        CSVFormat newFormat = CSVFormat.newBuilder(RFC4180).withDelimiter('!').build();\n+        assertTrue(newFormat.getDelimiter() != RFC4180.getDelimiter());\n+    }\n+    \n+    // FIXME implement equals on CSVFormat to allow use of Assert.assertEquals()\n+    private static void assertEqualFormats(CSVFormat expected, CSVFormat acutal) {\n+        assertEquals(expected.getCommentStart(), acutal.getCommentStart());\n+        assertEquals(expected.getDelimiter(), acutal.getDelimiter());\n+        assertEquals(expected.getEscape(), acutal.getEscape());\n+        assertArrayEquals(expected.getHeader(), acutal.getHeader());\n+        assertEquals(expected.getIgnoreEmptyLines(), acutal.getIgnoreEmptyLines());\n+        assertEquals(expected.getIgnoreSurroundingSpaces(), acutal.getIgnoreSurroundingSpaces());\n+        assertEquals(expected.getQuoteChar(), acutal.getQuoteChar());\n+        assertEquals(expected.getQuotePolicy(), acutal.getQuotePolicy());\n+        assertEquals(expected.getRecordSeparator(), acutal.getRecordSeparator());\n+    }\n }", "timestamp": 1353016596, "metainfo": ""}