{"sha": "02b21463e68e7b3d5f3d9980746d131a08a08eed", "log": "SANDBOX-322: CSVPrinter overhaul  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n   // the input stream\n   private final ExtendedBufferedReader in;\n \n-  // TODO: this can be made final if setStrategy is removed\n-  private CSVStrategy strategy;\n+  private final CSVStrategy strategy;\n   \n   // the following objects are shared to reduce garbage \n   /** A record buffer for getLine(). Grows as necessary and is reused. */\n     //  important: make sure a new char gets consumed in each iteration\n     while (!tkn.isReady) {\n       // ignore whitespaces at beginning of a token\n-      while (isWhitespace(c) && !eol) {\n+      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {\n         wsBuf.append((char) c);\n         c = in.read();\n         eol = isEndOfLine(c);\n   // ======================================================\n   \n   /**\n-   * Sets the specified CSV Strategy\n-   *\n-   * @return current instance of CSVParser to allow chained method calls\n-   * @deprecated the strategy should be set in the constructor {@link #CSVParser(Reader,CSVStrategy)}.\n-   */\n-  public CSVParser setStrategy(CSVStrategy strategy) {\n-    this.strategy = strategy;\n-    return this;\n-  }\n-  \n-  /**\n-   * Obtain the specified CSV Strategy\n+   * Obtain the specified CSV Strategy.  This should not be modified.\n    * \n    * @return strategy currently being used\n    */\n--- a/src/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/java/org/apache/commons/csv/CSVPrinter.java\n  */\n package org.apache.commons.csv;\n \n+import java.io.IOException;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.io.Writer;\n public class CSVPrinter {\n \n   /** The place that the values get written. */\n-  protected PrintWriter out;\n+  protected final Writer out;\n+  protected final CSVStrategy strategy;\n \n   /** True if we just began a new line. */\n   protected boolean newLine = true;\n \n-  private CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n+  protected char[] buf = new char[0];  // temporary buffer\n \n   /**\n    * Create a printer that will print values to the given\n-   * stream. Character to byte conversion is done using\n-   * the default character encoding. Comments will be\n-   * written using the default comment character '#'.\n+   * stream following the CSVStrategy.\n+   *\n+   * Currently, only a pure encapsulation strategy or a pure escaping strategy\n+   * is supported.  Hybrid strategies (encapsulation and escaping with a different character) are not supported.\n    *\n    * @param out stream to which to print.\n-   */\n-  public CSVPrinter(OutputStream out) {\n-    this.out = new PrintWriter(out);\n-  }\n-\n-\n-  /**\n-   * Create a printer that will print values to the given\n-   * stream. Comments will be\n-   * written using the default comment character '#'.\n-   *\n-   * @param out stream to which to print.\n-   */\n-  public CSVPrinter(Writer out) {\n-    if (out instanceof PrintWriter) {\n-      this.out = (PrintWriter) out;\n-    } else {\n-      this.out = new PrintWriter(out);\n-    }\n-  }\n-\n-\n-  // ======================================================\n-  //  strategies\n-  // ======================================================\n-  \n-  /**\n-   * Sets the specified CSV Strategy\n-   *\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVPrinter setStrategy(CSVStrategy strategy) {\n-    this.strategy = strategy;\n-    return this;\n-  }\n-  \n-  /**\n-   * Obtain the specified CSV Strategy\n-   * \n-   * @return strategy currently being used\n-   */\n-  public CSVStrategy getStrategy() {\n-    return this.strategy;\n+   * @param strategy describes the CSV variation.\n+   */\n+  public CSVPrinter(Writer out, CSVStrategy strategy) {\n+    this.out = out;\n+    this.strategy = strategy==null ? CSVStrategy.DEFAULT_STRATEGY : strategy;\n   }\n   \n   // ======================================================\n   // ======================================================\n \n   /**\n-   * Print the string as the last value on the line. The value\n-   * will be quoted if needed.\n-   *\n-   * @param value value to be outputted.\n-   */\n-  public void println(String value) {\n-    print(value);\n-    out.println();\n+   * Output a blank line\n+   */\n+  public void println() throws IOException {\n+    out.write(strategy.getPrinterNewline());\n+    newLine = true;\n+  }\n+\n+  public void flush() throws IOException {\n     out.flush();\n-    newLine = true;\n-  }\n-\n-\n-  /**\n-   * Output a blank line\n-   */\n-  public void println() {\n-    out.println();\n-    out.flush();\n-    newLine = true;\n   }\n \n \n    *\n    * @param values values to be outputted.\n    */\n-  public void println(String[] values) {\n+  public void println(String[] values) throws IOException {\n     for (int i = 0; i < values.length; i++) {\n       print(values[i]);\n     }\n-    out.println();\n-    out.flush();\n-    newLine = true;\n-  }\n-\n-\n-  /**\n-   * Print several lines of comma separated values.\n-   * The values will be quoted if needed.  Quotes and\n-   * newLine characters will be escaped.\n-   *\n-   * @param values values to be outputted.\n-   */\n-  public void println(String[][] values) {\n-    for (int i = 0; i < values.length; i++) {\n-      println(values[i]);\n-    }\n-    if (values.length == 0) {\n-      out.println();\n-    }\n-    out.flush();\n-    newLine = true;\n+    println();\n   }\n \n \n    *\n    * @param comment the comment to output\n    */\n-  public void printlnComment(String comment) {\n+  public void printlnComment(String comment) throws IOException {\n     if(this.strategy.isCommentingDisabled()) {\n         return;\n     }\n     if (!newLine) {\n-      out.println();\n-    }\n-    out.print(this.strategy.getCommentStart());\n-    out.print(' ');\n+      println();\n+    }\n+    out.write(this.strategy.getCommentStart());\n+    out.write(' ');\n     for (int i = 0; i < comment.length(); i++) {\n       char c = comment.charAt(i);\n       switch (c) {\n           }\n           // break intentionally excluded.\n         case '\\n' :\n-          out.println();\n-          out.print(this.strategy.getCommentStart());\n-          out.print(' ');\n+          println();\n+          out.write(this.strategy.getCommentStart());\n+          out.write(' ');\n           break;\n         default :\n-          out.print(c);\n+          out.write(c);\n           break;\n       }\n     }\n-    out.println();\n-    out.flush();\n-    newLine = true;\n-  }\n-\n-\n-  /**\n-   * Print the string as the next value on the line. The value\n-   * will be quoted if needed.\n-   *\n-   * @param value value to be outputted.\n-   */\n-  public void print(String value) {\n+    println();\n+  }\n+\n+\n+  public void print(char[] value, int offset, int len, boolean checkForEscape) throws IOException {\n+    if (!checkForEscape) {\n+      if (newLine) {\n+        newLine = false;\n+      } else {\n+        out.write(this.strategy.getDelimiter());\n+      }\n+      out.write(value, offset, len);\n+      return;\n+    }\n+\n+    if (strategy.getEncapsulator() != (char)-2) {\n+      printAndEncapsulate(value, offset, len);\n+    } else if (strategy.getEscape() != (char)-2) {\n+      printAndEscape(value, offset, len);\n+    } else {\n+      out.write(value, offset, len);\n+    }\n+  }\n+\n+  void printSep() throws IOException {\n+    if (newLine) {\n+      newLine = false;\n+    } else {\n+      out.write(this.strategy.getDelimiter());\n+    }\n+  }\n+\n+  void printAndEscape(char[] value, int offset, int len) throws IOException {\n+    int start = offset;\n+    int pos = offset;\n+    int end = offset + len;\n+\n+    char delim = this.strategy.getDelimiter();\n+    char escape = this.strategy.getEscape();\n+\n+    printSep();\n+\n+    while (pos < end) {\n+      char c = value[pos];\n+      if (c == '\\r' || c=='\\n' || c==delim || c==escape) {\n+        // write out segment up until this char\n+        int l = pos-start;\n+        if (l>0) {\n+          out.write(value, start, l);\n+        }\n+        if (c=='\\n') c='n';\n+        else if (c=='\\r') c='r';\n+\n+        out.write(escape);\n+        out.write(c);\n+\n+        start = pos+1; // start on the current char after this one\n+      }\n+\n+      pos++;\n+    }\n+\n+    // write last segment\n+    int l = pos-start;\n+    if (l>0) {\n+      out.write(value, start, l);      \n+    }\n+  }\n+\n+  void printAndEncapsulate(char[] value, int offset, int len) throws IOException {\n+    boolean first = newLine;  // is this the first value on this line?\n     boolean quote = false;\n-    if (value.length() > 0) {\n-      char c = value.charAt(0);\n-      if (newLine\n-        && (c < '0'\n+    int start = offset;\n+    int pos = offset;\n+    int end = offset + len;\n+\n+    char delim = this.strategy.getDelimiter();\n+    char encapsulator = this.strategy.getEncapsulator();\n+\n+    printSep();\n+\n+    if (len <= 0) {\n+      // always quote an empty token that is the first\n+      // on the line, as it may be the only thing on the\n+      // line. If it were not quoted in that case,\n+      // an empty line has no tokens.\n+      if (first) {\n+        quote = true;\n+      }\n+    } else {\n+      char c = value[pos];\n+\n+      // Hmmm, where did this rule come from?\n+      if (first\n+          && (c < '0'\n           || (c > '9' && c < 'A')\n           || (c > 'Z' && c < 'a')\n           || (c > 'z'))) {\n         quote = true;\n-      }\n-      if (c == ' ' || c == '\\f' || c == '\\t') {\n+      // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n+      } else if (c <= '#') {\n+        // Some other chars at the start of a value caused the parser to fail, so for now\n+        // encapsulate if we start in anything less than '#'.  We are being conservative\n+        // by including the default comment char too.\n         quote = true;\n-      }\n-      for (int i = 0; i < value.length(); i++) {\n-        c = value.charAt(i);\n-        if (c == '\"' || c == this.strategy.getDelimiter() || c == '\\n' || c == '\\r') {\n-          quote = true;\n-          c = value.charAt( value.length() - 1 );\n-          break;\n+      } else {\n+        while (pos < end) {\n+          c = value[pos];\n+          if (c=='\\n' || c=='\\r' || c==encapsulator || c==delim) {\n+            quote = true;\n+            break;\n+          }\n+          pos++;\n         }\n-      }\n-      if (c == ' ' || c == '\\f' || c == '\\t') {\n-        quote = true;\n-      }\n-    } else if (newLine) {\n-      // always quote an empty token that is the first\n-      // on the line, as it may be the only thing on the\n-      // line. If it were not quoted in that case,\n-      // an empty line has no tokens.\n-      quote = true;\n-    }\n-    if (newLine) {\n-      newLine = false;\n-    } else {\n-      out.print(this.strategy.getDelimiter());\n-    }\n-    if (quote) {\n-      out.print(escapeAndQuote(value));\n-    } else {\n-      out.print(value);\n-    }\n-    out.flush();\n-  }\n-\n-\n-  /**\n-   * Enclose the value in quotes and escape the quote\n-   * and comma characters that are inside.\n-   *\n-   * @param value needs to be escaped and quoted\n-   * @return the value, escaped and quoted\n-   */\n-  private String escapeAndQuote(String value) {\n-    // the initial count is for the preceding and trailing quotes\n-    int count = 2;\n-    for (int i = 0; i < value.length(); i++) {\n-      switch (value.charAt(i)) {\n-        case '\\\"' :\n-        case '\\n' :\n-        case '\\r' :\n-        case '\\\\' :\n-          count++;\n-          break;\n-        default:\n-          break;\n-      }\n-    }\n-    StringBuffer sb = new StringBuffer(value.length() + count);\n-    sb.append(strategy.getEncapsulator());\n-    for (int i = 0; i < value.length(); i++) {\n-      char c = value.charAt(i);\n-\n-      if (c == strategy.getEncapsulator()) {\n-        sb.append('\\\\').append(c);\n-        continue;\n-      }\n-      switch (c) {\n-        case '\\n' :\n-          sb.append(\"\\\\n\");\n-          break;\n-        case '\\r' :\n-          sb.append(\"\\\\r\");\n-          break;\n-        case '\\\\' :\n-          sb.append(\"\\\\\\\\\");\n-          break;\n-        default :\n-          sb.append(c);\n-      }\n-    }\n-    sb.append(strategy.getEncapsulator());\n-    return sb.toString();\n-  }\n-\n+\n+        if (!quote) {\n+          pos = end-1;\n+          c = value[pos];\n+          // if (c == ' ' || c == '\\f' || c == '\\t') {\n+          // Some other chars at the end caused the parser to fail, so for now\n+          // encapsulate if we end in anything less than ' '\n+          if (c <= ' ') {\n+            quote = true;\n+          }\n+        }\n+      }\n+    }\n+\n+    if (!quote) {\n+      // no encapsulation needed - write out the original value\n+      out.write(value, offset, len);\n+      return;\n+    }\n+\n+    // we hit something that needed encapsulation\n+    out.write(encapsulator);\n+\n+    // Pick up where we left off: pos should be positioned on the first character that caused\n+    // the need for encapsulation.\n+    while (pos<end) {\n+      char c = value[pos];\n+      if (c==encapsulator) {\n+        // write out the chunk up until this point\n+\n+        // add 1 to the length to write out the encapsulator also\n+        out.write(value, start, pos-start+1);\n+        // put the next starting position on the encapsulator so we will\n+        // write it out again with the next string (effectively doubling it)\n+        start = pos;\n+      }\n+      pos++;\n+    }\n+\n+    // write the last segment\n+    out.write(value, start, pos-start);\n+    out.write(encapsulator);    \n+  }\n+\n+  /**\n+   * Print the string as the next value on the line. The value\n+   * will be escaped or encapsulated as needed if checkForEscape==true\n+   *\n+   * @param value value to be outputted.\n+   */\n+  public void print(String value, boolean checkForEscape) throws IOException {\n+    if (!checkForEscape) {\n+      // write directly from string\n+      out.write(value);\n+      return;\n+    }\n+\n+    if (buf.length < value.length()) {\n+      buf = new char[value.length()];\n+    }\n+\n+    value.getChars(0, value.length(), buf, 0);\n+    print(buf, 0, value.length(), checkForEscape);\n+  }\n+\n+  /**\n+   * Print the string as the next value on the line. The value\n+   * will be escaped or encapsulated as needed.\n+   *\n+   * @param value value to be outputted.\n+   */\n+  public void print(String value) throws IOException {\n+    print(value, true);   \n+  }\n }\n--- a/src/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n     private boolean interpretUnicodeEscapes;\n     private boolean ignoreEmptyLines;\n \n+    // controls for output\n+    private String printerNewline = \"\\n\";\n+\n     // -2 is used to signal disabled, because it won't be confused with\n     // an EOF signal (-1), and because \\ufffe in UTF-16 would be\n     // encoded as two chars (using surrogates) and thus there should never\n     // be a collision with a real text char.\n     public static char COMMENTS_DISABLED       = (char)-2;\n     public static char ESCAPE_DISABLED         = (char)-2;\n+    public static char ENCAPSULATOR_DISABLED   = (char)-2;\n \n     public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, \n                                                                  true, false, true);\n              true, interpretUnicodeEscapes, ignoreEmptyLines);\n     }\n \n-\n     public void setDelimiter(char delimiter) { this.delimiter = delimiter; }\n     public char getDelimiter() { return this.delimiter; }\n \n     public void setIgnoreEmptyLines(boolean ignoreEmptyLines) { this.ignoreEmptyLines = ignoreEmptyLines; }\n     public boolean getIgnoreEmptyLines() { return this.ignoreEmptyLines; }\n \n+    public void setPrinterNewline(String newline) {\n+      this.printerNewline = newline;\n+    }\n+    public String getPrinterNewline() {\n+      return this.printerNewline;\n+    }\n+\n     public Object clone() {\n       try {\n         return super.clone();\n--- a/src/java/org/apache/commons/csv/CSVUtils.java\n+++ b/src/java/org/apache/commons/csv/CSVUtils.java\n      * @return the CSV string, will be an empty string if the length of the\n      * value array is 0\n      */\n-    public static String printLine(String[] values) {\n+    public static String printLine(String[] values, CSVStrategy strategy) {\n         // set up a CSVUtils\n         StringWriter stringWriter = new StringWriter();\n-        CSVPrinter csvPrinter = new CSVPrinter(stringWriter);\n+        CSVPrinter csvPrinter = new CSVPrinter(stringWriter, strategy);\n   \n         // check for null values an \"null\" as strings and convert them\n         // into the strings \"null\" and \"\\\"null\\\"\"\n         }\n   \n         // convert to CSV\n-        csvPrinter.println(values);\n-  \n+        try {\n+          csvPrinter.println(values);\n+        } catch (IOException e) {\n+          // should not happen with StringWriter\n+        }\n         // as the resulting string has \\r\\n at the end, we will trim that away\n         return stringWriter.toString().trim();\n     }\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n     TestCSVParser(Reader in) {\n       super(in);\n     }\n+\n+    TestCSVParser(Reader in, CSVStrategy strategy) {\n+      super(in, strategy);\n+    }\n     /**\n      * Calls super.nextToken() and prints out a String representation of token\n      * type and content.\n   public void testNextToken1() throws IOException {\n     String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";hijk;\", parser.testNextToken());\n      * \n      */\n     String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.getStrategy().setIgnoreEmptyLines(false);\n-    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n-    parser.getStrategy().setCommentStart('#');\n+    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n+    // strategy.setIgnoreEmptyLines(false);\n+    strategy.setCommentStart('#');\n+\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+\n+\n     assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";3;\", parser.testNextToken());\n      *       \\,,\n      */\n     String code = \"a,\\\\,,b\\n\\\\,,\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n-    parser.getStrategy().setCommentStart('#');\n+    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n+    strategy.setCommentStart('#');\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     // an unquoted single backslash is not an escape char\n     assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n      String code = \n       \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-     parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n      assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n      assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n      assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n     String code = \n       \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n      *       ;;\n      */\n     String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setStrategy( new CSVStrategy(';', '\\'', '!') );\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVStrategy(';', '\\'', '!'));\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     assertEquals(\n       CSVParser.TT_EORECORD + \";b and ' more\\n;\", \n       {\"\"},\n       {\"world\", \"\"}\n     };\n-    CSVParser parser = new CSVParser(new StringReader(code));\n-    parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n+    CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n     String[][] tmp = parser.getAllValues();\n     assertEquals(res.length, tmp.length);\n     assertTrue(tmp.length > 0);\n     String code;\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n+      CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n       assertTrue(tmp.length > 0);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n       assertTrue(tmp.length > 0);\n     String code;\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n+      CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n       assertTrue(tmp.length > 0);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n       assertTrue(tmp.length > 0);\n     }\n   }\n \n+  public void testBackslashEscaping2() throws IOException {\n+\n+    // To avoid confusion over the need for escaping chars in java code,\n+    // We will test with a forward slash as the escape char, and a single\n+    // quote as the encapsulator.\n+\n+    String code = \"\"\n+      + \" , , \\n\"           // 1)\n+      + \" \\t ,  , \\n\"       // 2)\n+      + \" // , /, , /,\\n\"   // 3)\n+      + \"\";\n+    String[][] res = {\n+        { \" \", \" \", \" \" },         // 1\n+        { \" \\t \", \"  \", \" \" },         // 2\n+        { \" / \", \" , \", \" ,\" },         //3\n+      };\n+\n+\n+    CSVStrategy strategy = new CSVStrategy(',',CSVStrategy.ENCAPSULATOR_DISABLED,CSVStrategy.COMMENTS_DISABLED,'/',false,false,true,true);\n+\n+    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+    String[][] tmp = parser.getAllValues();\n+    assertTrue(tmp.length > 0);\n+\n+    if (!CSVPrinterTest.equals(res, tmp)) {\n+      assertTrue(false);\n+    }\n+\n+  }\n+\n+\n+  public void testDefaultStrategy() throws IOException {\n+\n+    String code = \"\"\n+        + \"a,b\\n\"            // 1)\n+        + \"\\\"\\n\\\",\\\" \\\"\\n\"   // 2)\n+        + \"\\\"\\\",#\\n\"   // 2)\n+        ;\n+    String[][] res = {\n+        { \"a\", \"b\" },\n+        { \"\\n\", \" \" },\n+        { \"\", \"#\" },    // WARNING: TODO: this causes a hang if comments are enabled\n+    };\n+\n+    CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n+    assertEquals(CSVStrategy.COMMENTS_DISABLED, strategy.getCommentStart());\n+\n+    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+    String[][] tmp = parser.getAllValues();\n+    assertTrue(tmp.length > 0);\n+\n+    if (!CSVPrinterTest.equals(res, tmp)) {\n+      assertTrue(false);\n+    }\n+  }\n \n \n     public void testUnicodeEscape() throws IOException {\n     // From SANDBOX-153\n      public void testDelimiterIsWhitespace() throws IOException {\n          String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-         TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-         parser.setStrategy(CSVStrategy.TDF_STRATEGY);\n+         TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVStrategy.TDF_STRATEGY);\n          assertEquals(CSVParser.TT_TOKEN + \";one;\", parser.testNextToken());\n          assertEquals(CSVParser.TT_TOKEN + \";two;\", parser.testNextToken());\n          assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n--- a/src/test/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/org/apache/commons/csv/CSVPrinterTest.java\n  */\n package org.apache.commons.csv;\n \n+import java.io.IOException;\n+import java.io.StringReader;\n import java.io.StringWriter;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n  */\n public class CSVPrinterTest extends TestCase {\n   \n-  String lineSeparator = System.getProperty(\"line.separator\");\n+  String lineSeparator = \"\\n\";\n \n-  public void testPrinter1() {\n+  public void testPrinter1() throws IOException {\n     StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw);\n+    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n     String[] line1 = {\"a\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"a,b\" + lineSeparator, sw.toString());\n   }\n \n-  public void testPrinter2() {\n+  public void testPrinter2() throws IOException {\n     StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw);\n+    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n     String[] line1 = {\"a,b\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n   }\n \n-  public void testPrinter3() {\n+  public void testPrinter3() throws IOException {\n     StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw);\n+    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n     String[] line1 = {\"a, b\", \"b \"};\n     printer.println(line1);\n     assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n   }\n \n-  public void testExcelPrinter1() {\n+  public void testExcelPrinter1() throws IOException {\n     StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw);\n-    printer.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n+    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n     String[] line1 = {\"a\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"a,b\" + lineSeparator, sw.toString());\n   }\n \n-  public void testExcelPrinter2() {\n+  public void testExcelPrinter2() throws IOException {\n     StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw);\n-    printer.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n+    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n     String[] line1 = {\"a,b\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n   }\n \n+\n+  \n+  public void testRandom() throws Exception {\n+    int iter=10000;\n+    strategy = CSVStrategy.DEFAULT_STRATEGY;\n+    doRandom(iter);\n+    strategy = CSVStrategy.EXCEL_STRATEGY;\n+    doRandom(iter);\n+\n+    // Strategy for MySQL\n+    strategy = new CSVStrategy('\\t', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED,'\\\\',false, false, false, false);\n+    doRandom(iter);\n+  }\n+\n+  Random r = new Random();\n+  CSVStrategy strategy;\n+\n+  public void doRandom(int iter) throws Exception {\n+    for (int i=0; i<iter; i++) {\n+      doOneRandom();\n+    }\n+  }\n+\n+  public void doOneRandom() throws Exception {\n+    int nLines = r.nextInt(4)+1;\n+    int nCol = r.nextInt(3)+1;\n+    // nLines=1;nCol=2;\n+    String[][] lines = new String[nLines][];\n+    for (int i=0; i<nLines; i++) {\n+      String[] line = new String[nCol];\n+      lines[i] = line;\n+      for (int j=0; j<nCol; j++) {\n+        line[j] = randStr();\n+      }\n+    }\n+\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw, strategy);\n+\n+    for (int i=0; i<nLines; i++) {\n+      // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));      \n+      printer.println(lines[i]);\n+    }\n+\n+    printer.flush();\n+    String result = sw.toString();\n+    // System.out.println(\"### :\" + printable(result));\n+\n+    StringReader reader = new StringReader(result);\n+\n+    CSVParser parser = new CSVParser(reader, strategy);\n+    String[][] parseResult = parser.getAllValues();\n+\n+    if (!equals(lines, parseResult)) {\n+      System.out.println(\"Printer output :\" + printable(result));\n+      assertTrue(false);\n+    }\n+  }\n+\n+  public static boolean equals(String[][] a, String[][] b) {\n+    for (int i=0; i<a.length; i++) {\n+      String[] linea = a[i];\n+      String[] lineb = b[i];\n+      for (int j=0; j<linea.length; j++) {\n+        String aval = linea[j];\n+        String bval = lineb[j];\n+        if (!aval.equals(bval)) {\n+          System.out.println(\"expected  :\" + printable(aval));\n+          System.out.println(\"got       :\" + printable(bval));\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  public static String printable(String s) {\n+    StringBuffer sb = new StringBuffer();\n+    for (int i=0; i<s.length(); i++) {\n+      char ch = s.charAt(i);\n+      if (ch<=' ' || ch>=128) {\n+        sb.append(\"(\" + (int)ch + \")\");\n+      } else {\n+        sb.append(ch);\n+      }\n+    }\n+    return sb.toString();\n+  }\n+\n+  public String randStr() {\n+    int sz = r.nextInt(20);\n+    // sz = r.nextInt(3);\n+    char[] buf = new char[sz];\n+    for (int i=0; i<sz; i++) {\n+      // stick in special chars with greater frequency\n+      char ch;\n+      int what = r.nextInt(20);\n+      switch (what) {\n+        case 0: ch = '\\r'; break;\n+        case 1: ch = '\\n'; break;\n+        case 2: ch = '\\t'; break;\n+        case 3: ch = '\\f'; break;\n+        case 4: ch = ' ';  break;\n+        case 5: ch = ',';  break;\n+        case 6: ch = '\"';  break;\n+        case 7: ch = '\\''; break;\n+        case 8: ch = '\\\\'; break;\n+        default: ch = (char)r.nextInt(300); break;\n+        // default: ch = 'a'; break;\n+      }\n+      buf[i] = ch;\n+    }\n+    return new String(buf);\n+  }\n+\n }\n--- a/src/test/org/apache/commons/csv/CSVStrategyTest.java\n+++ b/src/test/org/apache/commons/csv/CSVStrategyTest.java\n   //   getters / setters\n   // ======================================================\n   public void testGetSetCommentStart() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    CSVStrategy strategy = parser.getStrategy();\n+    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n     strategy.setCommentStart('#');\n     assertEquals(strategy.getCommentStart(), '#');\n     strategy.setCommentStart('!');\n   }\n \n   public void testGetSetEncapsulator() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    CSVStrategy strategy = parser.getStrategy();\n+    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n     strategy.setEncapsulator('\"');\n     assertEquals(strategy.getEncapsulator(), '\"');\n     strategy.setEncapsulator('\\'');\n   }\n \n   public void testGetSetDelimiter() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    CSVStrategy strategy = parser.getStrategy();\n+    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n     strategy.setDelimiter(';');\n     assertEquals(strategy.getDelimiter(), ';');\n     strategy.setDelimiter(',');\n   }\n \n   public void testSetCSVStrategy() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    CSVStrategy strategy = parser.getStrategy();\n+    CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n     // default settings\n     assertEquals(strategy.getDelimiter(), ',');\n     assertEquals(strategy.getEncapsulator(), '\"');\n     assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n     assertEquals(true,  strategy.getIgnoreEmptyLines());\n     // explicit csv settings\n-    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     assertEquals(strategy.getDelimiter(), ',');\n     assertEquals(strategy.getEncapsulator(), '\"');\n     assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);", "timestamp": 1276704754, "metainfo": ""}