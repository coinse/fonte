{"sha": "ffdfffb8f2ac8fe36e6628622bba1a84a3828cbf", "log": "TRailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  * </p>\n  * <p>\n  * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n- * \n+ *\n  * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n  * </p>\n  * <pre>\n \n     /**\n      * Initializes the name to index mapping if the format defines a header.\n-     * \n+     *\n      * @return null if the format has no header.\n      */\n     private Map<String, Integer> initializeHeader() throws IOException {\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n     }\n \n     /**\n-     * Gets the target Appendable. \n-     * \n-     * @return the target Appendable. \n+     * Gets the target Appendable.\n+     *\n+     * @return the target Appendable.\n      */\n     public Appendable getOut() {\n         return this.out;\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n \n     /**\n      * Puts all values of this record into the given Map.\n-     * \n+     *\n      * @param map The Map to populate.\n      * @return the given map.\n      */\n \n     /**\n      * Converts the values to a List.\n-     * \n+     *\n      * TODO: Maybe make this public?\n      * @return a new List\n      */\n \n     /**\n      * Copies this record into a new Map. The new map is not connect\n-     * \n+     *\n      * @return A new Map. The map is empty if the record has no headers.\n      */\n     public Map<String, String> toMap() {\n--- a/src/main/java/org/apache/commons/csv/Constants.java\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n     static final char LF = '\\n';\n     static final char SP = ' ';\n     static final char TAB = '\\t';\n-    \n+\n     /** ASCII record separator */\n     static final char RS = 30;\n \n     /** ASCII unit separator */\n     static final char US = 31;\n-    \n+\n     static final String EMPTY = \"\";\n \n     /** The end of stream symbol */\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n     public void testDelimiterSameAsCommentStartThrowsException() {\n         CSVFormat.DEFAULT.withDelimiter('!').withCommentStart('!').validate();\n     }\n-    \n+\n     @Test(expected = IllegalStateException.class)\n     public void testDelimiterSameAsEscapeThrowsException() {\n         CSVFormat.DEFAULT.withDelimiter('!').withEscape('!').validate();\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     @Test(expected = IllegalArgumentException.class)\n     public void testParseUrlCharsetNullFormat() throws Exception {\n         final CSVParser parser = CSVParser.parse(new URL(\"http://commons.apache.org\"), Charset.defaultCharset(), null);\n-        parser.close();        \n+        parser.close();\n     }\n \n     @Test", "timestamp": 1396025537, "metainfo": ""}