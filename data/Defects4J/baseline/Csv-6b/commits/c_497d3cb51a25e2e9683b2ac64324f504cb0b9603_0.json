{"sha": "497d3cb51a25e2e9683b2ac64324f504cb0b9603", "log": "Add documentation about parsing CSV content into memory  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  *\n  * <h4>Parsing completely into memory</h4>\n  * <p>\n- * You may also get a List of records:\n+ * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n  * </p>\n  *\n  * <pre>\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n  * List&lt;CSVRecord&gt; list = parser.getRecords();\n  * </pre>\n+ *\n+ * <p>\n+ * There are two constraints that have to be kept in mind:\n+ * </p>\n+ *\n+ * <p>\n+ * <ol>\n+ *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n+ *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n+ *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n+ *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n+ * </ol>\n+ * </p>\n+ *\n  * <p>\n  * Internal parser state is completely covered by the format and the reader-state.\n  * </p>", "timestamp": 1379069613, "metainfo": ""}