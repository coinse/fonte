{"sha": "56ca5858db4765112dca44e5deeda0ac181a6766", "log": "Refactor constants from various classes into a package private Constants class and use static imports.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.COMMA;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.DOUBLE_QUOTE;\n+import static org.apache.commons.csv.Constants.ESCAPE;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.TAB;\n+\n import java.io.IOException;\n import java.io.Reader;\n import java.io.Serializable;\n  */\n public class CSVFormat implements Serializable {\n \n-    private static final String LF = \"\\n\";\n-\n-    private static final char ESCAPE = '\\\\';\n-\n-    private static final char TAB = '\\t';\n-\n-    private static final char DOUBLE_QUOTE = '\"';\n-\n-    private static final char COMMA = ',';\n+    private static final String LF_STR = \"\" + LF;\n \n     private static final long serialVersionUID = 1L;\n \n     /** According to RFC 4180, line breaks are delimited by CRLF */\n-    public static final String CRLF = \"\\r\\n\";\n+    public static final String CRLF = \"\" + CR + LF;\n \n     private final char delimiter;\n     private final char encapsulator;\n \n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n-     * a tab-delimited format with a LF character as the line separator. Values are not quoted and special characters\n+     * a tab-delimited format with a LF_STR character as the line separator. Values are not quoted and special characters\n      * are escaped with '\\'.\n      *\n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n             PRISTINE\n             .withDelimiter(TAB)\n             .withEscape(ESCAPE)\n-            .withLineSeparator(LF);\n+            .withLineSeparator(LF_STR);\n \n     /**\n      * Creates a customized CSV format.\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.COMMENT;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.EMPTY;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.SP;\n+\n import java.io.Flushable;\n import java.io.IOException;\n \n  * Print values as a comma separated list.\n  */\n public class CSVPrinter {\n-\n-    private static final char COMMENT = '#';\n-    private static final String EMPTY = \"\";\n-    private static final char SP = ' ';\n-    private static final char CR = '\\r';\n-    private static final char LF = '\\n';\n     \n     /** The place that the values get written. */\n     private final Appendable out;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+/**\n+ * Constants for this package.\n+ */\n+class Constants {\n+    \n+    static final char BELL = '\\b';\n+    static final char COMMA = ',';\n+    static final char COMMENT = '#';\n+    static final char CR = '\\r';\n+    static final char DOUBLE_QUOTE = '\"';\n+    static final char ESCAPE = '\\\\';\n+    static final char FF = '\\f';\n+    static final char LF = '\\n';\n+    static final char SP = ' ';\n+    static final char TAB = '\\t';\n+    static final String EMPTY = \"\";\n+    \n+    /** The end of stream symbol */\n+    static final int END_OF_STREAM = -1;\n+\n+    /** Undefined state for the lookahead char */\n+    static final int UNDEFINED = -2;\n+\n+\n+}\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.UNDEFINED;\n+\n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.Reader;\n  * {@link #read()}.\n  */\n class ExtendedBufferedReader extends BufferedReader {\n-\n-    private static final char CR = '\\r';\n-\n-    private static final char LF = '\\n';\n-\n-    /** The end of stream symbol */\n-    static final int END_OF_STREAM = -1;\n-\n-    /** Undefined state for the lookahead char */\n-    static final int UNDEFINED = -2;\n \n     /** The last char returned */\n     private int lastChar = UNDEFINED;\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.BELL;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n+import static org.apache.commons.csv.Constants.FF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.TAB;\n+import static org.apache.commons.csv.Constants.UNDEFINED;\n+\n import java.io.IOException;\n \n /**\n  */\n abstract class Lexer {\n \n-    private static final char FF = '\\f';\n-    private static final char BELL = '\\b';\n-    private static final char TAB = '\\t';\n-    private static final char LF = '\\n';\n-    private static final char CR = '\\r';\n-    \n     private final boolean isEncapsulating;\n     private final boolean isEscaping;\n     private final boolean isCommentEnabled;\n             return BELL;\n         case 'f':\n             return FF;\n-        case ExtendedBufferedReader.END_OF_STREAM:\n+        case END_OF_STREAM:\n             throw new IOException(\"EOF whilst processing escape sequence\");\n         default:\n             return c;\n      * @return true if the character is at the start of a line.\n      */\n     boolean isStartOfLine(final int c) {\n-        return c == LF || c == CR || c == ExtendedBufferedReader.UNDEFINED;\n+        return c == LF || c == CR || c == UNDEFINED;\n     }\n \n     /**\n      * @return true if the given character indicates end of file\n      */\n     boolean isEndOfFile(final int c) {\n-        return c == ExtendedBufferedReader.END_OF_STREAM;\n+        return c == END_OF_STREAM;\n     }\n \n     abstract Token nextToken(Token reusableToken) throws IOException;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.UNDEFINED;\n import static org.apache.commons.csv.Token.Type.EOF;\n import static org.apache.commons.csv.Token.Type.EORECORD;\n import static org.apache.commons.csv.Token.Type.TOKEN;\n         //  empty line detection: eol AND (last char was EOL or beginning)\n         if (format.getIgnoreEmptyLines()) {\n             while (eol\n-                    && (lastChar == '\\n' || lastChar == '\\r' || lastChar == ExtendedBufferedReader.UNDEFINED)\n+                    && (lastChar == '\\n' || lastChar == '\\r' || lastChar == UNDEFINED)\n                     && !isEndOfFile(lastChar)) {\n                 // go on char ahead ...\n                 lastChar = c;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer3.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer3.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n import static org.apache.commons.csv.Token.Type.COMMENT;\n import static org.apache.commons.csv.Token.Type.EOF;\n import static org.apache.commons.csv.Token.Type.EORECORD;\n         if (isWhitespace(intch)) { // Must be after EOL check\n             return CharType.WHITESPACE;\n         }\n-        if (intch == ExtendedBufferedReader.END_OF_STREAM) {\n+        if (intch == END_OF_STREAM) {\n             return CharType.EOFCHAR;\n         }\n         return CharType.OTHER;\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n+import static org.apache.commons.csv.Constants.UNDEFINED;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNull;\n     @Test\n     public void testEmptyInput() throws Exception {\n         final ExtendedBufferedReader br = getBufferedReader(\"\");\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n+        assertEquals(END_OF_STREAM, br.read());\n+        assertEquals(END_OF_STREAM, br.lookAhead());\n+        assertEquals(END_OF_STREAM, br.readAgain());\n         assertNull(br.readLine());\n         assertEquals(0, br.read(new char[10], 0, 0));\n     }\n     public void testReadLookahead1() throws Exception {\n         final ExtendedBufferedReader br = getBufferedReader(\"1\\n2\\r3\\n\");\n         assertEquals('1', br.lookAhead());\n-        assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain());\n+        assertEquals(UNDEFINED, br.readAgain());\n         assertEquals('1', br.read());\n         assertEquals('1', br.readAgain());\n \n         assertEquals('\\n', br.readAgain());\n         assertEquals(3, br.getLineNumber());\n \n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+        assertEquals(END_OF_STREAM, br.lookAhead());\n         assertEquals('\\n', br.readAgain());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n-        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+        assertEquals(END_OF_STREAM, br.read());\n+        assertEquals(END_OF_STREAM, br.readAgain());\n+        assertEquals(END_OF_STREAM, br.read());\n+        assertEquals(END_OF_STREAM, br.lookAhead());\n \n     }\n ", "timestamp": 1350045346, "metainfo": ""}