{"sha": "9141cb39e6659340574a96b41d7f463ebdc2610e", "log": "Changed while loops (CSV-55)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     String[] getRecord() throws IOException {\n         String[] result = EMPTY_STRING_ARRAY;\n         record.clear();\n-        while (true) {\n+        do {\n             reusableToken.reset();\n             lexer.nextToken(reusableToken);\n             switch (reusableToken.type) {\n                     throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n                     // unreachable: break;\n             }\n-            if (reusableToken.type != TOKEN) {\n-                break;\n-            }\n-        }\n+        } while (reusableToken.type == TOKEN);\n+        \n         if (!record.isEmpty()) {\n             result = record.toArray(new String[record.size()]);\n         }\n      * @throws IOException on stream access error\n      */\n     private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n-        for (; ;) {\n+        while (true) {\n             if (isEndOfLine(c)) {\n                 // end of record\n                 tkn.type = EORECORD;\n         int startLineNumber = getLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n-        for (; ;) {\n+        while (true) {\n             c = in.read();\n             \n             if (c == format.getEscape()) {\n                     tkn.content.append((char) c);\n                 } else {\n                     // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n-                    for (; ;) {\n+                    while (true) {\n                         c = in.read();\n                         if (c == format.getDelimiter()) {\n                             tkn.type = TOKEN;", "timestamp": 1331565175, "metainfo": ""}