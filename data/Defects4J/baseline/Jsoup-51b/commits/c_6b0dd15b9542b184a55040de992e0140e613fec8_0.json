{"sha": "6b0dd15b9542b184a55040de992e0140e613fec8", "log": "Performance tweaks.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n     public Attribute(String key, String value) {\n         Validate.notEmpty(key);\n         Validate.notNull(value);\n-        this.key = key.trim().toLowerCase().intern(); // attribute keys are interned as often repeated\n+        this.key = key.trim().toLowerCase();\n         this.value = value;\n     }\n \n         return key + \"=\\\"\" + StringEscapeUtils.escapeHtml(value) + \"\\\"\";\n         // return String.format(\"%s=\\\"%s\\\"\", key, StringEscapeUtils.escapeHtml(value));\n     }\n+    \n+    protected void html(StringBuilder accum) {\n+        accum\n+            .append(key)\n+            .append(\"=\\\"\")\n+            .append(StringEscapeUtils.escapeHtml(value))\n+            .append(\"\\\"\");\n+    }\n \n     /**\n      Get the string representation of this attribute, implemented as {@link #html()}.\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n+        html(accum);\n+        return accum.toString();\n+    }\n+    \n+    void html(StringBuilder accum) {\n         for (Attribute attribute : this) {\n             accum.append(\" \");\n-            accum.append(attribute.html());\n+            attribute.html(accum);\n         }\n-        return accum.toString();\n     }\n     \n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     @Override\n-    public Element parent() {\n+    public final Element parent() {\n         return (Element) super.parent();\n     }\n \n         List<Element> siblings = parent().children();\n         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n     }\n+    \n+    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n+        Validate.notNull(search);\n+        Validate.notNull(elements);\n+\n+        for (int i = 0; i < elements.size(); i++) {\n+            E element = elements.get(i);\n+            if (element.equals(search))\n+                return i;\n+        }\n+        return null;\n+    }\n \n     // DOM type methods\n \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     final List<Node> childNodes;\n     final Attributes attributes;\n     String baseUri;\n+    int siblingIndex;\n \n     /**\n      Create a new Node.\n         if (in.parentNode != null)\n             in.parentNode.removeChild(in);\n         \n-        Integer index = indexInList(out, childNodes);\n+        Integer index = out.siblingIndex();\n         childNodes.set(index, in);\n         in.parentNode = this;\n+        in.setSiblingIndex(index);\n         out.parentNode = null;\n     }\n \n     protected void removeChild(Node out) {\n         Validate.isTrue(out.parentNode == this);\n-        int index = indexInList(out, childNodes);\n+        int index = out.siblingIndex();\n         childNodes.remove(index);\n+        reindexChildren();\n         out.parentNode = null;\n     }\n \n     protected void addChildren(Node... children) {\n         addChildren(childNodes.size(), children);\n     }\n-    \n+      \n     protected void addChildren(int index, Node... children) {\n         Validate.noNullElements(children);\n         for (int i = children.length - 1; i >= 0; i--) {\n             childNodes.add(index, in);\n             in.setParentNode(this);\n         }\n+        reindexChildren();\n+    }\n+    \n+    private void reindexChildren() {\n+        for (int i = 0; i < childNodes.size(); i++) {\n+            childNodes.get(i).setSiblingIndex(i);\n+        }\n     }\n \n     protected int nodeDepth() {\n             return null; // root\n         \n         List<Node> siblings = parentNode.childNodes;\n-        Integer index = indexInList(this, siblings);\n+        Integer index = siblingIndex();\n         Validate.notNull(index);\n         if (siblings.size() > index+1)\n             return siblings.get(index+1);\n      */\n     public Node previousSibling() {\n         List<Node> siblings = parentNode.childNodes;\n-        Integer index = indexInList(this, siblings);\n+        Integer index = siblingIndex();\n         Validate.notNull(index);\n         if (index > 0)\n             return siblings.get(index-1);\n      * @see org.jsoup.nodes.Element#elementSiblingIndex()\n      */\n     public Integer siblingIndex() {\n-        return indexInList(this, parent().childNodes);\n-    }\n-\n-    protected static <N extends Node> Integer indexInList(N search, List<N> nodes) {\n-        Validate.notNull(search);\n-        Validate.notNull(nodes);\n-\n-        for (int i = 0; i < nodes.size(); i++) {\n-            N node = nodes.get(i);\n-            if (node.equals(search))\n-                return i;\n-        }\n-        return null;\n+        return siblingIndex;\n+    }\n+    \n+    protected void setSiblingIndex(int siblingIndex) {\n+        this.siblingIndex = siblingIndex;\n     }\n \n     /**\n      @return HTML\n      */\n     public String outerHtml() {\n-        StringBuilder accum = new StringBuilder();\n+        StringBuilder accum = new StringBuilder(32*1024);\n         outerHtml(accum);\n         return accum.toString();\n     }\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n  * @author Jonathan Hedley\n  */\n public class TokenQueue {\n-    private StringBuilder queue;\n+    private String queue;\n     private int pos = 0;\n     \n     private static final Character ESC = '\\\\'; // escape char for chomp balanced.\n      */\n     public TokenQueue(String data) {\n         Validate.notNull(data);\n-        queue = new StringBuilder(data);\n+        queue = data;\n+        //queue = new StringBuilder(data);\n     }\n \n     /**\n      @param c character to add\n      */\n     public void addFirst(Character c) {\n-        queue.insert(pos, c);\n+        addFirst(c.toString());\n     }\n \n     /**\n      @param seq string to add.\n      */\n     public void addFirst(String seq) {\n-        queue.insert(pos, seq);\n+        // not very performant, but an edge case\n+        queue = seq + queue.substring(pos);\n+        pos = 0;\n     }\n \n     /**\n      * @return String of word characters from queue, or empty string if none.\n      */\n     public String consumeWord() {\n-        StringBuilder wordAccum = new StringBuilder();\n-        while (matchesWord()) {\n-            wordAccum.append(consume());\n-        }\n-        return wordAccum.toString();\n+        int start = pos;\n+        while (matchesWord())\n+            pos++;\n+        return queue.substring(start, pos);\n     }\n \n     /**\n      @return attribute key\n      */\n     public String consumeAttributeKey() {\n-        StringBuilder accum = new StringBuilder();\n-        while (!isEmpty() && (matchesWord() || matchesAny(\"-\", \"_\", \":\"))) {\n-            accum.append(consume());\n-        }\n-        return accum.toString();\n+        int start = pos;\n+        while (!isEmpty() && (matchesWord() || matchesAny(\"-\", \"_\", \":\")))\n+            pos++;\n+        \n+        return queue.substring(start, pos);\n     }\n \n     /**", "timestamp": 1309605114, "metainfo": ""}