{"sha": "fc7c7f18cdbb55ca1c1fb708ae573c64e5e3ead5", "log": "Merge remote-tracking branch 'upstream/master'", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n         this.quirksMode = quirksMode;\n         return this;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return super.equals(o);\n+    }\n }\n \n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n         }\n         return data;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return super.equals(o);\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.LinkedList;\n import java.util.List;\n \n /**\n      */\n     @Override\n     public Node clone() {\n-        return doClone(null); // splits for orphan\n-    }\n-\n+        Node thisClone = doClone(null); // splits for orphan\n+\n+        // Queue up nodes that need their children cloned (BFS).\n+        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n+        nodesToProcess.add(thisClone);\n+\n+        while (!nodesToProcess.isEmpty()) {\n+            Node currParent = nodesToProcess.remove();\n+\n+            for (int i = 0; i < currParent.childNodes.size(); i++) {\n+                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n+                currParent.childNodes.set(i, childClone);\n+                nodesToProcess.add(childClone);\n+            }\n+        }\n+\n+        return thisClone;\n+    }\n+\n+    /*\n+     * Return a clone of the node using the given parent (which can be null).\n+     * Not a deep copy of children.\n+     */\n     protected Node doClone(Node parent) {\n         Node clone;\n+\n         try {\n             clone = (Node) super.clone();\n         } catch (CloneNotSupportedException e) {\n         clone.attributes = attributes != null ? attributes.clone() : null;\n         clone.baseUri = baseUri;\n         clone.childNodes = new ArrayList<Node>(childNodes.size());\n+\n         for (Node child: childNodes)\n-            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n+            clone.childNodes.add(child);\n \n         return clone;\n     }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n-            if (offset < length) {\n-                int i = offset + 1;\n-                int last = i + seq.length()-1;\n+            int i = offset + 1;\n+            int last = i + seq.length()-1;\n+            if (offset < length && last <= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n         if (startTag.isSelfClosing()) {\n             Element el = insertEmpty(startTag);\n             stack.add(el);\n+            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                         tb.transition(InHeadNoscript);\n                     } else if (name.equals(\"script\")) {\n                         // skips some script rules as won't execute them\n-                        tb.insert(start);\n+\n                         tb.tokeniser.transition(TokeniserState.ScriptData);\n                         tb.markInsertionMode();\n                         tb.transition(Text);\n+                        tb.insert(start);\n                     } else if (name.equals(\"head\")) {\n                         tb.error(this);\n                         return false;\n                                 commonAncestor.appendChild(lastNode);\n                             }\n \n-                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n+                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n+                            adopter.attributes().addAll(formatEl.attributes());\n                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                             for (Node childNode : childNodes) {\n                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n \n                 .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                 .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n+                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n                 .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                 .addProtocols(\"q\", \"cite\", \"http\", \"https\")\n                 ;\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n      */\n     @Override\n \tpublic Elements clone() {\n+        Elements clone;\n+        try {\n+            clone = (Elements) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeException(e);\n+        }\n     \tList<Element> elements = new ArrayList<Element>();\n+        clone.contents = elements;\n     \t\n     \tfor(Element e : contents)\n     \t\telements.add(e.clone());\n \t\t\n     \t\n-    \treturn new Elements(elements);\n+    \treturn clone;\n \t}\n \n \t// attribute methods\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.junit.Test;\n+import org.junit.Ignore;\n \n import static org.junit.Assert.*;\n \n                 TextUtil.stripNewlines(clone.html()));\n     }\n \n+    // Ignored since this test can take awhile to run.\n+    @Ignore\n+    @Test public void testOverflowClone() {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 100000; i++) {\n+            builder.insert(0, \"<i>\");\n+            builder.append(\"</i>\");\n+        }\n+\n+        Document doc = Jsoup.parse(builder.toString());\n+        doc.clone();\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertEquals(10, r.nextIndexOf(\"Two\"));\n         assertEquals(\"something Two Three Four\", r.consumeToEnd());\n         assertEquals(-1, r.nextIndexOf(\"Two\"));\n+    }\n+\n+    @Test public void nextIndexOfUnmatched() {\n+        CharacterReader r = new CharacterReader(\"<[[one]]\");\n+        assertEquals(-1, r.nextIndexOf(\"]]>\"));\n     }\n \n     @Test public void consumeToChar() {\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         assertEquals(1, div.childNodeSize()); // no elements, one text node\n     }\n \n+    @Test public void handlesUnclosedCdataAtEOF() {\n+        // https://github.com/jhy/jsoup/issues/349 would crash, as character reader would try to seek past EOF\n+        String h = \"<![CDATA[]]\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(1, doc.body().childNodeSize());\n+    }\n+\n     @Test public void handlesInvalidStartTags() {\n         String h = \"<div>Hello < There <&amp;></div>\"; // parse to <div {#text=Hello < There <&>}>\n         Document doc = Jsoup.parse(h);\n \n     @Test public void handlesKnownEmptyBlocks() {\n         // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n-        String h = \"<div id='1' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n-        Document doc = Jsoup.parse(h);\n-        assertEquals(\"<div id=\\\"1\\\"></div><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n+        String h = \"<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void handlesSolidusAtAttributeEnd() {\n                 \"</body>\\n\" +\n                 \"</html>\";\n         assertEquals(want, doc.html());\n+    }\n+\n+    @Test public void handlesUnclosedAnchors() {\n+        String h = \"<a href='http://example.com/'>Link<p>Error link</a>\";\n+        Document doc = Jsoup.parse(h);\n+        String want = \"<a href=\\\"http://example.com/\\\">Link</a>\\n<p><a href=\\\"http://example.com/\\\">Error link</a></p>\";\n+        assertEquals(want, doc.body().html());\n     }\n \n     @Test public void reconstructFormattingElements() {\n \n         assertEquals(\"<table><tbody><tr><form></form><input type=\\\"hidden\\\" id=\\\"1\\\" /><td><input type=\\\"text\\\" id=\\\"2\\\" /></td></tr><tr></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n+\n+    @Test public void handlesInputInTable() {\n+        String h = \"<body>\\n\" +\n+                \"<input type=\\\"hidden\\\" name=\\\"a\\\" value=\\\"\\\">\\n\" +\n+                \"<table>\\n\" +\n+                \"<input type=\\\"hidden\\\" name=\\\"b\\\" value=\\\"\\\" />\\n\" +\n+                \"</table>\\n\" +\n+                \"</body>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(1, doc.select(\"table input\").size());\n+        assertEquals(2, doc.select(\"input\").size());\n+    }\n }\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     }\n \n     /**\n+     * Setter to disable\\enable SSL certificates checks during https connection\n+     * @param value\n+     */\n+    Connection setSecure (boolean value);\n+\n+    /**\n      * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      * Represents a HTTP request.\n      */\n     public interface Request extends Base<Request> {\n+\n+\n         /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * get current state of security enabling\\disabling feature\n+         *\n+         * @return\n+         */\n+        boolean isSecure();\n+\n+        /**\n+         * Disable SSL certificates checks.\n+         * @param value\n+         */\n+        void setSecure(boolean value);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n+import javax.net.ssl.*;\n import java.io.*;\n import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n import java.util.*;\n import java.util.zip.GZIPInputStream;\n \n \tprivate HttpConnection() {\n         req = new Request();\n         res = new Response();\n+    }\n+\n+    public Connection setSecure(boolean value) {\n+        req.setSecure(value);\n+        return this;\n     }\n \n     public Connection url(URL url) {\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n-\n-      \tprivate Request() {\n+        private boolean secure = true;\n+\n+        private Request() {\n             timeoutMilliseconds = 3000;\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n         public Parser parser() {\n             return parser;\n         }\n+\n+        public boolean isSecure() {\n+            return secure;\n+        }\n+\n+        public void setSecure(boolean value) {\n+            secure = value;\n+        }\n     }\n \n     public static class Response extends Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private static SSLSocketFactory sslSocketFactory;\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n             HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n             conn.setReadTimeout(req.timeout());\n+            if (!req.isSecure()) {\n+                initUnSecureSSL();\n+                ( (HttpsURLConnection) conn ).setSSLSocketFactory(sslSocketFactory);\n+            }\n             if (req.method() == Method.POST)\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(header.getKey(), header.getValue());\n             }\n             return conn;\n+        }\n+\n+        private static void initUnSecureSSL() throws IOException {\n+            if ( sslSocketFactory == null) {\n+                // Create a trust manager that does not validate certificate chains\n+                final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n+\n+                    public void checkClientTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public void checkServerTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                } };\n+\n+                // Install the all-trusting trust manager\n+                final SSLContext sslContext;\n+                try {\n+                    sslContext = SSLContext.getInstance(\"SSL\");\n+                    sslContext.init( null, trustAllCerts, new java.security.SecureRandom() );\n+                    // Create an ssl socket factory with our all-trusting manager\n+                    sslSocketFactory = sslContext.getSocketFactory();\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                } catch (KeyManagementException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                }\n+            }\n+\n         }\n \n         // set up url, method, header, cookies", "timestamp": 1383929146, "metainfo": ""}