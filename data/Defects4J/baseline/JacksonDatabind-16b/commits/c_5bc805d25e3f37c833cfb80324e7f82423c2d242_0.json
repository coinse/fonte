{"sha": "5bc805d25e3f37c833cfb80324e7f82423c2d242", "log": "Merge pull request #155 from fge/master  Make ArrayNode and ObjectNode final", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n package com.fasterxml.jackson.databind.node;\n \n-import java.io.IOException;\n-import java.math.BigDecimal;\n-import java.util.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.util.EmptyIterator;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n \n /**\n  * Node class that represents Arrays mapped from Json content.\n  */\n-public class ArrayNode\n+public final class ArrayNode\n     extends ContainerNode<ArrayNode>\n {\n-    protected final List<JsonNode> _children = new ArrayList<JsonNode>();\n+    private final List<JsonNode> _children = new ArrayList<JsonNode>();\n \n     public ArrayNode(JsonNodeFactory nc) { super(nc); }\n \n     @Override\n     public ArrayNode deepCopy()\n     {\n-        /* 28-Sep-2012, tatu: Sub-classes really should override this method to\n-         *   produce compliant copies.\n-         */\n-        if (getClass() != ArrayNode.class) {\n-            throw new IllegalStateException(\"ArrayNode subtype (\"+getClass().getName()+\" does not override deepCopy(), needs to\");\n-        }\n-        return _defaultDeepCopy();\n-    }\n-\n-    /**\n-     * Default implementation for 'deepCopy()': can be delegated to by sub-classes\n-     * if necessary; but usually isn't.\n-     */\n-    protected ArrayNode _defaultDeepCopy()\n-    {\n-        final int len = _children.size();\n-        final ArrayNode ret = new ArrayNode(_nodeFactory);\n-\n-        for (JsonNode child : _children)\n-            ret._children.add(child.deepCopy());\n+        ArrayNode ret = new ArrayNode(_nodeFactory);\n+\n+        for (JsonNode element: _children)\n+            ret._children.add(element.deepCopy());\n \n         return ret;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Implementation of core JsonNode API\n      */\n \n     @Override\n-    public final JsonNodeType getNodeType()\n+    public JsonNodeType getNodeType()\n     {\n         return JsonNodeType.ARRAY;\n     }\n      */\n \n     @Override\n-    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+    public void serialize(JsonGenerator jg, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartArray();\n \n     /*\n     /**********************************************************\n-    /* Package methods (for other node classes to use)\n-    /**********************************************************\n-     */\n-\n-    protected void addContentsTo(List<JsonNode> dst)\n-    {\n-        dst.addAll(_children);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Overridable methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller does not know what\n-     * optimal size would, used for example when constructing a Map when adding\n-     * the first one.\n-     * \n-     * @since 2.1\n-     */\n-    protected List<JsonNode> _createList() {\n-        return new ArrayList<JsonNode>();\n-    }\n-    \n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller has an idea of what\n-     * optimal size should be: used when copying contents of an existing node.\n-     * \n-     * @since 2.1\n-     */\n-    protected List<JsonNode> _createList(int defaultSize) {\n-        return new ArrayList<JsonNode>(defaultSize);\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Standard methods\n     /**********************************************************\n      */\n \n     @Override\n-    public final boolean equals(Object o)\n+    public boolean equals(Object o)\n     {\n         if (o == this) return true;\n         if (o == null) return false;\n-        if (!(o instanceof ArrayNode)) {\n+        if (getClass() != o.getClass()) {\n             return false;\n         }\n         return _children.equals(((ArrayNode) o)._children);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n package com.fasterxml.jackson.databind.node;\n \n-import java.io.IOException;\n-import java.math.BigDecimal;\n-import java.util.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.util.EmptyIterator;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Node that maps to JSON Object structures in JSON content.\n  */\n-public class ObjectNode\n+public final class ObjectNode\n     extends ContainerNode<ObjectNode>\n {\n     // Note: LinkedHashMap for backwards compatibility\n-    protected final Map<String, JsonNode> _children\n+    private final Map<String, JsonNode> _children\n         = new LinkedHashMap<String, JsonNode>();\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n     @Override\n     public ObjectNode deepCopy()\n     {\n-        /* 28-Sep-2012, tatu: Sub-classes really should override this method to\n-         *   produce compliant copies.\n-         */\n-        if (getClass() != ObjectNode.class) {\n-            throw new IllegalStateException(\"ObjectNode subtype (\"+getClass().getName()+\" does not override deepCopy(), needs to\");\n-        }\n-        return _defaultDeepCopy();\n-    }\n- \n-    /**\n-     * Default implementation for 'deepCopy()': can be delegated to by sub-classes\n-     * if necessary; but usually isn't.\n-     */\n-    protected ObjectNode _defaultDeepCopy()\n-    {\n-        final int len = _children.size();\n-        final ObjectNode ret = new ObjectNode(_nodeFactory);\n-\n-        for (Map.Entry<String, JsonNode> entry : _children.entrySet())\n+        ObjectNode ret = new ObjectNode(_nodeFactory);\n+\n+        for (Map.Entry<String, JsonNode> entry: _children.entrySet())\n             ret._children.put(entry.getKey(), entry.getValue().deepCopy());\n \n         return ret;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Implementation of core JsonNode API\n      */\n \n     @Override\n-    public final JsonNodeType getNodeType()\n+    public JsonNodeType getNodeType()\n     {\n         return JsonNodeType.OBJECT;\n     }\n      * all of its descendants using specified JSON generator.\n      */\n     @Override\n-    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+    public void serialize(JsonGenerator jg, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartObject();\n      */\n     public JsonNode setAll(ObjectNode other)\n     {\n-        int len = other.size();\n-        if (len > 0) {\n-            other.putContentsTo(_children);\n-        }\n+        other._children.putAll(_children);\n         return this;\n     }\n     \n \n     /*\n     /**********************************************************\n-    /* Overridable methods\n-    /**********************************************************\n-     */\n-\n-    /*\n-    /**********************************************************\n-    /* Package methods (for other node classes to use)\n-    /**********************************************************\n-     */\n-\n-    protected void putContentsTo(Map<String,JsonNode> dst)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String,JsonNode> en : _children.entrySet()) {\n-                dst.put(en.getKey(), en.getValue());\n-            }\n-        }\n-    }\n-\n-    /*\n-    /**********************************************************\n     /* Standard methods\n     /**********************************************************\n      */\n \n     @Override\n-    public final boolean equals(Object o)\n+    public boolean equals(Object o)\n     {\n         if (o == this) return true;\n         if (o == null) return false;\n         \n         // minor improvement, wrt [Issue#70]\n-        if (o.getClass() != getClass() && !(o instanceof ObjectNode)) {\n+        if (getClass() != o.getClass()) {\n             return false;\n         }\n-        /* This is bit convoluted, but the goal is to make it possible to\n-         * fully override equality comparison, even though it is\n-         * asymmetric (i.e. can be called on either side, but we\n-         * want behavior to match).\n-         */\n-        return _equals((ObjectNode) o);\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     * \n-     * @since 2.1\n-     */\n-    protected boolean _equals(ObjectNode other)\n-    {\n-        return _children.equals(other._children);\n+        return _children.equals(((ObjectNode) o)._children);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n \n     /*\n     /**********************************************************\n-    /* Extended API\n+    /* Extended API, iteration\n     /**********************************************************\n      */\n \n         _parser.clearCurrentToken();\n         return result;\n     }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @return\n+     * \n+     * @since 2.2\n+     */\n+    public List<T> readAll() throws IOException {\n+    \treturn readAll(new ArrayList<T>());\n+    }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @return\n+     * \n+     * @since 2.2\n+     */\n+    public List<T> readAll(List<T> resultList) throws IOException\n+    {\n+    \twhile (hasNextValue()) {\n+    \t\tresultList.add(nextValue());\n+    \t}\n+    \treturn resultList;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for getting underlying parser this iterator uses.\n+     * \n+     * @since 2.2\n+     */\n+    public JsonParser getParser() {\n+    \treturn _parser;\n+    }\n+\n+    /**\n+     * Accessor for accessing {@link FormatSchema} that the underlying parser\n+     * (as per {@link #getParser}) is using, if any; only parser of schema-aware\n+     * formats use schemas.\n+     * \n+     * @since 2.2\n+     */\n+    public FormatSchema getParserSchema() {\n+    \treturn _parser.getSchema();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n                 }\n             }\n             if (schemaNode == null) {\n-                schemaNode = JsonSchema.getDefaultSchemaNode();\n+                schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n             }\n             o.put(\"items\", schemaNode);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n                     JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property);\n                     JsonNode schemaNode = (ser instanceof SchemaAware) ?\n                             ((SchemaAware) ser).getSchema(provider, null) :\n-                            JsonSchema.getDefaultSchemaNode();\n+                            \tcom.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n                     propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue), schemaNode);\n                 }\n                 o.put(\"properties\", propsNode);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n                 Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass();\n                 // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n                 if (componentType == Object.class) {\n-                    o.put(\"items\", JsonSchema.getDefaultSchemaNode());\n+                    o.put(\"items\", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode());\n                 } else {\n                     JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property);\n                     JsonNode schemaNode = (ser instanceof SchemaAware) ?\n                             ((SchemaAware) ser).getSchema(provider, null) :\n-                            JsonSchema.getDefaultSchemaNode();\n+                            \tcom.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();\n                     o.put(\"items\", schemaNode);\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n                 // otherwise move things around\n                 T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);\n                 System.arraycopy(array, 0, result, 1, ix);\n-                array[0] = element;\n+                result[0] = element;\n+                ++ix;\n+                int left = len - ix;\n+                if (left > 0) {\n+                \tSystem.arraycopy(array, ix, result, ix, left);\n+                }\n                 return result;\n             }\n         }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ArrayBuildersTest.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import org.junit.Assert;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+\n+public class ArrayBuildersTest extends BaseMapTest\n+{\n+\t// Test for [Issue#157]\n+\tpublic void testInsertInListNoDup()\n+\t{\n+        String [] arr = new String[]{\"me\", \"you\", \"him\"};\n+        String [] newarr;\n+        \n+        newarr = ArrayBuilders.insertInListNoDup(arr, \"you\");\n+        Assert.assertArrayEquals(new String[]{\"you\", \"me\", \"him\"}, newarr);\n+\n+        newarr = ArrayBuilders.insertInListNoDup(arr, \"me\");\n+        Assert.assertArrayEquals(new String[]{\"me\", \"you\",\"him\"}, newarr);\n+\n+        newarr = ArrayBuilders.insertInListNoDup(arr, \"him\");\n+        Assert.assertArrayEquals(new String[]{\"him\", \"me\", \"you\"}, newarr);\n+\n+        newarr = ArrayBuilders.insertInListNoDup(arr, \"foobar\");\n+        Assert.assertArrayEquals(new String[]{\"foobar\", \"me\", \"you\", \"him\"}, newarr);\n+\t}\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n \n public class TestExternalTypeId extends BaseMapTest\n {\n-    public void testTypes() throws IOException {\n-    final ObjectMapper mapper = new ObjectMapper();\n-    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void testTypes() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n \n-    final Point _date = new Point(new Date());\n-    final Point _integer = new Point(12231321);\n-    final Point _boolean = new Point(Boolean.TRUE);\n-    final Point _long = new Point(1234L);\n+        final Point _date = new Point(new Date());\n+        final Point _integer = new Point(12231321);\n+        final Point _boolean = new Point(Boolean.TRUE);\n+        final Point _long = new Point(1234L);\n \n-    final Point _pojo = new Point(new Pojo(1));\n-    final String s_date = mapper.writeValueAsString(_date);\n-    final String s_integer = mapper.writeValueAsString(_integer);\n+        final Point _pojo = new Point(new Pojo(1));\n+        final String s_date = mapper.writeValueAsString(_date);\n+        final String s_integer = mapper.writeValueAsString(_integer);\n \n System.err.println(\"Int -> \"+s_integer);   \n     \n-    final String s_boolean = mapper.writeValueAsString(_boolean);\n-    final String s_long = mapper.writeValueAsString(_long);\n-    final String s_pojo = mapper.writeValueAsString(_pojo);\n+        final String s_boolean = mapper.writeValueAsString(_boolean);\n+        final String s_long = mapper.writeValueAsString(_long);\n+        final String s_pojo = mapper.writeValueAsString(_pojo);\n \n-    final Point d_date = mapper.readValue(s_date, Point.class);\n-    final Point d_long = mapper.readValue(s_long, Point.class);\n-    final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n-    final Point d_integer = mapper.readValue(s_integer, Point.class);\n-    final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+        final Point d_date = mapper.readValue(s_date, Point.class);\n+        final Point d_long = mapper.readValue(s_long, Point.class);\n+        final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+        final Point d_integer = mapper.readValue(s_integer, Point.class);\n+        final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n     }\n \n     @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n         getterVisibility = JsonAutoDetect.Visibility.NONE,\n         setterVisibility = JsonAutoDetect.Visibility.NONE)\n-    private static class Point {\n+    static class Point {\n         @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n         property = \"t\",\n         visible = true,\n         private final Object v;\n     \n         @JsonCreator\n-        @SuppressWarnings(\"unused\")\n         public Point(@JsonProperty(\"v\") Object v) {\n             this.v = v;\n         }\n     }\n      \n \n-    private static class Pojo {\n+    static class Pojo {\n         public final int p;\n \n         @JsonCreator", "timestamp": 1360024042, "metainfo": ""}