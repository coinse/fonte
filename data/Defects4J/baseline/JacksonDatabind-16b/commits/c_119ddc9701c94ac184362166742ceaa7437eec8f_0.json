{"sha": "119ddc9701c94ac184362166742ceaa7437eec8f", "log": "Fix #731", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n     public boolean isMapLikeType() { return false; }\n \n     /**\n+     * Convenience method, short-hand for\n+     *<code>\n+     *   getRawClass() == Object.class\n+     *</code>\n+     * and used to figure if we basically have \"untyped\" type object.\n+     *\n+     * @since 2.5\n+     */\n+    public final boolean isJavaLangObject() { return _class == Object.class; }\n+\n+    /**\n      * Accessor for checking whether handlers for dealing with values of\n      * this type should use static typing (as opposed to dynamic typing).\n      * Note that while value of 'true' does mean that static typing is to\n      * @since 2.2\n      */\n     public final boolean useStaticType() { return _asStatic; }\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, type parameter access; pass-through\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             // [#359]: explicitly check (again) for @JsonSerializer...\n             ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n         }\n-        if (ser == null) {\n+        // [databind#731]: Should skip if nominally java.lang.Object\n+        if (ser == null && !delegateType.isJavaLangObject()) {\n             ser = _createSerializer2(prov, delegateType, beanDesc, true);\n         }\n         return new StdDelegatingSerializer(conv, delegateType, ser);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                 if (convDef != null) {\n                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                    // [databind#731]: Should skip if nominally java.lang.Object\n+                    JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null\n+                            : provider.findValueSerializer(delegateType, prop);\n                     return new StdDelegatingSerializer(conv, delegateType, ser);\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n             if (delegateType == null) {\n                 delegateType = _converter.getOutputType(provider.getTypeFactory());\n             }\n-            delSer = provider.findValueSerializer(delegateType);\n+            /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n+             *    java.lang.Object (or missing generic), [databind#731]\n+             */\n+            if (!delegateType.isJavaLangObject()) {\n+                delSer = provider.findValueSerializer(delegateType);\n+            }\n         }\n         if (delSer instanceof ContextualSerializer) {\n             delSer = provider.handleSecondaryContextualization(delSer, property);\n         }\n-        return (delSer == _delegateSerializer) ? this\n-                : withDelegate(_converter, delegateType, delSer);\n+        if (delSer == _delegateSerializer && delegateType == _delegateType) {\n+            return this;\n+        }\n+        return withDelegate(_converter, delegateType, delSer);\n     }\n \n     /*\n             provider.defaultSerializeNull(gen);\n             return;\n         }\n-        _delegateSerializer.serialize(delegateValue, gen, provider);\n+        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n+        JsonSerializer<Object> ser = _delegateSerializer;\n+        if (ser == null) {\n+            ser = _findSerializer(delegateValue, provider);\n+        }\n+        ser.serialize(delegateValue, gen, provider);\n     }\n \n     @Override\n          *    let's give it a chance?\n          */\n         Object delegateValue = convertValue(value);\n-        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n-    }\n-\n-    @Override\n-    @Deprecated // since 1.5\n+        JsonSerializer<Object> ser = _delegateSerializer;\n+        if (ser == null) {\n+            ser = _findSerializer(value, provider);\n+        }\n+        ser.serializeWithType(delegateValue, gen, provider, typeSer);\n+    }\n+\n+    @Override\n+    @Deprecated // since 2.5\n     public boolean isEmpty(Object value)\n     {\n         Object delegateValue = convertValue(value);\n+        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n+            return (value == null);\n+        }\n         return _delegateSerializer.isEmpty(delegateValue);\n     }\n \n     public boolean isEmpty(SerializerProvider prov, Object value)\n     {\n         Object delegateValue = convertValue(value);\n+        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n+            return (value == null);\n+        }\n         return _delegateSerializer.isEmpty(prov, delegateValue);\n     }\n \n         /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n          *    properly... but for now, try this:\n          */\n-        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n     }\n \n     /*\n     protected Object convertValue(Object value) {\n         return _converter.convert(value);\n     }\n+\n+    /**\n+     * Helper method used for locating serializer to use in dynamic use case, where\n+     * actual type value gets converted to is not specified beyond basic\n+     * {@link java.lang.Object}, and where serializer needs to be located dynamically\n+     * based on actual value type.\n+     *\n+     * @since 2.6\n+     */\n+    protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers)\n+        throws JsonMappingException\n+    {\n+        // NOTE: will NOT call contextualization\n+        return serializers.findValueSerializer(value.getClass());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n          *   when applying contextual content converter; this is not ideal way,\n          *   but should work for most cases.\n          */\n-\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n             AnnotatedMember m = prop.getMember();\n                 if (convDef != null) {\n                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                    if (existingSerializer == null) {\n+                    // [databind#731]: Should skip if nominally java.lang.Object\n+                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {\n                         existingSerializer = provider.findValueSerializer(delegateType);\n                     }\n                     return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java\n             jsonGenerator.writeString(\"Target\");\n         }\n     }\n-    \n+\n+    // [Issue#731]\n+    public static class DummyBean {\n+        public final int a, b;\n+        public DummyBean(int v1, int v2) {\n+            a = v1 * 2;\n+            b = v2 * 2;\n+        }\n+    }\n+\n+    @JsonSerialize(converter = UntypedConvertingBeanConverter.class)\n+    static class ConvertingBeanWithUntypedConverter {\n+        public int x, y;\n+        public ConvertingBeanWithUntypedConverter(int v1, int v2) {\n+            x = v1;\n+            y = v2;\n+        }\n+    }\n+\n+    static class UntypedConvertingBeanConverter extends StdConverter<ConvertingBeanWithUntypedConverter, Object>\n+    {\n+        @Override\n+        public Object convert(ConvertingBeanWithUntypedConverter cb) {\n+            return new DummyBean(cb.x, cb.y);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n         String json = objectWriter().writeValueAsString(new Bean359());\n         assertEquals(\"{\\\"stuff\\\":[\\\"Target\\\"]}\", json);\n     }\n+\n+    // [databind#731]: Problems converting from java.lang.Object (\"unknown\")\n+    public void testIssue731() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new ConvertingBeanWithUntypedConverter(1, 2));\n+        // must be  {\"a\":2,\"b\":4}\n+        assertEquals(\"{\\\"a\\\":2,\\\"b\\\":4}\", json);\n+    }\n }", "timestamp": 1428010346, "metainfo": ""}