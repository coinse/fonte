{"sha": "3a7ceb235418d529e1accf57b703abb18bb46f69", "log": "Fixes #528 - Add support for As.EXISTING_PROPERTY inclusion mechanism", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Type deserializer used with {@link As#EXISTING_PROPERTY}\n+ * inclusion mechanism.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeDeserializer extends AsArrayTypeDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public AsExistingPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n+    {\n+        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n+    }\n+\n+    public AsExistingPropertyTypeDeserializer(AsExistingPropertyTypeDeserializer src, BeanProperty property) {\n+        super(src, property);\n+    }\n+    \n+    @Override\n+    public TypeDeserializer forProperty(BeanProperty prop) {\n+        return (prop == _property) ? this : new AsExistingPropertyTypeDeserializer(this, prop);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+\n+    /**\n+     * This is the trickiest thing to handle, since property we are looking\n+     * for may be anywhere...\n+     */\n+    @Override\n+    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // 02-Aug-2013, tatu: May need to use native type ids\n+        if (jp.canReadTypeId()) {\n+            Object typeId = jp.getTypeId();\n+            if (typeId != null) {\n+                return _deserializeWithNativeTypeId(jp, ctxt, typeId);\n+            }\n+        }\n+        \n+        // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        } else if (t == JsonToken.START_ARRAY) {\n+            /* This is most likely due to the fact that not all Java types are\n+             * serialized as JSON Objects; so if \"as-property\" inclusion is requested,\n+             * serialization of things like Lists must be instead handled as if\n+             * \"as-wrapper-array\" was requested.\n+             * But this can also be due to some custom handling: so, if \"defaultImpl\"\n+             * is defined, it will be asked to handle this case.\n+             */\n+            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);\n+        } else if (t != JsonToken.FIELD_NAME) {\n+            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);\n+        }\n+        // Ok, let's try to find the property. But first, need token buffer...\n+        TokenBuffer tb = null;\n+\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String name = jp.getCurrentName();\n+            jp.nextToken(); // to point to the value\n+            if (_typePropertyName.equals(name)) { // gotcha!\n+                return _deserializeTypedForId(jp, ctxt, tb);\n+            }\n+            if (tb == null) {\n+                tb = new TokenBuffer(null, false);\n+            }\n+            tb.writeFieldName(name);\n+            tb.copyCurrentStructure(jp);\n+        }\n+        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException\n+    {\n+        String typeId = jp.getText();\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n+        if (_typeIdVisible) { // need to merge id back in JSON input?\n+            if (tb == null) {\n+                tb = new TokenBuffer(null, false);\n+            }\n+            tb.writeFieldName(jp.getCurrentName());\n+            tb.writeString(typeId);\n+        }\n+        if (tb != null) { // need to put back skipped properties?\n+            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+        }\n+        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:\n+        jp.nextToken(); // to skip past String value\n+        // deserializer should take care of closing END_OBJECT as well\n+        return deser.deserialize(jp, ctxt);\n+    }\n+    \n+    // off-lined to keep main method lean and mean...\n+    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException\n+    {\n+        // As per [JACKSON-614], may have default implementation to use\n+        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n+        if (deser != null) {\n+            if (tb != null) {\n+                tb.writeEndObject();\n+                jp = tb.asParser(jp);\n+                // must move to point to the first token:\n+                jp.nextToken();\n+            }\n+            return deser.deserialize(jp, ctxt);\n+        }\n+        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n+        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n+        if (result != null) {\n+            return result;\n+        }\n+        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n+        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            return super.deserializeTypedFromAny(jp, ctxt);\n+        }\n+        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n+                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n+    }\n+\n+    /* As per [JACKSON-352], also need to re-route \"unknown\" version. Need to think\n+     * this through bit more in future, but for now this does address issue and has\n+     * no negative side effects (at least within existing unit test suite).\n+     */\n+    @Override\n+    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+        /* [JACKSON-387]: Sometimes, however, we get an array wrapper; specifically\n+         *   when an array or list has been serialized with type information.\n+         */\n+        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            return super.deserializeTypedFromArray(jp, ctxt);\n+        }\n+        return deserializeTypedFromObject(jp, ctxt);\n+    }    \n+    \n+    // These are fine from base class:\n+    //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+    //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * 10/15/2014 - At time of commit, deserialization identical to deserializer\n+ * for {@link As#PROPERTY} inclusion mechanism\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsArrayTypeSerializer\n+{\n+    protected final String _typePropertyName;\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property);\n+        _typePropertyName = propName;\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public String getPropertyName() { return _typePropertyName; }\n+\n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException {\n+        // always need to close, regardless of whether its native type id or not\n+    \tjgen.writeEndObject();\n+    }\n+\n+\n+    /*\n+    /**********************************************************\n+    /* Writing with custom type id\n+    /**********************************************************\n+     */\n+\n+    // Only need to override Object-variants\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {\n+        jgen.writeEndObject();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n     // as per [#368]\n-    private IllegalArgumentException _noExisting() {\n-        return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n-    }\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n \n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             return new AsExternalTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeDeserializer(baseType, idRes,\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\t\n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+    \tAnimal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+    \tassertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubDeserialized.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+    \tAnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+    \tAnimal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+    \tassertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubExtracted.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+    \tassertNotNull(animalListDeserialized);\n+    \tassertTrue(animalListDeserialized.size() == 2);\n+    \tAnimal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+    \tassertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+    \tAnimal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+    \tassertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    \n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+    \tCar camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+    \tassertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryDeserialized.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+    \tCarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+    \tCar camryExtracted = camryWrapperDeserialized.car;\n+    \tassertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryExtracted.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+    \tassertNotNull(carListDeserialized);\n+    \tassertTrue(carListDeserialized.size() == 2);\n+    \tCar camry = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+    \tassertTrue(camry instanceof Camry);\n+        assertSame(camry.getClass(), Camry.class);\n+    \tCar accord = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+    \tassertTrue(accord instanceof Accord);\n+        assertSame(accord.getClass(), Accord.class);\n+    }\n+\n+    \n+}", "timestamp": 1413354610, "metainfo": ""}