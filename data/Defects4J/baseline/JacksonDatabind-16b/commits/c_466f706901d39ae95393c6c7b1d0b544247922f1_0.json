{"sha": "466f706901d39ae95393c6c7b1d0b544247922f1", "log": "Fix #705 for 2.5.2", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.io.NumberOutput;\n import com.fasterxml.jackson.databind.SerializerProvider;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n      * Method (or field) that represents the \"any getter\"\n      */\n     protected final AnnotatedMember _accessor;\n+\n+    protected JsonSerializer<Object> _serializer;\n+\n+    protected MapSerializer _mapSerializer;\n     \n-    protected MapSerializer _serializer;\n-    \n+    @SuppressWarnings(\"unchecked\")\n     public AnyGetterWriter(BeanProperty property,\n-            AnnotatedMember accessor, MapSerializer serializer)\n+            AnnotatedMember accessor, JsonSerializer<?> serializer)\n     {\n         _accessor = accessor;\n         _property = property;\n-        _serializer = serializer;\n+        _serializer = (JsonSerializer<Object>) serializer;\n+        if (serializer instanceof MapSerializer) {\n+            _mapSerializer = (MapSerializer) serializer;\n+        }\n     }\n \n-    public void getAndSerialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n         throws Exception\n     {\n         Object value = _accessor.getValue(bean);\n             throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                     +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n         }\n-        _serializer.serializeFields((Map<?,?>) value, jgen, provider);\n+        // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n+        if (_mapSerializer != null) {\n+            _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n+            return;\n+        }\n+        _serializer.serialize(value, gen, provider);\n     }\n \n     /**\n      * @since 2.3\n      */\n-    public void getAndFilter(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n             PropertyFilter filter)\n-        throws Exception\n-        {\n-            Object value = _accessor.getValue(bean);\n-            if (value == null) {\n-                return;\n-            }\n-            if (!(value instanceof Map<?,?>)) {\n-                throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n-                        +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n-            }\n-            // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n-            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter, null);\n+                    throws Exception\n+    {\n+        Object value = _accessor.getValue(bean);\n+        if (value == null) {\n+            return;\n         }\n+        if (!(value instanceof Map<?,?>)) {\n+            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n+                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n+        }\n+        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n+        if (_mapSerializer != null) {\n+            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);\n+            return;\n+        }\n+        // ... not sure how custom handler would do it\n+        _serializer.serialize(value, gen, provider);\n+    }\n     \n     // Note: NOT part of ResolvableSerializer...\n+    @SuppressWarnings(\"unchecked\")\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n         // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-        _serializer = (MapSerializer) provider.handlePrimaryContextualization(_serializer, _property);\n+        if (_serializer instanceof ContextualSerializer) {\n+            JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property);\n+            _serializer = (JsonSerializer<Object>) ser;\n+            if (ser instanceof MapSerializer) {\n+                _mapSerializer = (MapSerializer) ser;\n+            }\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             JavaType valueType = type.getContentType();\n             TypeSerializer typeSer = createTypeSerializer(config, valueType);\n             // last 2 nulls; don't know key, value serializers (yet)\n-            // TODO: support '@JsonIgnoreProperties' with any setter?\n-            MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n-                    typeSer, null, null, /*filterId*/ null);\n+            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n+            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n+            if (anySer == null) {\n+                // TODO: support '@JsonIgnoreProperties' with any setter?\n+                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n+                        typeSer, null, null, /*filterId*/ null);\n+            }\n             // TODO: can we find full PropertyName?\n             PropertyName name = new PropertyName(anyGetter.getName());\n             BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                     beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer));\n+            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n         }\n         // Next: need to gather view information, if any:\n         processViews(config, builder);\n-        \n+\n         // Finally: let interested parties mess with the result bit more...\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java.orig\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n+import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\n+import com.fasterxml.jackson.databind.ser.std.MapSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n+\n+/**\n+ * Factory class that can provide serializers for any regular Java beans\n+ * (as defined by \"having at least one get method recognizable as bean\n+ * accessor\" -- where {@link Object#getClass} does not count);\n+ * as well as for \"standard\" JDK types. Latter is achieved\n+ * by delegating calls to {@link BasicSerializerFactory} \n+ * to find serializers both for \"standard\" JDK types (and in some cases,\n+ * sub-classes as is the case for collection classes like\n+ * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n+ * classes.\n+ *<p>\n+ * Note about delegating calls to {@link BasicSerializerFactory}:\n+ * although it would be nicer to use linear delegation\n+ * for construction (to essentially dispatch all calls first to the\n+ * underlying {@link BasicSerializerFactory}; or alternatively after\n+ * failing to provide bean-based serializer}, there is a problem:\n+ * priority levels for detecting standard types are mixed. That is,\n+ * we want to check if a type is a bean after some of \"standard\" JDK\n+ * types, but before the rest.\n+ * As a result, \"mixed\" delegation used, and calls are NOT done using\n+ * regular {@link SerializerFactory} interface but rather via\n+ * direct calls to {@link BasicSerializerFactory}.\n+ *<p>\n+ * Finally, since all caching is handled by the serializer provider\n+ * (not factory) and there is no configurability, this\n+ * factory is stateless.\n+ * This means that a global singleton instance can be used.\n+ */\n+public class BeanSerializerFactory\n+    extends BasicSerializerFactory\n+    implements java.io.Serializable // since 2.1\n+{\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n+     * thus a single shared global (== singleton) instance can be used\n+     * without thread-safety issues.\n+     */\n+    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: creation, configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor for creating instances with specified configuration.\n+     */\n+    protected BeanSerializerFactory(SerializerFactoryConfig config)\n+    {\n+        super(config);\n+    }\n+    \n+    /**\n+     * Method used by module registration functionality, to attach additional\n+     * serializer providers into this serializer factory. This is typically\n+     * handled by constructing a new instance with additional serializers,\n+     * to ensure thread-safe access.\n+     */\n+    @Override\n+    public SerializerFactory withConfig(SerializerFactoryConfig config)\n+    {\n+        if (_factoryConfig == config) {\n+            return this;\n+        }\n+        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n+         *    and we pretty much have to here either choose between losing subtype instance\n+         *    when registering additional serializers, or losing serializers.\n+         *    Instead, let's actually just throw an error if this method is called when subtype\n+         *    has not properly overridden this method; this to indicate problem as soon as possible.\n+         */\n+        if (getClass() != BeanSerializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n+                    +\"additional serializer definitions\");\n+        }\n+        return new BeanSerializerFactory(config);\n+    }\n+\n+    @Override\n+    protected Iterable<Serializers> customSerializers() {\n+        return _factoryConfig.serializers();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* SerializerFactory impl\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serializer constructor method. We will have to be careful\n+     * with respect to ordering of various method calls: essentially\n+     * we want to reliably figure out which classes are standard types,\n+     * and which are beans. The problem is that some bean Classes may\n+     * implement standard interfaces (say, {@link java.lang.Iterable}.\n+     *<p>\n+     * Note: sub-classes may choose to complete replace implementation,\n+     * if they want to alter priority of serializer lookups.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n+            JavaType origType)\n+        throws JsonMappingException\n+    {\n+        // Very first thing, let's check if there is explicit serializer annotation:\n+        final SerializationConfig config = prov.getConfig();\n+        BeanDescription beanDesc = config.introspect(origType);\n+        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser != null) {\n+            return (JsonSerializer<Object>) ser;\n+        }\n+        boolean staticTyping;\n+        // Next: we may have annotations that further define types to use...\n+        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+        if (type == origType) { // no changes, won't force static typing\n+            staticTyping = false;\n+        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n+            staticTyping = true;\n+            if (!type.hasRawClass(origType.getRawClass())) {\n+                beanDesc = config.introspect(type);\n+            }\n+        }\n+        // Slight detour: do we have a Converter to consider?\n+        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n+        if (conv == null) { // no, simple\n+            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+        }\n+        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+        \n+        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+        if (!delegateType.hasRawClass(type.getRawClass())) {\n+            beanDesc = config.introspect(delegateType);\n+            // [#359]: explicitly check (again) for @JsonSerializer...\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+\n+    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n+        throws JsonMappingException\n+    {\n+        // Then JsonSerializable, @JsonValue etc:\n+        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        final SerializationConfig config = prov.getConfig();\n+        \n+        // Container types differ from non-container types\n+        // (note: called method checks for module-provided serializers)\n+        if (type.isContainerType()) {\n+            if (!staticTyping) {\n+                staticTyping = usesStaticTyping(config, beanDesc, null);\n+                // [Issue#23]: Need to figure out how to force passed parameterization\n+                //  to stick...\n+                /*\n+                if (property == null) {\n+                    JavaType t = origType.getContentType();\n+                    if (t != null && !t.hasRawClass(Object.class)) {\n+                        staticTyping = true;\n+                    }\n+                }\n+                */\n+            }\n+            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n+            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n+            // Will return right away, since called method does post-processing:\n+            if (ser != null) {\n+                return ser;\n+            }\n+        } else {\n+            // Modules may provide serializers of POJO types:\n+            for (Serializers serializers : customSerializers()) {\n+                ser = serializers.findSerializer(config, type, beanDesc);\n+                if (ser != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // Otherwise, we will check \"primary types\"; both marker types that\n+        // indicate specific handling (JsonSerializable), or main types that have\n+        // precedence over container types\n+        if (ser == null) {\n+            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n+            if (ser == null) {\n+                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n+                if (ser == null) {\n+                    // And this is where this class comes in: if type is not a\n+                    // known \"primary JDK type\", perhaps it's a bean? We can still\n+                    // get a null, if we can't find a single suitable bean property.\n+                    ser = findBeanSerializer(prov, type, beanDesc);\n+                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n+                    if (ser == null) {\n+                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n+                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n+                        //   post-processed\n+                        if (ser == null) {\n+                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (ser != null) {\n+            // [Issue#120]: Allow post-processing\n+            if (_factoryConfig.hasSerializerModifiers()) {\n+                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                    ser = mod.modifySerializer(config, beanDesc, ser);\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other public methods that are not part of\n+    /* JsonSerializerFactory API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will try to construct a {@link BeanSerializer} for\n+     * given class. Returns null if no properties are found.\n+     */\n+    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        // First things first: we know some types are not beans...\n+        if (!isPotentialBeanType(type.getRawClass())) {\n+            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n+            //   as per [Issue#24]\n+            if (!type.isEnumType()) {\n+                return null;\n+            }\n+        }\n+        return constructBeanSerializer(prov, beanDesc);\n+    }\n+\n+    /**\n+     * Method called to create a type information serializer for values of given\n+     * non-container property\n+     * if one is needed. If not needed (no polymorphic handling configured), should\n+     * return null.\n+     *\n+     * @param baseType Declared type to use as the base type for type information serializer\n+     * \n+     * @return Type serializer to use for property values, if one is needed; null if not.\n+     */\n+    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n+            SerializationConfig config, AnnotatedMember accessor)\n+        throws JsonMappingException\n+    {\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n+        // Defaulting: if no annotations on member, check value class\n+        if (b == null) {\n+            return createTypeSerializer(config, baseType);\n+        }\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n+                accessor, config, ai, baseType);\n+        return b.buildTypeSerializer(config, baseType, subtypes);\n+    }\n+\n+    /**\n+     * Method called to create a type information serializer for values of given\n+     * container property\n+     * if one is needed. If not needed (no polymorphic handling configured), should\n+     * return null.\n+     *\n+     * @param containerType Declared type of the container to use as the base type for type information serializer\n+     * \n+     * @return Type serializer to use for property value contents, if one is needed; null if not.\n+     */    \n+    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n+            SerializationConfig config, AnnotatedMember accessor)\n+        throws JsonMappingException\n+    {\n+        JavaType contentType = containerType.getContentType();\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n+        // Defaulting: if no annotations on member, check value class\n+        if (b == null) {\n+            return createTypeSerializer(config, contentType);\n+        }\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n+                config, ai, contentType);\n+        return b.buildTypeSerializer(config, contentType, subtypes);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable non-public factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to construct serializer for serializing specified bean type.\n+     * \n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n+            BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n+        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n+        if (beanDesc.getBeanClass() == Object.class) {\n+            return prov.getUnknownTypeSerializer(Object.class);\n+//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+        }\n+        final SerializationConfig config = prov.getConfig();\n+        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n+        builder.setConfig(config);\n+\n+        // First: any detectable (auto-detect, annotations) properties to serialize?\n+        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n+        if (props == null) {\n+            props = new ArrayList<BeanPropertyWriter>();\n+        }\n+        // [databind#638]: Allow injection of \"virtual\" properties:\n+        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n+\n+        // [JACKSON-440] Need to allow modification bean properties to serialize:\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                props = mod.changeProperties(config, beanDesc, props);\n+            }\n+        }\n+\n+        // Any properties to suppress?\n+        props = filterBeanProperties(config, beanDesc, props);\n+\n+        // [JACKSON-440] Need to allow reordering of properties to serialize\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                props = mod.orderProperties(config, beanDesc, props);\n+            }\n+        }\n+\n+        /* And if Object Id is needed, some preparation for that as well: better\n+         * do before view handling, mostly for the custom id case which needs\n+         * access to a property\n+         */\n+        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n+        \n+        builder.setProperties(props);\n+        builder.setFilterId(findFilterId(config, beanDesc));\n+        \n+        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n+        if (anyGetter != null) {\n+            if (config.canOverrideAccessModifiers()) {\n+                anyGetter.fixAccess();\n+            }\n+            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n+            // copied from BasicSerializerFactory.buildMapSerializer():\n+            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n+            JavaType valueType = type.getContentType();\n+            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n+            // last 2 nulls; don't know key, value serializers (yet)\n+            // TODO: support '@JsonIgnoreProperties' with any setter?\n+            MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n+                    typeSer, null, null, /*filterId*/ null);\n+            // TODO: can we find full PropertyName?\n+            PropertyName name = new PropertyName(anyGetter.getName());\n+            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n+                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n+            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer));\n+        }\n+        // Next: need to gather view information, if any:\n+        processViews(config, builder);\n+        \n+        // Finally: let interested parties mess with the result bit more...\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                builder = mod.updateBuilder(config, beanDesc, builder);\n+            }\n+        }\n+        \n+        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n+        \n+        if (ser == null) {\n+            // If we get this far, there were no properties found, so no regular BeanSerializer\n+            // would be constructed. But, couple of exceptions.\n+            // First: if there are known annotations, just create 'empty bean' serializer\n+            if (beanDesc.hasKnownClassAnnotations()) {\n+                return builder.createDummy();\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n+            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n+        throws JsonMappingException\n+    {\n+        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n+        if (objectIdInfo == null) {\n+            return null;\n+        }\n+        ObjectIdGenerator<?> gen;\n+        Class<?> implClass = objectIdInfo.getGeneratorType();\n+\n+        // Just one special case: Property-based generator is trickier\n+        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n+            String propName = objectIdInfo.getPropertyName().getSimpleName();\n+            BeanPropertyWriter idProp = null;\n+\n+            for (int i = 0, len = props.size() ;; ++i) {\n+                if (i == len) {\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n+                            +\": can not find property with name '\"+propName+\"'\");\n+                }\n+                BeanPropertyWriter prop = props.get(i);\n+                if (propName.equals(prop.getName())) {\n+                    idProp = prop;\n+                    /* Let's force it to be the first property to output\n+                     * (although it may still get rearranged etc)\n+                     */\n+                    if (i > 0) {\n+                        props.remove(i);\n+                        props.add(0, idProp);\n+                    }\n+                    break;\n+                }\n+            }\n+            JavaType idType = idProp.getType();\n+            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n+            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            \n+        } \n+        // other types are simpler\n+        JavaType type = prov.constructType(implClass);\n+        // Could require type to be passed explicitly, but we should be able to find it too:\n+        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n+        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n+                objectIdInfo.getAlwaysAsId());\n+    }\n+\n+    /**\n+     * Method called to construct a filtered writer, for given view\n+     * definitions. Default implementation constructs filter that checks\n+     * active view type to views property is to be included in.\n+     */\n+    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n+            Class<?>[] inViews)\n+    {\n+        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n+    }\n+    \n+    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n+            BeanDescription beanDesc)\n+    {\n+        return new PropertyBuilder(config, beanDesc);\n+    }\n+\n+    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n+        return new BeanSerializerBuilder(beanDesc);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable non-public introspection methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used to skip processing for types that we know\n+     * can not be (i.e. are never consider to be) beans: \n+     * things like primitives, Arrays, Enums, and proxy types.\n+     *<p>\n+     * Note that usually we shouldn't really be getting these sort of\n+     * types anyway; but better safe than sorry.\n+     */\n+    protected boolean isPotentialBeanType(Class<?> type)\n+    {\n+        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n+    }\n+\n+    /**\n+     * Method used to collect all actual serializable properties.\n+     * Can be overridden to implement custom detection schemes.\n+     */\n+    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n+            BeanDescription beanDesc, BeanSerializerBuilder builder)\n+        throws JsonMappingException\n+    {\n+        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n+        final SerializationConfig config = prov.getConfig();\n+\n+        // [JACKSON-429]: ignore specified types\n+        removeIgnorableTypes(config, beanDesc, properties);\n+        \n+        // and possibly remove ones without matching mutator...\n+        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n+            removeSetterlessGetters(config, beanDesc, properties);\n+        }\n+        \n+        // nothing? can't proceed (caller may or may not throw an exception)\n+        if (properties.isEmpty()) {\n+            return null;\n+        }\n+        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n+        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n+        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n+        \n+        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n+        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n+        for (BeanPropertyDefinition property : properties) {\n+            final AnnotatedMember accessor = property.getAccessor();\n+            // [JACKSON-762]: type id? Requires special handling:\n+            if (property.isTypeId()) {\n+                if (accessor != null) { // only add if we can access... but otherwise?\n+                    if (config.canOverrideAccessModifiers()) {\n+                        accessor.fixAccess();\n+                    }\n+                    builder.setTypeId(accessor);\n+                }\n+                continue;\n+            }\n+            // [JACKSON-235]: suppress writing of back references\n+            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n+            if (refType != null && refType.isBackReference()) {\n+                continue;\n+            }\n+            if (accessor instanceof AnnotatedMethod) {\n+                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n+            } else {\n+                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable non-public methods for manipulating bean properties\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Overridable method that can filter out properties. Default implementation\n+     * checks annotations class may have.\n+     */\n+    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n+            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        String[] ignored = intr.findPropertiesToIgnore(ac);\n+        if (ignored != null && ignored.length > 0) {\n+            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n+            Iterator<BeanPropertyWriter> it = props.iterator();\n+            while (it.hasNext()) {\n+                if (ignoredSet.contains(it.next().getName())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return props;\n+    }\n+\n+    /**\n+     * Method called to handle view information for constructed serializer,\n+     * based on bean property writers.\n+     *<p>\n+     * Note that this method is designed to be overridden by sub-classes\n+     * if they want to provide custom view handling. As such it is not\n+     * considered an internal implementation detail, and will be supported\n+     * as part of API going forward.\n+     */\n+    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n+    {\n+        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n+        List<BeanPropertyWriter> props = builder.getProperties();\n+        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n+        final int propCount = props.size();\n+        int viewsFound = 0;\n+        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n+        // Simple: view information is stored within individual writers, need to combine:\n+        for (int i = 0; i < propCount; ++i) {\n+            BeanPropertyWriter bpw = props.get(i);\n+            Class<?>[] views = bpw.getViews();\n+            if (views == null) { // no view info? include or exclude by default?\n+                if (includeByDefault) {\n+                    filtered[i] = bpw;\n+                }\n+            } else {\n+                ++viewsFound;\n+                filtered[i] = constructFilteredBeanWriter(bpw, views);\n+            }\n+        }\n+        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n+        if (includeByDefault && viewsFound == 0) {\n+            return;\n+        }\n+        builder.setFilteredProperties(filtered);\n+    }\n+\n+    /**\n+     * Method that will apply by-type limitations (as per [JACKSON-429]);\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n+     * annotation but can be supplied by module-provided introspectors too.\n+     */\n+    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n+            List<BeanPropertyDefinition> properties)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n+        Iterator<BeanPropertyDefinition> it = properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition property = it.next();\n+            AnnotatedMember accessor = property.getAccessor();\n+            if (accessor == null) {\n+                it.remove();\n+                continue;\n+            }\n+            Class<?> type = accessor.getRawType();\n+            Boolean result = ignores.get(type);\n+            if (result == null) {\n+                BeanDescription desc = config.introspectClassAnnotations(type);\n+                AnnotatedClass ac = desc.getClassInfo();\n+                result = intr.isIgnorableType(ac);\n+                // default to false, non-ignorable\n+                if (result == null) {\n+                    result = Boolean.FALSE;\n+                }\n+                ignores.put(type, result);\n+            }\n+            // lotsa work, and yes, it is ignorable type, so:\n+            if (result.booleanValue()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method that will remove all properties that do not have a mutator.\n+     */\n+    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n+            List<BeanPropertyDefinition> properties)\n+    {\n+        Iterator<BeanPropertyDefinition> it = properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition property = it.next();\n+            // one caveat: as per [JACKSON-806], only remove implicit properties;\n+            // explicitly annotated ones should remain\n+            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n+     * given member (field or method).\n+     */\n+    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n+            BeanPropertyDefinition propDef, TypeBindings typeContext,\n+            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n+        throws JsonMappingException\n+    {\n+        final PropertyName name = propDef.getFullName();\n+        if (prov.canOverrideAccessModifiers()) {\n+            accessor.fixAccess();\n+        }\n+        JavaType type = accessor.getType(typeContext);\n+        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n+                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n+\n+        // Does member specify a serializer? If so, let's use it.\n+        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n+                accessor);\n+        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n+         *  here will NOT be resolved or contextualized, unless done here, so:\n+         */\n+        if (annotatedSerializer instanceof ResolvableSerializer) {\n+            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n+        }\n+        // 05-Sep-2013, tatu: should be primary property serializer so:\n+        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n+        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n+        TypeSerializer contentTypeSer = null;\n+        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n+        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n+            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n+        }\n+        // and if not JAXB collection/array with annotations, maybe regular type info?\n+        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n+        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n+                        typeSer, contentTypeSer, accessor, staticTyping);\n+        return pbw;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java.rej\n+***************\n+*** 391,404 ****\n+              JavaType valueType = type.getContentType();\n+              TypeSerializer typeSer = createTypeSerializer(config, valueType);\n+              // last 2 nulls; don't know key, value serializers (yet)\n+-             // TODO: support '@JsonIgnoreProperties' with any setter?\n+-             MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n+-                     typeSer, null, null, /*filterId*/ null);\n+              // TODO: can we find full PropertyName?\n+              PropertyName name = PropertyName.construct(anyGetter.getName());\n+              BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n+                      beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n+-             builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer));\n+          }\n+          // Next: need to gather view information, if any:\n+          processViews(config, builder);\n+--- 391,409 ----\n+              JavaType valueType = type.getContentType();\n+              TypeSerializer typeSer = createTypeSerializer(config, valueType);\n+              // last 2 nulls; don't know key, value serializers (yet)\n++ \n++             // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n++             JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n++             if (anySer == null) {\n++                 // TODO: support '@JsonIgnoreProperties' with any setter?\n++                 anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n++                         typeSer, null, null, /*filterId*/ null);\n++             }\n+              // TODO: can we find full PropertyName?\n+              PropertyName name = PropertyName.construct(anyGetter.getName());\n+              BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n+                      beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n++             builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n+          }\n+          // Next: need to gather view information, if any:\n+          processViews(config, builder);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n \n         // also, any-getter may need to be resolved\n         if (_anyGetterWriter != null) {\n+            // 23-Feb-2015, tatu: Misleading, as this actually triggers call to contextualization...\n             _anyGetterWriter.resolve(provider);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.io.IOException;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n public class TestAnyGetter extends BaseMapTest\n {\n             stuff.put(key, value);\n         }\n     }\n-    \n+\n+    static class Issue705Bean\n+    {\n+        protected Map<String,String> stuff;\n+\n+        public Issue705Bean(String key, String value) {\n+            stuff = new LinkedHashMap<String,String>();\n+            stuff.put(key, value);\n+        }\n+        \n+        @JsonSerialize(using = Issue705Serializer.class)\n+//    @JsonSerialize(converter = MyConverter.class)\n+        @JsonAnyGetter\n+        public Map<String, String> getParameters(){\n+            return stuff;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class Issue705Serializer extends StdSerializer<Object>\n+    {\n+        public Issue705Serializer() {\n+            super(Map.class, false);\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            for (Map.Entry<?,?> entry : ((Map<?,?>) value).entrySet()) {\n+                sb.append('[').append(entry.getKey()).append('/').append(entry.getValue()).append(']');\n+            }\n+            jgen.writeStringField(\"stuff\", sb.toString());\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test cases\n         assertEquals(aposToQuotes(\"{'bar':null}\"),\n                 MAPPER.writeValueAsString(input));\n     }\n+\n+    public void testIssue705() throws Exception\n+    {\n+        Issue705Bean input = new Issue705Bean(\"key\", \"value\");        \n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(\"{\\\"stuff\\\":\\\"[key/value]\\\"}\", json);\n+    }\n }", "timestamp": 1424739236, "metainfo": ""}