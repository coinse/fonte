{"sha": "c717c2ff7ef92ef1c5a4e6970408efec1074b546", "log": "Fix #556 (minor regression during 2.5.0-SNAPSHOT, not included in any of released versions)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n         vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n \n+        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n+         *  (which has creator parameters sprinkled around) with actual creator\n+         *  declarations (which are needed to access creator annotation, amongst other things).\n+         *  Easiest to combine that info first, then pass it to remaining processing.\n+         */\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n+                beanDesc);\n+        \n         /* Important: first add factory methods; then constructors, so\n          * latter can override former!\n          */\n-        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         // constructors only usable on concrete types:\n         if (beanDesc.getType().isConcrete()) {\n-            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n+            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         }\n         return creators.constructValueInstantiator(config);\n     }\n \n+    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n+            BeanDescription beanDesc) throws JsonMappingException\n+    {\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n+        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n+            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n+            while (it.hasNext()) {\n+                AnnotatedParameter param = it.next();\n+                AnnotatedWithParams owner = param.getOwner();\n+                BeanPropertyDefinition[] defs = result.get(owner);\n+                final int index = param.getIndex();\n+                \n+                if (defs == null) {\n+                    if (result.isEmpty()) {\n+                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n+                    }\n+                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n+                    result.put(owner, defs);\n+                } else {\n+                    if (defs[index] != null) {\n+                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n+                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n+                    }\n+                }\n+                defs[index] = propDef;\n+            }\n+        }\n+        return result;\n+    }\n+    \n     public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n             Annotated annotated, Object instDef)\n         throws JsonMappingException\n                 config.canOverrideAccessModifiers());\n     }\n \n+    @Deprecated // since 2.5.0, removed from 2.6.0\n+    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n+    }\n+    \n     protected void _addDeserializerConstructors\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n         throws JsonMappingException\n     {\n         // First things first: the \"default constructor\" (zero-arg\n                 creators.setDefaultCreator(defaultCtor);\n             }\n         }\n-\n-        // And then other constructors\n         for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n-            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n-            int argCount = ctor.getParameterCount();\n+            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n+            final int argCount = ctor.getParameterCount();\n+\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                AnnotatedParameter param = ctor.getParameter(0);\n-                // NOTE: only consider EXPLICIT names for auto-detection\n-                PropertyName pn = _findExplicitParamName(param, intr);\n-                Object injectId = intr.findInjectableValueId(param);\n-\n-                if ((injectId == null) && (pn == null || pn.isEmpty())) { // not property based\n-                    _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n+                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n+                Object injectId = intr.findInjectableValueId(ctor.getParameter(0));\n+\n+                if (hasExplicitName || (injectId != null)) {\n+                    CreatorProperty[] properties = new CreatorProperty[1];\n+                    PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, ctor.getParameter(0), injectId);\n+                    creators.addPropertyCreator(ctor, properties);\n+                } else {\n+                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                             ctor, isCreator,\n-                            vchecker.isCreatorVisible(ctor), pn);\n-                    // otherwise just ignored\n-                    continue;\n-                }\n-                // fall through if there's name\n-            }\n-            \n-            // 1 or more args; all params must have name annotations\n+                            vchecker.isCreatorVisible(ctor));\n+                }\n+                // regardless, fully handled\n+                continue;\n+            }\n+\n+            // 2 or more args; all params must have names or be injectable\n             AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n             int explicitNameCount = 0;\n             int implicitNameCount = 0;\n             int injectCount = 0;            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                PropertyName name = _findExplicitParamName(param, intr);\n+                final AnnotatedParameter param = ctor.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n                     ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                     continue;\n                 }\n                 // One more thing: implicit names are ok iff ctor has creator annotation\n                 if (isCreator) {\n-                    name = _findImplicitParamName(param, intr);\n                     if (name != null && !name.isEmpty()) {\n                         ++implicitNameCount;\n                         properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                 if (nonAnnotatedParam == null) {\n                     nonAnnotatedParam = param;\n                 }\n-                // 23-Sep-2014, tatu: TODO: probably will need support for using implicit\n-                //   names, still, \n             }\n \n             final int namedCount = explicitNameCount + implicitNameCount;\n         }\n     }\n \n-    /* 23-Sep-2014, tatu: This is the old definition of method above, from 2.4.x,\n-     *   rewritten in 2.5. Left here until 2.6, just in case there's a regression,\n-     *   and we need to inspect diffs...\n-     */\n-/*    \n-    protected void XXX_addDeserializerConstructors\n-        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n-        throws JsonMappingException\n-    {\n-        // First things first: the \"default constructor\" (zero-arg\n-        // constructor; whether implicit or explicit) is NOT included\n-        // in list of constructors, so needs to be handled separately.\n-        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n-        if (defaultCtor != null) {\n-            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n-                creators.setDefaultCreator(defaultCtor);\n-            }\n-        }\n-\n-        PropertyName[] ctorPropNames = null;\n-        AnnotatedConstructor propertyCtor = null;\n-        \n-        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n-            if (propDef.getConstructorParameter() != null) {\n-                AnnotatedParameter param = propDef.getConstructorParameter();\n-                AnnotatedWithParams owner = param.getOwner();\n-                if (owner instanceof AnnotatedConstructor) {\n-                    if (propertyCtor == null) {\n-                        propertyCtor = (AnnotatedConstructor) owner;\n-                        ctorPropNames = new PropertyName[propertyCtor.getParameterCount()];\n-                    } else if (owner != propertyCtor) {\n-                        // there is a mismatch of some kind here (problem?)\n-                        continue;\n-                    }\n-                    ctorPropNames[param.getIndex()] = propDef.getFullName();\n-                }\n-            }\n-        }\n-\n-        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n-\n-            int argCount = ctor.getParameterCount();\n-            boolean isCreator = intr.hasCreatorAnnotation(ctor) || (ctor == propertyCtor);\n-//            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n-            \n-            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n-            \n-            // some single-arg constructors (String, number) are auto-detected\n-            if (argCount == 1) {\n-                PropertyName name = (ctor == propertyCtor) ? ctorPropNames[0] : null;\n-                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n-                        ctor, isCreator, isVisible, name);\n-                continue;\n-            }\n-            if (!isCreator && !isVisible) {\n-                continue;\n-            }\n-\n-            // [JACKSON-541] improved handling a bit so:\n-            // 2 or more args; all params must have name annotations\n-            // ... or @JacksonInject (or equivalent)\n-            // [JACKSON-711] One more possibility; can have 1 or more injectables, and\n-            // exactly one non-annotated parameter: if so, it's still delegating.\n-            AnnotatedParameter nonAnnotatedParam = null;\n-            int namedCount = 0;\n-            int injectCount = 0;\n-            CreatorProperty[] properties = new CreatorProperty[argCount];\n-            for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                PropertyName name = null;\n-                if (ctor == propertyCtor) {\n-                    name = ctorPropNames[i];\n-                }\n-                if (name == null) {\n-                    name = _findParamName(param, intr);\n-                }\n-                Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) { // injectable\n-                    ++injectCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) { // [Issue#265]: allow unwrapped properties\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc,\n-                                UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n-                    }\n-                }\n-            }\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n-                // simple case; everything covered:\n-                if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(ctor, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n-                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(ctor, properties);\n-                } else { // otherwise, record the incomplete parameter for later error messaging.\n-                    creators.addIncompeteParameter(nonAnnotatedParam);\n-                }\n-            }\n-        }\n-    }\n-*/\n-\n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible,\n-            PropertyName name)\n-        throws JsonMappingException\n-    {\n-        // note: if we do have EXPLICIT parameter name, it'll be \"property constructor\":\n-        AnnotatedParameter param = ctor.getParameter(0);\n-        if (name == null) {\n-            name = _findExplicitParamName(param, intr);\n-        }\n-        Object injectId = intr.findInjectableValueId(param);\n-    \n-        if ((injectId != null) || (name != null && name.hasSimpleName())) { // property-based\n-            // We know there's EXPLICIT name and it's only 1 parameter.\n-            CreatorProperty[] properties = new CreatorProperty[1];\n-            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n-            creators.addPropertyCreator(ctor, properties);\n-            return true;\n-        }\n-    \n+            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n+        throws JsonMappingException\n+    {\n         // otherwise either 'simple' number, String, or general delegate:\n         Class<?> type = ctor.getRawParameterType(0);\n         if (type == String.class) {\n         return false;\n     }\n \n+    @Deprecated // since 2.5, remove from 2.6\n+    protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n+    }\n+\n     protected void _addDeserializerFactoryMethods\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n-            boolean isCreator = intr.hasCreatorAnnotation(factory);\n-            int argCount = factory.getParameterCount();\n+            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n+            final int argCount = factory.getParameterCount();\n             // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n             if (argCount == 0) {\n                 if (isCreator) {\n                 }\n                 continue;\n             }\n-            \n+\n+            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                AnnotatedParameter param = factory.getParameter(0);\n-                // NOTE: only consider EXPLICIT names for auto-detection\n-                PropertyName pn = _findExplicitParamName(param, intr);\n-                String name = (pn == null) ? null : pn.getSimpleName();\n-                Object injectId = intr.findInjectableValueId(param);\n-\n-                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n-                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n+                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n+                final Object injectId = intr.findInjectableValueId(factory.getParameter(0));\n+                if ((injectId == null) && !hasExplicitName) { // not property based\n+                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                             factory, isCreator);\n                     // otherwise just ignored\n                     continue;\n                 }\n                 // fall through if there's name\n             } else {\n-                // more than 2 args, must be @JsonCreator\n-                if (!intr.hasCreatorAnnotation(factory)) {\n+                // more than 2 args, must have @JsonCreator\n+                if (!isCreator) {\n                     continue;\n                 }\n             }\n             // 1 or more args; all params must have name annotations\n             AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n-            int namedCount = 0;\n-            int injectCount = 0;            \n+            int implicitNameCount = 0;\n+            int explicitNameCount = 0;\n+            int injectCount = 0;\n+            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = factory.getParameter(i);\n-                PropertyName name = _findParamName(param, intr);\n+                final AnnotatedParameter param = factory.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n+                    ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) {\n+                    continue;\n+                }\n+                if (injectId != null) {\n                     ++injectCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) {\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++implicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n                     }\n                 }\n-            }\n-\n+                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n+                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n+                 *  let's add one more work around\n+                 */\n+                /*\n+                PropertyName name2 = _findExplicitParamName(param, intr);\n+                if (name2 != null && !name2.isEmpty()) {\n+                    // Hmmh. Ok, fine. So what are we to do with it... ?\n+                    // For now... skip. May need to revisit this, should this become problematic\n+                    continue main_loop;\n+                }\n+                */\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+            final int namedCount = explicitNameCount + implicitNameCount;\n+            \n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n                     creators.addPropertyCreator(factory, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n                     creators.addDelegatingCreator(factory, properties);\n                 } else { // otherwise, epic fail\n             }\n             return true;\n         }\n-        if (intr.hasCreatorAnnotation(factory)) {\n+        if (isCreator) {\n             creators.addDelegatingCreator(factory, null);\n             return true;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.PropertyMetadata;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n import com.fasterxml.jackson.databind.util.Named;\n \n /**\n     public abstract AnnotatedParameter getConstructorParameter();\n \n     /**\n+     * Additional method that may be called instead of {@link #getConstructorParameter()}\n+     * to get access to all constructor parameters, not just the highest priority one.\n+     * \n+     * @since 2.5\n+     */\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        return EmptyIterator.instance();\n+    }\n+    \n+    /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n      * Null if no such member exists.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n /**\n  * Helper class used for aggregating information about a single\n             curr = curr.next;\n         } while (curr != null);\n         return _ctorParameters.value;\n+    }\n+\n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        if (_ctorParameters == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return new MemberIterator<AnnotatedParameter>(_ctorParameters);\n     }\n     \n     @Override\n     private interface WithMember<T> {\n         public T withMember(AnnotatedMember member);\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected static class MemberIterator<T extends AnnotatedMember>\n+        implements Iterator<T>\n+    {\n+        private Linked<T> next;\n+        \n+        public MemberIterator(Linked<T> first) {\n+            next = first;\n+        }\n+        \n+        @Override\n+        public boolean hasNext() {\n+            return (next != null);\n+        }\n+\n+        @Override\n+        public T next() {\n+            if (next == null) throw new NoSuchElementException();\n+            T result = next.value;\n+            next = next.next;\n+            return result;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+    }\n     \n     /**\n      * Node used for creating simple linked lists to efficiently store small sets\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.util;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n         return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null;\n     }\n \n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        AnnotatedParameter param = getConstructorParameter();\n+        if (param == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return Collections.singleton(param).iterator();\n+    }\n+    \n     /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n         }\n     }\n \n-    protected String aposToQuotes(String json) {\n+    protected static String aposToQuotes(String json) {\n         return json.replace(\"'\", \"\\\"\");\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class SimpleBuilderXY\n     {\n         public int x, y;\n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class BuildABC\n     {\n         public int a; // to be used as is\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithNamingStrategy556.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreatorWithNamingStrategy556\n+    extends BaseMapTest\n+{\n+    static class RenamingCtorBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        @JsonCreator\n+        public RenamingCtorBean(int myAge, String myName)\n+        {\n+            this.myName = myName;\n+            this.myAge = myAge;\n+        }\n+    }\n+\n+    // Try the same with factory, too\n+    static class RenamedFactoryBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        private RenamedFactoryBean(int a, String n, boolean foo) {\n+            myAge = a;\n+            myName = n;\n+        }\n+        \n+        @JsonCreator\n+        public static RenamedFactoryBean create(int age, String name) {\n+            return new RenamedFactoryBean(age, name, true);\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"myAge\";\n+                case 1: return \"myName\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper()\n+            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n+            ;\n+    {\n+        MAPPER.setAnnotationIntrospector(new MyParamIntrospector());\n+    }\n+\n+    private final static String CTOR_JSON = aposToQuotes(\"{ 'MyAge' : 42,  'MyName' : 'NotMyRealName' }\");\n+    \n+    public void testRenameViaCtor() throws Exception\n+    {\n+        RenamingCtorBean bean = MAPPER.readValue(CTOR_JSON, RenamingCtorBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+\n+    public void testRenameViaFactory() throws Exception\n+    {\n+        RenamedFactoryBean bean = MAPPER.readValue(CTOR_JSON, RenamedFactoryBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n package com.fasterxml.jackson.databind.interop;\n \n-\n-import java.io.*;\n import java.lang.reflect.Method;\n import java.util.*;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n     {\n         public int x;\n \n-        @SuppressWarnings(\"hiding\")\n         public SimpleBuilder withX(int x) {\n     \t\t    this.x = x;\n     \t\t    return this;\n--- a/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n         String json = mapper.writeValueAsString(input);\n         assertEquals(\"{\\\"value\\\":{\\\"x\\\":13},\\\"type\\\":\\\"foo\\\"}\", json);\n     }\n-    \n-\n }", "timestamp": 1411689150, "metainfo": ""}