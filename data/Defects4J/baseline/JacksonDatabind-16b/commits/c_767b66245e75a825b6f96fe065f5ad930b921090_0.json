{"sha": "767b66245e75a825b6f96fe065f5ad930b921090", "log": "Merge pull request #361 from stuartwdouglas/master  Use double checked locking to remove sync block", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java\n     /**\n      * Most recent read-only instance, created from _sharedMap, if any.\n      */\n-    private ReadOnlyClassToSerializerMap _readOnlyMap = null;\n+    private volatile ReadOnlyClassToSerializerMap _readOnlyMap = null;\n \n     public SerializerCache() { }\n \n      */\n     public ReadOnlyClassToSerializerMap getReadOnlyLookupMap()\n     {\n-        ReadOnlyClassToSerializerMap m;\n-        synchronized (this) {\n-            m = _readOnlyMap;\n-            if (m == null) {\n-                _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap);\n+        ReadOnlyClassToSerializerMap m = _readOnlyMap;\n+        if(m == null) {\n+            synchronized (this) {\n+                m = _readOnlyMap;\n+                if (m == null) {\n+                    _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap);\n+                }\n             }\n         }\n         return m.instance();\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /**\n      * Reverse of {@link #treeToValue}; given a value (usually bean), will\n-     * construct equivalent JSON Tree representation. Functionally same\n-     * as if serializing value into JSON and parsing JSON as tree, but\n+     * construct equivalent JSON Tree representation. Functionally similar\n+     * to serializing value into JSON and parsing JSON as tree, but\n      * more efficient.\n+     *<p>\n+     * NOTE: one known difference from actual serialization is that so-called\n+     * \"raw values\" are not supported -- since they are opaque sequence of\n+     * bytes to include (which may or may not be supported by the backend)\n+     * they can not be converted using this method. It may be possible to\n+     * support conversions using full serialization, if raw values must be\n+     * preserved.\n      * \n      * @param <T> Actual node type; usually either basic {@link JsonNode} or\n      *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n /**\n- * Object that knows how to serialize Object Ids.\n+ * Object that knows how to deserialize Object Ids.\n  */\n public class ObjectIdReader\n     implements java.io.Serializable\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n                 Object elem = value.next();\n                 if (elem == null) {\n                     provider.defaultSerializeNull(jgen);\n-                } else {\n+                    continue;\n+                }\n+                JsonSerializer<Object> currSerializer = _elementSerializer;\n+                if (currSerializer == null) {\n                     // Minor optimization to avoid most lookups:\n                     Class<?> cc = elem.getClass();\n-                    JsonSerializer<Object> currSerializer;\n                     if (cc == prevClass) {\n                         currSerializer = prevSerializer;\n                     } else {\n                         prevSerializer = currSerializer;\n                         prevClass = cc;\n                     }\n-                    if (typeSer == null) {\n-                        currSerializer.serialize(elem, jgen, provider);\n-                    } else {\n-                        currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n-                    }\n+                }\n+                if (typeSer == null) {\n+                    currSerializer.serialize(elem, jgen, provider);\n+                } else {\n+                    currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n                 }\n             } while (value.hasNext());\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n \n     @Override\n     public boolean hasSingleElement(Iterable<?> value) {\n-        // no really good way to determine (without consuming iterator), so:\n+        // we can do it actually (fixed in 2.3.1)\n+        if (value != null) {\n+            Iterator<?> it = value.iterator();\n+            if (it.hasNext()) {\n+                it.next();\n+                if (!it.hasNext()) {\n+                    return true;\n+                }\n+            }\n+        }\n         return false;\n     }\n     \n                 Object elem = it.next();\n                 if (elem == null) {\n                     provider.defaultSerializeNull(jgen);\n-                } else {\n+                    continue;\n+                }\n+                JsonSerializer<Object> currSerializer = _elementSerializer;\n+                if (currSerializer == null) {\n                     // Minor optimization to avoid most lookups:\n                     Class<?> cc = elem.getClass();\n-                    JsonSerializer<Object> currSerializer;\n                     if (cc == prevClass) {\n                         currSerializer = prevSerializer;\n                     } else {\n                         prevSerializer = currSerializer;\n                         prevClass = cc;\n                     }\n-                    if (typeSer == null) {\n-                        currSerializer.serialize(elem, jgen, provider);\n-                    } else {\n-                        currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n-                    }\n+                }\n+                if (typeSer == null) {\n+                    currSerializer.serialize(elem, jgen, provider);\n+                } else {\n+                    currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n                 }\n             } while (it.hasNext());\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Specialized {@link JsonSerializer} to output {@link java.util.UUID}s.\n     {\n         // First: perhaps we could serialize it as raw binary data?\n         if (jgen.canWriteBinaryNatively()) {\n-            jgen.writeBinary(_asBytes(value));\n-            return;\n+            /* 07-Dec-2013, tatu: One nasty case; that of TokenBuffer. While it can\n+             *   technically retain binary data, we do not want to do use binary\n+             *   with it, as that results in UUIDs getting converted to Base64 for\n+             *   most conversions.\n+             */\n+            if (!(jgen instanceof TokenBuffer)) {\n+                jgen.writeBinary(_asBytes(value));\n+                return;\n+            }\n         }\n         \n         // UUID.toString() works ok functionally, but we can make it go much faster\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n \n         public int getX() { return 13; }\n     }\n-    \n+\n+    // [Issue#358]\n+    static class A {\n+        public String unexpected = \"Bye.\";\n+    }\n+\n+    static class B {\n+        @JsonSerialize(as = Iterable.class, contentUsing = ASerializer.class)\n+        public List<A> list = Arrays.asList(new A());\n+    }\n+    static class ASerializer extends JsonSerializer<A> {\n+        @Override\n+        public void serialize(A a, JsonGenerator jsonGenerator, SerializerProvider provider) throws IOException {\n+            jsonGenerator.writeStartArray();\n+            jsonGenerator.writeString(\"Hello world.\");\n+            jsonGenerator.writeEndArray();\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(\"[1,2,3]\",\n                 MAPPER.writeValueAsString(new IntIterable()));\n     }\n+    \n+    // [Issue#358]\n+    public void testIterable358() throws Exception {\n+        String json = MAPPER.writeValueAsString(new B());\n+        assertEquals(\"{\\\"list\\\":[[\\\"Hello world.\\\"]]}\", json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n public class TestJdkTypes\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n-    private final ObjectMapper MAPPER = new ObjectMapper();\n+    private final ObjectMapper MAPPER = objectMapper();\n     \n     /**\n      * Unit test to catch bug [JACKSON-8].\n             UUID uuid = UUID.fromString(value);\n             String json = MAPPER.writeValueAsString(uuid);\n             assertEquals(quote(uuid.toString()), json);\n+\n+            // Also, wrt [#362], should convert cleanly\n+            String str = MAPPER.convertValue(uuid, String.class);\n+            assertEquals(value, str);\n         }\n         \n         // then use templating; note that these are not exactly valid UUIDs\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n             UUID out = mapper.readValue(buf.asParser(), UUID.class);\n             assertEquals(uuid.toString(), out.toString());\n \n-            // second part: ensure it's written as binary...\n+            // second part: As per [#362], should NOT use binary with TokenBuffer\n             JsonParser jp = buf.asParser();\n-            assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());\n-            byte[] raw = jp.getBinaryValue();\n-            assertEquals(16, raw.length);\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            String str = jp.getText();\n+            assertEquals(value, str);\n             jp.close();\n         }\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.util.StdConverter;\n+\n+public class TestConvertingSerializer\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    // [Issue#357]\n+    static class A { }\n+\n+    static class B {\n+        @JsonSerialize(contentConverter = AToStringConverter.class)\n+        public List<A> list = Arrays.asList(new A());\n+    }\n+\n+    static class AToStringConverter extends StdConverter<A, List<String>> {\n+        @Override\n+        public List<String> convert(A value) {\n+            return Arrays.asList(\"Hello world!\");\n+        }\n+    }\n+\n+    // [Issue#359]\n+\n+    static class Bean359 {\n+        @JsonSerialize(as = List.class, contentAs = Source.class)\n+        public List<Source> stuff = Arrays.asList(new Source());\n+    }\n+\n+    @JsonSerialize(using = TargetSerializer.class)\n+    static class Target {\n+        public String unexpected = \"Bye.\";\n+    }\n+\n+    @JsonSerialize(converter = SourceToTargetConverter.class)\n+    static class Source { }\n+\n+    static class SourceToTargetConverter extends StdConverter<Source, Target> {\n+        @Override\n+        public Target convert(Source value) {\n+            return new Target();\n+        }\n+    }\n+\n+    static class TargetSerializer extends JsonSerializer<TargetSerializer>\n+    {\n+        @Override\n+        public void serialize(TargetSerializer a, JsonGenerator jsonGenerator, SerializerProvider provider)\n+                throws IOException {\n+            jsonGenerator.writeString(\"Target\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#357]\n+    public void testConverterForList357() throws Exception {\n+        String json = objectWriter().writeValueAsString(new B());\n+        assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n+    }\n+\n+    // [Issue#359]\n+    public void testIssue359() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new Bean359());\n+        assertNotNull(json);\n+        assertEquals(\"{\\\"stuff\\\":[\\\"Target\\\"]}\", json);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestCreatorWithPolymorphic113.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Test(s) for [Issue#113], problems with polymorphic types, JsonCreator.\n+ */\n+public class TestCreatorWithPolymorphic113 extends BaseMapTest\n+{\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"_class\")\n+    @JsonSubTypes({  @JsonSubTypes.Type(Dog.class) })\n+    public static abstract class Animal {\n+        public final static String ID = \"id\";\n+\n+        private String id;\n+\n+        @JsonCreator\n+        public Animal(@JsonProperty(ID) String id) {\n+            this.id = id;\n+        }\n+\n+        @JsonProperty(ID)\n+        public String getId() {\n+            return id;\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class Dog extends Animal {\n+        @JsonCreator\n+        public Dog(@JsonProperty(ID) String id) {\n+            super(id);\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class AnimalWrapper {\n+        private Animal animal;\n+\n+        @JsonCreator\n+        public AnimalWrapper(@JsonProperty(\"animal\") Animal animal) {\n+            this.animal = animal;\n+        }\n+\n+        public Animal getAnimal() {\n+            return animal;\n+        }\n+    }\n+\n+    public void testSubtypes() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String id = \"nice dogy\";\n+        String json = mapper.writeValueAsString(new AnimalWrapper(new Dog(id)));\n+//System.err.println(\"JSON = \"+json);\n+        AnimalWrapper wrapper = mapper.readValue(json, AnimalWrapper.class);\n+        assertEquals(id, wrapper.getAnimal().getId());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestNonStaticInnerClassInList.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestNonStaticInnerClassInList extends BaseMapTest\n+{\n+    public static class Dog2\n+    {\n+        public String name;\n+        public List<Leg> legs;\n+\n+        // NOTE: non-static on purpose!\n+        public class Leg {\n+            public int length;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+    \n+    // core/[Issue#32]\n+    public void testInnerList() throws Exception\n+    {\n+        Dog2 dog = new Dog2();\n+        dog.name = \"Spike\";\n+        dog.legs = new ArrayList<Dog2.Leg>();\n+        dog.legs.add(dog.new Leg());\n+        dog.legs.add(dog.new Leg());\n+        dog.legs.get(0).length = 5;\n+        dog.legs.get(1).length = 4;\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String dogJson = mapper.writeValueAsString(dog);\n+//        System.out.println(dogJson);\n+      // output: {\"name\":\"Spike\",\"legs\":[{length: 5}, {length: 4}]}\n+\n+        // currently throws JsonMappingException\n+        Dog2 dogCopy = mapper.readValue(dogJson, Dog2.class);\n+        assertEquals(dogCopy.legs.get(1).length, 4);\n+        // prefer fully populated Dog instance\n+    }\n+}\n+\n+", "timestamp": 1386733547, "metainfo": ""}