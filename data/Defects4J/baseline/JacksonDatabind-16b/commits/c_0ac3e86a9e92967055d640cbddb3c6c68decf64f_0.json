{"sha": "0ac3e86a9e92967055d640cbddb3c6c68decf64f", "log": "Merge pull request #581 from fleebytes/master  Fixes #528 - Add support for As.EXISTING_PROPERTY inclusion mechanism", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsPropertyTypeSerializer\n+{\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property, propName);\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n     // as per [#368]\n-    private IllegalArgumentException _noExisting() {\n-        return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n-    }\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n \n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             return new AsExternalTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsPropertyTypeDeserializer(baseType, idRes,\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\n+    /**\n+     * Polymorphic base class - existing property as simple property on subclasses\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Apple.class, name = \"apple\") ,\n+\t\t@Type(value = Orange.class, name = \"orange\") \n+\t\t})\n+\tstatic abstract class Fruit {\n+        public String name;\n+        protected Fruit(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"apple\")\n+    static class Apple extends Fruit\n+    {\n+    \tpublic int seedCount;\n+    \tpublic String type;\n+        \n+        private Apple() { super(null); type = \"apple\"; }\n+        public Apple(String name, int b) {\n+            super(name);\n+            seedCount = b;\n+            type = \"apple\";\n+        }\n+    }\n+    \n+    @JsonTypeName(\"orange\")\n+    static class Orange extends Fruit\n+    {\n+        public String color;\n+        public String type;\n+        \n+        private Orange() { super(null); type = \"orange\"; }\n+        public Orange(String name, String c) {\n+            super(name);\n+            color = c;\n+            type = \"orange\";\n+        }\n+    }\n+\n+    static class FruitWrapper {\n+        public Fruit fruit;\n+        public FruitWrapper() {}\n+        public FruitWrapper(Fruit f) { fruit = f; }\n+    }\n+    \n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Orange mandarin = new Orange(\"Mandarin Orange\", \"orange\");\n+\tprivate static final String mandarinJson = \"{\\\"name\\\":\\\"Mandarin Orange\\\",\\\"color\\\":\\\"orange\\\",\\\"type\\\":\\\"orange\\\"}\";\t\n+\tprivate static final Apple pinguo = new Apple(\"Apple-A-Day\", 16);\n+\tprivate static final String pinguoJson = \"{\\\"name\\\":\\\"Apple-A-Day\\\",\\\"seedCount\\\":16,\\\"type\\\":\\\"apple\\\"}\";\n+\tprivate static final FruitWrapper pinguoWrapper = new FruitWrapper(pinguo);\n+\tprivate static final String pinguoWrapperJson = \"{\\\"fruit\\\":\" + pinguoJson + \"}\";\n+\tprivate static final List<Fruit> fruitList = Arrays.asList(pinguo, mandarin);\n+\tprivate static final String fruitListJson = \"[\" + pinguoJson + \",\" + mandarinJson + \"]\";\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fruits - serialization tests for simple property on sub-classes\n+     */\n+    public void testExistingPropertySerializationFruits() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, pinguo);\n+        assertEquals(3, result.size());\n+        assertEquals(pinguo.name, result.get(\"name\"));\n+        assertEquals(pinguo.seedCount, result.get(\"seedCount\"));\n+        assertEquals(pinguo.type, result.get(\"type\"));\n+        \n+        result = writeAndMap(MAPPER, mandarin);\n+        assertEquals(3, result.size());\n+        assertEquals(mandarin.name, result.get(\"name\"));\n+        assertEquals(mandarin.color, result.get(\"color\"));\n+        assertEquals(mandarin.type, result.get(\"type\"));\n+        \n+        String pinguoSerialized = MAPPER.writeValueAsString(pinguo);\n+        assertEquals(pinguoSerialized, pinguoJson);\n+\n+        String mandarinSerialized = MAPPER.writeValueAsString(mandarin);\n+        assertEquals(mandarinSerialized, mandarinJson);\n+\n+        String fruitWrapperSerialized = MAPPER.writeValueAsString(pinguoWrapper);\n+        assertEquals(fruitWrapperSerialized, pinguoWrapperJson);\n+\n+        String fruitListSerialized = MAPPER.writeValueAsString(fruitList);\n+        assertEquals(fruitListSerialized, fruitListJson);\n+    }\n+\n+    /**\n+     * Fruits - deserialization tests for simple property on sub-classes\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationFruits() throws Exception\n+    {\n+    \tFruit pinguoDeserialized = MAPPER.readValue(pinguoJson, Fruit.class);\n+    \tassertTrue(pinguoDeserialized instanceof Apple);\n+        assertSame(pinguoDeserialized.getClass(), Apple.class);\n+    \tassertEquals(pinguo.name, pinguoDeserialized.name);\n+    \tassertEquals(pinguo.seedCount, ((Apple) pinguoDeserialized).seedCount);\n+    \tassertEquals(pinguo.type, ((Apple) pinguoDeserialized).type);\n+\n+    \tFruitWrapper pinguoWrapperDeserialized = MAPPER.readValue(pinguoWrapperJson, FruitWrapper.class);\n+    \tFruit pinguoExtracted = pinguoWrapperDeserialized.fruit;\n+    \tassertTrue(pinguoExtracted instanceof Apple);\n+        assertSame(pinguoExtracted.getClass(), Apple.class);\n+    \tassertEquals(pinguo.name, pinguoExtracted.name);\n+    \tassertEquals(pinguo.seedCount, ((Apple) pinguoExtracted).seedCount);\n+    \tassertEquals(pinguo.type, ((Apple) pinguoExtracted).type);\n+\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Fruit> fruitListDeserialized = MAPPER.readValue(fruitListJson, List.class);\n+    \tassertNotNull(fruitListDeserialized);\n+    \tassertTrue(fruitListDeserialized.size() == 2);\n+    \tFruit apple = MAPPER.convertValue(fruitListDeserialized.get(0), Apple.class);\n+    \tassertTrue(apple instanceof Apple);\n+        assertSame(apple.getClass(), Apple.class);\n+    \tFruit orange = MAPPER.convertValue(fruitListDeserialized.get(1), Orange.class);\n+    \tassertTrue(orange instanceof Orange);\n+        assertSame(orange.getClass(), Orange.class);\n+    }\n+\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+    \tAnimal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+    \tassertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubDeserialized.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+    \tAnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+    \tAnimal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+    \tassertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubExtracted.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+    \tassertNotNull(animalListDeserialized);\n+    \tassertTrue(animalListDeserialized.size() == 2);\n+    \tAnimal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+    \tassertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+    \tAnimal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+    \tassertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    \n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+    \tCar camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+    \tassertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryDeserialized.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+    \tCarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+    \tCar camryExtracted = camryWrapperDeserialized.car;\n+    \tassertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryExtracted.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+    \tassertNotNull(carListDeserialized);\n+    \tassertTrue(carListDeserialized.size() == 2);\n+    \tCar camry = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+    \tassertTrue(camry instanceof Camry);\n+        assertSame(camry.getClass(), Camry.class);\n+    \tCar accord = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+    \tassertTrue(accord instanceof Accord);\n+        assertSame(accord.getClass(), Accord.class);\n+    }\n+\n+    \n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n      * \n      * @since 2.3\n      */\n-    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n-    {\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc) {\n         return new AbstractDeserializer(beanDesc);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n                 ;\n     }\n \n-    protected BeanDeserializerBase(BeanDeserializerBase src)\n-    {\n+    protected BeanDeserializerBase(BeanDeserializerBase src) {\n         this(src, src._ignoreAllUnknown);\n     }\n \n             BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,\n                     delegateType, null, _classAnnotations, delegateCreator,\n                     PropertyMetadata.STD_OPTIONAL);\n-            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+\n+            TypeDeserializer td = delegateType.getTypeHandler();\n+            if (td == null) {\n+                td = ctxt.getConfig().findTypeDeserializer(delegateType);\n+            }\n+            JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n+            if (td != null) {\n+                td = td.forProperty(property);\n+                dd = new TypeWrappedDeserializer(td, dd);\n+            }\n+            _delegateDeserializer = dd;\n         }\n         \n         if (extTypes != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n      * \n      * @since 2.0\n      */\n-    public AbstractDeserializer buildAbstract()\n-    {\n+    public AbstractDeserializer buildAbstract() {\n         return new AbstractDeserializer(this, _beanDesc, _backRefProperties);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  */\n public final class TypeWrappedDeserializer\n     extends JsonDeserializer<Object>\n+    implements java.io.Serializable // since 2.5\n {\n-    final TypeDeserializer _typeDeserializer;\n-    final JsonDeserializer<Object> _deserializer;\n+    private static final long serialVersionUID = 1L;\n \n-    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+    final protected TypeDeserializer _typeDeserializer;\n+    final protected JsonDeserializer<Object> _deserializer;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super();\n         _typeDeserializer = typeDeser;\n-        _deserializer = deser;\n+        _deserializer = (JsonDeserializer<Object>) deser;\n     }\n \n     @Override\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n     }\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-        TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n+        TypeDeserializer typeDeserializer) throws IOException\n     {\n         // should never happen? (if it can, could call on that object)\n         throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object intoValue)\n-        throws IOException, JsonProcessingException\n+            Object intoValue) throws IOException\n     {\n         /* 01-Mar-2013, tatu: Hmmh. Tough call as to what to do... need\n          *   to delegate, but will this work reliably? Let's just hope so:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     extends ContainerDeserializerBase<Map<Object,Object>>\n     implements ContextualDeserializer, ResolvableDeserializer\n {\n-    private static final long serialVersionUID = -3378654289961736240L;\n+    private static final long serialVersionUID = 1L;\n \n     // // Configuration: typing, deserializers\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n      */\n     \n     @Override\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException\n     {\n         if (_defaultCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No default constructor for \"+getValueTypeDesc());\n     }\n     \n     @Override\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException\n     {\n         if (_withArgsCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No with-args constructor for \"+getValueTypeDesc());\n     }\n \n     @Override\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException\n     {\n         if (_delegateCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n      */\n     \n     @Override\n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException\n     {\n         if (_fromStringCreator != null) {\n             try {\n     }\n     \n     @Override\n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException\n     {\n         try {\n             // First: \"native\" int methods work best:\n     }\n \n     @Override\n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException\n     {\n         try {\n             if (_fromLongCreator != null) {\n     }\n \n     @Override\n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException\n     {\n         try {\n             if (_fromDoubleCreator != null) {\n     }\n \n     @Override\n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException\n     {\n         try {\n             if (_fromBooleanCreator != null) {\n     public AnnotatedParameter getIncompleteParameter() {\n         return _incompleteParameter;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/MemberKey.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/MemberKey.java\n              *    This happens with generics when a bound is specified.\n              *    I hope this works; check here must be transitive\n              */\n+            /* 14-Oct-2014, tatu: No, doing that is wrong. Conflicts may (and will) be\n+             *    handled at a later point; trying to change definition of equality\n+             *    will just cause problems like [jackson-core#158]\n+             */\n+            /*\n             if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) {\n                 continue;\n             }\n+            */\n             return false;\n         }\n         return true;\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n \n         // as above, should not carry on state\n         TestPOJO pojo2 = MAPPER.reader(TestPOJO.class)\n-                .withAttribute(KEY, Integer.valueOf(3))\n+                .withAttribute(KEY, Integer.valueOf(5))\n                 .readValue(INPUT);\n-        assertEquals(\"x/3\", pojo2.value);\n+        assertEquals(\"x/5\", pojo2.value);\n     }\n \n     public void testHierarchic() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JacksonInject;\n-\n import com.fasterxml.jackson.databind.*;\n \n public class TestCreatorsDelegating extends BaseMapTest\n             return new FactoryBean711(a, n1, n2);\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicDelegating.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPolymorphicDelegating extends BaseMapTest\n+{\n+\n+    // For [databind#580]\n+    \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+    static abstract class Issue580Base {\n+    }\n+\n+    static class Issue580Impl extends Issue580Base {\n+        public int id = 3;\n+\n+        public Issue580Impl() { }\n+        public Issue580Impl(int id) { this.id = id; }\n+    }\n+\n+    static class Issue580Bean {\n+        public Issue580Base value;\n+\n+        @JsonCreator\n+        public Issue580Bean(Issue580Base v) {\n+            value = v;\n+        }\n+\n+        @JsonValue\n+        public Issue580Base value() {\n+            return value;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractDelegateWithCreator() throws Exception\n+    {\n+        Issue580Bean input = new Issue580Bean(new Issue580Impl(13));\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue580Bean result = mapper.readValue(json, Issue580Bean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(13, ((Issue580Impl) result.value).id);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n                 \".hype\");\n         // note: need to wrap, to get declared as Object\n         String json = m.writeValueAsString(new StringBean(\"abc\"));\n-\n-        System.err.println(\"JSON == \"+json);\n         \n         // Ok: serialization seems to work as expected. Now deserialize:\n         Object result = m.readValue(json, Object.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n     public void testSubTypesFor356() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test\n-         *   suite green, let's not run it for versions prior to 1.7...\n-         */\n-        Version v = mapper.version();\n-        if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {\n-            System.err.println(\"Note: skipping test for Jackson 1.6\");\n-            return;\n-        }\n         \n         JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();\n \n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n-//        byte[] json = mapper.writeValueAsBytes(input);\n-\n-//        System.out.println(\"After Serialization: \" + new String(json));\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n         public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n                 BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n         {\n-            System.err.println(\"DEBUG: changeProperties!\");\n             return beanProperties;\n         }\n         \n         @Override\n         public JsonSerializer<?> modifySerializer(SerializationConfig config,\n                 BeanDescription beanDesc, JsonSerializer<?> serializer) {\n-System.err.println(\"DEBUG: modifySer!\");            \n             return new BogusBeanSerializer(42);\n         }\n     }", "timestamp": 1413425893, "metainfo": ""}