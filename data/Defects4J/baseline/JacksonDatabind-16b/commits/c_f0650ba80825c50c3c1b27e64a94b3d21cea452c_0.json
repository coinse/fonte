{"sha": "f0650ba80825c50c3c1b27e64a94b3d21cea452c", "log": "Solidify POJOs-as-array functionality", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             if (creatorProp != null) {\n                 // Last creator property to set?\n                 Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n             if (creatorProp != null) {\n                 // Last creator property to set?\n                 Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                 } else {\n                     // Last creator property to set?\n                     Object value = creatorProp.deserialize(jp, ctxt);\n-                    if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                         t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * to use have been successfully resolved.\n      */\n     final protected BeanPropertyMap _beanProperties;\n-\n+    \n     /**\n      * List of {@link ValueInjector}s, if any injectable values are\n      * expected by the bean; otherwise null.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n-import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.util.Annotations;\n \n /**\n      */\n     final protected Map<String, SettableBeanProperty> _properties\n         = new LinkedHashMap<String, SettableBeanProperty>();\n-\n+    \n     /**\n      * Value injectors for deserialization\n      */\n         if (_properties != null) {\n             _properties.remove(prop.getName());\n         }\n+        // ??? 23-Jul-2012, tatu: Should it be included in list of all properties?\n+        //   For now, won't add, since it is inferred, not explicit...\n     }\n \n     public void addInjectable(String propertyName, JavaType propertyType,\n      * For now, however, we just have to ensure that we don't try to resolve\n      * types that masked setter/field has (see [JACKSON-700] for details).\n      */\n+    public void addCreatorProperty(SettableBeanProperty prop)\n+    {\n+        addProperty(prop);\n+    }\n+\n+    /**\n+     * @deprecated since 2.1, override {@link #addCreatorProperty(SettableBeanProperty)} instead.\n+     */\n+    @Deprecated\n     public void addCreatorProperty(BeanPropertyDefinition propDef)\n     {\n         // do nothing\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n          // And then setters for deserializing from JSON Object\n         addBeanProps(ctxt, beanDesc, builder);\n         addObjectIdReader(ctxt, beanDesc, builder);\n-        \n+\n         // managed/back reference fields/setters need special handling... first part\n         addReferenceProperties(ctxt, beanDesc, builder);\n         addInjectables(ctxt, beanDesc, builder);\n             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n         throws JsonMappingException\n     {\n+        final SettableBeanProperty[] creatorProps =\n+                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n+        \n         // Things specified as \"ok to ignore\"? [JACKSON-77]\n         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         boolean ignoreAny = false;\n         \n         // At which point we still have all kinds of properties; not all with mutators:\n         for (BeanPropertyDefinition propDef : propDefs) {\n+            SettableBeanProperty prop = null;\n             if (propDef.hasConstructorParameter()) {\n-                /* [JACKSON-700] If property as passed via constructor parameter, we must\n+                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                  *   handle things in special way. Not sure what is the most optimal way...\n                  *   for now, let's just call a (new) method in builder, which does nothing.\n                  */\n                 // but let's call a method just to allow custom builders to be aware...\n-                builder.addCreatorProperty(propDef);\n+                final String name = propDef.getName();\n+                for (SettableBeanProperty cp : creatorProps) {\n+                    if (name.equals(cp.getName())) {\n+                        prop = cp;\n+                        break;\n+                    }\n+                }\n+                if (prop == null) {\n+                    throw ctxt.mappingException(\"Could not find creator property with name '\"+name+\"'\");\n+                }\n+                builder.addCreatorProperty(prop);\n                 continue;\n             }\n-            SettableBeanProperty prop = null;\n             if (propDef.hasSetter()) {\n                 Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                 prop = constructSettableProperty(ctxt,\n             }\n         }\n     }\n-\n+    \n     /**\n      * Helper method called to filter out explicit ignored properties,\n      * as well as properties that have \"ignorable types\".\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n             if (creatorProp != null) {\n                 // Last creator property to set?\n                 Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n             if (creatorProp != null) {\n                 // Last creator property to set?\n                 Object value = creatorProp.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n      * (in addition to, or instead of, regular deserialization).\n      */\n     protected final Object _injectableValueId;\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected final int _creatorIndex;\n     \n     /**\n      * @param name Name of the logical property\n      *    this property)\n      * @param param Representation of property, constructor or factory\n      *    method parameter; used for accessing annotations of the property\n+     * @param index Index of this property within creator invocatino\n      */\n     public CreatorProperty(String name, JavaType type, TypeDeserializer typeDeser,\n             Annotations contextAnnotations, AnnotatedParameter param,\n     {\n         super(name, type, typeDeser, contextAnnotations);\n         _annotated = param;\n-        _propertyIndex = index;\n+        _creatorIndex = index;\n         _injectableValueId = injectableValueId;\n     }\n \n     protected CreatorProperty(CreatorProperty src, String newName) {\n         super(src, newName);\n         _annotated = src._annotated;\n+        _creatorIndex = src._creatorIndex;\n         _injectableValueId = src._injectableValueId;\n     }\n     \n     protected CreatorProperty(CreatorProperty src, JsonDeserializer<?> deser) {\n         super(src, deser);\n         _annotated = src._annotated;\n+        _creatorIndex = src._creatorIndex;\n         _injectableValueId = src._injectableValueId;\n     }\n \n     }\n \n     @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+    @Override public int getCreatorIndex() {\n+        return _creatorIndex;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n      */\n     public int getPropertyIndex() { return _propertyIndex; }\n \n+    /**\n+     * Method for accessing index of the creator property: for other\n+     * types of properties will simply return -1.\n+     * \n+     * @since 2.1\n+     */\n+    public int getCreatorIndex() { return -1; }\n+    \n     /**\n      * Accessor for id of injectable value, if this bean property supports\n      * value injection.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     protected BeanDeserializerBase asArrayDeserializer() {\n         return this;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n     \n-    /*\n-    /**********************************************************\n-    /* JsonDeserializer implementation\n-    /**********************************************************\n-     */\n-\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        // common case first:\n+        throws IOException, JsonProcessingException\n+    {\n+        // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n         if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return _delegate.deserialize(jp, ctxt);\n+            return _deserializeFromNonArray(jp, ctxt);\n+        }\n+        if (!_vanillaProcessing) {\n+            return _deserializeNonVanilla(jp, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n         final SettableBeanProperty[] props = _orderedProperties;\n             }\n             ++i;\n         }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return bean;\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* No good way to verify that we have an array... although could I guess\n+         * check via JsonParser. So let's assume everything is working fine, for now.\n+         */\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return bean;\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n         \n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n         }\n         return bean;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, non-standard creation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Alternate deserialization method that has to check many more configuration\n+     * aspects than the \"vanilla\" processing.\n+     */\n+    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_nonStandardCreation) {\n+            return _deserializeWithCreator(jp, ctxt);\n+        }\n+        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return bean;\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            ++i;\n+            if (prop != null) { // normal case\n+                if (activeView == null || prop.visibleInView(activeView)) {\n+                    try {\n+                        prop.deserializeAndSet(jp, ctxt, bean);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, bean, prop.getName(), ctxt);\n+                    }\n+                    continue;\n+                }\n+            }\n+            // otherwise, skip it (view-filtered, no prop etc)\n+            jp.skipChildren();\n+        }\n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return bean;\n+    }\n+    \n+    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+\n+    /**\n+     * Method called to deserialize bean using \"property-based creator\":\n+     * this means that a non-default constructor or factory method is\n+     * called, and then possibly other setters. The trick is that\n+     * values for creator method need to be buffered, first; and \n+     * due to non-guaranteed ordering possibly some other properties\n+     * as well.\n+     */\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        final int propCount = props.length;\n+        int i = 0;\n+        Object bean = null;\n+        \n+        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+            SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n+            if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // if we have already constructed POJO, things are simple:\n+            if (bean != null) {\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, prop.getName(), ctxt);\n+                }\n+                continue;\n+            }\n+            final String propName = prop.getName();\n+            // if not yet, maybe we got a creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n+                    try {\n+                        bean = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    //  polymorphic?\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n+                         *   supported (since ordering of elements may not be guaranteed);\n+                         *   but make explicitly non-supported for now.\n+                         */\n+                        throw ctxt.mappingException(\"Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: \"\n+                                +\"nominal type \"+_beanType.getRawClass().getName()+\", actual type \"+bean.getClass().getName());\n+                    }\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+        }\n+\n+        // In case we didn't quite get all the creator properties, we may have to do this:P\n+        if (bean == null) {\n+            try {\n+                bean = creator.build(ctxt, buffer);\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+                return null; // never gets here\n+            }\n+        }\n+        return bean;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, error reporting\n+    /**********************************************************\n+     */\n+\n+    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        // Let's start with failure\n+        throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n+                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\"): type/property designed to be serialized as JSON Array\");\n+        // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n+        //return _delegate.deserialize(jp, ctxt);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n         for (int i = 0; i < len; ++i) {\n             SettableBeanProperty prop = _properties[i].getProperty();\n             if (creator.findCreatorProperty(prop.getName()) != null) {\n-                buffer.assignParameter(prop.getPropertyIndex(), values[i]);\n+                buffer.assignParameter(prop.getCreatorIndex(), values[i]);\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             if (prop != null) {\n                 // Last property to set?\n                 Object value = prop.deserialize(jp, ctxt);\n-                if (buffer.assignParameter(prop.getPropertyIndex(), value)) {\n+                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                     jp.nextToken();\n                     Map<Object,Object> result;\n                     try {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         if (value == null) { // nulls need specialized handling\n             if (_nullSerializer != null) {\n                 _nullSerializer.serialize(null, jgen, prov);\n+            } else { // can NOT suppress entries in tabular output\n+                jgen.writeNull();\n             }\n-            return;\n         }\n         // otherwise find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n+                    serializeAsPlaceholder(bean, jgen, prov);\n                     return;\n                 }\n-            } else if (_suppressableValue.equals(value)) {\n+            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n+                serializeAsPlaceholder(bean, jgen, prov);\n                 return;\n             }\n         }\n             ser.serialize(value, jgen, prov);\n         } else {\n             ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize a placeholder used in tabular output when\n+     * real value is not to be included (is filtered out), but when we need\n+     * an entry so that field indexes will not be off. Typically this should\n+     * output null or empty String, depending on datatype.\n+     * \n+     * @since 2.1\n+     */\n+    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        if (_nullSerializer != null) {\n+            _nullSerializer.serialize(null, jgen, prov);\n+        } else {\n+            jgen.writeNull();\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n         } else {\n             props = _props;\n         }\n+\n         int i = 0;\n         try {\n             for (final int len = props.length; i < len; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java\n                 _delegate.serializeAsField(bean, jgen, prov);\n             }\n         }\n+\n+        @Override\n+        public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+            throws Exception\n+        {\n+            Class<?> activeView = prov.getSerializationView();\n+            if (activeView == null || _view.isAssignableFrom(activeView)) {\n+                _delegate.serializeAsColumn(bean, jgen, prov);\n+            } else {\n+                _delegate.serializeAsPlaceholder(bean, jgen, prov);\n+            }\n+        }\n     }\n \n     private final static class MultiView\n             }\n             _delegate.serializeAsField(bean, jgen, prov);\n         }\n+\n+        @Override\n+        public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+            throws Exception\n+        {\n+            final Class<?> activeView = prov.getSerializationView();\n+            if (activeView != null) {\n+                int i = 0, len = _views.length;\n+                for (; i < len; ++i) {\n+                    if (_views[i].isAssignableFrom(activeView)) break;\n+                }\n+                // not included, bail out:\n+                if (i == len) {\n+                    _delegate.serializeAsPlaceholder(bean, jgen, prov);\n+                    return;\n+                }\n+            }\n+            _delegate.serializeAsColumn(bean, jgen, prov);\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestPOJOAsArrayAdvanced extends BaseMapTest\n+{\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class CreatorAsArray\n+    {\n+        protected int x, y;\n+        public int a, b;\n+\n+        @JsonCreator\n+        public CreatorAsArray(@JsonProperty(\"x\") int x, @JsonProperty(\"y\") int y)\n+        {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        public int getX() { return x; }\n+        public int getY() { return y; }\n+    }\n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder({\"a\",\"b\",\"x\",\"y\"})\n+    static class CreatorAsArrayShuffled\n+    {\n+        protected int x, y;\n+        public int a, b;\n+\n+        @JsonCreator\n+        public CreatorAsArrayShuffled(@JsonProperty(\"x\") int x, @JsonProperty(\"y\") int y)\n+        {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        public int getX() { return x; }\n+        public int getY() { return y; }\n+    }\n+\n+    static class ViewA { }\n+    static class ViewB { }\n+    \n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class AsArrayWithView\n+    {\n+        @JsonView(ViewA.class)\n+        public int a;\n+        @JsonView(ViewB.class)\n+        public int b;\n+        public int c;\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Basic tests\n+    /*****************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithView() throws Exception\n+    {\n+        // Ok, first, ensure that serializer will \"black out\" filtered properties\n+        AsArrayWithView input = new AsArrayWithView();\n+        input.a = 1;\n+        input.b = 2;\n+        input.c = 3;\n+        String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input);\n+        assertEquals(\"[1,null,3]\", json);\n+\n+        // and then that conversely deserializer does something similar\n+        AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class)\n+                .readValue(\"[1,2,3]\");\n+        // should include 'c' (not view-able) and 'b' (include in ViewB) but not 'a'\n+        assertEquals(3, output.c);\n+        assertEquals(2, output.b);\n+        assertEquals(0, output.a);\n+    }\n+\n+    public void testWithCreatorsOrdered() throws Exception\n+    {\n+        CreatorAsArray input = new CreatorAsArray(3, 4);\n+        input.a = 1;\n+        input.b = 2;\n+\n+        // note: Creator properties get sorted ahead of others, hence not [1,2,3,4] but:\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(\"[3,4,1,2]\", json);\n+\n+        // and should get back in proper order, too\n+        CreatorAsArray output = MAPPER.readValue(json, CreatorAsArray.class);\n+        assertEquals(1, output.a);\n+        assertEquals(2, output.b);\n+        assertEquals(3, output.x);\n+        assertEquals(4, output.y);\n+    }\n+\n+    // Same as above, but ordering of properties different...\n+    public void testWithCreatorsShuffled() throws Exception\n+    {\n+        CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4);\n+        input.a = 1;\n+        input.b = 2;\n+\n+        // note: explicit ordering overrides implicit creators-first ordering:\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(\"[1,2,3,4]\", json);\n+\n+        // and should get back in proper order, too\n+        CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class);\n+        assertEquals(1, output.a);\n+        assertEquals(2, output.b);\n+        assertEquals(3, output.x);\n+        assertEquals(4, output.y);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n      */\n     static class ImplicitBean {\n     \t@SuppressWarnings(\"unused\")\n-\t\t@JsonView(ViewA.class)\n+    \t@JsonView(ViewA.class)\n     \tprivate int a = 1;\n     }\n ", "timestamp": 1343101179, "metainfo": ""}