{"sha": "585f3097147cbdcfda2b5221ea76679e8915a029", "log": "Fixed #503", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n package com.fasterxml.jackson.databind.util;\n \n import java.io.*;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Helper for simple bounded LRU maps used for reusing lookup values.\n+ * Helper for simple bounded maps used for reusing lookup values.\n  *<p>\n  * Note that serialization behavior is such that contents are NOT serialized,\n  * on assumption that all use cases are for caching where persistence\n  * does not make sense. The only thing serialized is the cache size of Map.\n  *<p>\n- * NOTE: the only reason we extend {@link LinkedHashMap} instead of aggregating\n- * it is that this way we can override {@link #removeEldestEntry}.\n- * Access, however, MUST be done using single-element access methods (or matching\n- * <code>xxxAll()</code> methods that call them); access via iterators are not\n- * guaranteed to work.\n- *<p>\n- * NOTE: since version 2.4, uses {@link ReentrantReadWriteLock} to improve\n- * concurrent access.\n+ * NOTE: since version 2.4.2, this is <b>NOT</b> an LRU-based at all; reason\n+ * being that it is not possible to use JDK components that do LRU _AND_ perform\n+ * well wrt synchronization on multi-core systems. So we choose efficient synchronization\n+ * over potentially more effecient handling of entries.\n  */\n-public class LRUMap<K,V> extends LinkedHashMap<K,V>\n+public class LRUMap<K,V>\n     implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n-    protected final transient Lock _readLock, _writeLock;\n-    \n     protected final transient int _maxEntries;\n+\n+    protected final transient ConcurrentHashMap<K,V> _map;\n     \n     public LRUMap(int initialEntries, int maxEntries)\n     {\n-        super(initialEntries, 0.8f, true);\n+        // We'll use concurrency level of 4, seems reasonable\n+        _map = new ConcurrentHashMap<K,V>(initialEntries, 0.8f, 4);\n         _maxEntries = maxEntries;\n-        final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n-        _readLock = rwl.readLock();\n-        _writeLock = rwl.writeLock();\n     }\n \n-    @Override\n-    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n-        return size() > _maxEntries;\n+    public void put(K key, V value) {\n+        if (_map.size() >= _maxEntries) {\n+            // double-locking, yes, but safe here; trying to avoid \"clear storms\"\n+            synchronized (this) {\n+                if (_map.size() >= _maxEntries) {\n+                    clear();\n+                }\n+            }\n+        }\n+        _map.put(key, value);\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Overrides to support proper concurrency\n-    /**********************************************************\n-     */\n+    public V get(K key) {  return _map.get(key); }\n+    public void clear() { _map.clear(); }\n+    public int size() { return _map.size(); }\n \n-    @Override\n-    public V get(Object key) {\n-        _readLock.lock();\n-        try {\n-            return super.get(key);\n-        } finally {\n-            _readLock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public V put(K key, V value) {\n-        _writeLock.lock();\n-        try {\n-            return super.put(key, value);\n-        } finally {\n-            _writeLock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public V remove(Object key) {\n-        _writeLock.lock();\n-        try {\n-            return super.remove(key);\n-        } finally {\n-            _writeLock.unlock();\n-        }\n-    }\n-\n-    /**\n-     * Overridden to allow concurrent way of removing all cached entries.\n-     * \n-     * @since 2.4.1\n-     */\n-    @Override\n-    public void clear() {\n-        _writeLock.lock();\n-        try {\n-            super.clear();\n-        } finally {\n-            _writeLock.unlock();\n-        }\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Serializable overrides", "timestamp": 1405119365, "metainfo": ""}