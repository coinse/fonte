{"sha": "2fd4ffd9963545ce735a58957a84afb90809561e", "log": "Implement Builder-based deserializer; fix a few ObjectId issues", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.core.Versioned;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n     /**\n      * Method for checking if annotations indicate changes to minimum visibility levels\n      * needed for auto-detecting property elements (fields, methods, constructors).\n-     * A baseline checker is given, and introspector is to either return it as is (if\n-     * no annotations are found), or build and return a derived instance (using checker's build\n-     * methods).\n-     */\n-    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n+     * A baseline checker is given, and introspector is to either return it as is\n+     * (if no annotations are found), or build and return a derived instance (using\n+     * checker's build methods).\n+     */\n+    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n+            VisibilityChecker<?> checker) {\n         return checker;\n     }\n     \n         return null;\n     }\n \n+    /**\n+     * Method that can be called to check whether this member has\n+     * an annotation that suggests whether value for matching property\n+     * is required or not.\n+     * \n+     * @since 2.0\n+     */\n+    public Boolean hasRequiredMarker(AnnotatedMember m) {\n+        return null;\n+    }\n+    \n     /**\n      * Method for checking if annotated property (represented by a field or\n      * getter/setter method) has definitions for views it is to be included in.\n     /**********************************************************\n     /* Deserialization: class annotations\n     /**********************************************************\n-    */\n+     */\n \n     /**\n      * Method getting {@link ValueInstantiator} to use for given\n      * instantiator, or class of instantiator to create.\n      */\n     public Object findValueInstantiator(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding Builder object to use for constructing\n+     * value instance and binding data (sort of combining value\n+     * instantiators that can construct, and deserializers\n+     * that can bind data).\n+     *<p>\n+     * Note that unlike accessors for some helper Objects, this\n+     * method does not allow returning instances: the reason is\n+     * that builders have state, and a separate instance needs\n+     * to be created for each deserialization call.\n+     * \n+     * @since 2.0\n+     */\n+    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n+    \treturn null;\n+    }\n+\n+    /**\n+     * @since 2.0\n+     */\n+    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n         return null;\n     }\n     \n             }\n             return value;\n         }\n-        \n+\n         @Override\n         public boolean hasIgnoreMarker(AnnotatedMember m) {\n             return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n+        }\n+        \n+        @Override\n+        public Boolean hasRequiredMarker(AnnotatedMember m)\n+        {\n+            Boolean value = _primary.hasRequiredMarker(m);\n+            if (value == null) {\n+                value = _secondary.hasRequiredMarker(m);\n+            }\n+            return value;\n         }\n         \n         // // // Serialization: general annotations\n             return result;\n         }\n \n+        @Override\n+        public Class<?> findPOJOBuilder(AnnotatedClass ac)\n+        {\n+        \tClass<?> result = _primary.findPOJOBuilder(ac);\n+        \tif (result == null) {\n+        \t\tresult = _secondary.findPOJOBuilder(ac);\n+        \t}\n+        \treturn result;\n+        }\n+\n+        @Override\n+        public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n+        {\n+            JsonPOJOBuilder.Value result = _primary.findPOJOBuilderConfig(ac);\n+            if (result == null) {\n+                result = _secondary.findPOJOBuilderConfig(ac);\n+            }\n+            return result;\n+        }\n+        \n         // // // Deserialization: method annotations\n \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n      * class has.\n      */\n     public abstract Annotations getClassAnnotations();\n-    \n+   \n     /*\n     /**********************************************************\n     /* Basic API for finding properties\n     public abstract Map<Object, AnnotatedMember> findInjectables();\n \n     public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n+\n+    /**\n+     * Method for checking if the POJO type has annotations to\n+     * indicate that a builder is to be used for instantiating\n+     * instances and handling data binding, instead of standard\n+     * bean deserializer.\n+     */\n+    public abstract Class<?> findPOJOBuilder();\n+\n+    /**\n+     * Method for finding configuration for POJO Builder class.\n+     */\n+    public abstract JsonPOJOBuilder.Value findPOJOBuilderConfig();\n     \n     /**\n      * Method called to create a \"default instance\" of the bean, currently\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n         return (T) getClassIntrospector().forCreation(this, type, this);\n     }\n+\n+    /**\n+     * @since 2.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspectForBuilder(JavaType type) {\n+        return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     }\n \n     /**\n-     * Helper method for constructing generic mapping exception for specified type\n-     */\n-    public JsonMappingException mappingException(Class<?> targetClass) {\n-        return mappingException(targetClass, _parser.getCurrentToken());\n-    }\n-\n-    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)\n-    {\n-        String clsName = _calcName(targetClass);\n-        return JsonMappingException.from(_parser, \"Can not deserialize instance of \"+clsName+\" out of \"+token+\" token\");\n-    }\n-    \n-    /**\n-     * Helper method for constructing generic mapping exception with specified\n-     * message and current location information\n-     */\n-    public JsonMappingException mappingException(String message)\n-    {\n-        return JsonMappingException.from(getParser(), message);\n-    }\n-    \n-    /**\n-     * Helper method for constructing instantiation exception for specified type,\n-     * to indicate problem with physically constructing instance of\n-     * specified class (missing constructor, exception from constructor)\n-     */\n-    public JsonMappingException instantiationException(Class<?> instClass, Throwable t)\n-    {\n-        return JsonMappingException.from(_parser,\n-                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(),\n-                t);\n-    }\n-\n-    public JsonMappingException instantiationException(Class<?> instClass, String msg)\n-    {\n-        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\", problem: \"+msg);\n-    }\n-    \n-    /**\n-     * Method that will construct an exception suitable for throwing when\n-     * some String values are acceptable, but the one encountered is not.\n-     */\n-    public JsonMappingException weirdStringException(Class<?> instClass, String msg)\n-    {\n-        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from String value '\"+_valueDesc()+\"': \"+msg);\n-    }\n-\n-    /**\n-     * Helper method for constructing exception to indicate that input JSON\n-     * Number was not suitable for deserializing into given type.\n-     */\n-    public JsonMappingException weirdNumberException(Class<?> instClass, String msg)\n-    {\n-        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from number value (\"+_valueDesc()+\"): \"+msg);\n-    }\n-\n-    /**\n-     * Helper method for constructing exception to indicate that given JSON\n-     * Object field name was not in format to be able to deserialize specified\n-     * key type.\n-     */\n-    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)\n-    {\n-        return JsonMappingException.from(_parser, \"Can not construct Map key of type \"+keyClass.getName()+\" from String \\\"\"+_desc(keyValue)+\"\\\": \"+msg);\n-    }\n-\n-    /**\n-     * Helper method for indicating that the current token was expected to be another\n-     * token.\n-     */\n-    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg)\n-    {\n-        return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n-    }\n-    \n-    /**\n-     * Helper method for constructing exception to indicate that JSON Object\n-     * field name did not map to a known property of type being\n-     * deserialized.\n+     * Helper method for reporting a problem with unhandled unknown exception\n      * \n      * @param instanceOrClass Either value being populated (if one has been\n      *   instantiated), or Class that indicates type that would be (or\n      *   have been) instantiated\n      */\n-    public JsonMappingException unknownFieldException(Object instanceOrClass, String fieldName)\n-    {\n-        return UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName);\n+    public void reportUnknownProperty(Object instanceOrClass, String fieldName)\n+        throws JsonMappingException\n+    {\n+        if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+            throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for constructing exceptions\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method for constructing generic mapping exception for specified type\n+     */\n+    public JsonMappingException mappingException(Class<?> targetClass) {\n+        return mappingException(targetClass, _parser.getCurrentToken());\n+    }\n+\n+    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)\n+    {\n+        String clsName = _calcName(targetClass);\n+        return JsonMappingException.from(_parser,\n+                \"Can not deserialize instance of \"+clsName+\" out of \"+token+\" token\");\n+    }\n+    \n+    /**\n+     * Helper method for constructing generic mapping exception with specified\n+     * message and current location information\n+     */\n+    public JsonMappingException mappingException(String message) {\n+        return JsonMappingException.from(getParser(), message);\n+    }\n+    \n+    /**\n+     * Helper method for constructing instantiation exception for specified type,\n+     * to indicate problem with physically constructing instance of\n+     * specified class (missing constructor, exception from constructor)\n+     */\n+    public JsonMappingException instantiationException(Class<?> instClass, Throwable t)\n+    {\n+        return JsonMappingException.from(_parser,\n+                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(),\n+                t);\n+    }\n+\n+    public JsonMappingException instantiationException(Class<?> instClass, String msg) {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\", problem: \"+msg);\n+    }\n+    \n+    /**\n+     * Method that will construct an exception suitable for throwing when\n+     * some String values are acceptable, but the one encountered is not.\n+     */\n+    public JsonMappingException weirdStringException(Class<?> instClass, String msg) {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from String value '\"+_valueDesc()+\"': \"+msg);\n+    }\n+\n+    /**\n+     * Helper method for constructing exception to indicate that input JSON\n+     * Number was not suitable for deserializing into given type.\n+     */\n+    public JsonMappingException weirdNumberException(Class<?> instClass, String msg) {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from number value (\"+_valueDesc()+\"): \"+msg);\n+    }\n+\n+    /**\n+     * Helper method for constructing exception to indicate that given JSON\n+     * Object field name was not in format to be able to deserialize specified\n+     * key type.\n+     */\n+    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct Map key of type \"+keyClass.getName()+\" from String \\\"\"+_desc(keyValue)+\"\\\": \"+msg);\n+    }\n+\n+    /**\n+     * Helper method for indicating that the current token was expected to be another\n+     * token.\n+     */\n+    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg)\n+    {\n+        return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonDeserialize.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonDeserialize.java\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonDeserialize\n {\n-    // // // Annotations for explicitly specifying deserializer\n+    // // // Annotations for explicitly specifying deserialize/builder\n \n     /**\n      * Deserializer class to use for deserializing associated value.\n     public Class<? extends KeyDeserializer> keyUsing()\n         default KeyDeserializer.None.class;\n \n+    /**\n+     * Annotation for specifying if an external Builder class is to\n+     * be used for building up deserialized instances of annotated\n+     * class. If so, an instance of referenced class is first constructed\n+     * (possibly using a Creator method; or if none defined, using default\n+     * constructor), and its \"with-methods\" are used for populating fields;\n+     * and finally \"build-method\" is invoked to complete deserialization.\n+     */\n+    public Class<?> builder()\n+        default NoClass.class;\n+    \n     // // // Annotations for explicitly specifying deserialization type\n     // // // (which is used for choosing deserializer, if not explicitly\n     // // // specified\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonPOJOBuilder.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Annotation used to configure details of a Builder class:\n+ * instances of which are used as Builders for deserialized\n+ * POJO values, instead of POJOs being instantiated using\n+ * constructors or factory methods.\n+ * Note that this annotation is NOT used to define what is\n+ * the Builder class for a POJO: rather, this is determined\n+ * by {@link JsonDeserialize#builder} property of {@link JsonDeserialize}.\n+ *<p>\n+ * Annotation is typically used if the naming convention\n+ * of a Builder class is different from defaults:\n+ *<ul>\n+ * </ul>\n+ * \n+ * @since 2.0\n+ */\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonPOJOBuilder\n+{\n+\t/**\n+\t * Property to use for re-defining which zero-argument method\n+\t * is considered the actual \"build-method\": method called after\n+\t * all data has been bound, and the actual instance needs to\n+\t * be instantiated.\n+\t *<p>\n+\t * Default value is \"build\".\n+\t */\n+\tpublic String buildMethodName() default \"build\";\n+\n+\t/**\n+\t * Property used for (re)defining name prefix to use for\n+\t * auto-detecting \"with-methods\": methods that are similar to\n+\t * \"set-methods\" (in that they take an argument), but that\n+\t * may also return the new builder instance to use\n+\t * (which may be 'this', or a new modified builder instance).\n+\t * Note that in addition to this prefix, it is also possible\n+\t * to use {@link com.fasterxml.jackson.annotation.JsonProperty}\n+\t * annotation to indicate \"with-methods\" (as well as\n+\t * {@link com.fasterxml.jackson.annotation.JsonSetter}).\n+\t *<p>\n+\t * Default value is \"with\", so that method named \"withValue()\"\n+\t * would be used for binding JSON property \"value\" (using type\n+\t * indicated by the argument; or one defined with annotations.\n+\t */\n+\tpublic String withPrefix() default \"with\";\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\t\n+\t/**\n+\t * Simple value container for containing values read from\n+\t * {@link JsonPOJOBuilder} annotation instance.\n+\t */\n+\tpublic class Value\n+\t{\n+        public final String buildMethodName;\n+\t    public final String withPrefix;\n+\n+\t    public Value(JsonPOJOBuilder ann)\n+\t    {\n+\t        buildMethodName = ann.buildMethodName();\n+\t        withPrefix = ann.withPrefix();\n+\t    }\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n-import java.lang.reflect.*;\n import java.util.*;\n-\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n-import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.ClassKey;\n-import com.fasterxml.jackson.databind.util.Annotations;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n  * but possibly also from simple types like String values.\n  */\n public class BeanDeserializer\n-    extends StdDeserializer<Object>\n-    implements ContextualDeserializer, ResolvableDeserializer\n+    extends BeanDeserializerBase\n {\n-    /*\n-    /**********************************************************\n-    /* Information regarding type being deserialized\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Annotations from the bean class: used for accessing\n-     * annotations during resolution phase (see {@link #resolve}).\n-     */\n-    final protected Annotations _classAnnotations;\n-    \n-    /**\n-     * Declared type of the bean this deserializer handles.\n-     */\n-    final protected JavaType _beanType;\n-    \n-    /*\n-    /**********************************************************\n-    /* Configuration for creating value instance\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Object that handles details of constructing initial \n-     * bean value (to which bind data to), unless instance\n-     * is passed (via updateValue())\n-     */\n-    protected final ValueInstantiator _valueInstantiator;\n-    \n-    /**\n-     * Deserializer that is used iff delegate-based creator is\n-     * to be used for deserializing from JSON Object.\n-     */\n-    protected JsonDeserializer<Object> _delegateDeserializer;\n-    \n-    /**\n-     * If the bean needs to be instantiated using constructor\n-     * or factory method\n-     * that takes one or more named properties as argument(s),\n-     * this creator is used for instantiation.\n-     * This value gets resolved during general resolution.\n-     */\n-    protected PropertyBasedCreator _propertyBasedCreator;\n-\n-    /**\n-     * Flag that is set to mark \"non-standard\" cases; where either\n-     * we use one of non-default creators, or there are unwrapped\n-     * values to consider.\n-     */\n-    protected boolean _nonStandardCreation;\n-\n-    /**\n-     * Flag that indicates that no \"special features\" whatsoever\n-     * are enabled, so the simplest processing is possible.\n-     */\n-    protected boolean _vanillaProcessing;\n-    \n-    /*\n-    /**********************************************************\n-    /* Property information, setters\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Mapping of property names to properties, built when all properties\n-     * to use have been successfully resolved.\n-     */\n-    final protected BeanPropertyMap _beanProperties;\n-\n-    /**\n-     * List of {@link ValueInjector}s, if any injectable values are\n-     * expected by the bean; otherwise null.\n-     * This includes injectors used for injecting values via setters\n-     * and fields, but not ones passed through constructor parameters.\n-     */\n-    final protected ValueInjector[] _injectables;\n-    \n-    /**\n-     * Fallback setter used for handling any properties that are not\n-     * mapped to regular setters. If setter is not null, it will be\n-     * called once for each such property.\n-     */\n-    protected SettableAnyProperty _anySetter;\n-\n-    /**\n-     * In addition to properties that are set, we will also keep\n-     * track of recognized but ignorable properties: these will\n-     * be skipped without errors or warnings.\n-     */\n-    final protected HashSet<String> _ignorableProps;\n-\n-    /**\n-     * Flag that can be set to ignore and skip unknown properties.\n-     * If set, will not throw an exception for unknown properties.\n-     */\n-    final protected boolean _ignoreAllUnknown;\n-\n-    /**\n-     * Flag that indicates that some aspect of deserialization depends\n-     * on active view used (if any)\n-     */\n-    final protected boolean _needViewProcesing;\n-    \n-    /**\n-     * We may also have one or more back reference fields (usually\n-     * zero or one).\n-     */\n-    final protected Map<String, SettableBeanProperty> _backRefs;\n-    \n-    /*\n-    /**********************************************************\n-    /* Related handlers\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Lazily constructed map used to contain deserializers needed\n-     * for polymorphic subtypes.\n-     * Note that this is <b>only needed</b> for polymorphic types,\n-     * that is, when the actual type is not statically known.\n-     * For other types this remains null.\n-     */\n-    protected HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n-\n-    /**\n-     * If one of properties has \"unwrapped\" value, we need separate\n-     * helper object\n-     */\n-    protected UnwrappedPropertyHandler _unwrappedPropertyHandler;\n-\n-    /**\n-     * Handler that we need iff any of properties uses external\n-     * type id.\n-     */\n-    protected ExternalTypeHandler _externalTypeIdHandler;\n-\n-    /**\n-     * If an Object Id is to be used for value handled by this\n-     * deserializer, this reader is used for handling.\n-     */\n-    protected final ObjectIdReader _objectIdReader;\n-    \n     /*\n     /**********************************************************\n     /* Life-cycle, construction, initialization\n             HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n             boolean hasViews)\n     {\n-        super(beanDesc.getType());\n-        AnnotatedClass ac = beanDesc.getClassInfo();\n-        _classAnnotations = ac.getAnnotations();       \n-        \n-        _beanType = beanDesc.getType();\n-\n-        _valueInstantiator = builder.getValueInstantiator();\n-        \n-        _beanProperties = properties;\n-        _backRefs = backRefs;\n-        _ignorableProps = ignorableProps;\n-        _ignoreAllUnknown = ignoreAllUnknown;\n-\n-        _anySetter = builder.getAnySetter();\n-        List<ValueInjector> injectables = builder.getInjectables();\n-        _injectables = (injectables == null || injectables.isEmpty()) ? null\n-                : injectables.toArray(new ValueInjector[injectables.size()]);\n-        _objectIdReader = builder.getObjectIdReader();\n-        \n-        _nonStandardCreation = (_unwrappedPropertyHandler != null)\n-            || _valueInstantiator.canCreateUsingDelegate()\n-            || _valueInstantiator.canCreateFromObjectWith()\n-            || !_valueInstantiator.canCreateUsingDefault()\n-            ;\n-\n-        _needViewProcesing = hasViews;    \n-\n-        _vanillaProcessing = !_nonStandardCreation\n-                && (_injectables == null)\n-                && !_needViewProcesing\n-                ;\n+        super(builder, beanDesc, properties, backRefs,\n+        \t\tignorableProps, ignoreAllUnknown, hasViews);\n     }\n \n     /**\n      * Copy-constructor that can be used by sub-classes to allow\n      * copy-on-write styling copying of settings of an existing instance.\n      */\n-    protected BeanDeserializer(BeanDeserializer src)\n-    {\n-        this(src, src._ignoreAllUnknown);\n-    }\n-\n-    protected BeanDeserializer(BeanDeserializer src, boolean ignoreAllUnknown)\n-    {\n-        super(src._beanType);\n-        \n-        _classAnnotations = src._classAnnotations;\n-        _beanType = src._beanType;\n-        \n-        _valueInstantiator = src._valueInstantiator;\n-        _delegateDeserializer = src._delegateDeserializer;\n-        _propertyBasedCreator = src._propertyBasedCreator;\n-        \n-        _beanProperties = src._beanProperties;\n-        _backRefs = src._backRefs;\n-        _ignorableProps = src._ignorableProps;\n-        _ignoreAllUnknown = ignoreAllUnknown;\n-        _anySetter = src._anySetter;\n-        _injectables = src._injectables;\n-        _objectIdReader = src._objectIdReader;\n-        \n-        _nonStandardCreation = src._nonStandardCreation;\n-        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n-        _needViewProcesing = src._needViewProcesing;\n-\n-        _vanillaProcessing = src._vanillaProcessing;\n+    protected BeanDeserializer(BeanDeserializer src) {\n+    \tsuper(src, src._ignoreAllUnknown);\n+    }\n+\n+    protected BeanDeserializer(BeanDeserializer src, boolean ignoreAllUnknown) {\n+        super(src, ignoreAllUnknown);\n     }\n     \n-    protected BeanDeserializer(BeanDeserializer src, NameTransformer unwrapper)\n-    {\n-        super(src._beanType);\n-    \n-        _classAnnotations = src._classAnnotations;\n-        _beanType = src._beanType;\n-        \n-        _valueInstantiator = src._valueInstantiator;\n-        _delegateDeserializer = src._delegateDeserializer;\n-        _propertyBasedCreator = src._propertyBasedCreator;\n-        \n-        _backRefs = src._backRefs;\n-        _ignorableProps = src._ignorableProps;\n-        _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown;\n-        _anySetter = src._anySetter;\n-        _injectables = src._injectables;\n-        _objectIdReader = src._objectIdReader;\n-\n-        _nonStandardCreation = src._nonStandardCreation;\n-        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n-\n-        if (unwrapper != null) {\n-            // delegate further unwraps, if any\n-            if (_unwrappedPropertyHandler != null) { // got handler, delegate\n-                _unwrappedPropertyHandler.renameAll(unwrapper);\n-            }\n-            // and handle direct unwrapping as well:\n-            _beanProperties = src._beanProperties.renameAll(unwrapper);\n-        } else {\n-            _beanProperties = src._beanProperties;\n-        }\n-        _needViewProcesing = src._needViewProcesing;\n-        // probably adds a twist, so:\n-        _vanillaProcessing = false;        \n-    }\n-\n-    public BeanDeserializer(BeanDeserializer src, ObjectIdReader oir)\n-    {\n-        super(src._beanType);\n-        \n-        _classAnnotations = src._classAnnotations;\n-        _beanType = src._beanType;\n-        \n-        _valueInstantiator = src._valueInstantiator;\n-        _delegateDeserializer = src._delegateDeserializer;\n-        _propertyBasedCreator = src._propertyBasedCreator;\n-        \n-        _backRefs = src._backRefs;\n-        _ignorableProps = src._ignorableProps;\n-        _ignoreAllUnknown = src._ignoreAllUnknown;\n-        _anySetter = src._anySetter;\n-        _injectables = src._injectables;\n-        \n-        _nonStandardCreation = src._nonStandardCreation;\n-        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n-        _needViewProcesing = src._needViewProcesing;\n-\n-        _vanillaProcessing = src._vanillaProcessing;\n-\n-        // then actual changes:\n-        _objectIdReader = oir;\n-\n-        if (oir == null) {\n-            _beanProperties = src._beanProperties;\n-        } else {\n-            _beanProperties = src._beanProperties.withProperty(new ObjectIdProperty(oir));\n-        }\n+    protected BeanDeserializer(BeanDeserializer src, NameTransformer unwrapper) {\n+    \tsuper(src, unwrapper);\n+    }\n+\n+    public BeanDeserializer(BeanDeserializer src, ObjectIdReader oir) {\n+    \tsuper(src, oir);\n     }\n     \n     @Override\n \n     public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n         return new BeanDeserializer(this, oir);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public accessors\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Because of costs associated with constructing bean deserializers,\n-     * they usually should be cached unlike other deserializer types.\n-     */\n-    @Override\n-    public boolean isCachable() { return true; }\n-    \n-    public boolean hasProperty(String propertyName) {\n-        return _beanProperties.find(propertyName) != null;\n-    }\n-\n-    public boolean hasViews() {\n-        return _needViewProcesing;\n-    }\n-    \n-    /**\n-     * Accessor for checking number of deserialized properties.\n-     */\n-    public int getPropertyCount() { \n-        return _beanProperties.size();\n-    }\n-\n-    public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n-\n-    @Override public JavaType getValueType() { return _beanType; }\n-\n-    /**\n-     * Accessor for iterating over properties this deserializer uses; with\n-     * the exception that properties passed via Creator methods\n-     * (specifically, \"property-based constructor\") are not included,\n-     * but can be accessed separate by calling\n-     * {@link #creatorProperties}\n-     */\n-    public Iterator<SettableBeanProperty> properties()\n-    {\n-        if (_beanProperties == null) {\n-            throw new IllegalStateException(\"Can only call after BeanDeserializer has been resolved\");\n-        }\n-        return _beanProperties.allProperties();\n-    }\n-\n-    /**\n-     * Accessor for finding properties that represents values to pass\n-     * through property-based creator method (constructor or\n-     * factory method)\n-     * \n-     * @since 2.0\n-     */\n-    public Iterator<SettableBeanProperty> creatorProperties()\n-    {\n-        if (_propertyBasedCreator == null) {\n-            return Collections.<SettableBeanProperty>emptyList().iterator();\n-        }\n-        return _propertyBasedCreator.properties().iterator();\n-    }\n-\n-    /**\n-     * Accessor for finding the property with given name, if POJO\n-     * has one. Name used is the external name, i.e. name used\n-     * in external data representation (JSON).\n-     * \n-     * @since 2.0\n-     */\n-    public SettableBeanProperty findProperty(String propertyName)\n-    {\n-        SettableBeanProperty prop = (_beanProperties == null) ?\n-                null : _beanProperties.find(propertyName);\n-        if (prop == null && _propertyBasedCreator != null) {\n-            prop = _propertyBasedCreator.findCreatorProperty(propertyName);\n-        }\n-        return prop;\n-    }\n-    \n-    /**\n-     * Method needed by {@link BeanDeserializerFactory} to properly link\n-     * managed- and back-reference pairs.\n-     */\n-    public SettableBeanProperty findBackReference(String logicalName)\n-    {\n-        if (_backRefs == null) {\n-            return null;\n-        }\n-        return _backRefs.get(logicalName);\n-    }\n-\n-    public ValueInstantiator getValueInstantiator() {\n-        return _valueInstantiator;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Validation, post-processing\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method called to finalize setup of this deserializer,\n-     * after deserializer itself has been registered.\n-     * This is needed to handle recursive and transitive dependencies.\n-     */\n-    @Override\n-    public void resolve(DeserializationContext ctxt)\n-        throws JsonMappingException\n-    {\n-        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n-        if (_valueInstantiator.canCreateFromObjectWith()) {\n-            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n-            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n-        }\n-\n-        Iterator<SettableBeanProperty> it = _beanProperties.allProperties();\n-        UnwrappedPropertyHandler unwrapped = null;\n-        ExternalTypeHandler.Builder extTypes = null;\n-        \n-        while (it.hasNext()) {\n-            SettableBeanProperty origProp = it.next();\n-            SettableBeanProperty prop = origProp;\n-            // May already have deserializer from annotations, if so, skip:\n-            if (!prop.hasValueDeserializer()) {\n-                prop = prop.withValueDeserializer(findDeserializer(ctxt, prop.getType(), prop));\n-            } else { // may need contextual version\n-                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n-                if (deser instanceof ContextualDeserializer) {\n-                    JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop);\n-                    if (cd != deser) {\n-                        prop = prop.withValueDeserializer(cd);\n-                    }\n-                }\n-            }\n-            // [JACKSON-235]: need to link managed references with matching back references\n-            prop = _resolveManagedReferenceProperty(ctxt, prop);\n-            // [JACKSON-132]: support unwrapped values (via @JsonUnwrapped)\n-            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n-            if (u != null) {\n-                prop = u;\n-                if (unwrapped == null) {\n-                    unwrapped = new UnwrappedPropertyHandler();\n-                }\n-                unwrapped.addProperty(prop);\n-                continue;\n-            }\n-            // [JACKSON-594]: non-static inner classes too:\n-            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n-            if (prop != origProp) {\n-                _beanProperties.replace(prop);\n-            }\n-            \n-            /* one more thing: if this property uses \"external property\" type inclusion\n-             * (see [JACKSON-453]), it needs different handling altogether\n-             */\n-            if (prop.hasValueTypeDeserializer()) {\n-                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n-                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n-                    if (extTypes == null) {\n-                        extTypes = new ExternalTypeHandler.Builder();\n-                    }\n-                    extTypes.addExternal(prop, typeDeser.getPropertyName());\n-                    // In fact, remove from list of known properties to simplify later handling\n-                    _beanProperties.remove(prop);\n-                }\n-            }\n-        }\n-\n-        // \"any setter\" may also need to be resolved now\n-        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n-            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n-                    _anySetter.getType(), _anySetter.getProperty()));\n-        }\n-\n-        // as well as delegate-based constructor:\n-        if (_valueInstantiator.canCreateUsingDelegate()) {\n-            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n-            if (delegateType == null) {\n-                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n-                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n-                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n-            }\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n-            // Need to create a temporary property to allow contextual deserializers:\n-            BeanProperty.Std property = new BeanProperty.Std(null,\n-                    delegateType, _classAnnotations, delegateCreator);\n-            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n-        }\n-        \n-        if (extTypes != null) {\n-            _externalTypeIdHandler = extTypes.build();\n-            // we consider this non-standard, to offline handling\n-            _nonStandardCreation = true;\n-        }\n-        \n-        _unwrappedPropertyHandler = unwrapped;\n-        if (unwrapped != null) { // we consider this non-standard, to offline handling\n-            _nonStandardCreation = true;\n-        }\n-\n-        // may need to disable vanilla processing, if unwrapped handling was enabled...\n-        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n-    }\n-\n-    /**\n-     * Although most of post-processing is done in resolve(), we only get\n-     * access to referring property's annotations here; and this is needed\n-     * to support per-property ObjectIds.\n-     */\n-    @Override\n-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-            BeanProperty property) throws JsonMappingException\n-    {\n-        ObjectIdReader oir = _objectIdReader;\n-        \n-        // First: may have an override for Object Id:\n-        if (property != null) {\n-            final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-            final AnnotatedMember accessor = property.getMember();\n-            final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n-            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n-                ObjectIdGenerator<?> idGen;\n-                Class<?> implClass = objectIdInfo.getGeneratorType();\n-                JavaType type = ctxt.constructType(implClass);\n-                JavaType idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n-                // Property-based generator is trickier\n-                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n-                    // !!! TODO\n-                    idGen = null;\n-                    if (true) throw new IllegalStateException(\"Not yet implemented!\");\n-                } else { // other types need to be simpler\n-                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n-                }\n-                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n-                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser);\n-            }\n-        }\n-        // either way, need to resolve serializer:\n-        if (oir != null && oir != _objectIdReader) {\n-            return withObjectIdReader(oir);\n-        }\n-        return this;\n-    }\n-    \n-    /**\n-     * Helper method called to see if given property is part of 'managed' property\n-     * pair (managed + back reference), and if so, handle resolution details.\n-     */\n-    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt,\n-            SettableBeanProperty prop)\n-    {\n-        String refName = prop.getManagedReferenceName();\n-        if (refName == null) {\n-            return prop;\n-        }\n-        JsonDeserializer<?> valueDeser = prop.getValueDeserializer();\n-        SettableBeanProperty backProp = null;\n-        boolean isContainer = false;\n-        if (valueDeser instanceof BeanDeserializer) {\n-            backProp = ((BeanDeserializer) valueDeser).findBackReference(refName);\n-        } else if (valueDeser instanceof ContainerDeserializerBase<?>) {\n-            JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer();\n-            if (!(contentDeser instanceof BeanDeserializer)) {\n-                String deserName = (contentDeser == null) ? \"NULL\" : contentDeser.getClass().getName();\n-                throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n-                        +\"': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer \"\n-                        +\" (instead it's of type \"+deserName+\")\");\n-            }\n-            backProp = ((BeanDeserializer) contentDeser).findBackReference(refName);\n-            isContainer = true;\n-        } else if (valueDeser instanceof AbstractDeserializer) { // [JACKSON-368]: not easy to fix, alas  \n-            throw new IllegalArgumentException(\"Can not handle managed/back reference for abstract types (property \"+_beanType.getRawClass().getName()+\".\"+prop.getName()+\")\");\n-        } else {\n-            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n-                    +\"': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but \"\n-                    +valueDeser.getClass().getName());\n-        }\n-        if (backProp == null) {\n-            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': no back reference property found from type \"\n-                    +prop.getType());\n-        }\n-        // also: verify that type is compatible\n-        JavaType referredType = _beanType;\n-        JavaType backRefType = backProp.getType();\n-        if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {\n-            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': back reference type (\"\n-                    +backRefType.getRawClass().getName()+\") not compatible with managed type (\"\n-                    +referredType.getRawClass().getName()+\")\");\n-        }\n-        return new ManagedReferenceProperty(refName, prop, backProp,\n-                _classAnnotations, isContainer);\n-    }\n-\n-    /**\n-     * Helper method called to see if given property might be so-called unwrapped\n-     * property: these require special handling.\n-     */\n-    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt,\n-            SettableBeanProperty prop)\n-    {\n-        AnnotatedMember am = prop.getMember();\n-        if (am != null) {\n-            NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n-            if (unwrapper != null) {\n-                JsonDeserializer<Object> orig = prop.getValueDeserializer();\n-                JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper);\n-                if (unwrapping != orig && unwrapping != null) {\n-                    // might be cleaner to create new instance; but difficult to do reliably, so:\n-                    return prop.withValueDeserializer(unwrapping);\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /**\n-     * Helper method that will handle gruesome details of dealing with properties\n-     * that have non-static inner class as value...\n-     */\n-    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt,\n-            SettableBeanProperty prop)\n-    {            \n-        /* Should we encounter a property that has non-static inner-class\n-         * as value, we need to add some more magic to find the \"hidden\" constructor...\n-         */\n-        JsonDeserializer<Object> deser = prop.getValueDeserializer();\n-        // ideally wouldn't rely on it being BeanDeserializer; but for now it'll have to do\n-        if (deser instanceof BeanDeserializer) {\n-            BeanDeserializer bd = (BeanDeserializer) deser;\n-            ValueInstantiator vi = bd.getValueInstantiator();\n-            if (!vi.canCreateUsingDefault()) { // no default constructor\n-                Class<?> valueClass = prop.getType().getRawClass();\n-                Class<?> enclosing = ClassUtil.getOuterClass(valueClass);\n-                // and is inner class of the bean class...\n-                if (enclosing != null && enclosing == _beanType.getRawClass()) {\n-                    for (Constructor<?> ctor : valueClass.getConstructors()) {\n-                        Class<?>[] paramTypes = ctor.getParameterTypes();\n-                        if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n-                            if (ctxt.getConfig().canOverrideAccessModifiers()) {\n-                                ClassUtil.checkAndFixAccess(ctor);\n-                            }\n-                            return new InnerClassProperty(prop, ctor);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return prop;\n     }\n \n     /*\n         }\n         return bean;\n     }\n-\n-    @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n-        // In future could check current token... for now this should be enough:\n-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n-    }\n     \n     /*\n     /**********************************************************\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt,\n-            JsonToken t)\n+    private final Object vanillaDeserialize(JsonParser jp,\n+    \t\tDeserializationContext ctxt, JsonToken t)\n         throws IOException, JsonProcessingException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n             bean = deserialize(jp, ctxt, bean);\n         }\n         return bean;\n-    }\n-\n-    /**\n-     * Method called in cases where it looks like we got an Object Id\n-     * to parse and use as a reference.\n-     */\n-    protected Object deserializeUsingObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        Object id = _objectIdReader.deserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n-        // do we have it resolved?\n-        Object pojo = roid.item;\n-        if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"]\");\n-        }\n-        return pojo;\n     }\n     \n     /*\n         }\n         return ext.complete(jp, ctxt, bean);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Overridable helper methods\n-    /**********************************************************\n-     */\n-\n-    protected void injectValues(DeserializationContext ctxt, Object bean)\n-            throws IOException, JsonProcessingException\n-    {\n-        for (ValueInjector injector : _injectables) {\n-            injector.inject(ctxt, bean);\n-        }\n-    }\n-    \n-    /**\n-     * Method called when a JSON property is encountered that has not matching\n-     * setter, any-setter or field, and thus can not be assigned.\n-     */\n-    @Override\n-    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName)\n-        throws IOException, JsonProcessingException\n-    {\n-        /* 22-Aug-2010, tatu: Caller now mostly checks for ignorable properties, so\n-         *    following should not be necessary. However, \"handleUnknownProperties()\" seems\n-         *    to still possibly need it so it is left for now.\n-         */\n-        // If registered as ignorable, skip\n-        if (_ignoreAllUnknown ||\n-            (_ignorableProps != null && _ignorableProps.contains(propName))) {\n-            jp.skipChildren();\n-            return;\n-        }\n-        /* Otherwise use default handling (call handler(s); if not\n-         * handled, throw exception or skip depending on settings)\n-         */\n-        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);\n-    }\n-\n-    /**\n-     * Method called to handle set of one or more unknown properties,\n-     * stored in their entirety in given {@link TokenBuffer}\n-     * (as field entries, name and value).\n-     */\n-    protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n-        throws IOException, JsonProcessingException\n-    {\n-        // First: add closing END_OBJECT as marker\n-        unknownTokens.writeEndObject();\n-        \n-        // note: buffer does NOT have starting START_OBJECT\n-        JsonParser bufferParser = unknownTokens.asParser();\n-        while (bufferParser.nextToken() != JsonToken.END_OBJECT) {\n-            String propName = bufferParser.getCurrentName();\n-            // Unknown: let's call handler method\n-            bufferParser.nextToken();\n-            handleUnknownProperty(bufferParser, ctxt, bean, propName);\n-        }\n-        return bean;\n-    }\n-    \n-    /**\n-     * Helper method called to (try to) locate deserializer for given sub-type of\n-     * type that this deserializer handles.\n-     */\n-    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,\n-            Object bean, TokenBuffer unknownTokens)\n-        throws IOException, JsonProcessingException\n-    {  \n-        JsonDeserializer<Object> subDeser;\n-\n-        // First: maybe we have already created sub-type deserializer?\n-        synchronized (this) {\n-            subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass()));\n-        }\n-        if (subDeser != null) {\n-            return subDeser;\n-        }\n-        // If not, maybe we can locate one. First, need provider\n-        JavaType type = ctxt.constructType(bean.getClass());\n-        /* 30-Jan-2012, tatu: Ideally we would be passing referring\n-         *   property; which in theory we could keep track of via\n-         *   ResolvableDeserializer (if we absolutely must...).\n-         *   But for now, let's not bother.\n-         */\n-//        subDeser = ctxt.findValueDeserializer(type, _property);\n-        subDeser = ctxt.findRootValueDeserializer(type);\n-        // Also, need to cache it\n-        if (subDeser != null) {\n-            synchronized (this) {\n-                if (_subDeserializers == null) {\n-                    _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n-                }\n-                _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n-            }            \n-        }\n-        return subDeser;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods for error reporting\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method that will modify caught exception (passed in as argument)\n-     * as necessary to include reference information, and to ensure it\n-     * is a subtype of {@link IOException}, or an unchecked exception.\n-     *<p>\n-     * Rules for wrapping and unwrapping are bit complicated; essentially:\n-     *<ul>\n-     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n-     * <li>\"Plain\" IOExceptions (ones that are not of type\n-     *   {@link JsonMappingException} are to be passed as is\n-     *</ul>\n-     */\n-    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n-            DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n-         *   StackOverflow: usually due to infinite loop. But that\n-         *   usually gets hidden within an InvocationTargetException...\n-         */\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n-        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n-        if (t instanceof IOException) {\n-            if (!wrap || !(t instanceof JsonMappingException)) {\n-                throw (IOException) t;\n-            }\n-        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n-            if (t instanceof RuntimeException) {\n-                throw (RuntimeException) t;\n-            }\n-        }\n-        // [JACKSON-55] Need to add reference information\n-        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n-    }\n-\n-    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n-        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n-        if (t instanceof IOException) {\n-            if (!wrap || !(t instanceof JsonMappingException)) {\n-                throw (IOException) t;\n-            }\n-        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n-            if (t instanceof RuntimeException) {\n-                throw (RuntimeException) t;\n-            }\n-        }\n-        // [JACKSON-55] Need to add reference information\n-        throw JsonMappingException.wrapWithPath(t, bean, index);\n-    }\n-\n-    protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n-        if (t instanceof IOException) {\n-            // Since we have no more information to add, let's not actually wrap..\n-            throw (IOException) t;\n-        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n-            if (t instanceof RuntimeException) {\n-                throw (RuntimeException) t;\n-            }\n-        }\n-        throw ctxt.instantiationException(_beanType.getRawClass(), t);\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.*;\n+import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Base class for <code>BeanDeserializer</code>.\n+ */\n+public abstract class BeanDeserializerBase\n+\textends StdDeserializer<Object>\n+\timplements ContextualDeserializer, ResolvableDeserializer\n+{\n+    /*\n+    /**********************************************************\n+    /* Information regarding type being deserialized\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Annotations from the bean class: used for accessing\n+     * annotations during resolution phase (see {@link #resolve}).\n+     */\n+    final protected Annotations _classAnnotations;\n+    \n+    /**\n+     * Declared type of the bean this deserializer handles.\n+     */\n+    final protected JavaType _beanType;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration for creating value instance\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object that handles details of constructing initial \n+     * bean value (to which bind data to), unless instance\n+     * is passed (via updateValue())\n+     */\n+    protected final ValueInstantiator _valueInstantiator;\n+    \n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n+    \n+    /**\n+     * If the bean needs to be instantiated using constructor\n+     * or factory method\n+     * that takes one or more named properties as argument(s),\n+     * this creator is used for instantiation.\n+     * This value gets resolved during general resolution.\n+     */\n+    protected PropertyBasedCreator _propertyBasedCreator;\n+\n+    /**\n+     * Flag that is set to mark \"non-standard\" cases; where either\n+     * we use one of non-default creators, or there are unwrapped\n+     * values to consider.\n+     */\n+    protected boolean _nonStandardCreation;\n+\n+    /**\n+     * Flag that indicates that no \"special features\" whatsoever\n+     * are enabled, so the simplest processing is possible.\n+     */\n+    protected boolean _vanillaProcessing;\n+\n+    /*\n+    /**********************************************************\n+    /* Property information, setters\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Mapping of property names to properties, built when all properties\n+     * to use have been successfully resolved.\n+     */\n+    final protected BeanPropertyMap _beanProperties;\n+\n+    /**\n+     * List of {@link ValueInjector}s, if any injectable values are\n+     * expected by the bean; otherwise null.\n+     * This includes injectors used for injecting values via setters\n+     * and fields, but not ones passed through constructor parameters.\n+     */\n+    final protected ValueInjector[] _injectables;\n+    \n+    /**\n+     * Fallback setter used for handling any properties that are not\n+     * mapped to regular setters. If setter is not null, it will be\n+     * called once for each such property.\n+     */\n+    protected SettableAnyProperty _anySetter;\n+\n+    /**\n+     * In addition to properties that are set, we will also keep\n+     * track of recognized but ignorable properties: these will\n+     * be skipped without errors or warnings.\n+     */\n+    final protected HashSet<String> _ignorableProps;\n+\n+    /**\n+     * Flag that can be set to ignore and skip unknown properties.\n+     * If set, will not throw an exception for unknown properties.\n+     */\n+    final protected boolean _ignoreAllUnknown;\n+\n+    /**\n+     * Flag that indicates that some aspect of deserialization depends\n+     * on active view used (if any)\n+     */\n+    final protected boolean _needViewProcesing;\n+    \n+    /**\n+     * We may also have one or more back reference fields (usually\n+     * zero or one).\n+     */\n+    final protected Map<String, SettableBeanProperty> _backRefs;\n+    \n+    /*\n+    /**********************************************************\n+    /* Related handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed map used to contain deserializers needed\n+     * for polymorphic subtypes.\n+     * Note that this is <b>only needed</b> for polymorphic types,\n+     * that is, when the actual type is not statically known.\n+     * For other types this remains null.\n+     */\n+    protected HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n+\n+    /**\n+     * If one of properties has \"unwrapped\" value, we need separate\n+     * helper object\n+     */\n+    protected UnwrappedPropertyHandler _unwrappedPropertyHandler;\n+\n+    /**\n+     * Handler that we need iff any of properties uses external\n+     * type id.\n+     */\n+    protected ExternalTypeHandler _externalTypeIdHandler;\n+\n+    /**\n+     * If an Object Id is to be used for value handled by this\n+     * deserializer, this reader is used for handling.\n+     */\n+    protected final ObjectIdReader _objectIdReader;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used when initially building a deserializer\n+     * instance, given a {@link BeanDeserializerBuilder} that\n+     * contains configuration.\n+     */\n+    protected BeanDeserializerBase(BeanDeserializerBuilder builder,\n+            BeanDescription beanDesc,\n+            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n+            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n+            boolean hasViews)\n+    {\n+        super(beanDesc.getType());\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        _classAnnotations = ac.getAnnotations();       \n+        \n+        _beanType = beanDesc.getType();\n+\n+        _valueInstantiator = builder.getValueInstantiator();\n+        \n+        _beanProperties = properties;\n+        _backRefs = backRefs;\n+        _ignorableProps = ignorableProps;\n+        _ignoreAllUnknown = ignoreAllUnknown;\n+\n+        _anySetter = builder.getAnySetter();\n+        List<ValueInjector> injectables = builder.getInjectables();\n+        _injectables = (injectables == null || injectables.isEmpty()) ? null\n+                : injectables.toArray(new ValueInjector[injectables.size()]);\n+        _objectIdReader = builder.getObjectIdReader();\n+        _nonStandardCreation = (_unwrappedPropertyHandler != null)\n+            || _valueInstantiator.canCreateUsingDelegate()\n+            || _valueInstantiator.canCreateFromObjectWith()\n+            || !_valueInstantiator.canCreateUsingDefault()\n+            ;\n+\n+        _needViewProcesing = hasViews;    \n+\n+        _vanillaProcessing = !_nonStandardCreation\n+                && (_injectables == null)\n+                && !_needViewProcesing\n+                ;\n+    }\n+\n+    protected BeanDeserializerBase(BeanDeserializerBase src)\n+    {\n+        this(src, src._ignoreAllUnknown);\n+    }\n+\n+    protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown)\n+    {\n+        super(src._beanType);\n+        \n+        _classAnnotations = src._classAnnotations;\n+        _beanType = src._beanType;\n+        \n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        \n+        _beanProperties = src._beanProperties;\n+        _backRefs = src._backRefs;\n+        _ignorableProps = src._ignorableProps;\n+        _ignoreAllUnknown = ignoreAllUnknown;\n+        _anySetter = src._anySetter;\n+        _injectables = src._injectables;\n+        _objectIdReader = src._objectIdReader;\n+        \n+        _nonStandardCreation = src._nonStandardCreation;\n+        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n+        _needViewProcesing = src._needViewProcesing;\n+\n+        _vanillaProcessing = src._vanillaProcessing;\n+    }\n+ \n+    protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper)\n+    {\n+        super(src._beanType);\n+\n+        _classAnnotations = src._classAnnotations;\n+        _beanType = src._beanType;\n+        \n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        \n+        _backRefs = src._backRefs;\n+        _ignorableProps = src._ignorableProps;\n+        _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown;\n+        _anySetter = src._anySetter;\n+        _injectables = src._injectables;\n+        _objectIdReader = src._objectIdReader;\n+\n+        _nonStandardCreation = src._nonStandardCreation;\n+        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n+\n+        if (unwrapper != null) {\n+            // delegate further unwraps, if any\n+            if (_unwrappedPropertyHandler != null) { // got handler, delegate\n+                _unwrappedPropertyHandler.renameAll(unwrapper);\n+            }\n+            // and handle direct unwrapping as well:\n+            _beanProperties = src._beanProperties.renameAll(unwrapper);\n+        } else {\n+            _beanProperties = src._beanProperties;\n+        }\n+        _needViewProcesing = src._needViewProcesing;\n+        // probably adds a twist, so:\n+        _vanillaProcessing = false;        \n+    }\n+\n+    public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir)\n+    {\n+        super(src._beanType);\n+        \n+        _classAnnotations = src._classAnnotations;\n+        _beanType = src._beanType;\n+        \n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        \n+        _backRefs = src._backRefs;\n+        _ignorableProps = src._ignorableProps;\n+        _ignoreAllUnknown = src._ignoreAllUnknown;\n+        _anySetter = src._anySetter;\n+        _injectables = src._injectables;\n+        \n+        _nonStandardCreation = src._nonStandardCreation;\n+        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n+        _needViewProcesing = src._needViewProcesing;\n+\n+        _vanillaProcessing = src._vanillaProcessing;\n+\n+        // then actual changes:\n+        _objectIdReader = oir;\n+\n+        if (oir == null) {\n+            _beanProperties = src._beanProperties;\n+        } else {\n+        \t_beanProperties = src._beanProperties.withProperty(new ObjectIdProperty(oir));\n+        }\n+    }\n+\n+    @Override\n+    public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n+\n+    public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir);\n+    \n+    /*\n+    /**********************************************************\n+    /* Public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isCachable() { return true; }\n+    \n+    public boolean hasProperty(String propertyName) {\n+        return _beanProperties.find(propertyName) != null;\n+    }\n+\n+    public boolean hasViews() {\n+        return _needViewProcesing;\n+    }\n+    \n+    /**\n+     * Accessor for checking number of deserialized properties.\n+     */\n+    public int getPropertyCount() { \n+        return _beanProperties.size();\n+    }\n+\n+    public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n+\n+    @Override public JavaType getValueType() { return _beanType; }\n+\n+    /**\n+     * Accessor for iterating over properties this deserializer uses; with\n+     * the exception that properties passed via Creator methods\n+     * (specifically, \"property-based constructor\") are not included,\n+     * but can be accessed separate by calling\n+     * {@link #creatorProperties}\n+     */\n+    public Iterator<SettableBeanProperty> properties()\n+    {\n+        if (_beanProperties == null) {\n+            throw new IllegalStateException(\"Can only call after BeanDeserializer has been resolved\");\n+        }\n+        return _beanProperties.allProperties();\n+    }\n+\n+    /**\n+     * Accessor for finding properties that represents values to pass\n+     * through property-based creator method (constructor or\n+     * factory method)\n+     * \n+     * @since 2.0\n+     */\n+    public Iterator<SettableBeanProperty> creatorProperties()\n+    {\n+        if (_propertyBasedCreator == null) {\n+            return Collections.<SettableBeanProperty>emptyList().iterator();\n+        }\n+        return _propertyBasedCreator.properties().iterator();\n+    }\n+\n+    /**\n+     * Accessor for finding the property with given name, if POJO\n+     * has one. Name used is the external name, i.e. name used\n+     * in external data representation (JSON).\n+     * \n+     * @since 2.0\n+     */\n+    public SettableBeanProperty findProperty(String propertyName)\n+    {\n+        SettableBeanProperty prop = (_beanProperties == null) ?\n+                null : _beanProperties.find(propertyName);\n+        if (prop == null && _propertyBasedCreator != null) {\n+            prop = _propertyBasedCreator.findCreatorProperty(propertyName);\n+        }\n+        return prop;\n+    }\n+    \n+    /**\n+     * Method needed by {@link BeanDeserializerFactory} to properly link\n+     * managed- and back-reference pairs.\n+     */\n+    public SettableBeanProperty findBackReference(String logicalName)\n+    {\n+        if (_backRefs == null) {\n+            return null;\n+        }\n+        return _backRefs.get(logicalName);\n+    }\n+\n+    public ValueInstantiator getValueInstantiator() {\n+        return _valueInstantiator;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * after deserializer itself has been registered.\n+     * This is needed to handle recursive and transitive dependencies.\n+     */\n+    @Override\n+    public void resolve(DeserializationContext ctxt)\n+        throws JsonMappingException\n+    {\n+        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n+        if (_valueInstantiator.canCreateFromObjectWith()) {\n+            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n+            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n+        }\n+\n+        Iterator<SettableBeanProperty> it = _beanProperties.allProperties();\n+        UnwrappedPropertyHandler unwrapped = null;\n+        ExternalTypeHandler.Builder extTypes = null;\n+        \n+        while (it.hasNext()) {\n+            SettableBeanProperty origProp = it.next();\n+            SettableBeanProperty prop = origProp;\n+            // May already have deserializer from annotations, if so, skip:\n+            if (!prop.hasValueDeserializer()) {\n+                prop = prop.withValueDeserializer(findDeserializer(ctxt, prop.getType(), prop));\n+            } else { // may need contextual version\n+                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n+                if (deser instanceof ContextualDeserializer) {\n+                    JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop);\n+                    if (cd != deser) {\n+                        prop = prop.withValueDeserializer(cd);\n+                    }\n+                }\n+            }\n+            // [JACKSON-235]: need to link managed references with matching back references\n+            prop = _resolveManagedReferenceProperty(ctxt, prop);\n+            // [JACKSON-132]: support unwrapped values (via @JsonUnwrapped)\n+            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n+            if (u != null) {\n+                prop = u;\n+                if (unwrapped == null) {\n+                    unwrapped = new UnwrappedPropertyHandler();\n+                }\n+                unwrapped.addProperty(prop);\n+                continue;\n+            }\n+            // [JACKSON-594]: non-static inner classes too:\n+            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n+            if (prop != origProp) {\n+                _beanProperties.replace(prop);\n+            }\n+            \n+            /* one more thing: if this property uses \"external property\" type inclusion\n+             * (see [JACKSON-453]), it needs different handling altogether\n+             */\n+            if (prop.hasValueTypeDeserializer()) {\n+                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n+                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+                    if (extTypes == null) {\n+                        extTypes = new ExternalTypeHandler.Builder();\n+                    }\n+                    extTypes.addExternal(prop, typeDeser.getPropertyName());\n+                    // In fact, remove from list of known properties to simplify later handling\n+                    _beanProperties.remove(prop);\n+                }\n+            }\n+        }\n+\n+        // \"any setter\" may also need to be resolved now\n+        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n+            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n+                    _anySetter.getType(), _anySetter.getProperty()));\n+        }\n+\n+        // as well as delegate-based constructor:\n+        if (_valueInstantiator.canCreateUsingDelegate()) {\n+            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n+            if (delegateType == null) {\n+                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n+                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n+                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n+            }\n+            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+            // Need to create a temporary property to allow contextual deserializers:\n+            BeanProperty.Std property = new BeanProperty.Std(null,\n+                    delegateType, _classAnnotations, delegateCreator);\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+        }\n+        \n+        if (extTypes != null) {\n+            _externalTypeIdHandler = extTypes.build();\n+            // we consider this non-standard, to offline handling\n+            _nonStandardCreation = true;\n+        }\n+        \n+        _unwrappedPropertyHandler = unwrapped;\n+        if (unwrapped != null) { // we consider this non-standard, to offline handling\n+            _nonStandardCreation = true;\n+        }\n+\n+        // may need to disable vanilla processing, if unwrapped handling was enabled...\n+        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n+    }\n+\n+    /**\n+     * Although most of post-processing is done in resolve(), we only get\n+     * access to referring property's annotations here; and this is needed\n+     * to support per-property ObjectIds.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        ObjectIdReader oir = _objectIdReader;\n+        \n+        // First: may have an override for Object Id:\n+        if (property != null) {\n+            final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+            final AnnotatedMember accessor = property.getMember();\n+            final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n+                Class<?> implClass = objectIdInfo.getGeneratorType();\n+                // Property-based generator is trickier\n+                JavaType idType;\n+                SettableBeanProperty idProp;\n+                ObjectIdGenerator<?> idGen;\n+                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                    String propName = objectIdInfo.getPropertyName();\n+                    idProp = findProperty(propName);\n+                \tif (idProp == null) {\n+                \t\tthrow new IllegalArgumentException(\"Invalid Object Id definition for \"\n+                \t\t\t\t+getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n+                \t}\n+                    idType = idProp.getType();\n+                    idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n+                } else { // other types need to be simpler\n+                    JavaType type = ctxt.constructType(implClass);\n+                    idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+                    idProp = null;\n+                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                }\n+                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n+                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n+                \t\tidGen, deser, idProp);\n+            }\n+        }\n+        // either way, need to resolve serializer:\n+        if (oir != null && oir != _objectIdReader) {\n+            return withObjectIdReader(oir);\n+        }\n+        return this;\n+    }\n+\n+    \n+    /**\n+     * Helper method called to see if given property is part of 'managed' property\n+     * pair (managed + back reference), and if so, handle resolution details.\n+     */\n+    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt,\n+            SettableBeanProperty prop)\n+    {\n+        String refName = prop.getManagedReferenceName();\n+        if (refName == null) {\n+            return prop;\n+        }\n+        JsonDeserializer<?> valueDeser = prop.getValueDeserializer();\n+        SettableBeanProperty backProp = null;\n+        boolean isContainer = false;\n+        if (valueDeser instanceof BeanDeserializerBase) {\n+            backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName);\n+        } else if (valueDeser instanceof ContainerDeserializerBase<?>) {\n+            JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer();\n+            if (!(contentDeser instanceof BeanDeserializerBase)) {\n+                String deserName = (contentDeser == null) ? \"NULL\" : contentDeser.getClass().getName();\n+                throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n+                        +\"': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer \"\n+                        +\" (instead it's of type \"+deserName+\")\");\n+            }\n+            backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName);\n+            isContainer = true;\n+        } else if (valueDeser instanceof AbstractDeserializer) { // [JACKSON-368]: not easy to fix, alas  \n+            throw new IllegalArgumentException(\"Can not handle managed/back reference for abstract types (property \"+_beanType.getRawClass().getName()+\".\"+prop.getName()+\")\");\n+        } else {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n+                    +\"': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but \"\n+                    +valueDeser.getClass().getName());\n+        }\n+        if (backProp == null) {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': no back reference property found from type \"\n+                    +prop.getType());\n+        }\n+        // also: verify that type is compatible\n+        JavaType referredType = _beanType;\n+        JavaType backRefType = backProp.getType();\n+        if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': back reference type (\"\n+                    +backRefType.getRawClass().getName()+\") not compatible with managed type (\"\n+                    +referredType.getRawClass().getName()+\")\");\n+        }\n+        return new ManagedReferenceProperty(prop, refName, backProp,\n+                _classAnnotations, isContainer);\n+    }\n+\n+    /**\n+     * Helper method called to see if given property might be so-called unwrapped\n+     * property: these require special handling.\n+     */\n+    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt,\n+            SettableBeanProperty prop)\n+    {\n+        AnnotatedMember am = prop.getMember();\n+        if (am != null) {\n+            NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n+            if (unwrapper != null) {\n+                JsonDeserializer<Object> orig = prop.getValueDeserializer();\n+                JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper);\n+                if (unwrapping != orig && unwrapping != null) {\n+                    // might be cleaner to create new instance; but difficult to do reliably, so:\n+                    return prop.withValueDeserializer(unwrapping);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method that will handle gruesome details of dealing with properties\n+     * that have non-static inner class as value...\n+     */\n+    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt,\n+            SettableBeanProperty prop)\n+    {            \n+        /* Should we encounter a property that has non-static inner-class\n+         * as value, we need to add some more magic to find the \"hidden\" constructor...\n+         */\n+        JsonDeserializer<Object> deser = prop.getValueDeserializer();\n+        // ideally wouldn't rely on it being BeanDeserializerBase; but for now it'll have to do\n+        if (deser instanceof BeanDeserializerBase) {\n+            BeanDeserializerBase bd = (BeanDeserializerBase) deser;\n+            ValueInstantiator vi = bd.getValueInstantiator();\n+            if (!vi.canCreateUsingDefault()) { // no default constructor\n+                Class<?> valueClass = prop.getType().getRawClass();\n+                Class<?> enclosing = ClassUtil.getOuterClass(valueClass);\n+                // and is inner class of the bean class...\n+                if (enclosing != null && enclosing == _beanType.getRawClass()) {\n+                    for (Constructor<?> ctor : valueClass.getConstructors()) {\n+                        Class<?>[] paramTypes = ctor.getParameterTypes();\n+                        if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n+                            if (ctxt.getConfig().canOverrideAccessModifiers()) {\n+                                ClassUtil.checkAndFixAccess(ctor);\n+                            }\n+                            return new InnerClassProperty(prop, ctor);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return prop;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Partial deserializer implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 16-Feb-2012, tatu: ObjectId may be used as well... need to check\n+         *    that first\n+         */\n+        if (_objectIdReader != null) {\n+            JsonToken t = jp.getCurrentToken();\n+            // should be good enough check; we only care about Strings, integral numbers:\n+            if (t != null && t.isScalarValue()) {\n+                return deserializeUsingObjectId(jp, ctxt);\n+            }\n+        }\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    /**\n+     * Method called in cases where it looks like we got an Object Id\n+     * to parse and use as a reference.\n+     */\n+    protected final Object deserializeUsingObjectId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        Object id = _objectIdReader.deserializer.deserialize(jp, ctxt);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        // do we have it resolved?\n+        Object pojo = roid.item;\n+        if (pojo == null) { // not yet; should wait...\n+            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"]\");\n+        }\n+        return pojo;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+\n+    protected void injectValues(DeserializationContext ctxt, Object bean)\n+            throws IOException, JsonProcessingException\n+    {\n+        for (ValueInjector injector : _injectables) {\n+            injector.inject(ctxt, bean);\n+        }\n+    }\n+    \n+    /**\n+     * Method called when a JSON property is encountered that has not matching\n+     * setter, any-setter or field, and thus can not be assigned.\n+     */\n+    @Override\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,\n+            Object beanOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 22-Aug-2010, tatu: Caller now mostly checks for ignorable properties, so\n+         *    following should not be necessary. However, \"handleUnknownProperties()\" seems\n+         *    to still possibly need it so it is left for now.\n+         */\n+        // If registered as ignorable, skip\n+        if (_ignoreAllUnknown ||\n+            (_ignorableProps != null && _ignorableProps.contains(propName))) {\n+            jp.skipChildren();\n+            return;\n+        }\n+        /* Otherwise use default handling (call handler(s); if not\n+         * handled, throw exception or skip depending on settings)\n+         */\n+        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);\n+    }\n+\n+    /**\n+     * Method called to handle set of one or more unknown properties,\n+     * stored in their entirety in given {@link TokenBuffer}\n+     * (as field entries, name and value).\n+     */\n+    protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First: add closing END_OBJECT as marker\n+        unknownTokens.writeEndObject();\n+        \n+        // note: buffer does NOT have starting START_OBJECT\n+        JsonParser bufferParser = unknownTokens.asParser();\n+        while (bufferParser.nextToken() != JsonToken.END_OBJECT) {\n+            String propName = bufferParser.getCurrentName();\n+            // Unknown: let's call handler method\n+            bufferParser.nextToken();\n+            handleUnknownProperty(bufferParser, ctxt, bean, propName);\n+        }\n+        return bean;\n+    }\n+    \n+    /**\n+     * Helper method called to (try to) locate deserializer for given sub-type of\n+     * type that this deserializer handles.\n+     */\n+    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,\n+            Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {  \n+        JsonDeserializer<Object> subDeser;\n+\n+        // First: maybe we have already created sub-type deserializer?\n+        synchronized (this) {\n+            subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass()));\n+        }\n+        if (subDeser != null) {\n+            return subDeser;\n+        }\n+        // If not, maybe we can locate one. First, need provider\n+        JavaType type = ctxt.constructType(bean.getClass());\n+        /* 30-Jan-2012, tatu: Ideally we would be passing referring\n+         *   property; which in theory we could keep track of via\n+         *   ResolvableDeserializer (if we absolutely must...).\n+         *   But for now, let's not bother.\n+         */\n+//        subDeser = ctxt.findValueDeserializer(type, _property);\n+        subDeser = ctxt.findRootValueDeserializer(type);\n+        // Also, need to cache it\n+        if (subDeser != null) {\n+            synchronized (this) {\n+                if (_subDeserializers == null) {\n+                    _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n+                }\n+                _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n+            }            \n+        }\n+        return subDeser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods for error reporting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will modify caught exception (passed in as argument)\n+     * as necessary to include reference information, and to ensure it\n+     * is a subtype of {@link IOException}, or an unchecked exception.\n+     *<p>\n+     * Rules for wrapping and unwrapping are bit complicated; essentially:\n+     *<ul>\n+     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n+     * <li>\"Plain\" IOExceptions (ones that are not of type\n+     *   {@link JsonMappingException} are to be passed as is\n+     *</ul>\n+     */\n+    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n+            DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+         *   StackOverflow: usually due to infinite loop. But that\n+         *   usually gets hidden within an InvocationTargetException...\n+         */\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n+        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n+    }\n+\n+    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n+        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, index);\n+    }\n+\n+    protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            // Since we have no more information to add, let's not actually wrap..\n+            throw (IOException) t;\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        throw ctxt.instantiationException(_beanType.getRawClass(), t);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdProperty;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n import com.fasterxml.jackson.databind.util.Annotations;\n \n      * If set, will not throw an exception for unknown properties.\n      */\n     protected boolean _ignoreAllUnknown;\n+\n+    /**\n+     * When creating Builder-based deserializers, this indicates\n+     * method to call on builder to finalize value.\n+     */\n+    protected AnnotatedMethod _buildMethod;\n+\n+    /**\n+     * In addition, Builder may have additional configuration\n+     */\n+    protected JsonPOJOBuilder.Value _builderConfig;\n     \n     /*\n     /**********************************************************\n         _objectIdReader = r;\n     }\n \n+    public void setPOJOBuilder(AnnotatedMethod buildMethod,\n+            JsonPOJOBuilder.Value config) {\n+    \t_buildMethod = buildMethod;\n+    \t_builderConfig = config;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public accessors\n     public Iterator<SettableBeanProperty> getProperties() {\n         return _properties.values().iterator();\n     }\n+\n+    public SettableBeanProperty findProperty(String propertyName) {\n+    \treturn _properties.get(propertyName);\n+    }\n     \n     public boolean hasProperty(String propertyName) {\n-        return _properties.containsKey(propertyName);\n-    }\n-    \n-    public SettableBeanProperty removeProperty(String name)\n-    {\n+        return findProperty(propertyName) != null;\n+    }\n+    \n+    public SettableBeanProperty removeProperty(String name) {\n         return _properties.remove(name);\n     }\n \n     public ObjectIdReader getObjectIdReader() {\n         return _objectIdReader;\n     }\n+\n+    public AnnotatedMethod getBuildMethod() {\n+    \treturn _buildMethod;\n+    }\n+\n+    public JsonPOJOBuilder.Value getBuilderConfig() {\n+        return _builderConfig;\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    public JsonDeserializer<?> build()\n+    /**\n+     * Method for constructing a {@link BeanDeserializer}, given all\n+     * information collected.\n+     */\n+    public BeanDeserializer build()\n     {\n         Collection<SettableBeanProperty> props = _properties.values();\n         BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n                 _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown,\n                 anyViews);\n     }\n+\n+    /**\n+     * Method for constructing a specialized deserializer that uses\n+     * additional external Builder object during data binding.\n+     */\n+    public JsonDeserializer<?> buildBuilderBased(JavaType valueType,\n+    \t\tString expBuildMethodName)\n+    {\n+    \t// First: validation; must have build method that returns compatible type\n+    \tif (_buildMethod == null) {\n+        \tthrow new IllegalArgumentException(\"Builder class \"+_beanDesc.getBeanClass().getName()\n+        \t\t\t+\" does not have build method '\"+expBuildMethodName+\"()'\");\n+    \t}\n+    \t// also: type of the method must be compatible\n+    \tClass<?> rawBuildType = _buildMethod.getRawReturnType();\n+    \tif (!valueType.getRawClass().isAssignableFrom(rawBuildType)) {\n+        \tthrow new IllegalArgumentException(\"Build method '\"+_buildMethod.getFullName()\n+        \t\t\t+\" has bad return type (\"+rawBuildType.getName()\n+        \t\t\t+\"), not compatible with POJO type (\"+valueType.getRawClass().getName()+\")\");\n+    \t}\n+    \t// And if so, we can try building the deserializer\n+        Collection<SettableBeanProperty> props = _properties.values();\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        propertyMap.assignIndexes();\n+\n+        boolean anyViews = !_defaultViewInclusion;\n+\n+        if (!anyViews) {\n+            for (SettableBeanProperty prop : props) {\n+                if (prop.hasViews()) {\n+                    anyViews = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (_objectIdReader != null) {\n+            ObjectIdProperty prop = new ObjectIdProperty(_objectIdReader);\n+            propertyMap = propertyMap.withProperty(prop);\n+        }\n+        \n+        return new BuilderBasedDeserializer(this,\n+                _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown,\n+                anyViews);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n+import com.fasterxml.jackson.databind.deser.impl.FieldProperty;\n+import com.fasterxml.jackson.databind.deser.impl.MethodProperty;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n+import com.fasterxml.jackson.databind.deser.impl.PropertyBasedObjectIdGenerator;\n+import com.fasterxml.jackson.databind.deser.impl.SetterlessProperty;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n         }\n \n         // Otherwise, may want to check handlers for standard types, from superclass:\n-        JsonDeserializer<Object> deser = findStdBeanDeserializer(config, type);\n+        JsonDeserializer<Object> deser = findStdDeserializer(config, type);\n         if (deser != null) {\n             return deser;\n         }\n         // Use generic bean introspection to build deserializer\n         return buildBeanDeserializer(ctxt, type, beanDesc);\n     }\n+\n+    @Override\n+    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n+    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n+    \t\tClass<?> builderClass)\n+        throws JsonMappingException\n+    {\n+    \t// First: need a BeanDescription for builder class\n+    \tJavaType builderType = ctxt.constructType(builderClass);\n+    \tBeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n+    \treturn buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n+    }\n     \n     /**\n      * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n      * deserializer registered for given type.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> findStdBeanDeserializer(DeserializationConfig config,\n+    protected JsonDeserializer<Object> findStdDeserializer(DeserializationConfig config,\n             JavaType type)\n         throws JsonMappingException\n     {\n     {\n         // First: check what creators we can use, if any\n         ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n-        final DeserializationConfig config = ctxt.getConfig();\n         // ... since often we have nothing to go on, if we have abstract type:\n         if (type.isAbstract()) {\n             if (!valueInstantiator.canInstantiate()) {\n             }\n         }\n         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n-        builder.setObjectIdReader(constructObjectIdReader(ctxt, beanDesc));\n         builder.setValueInstantiator(valueInstantiator);\n          // And then setters for deserializing from JSON Object\n         addBeanProps(ctxt, beanDesc, builder);\n+        addObjectIdReader(ctxt, beanDesc, builder);\n+        \n         // managed/back reference fields/setters need special handling... first part\n         addReferenceProperties(ctxt, beanDesc, builder);\n         addInjectables(ctxt, beanDesc, builder);\n \n+        final DeserializationConfig config = ctxt.getConfig();\n         // [JACKSON-440]: update builder now that all information is in?\n         if (_factoryConfig.hasDeserializerModifiers()) {\n             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             }\n         }\n         return (JsonDeserializer<Object>) deserializer;\n+    }\n+\n+    /**\n+     * Method for constructing a bean deserializer that uses specified\n+     * intermediate Builder for binding data, and construction of the\n+     * value instance.\n+     * Note that implementation is mostly copied from the regular\n+     * BeanDeserializer build method.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n+    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n+        throws JsonMappingException\n+    {\n+    \t// Creators, anyone? (to create builder itself)\n+        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        final DeserializationConfig config = ctxt.getConfig();\n+        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n+        builder.setValueInstantiator(valueInstantiator);\n+         // And then \"with methods\" for deserializing from JSON Object\n+        addBeanProps(ctxt, builderDesc, builder);\n+        addObjectIdReader(ctxt, builderDesc, builder);\n         \n-    }\n-\n-    protected ObjectIdReader constructObjectIdReader(DeserializationContext ctxt,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        ObjectIdInfo oidInfo = beanDesc.getObjectIdInfo();\n-        if (oidInfo == null) {\n-            return null;\n-        }\n+        // managed/back reference fields/setters need special handling... first part\n+        addReferenceProperties(ctxt, builderDesc, builder);\n+        addInjectables(ctxt, builderDesc, builder);\n+\n+        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+        final String buildMethodName = (builderConfig == null) ?\n+                \"build\" : builderConfig.buildMethodName;\n+        \n+        // and lastly, find build method to use:\n+        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n+            if (config.canOverrideAccessModifiers()) {\n+            \tClassUtil.checkAndFixAccess(buildMethod.getMember());\n+            }\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+        // this may give us more information...\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                builder = mod.updateBuilder(config, builderDesc, builder);\n+            }\n+        }\n+        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n+        \t\tvalueType, buildMethodName);\n+\n+        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            }\n+        }\n+        return (JsonDeserializer<Object>) deserializer;\n+    }\n+    \n+    protected void addObjectIdReader(DeserializationContext ctxt,\n+            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n+        throws JsonMappingException\n+    {\n+        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n+        if (objectIdInfo == null) {\n+            return;\n+        }\n+        Class<?> implClass = objectIdInfo.getGeneratorType();\n+        JavaType idType;\n+    \tSettableBeanProperty idProp;\n         ObjectIdGenerator<?> gen;\n-        Class<?> implClass = oidInfo.getGeneratorType();\n-        JavaType type = ctxt.constructType(implClass);\n-        // Could require type to be passed explicitly, but we should be able to find it too:\n-        JavaType idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+\n+        // Just one special case: Property-based generator is trickier\n+        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n+            String propName = objectIdInfo.getPropertyName();\n+        \tidProp = builder.findProperty(propName);\n+        \tif (idProp == null) {\n+        \t\tthrow new IllegalArgumentException(\"Invalid Object Id definition for \"\n+        \t\t\t\t+beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n+        \t}\n+            idType = idProp.getType();\n+            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n+        } else {\n+\t        JavaType type = ctxt.constructType(implClass);\n+\t        idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+\t        idProp = null;\n+\t        gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n+        }\n         // also: unlike with value deserializers, let's just resolve one we need here\n         JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n-        \n-        // Just one special case: Property-based generator is trickier\n-        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n-            // !!! TODO\n-            gen = null;\n-            if (true) throw new IllegalStateException(\"Not yet implemented!\");\n-        } else { // other types need to be simpler\n-            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), oidInfo);\n-        }\n-        return ObjectIdReader.construct(idType, oidInfo.getPropertyName(), gen, deser);\n+        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n+        \t\tobjectIdInfo.getPropertyName(), gen, deser, idProp));\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n         if (ctxt.canOverrideAccessModifiers()) {\n             mutator.fixAccess();\n         }\n-        final String name = propDef.getName();\n-\n         // note: this works since we know there's exactly one argument for methods\n         JavaType t0 = beanDesc.resolveType(jdkType);\n \n-        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), mutator);\n+        BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, beanDesc.getClassAnnotations(), mutator);\n         JavaType type = resolveType(ctxt, beanDesc, t0, mutator);\n         // did type change?\n         if (type != t0) {\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop;\n         if (mutator instanceof AnnotatedMethod) {\n-            prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n+            prop = new MethodProperty(propDef, type, typeDeser,\n                 beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n         } else {\n-            prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n+            prop = new FieldProperty(propDef, type, typeDeser,\n                     beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n         }\n         if (propDeser != null) {\n             BeanDescription beanDesc, BeanPropertyDefinition propDef)\n         throws JsonMappingException\n     {\n-        final String name = propDef.getName();\n         final AnnotatedMethod getter = propDef.getGetter();\n         // need to ensure it is callable now:\n         if (ctxt.canOverrideAccessModifiers()) {\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n          */\n-//        BeanProperty.Std property = new BeanProperty.Std(name, type, beanDesc.getClassAnnotations(), getter);\n-\n         JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter);\n         type = modifyTypeByAnnotation(ctxt, getter, type);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n-        SettableBeanProperty prop = new SettableBeanProperty.SetterlessProperty(name, type, typeDeser,\n+        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                 beanDesc.getClassAnnotations(), getter);\n         if (propDeser != null) {\n             prop = prop.withValueDeserializer(propDeser);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Class that handles deserialization using a separate\n+ * Builder class, which is used for data binding and\n+ * produces actual deserialized value at the end\n+ * of data binding.\n+ *<p>\n+ * Note on implementation: much of code has been copied from\n+ * {@link BeanDeserializer}; there may be opportunities to\n+ * refactor this in future.\n+ */\n+public class BuilderBasedDeserializer\n+\textends BeanDeserializerBase\n+{\n+\tprotected final AnnotatedMethod _buildMethod;\n+\t\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by {@link BeanDeserializerBuilder}.\n+     */\n+    public BuilderBasedDeserializer(BeanDeserializerBuilder builder,\n+            BeanDescription beanDesc,\n+            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n+            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n+            boolean hasViews)\n+    {\n+    \tsuper(builder, beanDesc, properties, backRefs,\n+    \t\t\tignorableProps, ignoreAllUnknown, hasViews);\n+    \t_buildMethod = builder.getBuildMethod();\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     */\n+    protected BuilderBasedDeserializer(BuilderBasedDeserializer src)\n+    {\n+        this(src, src._ignoreAllUnknown);\n+    }\n+\n+    protected BuilderBasedDeserializer(BuilderBasedDeserializer src, boolean ignoreAllUnknown)\n+    {\n+        super(src, ignoreAllUnknown);\n+        _buildMethod = src._buildMethod;\n+    }\n+    \n+    protected BuilderBasedDeserializer(BuilderBasedDeserializer src, NameTransformer unwrapper) {\n+    \tsuper(src, unwrapper);\n+        _buildMethod = src._buildMethod;\n+    }\n+\n+    public BuilderBasedDeserializer(BuilderBasedDeserializer src, ObjectIdReader oir) {\n+        super(src, oir);\n+        _buildMethod = src._buildMethod;\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n+    {\n+        /* bit kludgy but we don't want to accidentally change type; sub-classes\n+         * MUST override this method to support unwrapped properties...\n+         */\n+        if (getClass() != BuilderBasedDeserializer.class) {\n+            return this;\n+        }\n+        /* main thing really is to just enforce ignoring of unknown\n+         * properties; since there may be multiple unwrapped values\n+         * and properties for all may be interleaved...\n+         */\n+        return new BuilderBasedDeserializer(this, unwrapper);\n+    }\n+\n+    @Override\n+    public BuilderBasedDeserializer withObjectIdReader(ObjectIdReader oir) {\n+        return new BuilderBasedDeserializer(this, oir);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+    \n+    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n+    \t\tthrows IOException\n+    {\n+        try {\n+    \t\treturn _buildMethod.getMember().invoke(builder);\n+    \t} catch (Exception e) {\n+    \t\twrapInstantiationProblem(e, ctxt);\n+    \t\treturn null;\n+\t\t}\n+    }\n+    \n+    /**\n+     * Main deserialization method for bean-based objects (POJOs).\n+     */\n+    @Override\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        \n+        // common case first:\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+            if (_vanillaProcessing) {\n+            \treturn finishBuild(ctxt, vanillaDeserialize(jp, ctxt, t));\n+            }\n+            Object builder = deserializeFromObject(jp, ctxt);\n+            return finishBuild(ctxt, builder);\n+        }\n+        // and then others, generally requiring use of @JsonCreator\n+        switch (t) {\n+        case VALUE_STRING:\n+            return finishBuild(ctxt, deserializeFromString(jp, ctxt));\n+        case VALUE_NUMBER_INT:\n+            return finishBuild(ctxt, deserializeFromNumber(jp, ctxt));\n+        case VALUE_NUMBER_FLOAT:\n+        \treturn finishBuild(ctxt, deserializeFromDouble(jp, ctxt));\n+        case VALUE_EMBEDDED_OBJECT:\n+            return jp.getEmbeddedObject();\n+        case VALUE_TRUE:\n+        case VALUE_FALSE:\n+            return finishBuild(ctxt, deserializeFromBoolean(jp, ctxt));\n+        case START_ARRAY:\n+            // these only work if there's a (delegating) creator...\n+            return finishBuild(ctxt, deserializeFromArray(jp, ctxt));\n+        case FIELD_NAME:\n+        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n+            return finishBuild(ctxt, deserializeFromObject(jp, ctxt));\n+\t\t}\n+        throw ctxt.mappingException(getBeanClass());\n+    }\n+\n+    /**\n+     * Secondary deserialization method, called in cases where POJO\n+     * instance is created as part of deserialization, potentially\n+     * after collecting some or all of the properties to set.\n+     */\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n+    \t\tObject builder)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Important: we call separate method which does NOT call\n+         * 'finishBuild()', to avoid problems with recursion\n+         */\n+        return finishBuild(ctxt, _deserialize(jp, ctxt, builder));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete deserialization methods\n+    /**********************************************************\n+     */\n+\n+    protected final Object _deserialize(JsonParser jp,\n+            DeserializationContext ctxt, Object builder)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_injectables != null) {\n+            injectValues(ctxt, builder);\n+        }\n+        if (_unwrappedPropertyHandler != null) {\n+            return deserializeWithUnwrapped(jp, ctxt, builder);\n+        }\n+        if (_externalTypeIdHandler != null) {\n+            return deserializeWithExternalTypeId(jp, ctxt, builder);\n+        }\n+        if (_needViewProcesing) {\n+            Class<?> view = ctxt.getActiveView();\n+            if (view != null) {\n+                return deserializeWithView(jp, ctxt, builder, view);\n+            }\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            \n+            if (prop != null) { // normal case\n+                try {\n+                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, builder, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+            } else if (_anySetter != null) {\n+                // should we try to get return value of any setter too?\n+                _anySetter.deserializeAndSet(jp, ctxt, builder, propName);\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, builder, propName);\n+            }\n+        }\n+        return builder;\n+    }\n+    \n+    /**\n+     * Streamlined version that is only used when no \"special\"\n+     * features are enabled.\n+     */\n+    private final Object vanillaDeserialize(JsonParser jp,\n+    \t\tDeserializationContext ctxt, JsonToken t)\n+        throws IOException, JsonProcessingException\n+    {\n+        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+            } else {\n+                _vanillaDeserializeHandleUnknown(jp, ctxt, bean, propName);\n+            }\n+        }\n+        return bean;\n+    }\n+\n+    /**\n+     * Helper method called for an unknown property, when using \"vanilla\"\n+     * processing.\n+     */\n+    private final void _vanillaDeserializeHandleUnknown(JsonParser jp, DeserializationContext ctxt,\n+            Object bean, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+            jp.skipChildren();\n+        } else if (_anySetter != null) {\n+            try {\n+            \t// should we consider return type of any setter?\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+            } catch (Exception e) {\n+                wrapAndThrow(e, bean, propName, ctxt);\n+            }\n+        } else {\n+            // Unknown: let's call handler method\n+            handleUnknownProperty(jp, ctxt, bean, propName);         \n+        }\n+    }\n+\n+    /**\n+     * General version used when handling needs more advanced\n+     * features.\n+     */\n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_nonStandardCreation) {\n+            if (_unwrappedPropertyHandler != null) {\n+                return deserializeWithUnwrapped(jp, ctxt);\n+            }\n+            if (_externalTypeIdHandler != null) {\n+                return deserializeWithExternalTypeId(jp, ctxt);\n+            }\n+            return deserializeFromObjectUsingNonDefault(jp, ctxt);\n+        }\n+        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        if (_needViewProcesing) {\n+            Class<?> view = ctxt.getActiveView();\n+            if (view != null) {\n+                return deserializeWithView(jp, ctxt, bean, view);\n+            }\n+        }\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+            } else if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);         \n+            }\n+        }\n+        return bean;\n+    }\n+\n+    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n+            DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt,\n+                    _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+    \n+    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First things first: id Object Id is used, most likely that's it\n+        if (_objectIdReader != null) {\n+            return deserializeUsingObjectId(jp, ctxt);\n+        }\n+        \n+        /* Bit complicated if we have delegating creator; may need to use it,\n+         * or might not...\n+         */\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromString()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+    }\n+\n+    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First things first: id Object Id is used, most likely that's it\n+        if (_objectIdReader != null) {\n+            return deserializeUsingObjectId(jp, ctxt);\n+        }\n+\n+        switch (jp.getNumberType()) {\n+        case INT:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromInt()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromInt(ctxt, jp.getIntValue());\n+        case LONG:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromInt()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromLong(ctxt, jp.getLongValue());\n+    \t}\n+        // actually, could also be BigInteger, so:\n+        if (_delegateDeserializer != null) {\n+            Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            if (_injectables != null) {\n+                injectValues(ctxt, bean);\n+            }\n+            return bean;\n+        }\n+        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON floating-point\n+     * number.\n+     */\n+    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getNumberType()) {\n+        case FLOAT: // no separate methods for taking float...\n+        case DOUBLE:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromDouble()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+        }\n+        // actually, could also be BigDecimal, so:\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n+     */\n+    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromBoolean()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        return _valueInstantiator.createFromBoolean(ctxt, value);\n+    }\n+\n+    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+    \tif (_delegateDeserializer != null) {\n+    \t    try {\n+    \t        Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+    \t        if (_injectables != null) {\n+    \t            injectValues(ctxt, bean);\n+    \t        }\n+    \t        return bean;\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+            }\n+    \t}\n+    \tthrow ctxt.mappingException(getBeanClass());\n+    }\n+\n+    /**\n+     * Method called to deserialize bean using \"property-based creator\":\n+     * this means that a non-default constructor or factory method is\n+     * called, and then possibly other setters. The trick is that\n+     * values for creator method need to be buffered, first; and \n+     * due to non-guaranteed ordering possibly some other properties\n+     * as well.\n+     */\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+            final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    { \n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n+        TokenBuffer unknown = null;\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    //  polymorphic?\n+        \t\t    if (bean.getClass() != _beanType.getRawClass()) {\n+        \t\t        return handlePolymorphic(jp, ctxt, bean, unknown);\n+        \t\t    }\n+        \t\t    if (unknown != null) { // nope, just extra unknown stuff...\n+        \t\t        bean = handleUnknownProperties(ctxt, bean, unknown);\n+        \t\t    }\n+        \t\t    // or just clean?\n+        \t\t    return _deserialize(jp, ctxt, bean);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            // Ok then, let's collect the whole field; name and value\n+            if (unknown == null) {\n+                unknown = new TokenBuffer(jp.getCodec());\n+            }\n+            unknown.writeFieldName(propName);\n+            unknown.copyCurrentStructure(jp);\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        try {\n+            bean =  creator.build(ctxt, buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        if (unknown != null) {\n+            // polymorphic?\n+            if (bean.getClass() != _beanType.getRawClass()) {\n+                return handlePolymorphic(null, ctxt, bean, unknown);\n+            }\n+            // no, just some extra unknown properties\n+            return handleUnknownProperties(ctxt, bean, unknown);\n+        }\n+        return bean;\n+    }\n+\n+    /**\n+     * Method called in cases where we may have polymorphic deserialization\n+     * case: that is, type of Creator-constructed bean is not the type\n+     * of deserializer itself. It should be a sub-class or implementation\n+     * class; either way, we may have more specific deserializer to use\n+     * for handling it.\n+     *\n+     * @param jp (optional) If not null, parser that has more properties to handle\n+     *   (in addition to buffered properties); if null, all properties are passed\n+     *   in buffer\n+     */\n+    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          \n+            Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {  \n+        // First things first: maybe there is a more specific deserializer available?\n+        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n+        if (subDeser != null) {\n+            if (unknownTokens != null) {\n+                // need to add END_OBJECT marker first\n+                unknownTokens.writeEndObject();\n+                JsonParser p2 = unknownTokens.asParser();\n+                p2.nextToken(); // to get to first data field\n+                bean = subDeser.deserialize(p2, ctxt, bean);\n+            }\n+            // Original parser may also have some leftovers\n+            if (jp != null) {\n+                bean = subDeser.deserialize(jp, ctxt, bean);\n+            }\n+            return bean;\n+        }\n+        // nope; need to use this deserializer. Unknowns we've seen so far?\n+        if (unknownTokens != null) {\n+            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n+        }\n+        // and/or things left to process via main parser?\n+        if (jp != null) {\n+            bean = deserialize(jp, ctxt, bean);\n+        }\n+        return bean;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserializing when we have to consider an active View\n+    /**********************************************************\n+     */\n+    \n+    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+            Object bean, Class<?> activeView)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                if (!prop.visibleInView(activeView)) {\n+                    jp.skipChildren();\n+                    continue;\n+                }\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+            } else if (_anySetter != null) {\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);\n+            }\n+        }\n+        return bean;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Handling for cases where we have \"unwrapped\" values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when there are declared \"unwrapped\" properties\n+     * which need special handling\n+     */\n+    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n+        }\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+\n+        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        \n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                if (activeView != null && !prop.visibleInView(activeView)) {\n+                    jp.skipChildren();\n+                    continue;\n+                }\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            // ignorable things should be ignored\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but... others should be passed to unwrapped property deserializers\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // how about any setter? We'll get copies but...\n+            if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+        }\n+        tokens.writeEndObject();\n+        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return bean;\n+    }    \n+\n+    protected Object deserializeWithUnwrapped(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            jp.nextToken();\n+            if (prop != null) { // normal case\n+                if (activeView != null && !prop.visibleInView(activeView)) {\n+                    jp.skipChildren();\n+                    continue;\n+                }\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but... others should be passed to unwrapped property deserializers\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // how about any setter? We'll get copies but...\n+            if (_anySetter != null) {\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+            }\n+        }\n+        tokens.writeEndObject();\n+        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return bean;\n+    }\n+\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp,\n+    \t\tDeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    // if so, need to copy all remaining tokens into buffer\n+                    while (t == JsonToken.FIELD_NAME) {\n+                        jp.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(jp);\n+                        t = jp.nextToken();\n+                    }\n+                    tokens.writeEndObject();\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n+                        //   it's too complicated, so bail out\n+                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                    }\n+                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+            }\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n+        try {\n+            bean = creator.build(ctxt, buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Handling for cases where we have property/-ies wth\n+    /* external type id\n+    /**********************************************************\n+     */\n+    \n+    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_propertyBasedCreator != null) {\n+            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+    }\n+\n+    protected Object deserializeWithExternalTypeId(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n+        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                if (activeView != null && !prop.visibleInView(activeView)) {\n+                    jp.skipChildren();\n+                    continue;\n+                }\n+                try {\n+                    bean = prop.deserializeSetAndReturn(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            // ignorable things should be ignored\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but others are likely to be part of external type id thingy...\n+            if (ext.handleToken(jp, ctxt, propName, bean)) {\n+                continue;\n+            }\n+            // if not, the usual fallback handling:\n+            if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);         \n+            }\n+        }\n+        // and when we get this far, let's try finalizing the deal:\n+        return ext.complete(jp, ctxt, bean);\n+    }        \n+\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp,\n+    \t\tDeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    // if so, need to copy all remaining tokens into buffer\n+                    while (t == JsonToken.FIELD_NAME) {\n+                        jp.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(jp);\n+                        t = jp.nextToken();\n+                    }\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n+                        //   it's too complicated, so bail out\n+                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                    }\n+                    return ext.complete(jp, ctxt, bean);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            // external type id (or property that depends on it)?\n+            if (ext.handleToken(jp, ctxt, propName, null)) {\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+            }\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        try {\n+            bean = creator.build(ctxt, buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        return ext.complete(jp, ctxt, bean);\n+    }    \n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n     }\n \n     @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        return setAndReturn(instance, deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n     public void set(Object instance, Object value)\n         throws IOException\n     {\n     }\n \n     @Override\n+    public Object setAndReturn(Object instance, Object value)\n+   \t\tthrows IOException\n+\t{\n+    \treturn instance;\n+\t}\n+    \n+    @Override\n     public Object getInjectableValueId() {\n         return _injectableValueId;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n             beanDesc = config.introspect(newType);\n         }\n \n+        // We may also have a Builder type to consider...\n+        Class<?> builder = beanDesc.findPOJOBuilder();\n+        if (builder != null) {\n+            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n+            \t\tctxt, type, beanDesc, builder);\n+        }\n+        \n         // If not, let's see which factory method to use:\n         if (type.isEnumType()) {\n             return (JsonDeserializer<Object>) factory.createEnumDeserializer(ctxt,\n                         clt, beanDesc);\n             }\n         }\n-\n-        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n             return (JsonDeserializer<Object>) factory.createTreeDeserializer(config, type, beanDesc);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n         throws JsonMappingException;\n \n     /**\n+     * Method called to create a deserializer that will use specified Builder\n+     * class for building value instances.\n+     * \n+     * @since 2.0\n+     */\n+    public abstract JsonDeserializer<Object> createBuilderBasedDeserializer(\n+    \t\tDeserializationContext ctxt, JavaType type, BeanDescription beanDesc,\n+    \t\tClass<?> builderClass)\n+        throws JsonMappingException;\n+    \n+    /**\n      * Method called to create (or, for completely immutable deserializers,\n      * reuse) a deserializer that can convert JSON content into values of\n      * specified Java type.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n \n import java.io.IOException;\n import java.lang.annotation.Annotation;\n-import java.lang.reflect.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.util.InternCache;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.deser.impl.NullProvider;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.ViewMatcher;\n \n /**\n- * Base class for settable properties of a bean: contains\n+ * Base class for deserilizable properties of a bean: contains\n  * both type and name definitions, and reflection-based set functionality.\n- * Concrete sub-classes implement details, so that both field- and\n- * setter-backed properties can be handled\n+ * Concrete sub-classes implement details, so that field- and\n+ * setter-backed properties, as well as a few more esoteric variations,\n+ * can be handled.\n  */\n public abstract class SettableBeanProperty\n     implements BeanProperty\n     /**********************************************************\n      */\n \n-    protected SettableBeanProperty(String propName, JavaType type, TypeDeserializer typeDeser,\n-            Annotations contextAnnotations)\n+    protected SettableBeanProperty(BeanPropertyDefinition propDef,\n+            JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations)\n+    {\n+        this(propDef.getName(), type, typeDeser, contextAnnotations);\n+    }\n+    \n+    protected SettableBeanProperty(String propName,\n+            JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations)\n     {\n         /* 09-Jan-2009, tatu: Intern()ing makes sense since Jackson parsed\n          *   field names are (usually) interned too, hence lookups will be faster.\n      * that should be consumed to produce the value (the only value for\n      * scalars, multiple for Objects and Arrays).\n      */\n-    public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                                           Object instance)\n+    public abstract void deserializeAndSet(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n         throws IOException, JsonProcessingException;\n \n+\t/**\n+\t * Alternative to {@link #deserializeAndSet} that returns\n+\t * either return value of setter method called (if one is),\n+\t * or null to indicate that no return value is available.\n+\t * Mostly used to support Builder style deserialization.\n+\t *\n+\t * @since 2.0\n+\t */\n+    public abstract Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to assign given value to this property, on\n+     * specified Object.\n+     */\n     public abstract void set(Object instance, Object value)\n         throws IOException;\n \n+    /**\n+     * Method called to assign given value to this property, on\n+     * specified Object, and return whatever delegating accessor\n+     * returned (if anything)\n+     * \n+     * @since 2.0\n+     */\n+    public abstract Object setAndReturn(Object instance, Object value)\n+\t\tthrows IOException;\n+    \n     /**\n      * This method is needed by some specialized bean deserializers,\n      * and also called by some {@link #deserializeAndSet} implementations.\n     }\n \n     @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n-    \n-    /*\n-    /**********************************************************\n-    /* Implementation classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * This concrete sub-class implements property that is set\n-     * using regular \"setter\" method.\n-     */\n-    public final static class MethodProperty\n-        extends SettableBeanProperty\n-    {\n-        protected final AnnotatedMethod _annotated;\n-        \n-        /**\n-         * Setter method for modifying property value; used for\n-         * \"regular\" method-accessible properties.\n-         */\n-        protected final Method _setter;\n-\n-        public MethodProperty(String name, JavaType type, TypeDeserializer typeDeser,\n-                Annotations contextAnnotations, AnnotatedMethod method)\n-        {\n-            super(name, type, typeDeser, contextAnnotations);\n-            _annotated = method;\n-            _setter = method.getAnnotated();\n-        }\n-\n-        protected MethodProperty(MethodProperty src, JsonDeserializer<?> deser) {\n-            super(src, deser);\n-            _annotated = src._annotated;\n-            _setter = src._setter;\n-        }\n-\n-        protected MethodProperty(MethodProperty src, String newName) {\n-            super(src, newName);\n-            _annotated = src._annotated;\n-            _setter = src._setter;\n-        }\n-\n-        @Override\n-        public MethodProperty withName(String newName) {\n-            return new MethodProperty(this, newName);\n-        }\n-        \n-        @Override\n-        public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) {\n-            return new MethodProperty(this, deser);\n-        }\n-        \n-        /*\n-        /**********************************************************\n-        /* BeanProperty impl\n-        /**********************************************************\n-         */\n-        \n-        @Override\n-        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-            return _annotated.getAnnotation(acls);\n-        }\n-\n-        @Override public AnnotatedMember getMember() {  return _annotated; }\n-\n-        /*\n-        /**********************************************************\n-        /* Overridden methods\n-        /**********************************************************\n-         */\n-\n-        @Override\n-        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                Object instance)\n-            throws IOException, JsonProcessingException\n-        {\n-            set(instance, deserialize(jp, ctxt));\n-        }\n-\n-        @Override\n-        public final void set(Object instance, Object value)\n-            throws IOException\n-        {\n-            try {\n-                _setter.invoke(instance, value);\n-            } catch (Exception e) {\n-                _throwAsIOE(e, value);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This concrete sub-class implements Collection or Map property that is\n-     * indirectly by getting the property value and directly modifying it.\n-     */\n-    public final static class SetterlessProperty\n-        extends SettableBeanProperty\n-    {\n-        protected final AnnotatedMethod _annotated;\n-\n-        /**\n-         * Get method for accessing property value used to access property\n-         * (of Collection or Map type) to modify.\n-         */\n-        protected final Method _getter;\n-\n-        public SetterlessProperty(String name, JavaType type, TypeDeserializer typeDeser,\n-                Annotations contextAnnotations, AnnotatedMethod method)\n-            {\n-            super(name, type, typeDeser, contextAnnotations);\n-            _annotated = method;\n-            _getter = method.getAnnotated();\n-        }\n-\n-        protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<?> deser) {\n-            super(src, deser);\n-            _annotated = src._annotated;\n-            _getter = src._getter;\n-        }\n-\n-        protected SetterlessProperty(SetterlessProperty src, String newName) {\n-            super(src, newName);\n-            _annotated = src._annotated;\n-            _getter = src._getter;\n-        }\n-\n-        @Override\n-        public SetterlessProperty withName(String newName) {\n-            return new SetterlessProperty(this, newName);\n-        }\n-        \n-        @Override\n-        public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) {\n-            return new SetterlessProperty(this, deser);\n-        }\n-        \n-        /*\n-        /**********************************************************\n-        /* BeanProperty impl\n-        /**********************************************************\n-         */\n-        \n-        @Override\n-        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-            return _annotated.getAnnotation(acls);\n-        }\n-\n-        @Override public AnnotatedMember getMember() {  return _annotated; }\n-\n-        /*\n-        /**********************************************************\n-        /* Overridden methods\n-        /**********************************************************\n-         */\n-        \n-        @Override\n-        public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                Object instance)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            if (t == JsonToken.VALUE_NULL) {\n-                /* Hmmh. Is this a problem? We won't be setting anything, so it's\n-                 * equivalent of empty Collection/Map in this case\n-                 */\n-                return;\n-            }\n-\n-            // Ok: then, need to fetch Collection/Map to modify:\n-            Object toModify;\n-            try {\n-                toModify = _getter.invoke(instance);\n-            } catch (Exception e) {\n-                _throwAsIOE(e);\n-                return; // never gets here\n-            }\n-            /* Note: null won't work, since we can't then inject anything\n-             * in. At least that's not good in common case. However,\n-             * theoretically the case where we get JSON null might\n-             * be compatible. If so, implementation could be changed.\n-             */\n-            if (toModify == null) {\n-                throw new JsonMappingException(\"Problem deserializing 'setterless' property '\"+getName()+\"': get method returned null\");\n-            }\n-            _valueDeserializer.deserialize(jp, ctxt, toModify);\n-        }\n-\n-        @Override\n-        public final void set(Object instance, Object value)\n-            throws IOException\n-        {\n-            throw new UnsupportedOperationException(\"Should never call 'set' on setterless property\");\n-        }\n-    }\n-\n-    /**\n-     * This concrete sub-class implements property that is set\n-     * directly assigning to a Field.\n-     */\n-    public final static class FieldProperty\n-        extends SettableBeanProperty\n-    {\n-        protected final AnnotatedField _annotated;\n-\n-        /**\n-         * Actual field to set when deserializing this property.\n-         */\n-        protected final Field _field;\n-\n-        public FieldProperty(String name, JavaType type, TypeDeserializer typeDeser,\n-                Annotations contextAnnotations, AnnotatedField field)\n-        {\n-            super(name, type, typeDeser, contextAnnotations);\n-            _annotated = field;\n-            _field = field.getAnnotated();\n-        }\n-\n-        protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser) {\n-            super(src, deser);\n-            _annotated = src._annotated;\n-            _field = src._field;\n-        }\n-\n-        protected FieldProperty(FieldProperty src, String newName) {\n-            super(src, newName);\n-            _annotated = src._annotated;\n-            _field = src._field;\n-        }\n-\n-        @Override\n-        public FieldProperty withName(String newName) {\n-            return new FieldProperty(this, newName);\n-        }\n-        \n-        @Override\n-        public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) {\n-            return new FieldProperty(this, deser);\n-        }\n-        \n-        /*\n-        /**********************************************************\n-        /* BeanProperty impl\n-        /**********************************************************\n-         */\n-        \n-        @Override\n-        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-            return _annotated.getAnnotation(acls);\n-        }\n-\n-        @Override public AnnotatedMember getMember() {  return _annotated; }\n-\n-        /*\n-        /**********************************************************\n-        /* Overridden methods\n-        /**********************************************************\n-         */\n-\n-        @Override\n-        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                                      Object instance)\n-            throws IOException, JsonProcessingException\n-        {\n-            set(instance, deserialize(jp, ctxt));\n-        }\n-\n-        @Override\n-        public final void set(Object instance, Object value)\n-            throws IOException\n-        {\n-            try {\n-                _field.set(instance, value);\n-            } catch (Exception e) {\n-                _throwAsIOE(e, value);\n-            }\n-        }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Other helper classes\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * To support [JACKSON-420] we need bit more indirection; this is used to produce\n-     * artificial failure for primitives that don't accept JSON null as value.\n-     */\n-    protected final static class NullProvider\n-    {\n-        private final Object _nullValue;\n-\n-        private final boolean _isPrimitive;\n-        \n-        private final Class<?> _rawType;\n-        \n-        protected NullProvider(JavaType type, Object nullValue)\n-        {\n-            _nullValue = nullValue;\n-            // [JACKSON-420]\n-            _isPrimitive = type.isPrimitive();\n-            _rawType = type.getRawClass();\n-        }\n-\n-        public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException\n-        {\n-            if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n-                throw ctxt.mappingException(\"Can not map JSON null into type \"+_rawType.getName()\n-                        +\" (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n-            }\n-            return _nullValue;\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n      */\n     public BeanPropertyMap withProperty(SettableBeanProperty newProperty)\n     {\n-        int bcount = _buckets.length;\n-        // can do a straight copy, since all additions are at the front\n+    \t// first things first: can just copy hash area:\n+    \tfinal int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n-        // and then insert the new property:\n-        String key = newProperty.getName();\n-        int index = key.hashCode() & _hashMask;\n-        newBuckets[index] = new Bucket(newBuckets[index], key, newProperty);\n-        return new BeanPropertyMap(newBuckets, _size+1);\n+        final String propName = newProperty.getName();\n+        // and then see if it's add or replace:\n+    \tSettableBeanProperty oldProp = find(newProperty.getName());\n+    \tif (oldProp == null) { // add\n+        \t// first things first: add or replace?\n+\t        // can do a straight copy, since all additions are at the front\n+\t        // and then insert the new property:\n+\t        int index = propName.hashCode() & _hashMask;\n+\t        newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty);\n+\t        return new BeanPropertyMap(newBuckets, _size+1);\n+    \t}\n+    \t// replace: easy, close + replace\n+    \tBeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount);\n+    \tnewMap.replace(newProperty);\n+    \treturn newMap;\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * This concrete sub-class implements property that is set\n+ * directly assigning to a Field.\n+ */\n+public final class FieldProperty\n+    extends SettableBeanProperty\n+{\n+    protected final AnnotatedField _annotated;\n+\n+    /**\n+     * Actual field to set when deserializing this property.\n+     */\n+    protected final Field _field;\n+\n+    public FieldProperty(BeanPropertyDefinition propDef, JavaType type,\n+            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field)\n+    {\n+        super(propDef, type, typeDeser, contextAnnotations);\n+        _annotated = field;\n+        _field = field.getAnnotated();\n+    }\n+\n+    protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser) {\n+        super(src, deser);\n+        _annotated = src._annotated;\n+        _field = src._field;\n+    }\n+\n+    protected FieldProperty(FieldProperty src, String newName) {\n+        super(src, newName);\n+        _annotated = src._annotated;\n+        _field = src._field;\n+    }\n+\n+    @Override\n+    public FieldProperty withName(String newName) {\n+        return new FieldProperty(this, newName);\n+    }\n+    \n+    @Override\n+    public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) {\n+        return new FieldProperty(this, deser);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return _annotated.getAnnotation(acls);\n+    }\n+\n+    @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void deserializeAndSet(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        set(instance, deserialize(jp, ctxt));\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        return setAndReturn(instance, deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n+    public final void set(Object instance, Object value)\n+        throws IOException\n+    {\n+        try {\n+            _field.set(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+\t\tthrows IOException\n+\t{\n+        try {\n+            _field.set(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n+        return instance;\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n             Object bean)\n         throws IOException, JsonProcessingException\n     {\n-        // mostly copied from super class impl:\n         JsonToken t = jp.getCurrentToken();\n         Object value;\n         if (t == JsonToken.VALUE_NULL) {\n     }\n \n     @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        return setAndReturn(instance, deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n     public final void set(Object instance, Object value) throws IOException\n     {\n         _delegate.set(instance, value);\n     }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+   \t\tthrows IOException\n+\t{\n+    \treturn _delegate.setAndReturn(instance, value);\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n \n     protected final SettableBeanProperty _backProperty;\n     \n-    public ManagedReferenceProperty(String refName,\n-            SettableBeanProperty forward, SettableBeanProperty backward,\n-            Annotations contextAnnotations,\n-            boolean isContainer)\n+    public ManagedReferenceProperty(SettableBeanProperty forward,\n+            String refName, SettableBeanProperty backward,\n+            Annotations contextAnnotations, boolean isContainer)\n     {\n         super(forward.getName(), forward.getType(), forward.getValueTypeDeserializer(),\n                 contextAnnotations);\n     }\n \n     @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        return setAndReturn(instance, deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n     public final void set(Object instance, Object value)\n         throws IOException\n     {\n-        _managedProperty.set(instance, value);\n+    \tsetAndReturn(instance, value);\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+   \t\tthrows IOException\n+\t{\n+    \tObject result = _managedProperty.setAndReturn(instance, value);\n         /* And then back reference, if (and only if!) we actually have a non-null\n          * reference\n          */\n                 _backProperty.set(value, instance);\n             }\n         }\n-    }\n+    \treturn result;\n+\t}\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * This concrete sub-class implements property that is set\n+ * using regular \"setter\" method.\n+ */\n+public final class MethodProperty\n+    extends SettableBeanProperty\n+{\n+    protected final AnnotatedMethod _annotated;\n+    \n+    /**\n+     * Setter method for modifying property value; used for\n+     * \"regular\" method-accessible properties.\n+     */\n+    protected final Method _setter;\n+\n+    public MethodProperty(BeanPropertyDefinition propDef,\n+            JavaType type, TypeDeserializer typeDeser,\n+            Annotations contextAnnotations, AnnotatedMethod method)\n+    {\n+        super(propDef, type, typeDeser, contextAnnotations);\n+        _annotated = method;\n+        _setter = method.getAnnotated();\n+    }\n+\n+    protected MethodProperty(MethodProperty src, JsonDeserializer<?> deser) {\n+        super(src, deser);\n+        _annotated = src._annotated;\n+        _setter = src._setter;\n+    }\n+\n+    protected MethodProperty(MethodProperty src, String newName) {\n+        super(src, newName);\n+        _annotated = src._annotated;\n+        _setter = src._setter;\n+    }\n+\n+    @Override\n+    public MethodProperty withName(String newName) {\n+        return new MethodProperty(this, newName);\n+    }\n+    \n+    @Override\n+    public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) {\n+        return new MethodProperty(this, deser);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return _annotated.getAnnotation(acls);\n+    }\n+\n+    @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+            Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        set(instance, deserialize(jp, ctxt));\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+    \treturn setAndReturn(instance, deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n+    public final void set(Object instance, Object value)\n+        throws IOException\n+    {\n+        try {\n+            _setter.invoke(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+\t\tthrows IOException\n+\t{\n+        try {\n+            Object result = _setter.invoke(instance, value);\n+            return (result == null) ? instance : result;\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+            return null;\n+        }\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NullProvider.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * To support [JACKSON-420] we need bit more indirection; this is used to produce\n+ * artificial failure for primitives that don't accept JSON null as value.\n+ */\n+public final class NullProvider\n+{\n+    private final Object _nullValue;\n+\n+    private final boolean _isPrimitive;\n+    \n+    private final Class<?> _rawType;\n+    \n+    public NullProvider(JavaType type, Object nullValue)\n+    {\n+        _nullValue = nullValue;\n+        // [JACKSON-420]\n+        _isPrimitive = type.isPrimitive();\n+        _rawType = type.getRawClass();\n+    }\n+\n+    public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException\n+    {\n+        if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n+            throw ctxt.mappingException(\"Can not map JSON null into type \"+_rawType.getName()\n+                    +\" (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n+        }\n+        return _nullValue;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdProperty.java\n  * for virtual property that represents Object Id that is used\n  * for some POJO types (or properties).\n  */\n-public class ObjectIdProperty extends SettableBeanProperty\n+public final class ObjectIdProperty\n+\textends SettableBeanProperty\n {\n     protected final ObjectIdReader _objectIdReader;\n     \n         Object instance)\n             throws IOException, JsonProcessingException\n     {\n+    \tdeserializeSetAndReturn(jp, ctxt, instance);\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n         // note: no null checks (unlike usually); deserializer should fail if one found\n         Object id = _valueDeserializer.deserialize(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n         roid.bindItem(instance);\n+        // also: may need to set a property value as well\n+        SettableBeanProperty idProp = _objectIdReader.idProperty;\n+        if (idProp != null) {\n+            return idProp.setAndReturn(instance, id);\n+        }\n+        return instance;\n+    }\n+    \n+    \n+    @Override\n+    public void set(Object instance, Object value) throws IOException {\n+    \tsetAndReturn(instance, value);\n     }\n \n     @Override\n-    public void set(Object instance, Object value) throws IOException {\n-        throw new UnsupportedOperationException(\"Should not call set() on ObjectIdProperty\");\n-    }\n-\n+    public Object setAndReturn(Object instance, Object value)\n+   \t\tthrows IOException\n+\t{\n+        SettableBeanProperty idProp = _objectIdReader.idProperty;\n+        if (idProp == null) {\n+        \tthrow new UnsupportedOperationException(\n+        \t\t\t\"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n+        }\n+        return idProp.setAndReturn(instance, value);\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n /**\n  * Object that knows how to serialize Object Ids.\n      * Serializer used for serializing id values.\n      */\n     public final JsonDeserializer<Object> deserializer;\n+\n+    public final SettableBeanProperty idProperty;\n     \n     /*\n     /**********************************************************\n     \n     @SuppressWarnings(\"unchecked\")\n     protected ObjectIdReader(JavaType t, String propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser)\n+            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n     {\n         idType = t;\n         propertyName = propName;\n         generator = gen;\n         deserializer = (JsonDeserializer<Object>) deser;\n+        idProperty = idProp;\n     }\n \n     /**\n      * for which serializer is being built.\n      */\n     public static ObjectIdReader construct(JavaType idType, String propName,\n-            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser)\n+            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n+            SettableBeanProperty idProp)\n     {\n-        return new ObjectIdReader(idType, propName, generator, deser);\n+        return new ObjectIdReader(idType, propName, generator, deser, idProp);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedObjectIdGenerator.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+\n+// Simple placeholder\n+public class PropertyBasedObjectIdGenerator\n+\textends ObjectIdGenerators.PropertyGenerator\n+{\n+    public PropertyBasedObjectIdGenerator(Class<?> scope) {\n+        super(scope);\n+    }\n+    \n+    @Override\n+    public Object generateId(Object forPojo) {\n+    \tthrow new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<Object> forScope(Class<?> scope) {\n+        return (scope == _scope) ? this : new PropertyBasedObjectIdGenerator(scope);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<Object> newForSerialization(Object context) {\n+        return this;\n+    }\n+\n+    @Override\n+    public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) {\n+        // should we use general type for all; or type of property itself?\n+        return new IdKey(getClass(), _scope, key);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * This concrete sub-class implements Collection or Map property that is\n+ * indirectly by getting the property value and directly modifying it.\n+ */\n+public final class SetterlessProperty\n+    extends SettableBeanProperty\n+{\n+    protected final AnnotatedMethod _annotated;\n+\n+    /**\n+     * Get method for accessing property value used to access property\n+     * (of Collection or Map type) to modify.\n+     */\n+    protected final Method _getter;\n+\n+    public SetterlessProperty(BeanPropertyDefinition propDef, JavaType type,\n+            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method)\n+        {\n+        super(propDef, type, typeDeser, contextAnnotations);\n+        _annotated = method;\n+        _getter = method.getAnnotated();\n+    }\n+\n+    protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<?> deser) {\n+        super(src, deser);\n+        _annotated = src._annotated;\n+        _getter = src._getter;\n+    }\n+\n+    protected SetterlessProperty(SetterlessProperty src, String newName) {\n+        super(src, newName);\n+        _annotated = src._annotated;\n+        _getter = src._getter;\n+    }\n+\n+    @Override\n+    public SetterlessProperty withName(String newName) {\n+        return new SetterlessProperty(this, newName);\n+    }\n+    \n+    @Override\n+    public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) {\n+        return new SetterlessProperty(this, deser);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return _annotated.getAnnotation(acls);\n+    }\n+\n+    @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+            Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NULL) {\n+            /* Hmmh. Is this a problem? We won't be setting anything, so it's\n+             * equivalent of empty Collection/Map in this case\n+             */\n+            return;\n+        }\n+\n+        // Ok: then, need to fetch Collection/Map to modify:\n+        Object toModify;\n+        try {\n+            toModify = _getter.invoke(instance);\n+        } catch (Exception e) {\n+            _throwAsIOE(e);\n+            return; // never gets here\n+        }\n+        /* Note: null won't work, since we can't then inject anything\n+         * in. At least that's not good in common case. However,\n+         * theoretically the case where we get JSON null might\n+         * be compatible. If so, implementation could be changed.\n+         */\n+        if (toModify == null) {\n+            throw new JsonMappingException(\"Problem deserializing 'setterless' property '\"+getName()+\"': get method returned null\");\n+        }\n+        _valueDeserializer.deserialize(jp, ctxt, toModify);\n+    }\n+\n+    @Override\n+    public Object deserializeSetAndReturn(JsonParser jp,\n+    \t\tDeserializationContext ctxt, Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+    \tdeserializeAndSet(jp, ctxt, instance);\n+    \treturn instance;\n+    }\n+    \n+    @Override\n+    public final void set(Object instance, Object value)\n+        throws IOException\n+    {\n+        throw new UnsupportedOperationException(\"Should never call 'set' on setterless property\");\n+    }\n+\n+    @Override\n+    public Object setAndReturn(Object instance, Object value)\n+\t\tthrows IOException\n+\t{\n+    \tset(instance, value);\n+    \treturn null;\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n      *   If null, will assume type is what {@link #getValueClass} returns.\n      * @param propName Name of the property that can not be mapped\n      */\n-    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName)\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,\n+            Object instanceOrClass, String propName)\n         throws IOException, JsonProcessingException\n     {\n         if (instanceOrClass == null) {\n             return;\n         }\n         // Nope, not handled. Potentially that's a problem...\n-        reportUnknownProperty(ctxt, instanceOrClass, propName);\n-\n-        /* If we get this far, need to skip now; we point to first token of\n-         * value (START_xxx for structured, or the value token for others)\n+        ctxt.reportUnknownProperty(instanceOrClass, propName);\n+\n+        /* But if we do get this far, need to skip whatever value we\n+         * are pointing to now.\n          */\n         jp.skipChildren();\n     }\n-        \n-    protected void reportUnknownProperty(DeserializationContext ctxt,\n-                                         Object instanceOrClass, String fieldName)\n-        throws IOException, JsonProcessingException\n-    {\n-        // throw exception if that's what we are expected to do\n-        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n-            throw ctxt.unknownFieldException(instanceOrClass, fieldName);\n-        }\n-        // ... or if not, just ignore\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n     public AnnotatedMethod(Method method, AnnotationMap classAnn, AnnotationMap[] paramAnnotations)\n     {\n         super(classAnn, paramAnnotations);\n+        if (method == null) {\n+        \tthrow new IllegalArgumentException(\"Can not construct AnnotatedMethod with null Method\");\n+        }\n         _method = method;\n     }\n \n     public Class<?> getDeclaringClass() { return _method.getDeclaringClass(); }\n \n     @Override\n-    public Member getMember() { return _method; }\n+    public Method getMember() { return _method; }\n \n     @Override\n     public void setValue(Object pojo, Object value)\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n     {\n         super(type);\n         _config = config;\n-        _annotationIntrospector = (_config == null) ? null : _config.getAnnotationIntrospector();\n+        _annotationIntrospector = (config == null) ? null : config.getAnnotationIntrospector();\n         _classInfo = classDef;\n         _properties = props;\n     }\n         return result;\n     }\n \n+    @Override\n+    public Class<?> findPOJOBuilder()\n+    {\n+    \treturn (_annotationIntrospector == null) ?\n+    \t\t\tnull : _annotationIntrospector.findPOJOBuilder(_classInfo);\n+    }\n+\n+    @Override\n+    public JsonPOJOBuilder.Value findPOJOBuilderConfig()\n+    {\n+        return (_annotationIntrospector == null) ?\n+                null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods for field introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n \n         // minor optimization: for JDK types do minimal introspection\n         BasicBeanDescription desc = _findCachedDesc(type);\n         if (desc == null) {\n-            desc = BasicBeanDescription.forSerialization(collectProperties(cfg, type, r, true));\n+            desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n+            \t\ttype, r, true, \"set\"));\n         }\n         return desc;\n     }\n         // minor optimization: for JDK types do minimal introspection\n         BasicBeanDescription desc = _findCachedDesc(type);\n         if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false));\n+            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n+            \t\ttype, r, false, \"set\"));\n         }\n         return desc;\n     }\n \n+    @Override\n+    public BasicBeanDescription forDeserializationWithBuilder(DeserializationConfig cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+    \t// no caching for Builders (no standard JDK builder types):\n+    \treturn BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n+            \t\ttype, r, false));\n+    }\n+    \n     @Override\n     public BasicBeanDescription forCreation(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n         BasicBeanDescription desc = _findCachedDesc(type);\n         if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false));\n+            desc = BasicBeanDescription.forDeserialization(\n+            \t\tcollectProperties(cfg, type, r, false, \"set\"));\n         }\n         return desc;\n     }\n      */\n \n     protected POJOPropertiesCollector collectProperties(MapperConfig<?> config,\n-            JavaType type, MixInResolver r, boolean forSerialization)\n+            JavaType type, MixInResolver r, boolean forSerialization,\n+            String mutatorPrefix)\n     {\n         boolean useAnnotations = config.isAnnotationProcessingEnabled();\n         AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n                 (useAnnotations ? config.getAnnotationIntrospector() : null), r);\n-        return constructPropertyCollector(config, ac, type, forSerialization).collect();\n+        return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect();\n+    }\n+    \n+    protected POJOPropertiesCollector collectPropertiesWithBuilder(MapperConfig<?> config,\n+            JavaType type, MixInResolver r, boolean forSerialization)\n+    {\n+        boolean useAnnotations = config.isAnnotationProcessingEnabled();\n+        AnnotationIntrospector ai = useAnnotations ? config.getAnnotationIntrospector() : null;\n+        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), ai, r);\n+        JsonPOJOBuilder.Value builderConfig = (ai == null) ? null : ai.findPOJOBuilderConfig(ac);\n+        String mutatorPrefix = (builderConfig == null) ? \"with\" : builderConfig.withPrefix;\n+        return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect();\n     }\n \n     /**\n      */\n     protected POJOPropertiesCollector constructPropertyCollector(MapperConfig<?> config,\n             AnnotatedClass ac, JavaType type,\n-            boolean forSerialization)\n+            boolean forSerialization, String mutatorPrefix)\n     {\n-        return new POJOPropertiesCollector(config, forSerialization, type, ac);\n+        return new POJOPropertiesCollector(config, forSerialization, type, ac, mutatorPrefix);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n     public ObjectIdInfo findObjectIdInfo() {\n         return null;\n     }\n+\n+    /**\n+     * Method used to check if this property is expected to have a value;\n+     * and if none found, should either be considered invalid (and most likely\n+     * fail deserialization), or handled by other means (by providing default\n+     * value)\n+     */\n+    public boolean isRequired() {\n+        return false;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n      * Factory method that constructs an introspector that has all\n      * information needed for serialization purposes.\n      */\n-    public abstract BeanDescription forSerialization(SerializationConfig cfg, JavaType type,\n-            MixInResolver r);\n+    public abstract BeanDescription forSerialization(SerializationConfig cfg,\n+    \t\tJavaType type, MixInResolver r);\n \n     /**\n      * Factory method that constructs an introspector that has all\n      * information needed for deserialization purposes.\n      */\n-    public abstract BeanDescription forDeserialization(DeserializationConfig cfg, JavaType type,\n-            MixInResolver r);\n+    public abstract BeanDescription forDeserialization(DeserializationConfig cfg,\n+    \t\tJavaType type, MixInResolver r);\n+\n+    /**\n+     * Factory method that constructs an introspector that has all\n+     * information needed for constructing deserializers that use\n+     * intermediate Builder objects.\n+     */\n+    public abstract BeanDescription forDeserializationWithBuilder(DeserializationConfig cfg,\n+    \t\tJavaType type, MixInResolver r);\n     \n     /**\n      * Factory method that constructs an introspector that has\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     }\n \n     @Override\n+    public Boolean hasRequiredMarker(AnnotatedMember m)\n+    {\n+        JsonProperty ann = m.getAnnotation(JsonProperty.class);\n+        if (ann != null) {\n+            return ann.required();\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n     public Object findInjectableValueId(AnnotatedMember m)\n     {\n         JacksonInject ann = m.getAnnotation(JacksonInject.class);\n         // no 'null' marker yet, so:\n         return (ann == null) ? null : ann.value();\n     }\n+\n+    @Override\n+    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n+    {\n+    \tJsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class);\n+    \treturn ((ann == null) || (ann.builder() == NoClass.class)) ?\n+    \t\t\tnull : ann.builder();\n+    }\n+\n+    @Override\n+    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n+    {\n+        JsonPOJOBuilder ann = ac.getAnnotation(JsonPOJOBuilder.class);\n+        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n     protected final VisibilityChecker<?> _visibilityChecker;\n \n     protected final AnnotationIntrospector _annotationIntrospector;\n+\n+    protected final String _mutatorPrefix;\n     \n     /*\n     /**********************************************************\n      */\n     \n     protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization,\n-            JavaType type, AnnotatedClass classDef)\n+            JavaType type, AnnotatedClass classDef, String mutatorPrefix)\n     {\n         _config = config;\n         _forSerialization = forSerialization;\n         _type = type;\n         _classDef = classDef;\n+        _mutatorPrefix = (mutatorPrefix == null) ? \"set\" : mutatorPrefix;\n         _annotationIntrospector = config.isAnnotationProcessingEnabled() ?\n                 _config.getAnnotationIntrospector() : null;\n         if (_annotationIntrospector == null) {\n             return null;\n         }\n         return _annotationIntrospector.findObjectIdInfo(_classDef);\n+    }\n+\n+    /**\n+     * Method for finding Class to use as POJO builder, if any.\n+     */\n+    public Class<?> findPOJOBuilderClass()\n+    {\n+    \treturn _annotationIntrospector.findPOJOBuilder(_classDef);\n     }\n     \n     // for unit tests:\n         final AnnotationIntrospector ai = _annotationIntrospector;\n         \n         for (AnnotatedMethod m : _classDef.memberMethods()) {\n-            String explName; // from annotation(s)\n-            String implName; // from naming convention\n-            \n             /* For methods, handling differs between getters and setters; and\n              * we will also only consider entries that either follow the bean\n              * naming convention or are explicitly marked: just being visible\n              * is not enough (unlike with fields)\n              */\n             int argCount = m.getParameterCount();\n-            boolean visible;\n-            \n             if (argCount == 0) { // getters (including 'any getter')\n-                // any getter?\n-                if (ai != null) {\n-                    if (ai.hasAnyGetterAnnotation(m)) {\n-                        if (_anyGetters == null) {\n-                            _anyGetters = new LinkedList<AnnotatedMember>();\n-                        }\n-                        _anyGetters.add(m);\n-                        continue;\n-                    }\n-                    // @JsonValue?\n-                    if (ai.hasAsValueAnnotation(m)) {\n-                        if (_jsonValueGetters == null) {\n-                            _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n-                        }\n-                        _jsonValueGetters.add(m);\n-                        continue;\n-                    }\n-                }\n-                \n-                explName = (ai == null) ? null : ai.findSerializationName(m);\n-                if (explName == null) { // no explicit name; must follow naming convention\n-                    implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n-                    if (implName == null) { // if not, must skip\n-                        implName = BeanUtil.okNameForIsGetter(m, m.getName());\n-                        if (implName == null) {\n-                            continue;\n-                        }\n-                        visible = _visibilityChecker.isIsGetterVisible(m);\n-                    } else {\n-                        visible = _visibilityChecker.isGetterVisible(m);\n-                    }\n-                } else { // explicit indication of inclusion, but may be empty\n-                    // we still need implicit name to link with other pieces\n-                    implName = BeanUtil.okNameForGetter(m);\n-                    // if not regular getter name, use method name as is\n-                    if (implName == null) {\n-                        implName = m.getName();\n-                    }\n-                    if (explName.length() == 0) {\n-                        explName = implName;\n-                    }\n-                    visible = true;\n-                }\n-                boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n-                _property(implName).addGetter(m, explName, visible, ignore);\n+            \t_addGetterMethod(m, ai);\n             } else if (argCount == 1) { // setters\n-                explName = (ai == null) ? null : ai.findDeserializationName(m);\n-                if (explName == null) { // no explicit name; must follow naming convention\n-                    implName = BeanUtil.okNameForSetter(m);\n-                    if (implName == null) { // if not, must skip\n-                        continue;\n-                    }\n-                    visible = _visibilityChecker.isSetterVisible(m);\n-                } else { // explicit indication of inclusion, but may be empty\n-                    // we still need implicit name to link with other pieces\n-                    implName = BeanUtil.okNameForSetter(m);\n-                    // if not regular getter name, use method name as is\n-                    if (implName == null) {\n-                        implName = m.getName();\n-                    }\n-                    if (explName.length() == 0) { \n-                        explName = implName;\n-                    }\n-                    visible = true;\n-                }\n-                boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n-                _property(implName).addSetter(m, explName, visible, ignore);\n-\n+            \t_addSetterMethod(m, ai);\n             } else if (argCount == 2) { // any getter?\n                 if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n                     if (_anySetters == null) {\n         }\n     }\n \n+    protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)\n+    {\n+        // any getter?\n+        if (ai != null) {\n+            if (ai.hasAnyGetterAnnotation(m)) {\n+                if (_anyGetters == null) {\n+                    _anyGetters = new LinkedList<AnnotatedMember>();\n+                }\n+                _anyGetters.add(m);\n+                return;\n+            }\n+            // @JsonValue?\n+            if (ai.hasAsValueAnnotation(m)) {\n+                if (_jsonValueGetters == null) {\n+                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n+                }\n+                _jsonValueGetters.add(m);\n+                return;\n+            }\n+        }\n+        String implName; // from naming convention\n+        boolean visible;\n+        \n+        String explName = (ai == null) ? null : ai.findSerializationName(m);\n+        if (explName == null) { // no explicit name; must follow naming convention\n+            implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+            if (implName == null) { // if not, must skip\n+                implName = BeanUtil.okNameForIsGetter(m, m.getName());\n+                if (implName == null) {\n+                    return;\n+                }\n+                visible = _visibilityChecker.isIsGetterVisible(m);\n+            } else {\n+                visible = _visibilityChecker.isGetterVisible(m);\n+            }\n+        } else { // explicit indication of inclusion, but may be empty\n+            // we still need implicit name to link with other pieces\n+            implName = BeanUtil.okNameForGetter(m);\n+            // if not regular getter name, use method name as is\n+            if (implName == null) {\n+                implName = m.getName();\n+            }\n+            if (explName.length() == 0) {\n+                explName = implName;\n+            }\n+            visible = true;\n+        }\n+        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n+        _property(implName).addGetter(m, explName, visible, ignore);\n+    }\n+\n+    protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)\n+    {\n+        String implName; // from naming convention\n+        boolean visible;\n+        String explName = (ai == null) ? null : ai.findDeserializationName(m);\n+        if (explName == null) { // no explicit name; must follow naming convention\n+            implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            if (implName == null) { // if not, must skip\n+            \treturn;\n+            }\n+            visible = _visibilityChecker.isSetterVisible(m);\n+        } else { // explicit indication of inclusion, but may be empty\n+            // we still need implicit name to link with other pieces\n+            implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+            // if not regular getter name, use method name as is\n+            if (implName == null) {\n+                implName = m.getName();\n+            }\n+            if (explName.length() == 0) { \n+                explName = implName;\n+            }\n+            visible = true;\n+        }\n+        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n+        _property(implName).addSetter(m, explName, visible, ignore);\n+    }\n+    \n     protected void _addInjectables()\n     {\n         final AnnotationIntrospector ai = _annotationIntrospector;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n     protected Linked<AnnotatedMethod> _setters;\n     \n-    public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector,\n-            boolean forSerialization)\n+    public POJOPropertyBuilder(String internalName,\n+            AnnotationIntrospector annotationIntrospector, boolean forSerialization)\n     {\n         _internalName = internalName;\n         _name = internalName;\n     }\n \n     @Override\n+    public boolean isRequired() {\n+        Boolean b = fromMemberAnnotation(new WithMember<Boolean>() {\n+            @Override public Boolean withMember(AnnotatedMember member) {\n+                return _annotationIntrospector.hasRequiredMarker(member);\n+            }\n+        });\n+        return (b != null) && b.booleanValue();\n+    }\n+    \n+    @Override\n     public ObjectIdInfo findObjectIdInfo() {\n         return fromMemberAnnotation(new WithMember<ObjectIdInfo>() {\n             @Override public ObjectIdInfo withMember(AnnotatedMember member) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n         jgen.writeEndObject();\n     }\n \n-    private final void serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+    private final void serializeWithObjectId(Object bean,\n+            JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         final ObjectIdWriter w = _objectIdWriter;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         }\n         ObjectIdGenerator<?> gen;\n         Class<?> implClass = objectIdInfo.getGeneratorType();\n-        JavaType idType;\n \n         // Just one special case: Property-based generator is trickier\n         if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                     break;\n                 }\n             }\n-            idType = idProp.getType();\n+            JavaType idType = idProp.getType();\n             gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n             // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n             return ObjectIdWriter.construct(idType, null, gen);\n         // other types are simpler\n         JavaType type = prov.constructType(implClass);\n         // Could require type to be passed explicitly, but we should be able to find it too:\n-        idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n         gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n         return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n         }\n         if (generator == null) {\n             generator = generatorType.newForSerialization(this);\n+            _objectIdGenerators.add(generator);\n         }\n         WritableObjectId oid = new WritableObjectId(generator);\n         _seenObjectIds.put(forPojo, oid);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertyBasedObjectIdGenerator.java\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.ser.*;\n \n-public class PropertyBasedObjectIdGenerator extends ObjectIdGenerators.PropertyGenerator\n+public class PropertyBasedObjectIdGenerator\n+\textends ObjectIdGenerators.PropertyGenerator\n {\n     protected final BeanPropertyWriter _property;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n     public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n+        if (_objectIdWriter != null) {\n+            serializeWithObjectId(bean, jgen, provider);\n+            return;\n+        }\n         if (_propertyFilterId != null) {\n             serializeFieldsFiltered(bean, jgen, provider);\n         } else {\n         }\n     }\n \n+    private final void serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final ObjectIdWriter w = _objectIdWriter;\n+        WritableObjectId oid = provider.findObjectId(bean, w.generator);\n+        Object id = oid.id;\n+        \n+        if (id != null) { // have seen before; serialize just id\n+            oid.serializer.serialize(id, jgen, provider);\n+            return;\n+        }\n+        // if not, bit more work:\n+        oid.serializer = w.serializer;\n+        oid.id = id = oid.generator.generateId(bean);\n+        // If not, need to inject the id:\n+        jgen.writeStartObject();\n+        SerializedString name = w.propertyName;\n+        if (name != null) {\n+            jgen.writeFieldName(name);\n+            w.serializer.serialize(id, jgen, provider);\n+        }\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Standard methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\n+import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n /**\n \n     // Type-info-augmented case implemented as it does not usually differ between impls\n     @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n+    public void serializeWithType(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, TypeSerializer typeSer)\n         throws IOException, JsonGenerationException\n     {\n-        if (_typeId != null) {\n-            serializeWithCustomType(bean, jgen, provider, typeSer);\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, typeSer);\n             return;\n         }\n-        typeSer.writeTypePrefixForObject(bean, jgen);\n+\n+        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n+        if (typeStr == null) {\n+            typeSer.writeTypePrefixForObject(bean, jgen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+        }\n         if (_propertyFilterId != null) {\n             serializeFieldsFiltered(bean, jgen, provider);\n         } else {\n             serializeFields(bean, jgen, provider);\n         }\n-        typeSer.writeTypeSuffixForObject(bean, jgen);\n-    }\n-\n-    private final void serializeWithCustomType(Object bean,\n+        if (typeStr == null) {\n+            typeSer.writeTypeSuffixForObject(bean, jgen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+        }\n+    }\n+\n+    private final void _serializeWithObjectId(Object bean,\n             JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonGenerationException\n     {\n-        final Object typeId = _typeId.getValue(bean);\n-        String typeStr;\n-        if (typeId == null) {\n-            typeStr = \"\";\n-        } else {\n-            typeStr = (typeId instanceof String) ? (String) typeId : typeId.toString();\n-        }\n-        typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+        final ObjectIdWriter w = _objectIdWriter;\n+        WritableObjectId oid = provider.findObjectId(bean, w.generator);\n+        Object id = oid.id;\n+        \n+        if (id != null) { // have seen before; serialize just id\n+            oid.serializer.serialize(id, jgen, provider);\n+            return;\n+        }\n+        // if not, bit more work:\n+        oid.serializer = w.serializer;\n+        oid.id = id = oid.generator.generateId(bean);\n+        \n+        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n+        if (typeStr == null) {\n+            typeSer.writeTypePrefixForObject(bean, jgen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+        }\n+\n+        // Very first thing: inject the id property\n+        SerializedString name = w.propertyName;\n+        if (name != null) {\n+            jgen.writeFieldName(name);\n+            w.serializer.serialize(id, jgen, provider);\n+        }\n+\n         if (_propertyFilterId != null) {\n             serializeFieldsFiltered(bean, jgen, provider);\n         } else {\n             serializeFields(bean, jgen, provider);\n         }\n-        typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+        if (typeStr == null) {\n+            typeSer.writeTypeSuffixForObject(bean, jgen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+        }\n+    }\n+    \n+    private final String _customTypeId(Object bean)\n+    {\n+        final Object typeId = _typeId.getValue(bean);\n+        if (typeId == null) {\n+            return \"\";\n+        }\n+        return (typeId instanceof String) ? (String) typeId : typeId.toString();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n         return new TypeBindings(_typeFactory, this, _contextClass, _contextType);\n     }\n \n-    private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type)\n+    private TypeBindings(TypeFactory tf, TypeBindings parent,\n+            Class<?> cc, JavaType type)\n     {\n         _typeFactory = tf;\n         _parentBindings = parent;\n         if (_contextType != null) {\n             int count = _contextType.containedTypeCount();\n             if (count > 0) {\n-                if (_bindings == null) {\n-                    _bindings = new LinkedHashMap<String,JavaType>();\n-                }\n                 for (int i = 0; i < count; ++i) {\n                     String name = _contextType.containedTypeName(i);\n                     JavaType type = _contextType.containedType(i);\n-                    _bindings.put(name, type);\n+                    addBinding(name, type);\n                 }\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n \n     public static String okNameForSetter(AnnotatedMethod am)\n     {\n-        String name = am.getName();\n-        if (name.startsWith(\"set\")) {\n-            name = manglePropertyName(name.substring(3));\n-            if (name == null) { // plain old \"set\" is no good...\n-                return null;\n-            }\n-            if (\"metaClass\".equals(name)) {\n-                // 26-Nov-2009 [JACSON-103], need to suppress this internal groovy method\n-                if (isGroovyMetaClassSetter(am)) {\n-                    return null;\n-                }\n-            }\n-            return name;\n+    \tString name = okNameForMutator(am, \"set\");\n+    \tif (name != null) {\n+\t        // 26-Nov-2009 [JACSON-103], need to suppress this internal groovy method\n+\t        if (\"metaClass\".equals(name)) {\n+\t            if (isGroovyMetaClassSetter(am)) {\n+\t                return null;\n+\t            }\n+\t        }\n+\t        return name;\n+    \t}\n+    \treturn null;\n+    }\n+\n+    public static String okNameForMutator(AnnotatedMethod am, String prefix)\n+    {\n+\t    String name = am.getName();\n+        if (name.startsWith(prefix)) {\n+        \treturn manglePropertyName(name.substring(prefix.length()));\n         }\n         return null;\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n+\n+public class TestBuilderSimple extends BaseMapTest\n+{\n+\t// // Simple 2-property value class, builder with standard naming\n+\t\n+\t@JsonDeserialize(builder=SimpleBuilderXY.class)\n+\tstatic class ValueClassXY\n+\t{\n+\t\tfinal int _x, _y;\n+\n+\t\tprotected ValueClassXY(int x, int y) {\n+\t\t\t_x = x+1;\n+\t\t\t_y = y+1;\n+\t\t}\n+\t}\n+\n+    static class SimpleBuilderXY\n+    {\n+    \tpublic int x, y;\n+    \t\n+    \tpublic SimpleBuilderXY withX(int x) {\n+    \t\tthis.x = x;\n+    \t\treturn this;\n+    \t}\n+\n+    \tpublic SimpleBuilderXY withY(int y) {\n+    \t\tthis.y = y;\n+    \t\treturn this;\n+    \t}\n+\n+    \tpublic ValueClassXY build() {\n+    \t\treturn new ValueClassXY(x, y);\n+    \t}\n+    }\n+\n+\t// // 3-property value, with more varied builder\n+\t\n+\t@JsonDeserialize(builder=BuildABC.class)\n+\tstatic class ValueClassABC\n+\t{\n+\t\tfinal int a, b, c;\n+\n+\t\tprotected ValueClassABC(int a, int b, int c) {\n+\t\t\tthis.a = a;\n+\t\t\tthis.b = b;\n+\t\t\tthis.c = c;\n+\t\t}\n+\t}\n+\n+    static class BuildABC\n+    {\n+    \tpublic int a; // to be used as is\n+    \tprivate int b, c;\n+    \t\n+    \t@JsonProperty(\"b\")\n+    \tpublic BuildABC assignB(int b) {\n+    \t\tthis.b = b;\n+    \t\treturn this;\n+    \t}\n+\n+    \t// Also ok NOT to return 'this'\n+    \t@JsonSetter(\"c\")\n+    \tpublic void c(int c) {\n+    \t\tthis.c = c;\n+    \t}\n+\n+    \tpublic ValueClassABC build() {\n+    \t\treturn new ValueClassABC(a, b, c);\n+    \t}\n+    }\n+\n+    // // Then Builder that is itself immutable\n+    \n+    @JsonDeserialize(builder=BuildImmutable.class)\n+    static class ValueImmutable\n+    {\n+        final int value;\n+        protected ValueImmutable(int v) { value = v; }\n+    }\n+    \n+    static class BuildImmutable {\n+        private final int value;\n+        \n+        private BuildImmutable() { this(0); }\n+        private BuildImmutable(int v) {\n+            value = v;\n+        }\n+        public BuildImmutable withValue(int v) {\n+            return new BuildImmutable(v);\n+        }\n+        public ValueImmutable build() {\n+            return new ValueImmutable(value);\n+        }\n+    }\n+    \n+    // And then with custom naming:\n+\n+\t@JsonDeserialize(builder=BuildFoo.class)\n+\tstatic class ValueFoo\n+\t{\n+\t\tfinal int value;\n+\t\tprotected ValueFoo(int v) { value = v; }\n+\t}\n+\n+\t@JsonPOJOBuilder(withPrefix=\"foo\", buildMethodName=\"construct\")\n+    static class BuildFoo {\n+        private int value;\n+        \n+        public BuildFoo fooValue(int v) {\n+            value = v;\n+            return this;\n+        }\n+        public ValueFoo construct() {\n+            return new ValueFoo(value);\n+        }\n+    }\n+\n+    // And with creator(s)\n+\t\n+    @JsonDeserialize(builder=CreatorBuilder.class)\n+    static class CreatorValue\n+    {\n+        final int a, b, c;\n+\n+        protected CreatorValue(int a, int b, int c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n+\n+    static class CreatorBuilder {\n+        private final int a, b;\n+        private int c;\n+\n+        @JsonCreator\n+        public CreatorBuilder(@JsonProperty(\"a\") int a,\n+                @JsonProperty(\"b\") int b)\n+        {\n+            this.a = a;\n+            this.b = b;\n+        }\n+        \n+        public CreatorBuilder withC(int v) {\n+            c = v;\n+            return this;\n+        }\n+        public CreatorValue build() {\n+            return new CreatorValue(a, b, c);\n+        }\n+    }\n+        \n+\t/*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n+    public void testSimple() throws Exception\n+    {\n+    \tString json = \"{\\\"x\\\":1,\\\"y\\\":2}\";\n+    \tObject o = mapper.readValue(json, ValueClassXY.class);\n+    \tassertNotNull(o);\n+    \tassertSame(ValueClassXY.class, o.getClass());\n+    \tValueClassXY value = (ValueClassXY) o;\n+    \t// note: ctor adds one to both values\n+    \tassertEquals(value._x, 2);\n+    \tassertEquals(value._y, 3);\n+    }\n+\n+    public void testMultiAccess() throws Exception\n+    {\n+    \tString json = \"{\\\"c\\\":3,\\\"a\\\":2,\\\"b\\\":-9}\";\n+    \tValueClassABC value = mapper.readValue(json, ValueClassABC.class);\n+    \tassertNotNull(value);\n+    \t// note: ctor adds one to both values\n+    \tassertEquals(value.a, 2);\n+    \tassertEquals(value.b, -9);\n+    \tassertEquals(value.c, 3);\n+    }\n+\n+    // test for Immutable builder, to ensure return value is used\n+    public void testImmutable() throws Exception\n+    {\n+        final String json = \"{\\\"value\\\":13}\";\n+        ValueImmutable value = mapper.readValue(json, ValueImmutable.class);        \n+        assertEquals(13, value.value);\n+    }\n+\n+    // test with custom 'with-prefix'\n+    public void testCustomWith() throws Exception\n+    {\n+        final String json = \"{\\\"value\\\":1}\";\n+        ValueFoo value = mapper.readValue(json, ValueFoo.class);        \n+        assertEquals(1, value.value);\n+    }\n+\n+    // test to ensure @JsonCreator also work\n+    public void testWithCreator() throws Exception\n+    {\n+        final String json = \"{\\\"a\\\":1,\\\"c\\\":3,\\\"b\\\":2}\";\n+        CreatorValue value = mapper.readValue(json, CreatorValue.class);        \n+        assertEquals(1, value.a);\n+        assertEquals(2, value.b);\n+        assertEquals(3, value.c);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInnerClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInnerClass.java\n         ObjectMapper mapper = new ObjectMapper();\n         Dog input = new Dog(\"Smurf\", true);\n         String json = mapper.writeValueAsString(input);\n-//System.out.println(\"JSON = \"+json);\n         Dog output = mapper.readValue(json, Dog.class);\n         assertEquals(\"Smurf\", output.name);\n         assertNotNull(output.brain);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector;\n+import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n+\n+public class TestBuilderMethods extends BaseMapTest\n+{\n+    static class SimpleBuilder\n+    {\n+    \tpublic int x;\n+    \t\n+    \tpublic SimpleBuilder withX(int x) {\n+    \t\tthis.x = x;\n+    \t\treturn this;\n+    \t}\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n+    public void testSimple()\n+    {\n+        POJOPropertiesCollector coll = collector(SimpleBuilder.class, \"with\");\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"x\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasField());\n+        assertFalse(prop.hasGetter());\n+        assertTrue(prop.hasSetter());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected POJOPropertiesCollector collector(Class<?> cls, String prefix)\n+    {\n+        BasicClassIntrospector bci = new BasicClassIntrospector();\n+        // no real difference between serialization, deserialization, at least here\n+        return bci.collectProperties(mapper.getSerializationConfig(),\n+                mapper.constructType(cls), null, false, prefix);\n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n     public void testSimple()\n     {\n-        POJOPropertiesCollector coll = collector(Simple.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tSimple.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"value\");\n     public void testSimpleFieldVisibility()\n     {\n         // false -> deserialization\n-        POJOPropertiesCollector coll = collector(SimpleFieldDeser.class, false);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tSimpleFieldDeser.class, false);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"values\");\n \n     public void testSimpleGetterVisibility()\n     {\n-        POJOPropertiesCollector coll = collector(SimpleGetterVisibility.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tSimpleGetterVisibility.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"a\");\n     // whole property, unless explicit property marker exists\n     public void testEmpty()\n     {\n-        POJOPropertiesCollector coll = collector(Empty.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tEmpty.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(0, props.size());\n     }\n     // only parts that are ignored are, well, ignored\n     public void testPartialIgnore()\n     {\n-        POJOPropertiesCollector coll = collector(IgnoredSetter.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tIgnoredSetter.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"value\");\n \n     public void testSimpleRenamed()\n     {\n-        POJOPropertiesCollector coll = collector(RenamedProperties.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tRenamedProperties.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"x\");\n \n     public void testSimpleRenamed2()\n     {\n-        POJOPropertiesCollector coll = collector(RenamedProperties2.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tRenamedProperties2.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"renamed\");\n \n     public void testMergeWithRename()\n     {\n-        POJOPropertiesCollector coll = collector(MergedProperties.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tMergedProperties.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"x\");\n     \n     public void testSimpleIgnoreAndRename()\n     {\n-        POJOPropertiesCollector coll = collector(IgnoredRenamedSetter.class, true);\n+        POJOPropertiesCollector coll = collector(mapper,\n+        \t\tIgnoredRenamedSetter.class, true);\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n         POJOPropertyBuilder prop = props.get(\"y\");\n \n     public void testCollectionOfIgnored()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        POJOPropertiesCollector coll = collector(m, ImplicitIgnores.class, false);\n+        POJOPropertiesCollector coll = collector(mapper, ImplicitIgnores.class, false);\n         // should be 1, due to ignorals\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n         assertEquals(1, props.size());\n \n     public void testSimpleOrderingForDeserialization()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        POJOPropertiesCollector coll = collector(m, SortedProperties.class, false);\n+        POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false);\n         List<BeanPropertyDefinition> props = coll.getProperties();\n         assertEquals(4, props.size());\n         assertEquals(\"a\", props.get(0).getName());\n \n     public void testSimpleWithType()\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // first for serialization; should base choice on getter\n         POJOPropertiesCollector coll = collector(mapper, TypeTestBean.class, true);\n         List<BeanPropertyDefinition> props = coll.getProperties();\n     // for [JACKSON-701]\n     public void testInnerClassWithAnnotationsInCreator() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         BasicBeanDescription beanDesc;\n         // first with serialization\n         beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Issue701Bean.class));\n \n     public void testJackson703() throws Exception\n     {\n+    \t// note: need a separate mapper, need to reconfigure\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.configure(MapperFeature.USE_ANNOTATIONS, false);\n         BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));\n \n     public void testJackson744() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         BasicBeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue744Bean.class));\n         assertNotNull(beanDesc);\n         AnnotatedMethod setter = beanDesc.findAnySetter();\n     /**********************************************************\n      */\n \n-    protected POJOPropertiesCollector collector(Class<?> cls, boolean forSerialization)\n-    {\n-        return collector(new ObjectMapper(), cls, forSerialization);\n-    }\n-\n     protected POJOPropertiesCollector collector(ObjectMapper mapper,\n             Class<?> cls, boolean forSerialization)\n     {\n         // no real difference between serialization, deserialization, at least here\n         if (forSerialization) {\n             return bci.collectProperties(mapper.getSerializationConfig(),\n-                    mapper.constructType(cls), null, true);\n+                    mapper.constructType(cls), null, true, \"set\");\n         }\n         return bci.collectProperties(mapper.getDeserializationConfig(),\n-                mapper.constructType(cls), null, false);\n+                mapper.constructType(cls), null, false, \"set\");\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/NodeTestBase.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+\n+abstract class NodeTestBase extends BaseMapTest\n+{\n+    protected void assertNodeNumbersForNonNumeric(JsonNode n)\n+    { \n+        assertFalse(n.isNumber());\n+        assertEquals(0, n.asInt());\n+        assertEquals(-42, n.asInt(-42));\n+        assertEquals(0, n.asLong());\n+        assertEquals(12345678901L, n.asLong(12345678901L));\n+        assertEquals(0.0, n.asDouble());\n+        assertEquals(-19.25, n.asDouble(-19.25));\n+    }\n+    \n+    protected void assertNodeNumbers(JsonNode n, int expInt, double expDouble)\n+    {\n+        assertEquals(expInt, n.asInt());\n+        assertEquals(expInt, n.asInt(-42));\n+        assertEquals((long) expInt, n.asLong());\n+        assertEquals((long) expInt, n.asLong(19L));\n+        assertEquals(expDouble, n.asDouble());\n+        assertEquals(expDouble, n.asDouble(-19.25));\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n         }\n     }\n \n+    static class IdWrapperExt\n+    {\n+        @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class,\n+        \t\tproperty=\"customId\")\n+        public ValueNodeExt node;\n+\n+        public IdWrapperExt() { }\n+        public IdWrapperExt(int v) {\n+            node = new ValueNodeExt(v);\n+        }\n+    }\n+\n+    static class ValueNodeExt\n+    {\n+        public int value;\n+        private int customId;\n+        public IdWrapperExt next;\n+        \n+        public ValueNodeExt() { this(0); }\n+        public ValueNodeExt(int v) { value = v; }\n+\n+        public void setCustomId(int i) {\n+        \tcustomId = i;\n+        }\n+    }\n+    \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n     /*\n         \n     public void testSimpleDeserializationProperty() throws Exception\n     {\n-        // then bring back...\n         IdWrapper result = mapper.readValue(EXP_SIMPLE_INT_PROP, IdWrapper.class);\n         assertEquals(7, result.node.value);\n         assertSame(result.node, result.node.next.node);\n         assertSame(result, result.next);\n     }\n \n+    private final static String EXP_CUSTOM_VIA_PROP = \"{\\\"node\\\":{\\\"customId\\\":3,\\\"value\\\":99,\\\"next\\\":{\\\"node\\\":3}}}\";\n+    \n+    public void testCustomDeserializationProperty() throws Exception\n+    {\n+        // then bring back...\n+    \tIdWrapperExt result = mapper.readValue(EXP_CUSTOM_VIA_PROP, IdWrapperExt.class);\n+        assertEquals(99, result.node.value);\n+        assertSame(result.node, result.node.next.node);\n+        assertEquals(3, result.node.customId);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectIdWithPolymorphic extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n+    static class Base\n+    {\n+        public int value;\n+\n+        public Base next;\n+        \n+        public Base() { this(0); }\n+        public Base(int v) {\n+            value = v;\n+        }\n+    }\n+\n+    static class Impl extends Base\n+    {\n+        public int extra;\n+\n+        public Impl() { this(0, 0); }\n+        public Impl(int v, int e) {\n+            super(v);\n+            extra = e;\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests for polymorphic type handling\n+    /*****************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+\n+    public void testPolymorphicRoundtrip() throws Exception\n+    {\n+        // create simple 2 node loop:\n+        Impl in1 = new Impl(123, 456);\n+        in1.next = new Impl(111, 222);\n+        in1.next.next = in1;\n+        \n+        String json = mapper.writeValueAsString(in1);\n+        \n+        // then bring back...\n+        Base result0 = mapper.readValue(json, Base.class);\n+        assertNotNull(result0);\n+        assertSame(Impl.class, result0.getClass());\n+        Impl result = (Impl) result0;\n+        assertEquals(123, result.value);\n+        assertEquals(456, result.extra);\n+        Impl result2 = (Impl) result.next;\n+        assertEquals(111, result2.value);\n+        assertEquals(222, result2.extra);\n+        assertSame(result, result2.next);\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestGenericSubTyping.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestGenericSubTyping.java\n     \n     static class Document {}\n     static class Row {}\n-    static class RowWithDoc<D extends Document> extends Row { @JsonProperty(\"d\") D d; }\n-    static class ResultSet<R extends Row> { @JsonProperty(\"rows\") List<R> rows; }\n+    static class RowWithDoc<D extends Document> extends Row {\n+        @JsonProperty(\"d\") D d;\n+    }\n+    static class ResultSet<R extends Row> {\n+        @JsonProperty(\"rows\") List<R> rows;\n+    }\n     static class ResultSetWithDoc<D extends Document> extends ResultSet<RowWithDoc<D>> {}\n \n     static class MyDoc extends Document {}\n-\n+    \n     /*\n     /*******************************************************\n     /* Unit tests\n     public void testIssue778() throws Exception\n     {\n         String json = \"{\\\"rows\\\":[{\\\"d\\\":{}}]}\";\n-    \n-        ResultSetWithDoc<MyDoc> rs = new ObjectMapper().readValue(json, new TypeReference<ResultSetWithDoc<MyDoc>>() {});\n-    \n+\n+        ResultSetWithDoc<MyDoc> rs = new ObjectMapper().readValue(json,\n+                new TypeReference<ResultSetWithDoc<MyDoc>>() {});\n         Document d = rs.rows.iterator().next().d;\n     \n         assertEquals(MyDoc.class, d.getClass()); //expected MyDoc but was Document", "timestamp": 1329547213, "metainfo": ""}