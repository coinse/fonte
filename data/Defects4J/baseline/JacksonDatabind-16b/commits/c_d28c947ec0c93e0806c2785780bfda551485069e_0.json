{"sha": "d28c947ec0c93e0806c2785780bfda551485069e", "log": "Merge pull request #552 from geronimo-iia/master  iso 8601 date format", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n import java.text.ParseException;\n \n /**\n- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n- * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+ * \n+ * @see http://www.w3.org/TR/NOTE-datetime\n  */\n public class ISO8601Utils {\n \n      */\n     private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID);\n \n-    /*\n-    /**********************************************************\n-    /* Static factories\n-    /**********************************************************\n-     */\n-    \n+    /* ********************************************************* */\n+    /* Static factories */\n+    /* ********************************************************* */\n+\n     /**\n      * Accessor for static GMT timezone instance.\n      */\n-    public static TimeZone timeZoneGMT() { return TIMEZONE_GMT; }\n-\n-    /*\n-    /**********************************************************\n-    /* Formatting\n-    /**********************************************************\n-     */\n-    \n+    public static TimeZone timeZoneGMT() {\n+        return TIMEZONE_GMT;\n+    }\n+\n+    /* ********************************************************* */\n+    /* Formatting */\n+    /* ********************************************************* */\n+\n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n-     *\n+     * \n      * @param date the date to format\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n      */\n \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n      */\n \n     /**\n      * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n-     * @param tz     timezone to use for the formatting (GMT will produce 'Z')\n+     * @param tz timezone to use for the formatting (GMT will produce 'Z')\n      * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n      */\n     public static String format(Date date, boolean millis, TimeZone tz) {\n         return formatted.toString();\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Parsing\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n+    /* ********************************************************* */\n+    /* Parsing */\n+    /* ********************************************************* */\n+\n+    /**\n+     * Parse a date from ISO-8601 formatted string. It expects a format\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * \n      * @param date ISO string to parse in the appropriate format.\n      * @param pos The position to start parsing from, updated to where parsing stopped.\n      * @return the parsed date\n      * @throws ParseException if the date is not in the appropriate format\n      */\n-    public static Date parse(String date, ParsePosition pos) throws ParseException\n-    {\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n         Exception fail = null;\n         try {\n             int offset = pos.getIndex();\n \n             // extract year\n             int year = parseInt(date, offset, offset += 4);\n-            checkOffset(date, offset, '-');\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract month\n-            int month = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, '-');\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract day\n-            int day = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, 'T');\n-\n-            // extract hours, minutes, seconds and milliseconds\n-            int hour = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int minutes = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int seconds = parseInt(date, offset += 1, offset += 2);\n-            // milliseconds can be optional in the format\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n             int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n-            if (date.charAt(offset) == '.') {\n-                checkOffset(date, offset, '.');\n-                milliseconds = parseInt(date, offset += 1, offset += 3);\n+            if (checkOffset(date, offset, 'T')) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            milliseconds = parseInt(date, offset += 1, offset += 3);\n+                        }\n+                    }\n+                }\n             }\n \n             // extract timezone\n             String timezoneId;\n+            if (date.length() <= offset) {\n+                throw new IndexOutOfBoundsException(\"No time zone indicator \");\n+            }\n             char timezoneIndicator = date.charAt(offset);\n             if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                 String timezoneOffset = date.substring(offset);\n \n             pos.setIndex(offset);\n             return calendar.getTime();\n-            //If we get a ParseException it'll already have the right message/offset.\n-            //Other exception types can convert here.\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n         } catch (IndexOutOfBoundsException e) {\n             fail = e;\n         } catch (NumberFormatException e) {\n         } catch (IllegalArgumentException e) {\n             fail = e;\n         }\n-        String input = (date == null) ? null : ('\"'+date+\"'\");\n-        throw new ParseException(\"Failed to parse date [\"+input\n-            +\"]: \"+fail.getMessage(), pos.getIndex());\n-    }\n-\n-    /**\n-     * Check if the expected character exist at the given offset of the\n-     *\n-     * @param value    the string to check at the specified offset\n-     * @param offset   the offset to look for the expected character\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n      * @param expected the expected character\n-     * @throws IndexOutOfBoundsException if the expected character is not found\n-     */\n-    private static void checkOffset(String value, int offset, char expected) throws ParseException {\n-        char found = value.charAt(offset);\n-        if (found != expected) {\n-            throw new ParseException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\", offset);\n-        }\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return value.length() > offset ? (value.charAt(offset) == expected) : false;\n     }\n \n     /**\n      * Parse an integer located between 2 given offsets in a string\n-     *\n-     * @param value      the string to parse\n+     * \n+     * @param value the string to parse\n      * @param beginIndex the start index for the integer in the string\n-     * @param endIndex   the end index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n      * @return the int\n      * @throws NumberFormatException if the value is not a number\n      */\n \n     /**\n      * Zero pad a number to a specified length\n-     *\n+     * \n      * @param buffer buffer to use for padding\n-     * @param value  the integer value to pad if necessary.\n+     * @param value the integer value to pad if necessary.\n      * @param length the length of the string we should zero pad\n      */\n     private static void padInt(StringBuilder buffer, int value, int length) {\n         buffer.append(strValue);\n     }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.util.*;\n+import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.util.ISO8601Utils;\n \n /**\n  * @see ISO8601Utils\n  */\n-public class ISO8601UtilsTest extends BaseMapTest\n-{\n+public class ISO8601UtilsTest extends BaseMapTest {\n     private Date date;\n+    private Date dateWithoutTime;\n     private Date dateZeroMillis;\n+    private Date dateZeroSecondAndMillis;\n \n     @Override\n-    public void setUp()\n-    {\n+    public void setUp() {\n         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(Calendar.MILLISECOND, 789);\n         date = cal.getTime();\n         cal.set(Calendar.MILLISECOND, 0);\n         dateZeroMillis = cal.getTime();\n+        cal.set(Calendar.SECOND, 0);\n+        dateZeroSecondAndMillis = cal.getTime();\n+        \n+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        dateWithoutTime = cal.getTime();\n+\n     }\n \n     public void testFormat() {\n         assertEquals(date, d);\n     }\n \n+    public void testParseShortDate() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T19:51:23.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T19:51:23Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T21:51:23.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortDateTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseWithoutTime() throws ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+    }\n+\n+    public void testParseWithoutTimeAndTimeZoneMustFail() {\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+    }\n+    \n+    \n+    public void testParseOptional() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T1951Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51+02:00\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n import java.lang.reflect.Modifier;\n \n import com.fasterxml.jackson.core.type.ResolvedType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for type token classes used both to contain information\n \n     @Override\n     public JavaType containedType(int index) { return null; }\n-\n+       \n     @Override\n     public String containedTypeName(int index) { return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API beyond ResolvedType\n+    /**********************************************************\n+     */\n+    \n+    // NOTE: not defined in Resolved type\n+    /**\n+     * Convenience method that is functionally same as:\n+     *<code>\n+     * JavaType t = containedType(index);\n+     * if (t == null) {\n+     *    t = TypeFactory.unknownType();\n+     * }\n+     *</code>\n+     * and typically used to eliminate need for null checks for common case\n+     * where we just want to check if containedType is available first; and\n+     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n+     * basically).\n+     *\n+     * @since 2.5\n+     */\n+    public JavaType containedTypeOrUnknown(int index) {\n+        JavaType t = containedType(index);\n+        return (t == null)  ? TypeFactory.unknownType() : t;\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * Method for enabling automatic inclusion of type information, needed\n      * for proper deserialization of polymorphic types (unless types\n      * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n+     *<P>\n+     * NOTE: use of {@link JsonTypeInfo.As#EXTERNAL_PROPERTY} is <b>NOT SUPPORTED</b>;\n+     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n+     * this limitation explicit.\n      * \n      * @param applicability Defines kinds of types for which additional type information\n      *    is added; see {@link DefaultTyping} for more information.\n      */\n     public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n     {\n+        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n+         *   use \"As.EXTERNAL_PROPERTY\", since that will not work.\n+         */\n+        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n+        }\n+        \n         TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n         // we'll always use full class name, when using defaulting\n         typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n         return _unknownTypeSerializer;\n     }\n \n+    /**\n+     * Helper method called to see if given serializer is considered to be\n+     * something returned by {@link #getUnknownTypeSerializer}, that is, something\n+     * for which no regular serializer was found or constructed.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n+        return (ser == _unknownTypeSerializer) || (ser == null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Methods for creating instances based on annotations\n      * @return Serializer if one can be found, null if not.\n      */\n     protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType)\n-\t\tthrows JsonMappingException\n+        throws JsonMappingException\n     {        \n         // Fast lookup from local lookup thingy works?\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        // If not, maybe shared map already has it?\n-        ser = _serializerCache.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        return _createAndCacheUntypedSerializer(runtimeType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(runtimeType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(runtimeType);\n+                /* 18-Sep-2014, tatu: This is unfortunate patch over related change\n+                 *    that pushes creation of \"unknown type\" serializer deeper down\n+                 *    in BeanSerializerFactory; as a result, we need to \"undo\" creation\n+                 *    here.\n+                 */\n+                if (isUnknownTypeSerializer(ser)) {\n+                    return null;\n+                }\n+            }\n+        }\n+        return ser;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                     // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                     if (ser == null) {\n                         ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n+                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n+                        //   post-processed\n+                        if (ser == null) {\n+                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n+                        }\n                     }\n                 }\n             }\n         \n         JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n         \n-        /* However, after all modifications: no properties, no serializer\n-         * (note; as per [JACKSON-670], check was moved later on from an earlier location)\n-         */\n         if (ser == null) {\n-            /* 27-Nov-2009, tatu: Except that as per [JACKSON-201], we are\n-             *   ok with that as long as it has a recognized class annotation\n-             *  (which may come from a mix-in too)\n-             */\n+            // If we get this far, there were no properties found, so no regular BeanSerializer\n+            // would be constructed. But, couple of exceptions.\n+            // First: if there are known annotations, just create 'empty bean' serializer\n             if (beanDesc.hasKnownClassAnnotations()) {\n                 return builder.createDummy();\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n                  *   to serializer factory at this point... \n                  */\n                 // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-                ser = provider.findPrimaryPropertySerializer(t, _property);\n+                ser = provider.findPrimaryPropertySerializer(t, property);\n                 /* 09-Dec-2010, tatu: Turns out we must add special handling for\n                  *   cases where \"native\" (aka \"natural\") type is being serialized,\n                  *   using standard serializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n         return o;\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n      * Another enum type, but this time forcing sub-classing\n      */\n     enum ComplexChoice {\n-    \tMAYBE(true), PROBABLY_NOT(false);\n-\n-    \tprivate boolean state;\n+        MAYBE(true), PROBABLY_NOT(false);\n+\n+        private boolean state;\n     \t\n-    \tprivate ComplexChoice(boolean b) { state = b; }\n+        private ComplexChoice(boolean b) { state = b; }\n     \t\n         @Override\n-    \tpublic String toString() { return String.valueOf(state); }\n+        public String toString() { return String.valueOf(state); }\n     }\n \n     // [JACKSON-311]\n         assertEquals(\"abc\", ((StringBean) result[0]).name);\n     }\n \n+    // with 2.5, another test to check that \"as-property\" is valid option\n+    public void testBeanAsObjectUsingAsProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL,\n+                \".hype\");\n+        // note: need to wrap, to get declared as Object\n+        String json = m.writeValueAsString(new StringBean(\"abc\"));\n+\n+        System.err.println(\"JSON == \"+json);\n+        \n+        // Ok: serialization seems to work as expected. Now deserialize:\n+        Object result = m.readValue(json, Object.class);\n+        assertNotNull(result);\n+        assertEquals(StringBean.class, result.getClass());\n+        assertEquals(\"abc\", ((StringBean) result).name);\n+    }\n+    \n     /**\n      * Unit test that verifies that an abstract bean is stored with type information\n      * if default type information is enabled for non-concrete types.\n         String json = mapper.writeValueAsString(new BeanHolder(new StringBean(\"punny\")));\n         assertEquals(\"{\\\"bean\\\":{\\\"*CLASS*\\\":\\\"com.fasterxml.jackson.databind.jsontype.TestDefaultForObject$StringBean\\\",\\\"name\\\":\\\"punny\\\"}}\", json);\n     }\n+\n+    public void testNoGoWithExternalProperty() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT,\n+                    JsonTypeInfo.As.EXTERNAL_PROPERTY);\n+            fail(\"Should not have passed\");\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"Can not use includeAs of EXTERNAL_PROPERTY\");\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n @SuppressWarnings(\"serial\")\n public class TestBeanSerializer extends BaseMapTest\n {\n-    /*\n-    /********************************************************\n-    /* Helper types\n-    /********************************************************\n-     */\n-\n-    static class ModuleImpl extends SimpleModule\n+    static class SerializerModifierModule extends SimpleModule\n     {\n         protected BeanSerializerModifier modifier;\n         \n-        public ModuleImpl(BeanSerializerModifier modifier)\n+        public SerializerModifierModule(BeanSerializerModifier modifier)\n         {\n             super(\"test\", Version.unknownVersion());\n             this.modifier = modifier;\n         }\n     }\n \n+    // [Issue#539]: use post-modifier\n+    static class EmptyBeanModifier539 extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            System.err.println(\"DEBUG: changeProperties!\");\n+            return beanProperties;\n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+                BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+System.err.println(\"DEBUG: modifySer!\");            \n+            return new BogusBeanSerializer(42);\n+        }\n+    }\n     // [Issue#120], arrays, collections, maps\n     \n     static class ArraySerializerModifier extends BeanSerializerModifier {\n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        mapper.registerModule(new SerializerModifierModule(new RemovingModifier(\"a\")));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testPropertyReorder() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReorderingModifier()));\n+        mapper.registerModule(new SerializerModifierModule(new ReorderingModifier()));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testBuilderReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));\n+        mapper.registerModule(new SerializerModifierModule(new BuilderModifier(new BogusBeanSerializer(17))));\n         Bean bean = new Bean();\n         assertEquals(\"17\", mapper.writeValueAsString(bean));\n     }    \n     public void testSerializerReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));\n+        mapper.registerModule(new SerializerModifierModule(new ReplacingModifier(new BogusBeanSerializer(123))));\n         Bean bean = new Bean();\n         assertEquals(\"123\", mapper.writeValueAsString(bean));\n     }\n         assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n     }\n \n+    // [Issue#539]\n+    public void testEmptyBean539() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\", Version.unknownVersion()) {\n+            @Override\n+            public void setupModule(SetupContext context)\n+            {\n+                super.setupModule(context);\n+                context.addBeanSerializerModifier(new EmptyBeanModifier539());\n+            }\n+        });\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"42\", json);\n+    }\n+    \n     // [Issue#121]\n \n     public void testModifyArraySerializer() throws Exception", "timestamp": 1411491325, "metainfo": ""}