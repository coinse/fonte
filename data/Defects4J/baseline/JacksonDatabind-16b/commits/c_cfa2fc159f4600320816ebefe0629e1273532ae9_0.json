{"sha": "cfa2fc159f4600320816ebefe0629e1273532ae9", "log": "Implement feature [Issue-11]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      *   objectMapper.convertValue(n, valueClass);\n      *</pre>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> T treeToValue(TreeNode n, Class<T> valueType)\n         throws JsonProcessingException\n     {\n         try {\n+            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n+            if (n.getClass().isAssignableFrom(valueType)) {\n+                return (T) n;\n+            }\n             return readValue(treeAsTokens(n), valueType);\n         } catch (JsonProcessingException e) {\n             throw e;\n     public <T> T convertValue(Object fromValue, Class<T> toValueType)\n         throws IllegalArgumentException\n     {\n+        // sanity check for null first:\n+        if (fromValue == null) return null;\n+        // also, as per [Issue-11], consider case for simple cast\n+        if (fromValue.getClass().isAssignableFrom(toValueType)) {\n+            return (T) fromValue;\n+        }\n         return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n     } \n \n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    public <T> T convertValue(Object fromValue, TypeReference toValueTypeRef)\n+    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n         throws IllegalArgumentException\n     {\n-        return (T) _convert(fromValue, _typeFactory.constructType(toValueTypeRef));\n+        return convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n     } \n \n     @SuppressWarnings(\"unchecked\")\n     public <T> T convertValue(Object fromValue, JavaType toValueType)\n         throws IllegalArgumentException\n     {\n+        // sanity check for null first:\n+        if (fromValue == null) return null;\n+        // also, as per [Issue-11], consider case for simple cast\n+        if (fromValue.getClass().isAssignableFrom(toValueType.getRawClass())) {\n+            return (T) fromValue;\n+        }\n         return (T) _convert(fromValue, toValueType);\n     } \n \n      */\n     protected Object _convert(Object fromValue, JavaType toValueType)\n         throws IllegalArgumentException\n-    {\n-        // sanity check for null first:\n-        if (fromValue == null) return null;\n+    {        \n         /* Then use TokenBuffer, which is a JsonGenerator:\n          * (see [JACKSON-175])\n          */\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n \n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.TreeNode;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n public class TestBeanConversions\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n-    final ObjectMapper mapper = new ObjectMapper();\n+    final ObjectMapper MAPPER = new ObjectMapper();\n \n     static class Point {\n         public int x, y;\n     {\n         // should have no problems convert between compatible beans...\n         PointStrings input = new PointStrings(\"37\", \"-9\");\n-        Point point = mapper.convertValue(input, Point.class);\n+        Point point = MAPPER.convertValue(input, Point.class);\n         assertEquals(37, point.x);\n         assertEquals(-9, point.y);\n         // z not included in input, will be whatever default constructor provides\n         //String json = \"{\\\"boolProp\\\":\\\"oops\\\"}\";\n         // First: unknown property\n         try {\n-            mapper.readValue(\"{\\\"unknownProp\\\":true}\", BooleanBean.class);\n+            MAPPER.readValue(\"{\\\"unknownProp\\\":true}\", BooleanBean.class);\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"unknownProp\");\n         }\n \n         // then bad conversion\n         try {\n-            mapper.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n+            MAPPER.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"boolProp\");\n         }\n     {\n         ObjectWrapper a = new ObjectWrapper(\"foo\");\n         ObjectWrapper b = new ObjectWrapper(a);\n-        ObjectWrapper b2 = mapper.convertValue(b, ObjectWrapper.class);\n-        ObjectWrapper a2 = mapper.convertValue(b2.getData(), ObjectWrapper.class);\n+        ObjectWrapper b2 = MAPPER.convertValue(b, ObjectWrapper.class);\n+        ObjectWrapper a2 = MAPPER.convertValue(b2.getData(), ObjectWrapper.class);\n         assertEquals(\"foo\", a2.getData());\n     }\n \n         _convertAndVerifyPoint(wrappingMapper);\n     }\n \n+    // [Issue-11]: simple cast, for POJOs etc\n+    public void testConvertUsingCast() throws Exception\n+    {\n+        String str = new String(\"foo\");\n+        CharSequence seq = str;\n+        String result = MAPPER.convertValue(seq, String.class);\n+        // should just cast...\n+        assertSame(str, result);\n+    }\n+    \n+    // [Issue-11]: simple cast, for Tree\n+    public void testNodeConvert() throws Exception\n+    {\n+        ObjectNode src = (ObjectNode) MAPPER.readTree(\"{}\");\n+        TreeNode node = src;\n+        ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class);\n+        // should just cast...\n+        assertSame(src, result);\n+    }\n+    \n     private void _convertAndVerifyPoint(ObjectMapper m)\n     {\n         final Point input = new Point(1, 2, 3);\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestStringConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestStringConversions.java\n public class TestStringConversions\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n-    final ObjectMapper mapper = new ObjectMapper();\n+    final ObjectMapper MAPPER = new ObjectMapper();\n \n     public void testSimple()\n     {\n-        assertEquals(Boolean.TRUE, mapper.convertValue(\"true\", Boolean.class));\n-        assertEquals(Integer.valueOf(-3), mapper.convertValue(\"  -3 \", Integer.class));\n-        assertEquals(Long.valueOf(77), mapper.convertValue(\"77\", Long.class));\n+        assertEquals(Boolean.TRUE, MAPPER.convertValue(\"true\", Boolean.class));\n+        assertEquals(Integer.valueOf(-3), MAPPER.convertValue(\"  -3 \", Integer.class));\n+        assertEquals(Long.valueOf(77), MAPPER.convertValue(\"77\", Long.class));\n \n         int[] ints = { 1, 2, 3 };\n         List<Integer> Ints = new ArrayList<Integer>();\n         Ints.add(2);\n         Ints.add(3);\n         \n-        assertArrayEquals(ints, mapper.convertValue(Ints, int[].class));\n+        assertArrayEquals(ints, MAPPER.convertValue(Ints, int[].class));\n     }\n \n     public void testStringsToInts()\n     {\n         // let's verify our \"neat trick\" actually works...\n         assertArrayEquals(new int[] { 1, 2, 3, 4, -1, 0 },\n-                          mapper.convertValue(\"1  2 3    4  -1 0\".split(\"\\\\s+\"), int[].class));\n+                          MAPPER.convertValue(\"1  2 3    4  -1 0\".split(\"\\\\s+\"), int[].class));\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public void testBytesToBase64AndBack() throws Exception\n     {\n         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n-        String encoded = mapper.convertValue(input, String.class);\n+        String encoded = MAPPER.convertValue(input, String.class);\n         assertNotNull(encoded);\n-        byte[] result = mapper.convertValue(encoded, byte[].class);\n+        byte[] result = MAPPER.convertValue(encoded, byte[].class);\n         assertArrayEquals(input, result);\n     }\n     \n-    /**\n-     * @since 1.7.3\n-     */\n     public void testBytestoCharArray() throws Exception\n     {\n         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n         // first, do baseline encoding\n-        char[] expEncoded = mapper.convertValue(input, String.class).toCharArray();\n+        char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray();\n         // then compare\n-        char[] actEncoded = mapper.convertValue(input, char[].class);\n+        char[] actEncoded = MAPPER.convertValue(input, char[].class);\n         assertArrayEquals(expEncoded, actEncoded);\n     }\n }", "timestamp": 1335580288, "metainfo": ""}