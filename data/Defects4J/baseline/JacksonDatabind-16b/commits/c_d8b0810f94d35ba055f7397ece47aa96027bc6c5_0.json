{"sha": "d8b0810f94d35ba055f7397ece47aa96027bc6c5", "log": "Add pre-fetching of serializers in ObjectWriter as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     protected final JavaType _valueType;\n \n     /**\n-     * We will find and (re)use deserializer as soon as {@link #_valueType}\n-     * is known; this allows avoiding further deserializer lookups\n-     * when readers are reused.\n+     * We may pre-fetch deserializer as soon as {@link #_valueType}\n+     * is known, and if so, reuse it afterwards.\n+     * This allows avoiding further deserializer lookups and increases\n+     * performance a bit on cases where readers are reused.\n      * \n      * @since 2.1\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     protected final JavaType _rootType;\n \n     /**\n+     * We may pre-fetch serializer if {@link #_rootType}\n+     * is known, and if so, reuse it afterwards.\n+     * This allows avoiding further serializer lookups and increases\n+     * performance a bit on cases where readers are reused.\n+     * \n+     * @since 2.1\n+     */\n+    protected final JsonSerializer<Object> _rootSerializer;\n+    \n+    /**\n      * To allow for dynamic enabling/disabling of pretty printing,\n      * pretty printer can be optionally configured for writer\n      * as well\n         _rootType = rootType;\n         _prettyPrinter = pp;\n         _schema = null;\n-    }\n-\n-    /**\n-     * Alternative constructor for initial instantiation.\n+\n+        _rootSerializer = _prefetchRootSerializer(config, rootType);\n+    }\n+\n+    /**\n+     * Alternative constructor for initial instantiation by {@link ObjectMapper}\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n         _jsonFactory = mapper._jsonFactory;\n \n         _rootType = null;\n+        _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = null;\n     }\n \n     /**\n-     * Alternative constructor for initial instantiation.\n+     * Alternative constructor for initial instantiation by {@link ObjectMapper}\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config,\n             FormatSchema s)\n         _jsonFactory = mapper._jsonFactory;\n \n         _rootType = null;\n+        _rootSerializer = null;\n         _prettyPrinter = null;\n         _schema = s;\n     }\n      * Copy constructor used for building variations.\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n-            JavaType rootType, PrettyPrinter pp, FormatSchema s)\n+            JavaType rootType, JsonSerializer<Object> rootSer,\n+            PrettyPrinter pp, FormatSchema s)\n     {\n         _config = config;\n \n         _jsonFactory = base._jsonFactory;\n         \n         _rootType = rootType;\n+        _rootSerializer = rootSer;\n         _prettyPrinter = pp;\n         _schema = s;\n     }\n         _schema = base._schema;\n         \n         _rootType = base._rootType;\n+        _rootSerializer = base._rootSerializer;\n         _prettyPrinter = base._prettyPrinter;\n     }\n     \n         if (pp == null) {\n             pp = NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, _config, _rootType, pp, _schema);\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema);\n     }\n \n     /**\n     public ObjectWriter withSchema(FormatSchema schema)\n     {\n         return (_schema == schema) ? this :\n-            new ObjectWriter(this, _config, _rootType, _prettyPrinter, schema);\n+            new ObjectWriter(this, _config, _rootType, _rootSerializer, _prettyPrinter, schema);\n     }\n     \n     /**\n      */\n     public ObjectWriter withType(JavaType rootType)\n     {\n+        JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType);\n         return (rootType == _rootType) ? this\n         // type is stored here, no need to make a copy of config\n-            : new ObjectWriter(this, _config, rootType, _prettyPrinter, _schema);\n+            : new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema);\n     }    \n \n     /**\n             if (_rootType == null) {\n                 _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType);\n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             if (_rootType == null) {\n                 _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType);                \n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             closed = true;\n             jgen.close();\n             if (_rootType == null) {\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value);\n+                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             // [JACKSON-520]: add support for pass-through schema:\n             if (_schema != null) {\n             if (_rootType == null) {\n                 _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value, _rootType);\n+                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n     }\n+\n+    /**\n+     * Method called to locate (root) serializer ahead of time, if permitted\n+     * by configuration. Method also is NOT to throw an exception if\n+     * access fails.\n+     */\n+    protected final JsonSerializer<Object> _prefetchRootSerializer(\n+            SerializationConfig config, JavaType valueType)\n+    {\n+        if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n+            return null;\n+        }\n+        try {\n+            return _serializerProvider(config).findTypedValueSerializer(valueType, true, null);\n+        } catch (JsonProcessingException e) {\n+            // need to swallow?\n+            return null;\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n      \n     /*\n     /******************************************************\n-    /* Data type - specific serialization configuration\n+    /* Datatype-specific serialization configuration\n     /******************************************************\n      */\n \n      *<p>\n      * Feature is disabled by default.\n      */\n-    ORDER_MAP_ENTRIES_BY_KEYS(false)\n-        ;\n+    ORDER_MAP_ENTRIES_BY_KEYS(false),\n+\n+    /*\n+    /******************************************************\n+    /* Other\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether {@link ObjectWriter} should\n+     * try to eagerly fetch necessary {@link JsonSerializer} when\n+     * possible. This improves performance in cases where similarly\n+     * configured {@link ObjectWriter} instance is used multiple\n+     * times; and should not significantly affect single-use cases.\n+     *<p>\n+     * Note that there should not be any need to normally disable this\n+     * feature: only consider that if there are actual perceived problems.\n+     *<p>\n+     * Feature is enabled by default.\n+     * \n+     * @since 2.1\n+     */\n+    EAGER_SERIALIZER_FETCH(true)    \n+    ;\n \n     private final boolean _defaultState;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n  * as well as constructors.\n  *<p>\n  * Note that class is abstract just because it does not\n- * define\n+ * define {@link #createInstance} method.\n+ *<p>\n+ * Also note that all custom {@link SerializerProvider}\n+ * implementations must sub-class this class: {@link ObjectMapper}\n+ * requires this type, not basic provider type.\n  */\n public abstract class DefaultSerializerProvider extends SerializerProvider\n {\n     /**********************************************************\n      */\n \n+    /**\n+     * Per-serialization map Object Ids that have seen so far, iff\n+     * Object Id handling is enabled.\n+     */\n     protected IdentityHashMap<Object, WritableObjectId> _seenObjectIds;\n     \n     protected ArrayList<ObjectIdGenerator<?>> _objectIdGenerators;\n         throws IOException, JsonGenerationException\n     {\n         JsonSerializer<Object> ser;\n-        boolean wrap;\n-\n-        if (value == null) {\n-            // no type provided; must just use the default null serializer\n+        final boolean wrap;\n+\n+        if (value == null) { // no type provided; must just use the default null serializer\n             ser = getDefaultNullValueSerializer();\n             wrap = false; // no name to use for wrapping; can't do!\n         } else {\n             if (wrap) {\n                 jgen.writeEndObject();\n             }\n-        } catch (IOException ioe) {\n-            /* As per [JACKSON-99], should not wrap IOException or its\n-             * sub-classes (like JsonProcessingException, JsonMappingException)\n-             */\n+        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n-        } catch (Exception e) {\n-            // but others are wrapped\n+        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             String msg = e.getMessage();\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value,\n-            JavaType rootType)\n+    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonGenerationException\n     {\n-        boolean wrap;\n+        final boolean wrap;\n \n         JsonSerializer<Object> ser;\n         if (value == null) {\n         }\n     }\n \n+    /**\n+     * The method to be called by {@link ObjectWriter}\n+     * for serializing given value (assumed to be of specified root type,\n+     * instead of runtime type of value), when it may know specific\n+     * {@link JsonSerializer} to use.\n+     * \n+     * @param rootType Type to use for locating serializer to use, instead of actual\n+     *    runtime type, if no serializer is passed\n+     * @param ser Root Serializer to use, if not null\n+     * \n+     * @since 2.1\n+     */\n+    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final boolean wrap;\n+\n+        if (value == null) {\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (rootType != null) {\n+                if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                    _reportIncompatibleRootType(value, rootType);\n+                }\n+            }\n+            // root value, not reached via property:\n+            if (ser == null) {\n+                ser = findTypedValueSerializer(rootType, true, null);\n+            }\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+    \n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n      * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n--- a/src/test/java/perf/ManualObjectReaderPerf.java\n+++ b/src/test/java/perf/ManualObjectReaderPerf.java\n     {\n         final byte[] input = mapper.writeValueAsBytes(inputValue);\n         \n-        // Let's try to guestimate suitable size... to get to 6 megs to process\n-        final int REPS = (int) ((double) (6 * 1000 * 1000) / (double) input.length);\n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        final int REPS = (int) ((double) (8 * 1000 * 1000) / (double) input.length);\n \n         System.out.println(\"Read \"+input.length+\" bytes to hash; will do \"+REPS+\" repetitions\");\n \n         ObjectMapper m = new ObjectMapper();\n         new ManualObjectReaderPerf().test(m, input, Record.class);\n     }\n-    \n-    /**\n-     * Simple test class \n-     */\n-    protected final static class Record\n-    {\n-        public int age;\n-        public String firstName, lastName;\n-        public char gender;\n-        public boolean insured;\n-\n-        public Record() { }\n-        public Record(int a, String fn, String ln, char g, boolean ins)\n-        {\n-            age = a;\n-            firstName = fn;\n-            lastName = ln;\n-            gender = g;\n-            insured = ins;\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/test/java/perf/ManualObjectWriterPerf.java\n+package perf;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class ManualObjectWriterPerf\n+{\n+    protected int hash;\n+    \n+    private <T> void test(ObjectMapper mapper, T inputValue, Class<T> inputClass)\n+        throws Exception\n+    {\n+        final int REPS;\n+        {\n+            final byte[] input = mapper.writeValueAsBytes(inputValue);\n+            \n+            // Let's try to guestimate suitable size, N megs of output\n+            REPS = (int) ((double) (9 * 1000 * 1000) / (double) input.length);\n+            System.out.println(\"Read \"+input.length+\" bytes to hash; will do \"+REPS+\" repetitions\");\n+        }\n+\n+        final ObjectWriter prefetching = mapper.writerWithType(inputClass);\n+        final ObjectWriter nonPrefetching = mapper.writer()\n+                .without(SerializationFeature.EAGER_SERIALIZER_FETCH)\n+                .withType(inputClass);\n+        \n+        int i = 0;\n+        int roundsDone = 0;\n+        final int TYPES = 2;\n+        final int WARMUP_ROUNDS = 5;\n+\n+        final long[] times = new long[TYPES];\n+\n+        while (true) {\n+            final NopOutputStream out = new NopOutputStream();\n+            try {  Thread.sleep(100L); } catch (InterruptedException ie) { }\n+            int round = (i++ % TYPES);\n+\n+            String msg;\n+            boolean lf = (round == 0);\n+\n+            long msecs;\n+            ObjectWriter writer;\n+            \n+            switch (round) {\n+            case 0:\n+                msg = \"Pre-fetch\";\n+                writer = prefetching;\n+                break;\n+            case 1:\n+                msg = \"NO pre-fetch\";\n+                writer = nonPrefetching;\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            msecs = testSer(REPS, inputValue, writer, out);\n+\n+            // skip first 5 rounds to let results stabilize\n+            if (roundsDone >= WARMUP_ROUNDS) {\n+                times[round] += msecs;\n+            }\n+            \n+            System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n+            if (lf) {\n+                ++roundsDone;\n+                if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                    double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                    System.out.printf(\"Averages after %d rounds (pre / no): %.1f / %.1f msecs\\n\",\n+                            (int) den,\n+                            times[0] / den, times[1] / den);\n+                            \n+                }\n+                System.out.println();\n+            }\n+            if ((i % 17) == 0) {\n+                System.out.println(\"[GC]\");\n+                Thread.sleep(100L);\n+                System.gc();\n+                Thread.sleep(100L);\n+            }\n+        }\n+    }\n+\n+    private final long testSer(int REPS, Object value, ObjectWriter writer, NopOutputStream out) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        while (--REPS >= 0) {\n+            writer.writeValue(out, value);\n+        }\n+        hash = out.size();\n+        return System.currentTimeMillis() - start;\n+    }\n+\n+    public static void main(String[] args) throws Exception\n+    {\n+        if (args.length != 0) {\n+            System.err.println(\"Usage: java ...\");\n+            System.exit(1);\n+        }\n+        Record input = new Record(44, \"BillyBob\", \"Bumbler\", 'm', true);\n+        ObjectMapper m = new ObjectMapper();\n+        new ManualObjectWriterPerf().test(m, input, Record.class);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/NopOutputStream.java\n+package perf;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+public class NopOutputStream extends OutputStream\n+{\n+    protected int size = 0;\n+    \n+    public NopOutputStream() { }\n+\n+    @Override\n+    public void write(int b) throws IOException { ++size; }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException { size += b.length; }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int len) throws IOException { size += len; }\n+\n+    public int size() { return size; }\n+}\n--- /dev/null\n+++ b/src/test/java/perf/Record.java\n+package perf;\n+\n+/**\n+ * Simple test class \n+ */\n+final class Record\n+{\n+    public int age;\n+    public String firstName, lastName;\n+    public char gender;\n+    public boolean insured;\n+\n+    public Record() { }\n+    public Record(int a, String fn, String ln, char g, boolean ins)\n+    {\n+        age = a;\n+        firstName = fn;\n+        lastName = ln;\n+        gender = g;\n+        insured = ins;\n+    }\n+}", "timestamp": 1340924929, "metainfo": ""}