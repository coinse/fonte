{"sha": "00cb595db4c680b53b0248e49129a8f9c96ca52e", "log": "Merging from upstream", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n  * In first case these defaults must follow \"config-then-use\" patterns\n  * (i.e. defined once, not changed afterwards); all per-call\n  * changes must be done using {@link ObjectReader}.\n+ *<p>\n+ * Note that features that do not indicate version of inclusion\n+ * were available in Jackson 2.0 (or earlier); only later additions\n+ * indicate version of inclusion.\n  */\n public enum DeserializationFeature implements ConfigFeature\n {\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForScalars.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForScalars.java\n \n import static org.junit.Assert.*;\n \n-\n import com.fasterxml.jackson.databind.*;\n \n /**\n  * Unit tests to verify that Java/JSON scalar values (non-structured values)\n  * are handled properly with respect to additional type information.\n- * \n- * @since 1.5\n- * @author tatu\n  */\n public class TestDefaultForScalars\n     extends BaseMapTest\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestNodeTypingIssue88.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestNodeTypingIssue88 extends BaseMapTest\n+{\n+    public static class Foo {\n+        public String bar;\n+\n+        public Foo() { }\n+        public Foo(String b) { bar = b; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testValueAsStringWithDefaultTyping() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        String json = mapper.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueToTreeWithDefaultTyping() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = mapper.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * values to the corresponding value type.  This is basically the opposite of the {@link #ACCEPT_SINGLE_VALUE_AS_ARRAY}\n      * feature.  If more than one value is found in the array, a JsonMappingException is thrown.\n      * <p>\n-     * Feature is disabled by default.\n-     * \n+     * \n+     * Feature is disabled by default\n      * @since 2.4\n      */\n     UNWRAP_SINGLE_VALUE_ARRAYS(false),\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n                             );\n                 }\n                 return value;\n-            } else if (t == JsonToken.VALUE_NULL && !_valueClass.isPrimitive()) {\n-                //Issue#unreported\n-                //  This handles the case where the value required is the Character wrapper class and the token is the null token\n-                return getEmptyValue();\n             }\n             throw ctxt.mappingException(_valueClass, t);\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n     final static class FloatBean {\n         float _v;\n         void setV(float v) { _v = v; }\n+    }\n+    \n+    final static class CharacterBean {\n+        char _v;\n+        void setV(char v) { _v = v; }\n+        char getV() { return _v; }\n+    }\n+    \n+    final static class CharacterWrapperBean {\n+        Character _v;\n+        void setV(Character v) { _v = v; }\n+        Character getV() { return _v; }\n     }\n \n     /**\n         // But can also pass in ascii code\n         result = MAPPER.readValue(new StringReader(\" \"+((int) 'X')), Character.class);\n         assertEquals(Character.valueOf('X'), result);\n+        \n+        final CharacterWrapperBean wrapper = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), CharacterWrapperBean.class);\n+        assertNotNull(wrapper);\n+        assertNull(wrapper.getV());\n+        \n+        final ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);\n+            mapper.readValue(\"{\\\"v\\\":null}\", CharacterBean.class);\n+            fail(\"Attempting to deserialize a 'null' JSON reference into a 'char' property did not throw an exception\");\n+        } catch (JsonMappingException exp) {\n+            //Exception thrown as required\n+        }\n+        \n+        mapper.disable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);  \n+        final CharacterBean charBean = MAPPER.readValue(new StringReader(\"{\\\"v\\\":null}\"), CharacterBean.class);\n+        assertNotNull(wrapper);\n+        assertEquals('\\u0000', charBean.getV());\n     }\n \n     public void testIntWrapper() throws Exception", "timestamp": 1389471334, "metainfo": ""}