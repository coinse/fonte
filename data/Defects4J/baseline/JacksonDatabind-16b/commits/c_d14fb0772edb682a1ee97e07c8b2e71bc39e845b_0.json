{"sha": "d14fb0772edb682a1ee97e07c8b2e71bc39e845b", "log": "Completing [Issue-29], ability to (de)serialize POJOs to/from JSON Arrays, to condense output", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n import java.lang.reflect.Method;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n     \n     /*\n     /**********************************************************\n+    /* Basic API, class configuration\n+    /**********************************************************\n+     */\n+\n+    public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n+\n+    /**\n+     * Method for checking what is the expected format for POJO, as\n+     * defined by defaults and possible annotations.\n+     * Note that this may be further refined by per-property annotations.\n+     * \n+     * @since 2.1s\n+     */\n+    public abstract JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue);\n+    \n+    /*\n+    /**********************************************************\n     /* Basic API, other\n     /**********************************************************\n      */\n \n     public abstract Map<Object, AnnotatedMember> findInjectables();\n-\n-    public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n-\n+    \n     /**\n      * Method for checking if the POJO type has annotations to\n      * indicate that a builder is to be used for instantiating\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     @Override\n     public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n         return new BeanDeserializer(this, ignorableProps);\n+    }\n+\n+    @Override\n+    protected BeanDeserializerBase asArrayDeserializer() {\n+        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n+        return new BeanAsArrayDeserializer(this, props);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import java.lang.reflect.InvocationTargetException;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n      * Annotations from the bean class: used for accessing\n      * annotations during resolution phase (see {@link #resolve}).\n      */\n-    final protected Annotations _classAnnotations;\n+    final private Annotations _classAnnotations;\n     \n     /**\n      * Declared type of the bean this deserializer handles.\n      */\n     final protected JavaType _beanType;\n \n+    /**\n+     * Requested shape from bean class annotations.\n+     */\n+    final protected JsonFormat.Shape _serializationShape;\n+    \n     /*\n     /**********************************************************\n     /* Configuration for creating value instance\n             || !_valueInstantiator.canCreateUsingDefault()\n             ;\n \n-        _needViewProcesing = hasViews;    \n-\n+        // Any transformation we may need to apply?\n+        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+        _serializationShape = (format == null) ? null : format.getShape();\n+        \n+        _needViewProcesing = hasViews;\n         _vanillaProcessing = !_nonStandardCreation\n                 && (_injectables == null)\n                 && !_needViewProcesing\n         _nonStandardCreation = src._nonStandardCreation;\n         _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n         _needViewProcesing = src._needViewProcesing;\n+        _serializationShape = src._serializationShape;\n \n         _vanillaProcessing = src._vanillaProcessing;\n     }\n             _beanProperties = src._beanProperties;\n         }\n         _needViewProcesing = src._needViewProcesing;\n+        _serializationShape = src._serializationShape;\n+\n         // probably adds a twist, so:\n         _vanillaProcessing = false;\n     }\n         _nonStandardCreation = src._nonStandardCreation;\n         _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n         _needViewProcesing = src._needViewProcesing;\n+        _serializationShape = src._serializationShape;\n \n         _vanillaProcessing = src._vanillaProcessing;\n \n         _nonStandardCreation = src._nonStandardCreation;\n         _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n         _needViewProcesing = src._needViewProcesing;\n+        _serializationShape = src._serializationShape;\n \n         _vanillaProcessing = src._vanillaProcessing;\n         _objectIdReader = src._objectIdReader;\n \n     public abstract BeanDeserializerBase withIgnorableProperties(HashSet<String> ignorableProps);\n \n+    /**\n+     * Fluent factory for creating a variant that can handle\n+     * POJO output as a JSON Array. Implementations may ignore this request\n+     * if no such input is possible.\n+     * \n+     * @since 2.1\n+     */\n+    protected abstract BeanDeserializerBase asArrayDeserializer();\n+    \n     /*\n     /**********************************************************\n     /* Validation, post-processing\n      * Although most of post-processing is done in resolve(), we only get\n      * access to referring property's annotations here; and this is needed\n      * to support per-property ObjectIds.\n+     * We will also consider Shape transformations (read from Array) at this\n+     * point, since it may come from either Class definition or property.\n      */\n //  @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n \n         // First: may have an override for Object Id:\n         final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n         if (property != null && intr != null) {\n-            final AnnotatedMember accessor = property.getMember();\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n             if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n             HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals);\n             contextual = contextual.withIgnorableProperties(newIgnored);\n         }\n+\n+        // One more thing: are we asked to serialize POJO as array?\n+        JsonFormat.Shape shape = null;\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+\n+            if (format != null) {\n+                shape = format.getShape();\n+            }\n+        }\n+        if (shape == null) {\n+            shape = _serializationShape;\n+        }\n+        if (shape == JsonFormat.Shape.ARRAY) {\n+            contextual = contextual.asArrayDeserializer();\n+        }\n         return contextual;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n /**\n  * Builder class used for aggregating deserialization information about\n  * a POJO, in order to build a {@link JsonDeserializer} for deserializing\n- * intances.\n+ * instances.\n  */\n public class BeanDeserializerBuilder\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n  * refactor this in future.\n  */\n public class BuilderBasedDeserializer\n-\textends BeanDeserializerBase\n+    extends BeanDeserializerBase\n {\n     protected final AnnotatedMethod _buildMethod;\n \t\n     @Override\n     public BuilderBasedDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n         return new BuilderBasedDeserializer(this, ignorableProps);\n+    }\n+\n+    @Override\n+    protected BuilderBasedDeserializer asArrayDeserializer() {\n+        /* 17-Jul-2012, tatu: Should be doable, but for now let's just not\n+         *   support this combination, and instead wait for an RFE to see\n+         *   if anyone cares.\n+         */\n+        throw new UnsupportedOperationException(\"Can not combine serialization-as-Array with Builder style construction\");\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n     /**\n      * Method called to assign given value to this property, on\n      * specified Object.\n+     *<p>\n+     * Note: this is an optional operation, not supported by all\n+     * implementations, creator-backed properties for example do not\n+     * support this method.\n      */\n     public abstract void set(Object instance, Object value)\n         throws IOException;\n      * Method called to assign given value to this property, on\n      * specified Object, and return whatever delegating accessor\n      * returned (if anything)\n+     *<p>\n+     * Note: this is an optional operation, not supported by all\n+     * implementations, creator-backed properties for example do not\n+     * support this method.\n      * \n      * @since 2.0\n      */\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Variant of {@link BeanDeserializer} used for handling deserialization\n+ * of POJOs when serialized as JSON Arrays, instead of JSON Objects.\n+ * \n+ * @since 2.1\n+ */\n+public class BeanAsArrayDeserializer\n+    extends BeanDeserializerBase\n+{\n+    /**\n+     * Deserializer we delegate operations that we can not handle.\n+     */\n+    protected final BeanDeserializerBase _delegate;\n+\n+    /**\n+     * Properties in order expected to be found in JSON array.\n+     */\n+    protected final SettableBeanProperty[] _orderedProperties;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main constructor used both for creating new instances (by\n+     * {@link BeanDeserializer#asArrayDeserializer}) and for\n+     * creating copies with different delegate.\n+     */\n+    public BeanAsArrayDeserializer(BeanDeserializerBase delegate,\n+            SettableBeanProperty[] ordered)\n+    {\n+        super(delegate);\n+        _delegate = delegate;\n+        _orderedProperties = ordered;\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n+    {\n+        /* We can't do much about this; could either replace _delegate\n+         * with unwrapping instance, or just replace this one. Latter seems\n+         * more sensible.\n+         */\n+        return _delegate.unwrappingDeserializer(unwrapper);\n+    }\n+\n+    @Override\n+    public BeanAsArrayDeserializer withObjectIdReader(ObjectIdReader oir) {\n+        return new BeanAsArrayDeserializer(_delegate.withObjectIdReader(oir),\n+                _orderedProperties);\n+    }\n+\n+    @Override\n+    public BeanAsArrayDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n+        return new BeanAsArrayDeserializer(_delegate.withIgnorableProperties(ignorableProps),\n+                _orderedProperties);\n+    }\n+\n+    @Override\n+    protected BeanDeserializerBase asArrayDeserializer() {\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        // common case first:\n+        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n+            return _delegate.deserialize(jp, ctxt);\n+        }\n+        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        final SettableBeanProperty[] props = _orderedProperties;\n+        int i = 0;\n+        final int propCount = props.length;\n+        while (true) {\n+            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+                return bean;\n+            }\n+            if (i == propCount) {\n+                break;\n+            }\n+            SettableBeanProperty prop = props[i];\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, prop.getName(), ctxt);\n+                }\n+            } else { // just skip?\n+                jp.skipChildren();\n+            }\n+            ++i;\n+        }\n+        \n+        // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n+        if (!_ignoreAllUnknown) {\n+            throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n+        }\n+        // otherwise, skip until end\n+        while (jp.nextToken() != JsonToken.END_ARRAY) {\n+            jp.skipChildren();\n+        }\n+        return bean;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n     private final int _hashMask;\n \n     private final int _size;\n-    \n+\n+    /**\n+     * Counter we use to keep track of insertion order of properties\n+     * (to be able to recreate insertion order when needed).\n+     *<p>\n+     * Note: is kept up-to-date with additions, but can NOT handle\n+     * removals (i.e. \"holes\" may be left)\n+     */\n+    private int _nextBucketIndex = 0;\n+\n     public BeanPropertyMap(Collection<SettableBeanProperty> properties)\n     {\n         _size = properties.size();\n         for (SettableBeanProperty property : properties) {\n             String key = property.getName();\n             int index = key.hashCode() & _hashMask;\n-            buckets[index] = new Bucket(buckets[index], key, property);\n+            buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++);\n         }\n         _buckets = buckets;\n     }\n \n-    private BeanPropertyMap(Bucket[] buckets, int size)\n+    private BeanPropertyMap(Bucket[] buckets, int size, int index)\n     {\n         _buckets = buckets;\n         _size = size;\n         _hashMask = buckets.length-1;\n+        _nextBucketIndex = index;\n     }\n     \n     /**\n         // and then see if it's add or replace:\n     \tSettableBeanProperty oldProp = find(newProperty.getName());\n     \tif (oldProp == null) { // add\n-        \t// first things first: add or replace?\n-\t        // can do a straight copy, since all additions are at the front\n-\t        // and then insert the new property:\n-\t        int index = propName.hashCode() & _hashMask;\n-\t        newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty);\n-\t        return new BeanPropertyMap(newBuckets, _size+1);\n+    \t    // first things first: add or replace?\n+    \t    // can do a straight copy, since all additions are at the front\n+    \t    // and then insert the new property:\n+    \t    int index = propName.hashCode() & _hashMask;\n+    \t    newBuckets[index] = new Bucket(newBuckets[index],\n+    \t            propName, newProperty, _nextBucketIndex++);\n+    \t    return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n     \t}\n     \t// replace: easy, close + replace\n-    \tBeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount);\n+    \tBeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n     \tnewMap.replace(newProperty);\n     \treturn newMap;\n     }\n         return new IteratorImpl(_buckets);\n     }\n     \n+    /**\n+     * Method that will re-create initial insertion-ordering of\n+     * properties contained in this map. Note that if properties\n+     * have been removed, array may contain nulls; otherwise\n+     * it should be consecutive.\n+     * \n+     * @since 2.1\n+     */\n+    public SettableBeanProperty[] getPropertiesInInsertionOrder()\n+    {\n+        int len = _nextBucketIndex;\n+        SettableBeanProperty[] result = new SettableBeanProperty[len];\n+        for (Bucket root : _buckets) {\n+            for (Bucket bucket = root; bucket != null; bucket = bucket.next) {\n+                result[bucket.index] = bucket.value;\n+            }\n+        }\n+        return result;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API\n          * are immutable, so we need to recreate the chain. Fine.\n          */\n         Bucket tail = null;\n-        boolean found = false;\n-\n+        int foundIndex = -1;\n         \n         for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) {\n             // match to remove?\n-            if (!found && bucket.key.equals(name)) {\n-                found = true;\n+            if (foundIndex < 0 && bucket.key.equals(name)) {\n+                foundIndex = bucket.index;\n             } else {\n-                tail = new Bucket(tail, bucket.key, bucket.value);\n+                tail = new Bucket(tail, bucket.key, bucket.value, bucket.index);\n             }\n         }\n         // Not finding specified entry is error, so:\n-        if (!found) {\n+        if (foundIndex < 0) {\n             throw new NoSuchElementException(\"No entry '\"+property+\"' found, can't replace\");\n         }\n         /* So let's attach replacement in front: useful also because\n          * it allows replacement even when iterating over entries\n          */\n-        _buckets[index] = new Bucket(tail, name, property);\n+        _buckets[index] = new Bucket(tail, name, property, foundIndex);\n     }\n \n     /**\n             if (!found && bucket.key.equals(name)) {\n                 found = true;\n             } else {\n-                tail = new Bucket(tail, bucket.key, bucket.value);\n+                tail = new Bucket(tail, bucket.key, bucket.value, bucket.index);\n             }\n         }\n         if (!found) { // must be found\n         public final Bucket next;\n         public final String key;\n         public final SettableBeanProperty value;\n+\n+        /**\n+         * Index that indicates insertion order of the bucket\n+         */\n+        public final int index;\n         \n-        public Bucket(Bucket next, String key, SettableBeanProperty value)\n+        public Bucket(Bucket next, String key, SettableBeanProperty value, int index)\n         {\n             this.next = next;\n             this.key = key;\n             this.value = value;\n+            this.index = index;\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n import java.lang.reflect.Method;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n \n     /*\n     /**********************************************************\n+    /* General per-class annotation introspection\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue)\n+    {\n+        if (_annotationIntrospector != null) {\n+            JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo);\n+            if (v != null) {\n+                return v;\n+            }\n+        }\n+        return defValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Introspection for serialization, factories\n     /**********************************************************\n      */\n         }\n         return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);\n     }\n-\n+    \n     /**\n      * Method used to locate the method of introspected class that\n      * implements {@link com.fasterxml.jackson.annotation.JsonAnyGetter}.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n     \n     /*\n     /**********************************************************\n-    /* Collected information\n+    /* Collected property information\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 2.1\n-     */\n-    public SerializationConfig getConfig() { return _config; }\n-\n     public AnnotatedClass getClassInfo() { return _beanDesc.getClassInfo(); }\n     \n     public BeanDescription getBeanDescription() { return _beanDesc; }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n             _anyGetterWriter = builder.getAnyGetter();\n             _propertyFilterId = builder.getFilterId();\n             _objectIdWriter = builder.getObjectIdWriter();\n-            AnnotationIntrospector ai = builder.getConfig().getAnnotationIntrospector();\n-            AnnotatedClass ac = builder.getClassInfo();\n-            JsonFormat.Value format = (ai == null) ? null : ai.findFormat(ac);\n+            JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null);\n             _serializationShape = (format == null) ? null : format.getShape();\n         }\n     }", "timestamp": 1342576164, "metainfo": ""}