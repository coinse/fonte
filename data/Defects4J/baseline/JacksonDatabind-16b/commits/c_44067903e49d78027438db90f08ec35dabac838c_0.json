{"sha": "44067903e49d78027438db90f08ec35dabac838c", "log": "Additional fix wrt #572", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import java.lang.reflect.Method;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n public class EnumDeserializer\n     extends StdScalarDeserializer<Enum<?>>\n {\n-    private static final long serialVersionUID = -5893263645879532318L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final EnumResolver<?> _resolver;\n     \n     {\n         // note: caller has verified there's just one arg; but we must verify its type\n         Class<?> paramClass = factory.getRawParameterType(0);\n-        if (paramClass == String.class) {\n-            paramClass = null;\n-        } else  if (paramClass == Integer.TYPE || paramClass == Integer.class) {\n-            paramClass = Integer.class;\n-        } else  if (paramClass == Long.TYPE || paramClass == Long.class) {\n-            paramClass = Long.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory\n-                    +\") not suitable, must be java.lang.String or int/Integer/long/Long\");\n-        }\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n      * for locating Enum values by String id.\n      */\n     protected static class FactoryBasedDeserializer\n-        extends StdScalarDeserializer<Object>\n-    {\n-        private static final long serialVersionUID = -7775129435872564122L;\n-\n-        protected final Class<?> _enumClass;\n+        extends StdDeserializer<Object>\n+        implements ContextualDeserializer\n+    {\n+        private static final long serialVersionUID = 1;\n+\n         // Marker type; null if String expected; otherwise numeric wrapper\n         protected final Class<?> _inputType;\n         protected final Method _factory;\n+        protected final JsonDeserializer<?> _deser;\n         \n         public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f,\n                 Class<?> inputType)\n         {\n-            super(Enum.class);\n-            _enumClass = cls;\n+            super(cls);\n             _factory = f.getAnnotated();\n             _inputType = inputType;\n-        }\n-\n+            _deser = null;\n+        }\n+\n+        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,\n+                JsonDeserializer<?> deser) {\n+            super(base._valueClass);\n+            _inputType = base._inputType;\n+            _factory = base._factory;\n+            _deser = deser;\n+        }\n+        \n         @Override\n-        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property)\n+            throws JsonMappingException\n         {\n-            // couple of accepted types...\n+            if ((_deser == null) && (_inputType != String.class)) {\n+                return new FactoryBasedDeserializer(this,\n+                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n             Object value;\n-            if (_inputType == null) {\n-                value = jp.getText();\n-            } else  if (_inputType == Integer.class) {\n-                value = Integer.valueOf(jp.getValueAsInt());\n-            } else  if (_inputType == Long.class) {\n-                value = Long.valueOf(jp.getValueAsLong());\n+            if (_deser != null) {\n+                value = _deser.deserialize(jp, ctxt);\n             } else {\n-                throw ctxt.mappingException(_enumClass);\n+                value = jp.getValueAsString();\n             }\n             try {\n-                return _factory.invoke(_enumClass, value);\n+                return _factory.invoke(_valueClass, value);\n             } catch (Exception e) {\n                 Throwable t = ClassUtil.getRootCause(e);\n                 if (t instanceof IOException) {\n                     throw (IOException) t;\n                 }\n-                throw ctxt.instantiationException(_enumClass, t);\n-            }\n+                throw ctxt.instantiationException(_valueClass, t);\n+            }\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n+            if (_deser == null) { // String never has type info\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     \n     protected final Class<?> _enumClass;\n \n-    protected JsonDeserializer<Enum<?>> _keyDeserializer;\n+    protected KeyDeserializer _keyDeserializer;\n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**********************************************************\n      */\n \n-    public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n         super(mapType);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n-        _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n+        _keyDeserializer = keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n     }\n \n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n     {\n         if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         // note: instead of finding key deserializer, with enums we actually\n         // work with regular deserializers (less code duplication; but not\n         // quite as clean as it ought to be)\n-        JsonDeserializer<?> kd = _keyDeserializer;\n+        KeyDeserializer kd = _keyDeserializer;\n         if (kd == null) {\n-            kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property);\n+            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n         }\n         JsonDeserializer<?> vd = _valueDeserializer;\n         if (vd == null) {\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n+        while ((jp.nextToken()) == JsonToken.FIELD_NAME) {\n             String keyName = jp.getCurrentName(); // just for error message\n             // but we need to let key deserializer handle it separately, nonetheless\n-            Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n+            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n             if (key == null) {\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                    String value = null;\n-                    try { // bit ugly, but will have to do; works with usual scalars\n-                        if (jp.hasCurrentToken()) {\n-                            value = jp.getText();\n-                        }\n-                    } catch (Exception e) { }\n-                    throw ctxt.weirdStringException(value, _enumClass, \"value not one of declared Enum instance names\");\n+                    throw ctxt.weirdStringException(keyName, _enumClass, \"value not one of declared Enum instance names for \"\n+                            +_mapType.getKeyType());\n                 }\n                 /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n                  *  just skip the entry then. But we must skip the value as well, if so.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n             return _parseLong(key);\n \n         case TYPE_FLOAT:\n-            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n-             *   here, so let's not bother even trying...\n-             */\n+            // Bounds/range checks would be tricky here, so let's not bother even trying...\n             return Float.valueOf((float) _parseDouble(key));\n         case TYPE_DOUBLE:\n             return _parseDouble(key);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n public class StdKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable\n {\n-    private static final long serialVersionUID = 923268084968181479L;\n+    private static final long serialVersionUID = 1L;\n     \n     public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) {\n         return new StdKeyDeserializer.EnumKD(enumResolver, null);\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n public class SimpleKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -6786398737835438187L;\n+    private static final long serialVersionUID = 1L;\n \n     protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n import java.util.EnumMap;\n import java.util.EnumSet;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n             return TestEnum.valueOf(jp.getText().toUpperCase());\n         }\n     }\n-    \n+\n     protected enum EnumWithCreator {\n         A, B;\n \n         public static EnumWithCreator fromEnum(String str) {\n             if (\"enumA\".equals(str)) return A;\n             if (\"enumB\".equals(str)) return B;\n+            return null;\n+        }\n+    }\n+\n+    protected enum EnumWithBDCreator {\n+        E5, E8;\n+\n+        @JsonCreator\n+        public static EnumWithBDCreator create(BigDecimal bd) {\n+            if (bd.longValue() == 5L) return E5;\n+            if (bd.longValue() == 8L) return E8;\n             return null;\n         }\n     }\n     }\n \n     // [JACKSON-193]\n-    public void testCreatorEnums() throws Exception\n-    {\n+    public void testCreatorEnums() throws Exception {\n         EnumWithCreator value = MAPPER.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n+    }\n+\n+    public void testCreatorEnumsFromBigDecimal() throws Exception {\n+        EnumWithBDCreator value = MAPPER.readValue(\"\\\"8.0\\\"\", EnumWithBDCreator.class);\n+        assertEquals(EnumWithBDCreator.E8, value);\n     }\n     \n     // [JACKSON-212]\n     // [JACKSON-834]\n     public void testEnumsFromInts() throws Exception\n     {\n-        TestEnumFor834 res = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n-        assertSame(TestEnumFor834.ENUM_A, res);\n+        Object ob = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n+        assertEquals(TestEnumFor834.class, ob.getClass());\n+        assertSame(TestEnumFor834.ENUM_A, ob);\n     }\n \n     // [Issue#141]: allow mapping of empty String into null", "timestamp": 1413169579, "metainfo": ""}