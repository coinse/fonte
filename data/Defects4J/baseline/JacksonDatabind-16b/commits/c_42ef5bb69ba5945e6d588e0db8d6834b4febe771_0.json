{"sha": "42ef5bb69ba5945e6d588e0db8d6834b4febe771", "log": "Fixed #653", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n      * us, which may be declaration order, but is not guaranteed).\n      *<p>\n      * Note that this is just the default behavior, and can be overridden by\n-     * explicit overrides in classes.\n+     * explicit overrides in classes (for example with\n+     * {@link com.fasterxml.jackson.annotation.JsonPropertyOrder} annotation)\n      *<p>\n      * Feature is disabled by default.\n      */\n      * @since 2.1\n      */\n     USE_WRAPPER_NAME_AS_PROPERTY_NAME(false),\n-    \n+\n+    /**\n+     * Feature that may be enabled to enforce strict compatibility with\n+     * Bean name introspection, instead of slightly different mechanism\n+     * Jackson defaults to.\n+     * Specific difference is that Jackson always lower cases leading upper-case\n+     * letters, so \"getURL()\" becomes \"url\" property; whereas standard Bean\n+     * naming <b>only</b> lower-cases the first letter if it is NOT followed by\n+     * another upper-case letter (so \"getURL()\" would result in \"URL\" property).\n+     *<p>\n+     * Feature is disabled by default for backwards compatibility purposes: earlier\n+     * Jackson versions used Jackson's own mechanism.\n+     *\n+     * @since 2.5\n+     */\n+    USE_STD_BEAN_NAMING(false),\n+\n     /*\n     /******************************************************\n     /* Other features\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n      *   precedence for serialization annotations), or not (false, deserialization)\n      */\n     protected final boolean _forSerialization;\n-    \n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected final boolean _stdBeanNaming;\n+\n     /**\n      * Type of POJO for which properties are being collected.\n      */\n             JavaType type, AnnotatedClass classDef, String mutatorPrefix)\n     {\n         _config = config;\n+        _stdBeanNaming = config.isEnabled(MapperFeature.USE_STD_BEAN_NAMING);\n         _forSerialization = forSerialization;\n         _type = type;\n         _classDef = classDef;\n         if (!nameExplicit) { // no explicit name; must consider implicit\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+                implName = BeanUtil.okNameForRegularGetter(m, m.getName(), _stdBeanNaming);\n             }\n             if (implName == null) { // if not, must skip\n-                implName = BeanUtil.okNameForIsGetter(m, m.getName());\n+                implName = BeanUtil.okNameForIsGetter(m, m.getName(), _stdBeanNaming);\n                 if (implName == null) {\n                     return;\n                 }\n             // we still need implicit name to link with other pieces\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForGetter(m);\n+                implName = BeanUtil.okNameForGetter(m, _stdBeanNaming);\n             }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n         if (!nameExplicit) { // no explicit name; must follow naming convention\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n             }\n             if (implName == null) { // if not, must skip\n             \treturn;\n             // we still need implicit name to link with other pieces\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n             }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n {\n     /*\n     /**********************************************************\n-    /* Handling \"getter\" names\n-    /**********************************************************\n-     */\n-\n-    public static String okNameForGetter(AnnotatedMethod am)\n-    {\n+    /* Handling property names\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForGetter(AnnotatedMethod am, boolean stdNaming) {\n         String name = am.getName();\n-        String str = okNameForIsGetter(am, name);\n+        String str = okNameForIsGetter(am, name, stdNaming);\n         if (str == null) {\n-            str = okNameForRegularGetter(am, name);\n+            str = okNameForRegularGetter(am, name, stdNaming);\n         }\n         return str;\n     }\n-\n-    public static String okNameForRegularGetter(AnnotatedMethod am, String name)\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForRegularGetter(AnnotatedMethod am, String name,\n+            boolean stdNaming)\n     {\n         if (name.startsWith(\"get\")) {\n             /* 16-Feb-2009, tatu: To handle [JACKSON-53], need to block\n                     return null;\n                 }\n             } else if (\"getMetaClass\".equals(name)) {\n-                /* 30-Apr-2009, tatu: [JACKSON-103], need to suppress\n-                 *    serialization of a cyclic (and useless) reference\n-                 */\n+                // 30-Apr-2009, tatu: Need to suppress serialization of a cyclic reference\n                 if (isGroovyMetaClassGetter(am)) {\n                     return null;\n                 }\n             }\n-            return manglePropertyName(name.substring(3));\n-        }\n-        return null;\n-    }\n-\n-    public static String okNameForIsGetter(AnnotatedMethod am, String name)\n-    {\n-        if (name.startsWith(\"is\")) {\n-            // plus, must return boolean...\n+            return stdNaming\n+                    ? stdManglePropertyName(name, 3)\n+                    : legacyManglePropertyName(name, 3);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForIsGetter(AnnotatedMethod am, String name,\n+            boolean stdNaming)\n+    {\n+        if (name.startsWith(\"is\")) { // plus, must return a boolean\n             Class<?> rt = am.getRawType();\n-            if (rt != Boolean.class && rt != Boolean.TYPE) {\n-                return null;\n-            }\n-            return manglePropertyName(name.substring(2));\n-        }\n-        // no, not a match by name\n-        return null;\n-    }\n-\n-    public static String okNameForSetter(AnnotatedMethod am)\n-    {\n-        String name = okNameForMutator(am, \"set\");\n-        if (name != null) {\n-            // 26-Nov-2009 [JACSON-103], need to suppress this internal groovy method\n-            if (\"metaClass\".equals(name)) {\n-                if (isGroovyMetaClassSetter(am)) {\n-                    return null;\n-                }\n-            }\n+            if (rt == Boolean.class || rt == Boolean.TYPE) {\n+                return stdNaming\n+                        ? stdManglePropertyName(name, 2)\n+                        : legacyManglePropertyName(name, 2);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForSetter(AnnotatedMethod am, boolean stdNaming) {\n+        String name = okNameForMutator(am, \"set\", stdNaming);\n+        if ((name != null) \n+            // 26-Nov-2009, tatu: need to suppress this internal groovy method\n+                && (!\"metaClass\".equals(name) || !isGroovyMetaClassSetter(am))) {\n             return name;\n         }\n         return null;\n     }\n \n-    public static String okNameForMutator(AnnotatedMethod am, String prefix)\n-    {\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForMutator(AnnotatedMethod am, String prefix,\n+            boolean stdNaming) {\n         String name = am.getName();\n         if (name.startsWith(prefix)) {\n-            return manglePropertyName(name.substring(prefix.length()));\n-        }\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods for bean property name handling\n+            return stdNaming\n+                    ? stdManglePropertyName(name, prefix.length())\n+                    : legacyManglePropertyName(name, prefix.length());\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Handling property names, deprecated methods\n+    /**********************************************************\n+     */\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForGetter(AnnotatedMethod am) {\n+        return okNameForGetter(am, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForRegularGetter(AnnotatedMethod am, String name) {\n+        return okNameForRegularGetter(am, name, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForIsGetter(AnnotatedMethod am, String name) {\n+        return okNameForIsGetter(am, name, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForSetter(AnnotatedMethod am) {\n+        return okNameForSetter(am, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForMutator(AnnotatedMethod am, String prefix) {\n+        return okNameForMutator(am, prefix, false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Special case handling\n     /**********************************************************\n      */\n \n         return false;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Actual name mangling methods\n+    /**********************************************************\n+     */\n+\n     /**\n      * Method called to figure out name of the property, given \n      * corresponding suggested name based on a method or field name.\n      * @param basename Name of accessor/mutator method, not including prefix\n      *  (\"get\"/\"is\"/\"set\")\n      */\n-    protected static String manglePropertyName(String basename)\n-    {\n-        int len = basename.length();\n-\n-        // First things first: empty basename is no good\n-        if (len == 0) {\n+    protected static String legacyManglePropertyName(final String basename, final int offset)\n+    {\n+        final int end = basename.length();\n+        if (end == offset) { // empty name, nope\n             return null;\n         }\n         // otherwise, lower case initial chars\n         StringBuilder sb = null;\n-        for (int i = 0; i < len; ++i) {\n+        for (int i = offset; i < end; ++i) {\n             char upper = basename.charAt(i);\n             char lower = Character.toLowerCase(upper);\n             if (upper == lower) {\n                 break;\n             }\n             if (sb == null) {\n-                sb = new StringBuilder(basename);\n-            }\n-            sb.setCharAt(i, lower);\n-        }\n-        return (sb == null) ? basename : sb.toString();\n-    }\n-\n-    /* 17-Dec-2014, tatu: This is how it should really work; need to figure out\n-     *     a good way to phase this in.\n-     */\n-/*\n-    protected static String manglePropertyName(String basename)\n-    {\n-        int len = basename.length();\n-\n-        // First things first: empty basename is no good\n-        if (len == 0) {\n+                int l = end-offset;\n+                sb = new StringBuilder(l);\n+                sb.append(basename, offset, end);\n+            }\n+            sb.setCharAt(i-offset, lower);\n+        }\n+        return (sb == null) ? basename.substring(offset) : sb.toString();\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected static String stdManglePropertyName(final String basename, final int offset)\n+    {\n+        final int end = basename.length();\n+        if (end == offset) { // empty name, nope\n             return null;\n         }\n         // first: if it doesn't start with capital, return as-is\n-        char c0 = basename.charAt(0);\n+        char c0 = basename.charAt(offset);\n         char c1 = Character.toLowerCase(c0);\n         if (c0 == c1) {\n-            return basename;\n+            return basename.substring(offset);\n         }\n         // 17-Dec-2014, tatu: As per [databind#653], need to follow more\n         //   closely Java Beans spec; specifically, if two first are upper-case,\n         //   then no lower-casing should be done.\n-        if (len > 1) {\n-            if (Character.isUpperCase(basename.charAt(1))) {\n-                return basename;\n-            }\n-        }\n-        StringBuilder sb = new StringBuilder(basename);\n-        sb.setCharAt(0, c1);\n+        if ((offset + 1) < end) {\n+            if (Character.isUpperCase(basename.charAt(offset+1))) {\n+                return basename.substring(offset);\n+            }\n+        }\n+        StringBuilder sb = new StringBuilder(end - offset);\n+        sb.append(c1);\n+        sb.append(basename, offset+1, end);\n         return sb.toString();\n     }\n-*/\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/BeanNamingTest.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+// Tests for [databind#653]\n+public class BeanNamingTest extends BaseMapTest\n+{\n+    static class URLBean {\n+        public String getURL() {\n+            return \"http://foo\";\n+        }\n+    }\n+\n+    static class ABean {\n+        public int getA() {\n+            return 3;\n+        }\n+    }\n+    \n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(MapperFeature.USE_STD_BEAN_NAMING));\n+        assertEquals(aposToQuotes(\"{'url':'http://foo'}\"),\n+                mapper.writeValueAsString(new URLBean()));\n+        assertEquals(aposToQuotes(\"{'a':3}\"),\n+                mapper.writeValueAsString(new ABean()));\n+\n+        mapper = new ObjectMapper();\n+        mapper.enable(MapperFeature.USE_STD_BEAN_NAMING);\n+        assertEquals(aposToQuotes(\"{'URL':'http://foo'}\"),\n+                mapper.writeValueAsString(new URLBean()));\n+        assertEquals(aposToQuotes(\"{'a':3}\"),\n+                mapper.writeValueAsString(new ABean()));\n+    }\n+}", "timestamp": 1418964310, "metainfo": ""}