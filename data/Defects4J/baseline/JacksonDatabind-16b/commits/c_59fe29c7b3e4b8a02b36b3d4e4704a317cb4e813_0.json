{"sha": "59fe29c7b3e4b8a02b36b3d4e4704a317cb4e813", "log": "Yet more work, trying to allow distinguishing of 'primary' and 'secondary' serializers, wrt property-context", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n \n     /**\n      * Method called for primary property deserializers (ones\n-     * directly created to deal with an annotatable POJO property),\n+     * directly created to deserialize values of a POJO property),\n      * to handle details of resolving\n      * {@link ContextualDeserializer} with given property context.\n      * \n      * for structured types, or deserializers for root values)\n      * to handle details of resolving\n      * {@link ContextualDeserializer} with given property context.\n-     * Given that these serializers are not directly related to given property\n+     * Given that these deserializers are not directly related to given property\n      * (or, in case of root value property, to any property), annotations\n      * accessible may or may not be relevant.\n      * \n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.*;\n             }\n         }\n         // at this point, resolution has occured, but not contextualization\n-        return (JsonSerializer<Object>) handleContextualization(ser, property);\n+        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n     /**\n                 }\n             }\n         }\n-        return (JsonSerializer<Object>) handleContextualization(ser, property);\n+        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n+    }\n+\n+    /**\n+     * Similar to {@link #findValueSerializer(JavaType, BeanProperty)}, but used\n+     * when finding \"primary\" property value serializer (one directly handling\n+     * value of the property). Difference has to do with contextual resolution,\n+     * and method(s) called: this method should only be called when caller is\n+     * certain that this is the primary property value serializer.\n+     * \n+     * @param property Property that is being handled; will never be null, and its\n+     *    type has to match <code>valueType</code> parameter.\n+     * \n+     * @since 2.3\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> findPrimaryPropertySerializer(JavaType valueType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(valueType);\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    // Should this be added to lookups?\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                    return ser;\n+                }\n+            }\n+        }\n+        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> findPrimaryPropertySerializer(Class<?> valueType,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    ser = _createAndCacheUntypedSerializer(valueType);\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                        return ser;\n+                    }\n+                }\n+            }\n+        }\n+        return (JsonSerializer<Object>) handlePrimaryContextualization(ser, property);\n     }\n     \n     /**\n      */\n \n     /**\n-     * Method that should be called to take of possible calls to resolve\n-     * {@link ContextualSerializer} with given property context (if any;\n-     * none for root-value serializers).\n+     * Method called for primary property serializers (ones\n+     * directly created to serialize values of a POJO property),\n+     * to handle details of resolving\n+     * {@link ContextualSerializer} with given property context.\n+     * \n+     * @param property Property for which the given primary serializer is used; never null.\n+     * \n+     * @since 2.3\n+     */\n+    public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (ser != null) {\n+            if (ser instanceof ContextualSerializer) {\n+                ser = ((ContextualSerializer) ser).createContextual(this, property);\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method called for secondary property serializers (ones\n+     * NOT directly created to serialize values of a POJO property\n+     * but instead created as a dependant serializer -- such as value serializers\n+     * for structured types, or serializers for root values)\n+     * to handle details of resolving\n+     * {@link ContextualDeserializer} with given property context.\n+     * Given that these serializers are not directly related to given property\n+     * (or, in case of root value property, to any property), annotations\n+     * accessible may or may not be relevant.\n      * \n      * @param property Property for which serializer is used, if any; null\n-     *    when serializing root values\n+     *    when deserializing root values\n      * \n      * @since 2.3\n      */\n-    public JsonSerializer<?> handleContextualization(JsonSerializer<?> ser,\n+    public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n         if (ser instanceof ResolvableSerializer) {\n             ((ResolvableSerializer) ser).resolve(this);\n         }\n-        return (JsonSerializer<Object>) handleContextualization(ser, property);\n+        return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n     // Note: NOT part of ResolvableSerializer...\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n-        _serializer = (MapSerializer) provider.handleContextualization(_serializer, _property);\n+        // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n+        _serializer = (MapSerializer) provider.handlePrimaryContextualization(_serializer, _property);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         PropertySerializerMap.SerializerAndMapResult result;\n         if (_nonTrivialBaseType != null) {\n             JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n-            result = map.findAndAddSerializer(t, provider, this);\n+            result = map.findAndAddPrimarySerializer(t, provider, this);\n         } else {\n-            result = map.findAndAddSerializer(type, provider, this);\n+            result = map.findAndAddPrimarySerializer(type, provider, this);\n         }\n         // did we get a new map of serializers? If so, start using it\n         if (map != result.map) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         // Does member specify a serializer? If so, let's use it.\n         JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                 accessor);\n-        /* 02-Feb-2012, tatu: Unlike most other codepaths, Serializer produced\n+        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n          *  here will NOT be resolved or contextualized, unless done here, so:\n          */\n         if (annotatedSerializer instanceof ResolvableSerializer) {\n             ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n         }\n-        annotatedSerializer = prov.handleContextualization(annotatedSerializer, property);\n+        // 05-Sep-2013, tatu: should be primary property serializer so:\n+        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n         if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n         if (ser == null) {\n             ser = provider.findValueSerializer(String.class, property);\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         // Optimization: default serializer just writes String, so we can avoid a call:\n         if (isDefaultSerializer(ser)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n     public abstract JsonSerializer<Object> serializerFor(Class<?> type);\n \n     /**\n-     * Method called if initial lookup fails; will both find serializer\n-     * and construct new map instance if warranted, and return both\n+     * Method called if initial lookup fails, when looking for a non-primary\n+     * serializer (one that is not directly attached to a property).\n+     * Will both find serializer\n+     * and construct new map instance if warranted, and return both.\n+     * \n+     * @since 2.3\n+     * \n      * @throws JsonMappingException \n      */\n-    public final SerializerAndMapResult findAndAddSerializer(Class<?> type,\n+    public final SerializerAndMapResult findAndAddSecondarySerializer(Class<?> type,\n             SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n         return new SerializerAndMapResult(serializer, newWith(type, serializer));\n     }\n \n-    public final SerializerAndMapResult findAndAddSerializer(JavaType type,\n+    public final SerializerAndMapResult findAndAddSecondarySerializer(JavaType type,\n             SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n \n+    /**\n+     * Method called if initial lookup fails, when looking for a primary\n+     * serializer (one that is directly attached to a property).\n+     * Will both find serializer\n+     * and construct new map instance if warranted, and return both.\n+     * \n+     * @since 2.3\n+     * \n+     * @throws JsonMappingException \n+     */\n+    public final SerializerAndMapResult findAndAddPrimarySerializer(Class<?> type,\n+            SerializerProvider provider, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findPrimaryPropertySerializer(type, property);\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    public final SerializerAndMapResult findAndAddPrimarySerializer(JavaType type,\n+            SerializerProvider provider, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findPrimaryPropertySerializer(type, property);\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+    \n     public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n     \n     public static PropertySerializerMap emptyMap() {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n         if (ser == null) {\n             ser = provider.findValueSerializer(String.class, property);\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         // Optimization: default serializer just writes String, so we can avoid a call:\n         if (isDefaultSerializer(ser)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n         if (ser == null) {\n             ser = provider.findValueSerializer(String.class, property);\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         // Optimization: default serializer just writes String, so we can avoid a call:\n         if (isDefaultSerializer(ser)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n                 }\n             }\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) {\n             return withResolved(property, typeSer, ser);\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         // did we get a new map of serializers? If so, start using it\n         if (map != result.map) {\n             _dynamicSerializers = result.map;\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             JavaType type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         if (map != result.map) {\n             _dynamicSerializers = result.map;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n                 return withValueSerializer(property, provider.findValueSerializer(_valueType, property));\n             }\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         if (ser != _valueSerializer) {\n             return withValueSerializer(property, ser);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n                  *   serializer from value serializer; but, alas, there's no access\n                  *   to serializer factory at this point... \n                  */\n+                // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n+                ser = provider.findPrimaryPropertySerializer(t, _property);\n                 /* 09-Dec-2010, tatu: Turns out we must add special handling for\n                  *   cases where \"native\" (aka \"natural\") type is being serialized,\n                  *   using standard serializer\n                  */\n-                ser = provider.findTypedValueSerializer(t, false, _property);\n                 boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser);\n                 return withResolved(property, ser, forceTypeInformation);\n             }\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n+            ser = provider.handlePrimaryContextualization(ser, property);\n             return withResolved(property, ser, _forceTypeInformation);\n         }\n         return this;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n                 ser = provider.findValueSerializer(_valueType, property);\n             }\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         if (keySer == null) {\n             keySer = _keySerializer;\n         if (keySer == null) {\n             keySer = provider.findKeySerializer(_keyType, property);\n         } else {\n-            keySer = provider.handleContextualization(keySer, property);\n+            keySer = provider.handleSecondaryContextualization(keySer, property);\n         }\n         HashSet<String> ignored = this._ignoredEntries;\n         AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         // did we get a new map of serializers? If so, start using it\n         if (map != result.map) {\n             _dynamicValueSerializers = result.map;\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             JavaType type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         if (map != result.map) {\n             _dynamicValueSerializers = result.map;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n                 }\n             }\n         } else {\n-            ser = provider.handleContextualization(ser, property);\n+            ser = provider.handleSecondaryContextualization(ser, property);\n         }\n         return withResolved(property, vts, ser);\n     }\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         // did we get a new map of serializers? If so, start using it\n         if (map != result.map) {\n             _dynamicSerializers = result.map;\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             JavaType type, SerializerProvider provider) throws JsonMappingException\n     {\n-        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n         // did we get a new map of serializers? If so, start using it\n         if (map != result.map) {\n             _dynamicSerializers = result.map;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n         // First: if already got serializer to delegate to, contextualize it:\n         if (_delegateSerializer != null) {\n             if (_delegateSerializer instanceof ContextualSerializer) {\n-                JsonSerializer<?> ser = provider.handleContextualization(_delegateSerializer, property);\n+                JsonSerializer<?> ser = provider.handleSecondaryContextualization(_delegateSerializer, property);\n                 if (ser == _delegateSerializer) {\n                     return this;\n                 }", "timestamp": 1378445826, "metainfo": ""}