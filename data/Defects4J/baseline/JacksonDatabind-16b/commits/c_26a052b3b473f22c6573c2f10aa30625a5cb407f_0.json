{"sha": "26a052b3b473f22c6573c2f10aa30625a5cb407f", "log": "Trying to refactor property introspection to use PropertyName, to help with namespaced names handling (-> xml)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n     \n     public boolean hasNamespace() {\n         return _namespace != null;\n+    }\n+\n+    /**\n+     * Method that is basically equivalent of:\n+     *<pre>\n+     *   !hasSimpleName() && !hasNamespace();\n+     *</pre>\n+     * \n+     * @since 2.4\n+     */\n+    public boolean isEmpty() {\n+        return (_namespace == null) && (_simpleName.isEmpty());\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n     /**********************************************************\n      */\n     \n-    public void addField(AnnotatedField a, String name, boolean explName, boolean visible, boolean ignored) {\n+    public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n         _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);\n     }\n \n-    public void addCtor(AnnotatedParameter a, String name, boolean explName, boolean visible, boolean ignored) {\n+    public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n         _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, explName, visible, ignored);\n     }\n \n-    public void addGetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+    public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n         _getters = new Linked<AnnotatedMethod>(a, _getters, name, explName, visible, ignored);\n     }\n \n-    public void addSetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+    public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {\n         _setters = new Linked<AnnotatedMethod>(a, _setters, name, explName, visible, ignored);\n     }\n \n      */\n     @Deprecated\n     public void addField(AnnotatedField a, String name, boolean visible, boolean ignored) {\n-        addField(a, name, true, visible, ignored);\n-    }\n-\n+        addField(a, _propName(name), true, visible, ignored);\n+    }\n+\n+    @Deprecated\n+    public void addField(AnnotatedField a, String name, boolean explName, boolean visible, boolean ignored) {\n+        addField(a, _propName(name), explName, visible, ignored);\n+    }\n+    \n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n      */\n     @Deprecated\n     public void addCtor(AnnotatedParameter a, String name, boolean visible, boolean ignored) {\n-        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, true, visible, ignored);\n-    }\n-\n+        addCtor(a, _propName(name), true, visible, ignored);\n+    }\n+    @Deprecated\n+    public void addCtor(AnnotatedParameter a, String name, boolean explName, boolean visible, boolean ignored) {\n+        addCtor(a, _propName(name), explName, visible, ignored);\n+    }\n+    \n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n      */\n     @Deprecated\n     public void addGetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n-        _getters = new Linked<AnnotatedMethod>(a, _getters, name, true, visible, ignored);\n-    }\n-\n+        addGetter(a, _propName(name), true, visible, ignored);\n+    }\n+    @Deprecated\n+    public void addGetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+        addGetter(a, _propName(name), explName, visible, ignored);\n+    }\n+    \n     /**\n      * @deprecated Since 2.4 call method that takes additional 'explName' argument, to indicate\n      *   whether name of property was provided by annotation (and not derived from accessor name);\n      */\n     @Deprecated\n     public void addSetter(AnnotatedMethod a, String name, boolean visible, boolean ignored) {\n-        _setters = new Linked<AnnotatedMethod>(a, _setters, name, true, visible, ignored);\n+        addSetter(a, _propName(name), true, visible, ignored);\n+    }\n+    @Deprecated\n+    public void addSetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+        addSetter(a, _propName(name), explName, visible, ignored);\n+    }\n+\n+    private PropertyName _propName(String simple) {\n+        return PropertyName.construct(simple, null);\n     }\n     \n     /*\n     private <T> boolean _anyExplicits(Linked<T> n)\n     {\n         for (; n != null; n = n.next) {\n-            if (n.name != null && n.name.length() > 0) {\n+            if (n.name != null && n.name.hasSimpleName()) {\n                 return true;\n             }\n         }\n     }\n \n     /**\n+     * @since 2.4 Use {@link #findNewNames} instead\n+     */\n+    /*\n+    @Deprecated\n+    public String findNewName()\n+    {\n+        Map<String,POJOPropertyBuilder> r = findRenamed();\n+        if (r == null) {\n+            return null;\n+        }\n+        return r.entrySet().iterator().next().getKey();\n+    }\n+    */\n+    \n+    /**\n      * Method called to check whether property represented by this collector\n      * should be renamed from the implicit name; and also verify that there\n      * are no conflicting rename definitions.\n         renamed = findRenamed(_getters, renamed);\n         renamed = findRenamed(_setters, renamed);\n         renamed = findRenamed(_ctorParameters, renamed);\n-        return (renamed == null) ? null : renamed.name;\n+        return (renamed == null) ? null : renamed.name.getSimpleName();\n     }\n \n     private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node,\n             if (!node.isNameExplicit) {\n                 continue;\n             }\n-            String name = node.name;\n+            PropertyName name = node.name;\n             // different from default name?\n             /* 14-Mar-2014, tatu: As per [#369], Must match local name... but,\n              *   shouldn't really exclude namespace. Not sure what's the best\n              *   fix but for now, let's not worry about that.\n              */\n-            if (name.equals(_name.getSimpleName())) { // nope, skip\n+            if (name.equals(_name)) { // nope, skip\n                 continue;\n             }\n             if (renamed == null) {\n     /**********************************************************\n      */\n \n-    private interface WithMember<T>\n-    {\n+    private interface WithMember<T> {\n         public T withMember(AnnotatedMember member);\n     }\n     \n         public final T value;\n         public final Linked<T> next;\n \n-        public final String name;\n+        public final PropertyName name;\n         public final boolean isNameExplicit;\n         public final boolean isVisible;\n         public final boolean isMarkedIgnored;\n         \n         public Linked(T v, Linked<T> n,\n-                String name, boolean explName, boolean visible, boolean ignored)\n+                PropertyName name, boolean explName, boolean visible, boolean ignored)\n         {\n             value = v;\n             next = n;\n             // ensure that we'll never have missing names\n-            this.name = (name == null || name.length() == 0) ? null : name;\n+            this.name = (name == null || !name.hasSimpleName()) ? null : name;\n             \n             isNameExplicit = explName;\n             isVisible = visible;\n             return new Linked<T>(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);\n         }\n         \n-        public Linked<T> withoutIgnored()\n-        {\n+        public Linked<T> withoutIgnored() {\n             if (isMarkedIgnored) {\n                 return (next == null) ? null : next.withoutIgnored();\n             }\n             return this;\n         }\n         \n-        public Linked<T> withoutNonVisible()\n-        {\n+        public Linked<T> withoutNonVisible() {\n             Linked<T> newNext = (next == null) ? null : next.withoutNonVisible();\n             return isVisible ? withNext(newNext) : newNext;\n         }\n          * Method called to append given node(s) at the end of this\n          * node chain.\n          */\n-        private Linked<T> append(Linked<T> appendable) \n-        {\n+        private Linked<T> append(Linked<T> appendable) {\n             if (next == null) {\n                 return withNext(appendable);\n             }\n             return withNext(next.append(appendable));\n         }\n-        \n-        public Linked<T> trimByVisibility()\n-        {\n+\n+        public Linked<T> trimByVisibility() {\n             if (next == null) {\n                 return this;\n             }", "timestamp": 1396237736, "metainfo": ""}