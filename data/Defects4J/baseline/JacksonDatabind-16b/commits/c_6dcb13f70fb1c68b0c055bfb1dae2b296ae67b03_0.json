{"sha": "6dcb13f70fb1c68b0c055bfb1dae2b296ae67b03", "log": "Streamlining `AnnotatedClass` slightly, trying to figure out #771", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n package com.fasterxml.jackson.databind.introspect;\n \n import java.lang.annotation.Annotation;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n import java.lang.reflect.*;\n import java.util.*;\n \n \n     protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n     {\n-        AnnotationMap annMap = new AnnotationMap();\n-        _addAnnotationsIfNotPresent(annMap, anns);\n-        return annMap;\n+        return _addAnnotationsIfNotPresent(new AnnotationMap(), anns);\n     }\n     \n     /* Helper method used to add all applicable annotations from given set.\n      * Takes into account possible \"annotation bundles\" (meta-annotations to\n      * include instead of main-level annotation)\n      */\n-    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n+    private AnnotationMap _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n     {\n         if (anns != null) {\n-            List<Annotation[]> bundles = null;\n+            List<Annotation> fromBundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n                 // note: we will NOT filter out non-Jackson anns any more\n                 boolean wasNotPresent = result.addIfNotPresent(ann);\n                 if (wasNotPresent && _isAnnotationBundle(ann)) {\n-                    if (bundles == null) {\n-                        bundles = new LinkedList<Annotation[]>();\n-                    }\n-                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                }\n-            }\n-            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n-                for (Annotation[] annotations : bundles) {\n-                    _addAnnotationsIfNotPresent(result, annotations);\n-                }\n-            }\n-        }\n-    }\n-\n+                    fromBundles = _addFromBundle(ann, fromBundles);\n+                }\n+            }\n+            if (fromBundles != null) { // and secondarily handle bundles, if any found: precedence important\n+                _addAnnotationsIfNotPresent(result, fromBundles.toArray(new Annotation[fromBundles.size()]));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private List<Annotation> _addFromBundle(Annotation bundle, List<Annotation> result)\n+    {\n+        for (Annotation a : bundle.annotationType().getDeclaredAnnotations()) {\n+            // minor optimization: by-pass 2 common JDK meta-annotations\n+            if ((a instanceof Target) || (a instanceof Retention)) {\n+                continue;\n+            }\n+            if (result == null) {\n+                result = new ArrayList<Annotation>();\n+            }\n+            result.add(a);\n+        }\n+        return result;\n+    }\n+    \n     private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n     {\n         if (anns != null) {\n-            List<Annotation[]> bundles = null;\n+            List<Annotation> fromBundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                // note: we will NOT filter out non-Jackson anns any more\n                 boolean wasNotPresent = target.addIfNotPresent(ann);\n                 if (wasNotPresent && _isAnnotationBundle(ann)) {\n-                    if (bundles == null) {\n-                        bundles = new LinkedList<Annotation[]>();\n-                    }\n-                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                }\n-            }\n-            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n-                for (Annotation[] annotations : bundles) {\n-                    _addAnnotationsIfNotPresent(target, annotations);\n-                }\n+                    fromBundles = _addFromBundle(ann, fromBundles);\n+                }\n+            }\n+            if (fromBundles != null) { // and secondarily handle bundles, if any found: precedence important\n+                _addAnnotationsIfNotPresent(target, fromBundles.toArray(new Annotation[fromBundles.size()]));\n             }\n         }\n     }\n     private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n     {\n         if (anns != null) {\n-            List<Annotation[]> bundles = null;\n+            List<Annotation> fromBundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                // note: we will NOT filter out non-Jackson anns any more\n                 boolean wasModified = target.addOrOverride(ann);\n                 if (wasModified && _isAnnotationBundle(ann)) {\n-                    if (bundles == null) {\n-                        bundles = new LinkedList<Annotation[]>();\n-                    }\n-                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                }\n-            }\n-            if (bundles != null) { // and then bundles, if any: important for precedence\n-                for (Annotation[] annotations : bundles) {\n-                    _addOrOverrideAnnotations(target, annotations);\n-                }\n+                    fromBundles = _addFromBundle(ann, fromBundles);\n+                }\n+            }\n+            if (fromBundles != null) { // and then bundles, if any: important for precedence\n+                _addOrOverrideAnnotations(target, fromBundles.toArray(new Annotation[fromBundles.size()]));\n             }\n         }\n     }\n         _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n     }\n \n-   private final boolean _isAnnotationBundle(Annotation ann) {\n-       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n-   }\n-   \n+    private final boolean _isAnnotationBundle(Annotation ann) {\n+        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Other methods\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/MixinsWithBundlesTest.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.lang.annotation.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+// for [databind#771]\n+public class MixinsWithBundlesTest extends BaseMapTest\n+{\n+    @Target(value={ ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD })\n+    @Retention(value=RetentionPolicy.RUNTIME)\n+    @JacksonAnnotationsInside\n+    @JsonProperty(\"bar\")\n+    public @interface ExposeStuff {\n+\n+    }\n+\n+    public abstract class FooMixin {\n+        @ExposeStuff\n+        public abstract String getStuff();\n+    }\n+\n+    public static class Foo {\n+\n+        private String stuff;\n+\n+        Foo(String stuff) {\n+            this.stuff = stuff;\n+        }\n+\n+        public String getStuff() {\n+            return stuff;\n+        }\n+    }    \n+    public void testMixinWithBundles() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n+        String result = mapper.writeValueAsString(new Foo(\"result\"));\n+        assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n+    }\n+}", "timestamp": 1430112297, "metainfo": ""}