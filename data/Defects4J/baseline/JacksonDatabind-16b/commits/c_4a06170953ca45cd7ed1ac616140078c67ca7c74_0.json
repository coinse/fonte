{"sha": "4a06170953ca45cd7ed1ac616140078c67ca7c74", "log": "Fixes to sequence writing; changed naming to be more consistent with 'readValues()' (hence, 'writeValues()'), added first tests", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     /**********************************************************\n      */\n \n-    public SequenceWriter createSequenceWriter(File out) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Target file to write value sequence to.\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(File out) throws IOException {\n         return _newSequenceWriter(false,\n                 _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n     }\n \n-    public SequenceWriter createSequenceWriter(JsonGenerator gen) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure that all content gets flushed by\n+     * the generator. However, since a {@link JsonGenerator} is explicitly passed,\n+     * it will NOT be closed when {@link SequenceWriter#close()} is called.\n+     *\n+     * @param gen Low-level generator caller has already constructed that will\n+     *   be used for actual writing of token stream.\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(JsonGenerator gen) throws IOException {\n         return _newSequenceWriter(false, _configureGenerator(gen), false);\n     }\n \n-    public SequenceWriter createSequenceWriter(Writer out) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Target writer to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(Writer out) throws IOException {\n         return _newSequenceWriter(false,\n                 _generatorFactory.createGenerator(out), true);\n     }\n \n-    public SequenceWriter createSequenceWriter(OutputStream out) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Physical output stream to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(OutputStream out) throws IOException {\n         return _newSequenceWriter(false,\n                 _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n     }\n-    \n-    public SequenceWriter createArrayWriter(File out) throws IOException {\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out File to write token stream to\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(File out) throws IOException {\n         return _newSequenceWriter(true,\n                 _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n     }\n \n-    public SequenceWriter createArrayWriter(JsonGenerator gen) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure that all content gets flushed by\n+     * the generator. However, since a {@link JsonGenerator} is explicitly passed,\n+     * it will NOT be closed when {@link SequenceWriter#close()} is called.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param gen Underlying generator to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(JsonGenerator gen) throws IOException {\n         return _newSequenceWriter(true, gen, false);\n     }\n \n-    public SequenceWriter createArrayWriter(Writer out) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out Writer to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(Writer out) throws IOException {\n         return _newSequenceWriter(true, _generatorFactory.createGenerator(out), true);\n     }\n \n-    public SequenceWriter createArrayWriter(OutputStream out) throws IOException {\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out Physical output stream to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(OutputStream out) throws IOException {\n         return _newSequenceWriter(true,\n                 _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.util.Collection;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n  * @since 2.5\n  */\n public class SequenceWriter\n-    implements Versioned, java.io.Closeable\n+    implements Versioned, java.io.Closeable, java.io.Flushable\n {\n     /*\n     /**********************************************************\n      * to write. If root type was specified for {@link ObjectWriter},\n      * value must be of compatible type (same or subtype).\n      */\n-    public void writeValue(Object value) throws IOException\n+    public SequenceWriter write(Object value) throws IOException\n     {\n         if (value == null) {\n             _provider.serializeValue(_generator, null);\n-            return;\n+            return this;\n         }\n         \n         if (_cfgCloseCloseable && (value instanceof Closeable)) {\n-            _writeCloseableValue(value);\n-            return;\n+            return _writeCloseableValue(value);\n         }\n         JsonSerializer<Object> ser = _rootSerializer;\n         if (ser == null) {\n         if (_cfgFlush) {\n             _generator.flush();\n         }\n+        return this;\n     }\n \n     /**\n      * If root type was specified for {@link ObjectWriter},\n      * value must be of compatible type (same or subtype).\n      */\n-    public void writeValue(Object value, JavaType type) throws IOException\n+    public SequenceWriter write(Object value, JavaType type) throws IOException\n     {\n         if (value == null) {\n             _provider.serializeValue(_generator, null);\n-            return;\n+            return this;\n         }\n         \n         if (_cfgCloseCloseable && (value instanceof Closeable)) {\n-            _writeCloseableValue(value, type);\n-            return;\n+            return _writeCloseableValue(value, type);\n         }\n         /* 15-Dec-2014, tatu: I wonder if this could be come problematic. It shouldn't\n          *   really, since trying to use differently paramterized types in a sequence\n         if (_cfgFlush) {\n             _generator.flush();\n         }\n-    }\n-    \n+        return this;\n+    }\n+\n+    public SequenceWriter writeAll(Object[] value) throws IOException\n+    {\n+        for (int i = 0, len = value.length; i < len; ++i) {\n+            write(value[i]);\n+        }\n+        return this;\n+    }\n+\n+    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException\n+    {\n+        for (Object value : container) {\n+            write(value);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        if (!_closed) {\n+            _generator.flush();\n+        }\n+    }\n+\n     @Override\n     public void close() throws IOException\n     {\n                 _openArray = false;\n                 _generator.writeEndArray();\n             }\n+            if (_closeGenerator) {\n+                _generator.close();\n+            }\n         }\n     }\n \n     /**********************************************************\n      */\n \n-    protected void _writeCloseableValue(Object value) throws IOException\n+    protected SequenceWriter _writeCloseableValue(Object value) throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n                 } catch (IOException ioe) { }\n             }\n         }\n-    }\n-\n-    protected void _writeCloseableValue(Object value, JavaType type) throws IOException\n+        return this;\n+    }\n+\n+    protected SequenceWriter _writeCloseableValue(Object value, JavaType type) throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n             // 15-Dec-2014, tatu: As per above, could be problem that we do not pass generic type\n-            JsonSerializer<Object >ser = _dynamicSerializers.serializerFor(type.getRawClass());\n+            JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type.getRawClass());\n             if (ser == null) {\n                 ser = _findAndAddDynamic(type);\n             }\n                 } catch (IOException ioe) { }\n             }\n         }\n+        return this;\n     }\n \n     protected final JsonSerializer<Object> _findAndAddDynamic(Class<?> type) throws JsonMappingException\n     {\n         PropertySerializerMap.SerializerAndMapResult result\n-            = _dynamicSerializers.findAndAddPrimarySerializer(type, _provider, null);\n+            = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n         _dynamicSerializers = result.map;\n         return result.serializer;\n     }\n     protected final JsonSerializer<Object> _findAndAddDynamic(JavaType type) throws JsonMappingException\n     {\n         PropertySerializerMap.SerializerAndMapResult result\n-            = _dynamicSerializers.findAndAddPrimarySerializer(type, _provider, null);\n+            = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n         _dynamicSerializers = result.map;\n         return result.serializer;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n public abstract class PropertySerializerMap\n {\n     /**\n-     * Configuration setting that determines whether we are caching\n-     * \"root value\" serializers (true), or \"property\" serializers (false);\n-     * former will have embedded {@link TypeSerializer}, whereas latter not.\n-     *\n-     * @since 2.5\n-     */\n-    protected final boolean _findRootSerializers;\n-\n-    /**\n      * Configuration setting that determines what happens when maximum\n      * size (currently 8) is reached: if true, will \"start from beginning\";\n      * if false, will simply stop adding new entries.\n     /**\n      * @since 2.5\n      */\n-    protected PropertySerializerMap(boolean rootSerializers, boolean resetWhenFull) {\n-        _findRootSerializers = rootSerializers;\n+    protected PropertySerializerMap(boolean resetWhenFull) {\n         _resetWhenFull = resetWhenFull;\n     }\n \n     protected PropertySerializerMap(PropertySerializerMap base) {\n-        _findRootSerializers = base._findRootSerializers;\n         _resetWhenFull = base._resetWhenFull;\n     }\n-    \n+\n     /**\n      * Main lookup method. Takes a \"raw\" type since usage is always from\n      * place where parameterization is fixed such that there can not be\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n \n+    /**\n+     * Method called if initial lookup fails, when looking for a root value\n+     * serializer: one that is not directly attached to a property, but needs to\n+     * have {@link com.fasterxml.jackson.databind.jsontype.TypeSerializer} wrapped\n+     * around it. Will both find the serializer\n+     * and construct new map instance if warranted, and return both.\n+     * \n+     * @since 2.5\n+     * \n+     * @throws JsonMappingException \n+     */\n+    public final SerializerAndMapResult findAndAddRootValueSerializer(Class<?> type,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findTypedValueSerializer(type, false, null);\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult findAndAddRootValueSerializer(JavaType type,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findTypedValueSerializer(type, false, null);\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+    \n     public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n \n     /**\n     private final static class Empty extends PropertySerializerMap\n     {\n         // No root serializers; do not reset when full\n-        public final static Empty FOR_PROPERTIES = new Empty(false, false);\n+        public final static Empty FOR_PROPERTIES = new Empty(false);\n \n         // Yes, root serializers; do reset when full\n-        public final static Empty FOR_ROOT_VALUES = new Empty(true, true);\n-\n-        protected Empty(boolean rootSerializers, boolean resetWhenFull) {\n-            super(rootSerializers, resetWhenFull);\n+        public final static Empty FOR_ROOT_VALUES = new Empty(true);\n+\n+        protected Empty(boolean resetWhenFull) {\n+            super(resetWhenFull);\n         }\n         \n         @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/seq/ReadValuesTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ReadValuesTest.java\n @SuppressWarnings(\"resource\")\n public class ReadValuesTest extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     static class Bean {\n         public int a;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java\n package com.fasterxml.jackson.databind.seq;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.*;\n \n public class SequenceWriterTest extends BaseMapTest\n {\n-    // !!! TBI\n+    static class Bean {\n+        public int a;\n \n-    public void testJustJoking() { }\n+        public Bean(int value) { a = value; }\n+        \n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = \"type\")\n+    static class PolyBase {\n+    }\n+\n+    @JsonTypeName(\"A\")\n+    static class ImplA extends PolyBase {\n+        public int value;\n+        \n+        public ImplA(int v) { value = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, simple writes\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    {\n+        MAPPER.getFactory().setRootValueSeparator(\"\\n\");\n+    }\n+    private final ObjectWriter WRITER = MAPPER.writer();\n+\n+    public void testSimpleNonArray() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValues(strw);\n+        w.write(new Bean(13))\n+        .write(new Bean(-6))\n+        .writeAll(new Bean[] { new Bean(3), new Bean(1) });\n+        w.close();\n+        assertEquals(aposToQuotes(\"{'a':13}\\n{'a':-6}\\n{'a':3}\\n{'a':1}\"),\n+                strw.toString());\n+    }\n+\n+    public void testSimpleArray() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER.writeValuesAsArray(strw);\n+        w.write(new Bean(1))\n+        .write(new Bean(2))\n+        .writeAll(new Bean[] { new Bean(-7), new Bean(2) });\n+        w.close();\n+        assertEquals(aposToQuotes(\"[{'a':1},{'a':2},{'a':-7},{'a':2}]\"),\n+                strw.toString());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, polymorphic writes\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testPolymorphicNonArrayWithoutType() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValues(strw);\n+        w.write(new ImplA(3))\n+            .write(new ImplA(4))\n+            .close();\n+        assertEquals(aposToQuotes(\"{'type':'A','value':3}\\n{'type':'A','value':4}\"),\n+                strw.toString());\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testPolymorphicArrayWithoutType() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValuesAsArray(strw);\n+        w.write(new ImplA(-1))\n+            .write(new ImplA(6))\n+            .close();\n+        assertEquals(aposToQuotes(\"[{'type':'A','value':-1},{'type':'A','value':6}]\"),\n+                strw.toString());\n+    }\n }", "timestamp": 1418751297, "metainfo": ""}