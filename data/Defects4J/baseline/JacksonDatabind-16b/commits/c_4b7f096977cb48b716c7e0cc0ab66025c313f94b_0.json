{"sha": "4b7f096977cb48b716c7e0cc0ab66025c313f94b", "log": "Fixes wrt [Issue-11]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     {\n         try {\n             // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n-            if (n.getClass().isAssignableFrom(valueType)) {\n+            // ... one caveat; while everything is Object.class, let's not take shortcut\n+            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                 return (T) n;\n             }\n             return readValue(treeAsTokens(n), valueType);\n         // sanity check for null first:\n         if (fromValue == null) return null;\n         // also, as per [Issue-11], consider case for simple cast\n-        if (fromValue.getClass().isAssignableFrom(toValueType)) {\n+        // ... one caveat; while everything is Object.class, let's not take shortcut\n+        if (toValueType != Object.class && toValueType.isAssignableFrom(fromValue.getClass())) {\n             return (T) fromValue;\n         }\n         return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n         // sanity check for null first:\n         if (fromValue == null) return null;\n         // also, as per [Issue-11], consider case for simple cast\n-        if (fromValue.getClass().isAssignableFrom(toValueType.getRawClass())) {\n+        /* But with caveats: one is that while everything is Object.class, we don't\n+         * want to \"optimize\" that out; and the other is that we also do not want\n+         * to lose conversions of generic types.\n+         */\n+        Class<?> targetType = toValueType.getRawClass();\n+        if (targetType != Object.class\n+                && !toValueType.hasGenericTypes()\n+                && targetType.isAssignableFrom(fromValue.getClass())) {\n             return (T) fromValue;\n         }\n         return (T) _convert(fromValue, toValueType);\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n package com.fasterxml.jackson.databind.node;\n \n import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n \n import static org.junit.Assert.*;\n \n \n     static class Leaf {\n         public int value;\n+\n+        public Leaf() { }\n+        public Leaf(int v) { value = v; }\n     }\n     \n     // MixIn for [JACKSON-554]\n     /* Unit tests\n     /**********************************************************\n      */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testAsInt() throws Exception\n     {\n      */\n     public void testIssue709() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         byte[] inputData = new byte[] { 1, 2, 3 };\n-        ObjectNode node = mapper.createObjectNode();\n+        ObjectNode node = MAPPER.createObjectNode();\n         node.put(\"data\", inputData);\n-        Issue709Bean result = mapper.treeToValue(node, Issue709Bean.class);\n-        String json = mapper.writeValueAsString(node);\n-        Issue709Bean resultFromString = mapper.readValue(json, Issue709Bean.class);\n-        Issue709Bean resultFromConvert = mapper.convertValue(node, Issue709Bean.class);\n+        Issue709Bean result = MAPPER.treeToValue(node, Issue709Bean.class);\n+        String json = MAPPER.writeValueAsString(node);\n+        Issue709Bean resultFromString = MAPPER.readValue(json, Issue709Bean.class);\n+        Issue709Bean resultFromConvert = MAPPER.convertValue(node, Issue709Bean.class);\n         \n         // all methods should work equally well:\n         Assert.assertArrayEquals(inputData, resultFromString.data);\n \n     public void testEmbeddedObject() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        TokenBuffer buf = new TokenBuffer(mapper);\n+        TokenBuffer buf = new TokenBuffer(MAPPER);\n         buf.writeObject(new byte[3]);\n-        JsonNode node = mapper.readTree(buf.asParser());\n+        JsonNode node = MAPPER.readTree(buf.asParser());\n         assertTrue(node.isBinary());\n         byte[] data = node.binaryValue();\n         assertNotNull(data);\n \n     public void testEmbeddedObjectInArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        TokenBuffer buf = new TokenBuffer(mapper);\n+        TokenBuffer buf = new TokenBuffer(MAPPER);\n         buf.writeStartArray();\n         buf.writeObject(MARKER);\n         buf.writeEndArray();\n-        JsonNode node = mapper.readTree(buf.asParser());\n+        JsonNode node = MAPPER.readTree(buf.asParser());\n         assertTrue(node.isArray());\n         assertEquals(1, node.size());\n         JsonNode n = node.get(0);\n \n     public void testEmbeddedObjectInObject() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        TokenBuffer buf = new TokenBuffer(mapper);\n+        TokenBuffer buf = new TokenBuffer(MAPPER);\n         buf.writeStartObject();\n         buf.writeFieldName(\"pojo\");\n         buf.writeObject(MARKER);\n         buf.writeEndObject();\n-        JsonNode node = mapper.readTree(buf.asParser());\n+        JsonNode node = MAPPER.readTree(buf.asParser());\n         assertTrue(node.isObject());\n         assertEquals(1, node.size());\n         JsonNode n = node.get(\"pojo\");\n         assertTrue(n.isPojo());\n         assertSame(MARKER, ((POJONode) n).getPojo());\n     }\n+\n+    /**\n+     * Need to test \"shortcuts\" introduced by [Issue-11]\n+     */\n+    public void testIssue11() throws Exception\n+    {\n+        // First the expected use case, Node specification\n+        ObjectNode root = MAPPER.createObjectNode();\n+        JsonNode n = root;\n+        ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class);\n+        assertSame(root, ob2);\n+\n+        JsonNode n2 = MAPPER.convertValue(n, JsonNode.class);\n+        assertSame(root, n2);\n+        \n+        // then some other no-op conversions\n+        String STR = \"test\";\n+        CharSequence seq = MAPPER.convertValue(STR, CharSequence.class);\n+        assertSame(STR, seq);\n+\n+        // and then something that should NOT use short-cut\n+        Leaf l = new Leaf(13);\n+        Map<?,?> m = MAPPER.convertValue(l, Map.class);\n+        assertNotNull(m);\n+        assertEquals(1, m.size());\n+        assertEquals(Integer.valueOf(13), m.get(\"value\"));\n+\n+        // and reverse too\n+        Leaf l2 = MAPPER.convertValue(m, Leaf.class);\n+        assertEquals(13, l2.value);\n+\n+        // also; ok to use \"untyped\" (Object):\n+        Object ob = MAPPER.convertValue(l, Object.class);\n+        assertNotNull(ob);\n+        assertEquals(LinkedHashMap.class, ob.getClass());\n+    }\n }\n ", "timestamp": 1341547970, "metainfo": ""}